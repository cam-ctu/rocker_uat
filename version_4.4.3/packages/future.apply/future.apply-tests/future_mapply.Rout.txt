
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:59:30.735] plan(): Setting new future strategy stack:
[10:59:30.735] List of future strategies:
[10:59:30.735] 1. sequential:
[10:59:30.735]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:30.735]    - tweaked: FALSE
[10:59:30.735]    - call: future::plan("sequential")
[10:59:30.748] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[10:59:30.762] plan(): Setting new future strategy stack:
[10:59:30.762] List of future strategies:
[10:59:30.762] 1. sequential:
[10:59:30.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:30.762]    - tweaked: FALSE
[10:59:30.762]    - call: plan(sequential)
[10:59:30.773] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[10:59:30.774] future_mapply() ...
[10:59:30.774] Generating random seeds ...
[10:59:30.774] Generating random seed streams for 4 elements ...
[10:59:30.775] Generating random seed streams for 4 elements ... DONE
[10:59:30.775] Generating random seeds ... DONE
[10:59:30.775] Will set RNG state on exit: 10407, -1869012937, 894550048, -1027017971, 1041286842, -199511037, 1047550554
[10:59:30.775] Number of chunks: 1
[10:59:30.775] getGlobalsAndPackagesXApply() ...
[10:59:30.775]  - future.globals: TRUE
[10:59:30.776] getGlobalsAndPackages() ...
[10:59:30.776] Searching for globals...
[10:59:30.780] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:59:30.781] Searching for globals ... DONE
[10:59:30.781] Resolving globals: FALSE
[10:59:30.782] The total size of the 1 globals is 501 bytes (501 bytes)
[10:59:30.782] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:59:30.782] - globals: [1] ‘FUN’
[10:59:30.782] - packages: [1] ‘stats’
[10:59:30.782] getGlobalsAndPackages() ... DONE
[10:59:30.783]  - globals found/used: [n=1] ‘FUN’
[10:59:30.783]  - needed namespaces: [n=1] ‘stats’
[10:59:30.783] Finding globals ... DONE
[10:59:30.783] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:30.783] List of 2
[10:59:30.783]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:59:30.783]  $ MoreArgs     :List of 1
[10:59:30.783]   ..$ min: num 1
[10:59:30.783]  - attr(*, "where")=List of 2
[10:59:30.783]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:30.783]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:30.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:30.783]  - attr(*, "resolved")= logi FALSE
[10:59:30.783]  - attr(*, "total_size")= num NA
[10:59:30.789] Packages to be attached in all futures: [n=1] ‘stats’
[10:59:30.789] getGlobalsAndPackagesXApply() ... DONE
[10:59:30.790] Number of futures (= number of chunks): 1
[10:59:30.790] Launching 1 futures (chunks) ...
[10:59:30.790] Chunk #1 of 1 ...
[10:59:30.790]  - Finding globals in '...' for chunk #1 ...
[10:59:30.790] getGlobalsAndPackages() ...
[10:59:30.790] Searching for globals...
[10:59:30.791] 
[10:59:30.791] Searching for globals ... DONE
[10:59:30.791] - globals: [0] <none>
[10:59:30.791] getGlobalsAndPackages() ... DONE
[10:59:30.791]    + additional globals found: [n=0] 
[10:59:30.791]    + additional namespaces needed: [n=0] 
[10:59:30.791]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:30.791]  - seeds: [4] <seeds>
[10:59:30.791]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.792] getGlobalsAndPackages() ...
[10:59:30.792] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.792] Resolving globals: FALSE
[10:59:30.792] The total size of the 5 globals is 990 bytes (990 bytes)
[10:59:30.793] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 990 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (196 bytes of class ‘list’) and ‘...future.seeds_ii’ (175 bytes of class ‘list’)
[10:59:30.793] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.793] - packages: [1] ‘stats’
[10:59:30.793] getGlobalsAndPackages() ... DONE
[10:59:30.794] run() for ‘Future’ ...
[10:59:30.794] - state: ‘created’
[10:59:30.794] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:30.794] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:30.794] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:30.794]   - Field: ‘label’
[10:59:30.794]   - Field: ‘local’
[10:59:30.795]   - Field: ‘owner’
[10:59:30.795]   - Field: ‘envir’
[10:59:30.795]   - Field: ‘packages’
[10:59:30.795]   - Field: ‘gc’
[10:59:30.795]   - Field: ‘conditions’
[10:59:30.795]   - Field: ‘expr’
[10:59:30.795]   - Field: ‘uuid’
[10:59:30.795]   - Field: ‘seed’
[10:59:30.795]   - Field: ‘version’
[10:59:30.795]   - Field: ‘result’
[10:59:30.795]   - Field: ‘asynchronous’
[10:59:30.795]   - Field: ‘calls’
[10:59:30.796]   - Field: ‘globals’
[10:59:30.796]   - Field: ‘stdout’
[10:59:30.796]   - Field: ‘earlySignal’
[10:59:30.796]   - Field: ‘lazy’
[10:59:30.796]   - Field: ‘state’
[10:59:30.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:30.796] - Launch lazy future ...
[10:59:30.797] Packages needed by the future expression (n = 1): ‘stats’
[10:59:30.797] Packages needed by future strategies (n = 0): <none>
[10:59:30.797] {
[10:59:30.797]     {
[10:59:30.797]         {
[10:59:30.797]             ...future.startTime <- base::Sys.time()
[10:59:30.797]             {
[10:59:30.797]                 {
[10:59:30.797]                   {
[10:59:30.797]                     {
[10:59:30.797]                       base::local({
[10:59:30.797]                         has_future <- base::requireNamespace("future", 
[10:59:30.797]                           quietly = TRUE)
[10:59:30.797]                         if (has_future) {
[10:59:30.797]                           ns <- base::getNamespace("future")
[10:59:30.797]                           version <- ns[[".package"]][["version"]]
[10:59:30.797]                           if (is.null(version)) 
[10:59:30.797]                             version <- utils::packageVersion("future")
[10:59:30.797]                         }
[10:59:30.797]                         else {
[10:59:30.797]                           version <- NULL
[10:59:30.797]                         }
[10:59:30.797]                         if (!has_future || version < "1.8.0") {
[10:59:30.797]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:30.797]                             "", base::R.version$version.string), 
[10:59:30.797]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:30.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:30.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:30.797]                               "release", "version")], collapse = " "), 
[10:59:30.797]                             hostname = base::Sys.info()[["nodename"]])
[10:59:30.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:30.797]                             info)
[10:59:30.797]                           info <- base::paste(info, collapse = "; ")
[10:59:30.797]                           if (!has_future) {
[10:59:30.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:30.797]                               info)
[10:59:30.797]                           }
[10:59:30.797]                           else {
[10:59:30.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:30.797]                               info, version)
[10:59:30.797]                           }
[10:59:30.797]                           base::stop(msg)
[10:59:30.797]                         }
[10:59:30.797]                       })
[10:59:30.797]                     }
[10:59:30.797]                     base::local({
[10:59:30.797]                       for (pkg in "stats") {
[10:59:30.797]                         base::loadNamespace(pkg)
[10:59:30.797]                         base::library(pkg, character.only = TRUE)
[10:59:30.797]                       }
[10:59:30.797]                     })
[10:59:30.797]                   }
[10:59:30.797]                   ...future.strategy.old <- future::plan("list")
[10:59:30.797]                   options(future.plan = NULL)
[10:59:30.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:30.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:30.797]                 }
[10:59:30.797]                 ...future.workdir <- getwd()
[10:59:30.797]             }
[10:59:30.797]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:30.797]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:30.797]         }
[10:59:30.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:30.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:30.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:30.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:30.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:30.797]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:30.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:30.797]             base::names(...future.oldOptions))
[10:59:30.797]     }
[10:59:30.797]     if (FALSE) {
[10:59:30.797]     }
[10:59:30.797]     else {
[10:59:30.797]         if (TRUE) {
[10:59:30.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:30.797]                 open = "w")
[10:59:30.797]         }
[10:59:30.797]         else {
[10:59:30.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:30.797]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:30.797]         }
[10:59:30.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:30.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:30.797]             base::sink(type = "output", split = FALSE)
[10:59:30.797]             base::close(...future.stdout)
[10:59:30.797]         }, add = TRUE)
[10:59:30.797]     }
[10:59:30.797]     ...future.frame <- base::sys.nframe()
[10:59:30.797]     ...future.conditions <- base::list()
[10:59:30.797]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:30.797]     if (FALSE) {
[10:59:30.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:30.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:30.797]     }
[10:59:30.797]     ...future.result <- base::tryCatch({
[10:59:30.797]         base::withCallingHandlers({
[10:59:30.797]             ...future.value <- base::withVisible(base::local({
[10:59:30.797]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:30.797]                 if (!identical(...future.globals.maxSize.org, 
[10:59:30.797]                   ...future.globals.maxSize)) {
[10:59:30.797]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:30.797]                   on.exit(options(oopts), add = TRUE)
[10:59:30.797]                 }
[10:59:30.797]                 {
[10:59:30.797]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:30.797]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:30.797]                       envir = globalenv(), inherits = FALSE)
[10:59:30.797]                     ...future.FUN(...)
[10:59:30.797]                   }
[10:59:30.797]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:30.797]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:30.797]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:30.797]                     USE.NAMES = FALSE)
[10:59:30.797]                   do.call(mapply, args = args)
[10:59:30.797]                 }
[10:59:30.797]             }))
[10:59:30.797]             future::FutureResult(value = ...future.value$value, 
[10:59:30.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:30.797]                   ...future.rng), globalenv = if (FALSE) 
[10:59:30.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:30.797]                     ...future.globalenv.names))
[10:59:30.797]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:30.797]         }, condition = base::local({
[10:59:30.797]             c <- base::c
[10:59:30.797]             inherits <- base::inherits
[10:59:30.797]             invokeRestart <- base::invokeRestart
[10:59:30.797]             length <- base::length
[10:59:30.797]             list <- base::list
[10:59:30.797]             seq.int <- base::seq.int
[10:59:30.797]             signalCondition <- base::signalCondition
[10:59:30.797]             sys.calls <- base::sys.calls
[10:59:30.797]             `[[` <- base::`[[`
[10:59:30.797]             `+` <- base::`+`
[10:59:30.797]             `<<-` <- base::`<<-`
[10:59:30.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:30.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:30.797]                   3L)]
[10:59:30.797]             }
[10:59:30.797]             function(cond) {
[10:59:30.797]                 is_error <- inherits(cond, "error")
[10:59:30.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:30.797]                   NULL)
[10:59:30.797]                 if (is_error) {
[10:59:30.797]                   sessionInformation <- function() {
[10:59:30.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:30.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:30.797]                       search = base::search(), system = base::Sys.info())
[10:59:30.797]                   }
[10:59:30.797]                   ...future.conditions[[length(...future.conditions) + 
[10:59:30.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:30.797]                     cond$call), session = sessionInformation(), 
[10:59:30.797]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:30.797]                   signalCondition(cond)
[10:59:30.797]                 }
[10:59:30.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:30.797]                 "immediateCondition"))) {
[10:59:30.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:30.797]                   ...future.conditions[[length(...future.conditions) + 
[10:59:30.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:30.797]                   if (TRUE && !signal) {
[10:59:30.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:30.797]                     {
[10:59:30.797]                       inherits <- base::inherits
[10:59:30.797]                       invokeRestart <- base::invokeRestart
[10:59:30.797]                       is.null <- base::is.null
[10:59:30.797]                       muffled <- FALSE
[10:59:30.797]                       if (inherits(cond, "message")) {
[10:59:30.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:30.797]                         if (muffled) 
[10:59:30.797]                           invokeRestart("muffleMessage")
[10:59:30.797]                       }
[10:59:30.797]                       else if (inherits(cond, "warning")) {
[10:59:30.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:30.797]                         if (muffled) 
[10:59:30.797]                           invokeRestart("muffleWarning")
[10:59:30.797]                       }
[10:59:30.797]                       else if (inherits(cond, "condition")) {
[10:59:30.797]                         if (!is.null(pattern)) {
[10:59:30.797]                           computeRestarts <- base::computeRestarts
[10:59:30.797]                           grepl <- base::grepl
[10:59:30.797]                           restarts <- computeRestarts(cond)
[10:59:30.797]                           for (restart in restarts) {
[10:59:30.797]                             name <- restart$name
[10:59:30.797]                             if (is.null(name)) 
[10:59:30.797]                               next
[10:59:30.797]                             if (!grepl(pattern, name)) 
[10:59:30.797]                               next
[10:59:30.797]                             invokeRestart(restart)
[10:59:30.797]                             muffled <- TRUE
[10:59:30.797]                             break
[10:59:30.797]                           }
[10:59:30.797]                         }
[10:59:30.797]                       }
[10:59:30.797]                       invisible(muffled)
[10:59:30.797]                     }
[10:59:30.797]                     muffleCondition(cond, pattern = "^muffle")
[10:59:30.797]                   }
[10:59:30.797]                 }
[10:59:30.797]                 else {
[10:59:30.797]                   if (TRUE) {
[10:59:30.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:30.797]                     {
[10:59:30.797]                       inherits <- base::inherits
[10:59:30.797]                       invokeRestart <- base::invokeRestart
[10:59:30.797]                       is.null <- base::is.null
[10:59:30.797]                       muffled <- FALSE
[10:59:30.797]                       if (inherits(cond, "message")) {
[10:59:30.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:30.797]                         if (muffled) 
[10:59:30.797]                           invokeRestart("muffleMessage")
[10:59:30.797]                       }
[10:59:30.797]                       else if (inherits(cond, "warning")) {
[10:59:30.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:30.797]                         if (muffled) 
[10:59:30.797]                           invokeRestart("muffleWarning")
[10:59:30.797]                       }
[10:59:30.797]                       else if (inherits(cond, "condition")) {
[10:59:30.797]                         if (!is.null(pattern)) {
[10:59:30.797]                           computeRestarts <- base::computeRestarts
[10:59:30.797]                           grepl <- base::grepl
[10:59:30.797]                           restarts <- computeRestarts(cond)
[10:59:30.797]                           for (restart in restarts) {
[10:59:30.797]                             name <- restart$name
[10:59:30.797]                             if (is.null(name)) 
[10:59:30.797]                               next
[10:59:30.797]                             if (!grepl(pattern, name)) 
[10:59:30.797]                               next
[10:59:30.797]                             invokeRestart(restart)
[10:59:30.797]                             muffled <- TRUE
[10:59:30.797]                             break
[10:59:30.797]                           }
[10:59:30.797]                         }
[10:59:30.797]                       }
[10:59:30.797]                       invisible(muffled)
[10:59:30.797]                     }
[10:59:30.797]                     muffleCondition(cond, pattern = "^muffle")
[10:59:30.797]                   }
[10:59:30.797]                 }
[10:59:30.797]             }
[10:59:30.797]         }))
[10:59:30.797]     }, error = function(ex) {
[10:59:30.797]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:30.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:30.797]                 ...future.rng), started = ...future.startTime, 
[10:59:30.797]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:30.797]             version = "1.8"), class = "FutureResult")
[10:59:30.797]     }, finally = {
[10:59:30.797]         if (!identical(...future.workdir, getwd())) 
[10:59:30.797]             setwd(...future.workdir)
[10:59:30.797]         {
[10:59:30.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:30.797]                 ...future.oldOptions$nwarnings <- NULL
[10:59:30.797]             }
[10:59:30.797]             base::options(...future.oldOptions)
[10:59:30.797]             if (.Platform$OS.type == "windows") {
[10:59:30.797]                 old_names <- names(...future.oldEnvVars)
[10:59:30.797]                 envs <- base::Sys.getenv()
[10:59:30.797]                 names <- names(envs)
[10:59:30.797]                 common <- intersect(names, old_names)
[10:59:30.797]                 added <- setdiff(names, old_names)
[10:59:30.797]                 removed <- setdiff(old_names, names)
[10:59:30.797]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:30.797]                   envs[common]]
[10:59:30.797]                 NAMES <- toupper(changed)
[10:59:30.797]                 args <- list()
[10:59:30.797]                 for (kk in seq_along(NAMES)) {
[10:59:30.797]                   name <- changed[[kk]]
[10:59:30.797]                   NAME <- NAMES[[kk]]
[10:59:30.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:30.797]                     next
[10:59:30.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:30.797]                 }
[10:59:30.797]                 NAMES <- toupper(added)
[10:59:30.797]                 for (kk in seq_along(NAMES)) {
[10:59:30.797]                   name <- added[[kk]]
[10:59:30.797]                   NAME <- NAMES[[kk]]
[10:59:30.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:30.797]                     next
[10:59:30.797]                   args[[name]] <- ""
[10:59:30.797]                 }
[10:59:30.797]                 NAMES <- toupper(removed)
[10:59:30.797]                 for (kk in seq_along(NAMES)) {
[10:59:30.797]                   name <- removed[[kk]]
[10:59:30.797]                   NAME <- NAMES[[kk]]
[10:59:30.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:30.797]                     next
[10:59:30.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:30.797]                 }
[10:59:30.797]                 if (length(args) > 0) 
[10:59:30.797]                   base::do.call(base::Sys.setenv, args = args)
[10:59:30.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:30.797]             }
[10:59:30.797]             else {
[10:59:30.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:30.797]             }
[10:59:30.797]             {
[10:59:30.797]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:30.797]                   0L) {
[10:59:30.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:30.797]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:30.797]                   base::options(opts)
[10:59:30.797]                 }
[10:59:30.797]                 {
[10:59:30.797]                   {
[10:59:30.797]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:30.797]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:30.797]                     1047550554L), envir = base::globalenv(), 
[10:59:30.797]                       inherits = FALSE)
[10:59:30.797]                     NULL
[10:59:30.797]                   }
[10:59:30.797]                   options(future.plan = NULL)
[10:59:30.797]                   if (is.na(NA_character_)) 
[10:59:30.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:30.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:30.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:30.797]                     .init = FALSE)
[10:59:30.797]                 }
[10:59:30.797]             }
[10:59:30.797]         }
[10:59:30.797]     })
[10:59:30.797]     if (TRUE) {
[10:59:30.797]         base::sink(type = "output", split = FALSE)
[10:59:30.797]         if (TRUE) {
[10:59:30.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:30.797]         }
[10:59:30.797]         else {
[10:59:30.797]             ...future.result["stdout"] <- base::list(NULL)
[10:59:30.797]         }
[10:59:30.797]         base::close(...future.stdout)
[10:59:30.797]         ...future.stdout <- NULL
[10:59:30.797]     }
[10:59:30.797]     ...future.result$conditions <- ...future.conditions
[10:59:30.797]     ...future.result$finished <- base::Sys.time()
[10:59:30.797]     ...future.result
[10:59:30.797] }
[10:59:30.799] assign_globals() ...
[10:59:30.799] List of 5
[10:59:30.799]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:59:30.799]  $ MoreArgs                 :List of 1
[10:59:30.799]   ..$ min: num 1
[10:59:30.799]  $ ...future.elements_ii    :List of 2
[10:59:30.799]   ..$ n  :List of 4
[10:59:30.799]   .. ..$ : int 1
[10:59:30.799]   .. ..$ : int 2
[10:59:30.799]   .. ..$ : int 3
[10:59:30.799]   .. ..$ : int 4
[10:59:30.799]   ..$ max:List of 4
[10:59:30.799]   .. ..$ : int 2
[10:59:30.799]   .. ..$ : int 3
[10:59:30.799]   .. ..$ : int 4
[10:59:30.799]   .. ..$ : int 5
[10:59:30.799]  $ ...future.seeds_ii       :List of 4
[10:59:30.799]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:59:30.799]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:59:30.799]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:59:30.799]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:59:30.799]  $ ...future.globals.maxSize: NULL
[10:59:30.799]  - attr(*, "where")=List of 5
[10:59:30.799]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:30.799]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:30.799]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:30.799]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:30.799]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:30.799]  - attr(*, "resolved")= logi FALSE
[10:59:30.799]  - attr(*, "total_size")= num 990
[10:59:30.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:30.799]  - attr(*, "already-done")= logi TRUE
[10:59:30.807] - copied ‘...future.FUN’ to environment
[10:59:30.807] - copied ‘MoreArgs’ to environment
[10:59:30.807] - copied ‘...future.elements_ii’ to environment
[10:59:30.807] - copied ‘...future.seeds_ii’ to environment
[10:59:30.808] - copied ‘...future.globals.maxSize’ to environment
[10:59:30.808] assign_globals() ... done
[10:59:30.808] plan(): Setting new future strategy stack:
[10:59:30.808] List of future strategies:
[10:59:30.808] 1. sequential:
[10:59:30.808]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:30.808]    - tweaked: FALSE
[10:59:30.808]    - call: NULL
[10:59:30.809] plan(): nbrOfWorkers() = 1
[10:59:30.810] plan(): Setting new future strategy stack:
[10:59:30.810] List of future strategies:
[10:59:30.810] 1. sequential:
[10:59:30.810]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:30.810]    - tweaked: FALSE
[10:59:30.810]    - call: plan(sequential)
[10:59:30.810] plan(): nbrOfWorkers() = 1
[10:59:30.810] SequentialFuture started (and completed)
[10:59:30.811] - Launch lazy future ... done
[10:59:30.811] run() for ‘SequentialFuture’ ... done
[10:59:30.811] Created future:
[10:59:30.811] SequentialFuture:
[10:59:30.811] Label: ‘future_mapply-1’
[10:59:30.811] Expression:
[10:59:30.811] {
[10:59:30.811]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:30.811]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:30.811]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:30.811]         on.exit(options(oopts), add = TRUE)
[10:59:30.811]     }
[10:59:30.811]     {
[10:59:30.811]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:30.811]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:30.811]                 inherits = FALSE)
[10:59:30.811]             ...future.FUN(...)
[10:59:30.811]         }
[10:59:30.811]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:30.811]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:30.811]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:30.811]         do.call(mapply, args = args)
[10:59:30.811]     }
[10:59:30.811] }
[10:59:30.811] Lazy evaluation: FALSE
[10:59:30.811] Asynchronous evaluation: FALSE
[10:59:30.811] Local evaluation: TRUE
[10:59:30.811] Environment: R_GlobalEnv
[10:59:30.811] Capture standard output: TRUE
[10:59:30.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:30.811] Globals: 5 objects totaling 990 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 196 bytes, list ‘...future.seeds_ii’ of 175 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:30.811] Packages: 1 packages (‘stats’)
[10:59:30.811] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:30.811] Resolved: TRUE
[10:59:30.811] Value: 143 bytes of class ‘list’
[10:59:30.811] Early signaling: FALSE
[10:59:30.811] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:30.811] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:30.812] Chunk #1 of 1 ... DONE
[10:59:30.812] Launching 1 futures (chunks) ... DONE
[10:59:30.812] Resolving 1 futures (chunks) ...
[10:59:30.813] resolve() on list ...
[10:59:30.813]  recursive: 0
[10:59:30.813]  length: 1
[10:59:30.813] 
[10:59:30.813] resolved() for ‘SequentialFuture’ ...
[10:59:30.813] - state: ‘finished’
[10:59:30.813] - run: TRUE
[10:59:30.813] - result: ‘FutureResult’
[10:59:30.814] resolved() for ‘SequentialFuture’ ... done
[10:59:30.814] Future #1
[10:59:30.815] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:30.815] - nx: 1
[10:59:30.816] - relay: TRUE
[10:59:30.816] - stdout: TRUE
[10:59:30.816] - signal: TRUE
[10:59:30.816] - resignal: FALSE
[10:59:30.816] - force: TRUE
[10:59:30.816] - relayed: [n=1] FALSE
[10:59:30.816] - queued futures: [n=1] FALSE
[10:59:30.816]  - until=1
[10:59:30.816]  - relaying element #1
[10:59:30.816] - relayed: [n=1] TRUE
[10:59:30.816] - queued futures: [n=1] TRUE
[10:59:30.816] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:30.817]  length: 0 (resolved future 1)
[10:59:30.817] Relaying remaining futures
[10:59:30.817] signalConditionsASAP(NULL, pos=0) ...
[10:59:30.817] - nx: 1
[10:59:30.817] - relay: TRUE
[10:59:30.817] - stdout: TRUE
[10:59:30.817] - signal: TRUE
[10:59:30.817] - resignal: FALSE
[10:59:30.817] - force: TRUE
[10:59:30.817] - relayed: [n=1] TRUE
[10:59:30.817] - queued futures: [n=1] TRUE
 - flush all
[10:59:30.818] - relayed: [n=1] TRUE
[10:59:30.818] - queued futures: [n=1] TRUE
[10:59:30.818] signalConditionsASAP(NULL, pos=0) ... done
[10:59:30.818] resolve() on list ... DONE
[10:59:30.818]  - Number of value chunks collected: 1
[10:59:30.818] Resolving 1 futures (chunks) ... DONE
[10:59:30.818] Reducing values from 1 chunks ...
[10:59:30.818]  - Number of values collected after concatenation: 4
[10:59:30.818]  - Number of values expected: 4
[10:59:30.818] Reducing values from 1 chunks ... DONE
[10:59:30.818] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:59:30.962] plan(): Setting new future strategy stack:
[10:59:30.962] List of future strategies:
[10:59:30.962] 1. sequential:
[10:59:30.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:30.962]    - tweaked: FALSE
[10:59:30.962]    - call: plan(strategy)
[10:59:30.963] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[10:59:30.963] future_mapply() ...
[10:59:30.964] Number of chunks: 1
[10:59:30.964] getGlobalsAndPackagesXApply() ...
[10:59:30.964]  - future.globals: TRUE
[10:59:30.964] getGlobalsAndPackages() ...
[10:59:30.964] Searching for globals...
[10:59:30.964] - globals found: [1] ‘FUN’
[10:59:30.965] Searching for globals ... DONE
[10:59:30.965] Resolving globals: FALSE
[10:59:30.965] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:30.965] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:30.965] - globals: [1] ‘FUN’
[10:59:30.965] 
[10:59:30.965] getGlobalsAndPackages() ... DONE
[10:59:30.965]  - globals found/used: [n=1] ‘FUN’
[10:59:30.966]  - needed namespaces: [n=0] 
[10:59:30.966] Finding globals ... DONE
[10:59:30.966] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:30.966] List of 2
[10:59:30.966]  $ ...future.FUN:function (x, ...)  
[10:59:30.966]  $ MoreArgs     : NULL
[10:59:30.966]  - attr(*, "where")=List of 2
[10:59:30.966]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:30.966]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:30.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:30.966]  - attr(*, "resolved")= logi FALSE
[10:59:30.966]  - attr(*, "total_size")= num NA
[10:59:30.968] Packages to be attached in all futures: [n=0] 
[10:59:30.968] getGlobalsAndPackagesXApply() ... DONE
[10:59:30.968] Number of futures (= number of chunks): 1
[10:59:30.969] Launching 1 futures (chunks) ...
[10:59:30.969] Chunk #1 of 1 ...
[10:59:30.969]  - Finding globals in '...' for chunk #1 ...
[10:59:30.969] getGlobalsAndPackages() ...
[10:59:30.969] Searching for globals...
[10:59:30.969] 
[10:59:30.969] Searching for globals ... DONE
[10:59:30.969] - globals: [0] <none>
[10:59:30.969] getGlobalsAndPackages() ... DONE
[10:59:30.970]    + additional globals found: [n=0] 
[10:59:30.970]    + additional namespaces needed: [n=0] 
[10:59:30.970]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:30.970]  - seeds: <none>
[10:59:30.970]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.970] getGlobalsAndPackages() ...
[10:59:30.970] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.970] Resolving globals: FALSE
[10:59:30.970] The total size of the 5 globals is 258 bytes (258 bytes)
[10:59:30.971] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:30.971] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.971] 
[10:59:30.971] getGlobalsAndPackages() ... DONE
[10:59:30.971] run() for ‘Future’ ...
[10:59:30.972] - state: ‘created’
[10:59:30.972] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:30.972] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:30.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:30.972]   - Field: ‘label’
[10:59:30.972]   - Field: ‘local’
[10:59:30.972]   - Field: ‘owner’
[10:59:30.972]   - Field: ‘envir’
[10:59:30.972]   - Field: ‘packages’
[10:59:30.972]   - Field: ‘gc’
[10:59:30.973]   - Field: ‘conditions’
[10:59:30.973]   - Field: ‘expr’
[10:59:30.973]   - Field: ‘uuid’
[10:59:30.973]   - Field: ‘seed’
[10:59:30.973]   - Field: ‘version’
[10:59:30.973]   - Field: ‘result’
[10:59:30.973]   - Field: ‘asynchronous’
[10:59:30.973]   - Field: ‘calls’
[10:59:30.973]   - Field: ‘globals’
[10:59:30.973]   - Field: ‘stdout’
[10:59:30.973]   - Field: ‘earlySignal’
[10:59:30.973]   - Field: ‘lazy’
[10:59:30.973]   - Field: ‘state’
[10:59:30.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:30.974] - Launch lazy future ...
[10:59:30.974] Packages needed by the future expression (n = 0): <none>
[10:59:30.974] Packages needed by future strategies (n = 0): <none>
[10:59:30.974] {
[10:59:30.974]     {
[10:59:30.974]         {
[10:59:30.974]             ...future.startTime <- base::Sys.time()
[10:59:30.974]             {
[10:59:30.974]                 {
[10:59:30.974]                   {
[10:59:30.974]                     base::local({
[10:59:30.974]                       has_future <- base::requireNamespace("future", 
[10:59:30.974]                         quietly = TRUE)
[10:59:30.974]                       if (has_future) {
[10:59:30.974]                         ns <- base::getNamespace("future")
[10:59:30.974]                         version <- ns[[".package"]][["version"]]
[10:59:30.974]                         if (is.null(version)) 
[10:59:30.974]                           version <- utils::packageVersion("future")
[10:59:30.974]                       }
[10:59:30.974]                       else {
[10:59:30.974]                         version <- NULL
[10:59:30.974]                       }
[10:59:30.974]                       if (!has_future || version < "1.8.0") {
[10:59:30.974]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:30.974]                           "", base::R.version$version.string), 
[10:59:30.974]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:30.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:30.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:30.974]                             "release", "version")], collapse = " "), 
[10:59:30.974]                           hostname = base::Sys.info()[["nodename"]])
[10:59:30.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:30.974]                           info)
[10:59:30.974]                         info <- base::paste(info, collapse = "; ")
[10:59:30.974]                         if (!has_future) {
[10:59:30.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:30.974]                             info)
[10:59:30.974]                         }
[10:59:30.974]                         else {
[10:59:30.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:30.974]                             info, version)
[10:59:30.974]                         }
[10:59:30.974]                         base::stop(msg)
[10:59:30.974]                       }
[10:59:30.974]                     })
[10:59:30.974]                   }
[10:59:30.974]                   ...future.strategy.old <- future::plan("list")
[10:59:30.974]                   options(future.plan = NULL)
[10:59:30.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:30.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:30.974]                 }
[10:59:30.974]                 ...future.workdir <- getwd()
[10:59:30.974]             }
[10:59:30.974]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:30.974]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:30.974]         }
[10:59:30.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:30.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:30.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:30.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:30.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:30.974]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:30.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:30.974]             base::names(...future.oldOptions))
[10:59:30.974]     }
[10:59:30.974]     if (FALSE) {
[10:59:30.974]     }
[10:59:30.974]     else {
[10:59:30.974]         if (TRUE) {
[10:59:30.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:30.974]                 open = "w")
[10:59:30.974]         }
[10:59:30.974]         else {
[10:59:30.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:30.974]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:30.974]         }
[10:59:30.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:30.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:30.974]             base::sink(type = "output", split = FALSE)
[10:59:30.974]             base::close(...future.stdout)
[10:59:30.974]         }, add = TRUE)
[10:59:30.974]     }
[10:59:30.974]     ...future.frame <- base::sys.nframe()
[10:59:30.974]     ...future.conditions <- base::list()
[10:59:30.974]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:30.974]     if (FALSE) {
[10:59:30.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:30.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:30.974]     }
[10:59:30.974]     ...future.result <- base::tryCatch({
[10:59:30.974]         base::withCallingHandlers({
[10:59:30.974]             ...future.value <- base::withVisible(base::local({
[10:59:30.974]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:30.974]                 if (!identical(...future.globals.maxSize.org, 
[10:59:30.974]                   ...future.globals.maxSize)) {
[10:59:30.974]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:30.974]                   on.exit(options(oopts), add = TRUE)
[10:59:30.974]                 }
[10:59:30.974]                 {
[10:59:30.974]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:30.974]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:30.974]                     USE.NAMES = FALSE)
[10:59:30.974]                   do.call(mapply, args = args)
[10:59:30.974]                 }
[10:59:30.974]             }))
[10:59:30.974]             future::FutureResult(value = ...future.value$value, 
[10:59:30.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:30.974]                   ...future.rng), globalenv = if (FALSE) 
[10:59:30.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:30.974]                     ...future.globalenv.names))
[10:59:30.974]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:30.974]         }, condition = base::local({
[10:59:30.974]             c <- base::c
[10:59:30.974]             inherits <- base::inherits
[10:59:30.974]             invokeRestart <- base::invokeRestart
[10:59:30.974]             length <- base::length
[10:59:30.974]             list <- base::list
[10:59:30.974]             seq.int <- base::seq.int
[10:59:30.974]             signalCondition <- base::signalCondition
[10:59:30.974]             sys.calls <- base::sys.calls
[10:59:30.974]             `[[` <- base::`[[`
[10:59:30.974]             `+` <- base::`+`
[10:59:30.974]             `<<-` <- base::`<<-`
[10:59:30.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:30.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:30.974]                   3L)]
[10:59:30.974]             }
[10:59:30.974]             function(cond) {
[10:59:30.974]                 is_error <- inherits(cond, "error")
[10:59:30.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:30.974]                   NULL)
[10:59:30.974]                 if (is_error) {
[10:59:30.974]                   sessionInformation <- function() {
[10:59:30.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:30.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:30.974]                       search = base::search(), system = base::Sys.info())
[10:59:30.974]                   }
[10:59:30.974]                   ...future.conditions[[length(...future.conditions) + 
[10:59:30.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:30.974]                     cond$call), session = sessionInformation(), 
[10:59:30.974]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:30.974]                   signalCondition(cond)
[10:59:30.974]                 }
[10:59:30.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:30.974]                 "immediateCondition"))) {
[10:59:30.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:30.974]                   ...future.conditions[[length(...future.conditions) + 
[10:59:30.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:30.974]                   if (TRUE && !signal) {
[10:59:30.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:30.974]                     {
[10:59:30.974]                       inherits <- base::inherits
[10:59:30.974]                       invokeRestart <- base::invokeRestart
[10:59:30.974]                       is.null <- base::is.null
[10:59:30.974]                       muffled <- FALSE
[10:59:30.974]                       if (inherits(cond, "message")) {
[10:59:30.974]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:30.974]                         if (muffled) 
[10:59:30.974]                           invokeRestart("muffleMessage")
[10:59:30.974]                       }
[10:59:30.974]                       else if (inherits(cond, "warning")) {
[10:59:30.974]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:30.974]                         if (muffled) 
[10:59:30.974]                           invokeRestart("muffleWarning")
[10:59:30.974]                       }
[10:59:30.974]                       else if (inherits(cond, "condition")) {
[10:59:30.974]                         if (!is.null(pattern)) {
[10:59:30.974]                           computeRestarts <- base::computeRestarts
[10:59:30.974]                           grepl <- base::grepl
[10:59:30.974]                           restarts <- computeRestarts(cond)
[10:59:30.974]                           for (restart in restarts) {
[10:59:30.974]                             name <- restart$name
[10:59:30.974]                             if (is.null(name)) 
[10:59:30.974]                               next
[10:59:30.974]                             if (!grepl(pattern, name)) 
[10:59:30.974]                               next
[10:59:30.974]                             invokeRestart(restart)
[10:59:30.974]                             muffled <- TRUE
[10:59:30.974]                             break
[10:59:30.974]                           }
[10:59:30.974]                         }
[10:59:30.974]                       }
[10:59:30.974]                       invisible(muffled)
[10:59:30.974]                     }
[10:59:30.974]                     muffleCondition(cond, pattern = "^muffle")
[10:59:30.974]                   }
[10:59:30.974]                 }
[10:59:30.974]                 else {
[10:59:30.974]                   if (TRUE) {
[10:59:30.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:30.974]                     {
[10:59:30.974]                       inherits <- base::inherits
[10:59:30.974]                       invokeRestart <- base::invokeRestart
[10:59:30.974]                       is.null <- base::is.null
[10:59:30.974]                       muffled <- FALSE
[10:59:30.974]                       if (inherits(cond, "message")) {
[10:59:30.974]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:30.974]                         if (muffled) 
[10:59:30.974]                           invokeRestart("muffleMessage")
[10:59:30.974]                       }
[10:59:30.974]                       else if (inherits(cond, "warning")) {
[10:59:30.974]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:30.974]                         if (muffled) 
[10:59:30.974]                           invokeRestart("muffleWarning")
[10:59:30.974]                       }
[10:59:30.974]                       else if (inherits(cond, "condition")) {
[10:59:30.974]                         if (!is.null(pattern)) {
[10:59:30.974]                           computeRestarts <- base::computeRestarts
[10:59:30.974]                           grepl <- base::grepl
[10:59:30.974]                           restarts <- computeRestarts(cond)
[10:59:30.974]                           for (restart in restarts) {
[10:59:30.974]                             name <- restart$name
[10:59:30.974]                             if (is.null(name)) 
[10:59:30.974]                               next
[10:59:30.974]                             if (!grepl(pattern, name)) 
[10:59:30.974]                               next
[10:59:30.974]                             invokeRestart(restart)
[10:59:30.974]                             muffled <- TRUE
[10:59:30.974]                             break
[10:59:30.974]                           }
[10:59:30.974]                         }
[10:59:30.974]                       }
[10:59:30.974]                       invisible(muffled)
[10:59:30.974]                     }
[10:59:30.974]                     muffleCondition(cond, pattern = "^muffle")
[10:59:30.974]                   }
[10:59:30.974]                 }
[10:59:30.974]             }
[10:59:30.974]         }))
[10:59:30.974]     }, error = function(ex) {
[10:59:30.974]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:30.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:30.974]                 ...future.rng), started = ...future.startTime, 
[10:59:30.974]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:30.974]             version = "1.8"), class = "FutureResult")
[10:59:30.974]     }, finally = {
[10:59:30.974]         if (!identical(...future.workdir, getwd())) 
[10:59:30.974]             setwd(...future.workdir)
[10:59:30.974]         {
[10:59:30.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:30.974]                 ...future.oldOptions$nwarnings <- NULL
[10:59:30.974]             }
[10:59:30.974]             base::options(...future.oldOptions)
[10:59:30.974]             if (.Platform$OS.type == "windows") {
[10:59:30.974]                 old_names <- names(...future.oldEnvVars)
[10:59:30.974]                 envs <- base::Sys.getenv()
[10:59:30.974]                 names <- names(envs)
[10:59:30.974]                 common <- intersect(names, old_names)
[10:59:30.974]                 added <- setdiff(names, old_names)
[10:59:30.974]                 removed <- setdiff(old_names, names)
[10:59:30.974]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:30.974]                   envs[common]]
[10:59:30.974]                 NAMES <- toupper(changed)
[10:59:30.974]                 args <- list()
[10:59:30.974]                 for (kk in seq_along(NAMES)) {
[10:59:30.974]                   name <- changed[[kk]]
[10:59:30.974]                   NAME <- NAMES[[kk]]
[10:59:30.974]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:30.974]                     next
[10:59:30.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:30.974]                 }
[10:59:30.974]                 NAMES <- toupper(added)
[10:59:30.974]                 for (kk in seq_along(NAMES)) {
[10:59:30.974]                   name <- added[[kk]]
[10:59:30.974]                   NAME <- NAMES[[kk]]
[10:59:30.974]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:30.974]                     next
[10:59:30.974]                   args[[name]] <- ""
[10:59:30.974]                 }
[10:59:30.974]                 NAMES <- toupper(removed)
[10:59:30.974]                 for (kk in seq_along(NAMES)) {
[10:59:30.974]                   name <- removed[[kk]]
[10:59:30.974]                   NAME <- NAMES[[kk]]
[10:59:30.974]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:30.974]                     next
[10:59:30.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:30.974]                 }
[10:59:30.974]                 if (length(args) > 0) 
[10:59:30.974]                   base::do.call(base::Sys.setenv, args = args)
[10:59:30.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:30.974]             }
[10:59:30.974]             else {
[10:59:30.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:30.974]             }
[10:59:30.974]             {
[10:59:30.974]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:30.974]                   0L) {
[10:59:30.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:30.974]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:30.974]                   base::options(opts)
[10:59:30.974]                 }
[10:59:30.974]                 {
[10:59:30.974]                   {
[10:59:30.974]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:30.974]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:30.974]                     1047550554L), envir = base::globalenv(), 
[10:59:30.974]                       inherits = FALSE)
[10:59:30.974]                     NULL
[10:59:30.974]                   }
[10:59:30.974]                   options(future.plan = NULL)
[10:59:30.974]                   if (is.na(NA_character_)) 
[10:59:30.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:30.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:30.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:30.974]                     .init = FALSE)
[10:59:30.974]                 }
[10:59:30.974]             }
[10:59:30.974]         }
[10:59:30.974]     })
[10:59:30.974]     if (TRUE) {
[10:59:30.974]         base::sink(type = "output", split = FALSE)
[10:59:30.974]         if (TRUE) {
[10:59:30.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:30.974]         }
[10:59:30.974]         else {
[10:59:30.974]             ...future.result["stdout"] <- base::list(NULL)
[10:59:30.974]         }
[10:59:30.974]         base::close(...future.stdout)
[10:59:30.974]         ...future.stdout <- NULL
[10:59:30.974]     }
[10:59:30.974]     ...future.result$conditions <- ...future.conditions
[10:59:30.974]     ...future.result$finished <- base::Sys.time()
[10:59:30.974]     ...future.result
[10:59:30.974] }
[10:59:30.976] assign_globals() ...
[10:59:30.976] List of 5
[10:59:30.976]  $ ...future.FUN            :function (x, ...)  
[10:59:30.976]  $ MoreArgs                 : NULL
[10:59:30.976]  $ ...future.elements_ii    :List of 2
[10:59:30.976]   ..$ :List of 4
[10:59:30.976]   .. ..$ : int 1
[10:59:30.976]   .. ..$ : int 2
[10:59:30.976]   .. ..$ : int 3
[10:59:30.976]   .. ..$ : int 4
[10:59:30.976]   ..$ :List of 4
[10:59:30.976]   .. ..$ : int 4
[10:59:30.976]   .. ..$ : int 3
[10:59:30.976]   .. ..$ : int 2
[10:59:30.976]   .. ..$ : int 1
[10:59:30.976]  $ ...future.seeds_ii       : NULL
[10:59:30.976]  $ ...future.globals.maxSize: NULL
[10:59:30.976]  - attr(*, "where")=List of 5
[10:59:30.976]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:30.976]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:30.976]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:30.976]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:30.976]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:30.976]  - attr(*, "resolved")= logi FALSE
[10:59:30.976]  - attr(*, "total_size")= num 258
[10:59:30.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:30.976]  - attr(*, "already-done")= logi TRUE
[10:59:30.982] - copied ‘...future.FUN’ to environment
[10:59:30.982] - copied ‘MoreArgs’ to environment
[10:59:30.982] - copied ‘...future.elements_ii’ to environment
[10:59:30.982] - copied ‘...future.seeds_ii’ to environment
[10:59:30.982] - copied ‘...future.globals.maxSize’ to environment
[10:59:30.983] assign_globals() ... done
[10:59:30.983] plan(): Setting new future strategy stack:
[10:59:30.983] List of future strategies:
[10:59:30.983] 1. sequential:
[10:59:30.983]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:30.983]    - tweaked: FALSE
[10:59:30.983]    - call: NULL
[10:59:30.983] plan(): nbrOfWorkers() = 1
[10:59:30.984] plan(): Setting new future strategy stack:
[10:59:30.984] List of future strategies:
[10:59:30.984] 1. sequential:
[10:59:30.984]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:30.984]    - tweaked: FALSE
[10:59:30.984]    - call: plan(strategy)
[10:59:30.984] plan(): nbrOfWorkers() = 1
[10:59:30.985] SequentialFuture started (and completed)
[10:59:30.985] - Launch lazy future ... done
[10:59:30.985] run() for ‘SequentialFuture’ ... done
[10:59:30.985] Created future:
[10:59:30.985] SequentialFuture:
[10:59:30.985] Label: ‘future_mapply-1’
[10:59:30.985] Expression:
[10:59:30.985] {
[10:59:30.985]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:30.985]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:30.985]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:30.985]         on.exit(options(oopts), add = TRUE)
[10:59:30.985]     }
[10:59:30.985]     {
[10:59:30.985]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:30.985]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:30.985]         do.call(mapply, args = args)
[10:59:30.985]     }
[10:59:30.985] }
[10:59:30.985] Lazy evaluation: FALSE
[10:59:30.985] Asynchronous evaluation: FALSE
[10:59:30.985] Local evaluation: TRUE
[10:59:30.985] Environment: R_GlobalEnv
[10:59:30.985] Capture standard output: TRUE
[10:59:30.985] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:30.985] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:30.985] Packages: <none>
[10:59:30.985] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:30.985] Resolved: TRUE
[10:59:30.985] Value: 103 bytes of class ‘list’
[10:59:30.985] Early signaling: FALSE
[10:59:30.985] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:30.985] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:30.987] Chunk #1 of 1 ... DONE
[10:59:30.987] Launching 1 futures (chunks) ... DONE
[10:59:30.987] Resolving 1 futures (chunks) ...
[10:59:30.987] resolve() on list ...
[10:59:30.987]  recursive: 0
[10:59:30.987]  length: 1
[10:59:30.987] 
[10:59:30.987] resolved() for ‘SequentialFuture’ ...
[10:59:30.987] - state: ‘finished’
[10:59:30.987] - run: TRUE
[10:59:30.987] - result: ‘FutureResult’
[10:59:30.988] resolved() for ‘SequentialFuture’ ... done
[10:59:30.988] Future #1
[10:59:30.988] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:30.988] - nx: 1
[10:59:30.988] - relay: TRUE
[10:59:30.988] - stdout: TRUE
[10:59:30.988] - signal: TRUE
[10:59:30.988] - resignal: FALSE
[10:59:30.988] - force: TRUE
[10:59:30.988] - relayed: [n=1] FALSE
[10:59:30.988] - queued futures: [n=1] FALSE
[10:59:30.988]  - until=1
[10:59:30.988]  - relaying element #1
[10:59:30.989] - relayed: [n=1] TRUE
[10:59:30.989] - queued futures: [n=1] TRUE
[10:59:30.989] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:30.989]  length: 0 (resolved future 1)
[10:59:30.989] Relaying remaining futures
[10:59:30.989] signalConditionsASAP(NULL, pos=0) ...
[10:59:30.989] - nx: 1
[10:59:30.989] - relay: TRUE
[10:59:30.989] - stdout: TRUE
[10:59:30.989] - signal: TRUE
[10:59:30.989] - resignal: FALSE
[10:59:30.989] - force: TRUE
[10:59:30.990] - relayed: [n=1] TRUE
[10:59:30.990] - queued futures: [n=1] TRUE
 - flush all
[10:59:30.990] - relayed: [n=1] TRUE
[10:59:30.990] - queued futures: [n=1] TRUE
[10:59:30.990] signalConditionsASAP(NULL, pos=0) ... done
[10:59:30.990] resolve() on list ... DONE
[10:59:30.990]  - Number of value chunks collected: 1
[10:59:30.990] Resolving 1 futures (chunks) ... DONE
[10:59:30.990] Reducing values from 1 chunks ...
[10:59:30.990]  - Number of values collected after concatenation: 4
[10:59:30.990]  - Number of values expected: 4
[10:59:30.990] Reducing values from 1 chunks ... DONE
[10:59:30.991] future_mapply() ... DONE
[10:59:30.991] future_mapply() ...
[10:59:30.991] Number of chunks: 1
[10:59:30.991] getGlobalsAndPackagesXApply() ...
[10:59:30.991]  - future.globals: TRUE
[10:59:30.991] getGlobalsAndPackages() ...
[10:59:30.991] Searching for globals...
[10:59:30.992] - globals found: [1] ‘FUN’
[10:59:30.992] Searching for globals ... DONE
[10:59:30.992] Resolving globals: FALSE
[10:59:30.992] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:30.992] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:30.992] - globals: [1] ‘FUN’
[10:59:30.993] 
[10:59:30.993] getGlobalsAndPackages() ... DONE
[10:59:30.993]  - globals found/used: [n=1] ‘FUN’
[10:59:30.993]  - needed namespaces: [n=0] 
[10:59:30.993] Finding globals ... DONE
[10:59:30.993] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:30.993] List of 2
[10:59:30.993]  $ ...future.FUN:function (x, ...)  
[10:59:30.993]  $ MoreArgs     : NULL
[10:59:30.993]  - attr(*, "where")=List of 2
[10:59:30.993]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:30.993]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:30.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:30.993]  - attr(*, "resolved")= logi FALSE
[10:59:30.993]  - attr(*, "total_size")= num NA
[10:59:30.995] Packages to be attached in all futures: [n=0] 
[10:59:30.995] getGlobalsAndPackagesXApply() ... DONE
[10:59:30.996] Number of futures (= number of chunks): 1
[10:59:30.996] Launching 1 futures (chunks) ...
[10:59:30.996] Chunk #1 of 1 ...
[10:59:30.996]  - Finding globals in '...' for chunk #1 ...
[10:59:30.996] getGlobalsAndPackages() ...
[10:59:30.996] Searching for globals...
[10:59:30.996] 
[10:59:30.996] Searching for globals ... DONE
[10:59:30.996] - globals: [0] <none>
[10:59:30.997] getGlobalsAndPackages() ... DONE
[10:59:30.997]    + additional globals found: [n=0] 
[10:59:30.997]    + additional namespaces needed: [n=0] 
[10:59:30.997]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:30.997]  - seeds: <none>
[10:59:30.997]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.997] getGlobalsAndPackages() ...
[10:59:30.997] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.997] Resolving globals: FALSE
[10:59:30.998] The total size of the 5 globals is 258 bytes (258 bytes)
[10:59:30.998] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:30.998] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:30.998] 
[10:59:30.998] getGlobalsAndPackages() ... DONE
[10:59:30.998] run() for ‘Future’ ...
[10:59:30.999] - state: ‘created’
[10:59:30.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:30.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:30.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:30.999]   - Field: ‘label’
[10:59:30.999]   - Field: ‘local’
[10:59:30.999]   - Field: ‘owner’
[10:59:30.999]   - Field: ‘envir’
[10:59:30.999]   - Field: ‘packages’
[10:59:30.999]   - Field: ‘gc’
[10:59:31.000]   - Field: ‘conditions’
[10:59:31.000]   - Field: ‘expr’
[10:59:31.000]   - Field: ‘uuid’
[10:59:31.000]   - Field: ‘seed’
[10:59:31.000]   - Field: ‘version’
[10:59:31.000]   - Field: ‘result’
[10:59:31.000]   - Field: ‘asynchronous’
[10:59:31.000]   - Field: ‘calls’
[10:59:31.000]   - Field: ‘globals’
[10:59:31.000]   - Field: ‘stdout’
[10:59:31.000]   - Field: ‘earlySignal’
[10:59:31.000]   - Field: ‘lazy’
[10:59:31.001]   - Field: ‘state’
[10:59:31.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.001] - Launch lazy future ...
[10:59:31.001] Packages needed by the future expression (n = 0): <none>
[10:59:31.001] Packages needed by future strategies (n = 0): <none>
[10:59:31.001] {
[10:59:31.001]     {
[10:59:31.001]         {
[10:59:31.001]             ...future.startTime <- base::Sys.time()
[10:59:31.001]             {
[10:59:31.001]                 {
[10:59:31.001]                   {
[10:59:31.001]                     base::local({
[10:59:31.001]                       has_future <- base::requireNamespace("future", 
[10:59:31.001]                         quietly = TRUE)
[10:59:31.001]                       if (has_future) {
[10:59:31.001]                         ns <- base::getNamespace("future")
[10:59:31.001]                         version <- ns[[".package"]][["version"]]
[10:59:31.001]                         if (is.null(version)) 
[10:59:31.001]                           version <- utils::packageVersion("future")
[10:59:31.001]                       }
[10:59:31.001]                       else {
[10:59:31.001]                         version <- NULL
[10:59:31.001]                       }
[10:59:31.001]                       if (!has_future || version < "1.8.0") {
[10:59:31.001]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.001]                           "", base::R.version$version.string), 
[10:59:31.001]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.001]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.001]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.001]                             "release", "version")], collapse = " "), 
[10:59:31.001]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.001]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.001]                           info)
[10:59:31.001]                         info <- base::paste(info, collapse = "; ")
[10:59:31.001]                         if (!has_future) {
[10:59:31.001]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.001]                             info)
[10:59:31.001]                         }
[10:59:31.001]                         else {
[10:59:31.001]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.001]                             info, version)
[10:59:31.001]                         }
[10:59:31.001]                         base::stop(msg)
[10:59:31.001]                       }
[10:59:31.001]                     })
[10:59:31.001]                   }
[10:59:31.001]                   ...future.strategy.old <- future::plan("list")
[10:59:31.001]                   options(future.plan = NULL)
[10:59:31.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.001]                 }
[10:59:31.001]                 ...future.workdir <- getwd()
[10:59:31.001]             }
[10:59:31.001]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.001]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.001]         }
[10:59:31.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.001]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.001]             base::names(...future.oldOptions))
[10:59:31.001]     }
[10:59:31.001]     if (FALSE) {
[10:59:31.001]     }
[10:59:31.001]     else {
[10:59:31.001]         if (TRUE) {
[10:59:31.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.001]                 open = "w")
[10:59:31.001]         }
[10:59:31.001]         else {
[10:59:31.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.001]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.001]         }
[10:59:31.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.001]             base::sink(type = "output", split = FALSE)
[10:59:31.001]             base::close(...future.stdout)
[10:59:31.001]         }, add = TRUE)
[10:59:31.001]     }
[10:59:31.001]     ...future.frame <- base::sys.nframe()
[10:59:31.001]     ...future.conditions <- base::list()
[10:59:31.001]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.001]     if (FALSE) {
[10:59:31.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.001]     }
[10:59:31.001]     ...future.result <- base::tryCatch({
[10:59:31.001]         base::withCallingHandlers({
[10:59:31.001]             ...future.value <- base::withVisible(base::local({
[10:59:31.001]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.001]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.001]                   ...future.globals.maxSize)) {
[10:59:31.001]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.001]                   on.exit(options(oopts), add = TRUE)
[10:59:31.001]                 }
[10:59:31.001]                 {
[10:59:31.001]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.001]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.001]                     USE.NAMES = FALSE)
[10:59:31.001]                   do.call(mapply, args = args)
[10:59:31.001]                 }
[10:59:31.001]             }))
[10:59:31.001]             future::FutureResult(value = ...future.value$value, 
[10:59:31.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.001]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.001]                     ...future.globalenv.names))
[10:59:31.001]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.001]         }, condition = base::local({
[10:59:31.001]             c <- base::c
[10:59:31.001]             inherits <- base::inherits
[10:59:31.001]             invokeRestart <- base::invokeRestart
[10:59:31.001]             length <- base::length
[10:59:31.001]             list <- base::list
[10:59:31.001]             seq.int <- base::seq.int
[10:59:31.001]             signalCondition <- base::signalCondition
[10:59:31.001]             sys.calls <- base::sys.calls
[10:59:31.001]             `[[` <- base::`[[`
[10:59:31.001]             `+` <- base::`+`
[10:59:31.001]             `<<-` <- base::`<<-`
[10:59:31.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.001]                   3L)]
[10:59:31.001]             }
[10:59:31.001]             function(cond) {
[10:59:31.001]                 is_error <- inherits(cond, "error")
[10:59:31.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.001]                   NULL)
[10:59:31.001]                 if (is_error) {
[10:59:31.001]                   sessionInformation <- function() {
[10:59:31.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.001]                       search = base::search(), system = base::Sys.info())
[10:59:31.001]                   }
[10:59:31.001]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.001]                     cond$call), session = sessionInformation(), 
[10:59:31.001]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.001]                   signalCondition(cond)
[10:59:31.001]                 }
[10:59:31.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.001]                 "immediateCondition"))) {
[10:59:31.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.001]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.001]                   if (TRUE && !signal) {
[10:59:31.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.001]                     {
[10:59:31.001]                       inherits <- base::inherits
[10:59:31.001]                       invokeRestart <- base::invokeRestart
[10:59:31.001]                       is.null <- base::is.null
[10:59:31.001]                       muffled <- FALSE
[10:59:31.001]                       if (inherits(cond, "message")) {
[10:59:31.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.001]                         if (muffled) 
[10:59:31.001]                           invokeRestart("muffleMessage")
[10:59:31.001]                       }
[10:59:31.001]                       else if (inherits(cond, "warning")) {
[10:59:31.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.001]                         if (muffled) 
[10:59:31.001]                           invokeRestart("muffleWarning")
[10:59:31.001]                       }
[10:59:31.001]                       else if (inherits(cond, "condition")) {
[10:59:31.001]                         if (!is.null(pattern)) {
[10:59:31.001]                           computeRestarts <- base::computeRestarts
[10:59:31.001]                           grepl <- base::grepl
[10:59:31.001]                           restarts <- computeRestarts(cond)
[10:59:31.001]                           for (restart in restarts) {
[10:59:31.001]                             name <- restart$name
[10:59:31.001]                             if (is.null(name)) 
[10:59:31.001]                               next
[10:59:31.001]                             if (!grepl(pattern, name)) 
[10:59:31.001]                               next
[10:59:31.001]                             invokeRestart(restart)
[10:59:31.001]                             muffled <- TRUE
[10:59:31.001]                             break
[10:59:31.001]                           }
[10:59:31.001]                         }
[10:59:31.001]                       }
[10:59:31.001]                       invisible(muffled)
[10:59:31.001]                     }
[10:59:31.001]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.001]                   }
[10:59:31.001]                 }
[10:59:31.001]                 else {
[10:59:31.001]                   if (TRUE) {
[10:59:31.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.001]                     {
[10:59:31.001]                       inherits <- base::inherits
[10:59:31.001]                       invokeRestart <- base::invokeRestart
[10:59:31.001]                       is.null <- base::is.null
[10:59:31.001]                       muffled <- FALSE
[10:59:31.001]                       if (inherits(cond, "message")) {
[10:59:31.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.001]                         if (muffled) 
[10:59:31.001]                           invokeRestart("muffleMessage")
[10:59:31.001]                       }
[10:59:31.001]                       else if (inherits(cond, "warning")) {
[10:59:31.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.001]                         if (muffled) 
[10:59:31.001]                           invokeRestart("muffleWarning")
[10:59:31.001]                       }
[10:59:31.001]                       else if (inherits(cond, "condition")) {
[10:59:31.001]                         if (!is.null(pattern)) {
[10:59:31.001]                           computeRestarts <- base::computeRestarts
[10:59:31.001]                           grepl <- base::grepl
[10:59:31.001]                           restarts <- computeRestarts(cond)
[10:59:31.001]                           for (restart in restarts) {
[10:59:31.001]                             name <- restart$name
[10:59:31.001]                             if (is.null(name)) 
[10:59:31.001]                               next
[10:59:31.001]                             if (!grepl(pattern, name)) 
[10:59:31.001]                               next
[10:59:31.001]                             invokeRestart(restart)
[10:59:31.001]                             muffled <- TRUE
[10:59:31.001]                             break
[10:59:31.001]                           }
[10:59:31.001]                         }
[10:59:31.001]                       }
[10:59:31.001]                       invisible(muffled)
[10:59:31.001]                     }
[10:59:31.001]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.001]                   }
[10:59:31.001]                 }
[10:59:31.001]             }
[10:59:31.001]         }))
[10:59:31.001]     }, error = function(ex) {
[10:59:31.001]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.001]                 ...future.rng), started = ...future.startTime, 
[10:59:31.001]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.001]             version = "1.8"), class = "FutureResult")
[10:59:31.001]     }, finally = {
[10:59:31.001]         if (!identical(...future.workdir, getwd())) 
[10:59:31.001]             setwd(...future.workdir)
[10:59:31.001]         {
[10:59:31.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.001]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.001]             }
[10:59:31.001]             base::options(...future.oldOptions)
[10:59:31.001]             if (.Platform$OS.type == "windows") {
[10:59:31.001]                 old_names <- names(...future.oldEnvVars)
[10:59:31.001]                 envs <- base::Sys.getenv()
[10:59:31.001]                 names <- names(envs)
[10:59:31.001]                 common <- intersect(names, old_names)
[10:59:31.001]                 added <- setdiff(names, old_names)
[10:59:31.001]                 removed <- setdiff(old_names, names)
[10:59:31.001]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.001]                   envs[common]]
[10:59:31.001]                 NAMES <- toupper(changed)
[10:59:31.001]                 args <- list()
[10:59:31.001]                 for (kk in seq_along(NAMES)) {
[10:59:31.001]                   name <- changed[[kk]]
[10:59:31.001]                   NAME <- NAMES[[kk]]
[10:59:31.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.001]                     next
[10:59:31.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.001]                 }
[10:59:31.001]                 NAMES <- toupper(added)
[10:59:31.001]                 for (kk in seq_along(NAMES)) {
[10:59:31.001]                   name <- added[[kk]]
[10:59:31.001]                   NAME <- NAMES[[kk]]
[10:59:31.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.001]                     next
[10:59:31.001]                   args[[name]] <- ""
[10:59:31.001]                 }
[10:59:31.001]                 NAMES <- toupper(removed)
[10:59:31.001]                 for (kk in seq_along(NAMES)) {
[10:59:31.001]                   name <- removed[[kk]]
[10:59:31.001]                   NAME <- NAMES[[kk]]
[10:59:31.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.001]                     next
[10:59:31.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.001]                 }
[10:59:31.001]                 if (length(args) > 0) 
[10:59:31.001]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.001]             }
[10:59:31.001]             else {
[10:59:31.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.001]             }
[10:59:31.001]             {
[10:59:31.001]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.001]                   0L) {
[10:59:31.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.001]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.001]                   base::options(opts)
[10:59:31.001]                 }
[10:59:31.001]                 {
[10:59:31.001]                   {
[10:59:31.001]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.001]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.001]                     1047550554L), envir = base::globalenv(), 
[10:59:31.001]                       inherits = FALSE)
[10:59:31.001]                     NULL
[10:59:31.001]                   }
[10:59:31.001]                   options(future.plan = NULL)
[10:59:31.001]                   if (is.na(NA_character_)) 
[10:59:31.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.001]                     .init = FALSE)
[10:59:31.001]                 }
[10:59:31.001]             }
[10:59:31.001]         }
[10:59:31.001]     })
[10:59:31.001]     if (TRUE) {
[10:59:31.001]         base::sink(type = "output", split = FALSE)
[10:59:31.001]         if (TRUE) {
[10:59:31.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.001]         }
[10:59:31.001]         else {
[10:59:31.001]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.001]         }
[10:59:31.001]         base::close(...future.stdout)
[10:59:31.001]         ...future.stdout <- NULL
[10:59:31.001]     }
[10:59:31.001]     ...future.result$conditions <- ...future.conditions
[10:59:31.001]     ...future.result$finished <- base::Sys.time()
[10:59:31.001]     ...future.result
[10:59:31.001] }
[10:59:31.003] assign_globals() ...
[10:59:31.003] List of 5
[10:59:31.003]  $ ...future.FUN            :function (x, ...)  
[10:59:31.003]  $ MoreArgs                 : NULL
[10:59:31.003]  $ ...future.elements_ii    :List of 2
[10:59:31.003]   ..$ :List of 4
[10:59:31.003]   .. ..$ : int 1
[10:59:31.003]   .. ..$ : int 2
[10:59:31.003]   .. ..$ : int 3
[10:59:31.003]   .. ..$ : int 4
[10:59:31.003]   ..$ :List of 4
[10:59:31.003]   .. ..$ : int 4
[10:59:31.003]   .. ..$ : int 3
[10:59:31.003]   .. ..$ : int 2
[10:59:31.003]   .. ..$ : int 1
[10:59:31.003]  $ ...future.seeds_ii       : NULL
[10:59:31.003]  $ ...future.globals.maxSize: NULL
[10:59:31.003]  - attr(*, "where")=List of 5
[10:59:31.003]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.003]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.003]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.003]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.003]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.003]  - attr(*, "resolved")= logi FALSE
[10:59:31.003]  - attr(*, "total_size")= num 258
[10:59:31.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.003]  - attr(*, "already-done")= logi TRUE
[10:59:31.010] - copied ‘...future.FUN’ to environment
[10:59:31.010] - copied ‘MoreArgs’ to environment
[10:59:31.010] - copied ‘...future.elements_ii’ to environment
[10:59:31.010] - copied ‘...future.seeds_ii’ to environment
[10:59:31.010] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.011] assign_globals() ... done
[10:59:31.011] plan(): Setting new future strategy stack:
[10:59:31.011] List of future strategies:
[10:59:31.011] 1. sequential:
[10:59:31.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.011]    - tweaked: FALSE
[10:59:31.011]    - call: NULL
[10:59:31.011] plan(): nbrOfWorkers() = 1
[10:59:31.012] plan(): Setting new future strategy stack:
[10:59:31.012] List of future strategies:
[10:59:31.012] 1. sequential:
[10:59:31.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.012]    - tweaked: FALSE
[10:59:31.012]    - call: plan(strategy)
[10:59:31.012] plan(): nbrOfWorkers() = 1
[10:59:31.013] SequentialFuture started (and completed)
[10:59:31.013] - Launch lazy future ... done
[10:59:31.013] run() for ‘SequentialFuture’ ... done
[10:59:31.013] Created future:
[10:59:31.013] SequentialFuture:
[10:59:31.013] Label: ‘future_mapply-1’
[10:59:31.013] Expression:
[10:59:31.013] {
[10:59:31.013]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.013]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.013]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.013]         on.exit(options(oopts), add = TRUE)
[10:59:31.013]     }
[10:59:31.013]     {
[10:59:31.013]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.013]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.013]         do.call(mapply, args = args)
[10:59:31.013]     }
[10:59:31.013] }
[10:59:31.013] Lazy evaluation: FALSE
[10:59:31.013] Asynchronous evaluation: FALSE
[10:59:31.013] Local evaluation: TRUE
[10:59:31.013] Environment: R_GlobalEnv
[10:59:31.013] Capture standard output: TRUE
[10:59:31.013] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.013] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.013] Packages: <none>
[10:59:31.013] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.013] Resolved: TRUE
[10:59:31.013] Value: 103 bytes of class ‘list’
[10:59:31.013] Early signaling: FALSE
[10:59:31.013] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.013] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.014] Chunk #1 of 1 ... DONE
[10:59:31.014] Launching 1 futures (chunks) ... DONE
[10:59:31.014] Resolving 1 futures (chunks) ...
[10:59:31.014] resolve() on list ...
[10:59:31.014]  recursive: 0
[10:59:31.014]  length: 1
[10:59:31.014] 
[10:59:31.014] resolved() for ‘SequentialFuture’ ...
[10:59:31.014] - state: ‘finished’
[10:59:31.014] - run: TRUE
[10:59:31.014] - result: ‘FutureResult’
[10:59:31.015] resolved() for ‘SequentialFuture’ ... done
[10:59:31.015] Future #1
[10:59:31.015] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.015] - nx: 1
[10:59:31.015] - relay: TRUE
[10:59:31.015] - stdout: TRUE
[10:59:31.015] - signal: TRUE
[10:59:31.015] - resignal: FALSE
[10:59:31.015] - force: TRUE
[10:59:31.015] - relayed: [n=1] FALSE
[10:59:31.015] - queued futures: [n=1] FALSE
[10:59:31.015]  - until=1
[10:59:31.016]  - relaying element #1
[10:59:31.016] - relayed: [n=1] TRUE
[10:59:31.016] - queued futures: [n=1] TRUE
[10:59:31.016] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.016]  length: 0 (resolved future 1)
[10:59:31.016] Relaying remaining futures
[10:59:31.016] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.016] - nx: 1
[10:59:31.016] - relay: TRUE
[10:59:31.016] - stdout: TRUE
[10:59:31.016] - signal: TRUE
[10:59:31.016] - resignal: FALSE
[10:59:31.017] - force: TRUE
[10:59:31.017] - relayed: [n=1] TRUE
[10:59:31.017] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.017] - relayed: [n=1] TRUE
[10:59:31.017] - queued futures: [n=1] TRUE
[10:59:31.017] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.017] resolve() on list ... DONE
[10:59:31.017]  - Number of value chunks collected: 1
[10:59:31.017] Resolving 1 futures (chunks) ... DONE
[10:59:31.017] Reducing values from 1 chunks ...
[10:59:31.017]  - Number of values collected after concatenation: 4
[10:59:31.017]  - Number of values expected: 4
[10:59:31.018] Reducing values from 1 chunks ... DONE
[10:59:31.018] future_mapply() ... DONE
[10:59:31.018] future_mapply() ...
[10:59:31.018] Number of chunks: 1
[10:59:31.018] getGlobalsAndPackagesXApply() ...
[10:59:31.018]  - future.globals: TRUE
[10:59:31.018] getGlobalsAndPackages() ...
[10:59:31.018] Searching for globals...
[10:59:31.019] - globals found: [1] ‘FUN’
[10:59:31.019] Searching for globals ... DONE
[10:59:31.019] Resolving globals: FALSE
[10:59:31.019] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:31.019] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:31.019] - globals: [1] ‘FUN’
[10:59:31.020] 
[10:59:31.020] getGlobalsAndPackages() ... DONE
[10:59:31.020]  - globals found/used: [n=1] ‘FUN’
[10:59:31.020]  - needed namespaces: [n=0] 
[10:59:31.020] Finding globals ... DONE
[10:59:31.020] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.020] List of 2
[10:59:31.020]  $ ...future.FUN:function (x, ...)  
[10:59:31.020]  $ MoreArgs     : NULL
[10:59:31.020]  - attr(*, "where")=List of 2
[10:59:31.020]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.020]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.020]  - attr(*, "resolved")= logi FALSE
[10:59:31.020]  - attr(*, "total_size")= num NA
[10:59:31.022] Packages to be attached in all futures: [n=0] 
[10:59:31.022] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.023] Number of futures (= number of chunks): 1
[10:59:31.023] Launching 1 futures (chunks) ...
[10:59:31.023] Chunk #1 of 1 ...
[10:59:31.023]  - Finding globals in '...' for chunk #1 ...
[10:59:31.023] getGlobalsAndPackages() ...
[10:59:31.023] Searching for globals...
[10:59:31.023] 
[10:59:31.023] Searching for globals ... DONE
[10:59:31.023] - globals: [0] <none>
[10:59:31.024] getGlobalsAndPackages() ... DONE
[10:59:31.024]    + additional globals found: [n=0] 
[10:59:31.024]    + additional namespaces needed: [n=0] 
[10:59:31.024]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.024]  - seeds: <none>
[10:59:31.024]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.024] getGlobalsAndPackages() ...
[10:59:31.024] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.024] Resolving globals: FALSE
[10:59:31.025] The total size of the 5 globals is 313 bytes (313 bytes)
[10:59:31.025] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 313 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (198 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.025] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.025] 
[10:59:31.025] getGlobalsAndPackages() ... DONE
[10:59:31.025] run() for ‘Future’ ...
[10:59:31.026] - state: ‘created’
[10:59:31.026] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.026] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.026]   - Field: ‘label’
[10:59:31.026]   - Field: ‘local’
[10:59:31.026]   - Field: ‘owner’
[10:59:31.026]   - Field: ‘envir’
[10:59:31.026]   - Field: ‘packages’
[10:59:31.026]   - Field: ‘gc’
[10:59:31.027]   - Field: ‘conditions’
[10:59:31.027]   - Field: ‘expr’
[10:59:31.027]   - Field: ‘uuid’
[10:59:31.027]   - Field: ‘seed’
[10:59:31.027]   - Field: ‘version’
[10:59:31.027]   - Field: ‘result’
[10:59:31.027]   - Field: ‘asynchronous’
[10:59:31.027]   - Field: ‘calls’
[10:59:31.027]   - Field: ‘globals’
[10:59:31.027]   - Field: ‘stdout’
[10:59:31.027]   - Field: ‘earlySignal’
[10:59:31.027]   - Field: ‘lazy’
[10:59:31.027]   - Field: ‘state’
[10:59:31.028] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.028] - Launch lazy future ...
[10:59:31.028] Packages needed by the future expression (n = 0): <none>
[10:59:31.028] Packages needed by future strategies (n = 0): <none>
[10:59:31.028] {
[10:59:31.028]     {
[10:59:31.028]         {
[10:59:31.028]             ...future.startTime <- base::Sys.time()
[10:59:31.028]             {
[10:59:31.028]                 {
[10:59:31.028]                   {
[10:59:31.028]                     base::local({
[10:59:31.028]                       has_future <- base::requireNamespace("future", 
[10:59:31.028]                         quietly = TRUE)
[10:59:31.028]                       if (has_future) {
[10:59:31.028]                         ns <- base::getNamespace("future")
[10:59:31.028]                         version <- ns[[".package"]][["version"]]
[10:59:31.028]                         if (is.null(version)) 
[10:59:31.028]                           version <- utils::packageVersion("future")
[10:59:31.028]                       }
[10:59:31.028]                       else {
[10:59:31.028]                         version <- NULL
[10:59:31.028]                       }
[10:59:31.028]                       if (!has_future || version < "1.8.0") {
[10:59:31.028]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.028]                           "", base::R.version$version.string), 
[10:59:31.028]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.028]                             "release", "version")], collapse = " "), 
[10:59:31.028]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.028]                           info)
[10:59:31.028]                         info <- base::paste(info, collapse = "; ")
[10:59:31.028]                         if (!has_future) {
[10:59:31.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.028]                             info)
[10:59:31.028]                         }
[10:59:31.028]                         else {
[10:59:31.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.028]                             info, version)
[10:59:31.028]                         }
[10:59:31.028]                         base::stop(msg)
[10:59:31.028]                       }
[10:59:31.028]                     })
[10:59:31.028]                   }
[10:59:31.028]                   ...future.strategy.old <- future::plan("list")
[10:59:31.028]                   options(future.plan = NULL)
[10:59:31.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.028]                 }
[10:59:31.028]                 ...future.workdir <- getwd()
[10:59:31.028]             }
[10:59:31.028]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.028]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.028]         }
[10:59:31.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.028]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.028]             base::names(...future.oldOptions))
[10:59:31.028]     }
[10:59:31.028]     if (FALSE) {
[10:59:31.028]     }
[10:59:31.028]     else {
[10:59:31.028]         if (TRUE) {
[10:59:31.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.028]                 open = "w")
[10:59:31.028]         }
[10:59:31.028]         else {
[10:59:31.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.028]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.028]         }
[10:59:31.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.028]             base::sink(type = "output", split = FALSE)
[10:59:31.028]             base::close(...future.stdout)
[10:59:31.028]         }, add = TRUE)
[10:59:31.028]     }
[10:59:31.028]     ...future.frame <- base::sys.nframe()
[10:59:31.028]     ...future.conditions <- base::list()
[10:59:31.028]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.028]     if (FALSE) {
[10:59:31.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.028]     }
[10:59:31.028]     ...future.result <- base::tryCatch({
[10:59:31.028]         base::withCallingHandlers({
[10:59:31.028]             ...future.value <- base::withVisible(base::local({
[10:59:31.028]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.028]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.028]                   ...future.globals.maxSize)) {
[10:59:31.028]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.028]                   on.exit(options(oopts), add = TRUE)
[10:59:31.028]                 }
[10:59:31.028]                 {
[10:59:31.028]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.028]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.028]                     USE.NAMES = FALSE)
[10:59:31.028]                   do.call(mapply, args = args)
[10:59:31.028]                 }
[10:59:31.028]             }))
[10:59:31.028]             future::FutureResult(value = ...future.value$value, 
[10:59:31.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.028]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.028]                     ...future.globalenv.names))
[10:59:31.028]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.028]         }, condition = base::local({
[10:59:31.028]             c <- base::c
[10:59:31.028]             inherits <- base::inherits
[10:59:31.028]             invokeRestart <- base::invokeRestart
[10:59:31.028]             length <- base::length
[10:59:31.028]             list <- base::list
[10:59:31.028]             seq.int <- base::seq.int
[10:59:31.028]             signalCondition <- base::signalCondition
[10:59:31.028]             sys.calls <- base::sys.calls
[10:59:31.028]             `[[` <- base::`[[`
[10:59:31.028]             `+` <- base::`+`
[10:59:31.028]             `<<-` <- base::`<<-`
[10:59:31.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.028]                   3L)]
[10:59:31.028]             }
[10:59:31.028]             function(cond) {
[10:59:31.028]                 is_error <- inherits(cond, "error")
[10:59:31.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.028]                   NULL)
[10:59:31.028]                 if (is_error) {
[10:59:31.028]                   sessionInformation <- function() {
[10:59:31.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.028]                       search = base::search(), system = base::Sys.info())
[10:59:31.028]                   }
[10:59:31.028]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.028]                     cond$call), session = sessionInformation(), 
[10:59:31.028]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.028]                   signalCondition(cond)
[10:59:31.028]                 }
[10:59:31.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.028]                 "immediateCondition"))) {
[10:59:31.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.028]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.028]                   if (TRUE && !signal) {
[10:59:31.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.028]                     {
[10:59:31.028]                       inherits <- base::inherits
[10:59:31.028]                       invokeRestart <- base::invokeRestart
[10:59:31.028]                       is.null <- base::is.null
[10:59:31.028]                       muffled <- FALSE
[10:59:31.028]                       if (inherits(cond, "message")) {
[10:59:31.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.028]                         if (muffled) 
[10:59:31.028]                           invokeRestart("muffleMessage")
[10:59:31.028]                       }
[10:59:31.028]                       else if (inherits(cond, "warning")) {
[10:59:31.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.028]                         if (muffled) 
[10:59:31.028]                           invokeRestart("muffleWarning")
[10:59:31.028]                       }
[10:59:31.028]                       else if (inherits(cond, "condition")) {
[10:59:31.028]                         if (!is.null(pattern)) {
[10:59:31.028]                           computeRestarts <- base::computeRestarts
[10:59:31.028]                           grepl <- base::grepl
[10:59:31.028]                           restarts <- computeRestarts(cond)
[10:59:31.028]                           for (restart in restarts) {
[10:59:31.028]                             name <- restart$name
[10:59:31.028]                             if (is.null(name)) 
[10:59:31.028]                               next
[10:59:31.028]                             if (!grepl(pattern, name)) 
[10:59:31.028]                               next
[10:59:31.028]                             invokeRestart(restart)
[10:59:31.028]                             muffled <- TRUE
[10:59:31.028]                             break
[10:59:31.028]                           }
[10:59:31.028]                         }
[10:59:31.028]                       }
[10:59:31.028]                       invisible(muffled)
[10:59:31.028]                     }
[10:59:31.028]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.028]                   }
[10:59:31.028]                 }
[10:59:31.028]                 else {
[10:59:31.028]                   if (TRUE) {
[10:59:31.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.028]                     {
[10:59:31.028]                       inherits <- base::inherits
[10:59:31.028]                       invokeRestart <- base::invokeRestart
[10:59:31.028]                       is.null <- base::is.null
[10:59:31.028]                       muffled <- FALSE
[10:59:31.028]                       if (inherits(cond, "message")) {
[10:59:31.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.028]                         if (muffled) 
[10:59:31.028]                           invokeRestart("muffleMessage")
[10:59:31.028]                       }
[10:59:31.028]                       else if (inherits(cond, "warning")) {
[10:59:31.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.028]                         if (muffled) 
[10:59:31.028]                           invokeRestart("muffleWarning")
[10:59:31.028]                       }
[10:59:31.028]                       else if (inherits(cond, "condition")) {
[10:59:31.028]                         if (!is.null(pattern)) {
[10:59:31.028]                           computeRestarts <- base::computeRestarts
[10:59:31.028]                           grepl <- base::grepl
[10:59:31.028]                           restarts <- computeRestarts(cond)
[10:59:31.028]                           for (restart in restarts) {
[10:59:31.028]                             name <- restart$name
[10:59:31.028]                             if (is.null(name)) 
[10:59:31.028]                               next
[10:59:31.028]                             if (!grepl(pattern, name)) 
[10:59:31.028]                               next
[10:59:31.028]                             invokeRestart(restart)
[10:59:31.028]                             muffled <- TRUE
[10:59:31.028]                             break
[10:59:31.028]                           }
[10:59:31.028]                         }
[10:59:31.028]                       }
[10:59:31.028]                       invisible(muffled)
[10:59:31.028]                     }
[10:59:31.028]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.028]                   }
[10:59:31.028]                 }
[10:59:31.028]             }
[10:59:31.028]         }))
[10:59:31.028]     }, error = function(ex) {
[10:59:31.028]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.028]                 ...future.rng), started = ...future.startTime, 
[10:59:31.028]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.028]             version = "1.8"), class = "FutureResult")
[10:59:31.028]     }, finally = {
[10:59:31.028]         if (!identical(...future.workdir, getwd())) 
[10:59:31.028]             setwd(...future.workdir)
[10:59:31.028]         {
[10:59:31.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.028]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.028]             }
[10:59:31.028]             base::options(...future.oldOptions)
[10:59:31.028]             if (.Platform$OS.type == "windows") {
[10:59:31.028]                 old_names <- names(...future.oldEnvVars)
[10:59:31.028]                 envs <- base::Sys.getenv()
[10:59:31.028]                 names <- names(envs)
[10:59:31.028]                 common <- intersect(names, old_names)
[10:59:31.028]                 added <- setdiff(names, old_names)
[10:59:31.028]                 removed <- setdiff(old_names, names)
[10:59:31.028]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.028]                   envs[common]]
[10:59:31.028]                 NAMES <- toupper(changed)
[10:59:31.028]                 args <- list()
[10:59:31.028]                 for (kk in seq_along(NAMES)) {
[10:59:31.028]                   name <- changed[[kk]]
[10:59:31.028]                   NAME <- NAMES[[kk]]
[10:59:31.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.028]                     next
[10:59:31.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.028]                 }
[10:59:31.028]                 NAMES <- toupper(added)
[10:59:31.028]                 for (kk in seq_along(NAMES)) {
[10:59:31.028]                   name <- added[[kk]]
[10:59:31.028]                   NAME <- NAMES[[kk]]
[10:59:31.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.028]                     next
[10:59:31.028]                   args[[name]] <- ""
[10:59:31.028]                 }
[10:59:31.028]                 NAMES <- toupper(removed)
[10:59:31.028]                 for (kk in seq_along(NAMES)) {
[10:59:31.028]                   name <- removed[[kk]]
[10:59:31.028]                   NAME <- NAMES[[kk]]
[10:59:31.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.028]                     next
[10:59:31.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.028]                 }
[10:59:31.028]                 if (length(args) > 0) 
[10:59:31.028]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.028]             }
[10:59:31.028]             else {
[10:59:31.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.028]             }
[10:59:31.028]             {
[10:59:31.028]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.028]                   0L) {
[10:59:31.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.028]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.028]                   base::options(opts)
[10:59:31.028]                 }
[10:59:31.028]                 {
[10:59:31.028]                   {
[10:59:31.028]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.028]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.028]                     1047550554L), envir = base::globalenv(), 
[10:59:31.028]                       inherits = FALSE)
[10:59:31.028]                     NULL
[10:59:31.028]                   }
[10:59:31.028]                   options(future.plan = NULL)
[10:59:31.028]                   if (is.na(NA_character_)) 
[10:59:31.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.028]                     .init = FALSE)
[10:59:31.028]                 }
[10:59:31.028]             }
[10:59:31.028]         }
[10:59:31.028]     })
[10:59:31.028]     if (TRUE) {
[10:59:31.028]         base::sink(type = "output", split = FALSE)
[10:59:31.028]         if (TRUE) {
[10:59:31.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.028]         }
[10:59:31.028]         else {
[10:59:31.028]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.028]         }
[10:59:31.028]         base::close(...future.stdout)
[10:59:31.028]         ...future.stdout <- NULL
[10:59:31.028]     }
[10:59:31.028]     ...future.result$conditions <- ...future.conditions
[10:59:31.028]     ...future.result$finished <- base::Sys.time()
[10:59:31.028]     ...future.result
[10:59:31.028] }
[10:59:31.030] assign_globals() ...
[10:59:31.030] List of 5
[10:59:31.030]  $ ...future.FUN            :function (x, ...)  
[10:59:31.030]  $ MoreArgs                 : NULL
[10:59:31.030]  $ ...future.elements_ii    :List of 2
[10:59:31.030]   ..$ times:List of 4
[10:59:31.030]   .. ..$ : int 1
[10:59:31.030]   .. ..$ : int 2
[10:59:31.030]   .. ..$ : int 3
[10:59:31.030]   .. ..$ : int 4
[10:59:31.030]   ..$ x    :List of 4
[10:59:31.030]   .. ..$ : int 4
[10:59:31.030]   .. ..$ : int 3
[10:59:31.030]   .. ..$ : int 2
[10:59:31.030]   .. ..$ : int 1
[10:59:31.030]  $ ...future.seeds_ii       : NULL
[10:59:31.030]  $ ...future.globals.maxSize: NULL
[10:59:31.030]  - attr(*, "where")=List of 5
[10:59:31.030]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.030]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.030]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.030]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.030]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.030]  - attr(*, "resolved")= logi FALSE
[10:59:31.030]  - attr(*, "total_size")= num 313
[10:59:31.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.030]  - attr(*, "already-done")= logi TRUE
[10:59:31.037] - copied ‘...future.FUN’ to environment
[10:59:31.037] - copied ‘MoreArgs’ to environment
[10:59:31.037] - copied ‘...future.elements_ii’ to environment
[10:59:31.037] - copied ‘...future.seeds_ii’ to environment
[10:59:31.037] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.038] assign_globals() ... done
[10:59:31.038] plan(): Setting new future strategy stack:
[10:59:31.038] List of future strategies:
[10:59:31.038] 1. sequential:
[10:59:31.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.038]    - tweaked: FALSE
[10:59:31.038]    - call: NULL
[10:59:31.038] plan(): nbrOfWorkers() = 1
[10:59:31.039] plan(): Setting new future strategy stack:
[10:59:31.039] List of future strategies:
[10:59:31.039] 1. sequential:
[10:59:31.039]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.039]    - tweaked: FALSE
[10:59:31.039]    - call: plan(strategy)
[10:59:31.039] plan(): nbrOfWorkers() = 1
[10:59:31.040] SequentialFuture started (and completed)
[10:59:31.040] - Launch lazy future ... done
[10:59:31.040] run() for ‘SequentialFuture’ ... done
[10:59:31.040] Created future:
[10:59:31.040] SequentialFuture:
[10:59:31.040] Label: ‘future_mapply-1’
[10:59:31.040] Expression:
[10:59:31.040] {
[10:59:31.040]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.040]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.040]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.040]         on.exit(options(oopts), add = TRUE)
[10:59:31.040]     }
[10:59:31.040]     {
[10:59:31.040]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.040]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.040]         do.call(mapply, args = args)
[10:59:31.040]     }
[10:59:31.040] }
[10:59:31.040] Lazy evaluation: FALSE
[10:59:31.040] Asynchronous evaluation: FALSE
[10:59:31.040] Local evaluation: TRUE
[10:59:31.040] Environment: R_GlobalEnv
[10:59:31.040] Capture standard output: TRUE
[10:59:31.040] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.040] Globals: 5 objects totaling 313 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 198 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.040] Packages: <none>
[10:59:31.040] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.040] Resolved: TRUE
[10:59:31.040] Value: 103 bytes of class ‘list’
[10:59:31.040] Early signaling: FALSE
[10:59:31.040] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.040] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.041] Chunk #1 of 1 ... DONE
[10:59:31.041] Launching 1 futures (chunks) ... DONE
[10:59:31.041] Resolving 1 futures (chunks) ...
[10:59:31.041] resolve() on list ...
[10:59:31.041]  recursive: 0
[10:59:31.041]  length: 1
[10:59:31.041] 
[10:59:31.041] resolved() for ‘SequentialFuture’ ...
[10:59:31.041] - state: ‘finished’
[10:59:31.041] - run: TRUE
[10:59:31.042] - result: ‘FutureResult’
[10:59:31.042] resolved() for ‘SequentialFuture’ ... done
[10:59:31.042] Future #1
[10:59:31.042] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.042] - nx: 1
[10:59:31.042] - relay: TRUE
[10:59:31.042] - stdout: TRUE
[10:59:31.042] - signal: TRUE
[10:59:31.042] - resignal: FALSE
[10:59:31.042] - force: TRUE
[10:59:31.042] - relayed: [n=1] FALSE
[10:59:31.042] - queued futures: [n=1] FALSE
[10:59:31.043]  - until=1
[10:59:31.043]  - relaying element #1
[10:59:31.043] - relayed: [n=1] TRUE
[10:59:31.043] - queued futures: [n=1] TRUE
[10:59:31.043] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.043]  length: 0 (resolved future 1)
[10:59:31.043] Relaying remaining futures
[10:59:31.043] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.043] - nx: 1
[10:59:31.043] - relay: TRUE
[10:59:31.043] - stdout: TRUE
[10:59:31.043] - signal: TRUE
[10:59:31.044] - resignal: FALSE
[10:59:31.044] - force: TRUE
[10:59:31.044] - relayed: [n=1] TRUE
[10:59:31.044] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.044] - relayed: [n=1] TRUE
[10:59:31.044] - queued futures: [n=1] TRUE
[10:59:31.044] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.044] resolve() on list ... DONE
[10:59:31.044]  - Number of value chunks collected: 1
[10:59:31.044] Resolving 1 futures (chunks) ... DONE
[10:59:31.044] Reducing values from 1 chunks ...
[10:59:31.044]  - Number of values collected after concatenation: 4
[10:59:31.044]  - Number of values expected: 4
[10:59:31.045] Reducing values from 1 chunks ... DONE
[10:59:31.045] future_mapply() ... DONE
[10:59:31.045] future_mapply() ...
[10:59:31.045] Number of chunks: 1
[10:59:31.045] getGlobalsAndPackagesXApply() ...
[10:59:31.045]  - future.globals: TRUE
[10:59:31.045] getGlobalsAndPackages() ...
[10:59:31.045] Searching for globals...
[10:59:31.046] - globals found: [1] ‘FUN’
[10:59:31.046] Searching for globals ... DONE
[10:59:31.046] Resolving globals: FALSE
[10:59:31.046] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:31.046] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:31.047] - globals: [1] ‘FUN’
[10:59:31.047] 
[10:59:31.047] getGlobalsAndPackages() ... DONE
[10:59:31.047]  - globals found/used: [n=1] ‘FUN’
[10:59:31.047]  - needed namespaces: [n=0] 
[10:59:31.047] Finding globals ... DONE
[10:59:31.047] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.047] List of 2
[10:59:31.047]  $ ...future.FUN:function (x, ...)  
[10:59:31.047]  $ MoreArgs     :List of 1
[10:59:31.047]   ..$ x: num 42
[10:59:31.047]  - attr(*, "where")=List of 2
[10:59:31.047]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.047]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.047]  - attr(*, "resolved")= logi FALSE
[10:59:31.047]  - attr(*, "total_size")= num NA
[10:59:31.050] Packages to be attached in all futures: [n=0] 
[10:59:31.050] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.050] Number of futures (= number of chunks): 1
[10:59:31.050] Launching 1 futures (chunks) ...
[10:59:31.050] Chunk #1 of 1 ...
[10:59:31.050]  - Finding globals in '...' for chunk #1 ...
[10:59:31.050] getGlobalsAndPackages() ...
[10:59:31.051] Searching for globals...
[10:59:31.051] 
[10:59:31.051] Searching for globals ... DONE
[10:59:31.051] - globals: [0] <none>
[10:59:31.051] getGlobalsAndPackages() ... DONE
[10:59:31.051]    + additional globals found: [n=0] 
[10:59:31.051]    + additional namespaces needed: [n=0] 
[10:59:31.052]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.052]  - seeds: <none>
[10:59:31.052]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.052] getGlobalsAndPackages() ...
[10:59:31.052] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.053] Resolving globals: FALSE
[10:59:31.053] The total size of the 5 globals is 310 bytes (310 bytes)
[10:59:31.053] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 310 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (133 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:59:31.053] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.053] 
[10:59:31.054] getGlobalsAndPackages() ... DONE
[10:59:31.054] run() for ‘Future’ ...
[10:59:31.054] - state: ‘created’
[10:59:31.054] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.054] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.054]   - Field: ‘label’
[10:59:31.055]   - Field: ‘local’
[10:59:31.055]   - Field: ‘owner’
[10:59:31.055]   - Field: ‘envir’
[10:59:31.055]   - Field: ‘packages’
[10:59:31.055]   - Field: ‘gc’
[10:59:31.055]   - Field: ‘conditions’
[10:59:31.055]   - Field: ‘expr’
[10:59:31.055]   - Field: ‘uuid’
[10:59:31.055]   - Field: ‘seed’
[10:59:31.055]   - Field: ‘version’
[10:59:31.055]   - Field: ‘result’
[10:59:31.055]   - Field: ‘asynchronous’
[10:59:31.055]   - Field: ‘calls’
[10:59:31.056]   - Field: ‘globals’
[10:59:31.056]   - Field: ‘stdout’
[10:59:31.056]   - Field: ‘earlySignal’
[10:59:31.056]   - Field: ‘lazy’
[10:59:31.056]   - Field: ‘state’
[10:59:31.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.056] - Launch lazy future ...
[10:59:31.056] Packages needed by the future expression (n = 0): <none>
[10:59:31.056] Packages needed by future strategies (n = 0): <none>
[10:59:31.057] {
[10:59:31.057]     {
[10:59:31.057]         {
[10:59:31.057]             ...future.startTime <- base::Sys.time()
[10:59:31.057]             {
[10:59:31.057]                 {
[10:59:31.057]                   {
[10:59:31.057]                     base::local({
[10:59:31.057]                       has_future <- base::requireNamespace("future", 
[10:59:31.057]                         quietly = TRUE)
[10:59:31.057]                       if (has_future) {
[10:59:31.057]                         ns <- base::getNamespace("future")
[10:59:31.057]                         version <- ns[[".package"]][["version"]]
[10:59:31.057]                         if (is.null(version)) 
[10:59:31.057]                           version <- utils::packageVersion("future")
[10:59:31.057]                       }
[10:59:31.057]                       else {
[10:59:31.057]                         version <- NULL
[10:59:31.057]                       }
[10:59:31.057]                       if (!has_future || version < "1.8.0") {
[10:59:31.057]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.057]                           "", base::R.version$version.string), 
[10:59:31.057]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.057]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.057]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.057]                             "release", "version")], collapse = " "), 
[10:59:31.057]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.057]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.057]                           info)
[10:59:31.057]                         info <- base::paste(info, collapse = "; ")
[10:59:31.057]                         if (!has_future) {
[10:59:31.057]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.057]                             info)
[10:59:31.057]                         }
[10:59:31.057]                         else {
[10:59:31.057]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.057]                             info, version)
[10:59:31.057]                         }
[10:59:31.057]                         base::stop(msg)
[10:59:31.057]                       }
[10:59:31.057]                     })
[10:59:31.057]                   }
[10:59:31.057]                   ...future.strategy.old <- future::plan("list")
[10:59:31.057]                   options(future.plan = NULL)
[10:59:31.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.057]                 }
[10:59:31.057]                 ...future.workdir <- getwd()
[10:59:31.057]             }
[10:59:31.057]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.057]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.057]         }
[10:59:31.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.057]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.057]             base::names(...future.oldOptions))
[10:59:31.057]     }
[10:59:31.057]     if (FALSE) {
[10:59:31.057]     }
[10:59:31.057]     else {
[10:59:31.057]         if (TRUE) {
[10:59:31.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.057]                 open = "w")
[10:59:31.057]         }
[10:59:31.057]         else {
[10:59:31.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.057]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.057]         }
[10:59:31.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.057]             base::sink(type = "output", split = FALSE)
[10:59:31.057]             base::close(...future.stdout)
[10:59:31.057]         }, add = TRUE)
[10:59:31.057]     }
[10:59:31.057]     ...future.frame <- base::sys.nframe()
[10:59:31.057]     ...future.conditions <- base::list()
[10:59:31.057]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.057]     if (FALSE) {
[10:59:31.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.057]     }
[10:59:31.057]     ...future.result <- base::tryCatch({
[10:59:31.057]         base::withCallingHandlers({
[10:59:31.057]             ...future.value <- base::withVisible(base::local({
[10:59:31.057]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.057]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.057]                   ...future.globals.maxSize)) {
[10:59:31.057]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.057]                   on.exit(options(oopts), add = TRUE)
[10:59:31.057]                 }
[10:59:31.057]                 {
[10:59:31.057]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.057]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.057]                     USE.NAMES = FALSE)
[10:59:31.057]                   do.call(mapply, args = args)
[10:59:31.057]                 }
[10:59:31.057]             }))
[10:59:31.057]             future::FutureResult(value = ...future.value$value, 
[10:59:31.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.057]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.057]                     ...future.globalenv.names))
[10:59:31.057]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.057]         }, condition = base::local({
[10:59:31.057]             c <- base::c
[10:59:31.057]             inherits <- base::inherits
[10:59:31.057]             invokeRestart <- base::invokeRestart
[10:59:31.057]             length <- base::length
[10:59:31.057]             list <- base::list
[10:59:31.057]             seq.int <- base::seq.int
[10:59:31.057]             signalCondition <- base::signalCondition
[10:59:31.057]             sys.calls <- base::sys.calls
[10:59:31.057]             `[[` <- base::`[[`
[10:59:31.057]             `+` <- base::`+`
[10:59:31.057]             `<<-` <- base::`<<-`
[10:59:31.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.057]                   3L)]
[10:59:31.057]             }
[10:59:31.057]             function(cond) {
[10:59:31.057]                 is_error <- inherits(cond, "error")
[10:59:31.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.057]                   NULL)
[10:59:31.057]                 if (is_error) {
[10:59:31.057]                   sessionInformation <- function() {
[10:59:31.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.057]                       search = base::search(), system = base::Sys.info())
[10:59:31.057]                   }
[10:59:31.057]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.057]                     cond$call), session = sessionInformation(), 
[10:59:31.057]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.057]                   signalCondition(cond)
[10:59:31.057]                 }
[10:59:31.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.057]                 "immediateCondition"))) {
[10:59:31.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.057]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.057]                   if (TRUE && !signal) {
[10:59:31.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.057]                     {
[10:59:31.057]                       inherits <- base::inherits
[10:59:31.057]                       invokeRestart <- base::invokeRestart
[10:59:31.057]                       is.null <- base::is.null
[10:59:31.057]                       muffled <- FALSE
[10:59:31.057]                       if (inherits(cond, "message")) {
[10:59:31.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.057]                         if (muffled) 
[10:59:31.057]                           invokeRestart("muffleMessage")
[10:59:31.057]                       }
[10:59:31.057]                       else if (inherits(cond, "warning")) {
[10:59:31.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.057]                         if (muffled) 
[10:59:31.057]                           invokeRestart("muffleWarning")
[10:59:31.057]                       }
[10:59:31.057]                       else if (inherits(cond, "condition")) {
[10:59:31.057]                         if (!is.null(pattern)) {
[10:59:31.057]                           computeRestarts <- base::computeRestarts
[10:59:31.057]                           grepl <- base::grepl
[10:59:31.057]                           restarts <- computeRestarts(cond)
[10:59:31.057]                           for (restart in restarts) {
[10:59:31.057]                             name <- restart$name
[10:59:31.057]                             if (is.null(name)) 
[10:59:31.057]                               next
[10:59:31.057]                             if (!grepl(pattern, name)) 
[10:59:31.057]                               next
[10:59:31.057]                             invokeRestart(restart)
[10:59:31.057]                             muffled <- TRUE
[10:59:31.057]                             break
[10:59:31.057]                           }
[10:59:31.057]                         }
[10:59:31.057]                       }
[10:59:31.057]                       invisible(muffled)
[10:59:31.057]                     }
[10:59:31.057]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.057]                   }
[10:59:31.057]                 }
[10:59:31.057]                 else {
[10:59:31.057]                   if (TRUE) {
[10:59:31.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.057]                     {
[10:59:31.057]                       inherits <- base::inherits
[10:59:31.057]                       invokeRestart <- base::invokeRestart
[10:59:31.057]                       is.null <- base::is.null
[10:59:31.057]                       muffled <- FALSE
[10:59:31.057]                       if (inherits(cond, "message")) {
[10:59:31.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.057]                         if (muffled) 
[10:59:31.057]                           invokeRestart("muffleMessage")
[10:59:31.057]                       }
[10:59:31.057]                       else if (inherits(cond, "warning")) {
[10:59:31.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.057]                         if (muffled) 
[10:59:31.057]                           invokeRestart("muffleWarning")
[10:59:31.057]                       }
[10:59:31.057]                       else if (inherits(cond, "condition")) {
[10:59:31.057]                         if (!is.null(pattern)) {
[10:59:31.057]                           computeRestarts <- base::computeRestarts
[10:59:31.057]                           grepl <- base::grepl
[10:59:31.057]                           restarts <- computeRestarts(cond)
[10:59:31.057]                           for (restart in restarts) {
[10:59:31.057]                             name <- restart$name
[10:59:31.057]                             if (is.null(name)) 
[10:59:31.057]                               next
[10:59:31.057]                             if (!grepl(pattern, name)) 
[10:59:31.057]                               next
[10:59:31.057]                             invokeRestart(restart)
[10:59:31.057]                             muffled <- TRUE
[10:59:31.057]                             break
[10:59:31.057]                           }
[10:59:31.057]                         }
[10:59:31.057]                       }
[10:59:31.057]                       invisible(muffled)
[10:59:31.057]                     }
[10:59:31.057]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.057]                   }
[10:59:31.057]                 }
[10:59:31.057]             }
[10:59:31.057]         }))
[10:59:31.057]     }, error = function(ex) {
[10:59:31.057]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.057]                 ...future.rng), started = ...future.startTime, 
[10:59:31.057]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.057]             version = "1.8"), class = "FutureResult")
[10:59:31.057]     }, finally = {
[10:59:31.057]         if (!identical(...future.workdir, getwd())) 
[10:59:31.057]             setwd(...future.workdir)
[10:59:31.057]         {
[10:59:31.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.057]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.057]             }
[10:59:31.057]             base::options(...future.oldOptions)
[10:59:31.057]             if (.Platform$OS.type == "windows") {
[10:59:31.057]                 old_names <- names(...future.oldEnvVars)
[10:59:31.057]                 envs <- base::Sys.getenv()
[10:59:31.057]                 names <- names(envs)
[10:59:31.057]                 common <- intersect(names, old_names)
[10:59:31.057]                 added <- setdiff(names, old_names)
[10:59:31.057]                 removed <- setdiff(old_names, names)
[10:59:31.057]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.057]                   envs[common]]
[10:59:31.057]                 NAMES <- toupper(changed)
[10:59:31.057]                 args <- list()
[10:59:31.057]                 for (kk in seq_along(NAMES)) {
[10:59:31.057]                   name <- changed[[kk]]
[10:59:31.057]                   NAME <- NAMES[[kk]]
[10:59:31.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.057]                     next
[10:59:31.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.057]                 }
[10:59:31.057]                 NAMES <- toupper(added)
[10:59:31.057]                 for (kk in seq_along(NAMES)) {
[10:59:31.057]                   name <- added[[kk]]
[10:59:31.057]                   NAME <- NAMES[[kk]]
[10:59:31.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.057]                     next
[10:59:31.057]                   args[[name]] <- ""
[10:59:31.057]                 }
[10:59:31.057]                 NAMES <- toupper(removed)
[10:59:31.057]                 for (kk in seq_along(NAMES)) {
[10:59:31.057]                   name <- removed[[kk]]
[10:59:31.057]                   NAME <- NAMES[[kk]]
[10:59:31.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.057]                     next
[10:59:31.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.057]                 }
[10:59:31.057]                 if (length(args) > 0) 
[10:59:31.057]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.057]             }
[10:59:31.057]             else {
[10:59:31.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.057]             }
[10:59:31.057]             {
[10:59:31.057]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.057]                   0L) {
[10:59:31.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.057]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.057]                   base::options(opts)
[10:59:31.057]                 }
[10:59:31.057]                 {
[10:59:31.057]                   {
[10:59:31.057]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.057]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.057]                     1047550554L), envir = base::globalenv(), 
[10:59:31.057]                       inherits = FALSE)
[10:59:31.057]                     NULL
[10:59:31.057]                   }
[10:59:31.057]                   options(future.plan = NULL)
[10:59:31.057]                   if (is.na(NA_character_)) 
[10:59:31.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.057]                     .init = FALSE)
[10:59:31.057]                 }
[10:59:31.057]             }
[10:59:31.057]         }
[10:59:31.057]     })
[10:59:31.057]     if (TRUE) {
[10:59:31.057]         base::sink(type = "output", split = FALSE)
[10:59:31.057]         if (TRUE) {
[10:59:31.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.057]         }
[10:59:31.057]         else {
[10:59:31.057]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.057]         }
[10:59:31.057]         base::close(...future.stdout)
[10:59:31.057]         ...future.stdout <- NULL
[10:59:31.057]     }
[10:59:31.057]     ...future.result$conditions <- ...future.conditions
[10:59:31.057]     ...future.result$finished <- base::Sys.time()
[10:59:31.057]     ...future.result
[10:59:31.057] }
[10:59:31.058] assign_globals() ...
[10:59:31.058] List of 5
[10:59:31.058]  $ ...future.FUN            :function (x, ...)  
[10:59:31.058]  $ MoreArgs                 :List of 1
[10:59:31.058]   ..$ x: num 42
[10:59:31.058]  $ ...future.elements_ii    :List of 1
[10:59:31.058]   ..$ times:List of 4
[10:59:31.058]   .. ..$ : int 1
[10:59:31.058]   .. ..$ : int 2
[10:59:31.058]   .. ..$ : int 3
[10:59:31.058]   .. ..$ : int 4
[10:59:31.058]  $ ...future.seeds_ii       : NULL
[10:59:31.058]  $ ...future.globals.maxSize: NULL
[10:59:31.058]  - attr(*, "where")=List of 5
[10:59:31.058]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.058]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.058]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.058]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.058]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.058]  - attr(*, "resolved")= logi FALSE
[10:59:31.058]  - attr(*, "total_size")= num 310
[10:59:31.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.058]  - attr(*, "already-done")= logi TRUE
[10:59:31.064] - copied ‘...future.FUN’ to environment
[10:59:31.064] - copied ‘MoreArgs’ to environment
[10:59:31.064] - copied ‘...future.elements_ii’ to environment
[10:59:31.064] - copied ‘...future.seeds_ii’ to environment
[10:59:31.064] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.064] assign_globals() ... done
[10:59:31.064] plan(): Setting new future strategy stack:
[10:59:31.064] List of future strategies:
[10:59:31.064] 1. sequential:
[10:59:31.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.064]    - tweaked: FALSE
[10:59:31.064]    - call: NULL
[10:59:31.065] plan(): nbrOfWorkers() = 1
[10:59:31.066] plan(): Setting new future strategy stack:
[10:59:31.066] List of future strategies:
[10:59:31.066] 1. sequential:
[10:59:31.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.066]    - tweaked: FALSE
[10:59:31.066]    - call: plan(strategy)
[10:59:31.066] plan(): nbrOfWorkers() = 1
[10:59:31.066] SequentialFuture started (and completed)
[10:59:31.066] - Launch lazy future ... done
[10:59:31.066] run() for ‘SequentialFuture’ ... done
[10:59:31.066] Created future:
[10:59:31.067] SequentialFuture:
[10:59:31.067] Label: ‘future_mapply-1’
[10:59:31.067] Expression:
[10:59:31.067] {
[10:59:31.067]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.067]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.067]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.067]         on.exit(options(oopts), add = TRUE)
[10:59:31.067]     }
[10:59:31.067]     {
[10:59:31.067]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.067]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.067]         do.call(mapply, args = args)
[10:59:31.067]     }
[10:59:31.067] }
[10:59:31.067] Lazy evaluation: FALSE
[10:59:31.067] Asynchronous evaluation: FALSE
[10:59:31.067] Local evaluation: TRUE
[10:59:31.067] Environment: R_GlobalEnv
[10:59:31.067] Capture standard output: TRUE
[10:59:31.067] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.067] Globals: 5 objects totaling 310 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 133 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.067] Packages: <none>
[10:59:31.067] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.067] Resolved: TRUE
[10:59:31.067] Value: 143 bytes of class ‘list’
[10:59:31.067] Early signaling: FALSE
[10:59:31.067] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.067] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.067] Chunk #1 of 1 ... DONE
[10:59:31.067] Launching 1 futures (chunks) ... DONE
[10:59:31.067] Resolving 1 futures (chunks) ...
[10:59:31.068] resolve() on list ...
[10:59:31.068]  recursive: 0
[10:59:31.068]  length: 1
[10:59:31.068] 
[10:59:31.068] resolved() for ‘SequentialFuture’ ...
[10:59:31.068] - state: ‘finished’
[10:59:31.068] - run: TRUE
[10:59:31.068] - result: ‘FutureResult’
[10:59:31.068] resolved() for ‘SequentialFuture’ ... done
[10:59:31.068] Future #1
[10:59:31.068] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.068] - nx: 1
[10:59:31.069] - relay: TRUE
[10:59:31.069] - stdout: TRUE
[10:59:31.069] - signal: TRUE
[10:59:31.069] - resignal: FALSE
[10:59:31.069] - force: TRUE
[10:59:31.069] - relayed: [n=1] FALSE
[10:59:31.069] - queued futures: [n=1] FALSE
[10:59:31.069]  - until=1
[10:59:31.069]  - relaying element #1
[10:59:31.069] - relayed: [n=1] TRUE
[10:59:31.069] - queued futures: [n=1] TRUE
[10:59:31.070] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.070]  length: 0 (resolved future 1)
[10:59:31.070] Relaying remaining futures
[10:59:31.070] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.070] - nx: 1
[10:59:31.070] - relay: TRUE
[10:59:31.070] - stdout: TRUE
[10:59:31.070] - signal: TRUE
[10:59:31.070] - resignal: FALSE
[10:59:31.070] - force: TRUE
[10:59:31.070] - relayed: [n=1] TRUE
[10:59:31.070] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.070] - relayed: [n=1] TRUE
[10:59:31.071] - queued futures: [n=1] TRUE
[10:59:31.071] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.071] resolve() on list ... DONE
[10:59:31.071]  - Number of value chunks collected: 1
[10:59:31.071] Resolving 1 futures (chunks) ... DONE
[10:59:31.071] Reducing values from 1 chunks ...
[10:59:31.071]  - Number of values collected after concatenation: 4
[10:59:31.071]  - Number of values expected: 4
[10:59:31.071] Reducing values from 1 chunks ... DONE
[10:59:31.071] future_mapply() ... DONE
[10:59:31.071] future_mapply() ...
[10:59:31.072] Number of chunks: 1
[10:59:31.072] getGlobalsAndPackagesXApply() ...
[10:59:31.072]  - future.globals: TRUE
[10:59:31.072] getGlobalsAndPackages() ...
[10:59:31.072] Searching for globals...
[10:59:31.073] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:59:31.073] Searching for globals ... DONE
[10:59:31.073] Resolving globals: FALSE
[10:59:31.074] The total size of the 1 globals is 414 bytes (414 bytes)
[10:59:31.075] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:59:31.075] - globals: [1] ‘FUN’
[10:59:31.075] 
[10:59:31.075] getGlobalsAndPackages() ... DONE
[10:59:31.075]  - globals found/used: [n=1] ‘FUN’
[10:59:31.076]  - needed namespaces: [n=0] 
[10:59:31.076] Finding globals ... DONE
[10:59:31.076] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.076] List of 2
[10:59:31.076]  $ ...future.FUN:function (x, y)  
[10:59:31.076]  $ MoreArgs     : NULL
[10:59:31.076]  - attr(*, "where")=List of 2
[10:59:31.076]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.076]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.076]  - attr(*, "resolved")= logi FALSE
[10:59:31.076]  - attr(*, "total_size")= num NA
[10:59:31.078] Packages to be attached in all futures: [n=0] 
[10:59:31.078] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.078] Number of futures (= number of chunks): 1
[10:59:31.079] Launching 1 futures (chunks) ...
[10:59:31.079] Chunk #1 of 1 ...
[10:59:31.079]  - Finding globals in '...' for chunk #1 ...
[10:59:31.079] getGlobalsAndPackages() ...
[10:59:31.079] Searching for globals...
[10:59:31.079] 
[10:59:31.079] Searching for globals ... DONE
[10:59:31.079] - globals: [0] <none>
[10:59:31.080] getGlobalsAndPackages() ... DONE
[10:59:31.080]    + additional globals found: [n=0] 
[10:59:31.080]    + additional namespaces needed: [n=0] 
[10:59:31.080]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.080]  - seeds: <none>
[10:59:31.080]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.080] getGlobalsAndPackages() ...
[10:59:31.080] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.080] Resolving globals: FALSE
[10:59:31.081] The total size of the 5 globals is 745 bytes (745 bytes)
[10:59:31.081] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 745 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (250 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.081] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.081] 
[10:59:31.081] getGlobalsAndPackages() ... DONE
[10:59:31.082] run() for ‘Future’ ...
[10:59:31.082] - state: ‘created’
[10:59:31.082] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.082] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.082]   - Field: ‘label’
[10:59:31.082]   - Field: ‘local’
[10:59:31.082]   - Field: ‘owner’
[10:59:31.082]   - Field: ‘envir’
[10:59:31.083]   - Field: ‘packages’
[10:59:31.083]   - Field: ‘gc’
[10:59:31.083]   - Field: ‘conditions’
[10:59:31.083]   - Field: ‘expr’
[10:59:31.083]   - Field: ‘uuid’
[10:59:31.083]   - Field: ‘seed’
[10:59:31.083]   - Field: ‘version’
[10:59:31.083]   - Field: ‘result’
[10:59:31.083]   - Field: ‘asynchronous’
[10:59:31.083]   - Field: ‘calls’
[10:59:31.083]   - Field: ‘globals’
[10:59:31.083]   - Field: ‘stdout’
[10:59:31.084]   - Field: ‘earlySignal’
[10:59:31.084]   - Field: ‘lazy’
[10:59:31.084]   - Field: ‘state’
[10:59:31.084] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.084] - Launch lazy future ...
[10:59:31.084] Packages needed by the future expression (n = 0): <none>
[10:59:31.084] Packages needed by future strategies (n = 0): <none>
[10:59:31.085] {
[10:59:31.085]     {
[10:59:31.085]         {
[10:59:31.085]             ...future.startTime <- base::Sys.time()
[10:59:31.085]             {
[10:59:31.085]                 {
[10:59:31.085]                   {
[10:59:31.085]                     base::local({
[10:59:31.085]                       has_future <- base::requireNamespace("future", 
[10:59:31.085]                         quietly = TRUE)
[10:59:31.085]                       if (has_future) {
[10:59:31.085]                         ns <- base::getNamespace("future")
[10:59:31.085]                         version <- ns[[".package"]][["version"]]
[10:59:31.085]                         if (is.null(version)) 
[10:59:31.085]                           version <- utils::packageVersion("future")
[10:59:31.085]                       }
[10:59:31.085]                       else {
[10:59:31.085]                         version <- NULL
[10:59:31.085]                       }
[10:59:31.085]                       if (!has_future || version < "1.8.0") {
[10:59:31.085]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.085]                           "", base::R.version$version.string), 
[10:59:31.085]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.085]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.085]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.085]                             "release", "version")], collapse = " "), 
[10:59:31.085]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.085]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.085]                           info)
[10:59:31.085]                         info <- base::paste(info, collapse = "; ")
[10:59:31.085]                         if (!has_future) {
[10:59:31.085]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.085]                             info)
[10:59:31.085]                         }
[10:59:31.085]                         else {
[10:59:31.085]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.085]                             info, version)
[10:59:31.085]                         }
[10:59:31.085]                         base::stop(msg)
[10:59:31.085]                       }
[10:59:31.085]                     })
[10:59:31.085]                   }
[10:59:31.085]                   ...future.strategy.old <- future::plan("list")
[10:59:31.085]                   options(future.plan = NULL)
[10:59:31.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.085]                 }
[10:59:31.085]                 ...future.workdir <- getwd()
[10:59:31.085]             }
[10:59:31.085]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.085]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.085]         }
[10:59:31.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.085]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.085]             base::names(...future.oldOptions))
[10:59:31.085]     }
[10:59:31.085]     if (FALSE) {
[10:59:31.085]     }
[10:59:31.085]     else {
[10:59:31.085]         if (TRUE) {
[10:59:31.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.085]                 open = "w")
[10:59:31.085]         }
[10:59:31.085]         else {
[10:59:31.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.085]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.085]         }
[10:59:31.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.085]             base::sink(type = "output", split = FALSE)
[10:59:31.085]             base::close(...future.stdout)
[10:59:31.085]         }, add = TRUE)
[10:59:31.085]     }
[10:59:31.085]     ...future.frame <- base::sys.nframe()
[10:59:31.085]     ...future.conditions <- base::list()
[10:59:31.085]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.085]     if (FALSE) {
[10:59:31.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.085]     }
[10:59:31.085]     ...future.result <- base::tryCatch({
[10:59:31.085]         base::withCallingHandlers({
[10:59:31.085]             ...future.value <- base::withVisible(base::local({
[10:59:31.085]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.085]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.085]                   ...future.globals.maxSize)) {
[10:59:31.085]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.085]                   on.exit(options(oopts), add = TRUE)
[10:59:31.085]                 }
[10:59:31.085]                 {
[10:59:31.085]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.085]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.085]                     USE.NAMES = FALSE)
[10:59:31.085]                   do.call(mapply, args = args)
[10:59:31.085]                 }
[10:59:31.085]             }))
[10:59:31.085]             future::FutureResult(value = ...future.value$value, 
[10:59:31.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.085]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.085]                     ...future.globalenv.names))
[10:59:31.085]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.085]         }, condition = base::local({
[10:59:31.085]             c <- base::c
[10:59:31.085]             inherits <- base::inherits
[10:59:31.085]             invokeRestart <- base::invokeRestart
[10:59:31.085]             length <- base::length
[10:59:31.085]             list <- base::list
[10:59:31.085]             seq.int <- base::seq.int
[10:59:31.085]             signalCondition <- base::signalCondition
[10:59:31.085]             sys.calls <- base::sys.calls
[10:59:31.085]             `[[` <- base::`[[`
[10:59:31.085]             `+` <- base::`+`
[10:59:31.085]             `<<-` <- base::`<<-`
[10:59:31.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.085]                   3L)]
[10:59:31.085]             }
[10:59:31.085]             function(cond) {
[10:59:31.085]                 is_error <- inherits(cond, "error")
[10:59:31.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.085]                   NULL)
[10:59:31.085]                 if (is_error) {
[10:59:31.085]                   sessionInformation <- function() {
[10:59:31.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.085]                       search = base::search(), system = base::Sys.info())
[10:59:31.085]                   }
[10:59:31.085]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.085]                     cond$call), session = sessionInformation(), 
[10:59:31.085]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.085]                   signalCondition(cond)
[10:59:31.085]                 }
[10:59:31.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.085]                 "immediateCondition"))) {
[10:59:31.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.085]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.085]                   if (TRUE && !signal) {
[10:59:31.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.085]                     {
[10:59:31.085]                       inherits <- base::inherits
[10:59:31.085]                       invokeRestart <- base::invokeRestart
[10:59:31.085]                       is.null <- base::is.null
[10:59:31.085]                       muffled <- FALSE
[10:59:31.085]                       if (inherits(cond, "message")) {
[10:59:31.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.085]                         if (muffled) 
[10:59:31.085]                           invokeRestart("muffleMessage")
[10:59:31.085]                       }
[10:59:31.085]                       else if (inherits(cond, "warning")) {
[10:59:31.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.085]                         if (muffled) 
[10:59:31.085]                           invokeRestart("muffleWarning")
[10:59:31.085]                       }
[10:59:31.085]                       else if (inherits(cond, "condition")) {
[10:59:31.085]                         if (!is.null(pattern)) {
[10:59:31.085]                           computeRestarts <- base::computeRestarts
[10:59:31.085]                           grepl <- base::grepl
[10:59:31.085]                           restarts <- computeRestarts(cond)
[10:59:31.085]                           for (restart in restarts) {
[10:59:31.085]                             name <- restart$name
[10:59:31.085]                             if (is.null(name)) 
[10:59:31.085]                               next
[10:59:31.085]                             if (!grepl(pattern, name)) 
[10:59:31.085]                               next
[10:59:31.085]                             invokeRestart(restart)
[10:59:31.085]                             muffled <- TRUE
[10:59:31.085]                             break
[10:59:31.085]                           }
[10:59:31.085]                         }
[10:59:31.085]                       }
[10:59:31.085]                       invisible(muffled)
[10:59:31.085]                     }
[10:59:31.085]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.085]                   }
[10:59:31.085]                 }
[10:59:31.085]                 else {
[10:59:31.085]                   if (TRUE) {
[10:59:31.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.085]                     {
[10:59:31.085]                       inherits <- base::inherits
[10:59:31.085]                       invokeRestart <- base::invokeRestart
[10:59:31.085]                       is.null <- base::is.null
[10:59:31.085]                       muffled <- FALSE
[10:59:31.085]                       if (inherits(cond, "message")) {
[10:59:31.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.085]                         if (muffled) 
[10:59:31.085]                           invokeRestart("muffleMessage")
[10:59:31.085]                       }
[10:59:31.085]                       else if (inherits(cond, "warning")) {
[10:59:31.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.085]                         if (muffled) 
[10:59:31.085]                           invokeRestart("muffleWarning")
[10:59:31.085]                       }
[10:59:31.085]                       else if (inherits(cond, "condition")) {
[10:59:31.085]                         if (!is.null(pattern)) {
[10:59:31.085]                           computeRestarts <- base::computeRestarts
[10:59:31.085]                           grepl <- base::grepl
[10:59:31.085]                           restarts <- computeRestarts(cond)
[10:59:31.085]                           for (restart in restarts) {
[10:59:31.085]                             name <- restart$name
[10:59:31.085]                             if (is.null(name)) 
[10:59:31.085]                               next
[10:59:31.085]                             if (!grepl(pattern, name)) 
[10:59:31.085]                               next
[10:59:31.085]                             invokeRestart(restart)
[10:59:31.085]                             muffled <- TRUE
[10:59:31.085]                             break
[10:59:31.085]                           }
[10:59:31.085]                         }
[10:59:31.085]                       }
[10:59:31.085]                       invisible(muffled)
[10:59:31.085]                     }
[10:59:31.085]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.085]                   }
[10:59:31.085]                 }
[10:59:31.085]             }
[10:59:31.085]         }))
[10:59:31.085]     }, error = function(ex) {
[10:59:31.085]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.085]                 ...future.rng), started = ...future.startTime, 
[10:59:31.085]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.085]             version = "1.8"), class = "FutureResult")
[10:59:31.085]     }, finally = {
[10:59:31.085]         if (!identical(...future.workdir, getwd())) 
[10:59:31.085]             setwd(...future.workdir)
[10:59:31.085]         {
[10:59:31.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.085]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.085]             }
[10:59:31.085]             base::options(...future.oldOptions)
[10:59:31.085]             if (.Platform$OS.type == "windows") {
[10:59:31.085]                 old_names <- names(...future.oldEnvVars)
[10:59:31.085]                 envs <- base::Sys.getenv()
[10:59:31.085]                 names <- names(envs)
[10:59:31.085]                 common <- intersect(names, old_names)
[10:59:31.085]                 added <- setdiff(names, old_names)
[10:59:31.085]                 removed <- setdiff(old_names, names)
[10:59:31.085]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.085]                   envs[common]]
[10:59:31.085]                 NAMES <- toupper(changed)
[10:59:31.085]                 args <- list()
[10:59:31.085]                 for (kk in seq_along(NAMES)) {
[10:59:31.085]                   name <- changed[[kk]]
[10:59:31.085]                   NAME <- NAMES[[kk]]
[10:59:31.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.085]                     next
[10:59:31.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.085]                 }
[10:59:31.085]                 NAMES <- toupper(added)
[10:59:31.085]                 for (kk in seq_along(NAMES)) {
[10:59:31.085]                   name <- added[[kk]]
[10:59:31.085]                   NAME <- NAMES[[kk]]
[10:59:31.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.085]                     next
[10:59:31.085]                   args[[name]] <- ""
[10:59:31.085]                 }
[10:59:31.085]                 NAMES <- toupper(removed)
[10:59:31.085]                 for (kk in seq_along(NAMES)) {
[10:59:31.085]                   name <- removed[[kk]]
[10:59:31.085]                   NAME <- NAMES[[kk]]
[10:59:31.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.085]                     next
[10:59:31.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.085]                 }
[10:59:31.085]                 if (length(args) > 0) 
[10:59:31.085]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.085]             }
[10:59:31.085]             else {
[10:59:31.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.085]             }
[10:59:31.085]             {
[10:59:31.085]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.085]                   0L) {
[10:59:31.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.085]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.085]                   base::options(opts)
[10:59:31.085]                 }
[10:59:31.085]                 {
[10:59:31.085]                   {
[10:59:31.085]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.085]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.085]                     1047550554L), envir = base::globalenv(), 
[10:59:31.085]                       inherits = FALSE)
[10:59:31.085]                     NULL
[10:59:31.085]                   }
[10:59:31.085]                   options(future.plan = NULL)
[10:59:31.085]                   if (is.na(NA_character_)) 
[10:59:31.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.085]                     .init = FALSE)
[10:59:31.085]                 }
[10:59:31.085]             }
[10:59:31.085]         }
[10:59:31.085]     })
[10:59:31.085]     if (TRUE) {
[10:59:31.085]         base::sink(type = "output", split = FALSE)
[10:59:31.085]         if (TRUE) {
[10:59:31.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.085]         }
[10:59:31.085]         else {
[10:59:31.085]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.085]         }
[10:59:31.085]         base::close(...future.stdout)
[10:59:31.085]         ...future.stdout <- NULL
[10:59:31.085]     }
[10:59:31.085]     ...future.result$conditions <- ...future.conditions
[10:59:31.085]     ...future.result$finished <- base::Sys.time()
[10:59:31.085]     ...future.result
[10:59:31.085] }
[10:59:31.086] assign_globals() ...
[10:59:31.086] List of 5
[10:59:31.086]  $ ...future.FUN            :function (x, y)  
[10:59:31.086]  $ MoreArgs                 : NULL
[10:59:31.086]  $ ...future.elements_ii    :List of 2
[10:59:31.086]   ..$ :List of 3
[10:59:31.086]   .. ..$ a: num 1
[10:59:31.086]   .. ..$ b: num 2
[10:59:31.086]   .. ..$ c: num 3
[10:59:31.086]   ..$ :List of 3
[10:59:31.086]   .. ..$ A: num 10
[10:59:31.086]   .. ..$ B: num 0
[10:59:31.086]   .. ..$ C: num -10
[10:59:31.086]  $ ...future.seeds_ii       : NULL
[10:59:31.086]  $ ...future.globals.maxSize: NULL
[10:59:31.086]  - attr(*, "where")=List of 5
[10:59:31.086]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.086]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.086]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.086]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.086]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.086]  - attr(*, "resolved")= logi FALSE
[10:59:31.086]  - attr(*, "total_size")= num 745
[10:59:31.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.086]  - attr(*, "already-done")= logi TRUE
[10:59:31.092] - reassign environment for ‘...future.FUN’
[10:59:31.092] - copied ‘...future.FUN’ to environment
[10:59:31.092] - copied ‘MoreArgs’ to environment
[10:59:31.092] - copied ‘...future.elements_ii’ to environment
[10:59:31.092] - copied ‘...future.seeds_ii’ to environment
[10:59:31.093] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.093] assign_globals() ... done
[10:59:31.093] plan(): Setting new future strategy stack:
[10:59:31.093] List of future strategies:
[10:59:31.093] 1. sequential:
[10:59:31.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.093]    - tweaked: FALSE
[10:59:31.093]    - call: NULL
[10:59:31.093] plan(): nbrOfWorkers() = 1
[10:59:31.094] plan(): Setting new future strategy stack:
[10:59:31.094] List of future strategies:
[10:59:31.094] 1. sequential:
[10:59:31.094]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.094]    - tweaked: FALSE
[10:59:31.094]    - call: plan(strategy)
[10:59:31.095] plan(): nbrOfWorkers() = 1
[10:59:31.095] SequentialFuture started (and completed)
[10:59:31.095] - Launch lazy future ... done
[10:59:31.095] run() for ‘SequentialFuture’ ... done
[10:59:31.095] Created future:
[10:59:31.095] SequentialFuture:
[10:59:31.095] Label: ‘future_mapply-1’
[10:59:31.095] Expression:
[10:59:31.095] {
[10:59:31.095]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.095]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.095]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.095]         on.exit(options(oopts), add = TRUE)
[10:59:31.095]     }
[10:59:31.095]     {
[10:59:31.095]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.095]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.095]         do.call(mapply, args = args)
[10:59:31.095]     }
[10:59:31.095] }
[10:59:31.095] Lazy evaluation: FALSE
[10:59:31.095] Asynchronous evaluation: FALSE
[10:59:31.095] Local evaluation: TRUE
[10:59:31.095] Environment: R_GlobalEnv
[10:59:31.095] Capture standard output: TRUE
[10:59:31.095] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.095] Globals: 5 objects totaling 745 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 250 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.095] Packages: <none>
[10:59:31.095] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.095] Resolved: TRUE
[10:59:31.095] Value: 103 bytes of class ‘list’
[10:59:31.095] Early signaling: FALSE
[10:59:31.095] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.095] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.096] Chunk #1 of 1 ... DONE
[10:59:31.096] Launching 1 futures (chunks) ... DONE
[10:59:31.096] Resolving 1 futures (chunks) ...
[10:59:31.096] resolve() on list ...
[10:59:31.096]  recursive: 0
[10:59:31.097]  length: 1
[10:59:31.097] 
[10:59:31.097] resolved() for ‘SequentialFuture’ ...
[10:59:31.097] - state: ‘finished’
[10:59:31.097] - run: TRUE
[10:59:31.097] - result: ‘FutureResult’
[10:59:31.097] resolved() for ‘SequentialFuture’ ... done
[10:59:31.097] Future #1
[10:59:31.097] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.098] - nx: 1
[10:59:31.099] - relay: TRUE
[10:59:31.099] - stdout: TRUE
[10:59:31.099] - signal: TRUE
[10:59:31.099] - resignal: FALSE
[10:59:31.099] - force: TRUE
[10:59:31.099] - relayed: [n=1] FALSE
[10:59:31.099] - queued futures: [n=1] FALSE
[10:59:31.099]  - until=1
[10:59:31.099]  - relaying element #1
[10:59:31.099] - relayed: [n=1] TRUE
[10:59:31.099] - queued futures: [n=1] TRUE
[10:59:31.100] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.100]  length: 0 (resolved future 1)
[10:59:31.100] Relaying remaining futures
[10:59:31.100] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.100] - nx: 1
[10:59:31.100] - relay: TRUE
[10:59:31.100] - stdout: TRUE
[10:59:31.100] - signal: TRUE
[10:59:31.100] - resignal: FALSE
[10:59:31.100] - force: TRUE
[10:59:31.100] - relayed: [n=1] TRUE
[10:59:31.100] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.101] - relayed: [n=1] TRUE
[10:59:31.101] - queued futures: [n=1] TRUE
[10:59:31.101] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.101] resolve() on list ... DONE
[10:59:31.101]  - Number of value chunks collected: 1
[10:59:31.101] Resolving 1 futures (chunks) ... DONE
[10:59:31.101] Reducing values from 1 chunks ...
[10:59:31.101]  - Number of values collected after concatenation: 3
[10:59:31.101]  - Number of values expected: 3
[10:59:31.101] Reducing values from 1 chunks ... DONE
[10:59:31.101] future_mapply() ... DONE
- future_.mapply()
[10:59:31.102] future_mapply() ...
[10:59:31.102] Number of chunks: 1
[10:59:31.102] getGlobalsAndPackagesXApply() ...
[10:59:31.102]  - future.globals: TRUE
[10:59:31.102] getGlobalsAndPackages() ...
[10:59:31.102] Searching for globals...
[10:59:31.104] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:59:31.104] Searching for globals ... DONE
[10:59:31.104] Resolving globals: FALSE
[10:59:31.104] The total size of the 1 globals is 414 bytes (414 bytes)
[10:59:31.104] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:59:31.105] - globals: [1] ‘FUN’
[10:59:31.105] 
[10:59:31.105] getGlobalsAndPackages() ... DONE
[10:59:31.105]  - globals found/used: [n=1] ‘FUN’
[10:59:31.105]  - needed namespaces: [n=0] 
[10:59:31.105] Finding globals ... DONE
[10:59:31.105] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.105] List of 2
[10:59:31.105]  $ ...future.FUN:function (x, y)  
[10:59:31.105]  $ MoreArgs     : list()
[10:59:31.105]  - attr(*, "where")=List of 2
[10:59:31.105]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.105]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.105]  - attr(*, "resolved")= logi FALSE
[10:59:31.105]  - attr(*, "total_size")= num NA
[10:59:31.107] Packages to be attached in all futures: [n=0] 
[10:59:31.108] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.108] Number of futures (= number of chunks): 1
[10:59:31.108] Launching 1 futures (chunks) ...
[10:59:31.108] Chunk #1 of 1 ...
[10:59:31.108]  - Finding globals in '...' for chunk #1 ...
[10:59:31.108] getGlobalsAndPackages() ...
[10:59:31.108] Searching for globals...
[10:59:31.108] 
[10:59:31.109] Searching for globals ... DONE
[10:59:31.109] - globals: [0] <none>
[10:59:31.109] getGlobalsAndPackages() ... DONE
[10:59:31.109]    + additional globals found: [n=0] 
[10:59:31.109]    + additional namespaces needed: [n=0] 
[10:59:31.109]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.109]  - seeds: <none>
[10:59:31.109]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.109] getGlobalsAndPackages() ...
[10:59:31.109] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.109] Resolving globals: FALSE
[10:59:31.110] The total size of the 5 globals is 749 bytes (749 bytes)
[10:59:31.110] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 749 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (250 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:31.110] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.110] 
[10:59:31.110] getGlobalsAndPackages() ... DONE
[10:59:31.111] run() for ‘Future’ ...
[10:59:31.111] - state: ‘created’
[10:59:31.111] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.111]   - Field: ‘label’
[10:59:31.111]   - Field: ‘local’
[10:59:31.111]   - Field: ‘owner’
[10:59:31.112]   - Field: ‘envir’
[10:59:31.112]   - Field: ‘packages’
[10:59:31.112]   - Field: ‘gc’
[10:59:31.112]   - Field: ‘conditions’
[10:59:31.112]   - Field: ‘expr’
[10:59:31.112]   - Field: ‘uuid’
[10:59:31.112]   - Field: ‘seed’
[10:59:31.112]   - Field: ‘version’
[10:59:31.112]   - Field: ‘result’
[10:59:31.112]   - Field: ‘asynchronous’
[10:59:31.112]   - Field: ‘calls’
[10:59:31.112]   - Field: ‘globals’
[10:59:31.112]   - Field: ‘stdout’
[10:59:31.113]   - Field: ‘earlySignal’
[10:59:31.113]   - Field: ‘lazy’
[10:59:31.113]   - Field: ‘state’
[10:59:31.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.113] - Launch lazy future ...
[10:59:31.113] Packages needed by the future expression (n = 0): <none>
[10:59:31.113] Packages needed by future strategies (n = 0): <none>
[10:59:31.114] {
[10:59:31.114]     {
[10:59:31.114]         {
[10:59:31.114]             ...future.startTime <- base::Sys.time()
[10:59:31.114]             {
[10:59:31.114]                 {
[10:59:31.114]                   {
[10:59:31.114]                     base::local({
[10:59:31.114]                       has_future <- base::requireNamespace("future", 
[10:59:31.114]                         quietly = TRUE)
[10:59:31.114]                       if (has_future) {
[10:59:31.114]                         ns <- base::getNamespace("future")
[10:59:31.114]                         version <- ns[[".package"]][["version"]]
[10:59:31.114]                         if (is.null(version)) 
[10:59:31.114]                           version <- utils::packageVersion("future")
[10:59:31.114]                       }
[10:59:31.114]                       else {
[10:59:31.114]                         version <- NULL
[10:59:31.114]                       }
[10:59:31.114]                       if (!has_future || version < "1.8.0") {
[10:59:31.114]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.114]                           "", base::R.version$version.string), 
[10:59:31.114]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.114]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.114]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.114]                             "release", "version")], collapse = " "), 
[10:59:31.114]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.114]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.114]                           info)
[10:59:31.114]                         info <- base::paste(info, collapse = "; ")
[10:59:31.114]                         if (!has_future) {
[10:59:31.114]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.114]                             info)
[10:59:31.114]                         }
[10:59:31.114]                         else {
[10:59:31.114]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.114]                             info, version)
[10:59:31.114]                         }
[10:59:31.114]                         base::stop(msg)
[10:59:31.114]                       }
[10:59:31.114]                     })
[10:59:31.114]                   }
[10:59:31.114]                   ...future.strategy.old <- future::plan("list")
[10:59:31.114]                   options(future.plan = NULL)
[10:59:31.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.114]                 }
[10:59:31.114]                 ...future.workdir <- getwd()
[10:59:31.114]             }
[10:59:31.114]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.114]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.114]         }
[10:59:31.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.114]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.114]             base::names(...future.oldOptions))
[10:59:31.114]     }
[10:59:31.114]     if (FALSE) {
[10:59:31.114]     }
[10:59:31.114]     else {
[10:59:31.114]         if (TRUE) {
[10:59:31.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.114]                 open = "w")
[10:59:31.114]         }
[10:59:31.114]         else {
[10:59:31.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.114]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.114]         }
[10:59:31.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.114]             base::sink(type = "output", split = FALSE)
[10:59:31.114]             base::close(...future.stdout)
[10:59:31.114]         }, add = TRUE)
[10:59:31.114]     }
[10:59:31.114]     ...future.frame <- base::sys.nframe()
[10:59:31.114]     ...future.conditions <- base::list()
[10:59:31.114]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.114]     if (FALSE) {
[10:59:31.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.114]     }
[10:59:31.114]     ...future.result <- base::tryCatch({
[10:59:31.114]         base::withCallingHandlers({
[10:59:31.114]             ...future.value <- base::withVisible(base::local({
[10:59:31.114]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.114]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.114]                   ...future.globals.maxSize)) {
[10:59:31.114]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.114]                   on.exit(options(oopts), add = TRUE)
[10:59:31.114]                 }
[10:59:31.114]                 {
[10:59:31.114]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.114]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.114]                     USE.NAMES = FALSE)
[10:59:31.114]                   do.call(mapply, args = args)
[10:59:31.114]                 }
[10:59:31.114]             }))
[10:59:31.114]             future::FutureResult(value = ...future.value$value, 
[10:59:31.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.114]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.114]                     ...future.globalenv.names))
[10:59:31.114]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.114]         }, condition = base::local({
[10:59:31.114]             c <- base::c
[10:59:31.114]             inherits <- base::inherits
[10:59:31.114]             invokeRestart <- base::invokeRestart
[10:59:31.114]             length <- base::length
[10:59:31.114]             list <- base::list
[10:59:31.114]             seq.int <- base::seq.int
[10:59:31.114]             signalCondition <- base::signalCondition
[10:59:31.114]             sys.calls <- base::sys.calls
[10:59:31.114]             `[[` <- base::`[[`
[10:59:31.114]             `+` <- base::`+`
[10:59:31.114]             `<<-` <- base::`<<-`
[10:59:31.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.114]                   3L)]
[10:59:31.114]             }
[10:59:31.114]             function(cond) {
[10:59:31.114]                 is_error <- inherits(cond, "error")
[10:59:31.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.114]                   NULL)
[10:59:31.114]                 if (is_error) {
[10:59:31.114]                   sessionInformation <- function() {
[10:59:31.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.114]                       search = base::search(), system = base::Sys.info())
[10:59:31.114]                   }
[10:59:31.114]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.114]                     cond$call), session = sessionInformation(), 
[10:59:31.114]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.114]                   signalCondition(cond)
[10:59:31.114]                 }
[10:59:31.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.114]                 "immediateCondition"))) {
[10:59:31.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.114]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.114]                   if (TRUE && !signal) {
[10:59:31.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.114]                     {
[10:59:31.114]                       inherits <- base::inherits
[10:59:31.114]                       invokeRestart <- base::invokeRestart
[10:59:31.114]                       is.null <- base::is.null
[10:59:31.114]                       muffled <- FALSE
[10:59:31.114]                       if (inherits(cond, "message")) {
[10:59:31.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.114]                         if (muffled) 
[10:59:31.114]                           invokeRestart("muffleMessage")
[10:59:31.114]                       }
[10:59:31.114]                       else if (inherits(cond, "warning")) {
[10:59:31.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.114]                         if (muffled) 
[10:59:31.114]                           invokeRestart("muffleWarning")
[10:59:31.114]                       }
[10:59:31.114]                       else if (inherits(cond, "condition")) {
[10:59:31.114]                         if (!is.null(pattern)) {
[10:59:31.114]                           computeRestarts <- base::computeRestarts
[10:59:31.114]                           grepl <- base::grepl
[10:59:31.114]                           restarts <- computeRestarts(cond)
[10:59:31.114]                           for (restart in restarts) {
[10:59:31.114]                             name <- restart$name
[10:59:31.114]                             if (is.null(name)) 
[10:59:31.114]                               next
[10:59:31.114]                             if (!grepl(pattern, name)) 
[10:59:31.114]                               next
[10:59:31.114]                             invokeRestart(restart)
[10:59:31.114]                             muffled <- TRUE
[10:59:31.114]                             break
[10:59:31.114]                           }
[10:59:31.114]                         }
[10:59:31.114]                       }
[10:59:31.114]                       invisible(muffled)
[10:59:31.114]                     }
[10:59:31.114]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.114]                   }
[10:59:31.114]                 }
[10:59:31.114]                 else {
[10:59:31.114]                   if (TRUE) {
[10:59:31.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.114]                     {
[10:59:31.114]                       inherits <- base::inherits
[10:59:31.114]                       invokeRestart <- base::invokeRestart
[10:59:31.114]                       is.null <- base::is.null
[10:59:31.114]                       muffled <- FALSE
[10:59:31.114]                       if (inherits(cond, "message")) {
[10:59:31.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.114]                         if (muffled) 
[10:59:31.114]                           invokeRestart("muffleMessage")
[10:59:31.114]                       }
[10:59:31.114]                       else if (inherits(cond, "warning")) {
[10:59:31.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.114]                         if (muffled) 
[10:59:31.114]                           invokeRestart("muffleWarning")
[10:59:31.114]                       }
[10:59:31.114]                       else if (inherits(cond, "condition")) {
[10:59:31.114]                         if (!is.null(pattern)) {
[10:59:31.114]                           computeRestarts <- base::computeRestarts
[10:59:31.114]                           grepl <- base::grepl
[10:59:31.114]                           restarts <- computeRestarts(cond)
[10:59:31.114]                           for (restart in restarts) {
[10:59:31.114]                             name <- restart$name
[10:59:31.114]                             if (is.null(name)) 
[10:59:31.114]                               next
[10:59:31.114]                             if (!grepl(pattern, name)) 
[10:59:31.114]                               next
[10:59:31.114]                             invokeRestart(restart)
[10:59:31.114]                             muffled <- TRUE
[10:59:31.114]                             break
[10:59:31.114]                           }
[10:59:31.114]                         }
[10:59:31.114]                       }
[10:59:31.114]                       invisible(muffled)
[10:59:31.114]                     }
[10:59:31.114]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.114]                   }
[10:59:31.114]                 }
[10:59:31.114]             }
[10:59:31.114]         }))
[10:59:31.114]     }, error = function(ex) {
[10:59:31.114]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.114]                 ...future.rng), started = ...future.startTime, 
[10:59:31.114]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.114]             version = "1.8"), class = "FutureResult")
[10:59:31.114]     }, finally = {
[10:59:31.114]         if (!identical(...future.workdir, getwd())) 
[10:59:31.114]             setwd(...future.workdir)
[10:59:31.114]         {
[10:59:31.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.114]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.114]             }
[10:59:31.114]             base::options(...future.oldOptions)
[10:59:31.114]             if (.Platform$OS.type == "windows") {
[10:59:31.114]                 old_names <- names(...future.oldEnvVars)
[10:59:31.114]                 envs <- base::Sys.getenv()
[10:59:31.114]                 names <- names(envs)
[10:59:31.114]                 common <- intersect(names, old_names)
[10:59:31.114]                 added <- setdiff(names, old_names)
[10:59:31.114]                 removed <- setdiff(old_names, names)
[10:59:31.114]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.114]                   envs[common]]
[10:59:31.114]                 NAMES <- toupper(changed)
[10:59:31.114]                 args <- list()
[10:59:31.114]                 for (kk in seq_along(NAMES)) {
[10:59:31.114]                   name <- changed[[kk]]
[10:59:31.114]                   NAME <- NAMES[[kk]]
[10:59:31.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.114]                     next
[10:59:31.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.114]                 }
[10:59:31.114]                 NAMES <- toupper(added)
[10:59:31.114]                 for (kk in seq_along(NAMES)) {
[10:59:31.114]                   name <- added[[kk]]
[10:59:31.114]                   NAME <- NAMES[[kk]]
[10:59:31.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.114]                     next
[10:59:31.114]                   args[[name]] <- ""
[10:59:31.114]                 }
[10:59:31.114]                 NAMES <- toupper(removed)
[10:59:31.114]                 for (kk in seq_along(NAMES)) {
[10:59:31.114]                   name <- removed[[kk]]
[10:59:31.114]                   NAME <- NAMES[[kk]]
[10:59:31.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.114]                     next
[10:59:31.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.114]                 }
[10:59:31.114]                 if (length(args) > 0) 
[10:59:31.114]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.114]             }
[10:59:31.114]             else {
[10:59:31.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.114]             }
[10:59:31.114]             {
[10:59:31.114]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.114]                   0L) {
[10:59:31.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.114]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.114]                   base::options(opts)
[10:59:31.114]                 }
[10:59:31.114]                 {
[10:59:31.114]                   {
[10:59:31.114]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.114]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.114]                     1047550554L), envir = base::globalenv(), 
[10:59:31.114]                       inherits = FALSE)
[10:59:31.114]                     NULL
[10:59:31.114]                   }
[10:59:31.114]                   options(future.plan = NULL)
[10:59:31.114]                   if (is.na(NA_character_)) 
[10:59:31.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.114]                     .init = FALSE)
[10:59:31.114]                 }
[10:59:31.114]             }
[10:59:31.114]         }
[10:59:31.114]     })
[10:59:31.114]     if (TRUE) {
[10:59:31.114]         base::sink(type = "output", split = FALSE)
[10:59:31.114]         if (TRUE) {
[10:59:31.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.114]         }
[10:59:31.114]         else {
[10:59:31.114]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.114]         }
[10:59:31.114]         base::close(...future.stdout)
[10:59:31.114]         ...future.stdout <- NULL
[10:59:31.114]     }
[10:59:31.114]     ...future.result$conditions <- ...future.conditions
[10:59:31.114]     ...future.result$finished <- base::Sys.time()
[10:59:31.114]     ...future.result
[10:59:31.114] }
[10:59:31.115] assign_globals() ...
[10:59:31.115] List of 5
[10:59:31.115]  $ ...future.FUN            :function (x, y)  
[10:59:31.115]  $ MoreArgs                 : list()
[10:59:31.115]  $ ...future.elements_ii    :List of 2
[10:59:31.115]   ..$ :List of 3
[10:59:31.115]   .. ..$ a: num 1
[10:59:31.115]   .. ..$ b: num 2
[10:59:31.115]   .. ..$ c: num 3
[10:59:31.115]   ..$ :List of 3
[10:59:31.115]   .. ..$ A: num 10
[10:59:31.115]   .. ..$ B: num 0
[10:59:31.115]   .. ..$ C: num -10
[10:59:31.115]  $ ...future.seeds_ii       : NULL
[10:59:31.115]  $ ...future.globals.maxSize: NULL
[10:59:31.115]  - attr(*, "where")=List of 5
[10:59:31.115]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.115]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.115]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.115]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.115]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.115]  - attr(*, "resolved")= logi FALSE
[10:59:31.115]  - attr(*, "total_size")= num 749
[10:59:31.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.115]  - attr(*, "already-done")= logi TRUE
[10:59:31.122] - reassign environment for ‘...future.FUN’
[10:59:31.122] - copied ‘...future.FUN’ to environment
[10:59:31.122] - copied ‘MoreArgs’ to environment
[10:59:31.122] - copied ‘...future.elements_ii’ to environment
[10:59:31.122] - copied ‘...future.seeds_ii’ to environment
[10:59:31.123] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.123] assign_globals() ... done
[10:59:31.123] plan(): Setting new future strategy stack:
[10:59:31.123] List of future strategies:
[10:59:31.123] 1. sequential:
[10:59:31.123]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.123]    - tweaked: FALSE
[10:59:31.123]    - call: NULL
[10:59:31.123] plan(): nbrOfWorkers() = 1
[10:59:31.124] plan(): Setting new future strategy stack:
[10:59:31.124] List of future strategies:
[10:59:31.124] 1. sequential:
[10:59:31.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.124]    - tweaked: FALSE
[10:59:31.124]    - call: plan(strategy)
[10:59:31.125] plan(): nbrOfWorkers() = 1
[10:59:31.125] SequentialFuture started (and completed)
[10:59:31.125] - Launch lazy future ... done
[10:59:31.125] run() for ‘SequentialFuture’ ... done
[10:59:31.125] Created future:
[10:59:31.125] SequentialFuture:
[10:59:31.125] Label: ‘future_.mapply-1’
[10:59:31.125] Expression:
[10:59:31.125] {
[10:59:31.125]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.125]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.125]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.125]         on.exit(options(oopts), add = TRUE)
[10:59:31.125]     }
[10:59:31.125]     {
[10:59:31.125]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.125]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.125]         do.call(mapply, args = args)
[10:59:31.125]     }
[10:59:31.125] }
[10:59:31.125] Lazy evaluation: FALSE
[10:59:31.125] Asynchronous evaluation: FALSE
[10:59:31.125] Local evaluation: TRUE
[10:59:31.125] Environment: R_GlobalEnv
[10:59:31.125] Capture standard output: TRUE
[10:59:31.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.125] Globals: 5 objects totaling 749 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 250 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.125] Packages: <none>
[10:59:31.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.125] Resolved: TRUE
[10:59:31.125] Value: 103 bytes of class ‘list’
[10:59:31.125] Early signaling: FALSE
[10:59:31.125] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.125] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.126] Chunk #1 of 1 ... DONE
[10:59:31.126] Launching 1 futures (chunks) ... DONE
[10:59:31.126] Resolving 1 futures (chunks) ...
[10:59:31.126] resolve() on list ...
[10:59:31.126]  recursive: 0
[10:59:31.126]  length: 1
[10:59:31.126] 
[10:59:31.126] resolved() for ‘SequentialFuture’ ...
[10:59:31.126] - state: ‘finished’
[10:59:31.126] - run: TRUE
[10:59:31.127] - result: ‘FutureResult’
[10:59:31.127] resolved() for ‘SequentialFuture’ ... done
[10:59:31.127] Future #1
[10:59:31.127] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.127] - nx: 1
[10:59:31.127] - relay: TRUE
[10:59:31.127] - stdout: TRUE
[10:59:31.127] - signal: TRUE
[10:59:31.127] - resignal: FALSE
[10:59:31.127] - force: TRUE
[10:59:31.127] - relayed: [n=1] FALSE
[10:59:31.127] - queued futures: [n=1] FALSE
[10:59:31.127]  - until=1
[10:59:31.128]  - relaying element #1
[10:59:31.128] - relayed: [n=1] TRUE
[10:59:31.128] - queued futures: [n=1] TRUE
[10:59:31.128] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.128]  length: 0 (resolved future 1)
[10:59:31.128] Relaying remaining futures
[10:59:31.128] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.128] - nx: 1
[10:59:31.128] - relay: TRUE
[10:59:31.128] - stdout: TRUE
[10:59:31.128] - signal: TRUE
[10:59:31.128] - resignal: FALSE
[10:59:31.129] - force: TRUE
[10:59:31.129] - relayed: [n=1] TRUE
[10:59:31.129] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.129] - relayed: [n=1] TRUE
[10:59:31.129] - queued futures: [n=1] TRUE
[10:59:31.129] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.129] resolve() on list ... DONE
[10:59:31.129]  - Number of value chunks collected: 1
[10:59:31.129] Resolving 1 futures (chunks) ... DONE
[10:59:31.129] Reducing values from 1 chunks ...
[10:59:31.129]  - Number of values collected after concatenation: 3
[10:59:31.129]  - Number of values expected: 3
[10:59:31.130] Reducing values from 1 chunks ... DONE
[10:59:31.130] future_mapply() ... DONE
[10:59:31.130] future_mapply() ...
[10:59:31.131] Number of chunks: 5
[10:59:31.131] getGlobalsAndPackagesXApply() ...
[10:59:31.131]  - future.globals: TRUE
[10:59:31.132] getGlobalsAndPackages() ...
[10:59:31.132] Searching for globals...
[10:59:31.133] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:31.133] Searching for globals ... DONE
[10:59:31.133] Resolving globals: FALSE
[10:59:31.133] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:31.134] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:31.134] - globals: [1] ‘FUN’
[10:59:31.134] 
[10:59:31.134] getGlobalsAndPackages() ... DONE
[10:59:31.134]  - globals found/used: [n=1] ‘FUN’
[10:59:31.134]  - needed namespaces: [n=0] 
[10:59:31.134] Finding globals ... DONE
[10:59:31.134] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.134] List of 2
[10:59:31.134]  $ ...future.FUN:function (C, k)  
[10:59:31.134]  $ MoreArgs     : NULL
[10:59:31.134]  - attr(*, "where")=List of 2
[10:59:31.134]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.134]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.134]  - attr(*, "resolved")= logi FALSE
[10:59:31.134]  - attr(*, "total_size")= num NA
[10:59:31.137] Packages to be attached in all futures: [n=0] 
[10:59:31.137] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.137] Number of futures (= number of chunks): 5
[10:59:31.137] Launching 5 futures (chunks) ...
[10:59:31.137] Chunk #1 of 5 ...
[10:59:31.137]  - Finding globals in '...' for chunk #1 ...
[10:59:31.137] getGlobalsAndPackages() ...
[10:59:31.137] Searching for globals...
[10:59:31.137] 
[10:59:31.138] Searching for globals ... DONE
[10:59:31.138] - globals: [0] <none>
[10:59:31.138] getGlobalsAndPackages() ... DONE
[10:59:31.138]    + additional globals found: [n=0] 
[10:59:31.138]    + additional namespaces needed: [n=0] 
[10:59:31.138]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.138]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:31.138]  - seeds: <none>
[10:59:31.138]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.138] getGlobalsAndPackages() ...
[10:59:31.138] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.138] Resolving globals: FALSE
[10:59:31.139] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:31.139] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.139] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.139] 
[10:59:31.140] getGlobalsAndPackages() ... DONE
[10:59:31.140] run() for ‘Future’ ...
[10:59:31.140] - state: ‘created’
[10:59:31.140] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.140] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.140] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.140]   - Field: ‘label’
[10:59:31.141]   - Field: ‘local’
[10:59:31.141]   - Field: ‘owner’
[10:59:31.141]   - Field: ‘envir’
[10:59:31.141]   - Field: ‘packages’
[10:59:31.142]   - Field: ‘gc’
[10:59:31.142]   - Field: ‘conditions’
[10:59:31.142]   - Field: ‘expr’
[10:59:31.142]   - Field: ‘uuid’
[10:59:31.142]   - Field: ‘seed’
[10:59:31.142]   - Field: ‘version’
[10:59:31.142]   - Field: ‘result’
[10:59:31.142]   - Field: ‘asynchronous’
[10:59:31.142]   - Field: ‘calls’
[10:59:31.143]   - Field: ‘globals’
[10:59:31.143]   - Field: ‘stdout’
[10:59:31.143]   - Field: ‘earlySignal’
[10:59:31.143]   - Field: ‘lazy’
[10:59:31.143]   - Field: ‘state’
[10:59:31.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.143] - Launch lazy future ...
[10:59:31.143] Packages needed by the future expression (n = 0): <none>
[10:59:31.143] Packages needed by future strategies (n = 0): <none>
[10:59:31.144] {
[10:59:31.144]     {
[10:59:31.144]         {
[10:59:31.144]             ...future.startTime <- base::Sys.time()
[10:59:31.144]             {
[10:59:31.144]                 {
[10:59:31.144]                   {
[10:59:31.144]                     base::local({
[10:59:31.144]                       has_future <- base::requireNamespace("future", 
[10:59:31.144]                         quietly = TRUE)
[10:59:31.144]                       if (has_future) {
[10:59:31.144]                         ns <- base::getNamespace("future")
[10:59:31.144]                         version <- ns[[".package"]][["version"]]
[10:59:31.144]                         if (is.null(version)) 
[10:59:31.144]                           version <- utils::packageVersion("future")
[10:59:31.144]                       }
[10:59:31.144]                       else {
[10:59:31.144]                         version <- NULL
[10:59:31.144]                       }
[10:59:31.144]                       if (!has_future || version < "1.8.0") {
[10:59:31.144]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.144]                           "", base::R.version$version.string), 
[10:59:31.144]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.144]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.144]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.144]                             "release", "version")], collapse = " "), 
[10:59:31.144]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.144]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.144]                           info)
[10:59:31.144]                         info <- base::paste(info, collapse = "; ")
[10:59:31.144]                         if (!has_future) {
[10:59:31.144]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.144]                             info)
[10:59:31.144]                         }
[10:59:31.144]                         else {
[10:59:31.144]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.144]                             info, version)
[10:59:31.144]                         }
[10:59:31.144]                         base::stop(msg)
[10:59:31.144]                       }
[10:59:31.144]                     })
[10:59:31.144]                   }
[10:59:31.144]                   ...future.strategy.old <- future::plan("list")
[10:59:31.144]                   options(future.plan = NULL)
[10:59:31.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.144]                 }
[10:59:31.144]                 ...future.workdir <- getwd()
[10:59:31.144]             }
[10:59:31.144]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.144]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.144]         }
[10:59:31.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.144]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:31.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.144]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.144]             base::names(...future.oldOptions))
[10:59:31.144]     }
[10:59:31.144]     if (FALSE) {
[10:59:31.144]     }
[10:59:31.144]     else {
[10:59:31.144]         if (TRUE) {
[10:59:31.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.144]                 open = "w")
[10:59:31.144]         }
[10:59:31.144]         else {
[10:59:31.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.144]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.144]         }
[10:59:31.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.144]             base::sink(type = "output", split = FALSE)
[10:59:31.144]             base::close(...future.stdout)
[10:59:31.144]         }, add = TRUE)
[10:59:31.144]     }
[10:59:31.144]     ...future.frame <- base::sys.nframe()
[10:59:31.144]     ...future.conditions <- base::list()
[10:59:31.144]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.144]     if (FALSE) {
[10:59:31.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.144]     }
[10:59:31.144]     ...future.result <- base::tryCatch({
[10:59:31.144]         base::withCallingHandlers({
[10:59:31.144]             ...future.value <- base::withVisible(base::local({
[10:59:31.144]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.144]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.144]                   ...future.globals.maxSize)) {
[10:59:31.144]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.144]                   on.exit(options(oopts), add = TRUE)
[10:59:31.144]                 }
[10:59:31.144]                 {
[10:59:31.144]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.144]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.144]                     USE.NAMES = FALSE)
[10:59:31.144]                   do.call(mapply, args = args)
[10:59:31.144]                 }
[10:59:31.144]             }))
[10:59:31.144]             future::FutureResult(value = ...future.value$value, 
[10:59:31.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.144]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.144]                     ...future.globalenv.names))
[10:59:31.144]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.144]         }, condition = base::local({
[10:59:31.144]             c <- base::c
[10:59:31.144]             inherits <- base::inherits
[10:59:31.144]             invokeRestart <- base::invokeRestart
[10:59:31.144]             length <- base::length
[10:59:31.144]             list <- base::list
[10:59:31.144]             seq.int <- base::seq.int
[10:59:31.144]             signalCondition <- base::signalCondition
[10:59:31.144]             sys.calls <- base::sys.calls
[10:59:31.144]             `[[` <- base::`[[`
[10:59:31.144]             `+` <- base::`+`
[10:59:31.144]             `<<-` <- base::`<<-`
[10:59:31.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.144]                   3L)]
[10:59:31.144]             }
[10:59:31.144]             function(cond) {
[10:59:31.144]                 is_error <- inherits(cond, "error")
[10:59:31.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.144]                   NULL)
[10:59:31.144]                 if (is_error) {
[10:59:31.144]                   sessionInformation <- function() {
[10:59:31.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.144]                       search = base::search(), system = base::Sys.info())
[10:59:31.144]                   }
[10:59:31.144]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.144]                     cond$call), session = sessionInformation(), 
[10:59:31.144]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.144]                   signalCondition(cond)
[10:59:31.144]                 }
[10:59:31.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.144]                 "immediateCondition"))) {
[10:59:31.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.144]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.144]                   if (TRUE && !signal) {
[10:59:31.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.144]                     {
[10:59:31.144]                       inherits <- base::inherits
[10:59:31.144]                       invokeRestart <- base::invokeRestart
[10:59:31.144]                       is.null <- base::is.null
[10:59:31.144]                       muffled <- FALSE
[10:59:31.144]                       if (inherits(cond, "message")) {
[10:59:31.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.144]                         if (muffled) 
[10:59:31.144]                           invokeRestart("muffleMessage")
[10:59:31.144]                       }
[10:59:31.144]                       else if (inherits(cond, "warning")) {
[10:59:31.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.144]                         if (muffled) 
[10:59:31.144]                           invokeRestart("muffleWarning")
[10:59:31.144]                       }
[10:59:31.144]                       else if (inherits(cond, "condition")) {
[10:59:31.144]                         if (!is.null(pattern)) {
[10:59:31.144]                           computeRestarts <- base::computeRestarts
[10:59:31.144]                           grepl <- base::grepl
[10:59:31.144]                           restarts <- computeRestarts(cond)
[10:59:31.144]                           for (restart in restarts) {
[10:59:31.144]                             name <- restart$name
[10:59:31.144]                             if (is.null(name)) 
[10:59:31.144]                               next
[10:59:31.144]                             if (!grepl(pattern, name)) 
[10:59:31.144]                               next
[10:59:31.144]                             invokeRestart(restart)
[10:59:31.144]                             muffled <- TRUE
[10:59:31.144]                             break
[10:59:31.144]                           }
[10:59:31.144]                         }
[10:59:31.144]                       }
[10:59:31.144]                       invisible(muffled)
[10:59:31.144]                     }
[10:59:31.144]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.144]                   }
[10:59:31.144]                 }
[10:59:31.144]                 else {
[10:59:31.144]                   if (TRUE) {
[10:59:31.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.144]                     {
[10:59:31.144]                       inherits <- base::inherits
[10:59:31.144]                       invokeRestart <- base::invokeRestart
[10:59:31.144]                       is.null <- base::is.null
[10:59:31.144]                       muffled <- FALSE
[10:59:31.144]                       if (inherits(cond, "message")) {
[10:59:31.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.144]                         if (muffled) 
[10:59:31.144]                           invokeRestart("muffleMessage")
[10:59:31.144]                       }
[10:59:31.144]                       else if (inherits(cond, "warning")) {
[10:59:31.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.144]                         if (muffled) 
[10:59:31.144]                           invokeRestart("muffleWarning")
[10:59:31.144]                       }
[10:59:31.144]                       else if (inherits(cond, "condition")) {
[10:59:31.144]                         if (!is.null(pattern)) {
[10:59:31.144]                           computeRestarts <- base::computeRestarts
[10:59:31.144]                           grepl <- base::grepl
[10:59:31.144]                           restarts <- computeRestarts(cond)
[10:59:31.144]                           for (restart in restarts) {
[10:59:31.144]                             name <- restart$name
[10:59:31.144]                             if (is.null(name)) 
[10:59:31.144]                               next
[10:59:31.144]                             if (!grepl(pattern, name)) 
[10:59:31.144]                               next
[10:59:31.144]                             invokeRestart(restart)
[10:59:31.144]                             muffled <- TRUE
[10:59:31.144]                             break
[10:59:31.144]                           }
[10:59:31.144]                         }
[10:59:31.144]                       }
[10:59:31.144]                       invisible(muffled)
[10:59:31.144]                     }
[10:59:31.144]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.144]                   }
[10:59:31.144]                 }
[10:59:31.144]             }
[10:59:31.144]         }))
[10:59:31.144]     }, error = function(ex) {
[10:59:31.144]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.144]                 ...future.rng), started = ...future.startTime, 
[10:59:31.144]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.144]             version = "1.8"), class = "FutureResult")
[10:59:31.144]     }, finally = {
[10:59:31.144]         if (!identical(...future.workdir, getwd())) 
[10:59:31.144]             setwd(...future.workdir)
[10:59:31.144]         {
[10:59:31.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.144]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.144]             }
[10:59:31.144]             base::options(...future.oldOptions)
[10:59:31.144]             if (.Platform$OS.type == "windows") {
[10:59:31.144]                 old_names <- names(...future.oldEnvVars)
[10:59:31.144]                 envs <- base::Sys.getenv()
[10:59:31.144]                 names <- names(envs)
[10:59:31.144]                 common <- intersect(names, old_names)
[10:59:31.144]                 added <- setdiff(names, old_names)
[10:59:31.144]                 removed <- setdiff(old_names, names)
[10:59:31.144]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.144]                   envs[common]]
[10:59:31.144]                 NAMES <- toupper(changed)
[10:59:31.144]                 args <- list()
[10:59:31.144]                 for (kk in seq_along(NAMES)) {
[10:59:31.144]                   name <- changed[[kk]]
[10:59:31.144]                   NAME <- NAMES[[kk]]
[10:59:31.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.144]                     next
[10:59:31.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.144]                 }
[10:59:31.144]                 NAMES <- toupper(added)
[10:59:31.144]                 for (kk in seq_along(NAMES)) {
[10:59:31.144]                   name <- added[[kk]]
[10:59:31.144]                   NAME <- NAMES[[kk]]
[10:59:31.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.144]                     next
[10:59:31.144]                   args[[name]] <- ""
[10:59:31.144]                 }
[10:59:31.144]                 NAMES <- toupper(removed)
[10:59:31.144]                 for (kk in seq_along(NAMES)) {
[10:59:31.144]                   name <- removed[[kk]]
[10:59:31.144]                   NAME <- NAMES[[kk]]
[10:59:31.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.144]                     next
[10:59:31.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.144]                 }
[10:59:31.144]                 if (length(args) > 0) 
[10:59:31.144]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.144]             }
[10:59:31.144]             else {
[10:59:31.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.144]             }
[10:59:31.144]             {
[10:59:31.144]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.144]                   0L) {
[10:59:31.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.144]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.144]                   base::options(opts)
[10:59:31.144]                 }
[10:59:31.144]                 {
[10:59:31.144]                   {
[10:59:31.144]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.144]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.144]                     1047550554L), envir = base::globalenv(), 
[10:59:31.144]                       inherits = FALSE)
[10:59:31.144]                     NULL
[10:59:31.144]                   }
[10:59:31.144]                   options(future.plan = NULL)
[10:59:31.144]                   if (is.na(NA_character_)) 
[10:59:31.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.144]                     .init = FALSE)
[10:59:31.144]                 }
[10:59:31.144]             }
[10:59:31.144]         }
[10:59:31.144]     })
[10:59:31.144]     if (TRUE) {
[10:59:31.144]         base::sink(type = "output", split = FALSE)
[10:59:31.144]         if (TRUE) {
[10:59:31.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.144]         }
[10:59:31.144]         else {
[10:59:31.144]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.144]         }
[10:59:31.144]         base::close(...future.stdout)
[10:59:31.144]         ...future.stdout <- NULL
[10:59:31.144]     }
[10:59:31.144]     ...future.result$conditions <- ...future.conditions
[10:59:31.144]     ...future.result$finished <- base::Sys.time()
[10:59:31.144]     ...future.result
[10:59:31.144] }
[10:59:31.145] assign_globals() ...
[10:59:31.145] List of 5
[10:59:31.145]  $ ...future.FUN            :function (C, k)  
[10:59:31.145]  $ MoreArgs                 : NULL
[10:59:31.145]  $ ...future.elements_ii    :List of 2
[10:59:31.145]   ..$ :List of 1
[10:59:31.145]   .. ..$ : chr "A"
[10:59:31.145]   ..$ :List of 1
[10:59:31.145]   .. ..$ : int 5
[10:59:31.145]  $ ...future.seeds_ii       : NULL
[10:59:31.145]  $ ...future.globals.maxSize: NULL
[10:59:31.145]  - attr(*, "where")=List of 5
[10:59:31.145]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.145]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.145]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.145]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.145]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.145]  - attr(*, "resolved")= logi FALSE
[10:59:31.145]  - attr(*, "total_size")= num 847
[10:59:31.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.145]  - attr(*, "already-done")= logi TRUE
[10:59:31.150] - reassign environment for ‘...future.FUN’
[10:59:31.150] - copied ‘...future.FUN’ to environment
[10:59:31.150] - copied ‘MoreArgs’ to environment
[10:59:31.150] - copied ‘...future.elements_ii’ to environment
[10:59:31.150] - copied ‘...future.seeds_ii’ to environment
[10:59:31.150] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.150] assign_globals() ... done
[10:59:31.150] plan(): Setting new future strategy stack:
[10:59:31.151] List of future strategies:
[10:59:31.151] 1. sequential:
[10:59:31.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.151]    - tweaked: FALSE
[10:59:31.151]    - call: NULL
[10:59:31.151] plan(): nbrOfWorkers() = 1
[10:59:31.152] plan(): Setting new future strategy stack:
[10:59:31.152] List of future strategies:
[10:59:31.152] 1. sequential:
[10:59:31.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.152]    - tweaked: FALSE
[10:59:31.152]    - call: plan(strategy)
[10:59:31.152] plan(): nbrOfWorkers() = 1
[10:59:31.152] SequentialFuture started (and completed)
[10:59:31.152] - Launch lazy future ... done
[10:59:31.152] run() for ‘SequentialFuture’ ... done
[10:59:31.153] Created future:
[10:59:31.153] SequentialFuture:
[10:59:31.153] Label: ‘future_mapply-1’
[10:59:31.153] Expression:
[10:59:31.153] {
[10:59:31.153]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.153]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.153]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.153]         on.exit(options(oopts), add = TRUE)
[10:59:31.153]     }
[10:59:31.153]     {
[10:59:31.153]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.153]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.153]         do.call(mapply, args = args)
[10:59:31.153]     }
[10:59:31.153] }
[10:59:31.153] Lazy evaluation: FALSE
[10:59:31.153] Asynchronous evaluation: FALSE
[10:59:31.153] Local evaluation: TRUE
[10:59:31.153] Environment: R_GlobalEnv
[10:59:31.153] Capture standard output: TRUE
[10:59:31.153] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.153] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.153] Packages: <none>
[10:59:31.153] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.153] Resolved: TRUE
[10:59:31.153] Value: 52 bytes of class ‘list’
[10:59:31.153] Early signaling: FALSE
[10:59:31.153] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.153] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.153] Chunk #1 of 5 ... DONE
[10:59:31.153] Chunk #2 of 5 ...
[10:59:31.154]  - Finding globals in '...' for chunk #2 ...
[10:59:31.154] getGlobalsAndPackages() ...
[10:59:31.154] Searching for globals...
[10:59:31.154] 
[10:59:31.154] Searching for globals ... DONE
[10:59:31.154] - globals: [0] <none>
[10:59:31.154] getGlobalsAndPackages() ... DONE
[10:59:31.154]    + additional globals found: [n=0] 
[10:59:31.154]    + additional namespaces needed: [n=0] 
[10:59:31.154]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:31.154]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:31.155]  - seeds: <none>
[10:59:31.155]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.155] getGlobalsAndPackages() ...
[10:59:31.155] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.155] Resolving globals: FALSE
[10:59:31.155] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:31.156] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.156] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.156] 
[10:59:31.156] getGlobalsAndPackages() ... DONE
[10:59:31.156] run() for ‘Future’ ...
[10:59:31.156] - state: ‘created’
[10:59:31.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.157] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.157]   - Field: ‘label’
[10:59:31.157]   - Field: ‘local’
[10:59:31.157]   - Field: ‘owner’
[10:59:31.157]   - Field: ‘envir’
[10:59:31.157]   - Field: ‘packages’
[10:59:31.157]   - Field: ‘gc’
[10:59:31.157]   - Field: ‘conditions’
[10:59:31.157]   - Field: ‘expr’
[10:59:31.157]   - Field: ‘uuid’
[10:59:31.158]   - Field: ‘seed’
[10:59:31.158]   - Field: ‘version’
[10:59:31.158]   - Field: ‘result’
[10:59:31.158]   - Field: ‘asynchronous’
[10:59:31.158]   - Field: ‘calls’
[10:59:31.158]   - Field: ‘globals’
[10:59:31.158]   - Field: ‘stdout’
[10:59:31.158]   - Field: ‘earlySignal’
[10:59:31.158]   - Field: ‘lazy’
[10:59:31.158]   - Field: ‘state’
[10:59:31.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.158] - Launch lazy future ...
[10:59:31.159] Packages needed by the future expression (n = 0): <none>
[10:59:31.159] Packages needed by future strategies (n = 0): <none>
[10:59:31.159] {
[10:59:31.159]     {
[10:59:31.159]         {
[10:59:31.159]             ...future.startTime <- base::Sys.time()
[10:59:31.159]             {
[10:59:31.159]                 {
[10:59:31.159]                   {
[10:59:31.159]                     base::local({
[10:59:31.159]                       has_future <- base::requireNamespace("future", 
[10:59:31.159]                         quietly = TRUE)
[10:59:31.159]                       if (has_future) {
[10:59:31.159]                         ns <- base::getNamespace("future")
[10:59:31.159]                         version <- ns[[".package"]][["version"]]
[10:59:31.159]                         if (is.null(version)) 
[10:59:31.159]                           version <- utils::packageVersion("future")
[10:59:31.159]                       }
[10:59:31.159]                       else {
[10:59:31.159]                         version <- NULL
[10:59:31.159]                       }
[10:59:31.159]                       if (!has_future || version < "1.8.0") {
[10:59:31.159]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.159]                           "", base::R.version$version.string), 
[10:59:31.159]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.159]                             "release", "version")], collapse = " "), 
[10:59:31.159]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.159]                           info)
[10:59:31.159]                         info <- base::paste(info, collapse = "; ")
[10:59:31.159]                         if (!has_future) {
[10:59:31.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.159]                             info)
[10:59:31.159]                         }
[10:59:31.159]                         else {
[10:59:31.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.159]                             info, version)
[10:59:31.159]                         }
[10:59:31.159]                         base::stop(msg)
[10:59:31.159]                       }
[10:59:31.159]                     })
[10:59:31.159]                   }
[10:59:31.159]                   ...future.strategy.old <- future::plan("list")
[10:59:31.159]                   options(future.plan = NULL)
[10:59:31.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.159]                 }
[10:59:31.159]                 ...future.workdir <- getwd()
[10:59:31.159]             }
[10:59:31.159]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.159]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.159]         }
[10:59:31.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.159]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:31.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.159]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.159]             base::names(...future.oldOptions))
[10:59:31.159]     }
[10:59:31.159]     if (FALSE) {
[10:59:31.159]     }
[10:59:31.159]     else {
[10:59:31.159]         if (TRUE) {
[10:59:31.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.159]                 open = "w")
[10:59:31.159]         }
[10:59:31.159]         else {
[10:59:31.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.159]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.159]         }
[10:59:31.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.159]             base::sink(type = "output", split = FALSE)
[10:59:31.159]             base::close(...future.stdout)
[10:59:31.159]         }, add = TRUE)
[10:59:31.159]     }
[10:59:31.159]     ...future.frame <- base::sys.nframe()
[10:59:31.159]     ...future.conditions <- base::list()
[10:59:31.159]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.159]     if (FALSE) {
[10:59:31.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.159]     }
[10:59:31.159]     ...future.result <- base::tryCatch({
[10:59:31.159]         base::withCallingHandlers({
[10:59:31.159]             ...future.value <- base::withVisible(base::local({
[10:59:31.159]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.159]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.159]                   ...future.globals.maxSize)) {
[10:59:31.159]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.159]                   on.exit(options(oopts), add = TRUE)
[10:59:31.159]                 }
[10:59:31.159]                 {
[10:59:31.159]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.159]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.159]                     USE.NAMES = FALSE)
[10:59:31.159]                   do.call(mapply, args = args)
[10:59:31.159]                 }
[10:59:31.159]             }))
[10:59:31.159]             future::FutureResult(value = ...future.value$value, 
[10:59:31.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.159]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.159]                     ...future.globalenv.names))
[10:59:31.159]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.159]         }, condition = base::local({
[10:59:31.159]             c <- base::c
[10:59:31.159]             inherits <- base::inherits
[10:59:31.159]             invokeRestart <- base::invokeRestart
[10:59:31.159]             length <- base::length
[10:59:31.159]             list <- base::list
[10:59:31.159]             seq.int <- base::seq.int
[10:59:31.159]             signalCondition <- base::signalCondition
[10:59:31.159]             sys.calls <- base::sys.calls
[10:59:31.159]             `[[` <- base::`[[`
[10:59:31.159]             `+` <- base::`+`
[10:59:31.159]             `<<-` <- base::`<<-`
[10:59:31.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.159]                   3L)]
[10:59:31.159]             }
[10:59:31.159]             function(cond) {
[10:59:31.159]                 is_error <- inherits(cond, "error")
[10:59:31.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.159]                   NULL)
[10:59:31.159]                 if (is_error) {
[10:59:31.159]                   sessionInformation <- function() {
[10:59:31.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.159]                       search = base::search(), system = base::Sys.info())
[10:59:31.159]                   }
[10:59:31.159]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.159]                     cond$call), session = sessionInformation(), 
[10:59:31.159]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.159]                   signalCondition(cond)
[10:59:31.159]                 }
[10:59:31.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.159]                 "immediateCondition"))) {
[10:59:31.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.159]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.159]                   if (TRUE && !signal) {
[10:59:31.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.159]                     {
[10:59:31.159]                       inherits <- base::inherits
[10:59:31.159]                       invokeRestart <- base::invokeRestart
[10:59:31.159]                       is.null <- base::is.null
[10:59:31.159]                       muffled <- FALSE
[10:59:31.159]                       if (inherits(cond, "message")) {
[10:59:31.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.159]                         if (muffled) 
[10:59:31.159]                           invokeRestart("muffleMessage")
[10:59:31.159]                       }
[10:59:31.159]                       else if (inherits(cond, "warning")) {
[10:59:31.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.159]                         if (muffled) 
[10:59:31.159]                           invokeRestart("muffleWarning")
[10:59:31.159]                       }
[10:59:31.159]                       else if (inherits(cond, "condition")) {
[10:59:31.159]                         if (!is.null(pattern)) {
[10:59:31.159]                           computeRestarts <- base::computeRestarts
[10:59:31.159]                           grepl <- base::grepl
[10:59:31.159]                           restarts <- computeRestarts(cond)
[10:59:31.159]                           for (restart in restarts) {
[10:59:31.159]                             name <- restart$name
[10:59:31.159]                             if (is.null(name)) 
[10:59:31.159]                               next
[10:59:31.159]                             if (!grepl(pattern, name)) 
[10:59:31.159]                               next
[10:59:31.159]                             invokeRestart(restart)
[10:59:31.159]                             muffled <- TRUE
[10:59:31.159]                             break
[10:59:31.159]                           }
[10:59:31.159]                         }
[10:59:31.159]                       }
[10:59:31.159]                       invisible(muffled)
[10:59:31.159]                     }
[10:59:31.159]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.159]                   }
[10:59:31.159]                 }
[10:59:31.159]                 else {
[10:59:31.159]                   if (TRUE) {
[10:59:31.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.159]                     {
[10:59:31.159]                       inherits <- base::inherits
[10:59:31.159]                       invokeRestart <- base::invokeRestart
[10:59:31.159]                       is.null <- base::is.null
[10:59:31.159]                       muffled <- FALSE
[10:59:31.159]                       if (inherits(cond, "message")) {
[10:59:31.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.159]                         if (muffled) 
[10:59:31.159]                           invokeRestart("muffleMessage")
[10:59:31.159]                       }
[10:59:31.159]                       else if (inherits(cond, "warning")) {
[10:59:31.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.159]                         if (muffled) 
[10:59:31.159]                           invokeRestart("muffleWarning")
[10:59:31.159]                       }
[10:59:31.159]                       else if (inherits(cond, "condition")) {
[10:59:31.159]                         if (!is.null(pattern)) {
[10:59:31.159]                           computeRestarts <- base::computeRestarts
[10:59:31.159]                           grepl <- base::grepl
[10:59:31.159]                           restarts <- computeRestarts(cond)
[10:59:31.159]                           for (restart in restarts) {
[10:59:31.159]                             name <- restart$name
[10:59:31.159]                             if (is.null(name)) 
[10:59:31.159]                               next
[10:59:31.159]                             if (!grepl(pattern, name)) 
[10:59:31.159]                               next
[10:59:31.159]                             invokeRestart(restart)
[10:59:31.159]                             muffled <- TRUE
[10:59:31.159]                             break
[10:59:31.159]                           }
[10:59:31.159]                         }
[10:59:31.159]                       }
[10:59:31.159]                       invisible(muffled)
[10:59:31.159]                     }
[10:59:31.159]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.159]                   }
[10:59:31.159]                 }
[10:59:31.159]             }
[10:59:31.159]         }))
[10:59:31.159]     }, error = function(ex) {
[10:59:31.159]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.159]                 ...future.rng), started = ...future.startTime, 
[10:59:31.159]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.159]             version = "1.8"), class = "FutureResult")
[10:59:31.159]     }, finally = {
[10:59:31.159]         if (!identical(...future.workdir, getwd())) 
[10:59:31.159]             setwd(...future.workdir)
[10:59:31.159]         {
[10:59:31.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.159]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.159]             }
[10:59:31.159]             base::options(...future.oldOptions)
[10:59:31.159]             if (.Platform$OS.type == "windows") {
[10:59:31.159]                 old_names <- names(...future.oldEnvVars)
[10:59:31.159]                 envs <- base::Sys.getenv()
[10:59:31.159]                 names <- names(envs)
[10:59:31.159]                 common <- intersect(names, old_names)
[10:59:31.159]                 added <- setdiff(names, old_names)
[10:59:31.159]                 removed <- setdiff(old_names, names)
[10:59:31.159]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.159]                   envs[common]]
[10:59:31.159]                 NAMES <- toupper(changed)
[10:59:31.159]                 args <- list()
[10:59:31.159]                 for (kk in seq_along(NAMES)) {
[10:59:31.159]                   name <- changed[[kk]]
[10:59:31.159]                   NAME <- NAMES[[kk]]
[10:59:31.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.159]                     next
[10:59:31.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.159]                 }
[10:59:31.159]                 NAMES <- toupper(added)
[10:59:31.159]                 for (kk in seq_along(NAMES)) {
[10:59:31.159]                   name <- added[[kk]]
[10:59:31.159]                   NAME <- NAMES[[kk]]
[10:59:31.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.159]                     next
[10:59:31.159]                   args[[name]] <- ""
[10:59:31.159]                 }
[10:59:31.159]                 NAMES <- toupper(removed)
[10:59:31.159]                 for (kk in seq_along(NAMES)) {
[10:59:31.159]                   name <- removed[[kk]]
[10:59:31.159]                   NAME <- NAMES[[kk]]
[10:59:31.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.159]                     next
[10:59:31.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.159]                 }
[10:59:31.159]                 if (length(args) > 0) 
[10:59:31.159]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.159]             }
[10:59:31.159]             else {
[10:59:31.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.159]             }
[10:59:31.159]             {
[10:59:31.159]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.159]                   0L) {
[10:59:31.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.159]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.159]                   base::options(opts)
[10:59:31.159]                 }
[10:59:31.159]                 {
[10:59:31.159]                   {
[10:59:31.159]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.159]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.159]                     1047550554L), envir = base::globalenv(), 
[10:59:31.159]                       inherits = FALSE)
[10:59:31.159]                     NULL
[10:59:31.159]                   }
[10:59:31.159]                   options(future.plan = NULL)
[10:59:31.159]                   if (is.na(NA_character_)) 
[10:59:31.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.159]                     .init = FALSE)
[10:59:31.159]                 }
[10:59:31.159]             }
[10:59:31.159]         }
[10:59:31.159]     })
[10:59:31.159]     if (TRUE) {
[10:59:31.159]         base::sink(type = "output", split = FALSE)
[10:59:31.159]         if (TRUE) {
[10:59:31.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.159]         }
[10:59:31.159]         else {
[10:59:31.159]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.159]         }
[10:59:31.159]         base::close(...future.stdout)
[10:59:31.159]         ...future.stdout <- NULL
[10:59:31.159]     }
[10:59:31.159]     ...future.result$conditions <- ...future.conditions
[10:59:31.159]     ...future.result$finished <- base::Sys.time()
[10:59:31.159]     ...future.result
[10:59:31.159] }
[10:59:31.161] assign_globals() ...
[10:59:31.161] List of 5
[10:59:31.161]  $ ...future.FUN            :function (C, k)  
[10:59:31.161]  $ MoreArgs                 : NULL
[10:59:31.161]  $ ...future.elements_ii    :List of 2
[10:59:31.161]   ..$ :List of 1
[10:59:31.161]   .. ..$ : chr "B"
[10:59:31.161]   ..$ :List of 1
[10:59:31.161]   .. ..$ : int 4
[10:59:31.161]  $ ...future.seeds_ii       : NULL
[10:59:31.161]  $ ...future.globals.maxSize: NULL
[10:59:31.161]  - attr(*, "where")=List of 5
[10:59:31.161]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.161]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.161]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.161]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.161]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.161]  - attr(*, "resolved")= logi FALSE
[10:59:31.161]  - attr(*, "total_size")= num 847
[10:59:31.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.161]  - attr(*, "already-done")= logi TRUE
[10:59:31.166] - reassign environment for ‘...future.FUN’
[10:59:31.166] - copied ‘...future.FUN’ to environment
[10:59:31.166] - copied ‘MoreArgs’ to environment
[10:59:31.166] - copied ‘...future.elements_ii’ to environment
[10:59:31.166] - copied ‘...future.seeds_ii’ to environment
[10:59:31.167] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.167] assign_globals() ... done
[10:59:31.167] plan(): Setting new future strategy stack:
[10:59:31.167] List of future strategies:
[10:59:31.167] 1. sequential:
[10:59:31.167]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.167]    - tweaked: FALSE
[10:59:31.167]    - call: NULL
[10:59:31.167] plan(): nbrOfWorkers() = 1
[10:59:31.168] plan(): Setting new future strategy stack:
[10:59:31.168] List of future strategies:
[10:59:31.168] 1. sequential:
[10:59:31.168]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.168]    - tweaked: FALSE
[10:59:31.168]    - call: plan(strategy)
[10:59:31.168] plan(): nbrOfWorkers() = 1
[10:59:31.169] SequentialFuture started (and completed)
[10:59:31.169] - Launch lazy future ... done
[10:59:31.169] run() for ‘SequentialFuture’ ... done
[10:59:31.169] Created future:
[10:59:31.169] SequentialFuture:
[10:59:31.169] Label: ‘future_mapply-2’
[10:59:31.169] Expression:
[10:59:31.169] {
[10:59:31.169]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.169]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.169]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.169]         on.exit(options(oopts), add = TRUE)
[10:59:31.169]     }
[10:59:31.169]     {
[10:59:31.169]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.169]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.169]         do.call(mapply, args = args)
[10:59:31.169]     }
[10:59:31.169] }
[10:59:31.169] Lazy evaluation: FALSE
[10:59:31.169] Asynchronous evaluation: FALSE
[10:59:31.169] Local evaluation: TRUE
[10:59:31.169] Environment: R_GlobalEnv
[10:59:31.169] Capture standard output: TRUE
[10:59:31.169] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.169] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.169] Packages: <none>
[10:59:31.169] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.169] Resolved: TRUE
[10:59:31.169] Value: 51 bytes of class ‘list’
[10:59:31.169] Early signaling: FALSE
[10:59:31.169] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.169] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.170] Chunk #2 of 5 ... DONE
[10:59:31.170] Chunk #3 of 5 ...
[10:59:31.170]  - Finding globals in '...' for chunk #3 ...
[10:59:31.170] getGlobalsAndPackages() ...
[10:59:31.170] Searching for globals...
[10:59:31.170] 
[10:59:31.170] Searching for globals ... DONE
[10:59:31.170] - globals: [0] <none>
[10:59:31.170] getGlobalsAndPackages() ... DONE
[10:59:31.171]    + additional globals found: [n=0] 
[10:59:31.171]    + additional namespaces needed: [n=0] 
[10:59:31.171]  - Finding globals in '...' for chunk #3 ... DONE
[10:59:31.171]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:31.171]  - seeds: <none>
[10:59:31.171]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.171] getGlobalsAndPackages() ...
[10:59:31.171] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.171] Resolving globals: FALSE
[10:59:31.172] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:31.172] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.172] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.172] 
[10:59:31.172] getGlobalsAndPackages() ... DONE
[10:59:31.173] run() for ‘Future’ ...
[10:59:31.173] - state: ‘created’
[10:59:31.173] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.173] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.173]   - Field: ‘label’
[10:59:31.173]   - Field: ‘local’
[10:59:31.173]   - Field: ‘owner’
[10:59:31.173]   - Field: ‘envir’
[10:59:31.173]   - Field: ‘packages’
[10:59:31.174]   - Field: ‘gc’
[10:59:31.174]   - Field: ‘conditions’
[10:59:31.174]   - Field: ‘expr’
[10:59:31.174]   - Field: ‘uuid’
[10:59:31.174]   - Field: ‘seed’
[10:59:31.174]   - Field: ‘version’
[10:59:31.174]   - Field: ‘result’
[10:59:31.174]   - Field: ‘asynchronous’
[10:59:31.174]   - Field: ‘calls’
[10:59:31.174]   - Field: ‘globals’
[10:59:31.174]   - Field: ‘stdout’
[10:59:31.174]   - Field: ‘earlySignal’
[10:59:31.174]   - Field: ‘lazy’
[10:59:31.175]   - Field: ‘state’
[10:59:31.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.175] - Launch lazy future ...
[10:59:31.175] Packages needed by the future expression (n = 0): <none>
[10:59:31.175] Packages needed by future strategies (n = 0): <none>
[10:59:31.175] {
[10:59:31.175]     {
[10:59:31.175]         {
[10:59:31.175]             ...future.startTime <- base::Sys.time()
[10:59:31.175]             {
[10:59:31.175]                 {
[10:59:31.175]                   {
[10:59:31.175]                     base::local({
[10:59:31.175]                       has_future <- base::requireNamespace("future", 
[10:59:31.175]                         quietly = TRUE)
[10:59:31.175]                       if (has_future) {
[10:59:31.175]                         ns <- base::getNamespace("future")
[10:59:31.175]                         version <- ns[[".package"]][["version"]]
[10:59:31.175]                         if (is.null(version)) 
[10:59:31.175]                           version <- utils::packageVersion("future")
[10:59:31.175]                       }
[10:59:31.175]                       else {
[10:59:31.175]                         version <- NULL
[10:59:31.175]                       }
[10:59:31.175]                       if (!has_future || version < "1.8.0") {
[10:59:31.175]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.175]                           "", base::R.version$version.string), 
[10:59:31.175]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.175]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.175]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.175]                             "release", "version")], collapse = " "), 
[10:59:31.175]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.175]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.175]                           info)
[10:59:31.175]                         info <- base::paste(info, collapse = "; ")
[10:59:31.175]                         if (!has_future) {
[10:59:31.175]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.175]                             info)
[10:59:31.175]                         }
[10:59:31.175]                         else {
[10:59:31.175]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.175]                             info, version)
[10:59:31.175]                         }
[10:59:31.175]                         base::stop(msg)
[10:59:31.175]                       }
[10:59:31.175]                     })
[10:59:31.175]                   }
[10:59:31.175]                   ...future.strategy.old <- future::plan("list")
[10:59:31.175]                   options(future.plan = NULL)
[10:59:31.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.175]                 }
[10:59:31.175]                 ...future.workdir <- getwd()
[10:59:31.175]             }
[10:59:31.175]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.175]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.175]         }
[10:59:31.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.175]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:31.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.175]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.175]             base::names(...future.oldOptions))
[10:59:31.175]     }
[10:59:31.175]     if (FALSE) {
[10:59:31.175]     }
[10:59:31.175]     else {
[10:59:31.175]         if (TRUE) {
[10:59:31.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.175]                 open = "w")
[10:59:31.175]         }
[10:59:31.175]         else {
[10:59:31.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.175]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.175]         }
[10:59:31.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.175]             base::sink(type = "output", split = FALSE)
[10:59:31.175]             base::close(...future.stdout)
[10:59:31.175]         }, add = TRUE)
[10:59:31.175]     }
[10:59:31.175]     ...future.frame <- base::sys.nframe()
[10:59:31.175]     ...future.conditions <- base::list()
[10:59:31.175]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.175]     if (FALSE) {
[10:59:31.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.175]     }
[10:59:31.175]     ...future.result <- base::tryCatch({
[10:59:31.175]         base::withCallingHandlers({
[10:59:31.175]             ...future.value <- base::withVisible(base::local({
[10:59:31.175]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.175]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.175]                   ...future.globals.maxSize)) {
[10:59:31.175]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.175]                   on.exit(options(oopts), add = TRUE)
[10:59:31.175]                 }
[10:59:31.175]                 {
[10:59:31.175]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.175]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.175]                     USE.NAMES = FALSE)
[10:59:31.175]                   do.call(mapply, args = args)
[10:59:31.175]                 }
[10:59:31.175]             }))
[10:59:31.175]             future::FutureResult(value = ...future.value$value, 
[10:59:31.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.175]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.175]                     ...future.globalenv.names))
[10:59:31.175]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.175]         }, condition = base::local({
[10:59:31.175]             c <- base::c
[10:59:31.175]             inherits <- base::inherits
[10:59:31.175]             invokeRestart <- base::invokeRestart
[10:59:31.175]             length <- base::length
[10:59:31.175]             list <- base::list
[10:59:31.175]             seq.int <- base::seq.int
[10:59:31.175]             signalCondition <- base::signalCondition
[10:59:31.175]             sys.calls <- base::sys.calls
[10:59:31.175]             `[[` <- base::`[[`
[10:59:31.175]             `+` <- base::`+`
[10:59:31.175]             `<<-` <- base::`<<-`
[10:59:31.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.175]                   3L)]
[10:59:31.175]             }
[10:59:31.175]             function(cond) {
[10:59:31.175]                 is_error <- inherits(cond, "error")
[10:59:31.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.175]                   NULL)
[10:59:31.175]                 if (is_error) {
[10:59:31.175]                   sessionInformation <- function() {
[10:59:31.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.175]                       search = base::search(), system = base::Sys.info())
[10:59:31.175]                   }
[10:59:31.175]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.175]                     cond$call), session = sessionInformation(), 
[10:59:31.175]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.175]                   signalCondition(cond)
[10:59:31.175]                 }
[10:59:31.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.175]                 "immediateCondition"))) {
[10:59:31.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.175]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.175]                   if (TRUE && !signal) {
[10:59:31.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.175]                     {
[10:59:31.175]                       inherits <- base::inherits
[10:59:31.175]                       invokeRestart <- base::invokeRestart
[10:59:31.175]                       is.null <- base::is.null
[10:59:31.175]                       muffled <- FALSE
[10:59:31.175]                       if (inherits(cond, "message")) {
[10:59:31.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.175]                         if (muffled) 
[10:59:31.175]                           invokeRestart("muffleMessage")
[10:59:31.175]                       }
[10:59:31.175]                       else if (inherits(cond, "warning")) {
[10:59:31.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.175]                         if (muffled) 
[10:59:31.175]                           invokeRestart("muffleWarning")
[10:59:31.175]                       }
[10:59:31.175]                       else if (inherits(cond, "condition")) {
[10:59:31.175]                         if (!is.null(pattern)) {
[10:59:31.175]                           computeRestarts <- base::computeRestarts
[10:59:31.175]                           grepl <- base::grepl
[10:59:31.175]                           restarts <- computeRestarts(cond)
[10:59:31.175]                           for (restart in restarts) {
[10:59:31.175]                             name <- restart$name
[10:59:31.175]                             if (is.null(name)) 
[10:59:31.175]                               next
[10:59:31.175]                             if (!grepl(pattern, name)) 
[10:59:31.175]                               next
[10:59:31.175]                             invokeRestart(restart)
[10:59:31.175]                             muffled <- TRUE
[10:59:31.175]                             break
[10:59:31.175]                           }
[10:59:31.175]                         }
[10:59:31.175]                       }
[10:59:31.175]                       invisible(muffled)
[10:59:31.175]                     }
[10:59:31.175]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.175]                   }
[10:59:31.175]                 }
[10:59:31.175]                 else {
[10:59:31.175]                   if (TRUE) {
[10:59:31.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.175]                     {
[10:59:31.175]                       inherits <- base::inherits
[10:59:31.175]                       invokeRestart <- base::invokeRestart
[10:59:31.175]                       is.null <- base::is.null
[10:59:31.175]                       muffled <- FALSE
[10:59:31.175]                       if (inherits(cond, "message")) {
[10:59:31.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.175]                         if (muffled) 
[10:59:31.175]                           invokeRestart("muffleMessage")
[10:59:31.175]                       }
[10:59:31.175]                       else if (inherits(cond, "warning")) {
[10:59:31.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.175]                         if (muffled) 
[10:59:31.175]                           invokeRestart("muffleWarning")
[10:59:31.175]                       }
[10:59:31.175]                       else if (inherits(cond, "condition")) {
[10:59:31.175]                         if (!is.null(pattern)) {
[10:59:31.175]                           computeRestarts <- base::computeRestarts
[10:59:31.175]                           grepl <- base::grepl
[10:59:31.175]                           restarts <- computeRestarts(cond)
[10:59:31.175]                           for (restart in restarts) {
[10:59:31.175]                             name <- restart$name
[10:59:31.175]                             if (is.null(name)) 
[10:59:31.175]                               next
[10:59:31.175]                             if (!grepl(pattern, name)) 
[10:59:31.175]                               next
[10:59:31.175]                             invokeRestart(restart)
[10:59:31.175]                             muffled <- TRUE
[10:59:31.175]                             break
[10:59:31.175]                           }
[10:59:31.175]                         }
[10:59:31.175]                       }
[10:59:31.175]                       invisible(muffled)
[10:59:31.175]                     }
[10:59:31.175]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.175]                   }
[10:59:31.175]                 }
[10:59:31.175]             }
[10:59:31.175]         }))
[10:59:31.175]     }, error = function(ex) {
[10:59:31.175]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.175]                 ...future.rng), started = ...future.startTime, 
[10:59:31.175]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.175]             version = "1.8"), class = "FutureResult")
[10:59:31.175]     }, finally = {
[10:59:31.175]         if (!identical(...future.workdir, getwd())) 
[10:59:31.175]             setwd(...future.workdir)
[10:59:31.175]         {
[10:59:31.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.175]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.175]             }
[10:59:31.175]             base::options(...future.oldOptions)
[10:59:31.175]             if (.Platform$OS.type == "windows") {
[10:59:31.175]                 old_names <- names(...future.oldEnvVars)
[10:59:31.175]                 envs <- base::Sys.getenv()
[10:59:31.175]                 names <- names(envs)
[10:59:31.175]                 common <- intersect(names, old_names)
[10:59:31.175]                 added <- setdiff(names, old_names)
[10:59:31.175]                 removed <- setdiff(old_names, names)
[10:59:31.175]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.175]                   envs[common]]
[10:59:31.175]                 NAMES <- toupper(changed)
[10:59:31.175]                 args <- list()
[10:59:31.175]                 for (kk in seq_along(NAMES)) {
[10:59:31.175]                   name <- changed[[kk]]
[10:59:31.175]                   NAME <- NAMES[[kk]]
[10:59:31.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.175]                     next
[10:59:31.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.175]                 }
[10:59:31.175]                 NAMES <- toupper(added)
[10:59:31.175]                 for (kk in seq_along(NAMES)) {
[10:59:31.175]                   name <- added[[kk]]
[10:59:31.175]                   NAME <- NAMES[[kk]]
[10:59:31.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.175]                     next
[10:59:31.175]                   args[[name]] <- ""
[10:59:31.175]                 }
[10:59:31.175]                 NAMES <- toupper(removed)
[10:59:31.175]                 for (kk in seq_along(NAMES)) {
[10:59:31.175]                   name <- removed[[kk]]
[10:59:31.175]                   NAME <- NAMES[[kk]]
[10:59:31.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.175]                     next
[10:59:31.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.175]                 }
[10:59:31.175]                 if (length(args) > 0) 
[10:59:31.175]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.175]             }
[10:59:31.175]             else {
[10:59:31.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.175]             }
[10:59:31.175]             {
[10:59:31.175]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.175]                   0L) {
[10:59:31.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.175]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.175]                   base::options(opts)
[10:59:31.175]                 }
[10:59:31.175]                 {
[10:59:31.175]                   {
[10:59:31.175]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.175]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.175]                     1047550554L), envir = base::globalenv(), 
[10:59:31.175]                       inherits = FALSE)
[10:59:31.175]                     NULL
[10:59:31.175]                   }
[10:59:31.175]                   options(future.plan = NULL)
[10:59:31.175]                   if (is.na(NA_character_)) 
[10:59:31.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.175]                     .init = FALSE)
[10:59:31.175]                 }
[10:59:31.175]             }
[10:59:31.175]         }
[10:59:31.175]     })
[10:59:31.175]     if (TRUE) {
[10:59:31.175]         base::sink(type = "output", split = FALSE)
[10:59:31.175]         if (TRUE) {
[10:59:31.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.175]         }
[10:59:31.175]         else {
[10:59:31.175]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.175]         }
[10:59:31.175]         base::close(...future.stdout)
[10:59:31.175]         ...future.stdout <- NULL
[10:59:31.175]     }
[10:59:31.175]     ...future.result$conditions <- ...future.conditions
[10:59:31.175]     ...future.result$finished <- base::Sys.time()
[10:59:31.175]     ...future.result
[10:59:31.175] }
[10:59:31.177] assign_globals() ...
[10:59:31.177] List of 5
[10:59:31.177]  $ ...future.FUN            :function (C, k)  
[10:59:31.177]  $ MoreArgs                 : NULL
[10:59:31.177]  $ ...future.elements_ii    :List of 2
[10:59:31.177]   ..$ :List of 1
[10:59:31.177]   .. ..$ : chr "C"
[10:59:31.177]   ..$ :List of 1
[10:59:31.177]   .. ..$ : int 3
[10:59:31.177]  $ ...future.seeds_ii       : NULL
[10:59:31.177]  $ ...future.globals.maxSize: NULL
[10:59:31.177]  - attr(*, "where")=List of 5
[10:59:31.177]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.177]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.177]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.177]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.177]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.177]  - attr(*, "resolved")= logi FALSE
[10:59:31.177]  - attr(*, "total_size")= num 847
[10:59:31.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.177]  - attr(*, "already-done")= logi TRUE
[10:59:31.181] - reassign environment for ‘...future.FUN’
[10:59:31.182] - copied ‘...future.FUN’ to environment
[10:59:31.182] - copied ‘MoreArgs’ to environment
[10:59:31.182] - copied ‘...future.elements_ii’ to environment
[10:59:31.182] - copied ‘...future.seeds_ii’ to environment
[10:59:31.182] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.182] assign_globals() ... done
[10:59:31.182] plan(): Setting new future strategy stack:
[10:59:31.182] List of future strategies:
[10:59:31.182] 1. sequential:
[10:59:31.182]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.182]    - tweaked: FALSE
[10:59:31.182]    - call: NULL
[10:59:31.183] plan(): nbrOfWorkers() = 1
[10:59:31.183] plan(): Setting new future strategy stack:
[10:59:31.183] List of future strategies:
[10:59:31.183] 1. sequential:
[10:59:31.183]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.183]    - tweaked: FALSE
[10:59:31.183]    - call: plan(strategy)
[10:59:31.207] plan(): nbrOfWorkers() = 1
[10:59:31.207] SequentialFuture started (and completed)
[10:59:31.207] - Launch lazy future ... done
[10:59:31.207] run() for ‘SequentialFuture’ ... done
[10:59:31.208] Created future:
[10:59:31.208] SequentialFuture:
[10:59:31.208] Label: ‘future_mapply-3’
[10:59:31.208] Expression:
[10:59:31.208] {
[10:59:31.208]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.208]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.208]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.208]         on.exit(options(oopts), add = TRUE)
[10:59:31.208]     }
[10:59:31.208]     {
[10:59:31.208]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.208]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.208]         do.call(mapply, args = args)
[10:59:31.208]     }
[10:59:31.208] }
[10:59:31.208] Lazy evaluation: FALSE
[10:59:31.208] Asynchronous evaluation: FALSE
[10:59:31.208] Local evaluation: TRUE
[10:59:31.208] Environment: R_GlobalEnv
[10:59:31.208] Capture standard output: TRUE
[10:59:31.208] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.208] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.208] Packages: <none>
[10:59:31.208] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.208] Resolved: TRUE
[10:59:31.208] Value: 50 bytes of class ‘list’
[10:59:31.208] Early signaling: FALSE
[10:59:31.208] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.208] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.209] Chunk #3 of 5 ... DONE
[10:59:31.209] Chunk #4 of 5 ...
[10:59:31.209]  - Finding globals in '...' for chunk #4 ...
[10:59:31.209] getGlobalsAndPackages() ...
[10:59:31.209] Searching for globals...
[10:59:31.209] 
[10:59:31.209] Searching for globals ... DONE
[10:59:31.209] - globals: [0] <none>
[10:59:31.210] getGlobalsAndPackages() ... DONE
[10:59:31.210]    + additional globals found: [n=0] 
[10:59:31.210]    + additional namespaces needed: [n=0] 
[10:59:31.210]  - Finding globals in '...' for chunk #4 ... DONE
[10:59:31.210]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:31.210]  - seeds: <none>
[10:59:31.210]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.210] getGlobalsAndPackages() ...
[10:59:31.210] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.210] Resolving globals: FALSE
[10:59:31.211] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:31.211] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.211] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.211] 
[10:59:31.211] getGlobalsAndPackages() ... DONE
[10:59:31.212] run() for ‘Future’ ...
[10:59:31.212] - state: ‘created’
[10:59:31.212] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.212] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.212] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.212]   - Field: ‘label’
[10:59:31.212]   - Field: ‘local’
[10:59:31.212]   - Field: ‘owner’
[10:59:31.213]   - Field: ‘envir’
[10:59:31.213]   - Field: ‘packages’
[10:59:31.213]   - Field: ‘gc’
[10:59:31.213]   - Field: ‘conditions’
[10:59:31.213]   - Field: ‘expr’
[10:59:31.213]   - Field: ‘uuid’
[10:59:31.213]   - Field: ‘seed’
[10:59:31.213]   - Field: ‘version’
[10:59:31.213]   - Field: ‘result’
[10:59:31.213]   - Field: ‘asynchronous’
[10:59:31.213]   - Field: ‘calls’
[10:59:31.213]   - Field: ‘globals’
[10:59:31.214]   - Field: ‘stdout’
[10:59:31.214]   - Field: ‘earlySignal’
[10:59:31.214]   - Field: ‘lazy’
[10:59:31.214]   - Field: ‘state’
[10:59:31.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.214] - Launch lazy future ...
[10:59:31.214] Packages needed by the future expression (n = 0): <none>
[10:59:31.214] Packages needed by future strategies (n = 0): <none>
[10:59:31.215] {
[10:59:31.215]     {
[10:59:31.215]         {
[10:59:31.215]             ...future.startTime <- base::Sys.time()
[10:59:31.215]             {
[10:59:31.215]                 {
[10:59:31.215]                   {
[10:59:31.215]                     base::local({
[10:59:31.215]                       has_future <- base::requireNamespace("future", 
[10:59:31.215]                         quietly = TRUE)
[10:59:31.215]                       if (has_future) {
[10:59:31.215]                         ns <- base::getNamespace("future")
[10:59:31.215]                         version <- ns[[".package"]][["version"]]
[10:59:31.215]                         if (is.null(version)) 
[10:59:31.215]                           version <- utils::packageVersion("future")
[10:59:31.215]                       }
[10:59:31.215]                       else {
[10:59:31.215]                         version <- NULL
[10:59:31.215]                       }
[10:59:31.215]                       if (!has_future || version < "1.8.0") {
[10:59:31.215]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.215]                           "", base::R.version$version.string), 
[10:59:31.215]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.215]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.215]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.215]                             "release", "version")], collapse = " "), 
[10:59:31.215]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.215]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.215]                           info)
[10:59:31.215]                         info <- base::paste(info, collapse = "; ")
[10:59:31.215]                         if (!has_future) {
[10:59:31.215]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.215]                             info)
[10:59:31.215]                         }
[10:59:31.215]                         else {
[10:59:31.215]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.215]                             info, version)
[10:59:31.215]                         }
[10:59:31.215]                         base::stop(msg)
[10:59:31.215]                       }
[10:59:31.215]                     })
[10:59:31.215]                   }
[10:59:31.215]                   ...future.strategy.old <- future::plan("list")
[10:59:31.215]                   options(future.plan = NULL)
[10:59:31.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.215]                 }
[10:59:31.215]                 ...future.workdir <- getwd()
[10:59:31.215]             }
[10:59:31.215]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.215]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.215]         }
[10:59:31.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.215]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:31.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.215]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.215]             base::names(...future.oldOptions))
[10:59:31.215]     }
[10:59:31.215]     if (FALSE) {
[10:59:31.215]     }
[10:59:31.215]     else {
[10:59:31.215]         if (TRUE) {
[10:59:31.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.215]                 open = "w")
[10:59:31.215]         }
[10:59:31.215]         else {
[10:59:31.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.215]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.215]         }
[10:59:31.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.215]             base::sink(type = "output", split = FALSE)
[10:59:31.215]             base::close(...future.stdout)
[10:59:31.215]         }, add = TRUE)
[10:59:31.215]     }
[10:59:31.215]     ...future.frame <- base::sys.nframe()
[10:59:31.215]     ...future.conditions <- base::list()
[10:59:31.215]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.215]     if (FALSE) {
[10:59:31.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.215]     }
[10:59:31.215]     ...future.result <- base::tryCatch({
[10:59:31.215]         base::withCallingHandlers({
[10:59:31.215]             ...future.value <- base::withVisible(base::local({
[10:59:31.215]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.215]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.215]                   ...future.globals.maxSize)) {
[10:59:31.215]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.215]                   on.exit(options(oopts), add = TRUE)
[10:59:31.215]                 }
[10:59:31.215]                 {
[10:59:31.215]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.215]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.215]                     USE.NAMES = FALSE)
[10:59:31.215]                   do.call(mapply, args = args)
[10:59:31.215]                 }
[10:59:31.215]             }))
[10:59:31.215]             future::FutureResult(value = ...future.value$value, 
[10:59:31.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.215]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.215]                     ...future.globalenv.names))
[10:59:31.215]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.215]         }, condition = base::local({
[10:59:31.215]             c <- base::c
[10:59:31.215]             inherits <- base::inherits
[10:59:31.215]             invokeRestart <- base::invokeRestart
[10:59:31.215]             length <- base::length
[10:59:31.215]             list <- base::list
[10:59:31.215]             seq.int <- base::seq.int
[10:59:31.215]             signalCondition <- base::signalCondition
[10:59:31.215]             sys.calls <- base::sys.calls
[10:59:31.215]             `[[` <- base::`[[`
[10:59:31.215]             `+` <- base::`+`
[10:59:31.215]             `<<-` <- base::`<<-`
[10:59:31.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.215]                   3L)]
[10:59:31.215]             }
[10:59:31.215]             function(cond) {
[10:59:31.215]                 is_error <- inherits(cond, "error")
[10:59:31.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.215]                   NULL)
[10:59:31.215]                 if (is_error) {
[10:59:31.215]                   sessionInformation <- function() {
[10:59:31.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.215]                       search = base::search(), system = base::Sys.info())
[10:59:31.215]                   }
[10:59:31.215]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.215]                     cond$call), session = sessionInformation(), 
[10:59:31.215]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.215]                   signalCondition(cond)
[10:59:31.215]                 }
[10:59:31.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.215]                 "immediateCondition"))) {
[10:59:31.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.215]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.215]                   if (TRUE && !signal) {
[10:59:31.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.215]                     {
[10:59:31.215]                       inherits <- base::inherits
[10:59:31.215]                       invokeRestart <- base::invokeRestart
[10:59:31.215]                       is.null <- base::is.null
[10:59:31.215]                       muffled <- FALSE
[10:59:31.215]                       if (inherits(cond, "message")) {
[10:59:31.215]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.215]                         if (muffled) 
[10:59:31.215]                           invokeRestart("muffleMessage")
[10:59:31.215]                       }
[10:59:31.215]                       else if (inherits(cond, "warning")) {
[10:59:31.215]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.215]                         if (muffled) 
[10:59:31.215]                           invokeRestart("muffleWarning")
[10:59:31.215]                       }
[10:59:31.215]                       else if (inherits(cond, "condition")) {
[10:59:31.215]                         if (!is.null(pattern)) {
[10:59:31.215]                           computeRestarts <- base::computeRestarts
[10:59:31.215]                           grepl <- base::grepl
[10:59:31.215]                           restarts <- computeRestarts(cond)
[10:59:31.215]                           for (restart in restarts) {
[10:59:31.215]                             name <- restart$name
[10:59:31.215]                             if (is.null(name)) 
[10:59:31.215]                               next
[10:59:31.215]                             if (!grepl(pattern, name)) 
[10:59:31.215]                               next
[10:59:31.215]                             invokeRestart(restart)
[10:59:31.215]                             muffled <- TRUE
[10:59:31.215]                             break
[10:59:31.215]                           }
[10:59:31.215]                         }
[10:59:31.215]                       }
[10:59:31.215]                       invisible(muffled)
[10:59:31.215]                     }
[10:59:31.215]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.215]                   }
[10:59:31.215]                 }
[10:59:31.215]                 else {
[10:59:31.215]                   if (TRUE) {
[10:59:31.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.215]                     {
[10:59:31.215]                       inherits <- base::inherits
[10:59:31.215]                       invokeRestart <- base::invokeRestart
[10:59:31.215]                       is.null <- base::is.null
[10:59:31.215]                       muffled <- FALSE
[10:59:31.215]                       if (inherits(cond, "message")) {
[10:59:31.215]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.215]                         if (muffled) 
[10:59:31.215]                           invokeRestart("muffleMessage")
[10:59:31.215]                       }
[10:59:31.215]                       else if (inherits(cond, "warning")) {
[10:59:31.215]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.215]                         if (muffled) 
[10:59:31.215]                           invokeRestart("muffleWarning")
[10:59:31.215]                       }
[10:59:31.215]                       else if (inherits(cond, "condition")) {
[10:59:31.215]                         if (!is.null(pattern)) {
[10:59:31.215]                           computeRestarts <- base::computeRestarts
[10:59:31.215]                           grepl <- base::grepl
[10:59:31.215]                           restarts <- computeRestarts(cond)
[10:59:31.215]                           for (restart in restarts) {
[10:59:31.215]                             name <- restart$name
[10:59:31.215]                             if (is.null(name)) 
[10:59:31.215]                               next
[10:59:31.215]                             if (!grepl(pattern, name)) 
[10:59:31.215]                               next
[10:59:31.215]                             invokeRestart(restart)
[10:59:31.215]                             muffled <- TRUE
[10:59:31.215]                             break
[10:59:31.215]                           }
[10:59:31.215]                         }
[10:59:31.215]                       }
[10:59:31.215]                       invisible(muffled)
[10:59:31.215]                     }
[10:59:31.215]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.215]                   }
[10:59:31.215]                 }
[10:59:31.215]             }
[10:59:31.215]         }))
[10:59:31.215]     }, error = function(ex) {
[10:59:31.215]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.215]                 ...future.rng), started = ...future.startTime, 
[10:59:31.215]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.215]             version = "1.8"), class = "FutureResult")
[10:59:31.215]     }, finally = {
[10:59:31.215]         if (!identical(...future.workdir, getwd())) 
[10:59:31.215]             setwd(...future.workdir)
[10:59:31.215]         {
[10:59:31.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.215]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.215]             }
[10:59:31.215]             base::options(...future.oldOptions)
[10:59:31.215]             if (.Platform$OS.type == "windows") {
[10:59:31.215]                 old_names <- names(...future.oldEnvVars)
[10:59:31.215]                 envs <- base::Sys.getenv()
[10:59:31.215]                 names <- names(envs)
[10:59:31.215]                 common <- intersect(names, old_names)
[10:59:31.215]                 added <- setdiff(names, old_names)
[10:59:31.215]                 removed <- setdiff(old_names, names)
[10:59:31.215]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.215]                   envs[common]]
[10:59:31.215]                 NAMES <- toupper(changed)
[10:59:31.215]                 args <- list()
[10:59:31.215]                 for (kk in seq_along(NAMES)) {
[10:59:31.215]                   name <- changed[[kk]]
[10:59:31.215]                   NAME <- NAMES[[kk]]
[10:59:31.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.215]                     next
[10:59:31.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.215]                 }
[10:59:31.215]                 NAMES <- toupper(added)
[10:59:31.215]                 for (kk in seq_along(NAMES)) {
[10:59:31.215]                   name <- added[[kk]]
[10:59:31.215]                   NAME <- NAMES[[kk]]
[10:59:31.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.215]                     next
[10:59:31.215]                   args[[name]] <- ""
[10:59:31.215]                 }
[10:59:31.215]                 NAMES <- toupper(removed)
[10:59:31.215]                 for (kk in seq_along(NAMES)) {
[10:59:31.215]                   name <- removed[[kk]]
[10:59:31.215]                   NAME <- NAMES[[kk]]
[10:59:31.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.215]                     next
[10:59:31.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.215]                 }
[10:59:31.215]                 if (length(args) > 0) 
[10:59:31.215]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.215]             }
[10:59:31.215]             else {
[10:59:31.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.215]             }
[10:59:31.215]             {
[10:59:31.215]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.215]                   0L) {
[10:59:31.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.215]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.215]                   base::options(opts)
[10:59:31.215]                 }
[10:59:31.215]                 {
[10:59:31.215]                   {
[10:59:31.215]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.215]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.215]                     1047550554L), envir = base::globalenv(), 
[10:59:31.215]                       inherits = FALSE)
[10:59:31.215]                     NULL
[10:59:31.215]                   }
[10:59:31.215]                   options(future.plan = NULL)
[10:59:31.215]                   if (is.na(NA_character_)) 
[10:59:31.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.215]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.215]                     .init = FALSE)
[10:59:31.215]                 }
[10:59:31.215]             }
[10:59:31.215]         }
[10:59:31.215]     })
[10:59:31.215]     if (TRUE) {
[10:59:31.215]         base::sink(type = "output", split = FALSE)
[10:59:31.215]         if (TRUE) {
[10:59:31.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.215]         }
[10:59:31.215]         else {
[10:59:31.215]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.215]         }
[10:59:31.215]         base::close(...future.stdout)
[10:59:31.215]         ...future.stdout <- NULL
[10:59:31.215]     }
[10:59:31.215]     ...future.result$conditions <- ...future.conditions
[10:59:31.215]     ...future.result$finished <- base::Sys.time()
[10:59:31.215]     ...future.result
[10:59:31.215] }
[10:59:31.216] assign_globals() ...
[10:59:31.216] List of 5
[10:59:31.216]  $ ...future.FUN            :function (C, k)  
[10:59:31.216]  $ MoreArgs                 : NULL
[10:59:31.216]  $ ...future.elements_ii    :List of 2
[10:59:31.216]   ..$ :List of 1
[10:59:31.216]   .. ..$ : chr "D"
[10:59:31.216]   ..$ :List of 1
[10:59:31.216]   .. ..$ : int 2
[10:59:31.216]  $ ...future.seeds_ii       : NULL
[10:59:31.216]  $ ...future.globals.maxSize: NULL
[10:59:31.216]  - attr(*, "where")=List of 5
[10:59:31.216]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.216]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.216]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.216]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.216]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.216]  - attr(*, "resolved")= logi FALSE
[10:59:31.216]  - attr(*, "total_size")= num 847
[10:59:31.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.216]  - attr(*, "already-done")= logi TRUE
[10:59:31.221] - reassign environment for ‘...future.FUN’
[10:59:31.221] - copied ‘...future.FUN’ to environment
[10:59:31.221] - copied ‘MoreArgs’ to environment
[10:59:31.221] - copied ‘...future.elements_ii’ to environment
[10:59:31.222] - copied ‘...future.seeds_ii’ to environment
[10:59:31.222] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.222] assign_globals() ... done
[10:59:31.222] plan(): Setting new future strategy stack:
[10:59:31.222] List of future strategies:
[10:59:31.222] 1. sequential:
[10:59:31.222]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.222]    - tweaked: FALSE
[10:59:31.222]    - call: NULL
[10:59:31.222] plan(): nbrOfWorkers() = 1
[10:59:31.223] plan(): Setting new future strategy stack:
[10:59:31.223] List of future strategies:
[10:59:31.223] 1. sequential:
[10:59:31.223]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.223]    - tweaked: FALSE
[10:59:31.223]    - call: plan(strategy)
[10:59:31.224] plan(): nbrOfWorkers() = 1
[10:59:31.224] SequentialFuture started (and completed)
[10:59:31.224] - Launch lazy future ... done
[10:59:31.224] run() for ‘SequentialFuture’ ... done
[10:59:31.224] Created future:
[10:59:31.224] SequentialFuture:
[10:59:31.224] Label: ‘future_mapply-4’
[10:59:31.224] Expression:
[10:59:31.224] {
[10:59:31.224]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.224]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.224]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.224]         on.exit(options(oopts), add = TRUE)
[10:59:31.224]     }
[10:59:31.224]     {
[10:59:31.224]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.224]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.224]         do.call(mapply, args = args)
[10:59:31.224]     }
[10:59:31.224] }
[10:59:31.224] Lazy evaluation: FALSE
[10:59:31.224] Asynchronous evaluation: FALSE
[10:59:31.224] Local evaluation: TRUE
[10:59:31.224] Environment: R_GlobalEnv
[10:59:31.224] Capture standard output: TRUE
[10:59:31.224] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.224] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.224] Packages: <none>
[10:59:31.224] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.224] Resolved: TRUE
[10:59:31.224] Value: 49 bytes of class ‘list’
[10:59:31.224] Early signaling: FALSE
[10:59:31.224] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.224] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.225] Chunk #4 of 5 ... DONE
[10:59:31.225] Chunk #5 of 5 ...
[10:59:31.225]  - Finding globals in '...' for chunk #5 ...
[10:59:31.225] getGlobalsAndPackages() ...
[10:59:31.225] Searching for globals...
[10:59:31.226] 
[10:59:31.226] Searching for globals ... DONE
[10:59:31.226] - globals: [0] <none>
[10:59:31.226] getGlobalsAndPackages() ... DONE
[10:59:31.226]    + additional globals found: [n=0] 
[10:59:31.226]    + additional namespaces needed: [n=0] 
[10:59:31.226]  - Finding globals in '...' for chunk #5 ... DONE
[10:59:31.226]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:31.226]  - seeds: <none>
[10:59:31.226]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.226] getGlobalsAndPackages() ...
[10:59:31.227] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.227] Resolving globals: FALSE
[10:59:31.227] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:31.227] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.228] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.228] 
[10:59:31.228] getGlobalsAndPackages() ... DONE
[10:59:31.228] run() for ‘Future’ ...
[10:59:31.228] - state: ‘created’
[10:59:31.228] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.228] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.229]   - Field: ‘label’
[10:59:31.229]   - Field: ‘local’
[10:59:31.229]   - Field: ‘owner’
[10:59:31.229]   - Field: ‘envir’
[10:59:31.229]   - Field: ‘packages’
[10:59:31.229]   - Field: ‘gc’
[10:59:31.229]   - Field: ‘conditions’
[10:59:31.229]   - Field: ‘expr’
[10:59:31.229]   - Field: ‘uuid’
[10:59:31.229]   - Field: ‘seed’
[10:59:31.229]   - Field: ‘version’
[10:59:31.230]   - Field: ‘result’
[10:59:31.230]   - Field: ‘asynchronous’
[10:59:31.230]   - Field: ‘calls’
[10:59:31.230]   - Field: ‘globals’
[10:59:31.230]   - Field: ‘stdout’
[10:59:31.230]   - Field: ‘earlySignal’
[10:59:31.230]   - Field: ‘lazy’
[10:59:31.230]   - Field: ‘state’
[10:59:31.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.230] - Launch lazy future ...
[10:59:31.230] Packages needed by the future expression (n = 0): <none>
[10:59:31.231] Packages needed by future strategies (n = 0): <none>
[10:59:31.232] {
[10:59:31.232]     {
[10:59:31.232]         {
[10:59:31.232]             ...future.startTime <- base::Sys.time()
[10:59:31.232]             {
[10:59:31.232]                 {
[10:59:31.232]                   {
[10:59:31.232]                     base::local({
[10:59:31.232]                       has_future <- base::requireNamespace("future", 
[10:59:31.232]                         quietly = TRUE)
[10:59:31.232]                       if (has_future) {
[10:59:31.232]                         ns <- base::getNamespace("future")
[10:59:31.232]                         version <- ns[[".package"]][["version"]]
[10:59:31.232]                         if (is.null(version)) 
[10:59:31.232]                           version <- utils::packageVersion("future")
[10:59:31.232]                       }
[10:59:31.232]                       else {
[10:59:31.232]                         version <- NULL
[10:59:31.232]                       }
[10:59:31.232]                       if (!has_future || version < "1.8.0") {
[10:59:31.232]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.232]                           "", base::R.version$version.string), 
[10:59:31.232]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.232]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.232]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.232]                             "release", "version")], collapse = " "), 
[10:59:31.232]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.232]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.232]                           info)
[10:59:31.232]                         info <- base::paste(info, collapse = "; ")
[10:59:31.232]                         if (!has_future) {
[10:59:31.232]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.232]                             info)
[10:59:31.232]                         }
[10:59:31.232]                         else {
[10:59:31.232]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.232]                             info, version)
[10:59:31.232]                         }
[10:59:31.232]                         base::stop(msg)
[10:59:31.232]                       }
[10:59:31.232]                     })
[10:59:31.232]                   }
[10:59:31.232]                   ...future.strategy.old <- future::plan("list")
[10:59:31.232]                   options(future.plan = NULL)
[10:59:31.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.232]                 }
[10:59:31.232]                 ...future.workdir <- getwd()
[10:59:31.232]             }
[10:59:31.232]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.232]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.232]         }
[10:59:31.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.232]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:31.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.232]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.232]             base::names(...future.oldOptions))
[10:59:31.232]     }
[10:59:31.232]     if (FALSE) {
[10:59:31.232]     }
[10:59:31.232]     else {
[10:59:31.232]         if (TRUE) {
[10:59:31.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.232]                 open = "w")
[10:59:31.232]         }
[10:59:31.232]         else {
[10:59:31.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.232]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.232]         }
[10:59:31.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.232]             base::sink(type = "output", split = FALSE)
[10:59:31.232]             base::close(...future.stdout)
[10:59:31.232]         }, add = TRUE)
[10:59:31.232]     }
[10:59:31.232]     ...future.frame <- base::sys.nframe()
[10:59:31.232]     ...future.conditions <- base::list()
[10:59:31.232]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.232]     if (FALSE) {
[10:59:31.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.232]     }
[10:59:31.232]     ...future.result <- base::tryCatch({
[10:59:31.232]         base::withCallingHandlers({
[10:59:31.232]             ...future.value <- base::withVisible(base::local({
[10:59:31.232]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.232]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.232]                   ...future.globals.maxSize)) {
[10:59:31.232]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.232]                   on.exit(options(oopts), add = TRUE)
[10:59:31.232]                 }
[10:59:31.232]                 {
[10:59:31.232]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.232]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.232]                     USE.NAMES = FALSE)
[10:59:31.232]                   do.call(mapply, args = args)
[10:59:31.232]                 }
[10:59:31.232]             }))
[10:59:31.232]             future::FutureResult(value = ...future.value$value, 
[10:59:31.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.232]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.232]                     ...future.globalenv.names))
[10:59:31.232]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.232]         }, condition = base::local({
[10:59:31.232]             c <- base::c
[10:59:31.232]             inherits <- base::inherits
[10:59:31.232]             invokeRestart <- base::invokeRestart
[10:59:31.232]             length <- base::length
[10:59:31.232]             list <- base::list
[10:59:31.232]             seq.int <- base::seq.int
[10:59:31.232]             signalCondition <- base::signalCondition
[10:59:31.232]             sys.calls <- base::sys.calls
[10:59:31.232]             `[[` <- base::`[[`
[10:59:31.232]             `+` <- base::`+`
[10:59:31.232]             `<<-` <- base::`<<-`
[10:59:31.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.232]                   3L)]
[10:59:31.232]             }
[10:59:31.232]             function(cond) {
[10:59:31.232]                 is_error <- inherits(cond, "error")
[10:59:31.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.232]                   NULL)
[10:59:31.232]                 if (is_error) {
[10:59:31.232]                   sessionInformation <- function() {
[10:59:31.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.232]                       search = base::search(), system = base::Sys.info())
[10:59:31.232]                   }
[10:59:31.232]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.232]                     cond$call), session = sessionInformation(), 
[10:59:31.232]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.232]                   signalCondition(cond)
[10:59:31.232]                 }
[10:59:31.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.232]                 "immediateCondition"))) {
[10:59:31.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.232]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.232]                   if (TRUE && !signal) {
[10:59:31.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.232]                     {
[10:59:31.232]                       inherits <- base::inherits
[10:59:31.232]                       invokeRestart <- base::invokeRestart
[10:59:31.232]                       is.null <- base::is.null
[10:59:31.232]                       muffled <- FALSE
[10:59:31.232]                       if (inherits(cond, "message")) {
[10:59:31.232]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.232]                         if (muffled) 
[10:59:31.232]                           invokeRestart("muffleMessage")
[10:59:31.232]                       }
[10:59:31.232]                       else if (inherits(cond, "warning")) {
[10:59:31.232]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.232]                         if (muffled) 
[10:59:31.232]                           invokeRestart("muffleWarning")
[10:59:31.232]                       }
[10:59:31.232]                       else if (inherits(cond, "condition")) {
[10:59:31.232]                         if (!is.null(pattern)) {
[10:59:31.232]                           computeRestarts <- base::computeRestarts
[10:59:31.232]                           grepl <- base::grepl
[10:59:31.232]                           restarts <- computeRestarts(cond)
[10:59:31.232]                           for (restart in restarts) {
[10:59:31.232]                             name <- restart$name
[10:59:31.232]                             if (is.null(name)) 
[10:59:31.232]                               next
[10:59:31.232]                             if (!grepl(pattern, name)) 
[10:59:31.232]                               next
[10:59:31.232]                             invokeRestart(restart)
[10:59:31.232]                             muffled <- TRUE
[10:59:31.232]                             break
[10:59:31.232]                           }
[10:59:31.232]                         }
[10:59:31.232]                       }
[10:59:31.232]                       invisible(muffled)
[10:59:31.232]                     }
[10:59:31.232]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.232]                   }
[10:59:31.232]                 }
[10:59:31.232]                 else {
[10:59:31.232]                   if (TRUE) {
[10:59:31.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.232]                     {
[10:59:31.232]                       inherits <- base::inherits
[10:59:31.232]                       invokeRestart <- base::invokeRestart
[10:59:31.232]                       is.null <- base::is.null
[10:59:31.232]                       muffled <- FALSE
[10:59:31.232]                       if (inherits(cond, "message")) {
[10:59:31.232]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.232]                         if (muffled) 
[10:59:31.232]                           invokeRestart("muffleMessage")
[10:59:31.232]                       }
[10:59:31.232]                       else if (inherits(cond, "warning")) {
[10:59:31.232]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.232]                         if (muffled) 
[10:59:31.232]                           invokeRestart("muffleWarning")
[10:59:31.232]                       }
[10:59:31.232]                       else if (inherits(cond, "condition")) {
[10:59:31.232]                         if (!is.null(pattern)) {
[10:59:31.232]                           computeRestarts <- base::computeRestarts
[10:59:31.232]                           grepl <- base::grepl
[10:59:31.232]                           restarts <- computeRestarts(cond)
[10:59:31.232]                           for (restart in restarts) {
[10:59:31.232]                             name <- restart$name
[10:59:31.232]                             if (is.null(name)) 
[10:59:31.232]                               next
[10:59:31.232]                             if (!grepl(pattern, name)) 
[10:59:31.232]                               next
[10:59:31.232]                             invokeRestart(restart)
[10:59:31.232]                             muffled <- TRUE
[10:59:31.232]                             break
[10:59:31.232]                           }
[10:59:31.232]                         }
[10:59:31.232]                       }
[10:59:31.232]                       invisible(muffled)
[10:59:31.232]                     }
[10:59:31.232]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.232]                   }
[10:59:31.232]                 }
[10:59:31.232]             }
[10:59:31.232]         }))
[10:59:31.232]     }, error = function(ex) {
[10:59:31.232]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.232]                 ...future.rng), started = ...future.startTime, 
[10:59:31.232]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.232]             version = "1.8"), class = "FutureResult")
[10:59:31.232]     }, finally = {
[10:59:31.232]         if (!identical(...future.workdir, getwd())) 
[10:59:31.232]             setwd(...future.workdir)
[10:59:31.232]         {
[10:59:31.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.232]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.232]             }
[10:59:31.232]             base::options(...future.oldOptions)
[10:59:31.232]             if (.Platform$OS.type == "windows") {
[10:59:31.232]                 old_names <- names(...future.oldEnvVars)
[10:59:31.232]                 envs <- base::Sys.getenv()
[10:59:31.232]                 names <- names(envs)
[10:59:31.232]                 common <- intersect(names, old_names)
[10:59:31.232]                 added <- setdiff(names, old_names)
[10:59:31.232]                 removed <- setdiff(old_names, names)
[10:59:31.232]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.232]                   envs[common]]
[10:59:31.232]                 NAMES <- toupper(changed)
[10:59:31.232]                 args <- list()
[10:59:31.232]                 for (kk in seq_along(NAMES)) {
[10:59:31.232]                   name <- changed[[kk]]
[10:59:31.232]                   NAME <- NAMES[[kk]]
[10:59:31.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.232]                     next
[10:59:31.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.232]                 }
[10:59:31.232]                 NAMES <- toupper(added)
[10:59:31.232]                 for (kk in seq_along(NAMES)) {
[10:59:31.232]                   name <- added[[kk]]
[10:59:31.232]                   NAME <- NAMES[[kk]]
[10:59:31.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.232]                     next
[10:59:31.232]                   args[[name]] <- ""
[10:59:31.232]                 }
[10:59:31.232]                 NAMES <- toupper(removed)
[10:59:31.232]                 for (kk in seq_along(NAMES)) {
[10:59:31.232]                   name <- removed[[kk]]
[10:59:31.232]                   NAME <- NAMES[[kk]]
[10:59:31.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.232]                     next
[10:59:31.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.232]                 }
[10:59:31.232]                 if (length(args) > 0) 
[10:59:31.232]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.232]             }
[10:59:31.232]             else {
[10:59:31.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.232]             }
[10:59:31.232]             {
[10:59:31.232]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.232]                   0L) {
[10:59:31.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.232]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.232]                   base::options(opts)
[10:59:31.232]                 }
[10:59:31.232]                 {
[10:59:31.232]                   {
[10:59:31.232]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.232]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.232]                     1047550554L), envir = base::globalenv(), 
[10:59:31.232]                       inherits = FALSE)
[10:59:31.232]                     NULL
[10:59:31.232]                   }
[10:59:31.232]                   options(future.plan = NULL)
[10:59:31.232]                   if (is.na(NA_character_)) 
[10:59:31.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.232]                     .init = FALSE)
[10:59:31.232]                 }
[10:59:31.232]             }
[10:59:31.232]         }
[10:59:31.232]     })
[10:59:31.232]     if (TRUE) {
[10:59:31.232]         base::sink(type = "output", split = FALSE)
[10:59:31.232]         if (TRUE) {
[10:59:31.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.232]         }
[10:59:31.232]         else {
[10:59:31.232]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.232]         }
[10:59:31.232]         base::close(...future.stdout)
[10:59:31.232]         ...future.stdout <- NULL
[10:59:31.232]     }
[10:59:31.232]     ...future.result$conditions <- ...future.conditions
[10:59:31.232]     ...future.result$finished <- base::Sys.time()
[10:59:31.232]     ...future.result
[10:59:31.232] }
[10:59:31.234] assign_globals() ...
[10:59:31.234] List of 5
[10:59:31.234]  $ ...future.FUN            :function (C, k)  
[10:59:31.234]  $ MoreArgs                 : NULL
[10:59:31.234]  $ ...future.elements_ii    :List of 2
[10:59:31.234]   ..$ :List of 1
[10:59:31.234]   .. ..$ : chr "E"
[10:59:31.234]   ..$ :List of 1
[10:59:31.234]   .. ..$ : int 1
[10:59:31.234]  $ ...future.seeds_ii       : NULL
[10:59:31.234]  $ ...future.globals.maxSize: NULL
[10:59:31.234]  - attr(*, "where")=List of 5
[10:59:31.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.234]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.234]  - attr(*, "resolved")= logi FALSE
[10:59:31.234]  - attr(*, "total_size")= num 847
[10:59:31.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.234]  - attr(*, "already-done")= logi TRUE
[10:59:31.238] - reassign environment for ‘...future.FUN’
[10:59:31.239] - copied ‘...future.FUN’ to environment
[10:59:31.239] - copied ‘MoreArgs’ to environment
[10:59:31.239] - copied ‘...future.elements_ii’ to environment
[10:59:31.239] - copied ‘...future.seeds_ii’ to environment
[10:59:31.239] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.239] assign_globals() ... done
[10:59:31.239] plan(): Setting new future strategy stack:
[10:59:31.239] List of future strategies:
[10:59:31.239] 1. sequential:
[10:59:31.239]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.239]    - tweaked: FALSE
[10:59:31.239]    - call: NULL
[10:59:31.240] plan(): nbrOfWorkers() = 1
[10:59:31.240] plan(): Setting new future strategy stack:
[10:59:31.240] List of future strategies:
[10:59:31.240] 1. sequential:
[10:59:31.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.240]    - tweaked: FALSE
[10:59:31.240]    - call: plan(strategy)
[10:59:31.241] plan(): nbrOfWorkers() = 1
[10:59:31.241] SequentialFuture started (and completed)
[10:59:31.241] - Launch lazy future ... done
[10:59:31.241] run() for ‘SequentialFuture’ ... done
[10:59:31.241] Created future:
[10:59:31.241] SequentialFuture:
[10:59:31.241] Label: ‘future_mapply-5’
[10:59:31.241] Expression:
[10:59:31.241] {
[10:59:31.241]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.241]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.241]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.241]         on.exit(options(oopts), add = TRUE)
[10:59:31.241]     }
[10:59:31.241]     {
[10:59:31.241]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.241]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.241]         do.call(mapply, args = args)
[10:59:31.241]     }
[10:59:31.241] }
[10:59:31.241] Lazy evaluation: FALSE
[10:59:31.241] Asynchronous evaluation: FALSE
[10:59:31.241] Local evaluation: TRUE
[10:59:31.241] Environment: R_GlobalEnv
[10:59:31.241] Capture standard output: TRUE
[10:59:31.241] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.241] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.241] Packages: <none>
[10:59:31.241] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.241] Resolved: TRUE
[10:59:31.241] Value: 48 bytes of class ‘list’
[10:59:31.241] Early signaling: FALSE
[10:59:31.241] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.241] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.242] Chunk #5 of 5 ... DONE
[10:59:31.242] Launching 5 futures (chunks) ... DONE
[10:59:31.242] Resolving 5 futures (chunks) ...
[10:59:31.242] resolve() on list ...
[10:59:31.242]  recursive: 0
[10:59:31.242]  length: 5
[10:59:31.243] 
[10:59:31.243] resolved() for ‘SequentialFuture’ ...
[10:59:31.243] - state: ‘finished’
[10:59:31.243] - run: TRUE
[10:59:31.243] - result: ‘FutureResult’
[10:59:31.243] resolved() for ‘SequentialFuture’ ... done
[10:59:31.243] Future #1
[10:59:31.243] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.243] - nx: 5
[10:59:31.243] - relay: TRUE
[10:59:31.243] - stdout: TRUE
[10:59:31.244] - signal: TRUE
[10:59:31.244] - resignal: FALSE
[10:59:31.244] - force: TRUE
[10:59:31.244] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:59:31.244] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:59:31.244]  - until=1
[10:59:31.244]  - relaying element #1
[10:59:31.244] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:31.244] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:31.244] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.244]  length: 4 (resolved future 1)
[10:59:31.245] resolved() for ‘SequentialFuture’ ...
[10:59:31.245] - state: ‘finished’
[10:59:31.245] - run: TRUE
[10:59:31.245] - result: ‘FutureResult’
[10:59:31.245] resolved() for ‘SequentialFuture’ ... done
[10:59:31.245] Future #2
[10:59:31.245] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:59:31.245] - nx: 5
[10:59:31.245] - relay: TRUE
[10:59:31.245] - stdout: TRUE
[10:59:31.245] - signal: TRUE
[10:59:31.245] - resignal: FALSE
[10:59:31.246] - force: TRUE
[10:59:31.246] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:31.246] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:31.246]  - until=2
[10:59:31.246]  - relaying element #2
[10:59:31.246] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:31.246] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:31.246] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:59:31.246]  length: 3 (resolved future 2)
[10:59:31.246] resolved() for ‘SequentialFuture’ ...
[10:59:31.246] - state: ‘finished’
[10:59:31.247] - run: TRUE
[10:59:31.247] - result: ‘FutureResult’
[10:59:31.247] resolved() for ‘SequentialFuture’ ... done
[10:59:31.247] Future #3
[10:59:31.247] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:59:31.247] - nx: 5
[10:59:31.247] - relay: TRUE
[10:59:31.247] - stdout: TRUE
[10:59:31.247] - signal: TRUE
[10:59:31.247] - resignal: FALSE
[10:59:31.247] - force: TRUE
[10:59:31.247] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:31.247] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:31.248]  - until=3
[10:59:31.248]  - relaying element #3
[10:59:31.248] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:31.248] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:31.248] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:59:31.248]  length: 2 (resolved future 3)
[10:59:31.248] resolved() for ‘SequentialFuture’ ...
[10:59:31.248] - state: ‘finished’
[10:59:31.248] - run: TRUE
[10:59:31.248] - result: ‘FutureResult’
[10:59:31.248] resolved() for ‘SequentialFuture’ ... done
[10:59:31.249] Future #4
[10:59:31.249] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:59:31.249] - nx: 5
[10:59:31.249] - relay: TRUE
[10:59:31.249] - stdout: TRUE
[10:59:31.249] - signal: TRUE
[10:59:31.249] - resignal: FALSE
[10:59:31.249] - force: TRUE
[10:59:31.249] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:31.249] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:31.249]  - until=4
[10:59:31.249]  - relaying element #4
[10:59:31.250] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:31.250] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:31.250] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:59:31.250]  length: 1 (resolved future 4)
[10:59:31.250] resolved() for ‘SequentialFuture’ ...
[10:59:31.250] - state: ‘finished’
[10:59:31.250] - run: TRUE
[10:59:31.250] - result: ‘FutureResult’
[10:59:31.250] resolved() for ‘SequentialFuture’ ... done
[10:59:31.250] Future #5
[10:59:31.250] signalConditionsASAP(SequentialFuture, pos=5) ...
[10:59:31.251] - nx: 5
[10:59:31.251] - relay: TRUE
[10:59:31.251] - stdout: TRUE
[10:59:31.251] - signal: TRUE
[10:59:31.251] - resignal: FALSE
[10:59:31.251] - force: TRUE
[10:59:31.251] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:31.251] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:31.251]  - until=5
[10:59:31.251]  - relaying element #5
[10:59:31.251] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:31.251] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:31.252] signalConditionsASAP(SequentialFuture, pos=5) ... done
[10:59:31.252]  length: 0 (resolved future 5)
[10:59:31.252] Relaying remaining futures
[10:59:31.252] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.252] - nx: 5
[10:59:31.252] - relay: TRUE
[10:59:31.252] - stdout: TRUE
[10:59:31.252] - signal: TRUE
[10:59:31.252] - resignal: FALSE
[10:59:31.252] - force: TRUE
[10:59:31.252] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:31.252] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:59:31.253] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:31.253] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:31.253] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.253] resolve() on list ... DONE
[10:59:31.253]  - Number of value chunks collected: 5
[10:59:31.253] Resolving 5 futures (chunks) ... DONE
[10:59:31.253] Reducing values from 5 chunks ...
[10:59:31.253]  - Number of values collected after concatenation: 5
[10:59:31.253]  - Number of values expected: 5
[10:59:31.253] Reducing values from 5 chunks ... DONE
[10:59:31.254] future_mapply() ... DONE
[10:59:31.255] future_mapply() ...
[10:59:31.255] Number of chunks: 1
[10:59:31.255] getGlobalsAndPackagesXApply() ...
[10:59:31.255]  - future.globals: TRUE
[10:59:31.255] getGlobalsAndPackages() ...
[10:59:31.255] Searching for globals...
[10:59:31.256] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:31.256] Searching for globals ... DONE
[10:59:31.256] Resolving globals: FALSE
[10:59:31.257] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:31.257] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:31.257] - globals: [1] ‘FUN’
[10:59:31.257] 
[10:59:31.257] getGlobalsAndPackages() ... DONE
[10:59:31.257]  - globals found/used: [n=1] ‘FUN’
[10:59:31.258]  - needed namespaces: [n=0] 
[10:59:31.258] Finding globals ... DONE
[10:59:31.258] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.258] List of 2
[10:59:31.258]  $ ...future.FUN:function (C, k)  
[10:59:31.258]  $ MoreArgs     : list()
[10:59:31.258]  - attr(*, "where")=List of 2
[10:59:31.258]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.258]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.258]  - attr(*, "resolved")= logi FALSE
[10:59:31.258]  - attr(*, "total_size")= num NA
[10:59:31.260] Packages to be attached in all futures: [n=0] 
[10:59:31.260] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.260] Number of futures (= number of chunks): 1
[10:59:31.260] Launching 1 futures (chunks) ...
[10:59:31.261] Chunk #1 of 1 ...
[10:59:31.261]  - Finding globals in '...' for chunk #1 ...
[10:59:31.261] getGlobalsAndPackages() ...
[10:59:31.261] Searching for globals...
[10:59:31.261] 
[10:59:31.261] Searching for globals ... DONE
[10:59:31.261] - globals: [0] <none>
[10:59:31.261] getGlobalsAndPackages() ... DONE
[10:59:31.261]    + additional globals found: [n=0] 
[10:59:31.262]    + additional namespaces needed: [n=0] 
[10:59:31.262]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.262]  - seeds: <none>
[10:59:31.262]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.262] getGlobalsAndPackages() ...
[10:59:31.262] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.262] Resolving globals: FALSE
[10:59:31.262] The total size of the 5 globals is 967 bytes (967 bytes)
[10:59:31.263] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:31.263] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.263] 
[10:59:31.263] getGlobalsAndPackages() ... DONE
[10:59:31.263] run() for ‘Future’ ...
[10:59:31.263] - state: ‘created’
[10:59:31.263] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.264] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.264] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.264]   - Field: ‘label’
[10:59:31.264]   - Field: ‘local’
[10:59:31.264]   - Field: ‘owner’
[10:59:31.264]   - Field: ‘envir’
[10:59:31.264]   - Field: ‘packages’
[10:59:31.264]   - Field: ‘gc’
[10:59:31.264]   - Field: ‘conditions’
[10:59:31.264]   - Field: ‘expr’
[10:59:31.265]   - Field: ‘uuid’
[10:59:31.265]   - Field: ‘seed’
[10:59:31.265]   - Field: ‘version’
[10:59:31.265]   - Field: ‘result’
[10:59:31.265]   - Field: ‘asynchronous’
[10:59:31.265]   - Field: ‘calls’
[10:59:31.265]   - Field: ‘globals’
[10:59:31.265]   - Field: ‘stdout’
[10:59:31.265]   - Field: ‘earlySignal’
[10:59:31.265]   - Field: ‘lazy’
[10:59:31.265]   - Field: ‘state’
[10:59:31.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.266] - Launch lazy future ...
[10:59:31.266] Packages needed by the future expression (n = 0): <none>
[10:59:31.266] Packages needed by future strategies (n = 0): <none>
[10:59:31.266] {
[10:59:31.266]     {
[10:59:31.266]         {
[10:59:31.266]             ...future.startTime <- base::Sys.time()
[10:59:31.266]             {
[10:59:31.266]                 {
[10:59:31.266]                   {
[10:59:31.266]                     base::local({
[10:59:31.266]                       has_future <- base::requireNamespace("future", 
[10:59:31.266]                         quietly = TRUE)
[10:59:31.266]                       if (has_future) {
[10:59:31.266]                         ns <- base::getNamespace("future")
[10:59:31.266]                         version <- ns[[".package"]][["version"]]
[10:59:31.266]                         if (is.null(version)) 
[10:59:31.266]                           version <- utils::packageVersion("future")
[10:59:31.266]                       }
[10:59:31.266]                       else {
[10:59:31.266]                         version <- NULL
[10:59:31.266]                       }
[10:59:31.266]                       if (!has_future || version < "1.8.0") {
[10:59:31.266]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.266]                           "", base::R.version$version.string), 
[10:59:31.266]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.266]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.266]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.266]                             "release", "version")], collapse = " "), 
[10:59:31.266]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.266]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.266]                           info)
[10:59:31.266]                         info <- base::paste(info, collapse = "; ")
[10:59:31.266]                         if (!has_future) {
[10:59:31.266]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.266]                             info)
[10:59:31.266]                         }
[10:59:31.266]                         else {
[10:59:31.266]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.266]                             info, version)
[10:59:31.266]                         }
[10:59:31.266]                         base::stop(msg)
[10:59:31.266]                       }
[10:59:31.266]                     })
[10:59:31.266]                   }
[10:59:31.266]                   ...future.strategy.old <- future::plan("list")
[10:59:31.266]                   options(future.plan = NULL)
[10:59:31.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.266]                 }
[10:59:31.266]                 ...future.workdir <- getwd()
[10:59:31.266]             }
[10:59:31.266]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.266]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.266]         }
[10:59:31.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.266]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.266]             base::names(...future.oldOptions))
[10:59:31.266]     }
[10:59:31.266]     if (FALSE) {
[10:59:31.266]     }
[10:59:31.266]     else {
[10:59:31.266]         if (TRUE) {
[10:59:31.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.266]                 open = "w")
[10:59:31.266]         }
[10:59:31.266]         else {
[10:59:31.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.266]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.266]         }
[10:59:31.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.266]             base::sink(type = "output", split = FALSE)
[10:59:31.266]             base::close(...future.stdout)
[10:59:31.266]         }, add = TRUE)
[10:59:31.266]     }
[10:59:31.266]     ...future.frame <- base::sys.nframe()
[10:59:31.266]     ...future.conditions <- base::list()
[10:59:31.266]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.266]     if (FALSE) {
[10:59:31.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.266]     }
[10:59:31.266]     ...future.result <- base::tryCatch({
[10:59:31.266]         base::withCallingHandlers({
[10:59:31.266]             ...future.value <- base::withVisible(base::local({
[10:59:31.266]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.266]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.266]                   ...future.globals.maxSize)) {
[10:59:31.266]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.266]                   on.exit(options(oopts), add = TRUE)
[10:59:31.266]                 }
[10:59:31.266]                 {
[10:59:31.266]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.266]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.266]                     USE.NAMES = FALSE)
[10:59:31.266]                   do.call(mapply, args = args)
[10:59:31.266]                 }
[10:59:31.266]             }))
[10:59:31.266]             future::FutureResult(value = ...future.value$value, 
[10:59:31.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.266]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.266]                     ...future.globalenv.names))
[10:59:31.266]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.266]         }, condition = base::local({
[10:59:31.266]             c <- base::c
[10:59:31.266]             inherits <- base::inherits
[10:59:31.266]             invokeRestart <- base::invokeRestart
[10:59:31.266]             length <- base::length
[10:59:31.266]             list <- base::list
[10:59:31.266]             seq.int <- base::seq.int
[10:59:31.266]             signalCondition <- base::signalCondition
[10:59:31.266]             sys.calls <- base::sys.calls
[10:59:31.266]             `[[` <- base::`[[`
[10:59:31.266]             `+` <- base::`+`
[10:59:31.266]             `<<-` <- base::`<<-`
[10:59:31.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.266]                   3L)]
[10:59:31.266]             }
[10:59:31.266]             function(cond) {
[10:59:31.266]                 is_error <- inherits(cond, "error")
[10:59:31.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.266]                   NULL)
[10:59:31.266]                 if (is_error) {
[10:59:31.266]                   sessionInformation <- function() {
[10:59:31.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.266]                       search = base::search(), system = base::Sys.info())
[10:59:31.266]                   }
[10:59:31.266]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.266]                     cond$call), session = sessionInformation(), 
[10:59:31.266]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.266]                   signalCondition(cond)
[10:59:31.266]                 }
[10:59:31.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.266]                 "immediateCondition"))) {
[10:59:31.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.266]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.266]                   if (TRUE && !signal) {
[10:59:31.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.266]                     {
[10:59:31.266]                       inherits <- base::inherits
[10:59:31.266]                       invokeRestart <- base::invokeRestart
[10:59:31.266]                       is.null <- base::is.null
[10:59:31.266]                       muffled <- FALSE
[10:59:31.266]                       if (inherits(cond, "message")) {
[10:59:31.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.266]                         if (muffled) 
[10:59:31.266]                           invokeRestart("muffleMessage")
[10:59:31.266]                       }
[10:59:31.266]                       else if (inherits(cond, "warning")) {
[10:59:31.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.266]                         if (muffled) 
[10:59:31.266]                           invokeRestart("muffleWarning")
[10:59:31.266]                       }
[10:59:31.266]                       else if (inherits(cond, "condition")) {
[10:59:31.266]                         if (!is.null(pattern)) {
[10:59:31.266]                           computeRestarts <- base::computeRestarts
[10:59:31.266]                           grepl <- base::grepl
[10:59:31.266]                           restarts <- computeRestarts(cond)
[10:59:31.266]                           for (restart in restarts) {
[10:59:31.266]                             name <- restart$name
[10:59:31.266]                             if (is.null(name)) 
[10:59:31.266]                               next
[10:59:31.266]                             if (!grepl(pattern, name)) 
[10:59:31.266]                               next
[10:59:31.266]                             invokeRestart(restart)
[10:59:31.266]                             muffled <- TRUE
[10:59:31.266]                             break
[10:59:31.266]                           }
[10:59:31.266]                         }
[10:59:31.266]                       }
[10:59:31.266]                       invisible(muffled)
[10:59:31.266]                     }
[10:59:31.266]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.266]                   }
[10:59:31.266]                 }
[10:59:31.266]                 else {
[10:59:31.266]                   if (TRUE) {
[10:59:31.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.266]                     {
[10:59:31.266]                       inherits <- base::inherits
[10:59:31.266]                       invokeRestart <- base::invokeRestart
[10:59:31.266]                       is.null <- base::is.null
[10:59:31.266]                       muffled <- FALSE
[10:59:31.266]                       if (inherits(cond, "message")) {
[10:59:31.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.266]                         if (muffled) 
[10:59:31.266]                           invokeRestart("muffleMessage")
[10:59:31.266]                       }
[10:59:31.266]                       else if (inherits(cond, "warning")) {
[10:59:31.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.266]                         if (muffled) 
[10:59:31.266]                           invokeRestart("muffleWarning")
[10:59:31.266]                       }
[10:59:31.266]                       else if (inherits(cond, "condition")) {
[10:59:31.266]                         if (!is.null(pattern)) {
[10:59:31.266]                           computeRestarts <- base::computeRestarts
[10:59:31.266]                           grepl <- base::grepl
[10:59:31.266]                           restarts <- computeRestarts(cond)
[10:59:31.266]                           for (restart in restarts) {
[10:59:31.266]                             name <- restart$name
[10:59:31.266]                             if (is.null(name)) 
[10:59:31.266]                               next
[10:59:31.266]                             if (!grepl(pattern, name)) 
[10:59:31.266]                               next
[10:59:31.266]                             invokeRestart(restart)
[10:59:31.266]                             muffled <- TRUE
[10:59:31.266]                             break
[10:59:31.266]                           }
[10:59:31.266]                         }
[10:59:31.266]                       }
[10:59:31.266]                       invisible(muffled)
[10:59:31.266]                     }
[10:59:31.266]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.266]                   }
[10:59:31.266]                 }
[10:59:31.266]             }
[10:59:31.266]         }))
[10:59:31.266]     }, error = function(ex) {
[10:59:31.266]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.266]                 ...future.rng), started = ...future.startTime, 
[10:59:31.266]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.266]             version = "1.8"), class = "FutureResult")
[10:59:31.266]     }, finally = {
[10:59:31.266]         if (!identical(...future.workdir, getwd())) 
[10:59:31.266]             setwd(...future.workdir)
[10:59:31.266]         {
[10:59:31.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.266]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.266]             }
[10:59:31.266]             base::options(...future.oldOptions)
[10:59:31.266]             if (.Platform$OS.type == "windows") {
[10:59:31.266]                 old_names <- names(...future.oldEnvVars)
[10:59:31.266]                 envs <- base::Sys.getenv()
[10:59:31.266]                 names <- names(envs)
[10:59:31.266]                 common <- intersect(names, old_names)
[10:59:31.266]                 added <- setdiff(names, old_names)
[10:59:31.266]                 removed <- setdiff(old_names, names)
[10:59:31.266]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.266]                   envs[common]]
[10:59:31.266]                 NAMES <- toupper(changed)
[10:59:31.266]                 args <- list()
[10:59:31.266]                 for (kk in seq_along(NAMES)) {
[10:59:31.266]                   name <- changed[[kk]]
[10:59:31.266]                   NAME <- NAMES[[kk]]
[10:59:31.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.266]                     next
[10:59:31.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.266]                 }
[10:59:31.266]                 NAMES <- toupper(added)
[10:59:31.266]                 for (kk in seq_along(NAMES)) {
[10:59:31.266]                   name <- added[[kk]]
[10:59:31.266]                   NAME <- NAMES[[kk]]
[10:59:31.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.266]                     next
[10:59:31.266]                   args[[name]] <- ""
[10:59:31.266]                 }
[10:59:31.266]                 NAMES <- toupper(removed)
[10:59:31.266]                 for (kk in seq_along(NAMES)) {
[10:59:31.266]                   name <- removed[[kk]]
[10:59:31.266]                   NAME <- NAMES[[kk]]
[10:59:31.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.266]                     next
[10:59:31.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.266]                 }
[10:59:31.266]                 if (length(args) > 0) 
[10:59:31.266]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.266]             }
[10:59:31.266]             else {
[10:59:31.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.266]             }
[10:59:31.266]             {
[10:59:31.266]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.266]                   0L) {
[10:59:31.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.266]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.266]                   base::options(opts)
[10:59:31.266]                 }
[10:59:31.266]                 {
[10:59:31.266]                   {
[10:59:31.266]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.266]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.266]                     1047550554L), envir = base::globalenv(), 
[10:59:31.266]                       inherits = FALSE)
[10:59:31.266]                     NULL
[10:59:31.266]                   }
[10:59:31.266]                   options(future.plan = NULL)
[10:59:31.266]                   if (is.na(NA_character_)) 
[10:59:31.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.266]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.266]                     .init = FALSE)
[10:59:31.266]                 }
[10:59:31.266]             }
[10:59:31.266]         }
[10:59:31.266]     })
[10:59:31.266]     if (TRUE) {
[10:59:31.266]         base::sink(type = "output", split = FALSE)
[10:59:31.266]         if (TRUE) {
[10:59:31.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.266]         }
[10:59:31.266]         else {
[10:59:31.266]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.266]         }
[10:59:31.266]         base::close(...future.stdout)
[10:59:31.266]         ...future.stdout <- NULL
[10:59:31.266]     }
[10:59:31.266]     ...future.result$conditions <- ...future.conditions
[10:59:31.266]     ...future.result$finished <- base::Sys.time()
[10:59:31.266]     ...future.result
[10:59:31.266] }
[10:59:31.268] assign_globals() ...
[10:59:31.268] List of 5
[10:59:31.268]  $ ...future.FUN            :function (C, k)  
[10:59:31.268]  $ MoreArgs                 : list()
[10:59:31.268]  $ ...future.elements_ii    :List of 2
[10:59:31.268]   ..$ :List of 5
[10:59:31.268]   .. ..$ : chr "A"
[10:59:31.268]   .. ..$ : chr "B"
[10:59:31.268]   .. ..$ : chr "C"
[10:59:31.268]   .. ..$ : chr "D"
[10:59:31.268]   .. ..$ : chr "E"
[10:59:31.268]   ..$ :List of 5
[10:59:31.268]   .. ..$ : int 5
[10:59:31.268]   .. ..$ : int 4
[10:59:31.268]   .. ..$ : int 3
[10:59:31.268]   .. ..$ : int 2
[10:59:31.268]   .. ..$ : int 1
[10:59:31.268]  $ ...future.seeds_ii       : NULL
[10:59:31.268]  $ ...future.globals.maxSize: NULL
[10:59:31.268]  - attr(*, "where")=List of 5
[10:59:31.268]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.268]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.268]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.268]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.268]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.268]  - attr(*, "resolved")= logi FALSE
[10:59:31.268]  - attr(*, "total_size")= num 967
[10:59:31.268]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.268]  - attr(*, "already-done")= logi TRUE
[10:59:31.274] - reassign environment for ‘...future.FUN’
[10:59:31.274] - copied ‘...future.FUN’ to environment
[10:59:31.274] - copied ‘MoreArgs’ to environment
[10:59:31.274] - copied ‘...future.elements_ii’ to environment
[10:59:31.275] - copied ‘...future.seeds_ii’ to environment
[10:59:31.275] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.275] assign_globals() ... done
[10:59:31.275] plan(): Setting new future strategy stack:
[10:59:31.275] List of future strategies:
[10:59:31.275] 1. sequential:
[10:59:31.275]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.275]    - tweaked: FALSE
[10:59:31.275]    - call: NULL
[10:59:31.275] plan(): nbrOfWorkers() = 1
[10:59:31.277] plan(): Setting new future strategy stack:
[10:59:31.277] List of future strategies:
[10:59:31.277] 1. sequential:
[10:59:31.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.277]    - tweaked: FALSE
[10:59:31.277]    - call: plan(strategy)
[10:59:31.277] plan(): nbrOfWorkers() = 1
[10:59:31.278] SequentialFuture started (and completed)
[10:59:31.278] - Launch lazy future ... done
[10:59:31.278] run() for ‘SequentialFuture’ ... done
[10:59:31.278] Created future:
[10:59:31.278] SequentialFuture:
[10:59:31.278] Label: ‘future_.mapply-1’
[10:59:31.278] Expression:
[10:59:31.278] {
[10:59:31.278]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.278]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.278]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.278]         on.exit(options(oopts), add = TRUE)
[10:59:31.278]     }
[10:59:31.278]     {
[10:59:31.278]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.278]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.278]         do.call(mapply, args = args)
[10:59:31.278]     }
[10:59:31.278] }
[10:59:31.278] Lazy evaluation: FALSE
[10:59:31.278] Asynchronous evaluation: FALSE
[10:59:31.278] Local evaluation: TRUE
[10:59:31.278] Environment: R_GlobalEnv
[10:59:31.278] Capture standard output: TRUE
[10:59:31.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.278] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.278] Packages: <none>
[10:59:31.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.278] Resolved: TRUE
[10:59:31.278] Value: 126 bytes of class ‘list’
[10:59:31.278] Early signaling: FALSE
[10:59:31.278] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.278] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.279] Chunk #1 of 1 ... DONE
[10:59:31.279] Launching 1 futures (chunks) ... DONE
[10:59:31.279] Resolving 1 futures (chunks) ...
[10:59:31.279] resolve() on list ...
[10:59:31.279]  recursive: 0
[10:59:31.279]  length: 1
[10:59:31.279] 
[10:59:31.279] resolved() for ‘SequentialFuture’ ...
[10:59:31.279] - state: ‘finished’
[10:59:31.279] - run: TRUE
[10:59:31.279] - result: ‘FutureResult’
[10:59:31.280] resolved() for ‘SequentialFuture’ ... done
[10:59:31.280] Future #1
[10:59:31.280] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.280] - nx: 1
[10:59:31.280] - relay: TRUE
[10:59:31.280] - stdout: TRUE
[10:59:31.280] - signal: TRUE
[10:59:31.280] - resignal: FALSE
[10:59:31.280] - force: TRUE
[10:59:31.280] - relayed: [n=1] FALSE
[10:59:31.280] - queued futures: [n=1] FALSE
[10:59:31.280]  - until=1
[10:59:31.281]  - relaying element #1
[10:59:31.281] - relayed: [n=1] TRUE
[10:59:31.281] - queued futures: [n=1] TRUE
[10:59:31.281] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.281]  length: 0 (resolved future 1)
[10:59:31.281] Relaying remaining futures
[10:59:31.281] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.281] - nx: 1
[10:59:31.281] - relay: TRUE
[10:59:31.281] - stdout: TRUE
[10:59:31.281] - signal: TRUE
[10:59:31.281] - resignal: FALSE
[10:59:31.281] - force: TRUE
[10:59:31.282] - relayed: [n=1] TRUE
[10:59:31.282] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.282] - relayed: [n=1] TRUE
[10:59:31.282] - queued futures: [n=1] TRUE
[10:59:31.282] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.282] resolve() on list ... DONE
[10:59:31.282]  - Number of value chunks collected: 1
[10:59:31.282] Resolving 1 futures (chunks) ... DONE
[10:59:31.282] Reducing values from 1 chunks ...
[10:59:31.282]  - Number of values collected after concatenation: 5
[10:59:31.282]  - Number of values expected: 5
[10:59:31.283] Reducing values from 1 chunks ... DONE
[10:59:31.283] future_mapply() ... DONE
[10:59:31.283] future_mapply() ...
[10:59:31.283] Number of chunks: 3
[10:59:31.283] Index remapping (attribute 'ordering'): [n = 5] 5, 3, 1, 2, 4
[10:59:31.283] getGlobalsAndPackagesXApply() ...
[10:59:31.284]  - future.globals: TRUE
[10:59:31.284] getGlobalsAndPackages() ...
[10:59:31.284] Searching for globals...
[10:59:31.285] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:31.285] Searching for globals ... DONE
[10:59:31.285] Resolving globals: FALSE
[10:59:31.285] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:31.286] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:31.286] - globals: [1] ‘FUN’
[10:59:31.286] 
[10:59:31.286] getGlobalsAndPackages() ... DONE
[10:59:31.286]  - globals found/used: [n=1] ‘FUN’
[10:59:31.286]  - needed namespaces: [n=0] 
[10:59:31.286] Finding globals ... DONE
[10:59:31.286] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.286] List of 2
[10:59:31.286]  $ ...future.FUN:function (C, k)  
[10:59:31.286]  $ MoreArgs     : NULL
[10:59:31.286]  - attr(*, "where")=List of 2
[10:59:31.286]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.286]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.286]  - attr(*, "resolved")= logi FALSE
[10:59:31.286]  - attr(*, "total_size")= num NA
[10:59:31.289] Packages to be attached in all futures: [n=0] 
[10:59:31.289] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.289] Number of futures (= number of chunks): 3
[10:59:31.289] Launching 3 futures (chunks) ...
[10:59:31.289] Chunk #1 of 3 ...
[10:59:31.289]  - Finding globals in '...' for chunk #1 ...
[10:59:31.289] getGlobalsAndPackages() ...
[10:59:31.289] Searching for globals...
[10:59:31.289] 
[10:59:31.290] Searching for globals ... DONE
[10:59:31.290] - globals: [0] <none>
[10:59:31.290] getGlobalsAndPackages() ... DONE
[10:59:31.290]    + additional globals found: [n=0] 
[10:59:31.290]    + additional namespaces needed: [n=0] 
[10:59:31.290]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.290]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:31.290]  - seeds: <none>
[10:59:31.290]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.290] getGlobalsAndPackages() ...
[10:59:31.290] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.290] Resolving globals: FALSE
[10:59:31.291] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:31.291] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.291] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.291] 
[10:59:31.292] getGlobalsAndPackages() ... DONE
[10:59:31.292] run() for ‘Future’ ...
[10:59:31.292] - state: ‘created’
[10:59:31.292] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.292] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.292]   - Field: ‘label’
[10:59:31.292]   - Field: ‘local’
[10:59:31.293]   - Field: ‘owner’
[10:59:31.293]   - Field: ‘envir’
[10:59:31.293]   - Field: ‘packages’
[10:59:31.293]   - Field: ‘gc’
[10:59:31.293]   - Field: ‘conditions’
[10:59:31.293]   - Field: ‘expr’
[10:59:31.293]   - Field: ‘uuid’
[10:59:31.293]   - Field: ‘seed’
[10:59:31.293]   - Field: ‘version’
[10:59:31.293]   - Field: ‘result’
[10:59:31.293]   - Field: ‘asynchronous’
[10:59:31.293]   - Field: ‘calls’
[10:59:31.293]   - Field: ‘globals’
[10:59:31.294]   - Field: ‘stdout’
[10:59:31.294]   - Field: ‘earlySignal’
[10:59:31.294]   - Field: ‘lazy’
[10:59:31.294]   - Field: ‘state’
[10:59:31.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.294] - Launch lazy future ...
[10:59:31.294] Packages needed by the future expression (n = 0): <none>
[10:59:31.294] Packages needed by future strategies (n = 0): <none>
[10:59:31.295] {
[10:59:31.295]     {
[10:59:31.295]         {
[10:59:31.295]             ...future.startTime <- base::Sys.time()
[10:59:31.295]             {
[10:59:31.295]                 {
[10:59:31.295]                   {
[10:59:31.295]                     base::local({
[10:59:31.295]                       has_future <- base::requireNamespace("future", 
[10:59:31.295]                         quietly = TRUE)
[10:59:31.295]                       if (has_future) {
[10:59:31.295]                         ns <- base::getNamespace("future")
[10:59:31.295]                         version <- ns[[".package"]][["version"]]
[10:59:31.295]                         if (is.null(version)) 
[10:59:31.295]                           version <- utils::packageVersion("future")
[10:59:31.295]                       }
[10:59:31.295]                       else {
[10:59:31.295]                         version <- NULL
[10:59:31.295]                       }
[10:59:31.295]                       if (!has_future || version < "1.8.0") {
[10:59:31.295]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.295]                           "", base::R.version$version.string), 
[10:59:31.295]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.295]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.295]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.295]                             "release", "version")], collapse = " "), 
[10:59:31.295]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.295]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.295]                           info)
[10:59:31.295]                         info <- base::paste(info, collapse = "; ")
[10:59:31.295]                         if (!has_future) {
[10:59:31.295]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.295]                             info)
[10:59:31.295]                         }
[10:59:31.295]                         else {
[10:59:31.295]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.295]                             info, version)
[10:59:31.295]                         }
[10:59:31.295]                         base::stop(msg)
[10:59:31.295]                       }
[10:59:31.295]                     })
[10:59:31.295]                   }
[10:59:31.295]                   ...future.strategy.old <- future::plan("list")
[10:59:31.295]                   options(future.plan = NULL)
[10:59:31.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.295]                 }
[10:59:31.295]                 ...future.workdir <- getwd()
[10:59:31.295]             }
[10:59:31.295]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.295]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.295]         }
[10:59:31.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.295]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:31.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.295]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.295]             base::names(...future.oldOptions))
[10:59:31.295]     }
[10:59:31.295]     if (FALSE) {
[10:59:31.295]     }
[10:59:31.295]     else {
[10:59:31.295]         if (TRUE) {
[10:59:31.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.295]                 open = "w")
[10:59:31.295]         }
[10:59:31.295]         else {
[10:59:31.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.295]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.295]         }
[10:59:31.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.295]             base::sink(type = "output", split = FALSE)
[10:59:31.295]             base::close(...future.stdout)
[10:59:31.295]         }, add = TRUE)
[10:59:31.295]     }
[10:59:31.295]     ...future.frame <- base::sys.nframe()
[10:59:31.295]     ...future.conditions <- base::list()
[10:59:31.295]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.295]     if (FALSE) {
[10:59:31.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.295]     }
[10:59:31.295]     ...future.result <- base::tryCatch({
[10:59:31.295]         base::withCallingHandlers({
[10:59:31.295]             ...future.value <- base::withVisible(base::local({
[10:59:31.295]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.295]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.295]                   ...future.globals.maxSize)) {
[10:59:31.295]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.295]                   on.exit(options(oopts), add = TRUE)
[10:59:31.295]                 }
[10:59:31.295]                 {
[10:59:31.295]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.295]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.295]                     USE.NAMES = FALSE)
[10:59:31.295]                   do.call(mapply, args = args)
[10:59:31.295]                 }
[10:59:31.295]             }))
[10:59:31.295]             future::FutureResult(value = ...future.value$value, 
[10:59:31.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.295]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.295]                     ...future.globalenv.names))
[10:59:31.295]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.295]         }, condition = base::local({
[10:59:31.295]             c <- base::c
[10:59:31.295]             inherits <- base::inherits
[10:59:31.295]             invokeRestart <- base::invokeRestart
[10:59:31.295]             length <- base::length
[10:59:31.295]             list <- base::list
[10:59:31.295]             seq.int <- base::seq.int
[10:59:31.295]             signalCondition <- base::signalCondition
[10:59:31.295]             sys.calls <- base::sys.calls
[10:59:31.295]             `[[` <- base::`[[`
[10:59:31.295]             `+` <- base::`+`
[10:59:31.295]             `<<-` <- base::`<<-`
[10:59:31.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.295]                   3L)]
[10:59:31.295]             }
[10:59:31.295]             function(cond) {
[10:59:31.295]                 is_error <- inherits(cond, "error")
[10:59:31.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.295]                   NULL)
[10:59:31.295]                 if (is_error) {
[10:59:31.295]                   sessionInformation <- function() {
[10:59:31.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.295]                       search = base::search(), system = base::Sys.info())
[10:59:31.295]                   }
[10:59:31.295]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.295]                     cond$call), session = sessionInformation(), 
[10:59:31.295]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.295]                   signalCondition(cond)
[10:59:31.295]                 }
[10:59:31.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.295]                 "immediateCondition"))) {
[10:59:31.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.295]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.295]                   if (TRUE && !signal) {
[10:59:31.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.295]                     {
[10:59:31.295]                       inherits <- base::inherits
[10:59:31.295]                       invokeRestart <- base::invokeRestart
[10:59:31.295]                       is.null <- base::is.null
[10:59:31.295]                       muffled <- FALSE
[10:59:31.295]                       if (inherits(cond, "message")) {
[10:59:31.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.295]                         if (muffled) 
[10:59:31.295]                           invokeRestart("muffleMessage")
[10:59:31.295]                       }
[10:59:31.295]                       else if (inherits(cond, "warning")) {
[10:59:31.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.295]                         if (muffled) 
[10:59:31.295]                           invokeRestart("muffleWarning")
[10:59:31.295]                       }
[10:59:31.295]                       else if (inherits(cond, "condition")) {
[10:59:31.295]                         if (!is.null(pattern)) {
[10:59:31.295]                           computeRestarts <- base::computeRestarts
[10:59:31.295]                           grepl <- base::grepl
[10:59:31.295]                           restarts <- computeRestarts(cond)
[10:59:31.295]                           for (restart in restarts) {
[10:59:31.295]                             name <- restart$name
[10:59:31.295]                             if (is.null(name)) 
[10:59:31.295]                               next
[10:59:31.295]                             if (!grepl(pattern, name)) 
[10:59:31.295]                               next
[10:59:31.295]                             invokeRestart(restart)
[10:59:31.295]                             muffled <- TRUE
[10:59:31.295]                             break
[10:59:31.295]                           }
[10:59:31.295]                         }
[10:59:31.295]                       }
[10:59:31.295]                       invisible(muffled)
[10:59:31.295]                     }
[10:59:31.295]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.295]                   }
[10:59:31.295]                 }
[10:59:31.295]                 else {
[10:59:31.295]                   if (TRUE) {
[10:59:31.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.295]                     {
[10:59:31.295]                       inherits <- base::inherits
[10:59:31.295]                       invokeRestart <- base::invokeRestart
[10:59:31.295]                       is.null <- base::is.null
[10:59:31.295]                       muffled <- FALSE
[10:59:31.295]                       if (inherits(cond, "message")) {
[10:59:31.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.295]                         if (muffled) 
[10:59:31.295]                           invokeRestart("muffleMessage")
[10:59:31.295]                       }
[10:59:31.295]                       else if (inherits(cond, "warning")) {
[10:59:31.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.295]                         if (muffled) 
[10:59:31.295]                           invokeRestart("muffleWarning")
[10:59:31.295]                       }
[10:59:31.295]                       else if (inherits(cond, "condition")) {
[10:59:31.295]                         if (!is.null(pattern)) {
[10:59:31.295]                           computeRestarts <- base::computeRestarts
[10:59:31.295]                           grepl <- base::grepl
[10:59:31.295]                           restarts <- computeRestarts(cond)
[10:59:31.295]                           for (restart in restarts) {
[10:59:31.295]                             name <- restart$name
[10:59:31.295]                             if (is.null(name)) 
[10:59:31.295]                               next
[10:59:31.295]                             if (!grepl(pattern, name)) 
[10:59:31.295]                               next
[10:59:31.295]                             invokeRestart(restart)
[10:59:31.295]                             muffled <- TRUE
[10:59:31.295]                             break
[10:59:31.295]                           }
[10:59:31.295]                         }
[10:59:31.295]                       }
[10:59:31.295]                       invisible(muffled)
[10:59:31.295]                     }
[10:59:31.295]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.295]                   }
[10:59:31.295]                 }
[10:59:31.295]             }
[10:59:31.295]         }))
[10:59:31.295]     }, error = function(ex) {
[10:59:31.295]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.295]                 ...future.rng), started = ...future.startTime, 
[10:59:31.295]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.295]             version = "1.8"), class = "FutureResult")
[10:59:31.295]     }, finally = {
[10:59:31.295]         if (!identical(...future.workdir, getwd())) 
[10:59:31.295]             setwd(...future.workdir)
[10:59:31.295]         {
[10:59:31.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.295]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.295]             }
[10:59:31.295]             base::options(...future.oldOptions)
[10:59:31.295]             if (.Platform$OS.type == "windows") {
[10:59:31.295]                 old_names <- names(...future.oldEnvVars)
[10:59:31.295]                 envs <- base::Sys.getenv()
[10:59:31.295]                 names <- names(envs)
[10:59:31.295]                 common <- intersect(names, old_names)
[10:59:31.295]                 added <- setdiff(names, old_names)
[10:59:31.295]                 removed <- setdiff(old_names, names)
[10:59:31.295]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.295]                   envs[common]]
[10:59:31.295]                 NAMES <- toupper(changed)
[10:59:31.295]                 args <- list()
[10:59:31.295]                 for (kk in seq_along(NAMES)) {
[10:59:31.295]                   name <- changed[[kk]]
[10:59:31.295]                   NAME <- NAMES[[kk]]
[10:59:31.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.295]                     next
[10:59:31.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.295]                 }
[10:59:31.295]                 NAMES <- toupper(added)
[10:59:31.295]                 for (kk in seq_along(NAMES)) {
[10:59:31.295]                   name <- added[[kk]]
[10:59:31.295]                   NAME <- NAMES[[kk]]
[10:59:31.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.295]                     next
[10:59:31.295]                   args[[name]] <- ""
[10:59:31.295]                 }
[10:59:31.295]                 NAMES <- toupper(removed)
[10:59:31.295]                 for (kk in seq_along(NAMES)) {
[10:59:31.295]                   name <- removed[[kk]]
[10:59:31.295]                   NAME <- NAMES[[kk]]
[10:59:31.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.295]                     next
[10:59:31.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.295]                 }
[10:59:31.295]                 if (length(args) > 0) 
[10:59:31.295]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.295]             }
[10:59:31.295]             else {
[10:59:31.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.295]             }
[10:59:31.295]             {
[10:59:31.295]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.295]                   0L) {
[10:59:31.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.295]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.295]                   base::options(opts)
[10:59:31.295]                 }
[10:59:31.295]                 {
[10:59:31.295]                   {
[10:59:31.295]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.295]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.295]                     1047550554L), envir = base::globalenv(), 
[10:59:31.295]                       inherits = FALSE)
[10:59:31.295]                     NULL
[10:59:31.295]                   }
[10:59:31.295]                   options(future.plan = NULL)
[10:59:31.295]                   if (is.na(NA_character_)) 
[10:59:31.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.295]                     .init = FALSE)
[10:59:31.295]                 }
[10:59:31.295]             }
[10:59:31.295]         }
[10:59:31.295]     })
[10:59:31.295]     if (TRUE) {
[10:59:31.295]         base::sink(type = "output", split = FALSE)
[10:59:31.295]         if (TRUE) {
[10:59:31.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.295]         }
[10:59:31.295]         else {
[10:59:31.295]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.295]         }
[10:59:31.295]         base::close(...future.stdout)
[10:59:31.295]         ...future.stdout <- NULL
[10:59:31.295]     }
[10:59:31.295]     ...future.result$conditions <- ...future.conditions
[10:59:31.295]     ...future.result$finished <- base::Sys.time()
[10:59:31.295]     ...future.result
[10:59:31.295] }
[10:59:31.296] assign_globals() ...
[10:59:31.296] List of 5
[10:59:31.296]  $ ...future.FUN            :function (C, k)  
[10:59:31.296]  $ MoreArgs                 : NULL
[10:59:31.296]  $ ...future.elements_ii    :List of 2
[10:59:31.296]   ..$ :List of 2
[10:59:31.296]   .. ..$ : chr "E"
[10:59:31.296]   .. ..$ : chr "C"
[10:59:31.296]   ..$ :List of 2
[10:59:31.296]   .. ..$ : int 1
[10:59:31.296]   .. ..$ : int 3
[10:59:31.296]  $ ...future.seeds_ii       : NULL
[10:59:31.296]  $ ...future.globals.maxSize: NULL
[10:59:31.296]  - attr(*, "where")=List of 5
[10:59:31.296]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.296]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.296]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.296]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.296]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.296]  - attr(*, "resolved")= logi FALSE
[10:59:31.296]  - attr(*, "total_size")= num 876
[10:59:31.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.296]  - attr(*, "already-done")= logi TRUE
[10:59:31.302] - reassign environment for ‘...future.FUN’
[10:59:31.302] - copied ‘...future.FUN’ to environment
[10:59:31.303] - copied ‘MoreArgs’ to environment
[10:59:31.303] - copied ‘...future.elements_ii’ to environment
[10:59:31.303] - copied ‘...future.seeds_ii’ to environment
[10:59:31.303] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.303] assign_globals() ... done
[10:59:31.303] plan(): Setting new future strategy stack:
[10:59:31.303] List of future strategies:
[10:59:31.303] 1. sequential:
[10:59:31.303]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.303]    - tweaked: FALSE
[10:59:31.303]    - call: NULL
[10:59:31.304] plan(): nbrOfWorkers() = 1
[10:59:31.304] plan(): Setting new future strategy stack:
[10:59:31.304] List of future strategies:
[10:59:31.304] 1. sequential:
[10:59:31.304]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.304]    - tweaked: FALSE
[10:59:31.304]    - call: plan(strategy)
[10:59:31.305] plan(): nbrOfWorkers() = 1
[10:59:31.305] SequentialFuture started (and completed)
[10:59:31.305] - Launch lazy future ... done
[10:59:31.305] run() for ‘SequentialFuture’ ... done
[10:59:31.305] Created future:
[10:59:31.305] SequentialFuture:
[10:59:31.305] Label: ‘future_mapply-1’
[10:59:31.305] Expression:
[10:59:31.305] {
[10:59:31.305]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.305]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.305]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.305]         on.exit(options(oopts), add = TRUE)
[10:59:31.305]     }
[10:59:31.305]     {
[10:59:31.305]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.305]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.305]         do.call(mapply, args = args)
[10:59:31.305]     }
[10:59:31.305] }
[10:59:31.305] Lazy evaluation: FALSE
[10:59:31.305] Asynchronous evaluation: FALSE
[10:59:31.305] Local evaluation: TRUE
[10:59:31.305] Environment: R_GlobalEnv
[10:59:31.305] Capture standard output: TRUE
[10:59:31.305] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.305] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.305] Packages: <none>
[10:59:31.305] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.305] Resolved: TRUE
[10:59:31.305] Value: 67 bytes of class ‘list’
[10:59:31.305] Early signaling: FALSE
[10:59:31.305] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.305] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.306] Chunk #1 of 3 ... DONE
[10:59:31.306] Chunk #2 of 3 ...
[10:59:31.306]  - Finding globals in '...' for chunk #2 ...
[10:59:31.306] getGlobalsAndPackages() ...
[10:59:31.306] Searching for globals...
[10:59:31.307] 
[10:59:31.307] Searching for globals ... DONE
[10:59:31.307] - globals: [0] <none>
[10:59:31.307] getGlobalsAndPackages() ... DONE
[10:59:31.307]    + additional globals found: [n=0] 
[10:59:31.307]    + additional namespaces needed: [n=0] 
[10:59:31.307]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:31.307]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:31.307]  - seeds: <none>
[10:59:31.307]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.307] getGlobalsAndPackages() ...
[10:59:31.308] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.308] Resolving globals: FALSE
[10:59:31.308] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:31.308] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.308] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.309] 
[10:59:31.309] getGlobalsAndPackages() ... DONE
[10:59:31.309] run() for ‘Future’ ...
[10:59:31.309] - state: ‘created’
[10:59:31.309] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.309] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.309]   - Field: ‘label’
[10:59:31.310]   - Field: ‘local’
[10:59:31.310]   - Field: ‘owner’
[10:59:31.310]   - Field: ‘envir’
[10:59:31.310]   - Field: ‘packages’
[10:59:31.310]   - Field: ‘gc’
[10:59:31.310]   - Field: ‘conditions’
[10:59:31.310]   - Field: ‘expr’
[10:59:31.310]   - Field: ‘uuid’
[10:59:31.310]   - Field: ‘seed’
[10:59:31.310]   - Field: ‘version’
[10:59:31.310]   - Field: ‘result’
[10:59:31.310]   - Field: ‘asynchronous’
[10:59:31.311]   - Field: ‘calls’
[10:59:31.311]   - Field: ‘globals’
[10:59:31.311]   - Field: ‘stdout’
[10:59:31.311]   - Field: ‘earlySignal’
[10:59:31.311]   - Field: ‘lazy’
[10:59:31.311]   - Field: ‘state’
[10:59:31.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.311] - Launch lazy future ...
[10:59:31.311] Packages needed by the future expression (n = 0): <none>
[10:59:31.311] Packages needed by future strategies (n = 0): <none>
[10:59:31.312] {
[10:59:31.312]     {
[10:59:31.312]         {
[10:59:31.312]             ...future.startTime <- base::Sys.time()
[10:59:31.312]             {
[10:59:31.312]                 {
[10:59:31.312]                   {
[10:59:31.312]                     base::local({
[10:59:31.312]                       has_future <- base::requireNamespace("future", 
[10:59:31.312]                         quietly = TRUE)
[10:59:31.312]                       if (has_future) {
[10:59:31.312]                         ns <- base::getNamespace("future")
[10:59:31.312]                         version <- ns[[".package"]][["version"]]
[10:59:31.312]                         if (is.null(version)) 
[10:59:31.312]                           version <- utils::packageVersion("future")
[10:59:31.312]                       }
[10:59:31.312]                       else {
[10:59:31.312]                         version <- NULL
[10:59:31.312]                       }
[10:59:31.312]                       if (!has_future || version < "1.8.0") {
[10:59:31.312]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.312]                           "", base::R.version$version.string), 
[10:59:31.312]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.312]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.312]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.312]                             "release", "version")], collapse = " "), 
[10:59:31.312]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.312]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.312]                           info)
[10:59:31.312]                         info <- base::paste(info, collapse = "; ")
[10:59:31.312]                         if (!has_future) {
[10:59:31.312]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.312]                             info)
[10:59:31.312]                         }
[10:59:31.312]                         else {
[10:59:31.312]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.312]                             info, version)
[10:59:31.312]                         }
[10:59:31.312]                         base::stop(msg)
[10:59:31.312]                       }
[10:59:31.312]                     })
[10:59:31.312]                   }
[10:59:31.312]                   ...future.strategy.old <- future::plan("list")
[10:59:31.312]                   options(future.plan = NULL)
[10:59:31.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.312]                 }
[10:59:31.312]                 ...future.workdir <- getwd()
[10:59:31.312]             }
[10:59:31.312]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.312]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.312]         }
[10:59:31.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.312]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:31.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.312]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.312]             base::names(...future.oldOptions))
[10:59:31.312]     }
[10:59:31.312]     if (FALSE) {
[10:59:31.312]     }
[10:59:31.312]     else {
[10:59:31.312]         if (TRUE) {
[10:59:31.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.312]                 open = "w")
[10:59:31.312]         }
[10:59:31.312]         else {
[10:59:31.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.312]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.312]         }
[10:59:31.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.312]             base::sink(type = "output", split = FALSE)
[10:59:31.312]             base::close(...future.stdout)
[10:59:31.312]         }, add = TRUE)
[10:59:31.312]     }
[10:59:31.312]     ...future.frame <- base::sys.nframe()
[10:59:31.312]     ...future.conditions <- base::list()
[10:59:31.312]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.312]     if (FALSE) {
[10:59:31.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.312]     }
[10:59:31.312]     ...future.result <- base::tryCatch({
[10:59:31.312]         base::withCallingHandlers({
[10:59:31.312]             ...future.value <- base::withVisible(base::local({
[10:59:31.312]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.312]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.312]                   ...future.globals.maxSize)) {
[10:59:31.312]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.312]                   on.exit(options(oopts), add = TRUE)
[10:59:31.312]                 }
[10:59:31.312]                 {
[10:59:31.312]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.312]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.312]                     USE.NAMES = FALSE)
[10:59:31.312]                   do.call(mapply, args = args)
[10:59:31.312]                 }
[10:59:31.312]             }))
[10:59:31.312]             future::FutureResult(value = ...future.value$value, 
[10:59:31.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.312]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.312]                     ...future.globalenv.names))
[10:59:31.312]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.312]         }, condition = base::local({
[10:59:31.312]             c <- base::c
[10:59:31.312]             inherits <- base::inherits
[10:59:31.312]             invokeRestart <- base::invokeRestart
[10:59:31.312]             length <- base::length
[10:59:31.312]             list <- base::list
[10:59:31.312]             seq.int <- base::seq.int
[10:59:31.312]             signalCondition <- base::signalCondition
[10:59:31.312]             sys.calls <- base::sys.calls
[10:59:31.312]             `[[` <- base::`[[`
[10:59:31.312]             `+` <- base::`+`
[10:59:31.312]             `<<-` <- base::`<<-`
[10:59:31.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.312]                   3L)]
[10:59:31.312]             }
[10:59:31.312]             function(cond) {
[10:59:31.312]                 is_error <- inherits(cond, "error")
[10:59:31.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.312]                   NULL)
[10:59:31.312]                 if (is_error) {
[10:59:31.312]                   sessionInformation <- function() {
[10:59:31.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.312]                       search = base::search(), system = base::Sys.info())
[10:59:31.312]                   }
[10:59:31.312]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.312]                     cond$call), session = sessionInformation(), 
[10:59:31.312]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.312]                   signalCondition(cond)
[10:59:31.312]                 }
[10:59:31.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.312]                 "immediateCondition"))) {
[10:59:31.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.312]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.312]                   if (TRUE && !signal) {
[10:59:31.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.312]                     {
[10:59:31.312]                       inherits <- base::inherits
[10:59:31.312]                       invokeRestart <- base::invokeRestart
[10:59:31.312]                       is.null <- base::is.null
[10:59:31.312]                       muffled <- FALSE
[10:59:31.312]                       if (inherits(cond, "message")) {
[10:59:31.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.312]                         if (muffled) 
[10:59:31.312]                           invokeRestart("muffleMessage")
[10:59:31.312]                       }
[10:59:31.312]                       else if (inherits(cond, "warning")) {
[10:59:31.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.312]                         if (muffled) 
[10:59:31.312]                           invokeRestart("muffleWarning")
[10:59:31.312]                       }
[10:59:31.312]                       else if (inherits(cond, "condition")) {
[10:59:31.312]                         if (!is.null(pattern)) {
[10:59:31.312]                           computeRestarts <- base::computeRestarts
[10:59:31.312]                           grepl <- base::grepl
[10:59:31.312]                           restarts <- computeRestarts(cond)
[10:59:31.312]                           for (restart in restarts) {
[10:59:31.312]                             name <- restart$name
[10:59:31.312]                             if (is.null(name)) 
[10:59:31.312]                               next
[10:59:31.312]                             if (!grepl(pattern, name)) 
[10:59:31.312]                               next
[10:59:31.312]                             invokeRestart(restart)
[10:59:31.312]                             muffled <- TRUE
[10:59:31.312]                             break
[10:59:31.312]                           }
[10:59:31.312]                         }
[10:59:31.312]                       }
[10:59:31.312]                       invisible(muffled)
[10:59:31.312]                     }
[10:59:31.312]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.312]                   }
[10:59:31.312]                 }
[10:59:31.312]                 else {
[10:59:31.312]                   if (TRUE) {
[10:59:31.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.312]                     {
[10:59:31.312]                       inherits <- base::inherits
[10:59:31.312]                       invokeRestart <- base::invokeRestart
[10:59:31.312]                       is.null <- base::is.null
[10:59:31.312]                       muffled <- FALSE
[10:59:31.312]                       if (inherits(cond, "message")) {
[10:59:31.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.312]                         if (muffled) 
[10:59:31.312]                           invokeRestart("muffleMessage")
[10:59:31.312]                       }
[10:59:31.312]                       else if (inherits(cond, "warning")) {
[10:59:31.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.312]                         if (muffled) 
[10:59:31.312]                           invokeRestart("muffleWarning")
[10:59:31.312]                       }
[10:59:31.312]                       else if (inherits(cond, "condition")) {
[10:59:31.312]                         if (!is.null(pattern)) {
[10:59:31.312]                           computeRestarts <- base::computeRestarts
[10:59:31.312]                           grepl <- base::grepl
[10:59:31.312]                           restarts <- computeRestarts(cond)
[10:59:31.312]                           for (restart in restarts) {
[10:59:31.312]                             name <- restart$name
[10:59:31.312]                             if (is.null(name)) 
[10:59:31.312]                               next
[10:59:31.312]                             if (!grepl(pattern, name)) 
[10:59:31.312]                               next
[10:59:31.312]                             invokeRestart(restart)
[10:59:31.312]                             muffled <- TRUE
[10:59:31.312]                             break
[10:59:31.312]                           }
[10:59:31.312]                         }
[10:59:31.312]                       }
[10:59:31.312]                       invisible(muffled)
[10:59:31.312]                     }
[10:59:31.312]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.312]                   }
[10:59:31.312]                 }
[10:59:31.312]             }
[10:59:31.312]         }))
[10:59:31.312]     }, error = function(ex) {
[10:59:31.312]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.312]                 ...future.rng), started = ...future.startTime, 
[10:59:31.312]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.312]             version = "1.8"), class = "FutureResult")
[10:59:31.312]     }, finally = {
[10:59:31.312]         if (!identical(...future.workdir, getwd())) 
[10:59:31.312]             setwd(...future.workdir)
[10:59:31.312]         {
[10:59:31.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.312]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.312]             }
[10:59:31.312]             base::options(...future.oldOptions)
[10:59:31.312]             if (.Platform$OS.type == "windows") {
[10:59:31.312]                 old_names <- names(...future.oldEnvVars)
[10:59:31.312]                 envs <- base::Sys.getenv()
[10:59:31.312]                 names <- names(envs)
[10:59:31.312]                 common <- intersect(names, old_names)
[10:59:31.312]                 added <- setdiff(names, old_names)
[10:59:31.312]                 removed <- setdiff(old_names, names)
[10:59:31.312]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.312]                   envs[common]]
[10:59:31.312]                 NAMES <- toupper(changed)
[10:59:31.312]                 args <- list()
[10:59:31.312]                 for (kk in seq_along(NAMES)) {
[10:59:31.312]                   name <- changed[[kk]]
[10:59:31.312]                   NAME <- NAMES[[kk]]
[10:59:31.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.312]                     next
[10:59:31.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.312]                 }
[10:59:31.312]                 NAMES <- toupper(added)
[10:59:31.312]                 for (kk in seq_along(NAMES)) {
[10:59:31.312]                   name <- added[[kk]]
[10:59:31.312]                   NAME <- NAMES[[kk]]
[10:59:31.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.312]                     next
[10:59:31.312]                   args[[name]] <- ""
[10:59:31.312]                 }
[10:59:31.312]                 NAMES <- toupper(removed)
[10:59:31.312]                 for (kk in seq_along(NAMES)) {
[10:59:31.312]                   name <- removed[[kk]]
[10:59:31.312]                   NAME <- NAMES[[kk]]
[10:59:31.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.312]                     next
[10:59:31.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.312]                 }
[10:59:31.312]                 if (length(args) > 0) 
[10:59:31.312]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.312]             }
[10:59:31.312]             else {
[10:59:31.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.312]             }
[10:59:31.312]             {
[10:59:31.312]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.312]                   0L) {
[10:59:31.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.312]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.312]                   base::options(opts)
[10:59:31.312]                 }
[10:59:31.312]                 {
[10:59:31.312]                   {
[10:59:31.312]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.312]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.312]                     1047550554L), envir = base::globalenv(), 
[10:59:31.312]                       inherits = FALSE)
[10:59:31.312]                     NULL
[10:59:31.312]                   }
[10:59:31.312]                   options(future.plan = NULL)
[10:59:31.312]                   if (is.na(NA_character_)) 
[10:59:31.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.312]                     .init = FALSE)
[10:59:31.312]                 }
[10:59:31.312]             }
[10:59:31.312]         }
[10:59:31.312]     })
[10:59:31.312]     if (TRUE) {
[10:59:31.312]         base::sink(type = "output", split = FALSE)
[10:59:31.312]         if (TRUE) {
[10:59:31.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.312]         }
[10:59:31.312]         else {
[10:59:31.312]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.312]         }
[10:59:31.312]         base::close(...future.stdout)
[10:59:31.312]         ...future.stdout <- NULL
[10:59:31.312]     }
[10:59:31.312]     ...future.result$conditions <- ...future.conditions
[10:59:31.312]     ...future.result$finished <- base::Sys.time()
[10:59:31.312]     ...future.result
[10:59:31.312] }
[10:59:31.313] assign_globals() ...
[10:59:31.313] List of 5
[10:59:31.313]  $ ...future.FUN            :function (C, k)  
[10:59:31.313]  $ MoreArgs                 : NULL
[10:59:31.313]  $ ...future.elements_ii    :List of 2
[10:59:31.313]   ..$ :List of 1
[10:59:31.313]   .. ..$ : chr "A"
[10:59:31.313]   ..$ :List of 1
[10:59:31.313]   .. ..$ : int 5
[10:59:31.313]  $ ...future.seeds_ii       : NULL
[10:59:31.313]  $ ...future.globals.maxSize: NULL
[10:59:31.313]  - attr(*, "where")=List of 5
[10:59:31.313]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.313]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.313]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.313]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.313]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.313]  - attr(*, "resolved")= logi FALSE
[10:59:31.313]  - attr(*, "total_size")= num 847
[10:59:31.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.313]  - attr(*, "already-done")= logi TRUE
[10:59:31.318] - reassign environment for ‘...future.FUN’
[10:59:31.318] - copied ‘...future.FUN’ to environment
[10:59:31.318] - copied ‘MoreArgs’ to environment
[10:59:31.318] - copied ‘...future.elements_ii’ to environment
[10:59:31.318] - copied ‘...future.seeds_ii’ to environment
[10:59:31.318] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.318] assign_globals() ... done
[10:59:31.319] plan(): Setting new future strategy stack:
[10:59:31.319] List of future strategies:
[10:59:31.319] 1. sequential:
[10:59:31.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.319]    - tweaked: FALSE
[10:59:31.319]    - call: NULL
[10:59:31.319] plan(): nbrOfWorkers() = 1
[10:59:31.320] plan(): Setting new future strategy stack:
[10:59:31.320] List of future strategies:
[10:59:31.320] 1. sequential:
[10:59:31.320]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.320]    - tweaked: FALSE
[10:59:31.320]    - call: plan(strategy)
[10:59:31.320] plan(): nbrOfWorkers() = 1
[10:59:31.320] SequentialFuture started (and completed)
[10:59:31.321] - Launch lazy future ... done
[10:59:31.321] run() for ‘SequentialFuture’ ... done
[10:59:31.321] Created future:
[10:59:31.321] SequentialFuture:
[10:59:31.321] Label: ‘future_mapply-2’
[10:59:31.321] Expression:
[10:59:31.321] {
[10:59:31.321]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.321]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.321]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.321]         on.exit(options(oopts), add = TRUE)
[10:59:31.321]     }
[10:59:31.321]     {
[10:59:31.321]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.321]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.321]         do.call(mapply, args = args)
[10:59:31.321]     }
[10:59:31.321] }
[10:59:31.321] Lazy evaluation: FALSE
[10:59:31.321] Asynchronous evaluation: FALSE
[10:59:31.321] Local evaluation: TRUE
[10:59:31.321] Environment: R_GlobalEnv
[10:59:31.321] Capture standard output: TRUE
[10:59:31.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.321] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.321] Packages: <none>
[10:59:31.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.321] Resolved: TRUE
[10:59:31.321] Value: 52 bytes of class ‘list’
[10:59:31.321] Early signaling: FALSE
[10:59:31.321] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.321] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.322] Chunk #2 of 3 ... DONE
[10:59:31.322] Chunk #3 of 3 ...
[10:59:31.323]  - Finding globals in '...' for chunk #3 ...
[10:59:31.323] getGlobalsAndPackages() ...
[10:59:31.323] Searching for globals...
[10:59:31.323] 
[10:59:31.323] Searching for globals ... DONE
[10:59:31.323] - globals: [0] <none>
[10:59:31.323] getGlobalsAndPackages() ... DONE
[10:59:31.323]    + additional globals found: [n=0] 
[10:59:31.323]    + additional namespaces needed: [n=0] 
[10:59:31.323]  - Finding globals in '...' for chunk #3 ... DONE
[10:59:31.324]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:31.324]  - seeds: <none>
[10:59:31.324]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.324] getGlobalsAndPackages() ...
[10:59:31.324] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.324] Resolving globals: FALSE
[10:59:31.324] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:31.325] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.325] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.325] 
[10:59:31.325] getGlobalsAndPackages() ... DONE
[10:59:31.325] run() for ‘Future’ ...
[10:59:31.325] - state: ‘created’
[10:59:31.325] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.326] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.326]   - Field: ‘label’
[10:59:31.326]   - Field: ‘local’
[10:59:31.326]   - Field: ‘owner’
[10:59:31.326]   - Field: ‘envir’
[10:59:31.326]   - Field: ‘packages’
[10:59:31.326]   - Field: ‘gc’
[10:59:31.326]   - Field: ‘conditions’
[10:59:31.326]   - Field: ‘expr’
[10:59:31.327]   - Field: ‘uuid’
[10:59:31.327]   - Field: ‘seed’
[10:59:31.327]   - Field: ‘version’
[10:59:31.327]   - Field: ‘result’
[10:59:31.327]   - Field: ‘asynchronous’
[10:59:31.327]   - Field: ‘calls’
[10:59:31.327]   - Field: ‘globals’
[10:59:31.327]   - Field: ‘stdout’
[10:59:31.327]   - Field: ‘earlySignal’
[10:59:31.327]   - Field: ‘lazy’
[10:59:31.327]   - Field: ‘state’
[10:59:31.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.328] - Launch lazy future ...
[10:59:31.328] Packages needed by the future expression (n = 0): <none>
[10:59:31.328] Packages needed by future strategies (n = 0): <none>
[10:59:31.328] {
[10:59:31.328]     {
[10:59:31.328]         {
[10:59:31.328]             ...future.startTime <- base::Sys.time()
[10:59:31.328]             {
[10:59:31.328]                 {
[10:59:31.328]                   {
[10:59:31.328]                     base::local({
[10:59:31.328]                       has_future <- base::requireNamespace("future", 
[10:59:31.328]                         quietly = TRUE)
[10:59:31.328]                       if (has_future) {
[10:59:31.328]                         ns <- base::getNamespace("future")
[10:59:31.328]                         version <- ns[[".package"]][["version"]]
[10:59:31.328]                         if (is.null(version)) 
[10:59:31.328]                           version <- utils::packageVersion("future")
[10:59:31.328]                       }
[10:59:31.328]                       else {
[10:59:31.328]                         version <- NULL
[10:59:31.328]                       }
[10:59:31.328]                       if (!has_future || version < "1.8.0") {
[10:59:31.328]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.328]                           "", base::R.version$version.string), 
[10:59:31.328]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.328]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.328]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.328]                             "release", "version")], collapse = " "), 
[10:59:31.328]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.328]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.328]                           info)
[10:59:31.328]                         info <- base::paste(info, collapse = "; ")
[10:59:31.328]                         if (!has_future) {
[10:59:31.328]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.328]                             info)
[10:59:31.328]                         }
[10:59:31.328]                         else {
[10:59:31.328]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.328]                             info, version)
[10:59:31.328]                         }
[10:59:31.328]                         base::stop(msg)
[10:59:31.328]                       }
[10:59:31.328]                     })
[10:59:31.328]                   }
[10:59:31.328]                   ...future.strategy.old <- future::plan("list")
[10:59:31.328]                   options(future.plan = NULL)
[10:59:31.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.328]                 }
[10:59:31.328]                 ...future.workdir <- getwd()
[10:59:31.328]             }
[10:59:31.328]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.328]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.328]         }
[10:59:31.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.328]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:31.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.328]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.328]             base::names(...future.oldOptions))
[10:59:31.328]     }
[10:59:31.328]     if (FALSE) {
[10:59:31.328]     }
[10:59:31.328]     else {
[10:59:31.328]         if (TRUE) {
[10:59:31.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.328]                 open = "w")
[10:59:31.328]         }
[10:59:31.328]         else {
[10:59:31.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.328]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.328]         }
[10:59:31.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.328]             base::sink(type = "output", split = FALSE)
[10:59:31.328]             base::close(...future.stdout)
[10:59:31.328]         }, add = TRUE)
[10:59:31.328]     }
[10:59:31.328]     ...future.frame <- base::sys.nframe()
[10:59:31.328]     ...future.conditions <- base::list()
[10:59:31.328]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.328]     if (FALSE) {
[10:59:31.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.328]     }
[10:59:31.328]     ...future.result <- base::tryCatch({
[10:59:31.328]         base::withCallingHandlers({
[10:59:31.328]             ...future.value <- base::withVisible(base::local({
[10:59:31.328]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.328]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.328]                   ...future.globals.maxSize)) {
[10:59:31.328]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.328]                   on.exit(options(oopts), add = TRUE)
[10:59:31.328]                 }
[10:59:31.328]                 {
[10:59:31.328]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.328]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.328]                     USE.NAMES = FALSE)
[10:59:31.328]                   do.call(mapply, args = args)
[10:59:31.328]                 }
[10:59:31.328]             }))
[10:59:31.328]             future::FutureResult(value = ...future.value$value, 
[10:59:31.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.328]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.328]                     ...future.globalenv.names))
[10:59:31.328]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.328]         }, condition = base::local({
[10:59:31.328]             c <- base::c
[10:59:31.328]             inherits <- base::inherits
[10:59:31.328]             invokeRestart <- base::invokeRestart
[10:59:31.328]             length <- base::length
[10:59:31.328]             list <- base::list
[10:59:31.328]             seq.int <- base::seq.int
[10:59:31.328]             signalCondition <- base::signalCondition
[10:59:31.328]             sys.calls <- base::sys.calls
[10:59:31.328]             `[[` <- base::`[[`
[10:59:31.328]             `+` <- base::`+`
[10:59:31.328]             `<<-` <- base::`<<-`
[10:59:31.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.328]                   3L)]
[10:59:31.328]             }
[10:59:31.328]             function(cond) {
[10:59:31.328]                 is_error <- inherits(cond, "error")
[10:59:31.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.328]                   NULL)
[10:59:31.328]                 if (is_error) {
[10:59:31.328]                   sessionInformation <- function() {
[10:59:31.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.328]                       search = base::search(), system = base::Sys.info())
[10:59:31.328]                   }
[10:59:31.328]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.328]                     cond$call), session = sessionInformation(), 
[10:59:31.328]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.328]                   signalCondition(cond)
[10:59:31.328]                 }
[10:59:31.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.328]                 "immediateCondition"))) {
[10:59:31.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.328]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.328]                   if (TRUE && !signal) {
[10:59:31.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.328]                     {
[10:59:31.328]                       inherits <- base::inherits
[10:59:31.328]                       invokeRestart <- base::invokeRestart
[10:59:31.328]                       is.null <- base::is.null
[10:59:31.328]                       muffled <- FALSE
[10:59:31.328]                       if (inherits(cond, "message")) {
[10:59:31.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.328]                         if (muffled) 
[10:59:31.328]                           invokeRestart("muffleMessage")
[10:59:31.328]                       }
[10:59:31.328]                       else if (inherits(cond, "warning")) {
[10:59:31.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.328]                         if (muffled) 
[10:59:31.328]                           invokeRestart("muffleWarning")
[10:59:31.328]                       }
[10:59:31.328]                       else if (inherits(cond, "condition")) {
[10:59:31.328]                         if (!is.null(pattern)) {
[10:59:31.328]                           computeRestarts <- base::computeRestarts
[10:59:31.328]                           grepl <- base::grepl
[10:59:31.328]                           restarts <- computeRestarts(cond)
[10:59:31.328]                           for (restart in restarts) {
[10:59:31.328]                             name <- restart$name
[10:59:31.328]                             if (is.null(name)) 
[10:59:31.328]                               next
[10:59:31.328]                             if (!grepl(pattern, name)) 
[10:59:31.328]                               next
[10:59:31.328]                             invokeRestart(restart)
[10:59:31.328]                             muffled <- TRUE
[10:59:31.328]                             break
[10:59:31.328]                           }
[10:59:31.328]                         }
[10:59:31.328]                       }
[10:59:31.328]                       invisible(muffled)
[10:59:31.328]                     }
[10:59:31.328]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.328]                   }
[10:59:31.328]                 }
[10:59:31.328]                 else {
[10:59:31.328]                   if (TRUE) {
[10:59:31.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.328]                     {
[10:59:31.328]                       inherits <- base::inherits
[10:59:31.328]                       invokeRestart <- base::invokeRestart
[10:59:31.328]                       is.null <- base::is.null
[10:59:31.328]                       muffled <- FALSE
[10:59:31.328]                       if (inherits(cond, "message")) {
[10:59:31.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.328]                         if (muffled) 
[10:59:31.328]                           invokeRestart("muffleMessage")
[10:59:31.328]                       }
[10:59:31.328]                       else if (inherits(cond, "warning")) {
[10:59:31.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.328]                         if (muffled) 
[10:59:31.328]                           invokeRestart("muffleWarning")
[10:59:31.328]                       }
[10:59:31.328]                       else if (inherits(cond, "condition")) {
[10:59:31.328]                         if (!is.null(pattern)) {
[10:59:31.328]                           computeRestarts <- base::computeRestarts
[10:59:31.328]                           grepl <- base::grepl
[10:59:31.328]                           restarts <- computeRestarts(cond)
[10:59:31.328]                           for (restart in restarts) {
[10:59:31.328]                             name <- restart$name
[10:59:31.328]                             if (is.null(name)) 
[10:59:31.328]                               next
[10:59:31.328]                             if (!grepl(pattern, name)) 
[10:59:31.328]                               next
[10:59:31.328]                             invokeRestart(restart)
[10:59:31.328]                             muffled <- TRUE
[10:59:31.328]                             break
[10:59:31.328]                           }
[10:59:31.328]                         }
[10:59:31.328]                       }
[10:59:31.328]                       invisible(muffled)
[10:59:31.328]                     }
[10:59:31.328]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.328]                   }
[10:59:31.328]                 }
[10:59:31.328]             }
[10:59:31.328]         }))
[10:59:31.328]     }, error = function(ex) {
[10:59:31.328]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.328]                 ...future.rng), started = ...future.startTime, 
[10:59:31.328]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.328]             version = "1.8"), class = "FutureResult")
[10:59:31.328]     }, finally = {
[10:59:31.328]         if (!identical(...future.workdir, getwd())) 
[10:59:31.328]             setwd(...future.workdir)
[10:59:31.328]         {
[10:59:31.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.328]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.328]             }
[10:59:31.328]             base::options(...future.oldOptions)
[10:59:31.328]             if (.Platform$OS.type == "windows") {
[10:59:31.328]                 old_names <- names(...future.oldEnvVars)
[10:59:31.328]                 envs <- base::Sys.getenv()
[10:59:31.328]                 names <- names(envs)
[10:59:31.328]                 common <- intersect(names, old_names)
[10:59:31.328]                 added <- setdiff(names, old_names)
[10:59:31.328]                 removed <- setdiff(old_names, names)
[10:59:31.328]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.328]                   envs[common]]
[10:59:31.328]                 NAMES <- toupper(changed)
[10:59:31.328]                 args <- list()
[10:59:31.328]                 for (kk in seq_along(NAMES)) {
[10:59:31.328]                   name <- changed[[kk]]
[10:59:31.328]                   NAME <- NAMES[[kk]]
[10:59:31.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.328]                     next
[10:59:31.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.328]                 }
[10:59:31.328]                 NAMES <- toupper(added)
[10:59:31.328]                 for (kk in seq_along(NAMES)) {
[10:59:31.328]                   name <- added[[kk]]
[10:59:31.328]                   NAME <- NAMES[[kk]]
[10:59:31.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.328]                     next
[10:59:31.328]                   args[[name]] <- ""
[10:59:31.328]                 }
[10:59:31.328]                 NAMES <- toupper(removed)
[10:59:31.328]                 for (kk in seq_along(NAMES)) {
[10:59:31.328]                   name <- removed[[kk]]
[10:59:31.328]                   NAME <- NAMES[[kk]]
[10:59:31.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.328]                     next
[10:59:31.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.328]                 }
[10:59:31.328]                 if (length(args) > 0) 
[10:59:31.328]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.328]             }
[10:59:31.328]             else {
[10:59:31.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.328]             }
[10:59:31.328]             {
[10:59:31.328]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.328]                   0L) {
[10:59:31.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.328]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.328]                   base::options(opts)
[10:59:31.328]                 }
[10:59:31.328]                 {
[10:59:31.328]                   {
[10:59:31.328]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.328]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.328]                     1047550554L), envir = base::globalenv(), 
[10:59:31.328]                       inherits = FALSE)
[10:59:31.328]                     NULL
[10:59:31.328]                   }
[10:59:31.328]                   options(future.plan = NULL)
[10:59:31.328]                   if (is.na(NA_character_)) 
[10:59:31.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.328]                     .init = FALSE)
[10:59:31.328]                 }
[10:59:31.328]             }
[10:59:31.328]         }
[10:59:31.328]     })
[10:59:31.328]     if (TRUE) {
[10:59:31.328]         base::sink(type = "output", split = FALSE)
[10:59:31.328]         if (TRUE) {
[10:59:31.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.328]         }
[10:59:31.328]         else {
[10:59:31.328]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.328]         }
[10:59:31.328]         base::close(...future.stdout)
[10:59:31.328]         ...future.stdout <- NULL
[10:59:31.328]     }
[10:59:31.328]     ...future.result$conditions <- ...future.conditions
[10:59:31.328]     ...future.result$finished <- base::Sys.time()
[10:59:31.328]     ...future.result
[10:59:31.328] }
[10:59:31.330] assign_globals() ...
[10:59:31.330] List of 5
[10:59:31.330]  $ ...future.FUN            :function (C, k)  
[10:59:31.330]  $ MoreArgs                 : NULL
[10:59:31.330]  $ ...future.elements_ii    :List of 2
[10:59:31.330]   ..$ :List of 2
[10:59:31.330]   .. ..$ : chr "B"
[10:59:31.330]   .. ..$ : chr "D"
[10:59:31.330]   ..$ :List of 2
[10:59:31.330]   .. ..$ : int 4
[10:59:31.330]   .. ..$ : int 2
[10:59:31.330]  $ ...future.seeds_ii       : NULL
[10:59:31.330]  $ ...future.globals.maxSize: NULL
[10:59:31.330]  - attr(*, "where")=List of 5
[10:59:31.330]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.330]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.330]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.330]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.330]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.330]  - attr(*, "resolved")= logi FALSE
[10:59:31.330]  - attr(*, "total_size")= num 876
[10:59:31.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.330]  - attr(*, "already-done")= logi TRUE
[10:59:31.335] - reassign environment for ‘...future.FUN’
[10:59:31.335] - copied ‘...future.FUN’ to environment
[10:59:31.335] - copied ‘MoreArgs’ to environment
[10:59:31.335] - copied ‘...future.elements_ii’ to environment
[10:59:31.335] - copied ‘...future.seeds_ii’ to environment
[10:59:31.335] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.335] assign_globals() ... done
[10:59:31.336] plan(): Setting new future strategy stack:
[10:59:31.336] List of future strategies:
[10:59:31.336] 1. sequential:
[10:59:31.336]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.336]    - tweaked: FALSE
[10:59:31.336]    - call: NULL
[10:59:31.336] plan(): nbrOfWorkers() = 1
[10:59:31.337] plan(): Setting new future strategy stack:
[10:59:31.337] List of future strategies:
[10:59:31.337] 1. sequential:
[10:59:31.337]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.337]    - tweaked: FALSE
[10:59:31.337]    - call: plan(strategy)
[10:59:31.337] plan(): nbrOfWorkers() = 1
[10:59:31.337] SequentialFuture started (and completed)
[10:59:31.337] - Launch lazy future ... done
[10:59:31.338] run() for ‘SequentialFuture’ ... done
[10:59:31.338] Created future:
[10:59:31.338] SequentialFuture:
[10:59:31.338] Label: ‘future_mapply-3’
[10:59:31.338] Expression:
[10:59:31.338] {
[10:59:31.338]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.338]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.338]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.338]         on.exit(options(oopts), add = TRUE)
[10:59:31.338]     }
[10:59:31.338]     {
[10:59:31.338]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.338]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.338]         do.call(mapply, args = args)
[10:59:31.338]     }
[10:59:31.338] }
[10:59:31.338] Lazy evaluation: FALSE
[10:59:31.338] Asynchronous evaluation: FALSE
[10:59:31.338] Local evaluation: TRUE
[10:59:31.338] Environment: R_GlobalEnv
[10:59:31.338] Capture standard output: TRUE
[10:59:31.338] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.338] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.338] Packages: <none>
[10:59:31.338] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.338] Resolved: TRUE
[10:59:31.338] Value: 69 bytes of class ‘list’
[10:59:31.338] Early signaling: FALSE
[10:59:31.338] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.338] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.338] Chunk #3 of 3 ... DONE
[10:59:31.338] Launching 3 futures (chunks) ... DONE
[10:59:31.339] Resolving 3 futures (chunks) ...
[10:59:31.339] resolve() on list ...
[10:59:31.339]  recursive: 0
[10:59:31.339]  length: 3
[10:59:31.339] 
[10:59:31.339] resolved() for ‘SequentialFuture’ ...
[10:59:31.339] - state: ‘finished’
[10:59:31.339] - run: TRUE
[10:59:31.339] - result: ‘FutureResult’
[10:59:31.339] resolved() for ‘SequentialFuture’ ... done
[10:59:31.339] Future #1
[10:59:31.340] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.340] - nx: 3
[10:59:31.340] - relay: TRUE
[10:59:31.340] - stdout: TRUE
[10:59:31.340] - signal: TRUE
[10:59:31.340] - resignal: FALSE
[10:59:31.340] - force: TRUE
[10:59:31.340] - relayed: [n=3] FALSE, FALSE, FALSE
[10:59:31.340] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:59:31.340]  - until=1
[10:59:31.340]  - relaying element #1
[10:59:31.340] - relayed: [n=3] TRUE, FALSE, FALSE
[10:59:31.341] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:59:31.341] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.341]  length: 2 (resolved future 1)
[10:59:31.341] resolved() for ‘SequentialFuture’ ...
[10:59:31.341] - state: ‘finished’
[10:59:31.341] - run: TRUE
[10:59:31.341] - result: ‘FutureResult’
[10:59:31.341] resolved() for ‘SequentialFuture’ ... done
[10:59:31.341] Future #2
[10:59:31.341] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:59:31.341] - nx: 3
[10:59:31.341] - relay: TRUE
[10:59:31.342] - stdout: TRUE
[10:59:31.342] - signal: TRUE
[10:59:31.342] - resignal: FALSE
[10:59:31.342] - force: TRUE
[10:59:31.342] - relayed: [n=3] TRUE, FALSE, FALSE
[10:59:31.342] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:59:31.342]  - until=2
[10:59:31.342]  - relaying element #2
[10:59:31.342] - relayed: [n=3] TRUE, TRUE, FALSE
[10:59:31.342] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:59:31.342] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:59:31.342]  length: 1 (resolved future 2)
[10:59:31.343] resolved() for ‘SequentialFuture’ ...
[10:59:31.343] - state: ‘finished’
[10:59:31.343] - run: TRUE
[10:59:31.343] - result: ‘FutureResult’
[10:59:31.343] resolved() for ‘SequentialFuture’ ... done
[10:59:31.343] Future #3
[10:59:31.343] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:59:31.343] - nx: 3
[10:59:31.344] - relay: TRUE
[10:59:31.344] - stdout: TRUE
[10:59:31.344] - signal: TRUE
[10:59:31.344] - resignal: FALSE
[10:59:31.344] - force: TRUE
[10:59:31.344] - relayed: [n=3] TRUE, TRUE, FALSE
[10:59:31.345] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:59:31.345]  - until=3
[10:59:31.345]  - relaying element #3
[10:59:31.345] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:31.345] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:59:31.345] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:59:31.345]  length: 0 (resolved future 3)
[10:59:31.345] Relaying remaining futures
[10:59:31.345] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.345] - nx: 3
[10:59:31.345] - relay: TRUE
[10:59:31.346] - stdout: TRUE
[10:59:31.346] - signal: TRUE
[10:59:31.346] - resignal: FALSE
[10:59:31.346] - force: TRUE
[10:59:31.346] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:31.346] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:59:31.346] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:31.346] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:59:31.346] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.346] resolve() on list ... DONE
[10:59:31.347]  - Number of value chunks collected: 3
[10:59:31.347] Resolving 3 futures (chunks) ... DONE
[10:59:31.347] Reducing values from 3 chunks ...
[10:59:31.347]  - Number of values collected after concatenation: 5
[10:59:31.347]  - Number of values expected: 5
[10:59:31.347] Reverse index remapping (attribute 'ordering'): [n = 5] 3, 4, 2, 5, 1
[10:59:31.347] Reducing values from 3 chunks ... DONE
[10:59:31.347] future_mapply() ... DONE
[10:59:31.347] future_mapply() ...
[10:59:31.347] Number of chunks: 1
[10:59:31.348] getGlobalsAndPackagesXApply() ...
[10:59:31.348]  - future.globals: TRUE
[10:59:31.348] getGlobalsAndPackages() ...
[10:59:31.348] Searching for globals...
[10:59:31.349] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:31.349] Searching for globals ... DONE
[10:59:31.349] Resolving globals: FALSE
[10:59:31.349] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:31.350] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:31.350] - globals: [1] ‘FUN’
[10:59:31.350] 
[10:59:31.350] getGlobalsAndPackages() ... DONE
[10:59:31.350]  - globals found/used: [n=1] ‘FUN’
[10:59:31.350]  - needed namespaces: [n=0] 
[10:59:31.350] Finding globals ... DONE
[10:59:31.350] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.350] List of 2
[10:59:31.350]  $ ...future.FUN:function (C, k)  
[10:59:31.350]  $ MoreArgs     : list()
[10:59:31.350]  - attr(*, "where")=List of 2
[10:59:31.350]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.350]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.350]  - attr(*, "resolved")= logi FALSE
[10:59:31.350]  - attr(*, "total_size")= num NA
[10:59:31.353] Packages to be attached in all futures: [n=0] 
[10:59:31.353] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.353] Number of futures (= number of chunks): 1
[10:59:31.353] Launching 1 futures (chunks) ...
[10:59:31.353] Chunk #1 of 1 ...
[10:59:31.353]  - Finding globals in '...' for chunk #1 ...
[10:59:31.353] getGlobalsAndPackages() ...
[10:59:31.353] Searching for globals...
[10:59:31.354] 
[10:59:31.354] Searching for globals ... DONE
[10:59:31.354] - globals: [0] <none>
[10:59:31.354] getGlobalsAndPackages() ... DONE
[10:59:31.354]    + additional globals found: [n=0] 
[10:59:31.354]    + additional namespaces needed: [n=0] 
[10:59:31.354]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.354]  - seeds: <none>
[10:59:31.354]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.354] getGlobalsAndPackages() ...
[10:59:31.354] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.355] Resolving globals: FALSE
[10:59:31.355] The total size of the 5 globals is 967 bytes (967 bytes)
[10:59:31.355] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:31.355] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.356] 
[10:59:31.356] getGlobalsAndPackages() ... DONE
[10:59:31.356] run() for ‘Future’ ...
[10:59:31.356] - state: ‘created’
[10:59:31.356] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.356] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.356]   - Field: ‘label’
[10:59:31.357]   - Field: ‘local’
[10:59:31.357]   - Field: ‘owner’
[10:59:31.357]   - Field: ‘envir’
[10:59:31.357]   - Field: ‘packages’
[10:59:31.357]   - Field: ‘gc’
[10:59:31.357]   - Field: ‘conditions’
[10:59:31.357]   - Field: ‘expr’
[10:59:31.357]   - Field: ‘uuid’
[10:59:31.357]   - Field: ‘seed’
[10:59:31.357]   - Field: ‘version’
[10:59:31.357]   - Field: ‘result’
[10:59:31.357]   - Field: ‘asynchronous’
[10:59:31.357]   - Field: ‘calls’
[10:59:31.358]   - Field: ‘globals’
[10:59:31.358]   - Field: ‘stdout’
[10:59:31.358]   - Field: ‘earlySignal’
[10:59:31.358]   - Field: ‘lazy’
[10:59:31.358]   - Field: ‘state’
[10:59:31.358] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.358] - Launch lazy future ...
[10:59:31.358] Packages needed by the future expression (n = 0): <none>
[10:59:31.358] Packages needed by future strategies (n = 0): <none>
[10:59:31.359] {
[10:59:31.359]     {
[10:59:31.359]         {
[10:59:31.359]             ...future.startTime <- base::Sys.time()
[10:59:31.359]             {
[10:59:31.359]                 {
[10:59:31.359]                   {
[10:59:31.359]                     base::local({
[10:59:31.359]                       has_future <- base::requireNamespace("future", 
[10:59:31.359]                         quietly = TRUE)
[10:59:31.359]                       if (has_future) {
[10:59:31.359]                         ns <- base::getNamespace("future")
[10:59:31.359]                         version <- ns[[".package"]][["version"]]
[10:59:31.359]                         if (is.null(version)) 
[10:59:31.359]                           version <- utils::packageVersion("future")
[10:59:31.359]                       }
[10:59:31.359]                       else {
[10:59:31.359]                         version <- NULL
[10:59:31.359]                       }
[10:59:31.359]                       if (!has_future || version < "1.8.0") {
[10:59:31.359]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.359]                           "", base::R.version$version.string), 
[10:59:31.359]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.359]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.359]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.359]                             "release", "version")], collapse = " "), 
[10:59:31.359]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.359]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.359]                           info)
[10:59:31.359]                         info <- base::paste(info, collapse = "; ")
[10:59:31.359]                         if (!has_future) {
[10:59:31.359]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.359]                             info)
[10:59:31.359]                         }
[10:59:31.359]                         else {
[10:59:31.359]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.359]                             info, version)
[10:59:31.359]                         }
[10:59:31.359]                         base::stop(msg)
[10:59:31.359]                       }
[10:59:31.359]                     })
[10:59:31.359]                   }
[10:59:31.359]                   ...future.strategy.old <- future::plan("list")
[10:59:31.359]                   options(future.plan = NULL)
[10:59:31.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.359]                 }
[10:59:31.359]                 ...future.workdir <- getwd()
[10:59:31.359]             }
[10:59:31.359]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.359]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.359]         }
[10:59:31.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.359]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.359]             base::names(...future.oldOptions))
[10:59:31.359]     }
[10:59:31.359]     if (FALSE) {
[10:59:31.359]     }
[10:59:31.359]     else {
[10:59:31.359]         if (TRUE) {
[10:59:31.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.359]                 open = "w")
[10:59:31.359]         }
[10:59:31.359]         else {
[10:59:31.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.359]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.359]         }
[10:59:31.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.359]             base::sink(type = "output", split = FALSE)
[10:59:31.359]             base::close(...future.stdout)
[10:59:31.359]         }, add = TRUE)
[10:59:31.359]     }
[10:59:31.359]     ...future.frame <- base::sys.nframe()
[10:59:31.359]     ...future.conditions <- base::list()
[10:59:31.359]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.359]     if (FALSE) {
[10:59:31.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.359]     }
[10:59:31.359]     ...future.result <- base::tryCatch({
[10:59:31.359]         base::withCallingHandlers({
[10:59:31.359]             ...future.value <- base::withVisible(base::local({
[10:59:31.359]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.359]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.359]                   ...future.globals.maxSize)) {
[10:59:31.359]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.359]                   on.exit(options(oopts), add = TRUE)
[10:59:31.359]                 }
[10:59:31.359]                 {
[10:59:31.359]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.359]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.359]                     USE.NAMES = FALSE)
[10:59:31.359]                   do.call(mapply, args = args)
[10:59:31.359]                 }
[10:59:31.359]             }))
[10:59:31.359]             future::FutureResult(value = ...future.value$value, 
[10:59:31.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.359]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.359]                     ...future.globalenv.names))
[10:59:31.359]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.359]         }, condition = base::local({
[10:59:31.359]             c <- base::c
[10:59:31.359]             inherits <- base::inherits
[10:59:31.359]             invokeRestart <- base::invokeRestart
[10:59:31.359]             length <- base::length
[10:59:31.359]             list <- base::list
[10:59:31.359]             seq.int <- base::seq.int
[10:59:31.359]             signalCondition <- base::signalCondition
[10:59:31.359]             sys.calls <- base::sys.calls
[10:59:31.359]             `[[` <- base::`[[`
[10:59:31.359]             `+` <- base::`+`
[10:59:31.359]             `<<-` <- base::`<<-`
[10:59:31.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.359]                   3L)]
[10:59:31.359]             }
[10:59:31.359]             function(cond) {
[10:59:31.359]                 is_error <- inherits(cond, "error")
[10:59:31.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.359]                   NULL)
[10:59:31.359]                 if (is_error) {
[10:59:31.359]                   sessionInformation <- function() {
[10:59:31.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.359]                       search = base::search(), system = base::Sys.info())
[10:59:31.359]                   }
[10:59:31.359]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.359]                     cond$call), session = sessionInformation(), 
[10:59:31.359]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.359]                   signalCondition(cond)
[10:59:31.359]                 }
[10:59:31.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.359]                 "immediateCondition"))) {
[10:59:31.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.359]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.359]                   if (TRUE && !signal) {
[10:59:31.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.359]                     {
[10:59:31.359]                       inherits <- base::inherits
[10:59:31.359]                       invokeRestart <- base::invokeRestart
[10:59:31.359]                       is.null <- base::is.null
[10:59:31.359]                       muffled <- FALSE
[10:59:31.359]                       if (inherits(cond, "message")) {
[10:59:31.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.359]                         if (muffled) 
[10:59:31.359]                           invokeRestart("muffleMessage")
[10:59:31.359]                       }
[10:59:31.359]                       else if (inherits(cond, "warning")) {
[10:59:31.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.359]                         if (muffled) 
[10:59:31.359]                           invokeRestart("muffleWarning")
[10:59:31.359]                       }
[10:59:31.359]                       else if (inherits(cond, "condition")) {
[10:59:31.359]                         if (!is.null(pattern)) {
[10:59:31.359]                           computeRestarts <- base::computeRestarts
[10:59:31.359]                           grepl <- base::grepl
[10:59:31.359]                           restarts <- computeRestarts(cond)
[10:59:31.359]                           for (restart in restarts) {
[10:59:31.359]                             name <- restart$name
[10:59:31.359]                             if (is.null(name)) 
[10:59:31.359]                               next
[10:59:31.359]                             if (!grepl(pattern, name)) 
[10:59:31.359]                               next
[10:59:31.359]                             invokeRestart(restart)
[10:59:31.359]                             muffled <- TRUE
[10:59:31.359]                             break
[10:59:31.359]                           }
[10:59:31.359]                         }
[10:59:31.359]                       }
[10:59:31.359]                       invisible(muffled)
[10:59:31.359]                     }
[10:59:31.359]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.359]                   }
[10:59:31.359]                 }
[10:59:31.359]                 else {
[10:59:31.359]                   if (TRUE) {
[10:59:31.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.359]                     {
[10:59:31.359]                       inherits <- base::inherits
[10:59:31.359]                       invokeRestart <- base::invokeRestart
[10:59:31.359]                       is.null <- base::is.null
[10:59:31.359]                       muffled <- FALSE
[10:59:31.359]                       if (inherits(cond, "message")) {
[10:59:31.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.359]                         if (muffled) 
[10:59:31.359]                           invokeRestart("muffleMessage")
[10:59:31.359]                       }
[10:59:31.359]                       else if (inherits(cond, "warning")) {
[10:59:31.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.359]                         if (muffled) 
[10:59:31.359]                           invokeRestart("muffleWarning")
[10:59:31.359]                       }
[10:59:31.359]                       else if (inherits(cond, "condition")) {
[10:59:31.359]                         if (!is.null(pattern)) {
[10:59:31.359]                           computeRestarts <- base::computeRestarts
[10:59:31.359]                           grepl <- base::grepl
[10:59:31.359]                           restarts <- computeRestarts(cond)
[10:59:31.359]                           for (restart in restarts) {
[10:59:31.359]                             name <- restart$name
[10:59:31.359]                             if (is.null(name)) 
[10:59:31.359]                               next
[10:59:31.359]                             if (!grepl(pattern, name)) 
[10:59:31.359]                               next
[10:59:31.359]                             invokeRestart(restart)
[10:59:31.359]                             muffled <- TRUE
[10:59:31.359]                             break
[10:59:31.359]                           }
[10:59:31.359]                         }
[10:59:31.359]                       }
[10:59:31.359]                       invisible(muffled)
[10:59:31.359]                     }
[10:59:31.359]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.359]                   }
[10:59:31.359]                 }
[10:59:31.359]             }
[10:59:31.359]         }))
[10:59:31.359]     }, error = function(ex) {
[10:59:31.359]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.359]                 ...future.rng), started = ...future.startTime, 
[10:59:31.359]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.359]             version = "1.8"), class = "FutureResult")
[10:59:31.359]     }, finally = {
[10:59:31.359]         if (!identical(...future.workdir, getwd())) 
[10:59:31.359]             setwd(...future.workdir)
[10:59:31.359]         {
[10:59:31.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.359]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.359]             }
[10:59:31.359]             base::options(...future.oldOptions)
[10:59:31.359]             if (.Platform$OS.type == "windows") {
[10:59:31.359]                 old_names <- names(...future.oldEnvVars)
[10:59:31.359]                 envs <- base::Sys.getenv()
[10:59:31.359]                 names <- names(envs)
[10:59:31.359]                 common <- intersect(names, old_names)
[10:59:31.359]                 added <- setdiff(names, old_names)
[10:59:31.359]                 removed <- setdiff(old_names, names)
[10:59:31.359]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.359]                   envs[common]]
[10:59:31.359]                 NAMES <- toupper(changed)
[10:59:31.359]                 args <- list()
[10:59:31.359]                 for (kk in seq_along(NAMES)) {
[10:59:31.359]                   name <- changed[[kk]]
[10:59:31.359]                   NAME <- NAMES[[kk]]
[10:59:31.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.359]                     next
[10:59:31.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.359]                 }
[10:59:31.359]                 NAMES <- toupper(added)
[10:59:31.359]                 for (kk in seq_along(NAMES)) {
[10:59:31.359]                   name <- added[[kk]]
[10:59:31.359]                   NAME <- NAMES[[kk]]
[10:59:31.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.359]                     next
[10:59:31.359]                   args[[name]] <- ""
[10:59:31.359]                 }
[10:59:31.359]                 NAMES <- toupper(removed)
[10:59:31.359]                 for (kk in seq_along(NAMES)) {
[10:59:31.359]                   name <- removed[[kk]]
[10:59:31.359]                   NAME <- NAMES[[kk]]
[10:59:31.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.359]                     next
[10:59:31.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.359]                 }
[10:59:31.359]                 if (length(args) > 0) 
[10:59:31.359]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.359]             }
[10:59:31.359]             else {
[10:59:31.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.359]             }
[10:59:31.359]             {
[10:59:31.359]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.359]                   0L) {
[10:59:31.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.359]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.359]                   base::options(opts)
[10:59:31.359]                 }
[10:59:31.359]                 {
[10:59:31.359]                   {
[10:59:31.359]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.359]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.359]                     1047550554L), envir = base::globalenv(), 
[10:59:31.359]                       inherits = FALSE)
[10:59:31.359]                     NULL
[10:59:31.359]                   }
[10:59:31.359]                   options(future.plan = NULL)
[10:59:31.359]                   if (is.na(NA_character_)) 
[10:59:31.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.359]                     .init = FALSE)
[10:59:31.359]                 }
[10:59:31.359]             }
[10:59:31.359]         }
[10:59:31.359]     })
[10:59:31.359]     if (TRUE) {
[10:59:31.359]         base::sink(type = "output", split = FALSE)
[10:59:31.359]         if (TRUE) {
[10:59:31.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.359]         }
[10:59:31.359]         else {
[10:59:31.359]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.359]         }
[10:59:31.359]         base::close(...future.stdout)
[10:59:31.359]         ...future.stdout <- NULL
[10:59:31.359]     }
[10:59:31.359]     ...future.result$conditions <- ...future.conditions
[10:59:31.359]     ...future.result$finished <- base::Sys.time()
[10:59:31.359]     ...future.result
[10:59:31.359] }
[10:59:31.360] assign_globals() ...
[10:59:31.360] List of 5
[10:59:31.360]  $ ...future.FUN            :function (C, k)  
[10:59:31.360]  $ MoreArgs                 : list()
[10:59:31.360]  $ ...future.elements_ii    :List of 2
[10:59:31.360]   ..$ :List of 5
[10:59:31.360]   .. ..$ : chr "A"
[10:59:31.360]   .. ..$ : chr "B"
[10:59:31.360]   .. ..$ : chr "C"
[10:59:31.360]   .. ..$ : chr "D"
[10:59:31.360]   .. ..$ : chr "E"
[10:59:31.360]   ..$ :List of 5
[10:59:31.360]   .. ..$ : int 5
[10:59:31.360]   .. ..$ : int 4
[10:59:31.360]   .. ..$ : int 3
[10:59:31.360]   .. ..$ : int 2
[10:59:31.360]   .. ..$ : int 1
[10:59:31.360]  $ ...future.seeds_ii       : NULL
[10:59:31.360]  $ ...future.globals.maxSize: NULL
[10:59:31.360]  - attr(*, "where")=List of 5
[10:59:31.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.360]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.360]  - attr(*, "resolved")= logi FALSE
[10:59:31.360]  - attr(*, "total_size")= num 967
[10:59:31.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.360]  - attr(*, "already-done")= logi TRUE
[10:59:31.368] - reassign environment for ‘...future.FUN’
[10:59:31.368] - copied ‘...future.FUN’ to environment
[10:59:31.368] - copied ‘MoreArgs’ to environment
[10:59:31.368] - copied ‘...future.elements_ii’ to environment
[10:59:31.368] - copied ‘...future.seeds_ii’ to environment
[10:59:31.368] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.368] assign_globals() ... done
[10:59:31.368] plan(): Setting new future strategy stack:
[10:59:31.368] List of future strategies:
[10:59:31.368] 1. sequential:
[10:59:31.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.368]    - tweaked: FALSE
[10:59:31.368]    - call: NULL
[10:59:31.369] plan(): nbrOfWorkers() = 1
[10:59:31.369] plan(): Setting new future strategy stack:
[10:59:31.370] List of future strategies:
[10:59:31.370] 1. sequential:
[10:59:31.370]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.370]    - tweaked: FALSE
[10:59:31.370]    - call: plan(strategy)
[10:59:31.370] plan(): nbrOfWorkers() = 1
[10:59:31.370] SequentialFuture started (and completed)
[10:59:31.370] - Launch lazy future ... done
[10:59:31.370] run() for ‘SequentialFuture’ ... done
[10:59:31.370] Created future:
[10:59:31.370] SequentialFuture:
[10:59:31.370] Label: ‘future_.mapply-1’
[10:59:31.370] Expression:
[10:59:31.370] {
[10:59:31.370]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.370]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.370]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.370]         on.exit(options(oopts), add = TRUE)
[10:59:31.370]     }
[10:59:31.370]     {
[10:59:31.370]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.370]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.370]         do.call(mapply, args = args)
[10:59:31.370]     }
[10:59:31.370] }
[10:59:31.370] Lazy evaluation: FALSE
[10:59:31.370] Asynchronous evaluation: FALSE
[10:59:31.370] Local evaluation: TRUE
[10:59:31.370] Environment: R_GlobalEnv
[10:59:31.370] Capture standard output: TRUE
[10:59:31.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.370] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.370] Packages: <none>
[10:59:31.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.370] Resolved: TRUE
[10:59:31.370] Value: 126 bytes of class ‘list’
[10:59:31.370] Early signaling: FALSE
[10:59:31.370] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.370] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.371] Chunk #1 of 1 ... DONE
[10:59:31.371] Launching 1 futures (chunks) ... DONE
[10:59:31.371] Resolving 1 futures (chunks) ...
[10:59:31.371] resolve() on list ...
[10:59:31.372]  recursive: 0
[10:59:31.372]  length: 1
[10:59:31.372] 
[10:59:31.372] resolved() for ‘SequentialFuture’ ...
[10:59:31.372] - state: ‘finished’
[10:59:31.372] - run: TRUE
[10:59:31.372] - result: ‘FutureResult’
[10:59:31.372] resolved() for ‘SequentialFuture’ ... done
[10:59:31.372] Future #1
[10:59:31.372] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.372] - nx: 1
[10:59:31.372] - relay: TRUE
[10:59:31.373] - stdout: TRUE
[10:59:31.373] - signal: TRUE
[10:59:31.373] - resignal: FALSE
[10:59:31.373] - force: TRUE
[10:59:31.373] - relayed: [n=1] FALSE
[10:59:31.373] - queued futures: [n=1] FALSE
[10:59:31.373]  - until=1
[10:59:31.373]  - relaying element #1
[10:59:31.373] - relayed: [n=1] TRUE
[10:59:31.373] - queued futures: [n=1] TRUE
[10:59:31.373] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.373]  length: 0 (resolved future 1)
[10:59:31.374] Relaying remaining futures
[10:59:31.374] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.374] - nx: 1
[10:59:31.374] - relay: TRUE
[10:59:31.374] - stdout: TRUE
[10:59:31.374] - signal: TRUE
[10:59:31.374] - resignal: FALSE
[10:59:31.374] - force: TRUE
[10:59:31.374] - relayed: [n=1] TRUE
[10:59:31.374] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.374] - relayed: [n=1] TRUE
[10:59:31.374] - queued futures: [n=1] TRUE
[10:59:31.374] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.375] resolve() on list ... DONE
[10:59:31.375]  - Number of value chunks collected: 1
[10:59:31.375] Resolving 1 futures (chunks) ... DONE
[10:59:31.375] Reducing values from 1 chunks ...
[10:59:31.375]  - Number of values collected after concatenation: 5
[10:59:31.375]  - Number of values expected: 5
[10:59:31.375] Reducing values from 1 chunks ... DONE
[10:59:31.375] future_mapply() ... DONE
[10:59:31.375] future_mapply() ...
[10:59:31.376] Number of chunks: 2
[10:59:31.376] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:59:31.376] getGlobalsAndPackagesXApply() ...
[10:59:31.376]  - future.globals: TRUE
[10:59:31.376] getGlobalsAndPackages() ...
[10:59:31.376] Searching for globals...
[10:59:31.377] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:31.377] Searching for globals ... DONE
[10:59:31.377] Resolving globals: FALSE
[10:59:31.378] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:31.378] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:31.378] - globals: [1] ‘FUN’
[10:59:31.378] 
[10:59:31.378] getGlobalsAndPackages() ... DONE
[10:59:31.378]  - globals found/used: [n=1] ‘FUN’
[10:59:31.378]  - needed namespaces: [n=0] 
[10:59:31.378] Finding globals ... DONE
[10:59:31.379] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.379] List of 2
[10:59:31.379]  $ ...future.FUN:function (C, k)  
[10:59:31.379]  $ MoreArgs     : NULL
[10:59:31.379]  - attr(*, "where")=List of 2
[10:59:31.379]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.379]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.379]  - attr(*, "resolved")= logi FALSE
[10:59:31.379]  - attr(*, "total_size")= num NA
[10:59:31.381] Packages to be attached in all futures: [n=0] 
[10:59:31.381] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.381] Number of futures (= number of chunks): 2
[10:59:31.381] Launching 2 futures (chunks) ...
[10:59:31.381] Chunk #1 of 2 ...
[10:59:31.381]  - Finding globals in '...' for chunk #1 ...
[10:59:31.382] getGlobalsAndPackages() ...
[10:59:31.382] Searching for globals...
[10:59:31.382] 
[10:59:31.382] Searching for globals ... DONE
[10:59:31.382] - globals: [0] <none>
[10:59:31.382] getGlobalsAndPackages() ... DONE
[10:59:31.382]    + additional globals found: [n=0] 
[10:59:31.382]    + additional namespaces needed: [n=0] 
[10:59:31.382]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.382]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.383]  - seeds: <none>
[10:59:31.383]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.383] getGlobalsAndPackages() ...
[10:59:31.383] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.383] Resolving globals: FALSE
[10:59:31.383] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:31.384] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.384] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.384] 
[10:59:31.384] getGlobalsAndPackages() ... DONE
[10:59:31.384] run() for ‘Future’ ...
[10:59:31.384] - state: ‘created’
[10:59:31.384] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.385] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.385]   - Field: ‘label’
[10:59:31.385]   - Field: ‘local’
[10:59:31.385]   - Field: ‘owner’
[10:59:31.385]   - Field: ‘envir’
[10:59:31.385]   - Field: ‘packages’
[10:59:31.385]   - Field: ‘gc’
[10:59:31.386]   - Field: ‘conditions’
[10:59:31.386]   - Field: ‘expr’
[10:59:31.386]   - Field: ‘uuid’
[10:59:31.386]   - Field: ‘seed’
[10:59:31.386]   - Field: ‘version’
[10:59:31.386]   - Field: ‘result’
[10:59:31.386]   - Field: ‘asynchronous’
[10:59:31.387]   - Field: ‘calls’
[10:59:31.387]   - Field: ‘globals’
[10:59:31.387]   - Field: ‘stdout’
[10:59:31.387]   - Field: ‘earlySignal’
[10:59:31.387]   - Field: ‘lazy’
[10:59:31.387]   - Field: ‘state’
[10:59:31.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.387] - Launch lazy future ...
[10:59:31.387] Packages needed by the future expression (n = 0): <none>
[10:59:31.387] Packages needed by future strategies (n = 0): <none>
[10:59:31.388] {
[10:59:31.388]     {
[10:59:31.388]         {
[10:59:31.388]             ...future.startTime <- base::Sys.time()
[10:59:31.388]             {
[10:59:31.388]                 {
[10:59:31.388]                   {
[10:59:31.388]                     base::local({
[10:59:31.388]                       has_future <- base::requireNamespace("future", 
[10:59:31.388]                         quietly = TRUE)
[10:59:31.388]                       if (has_future) {
[10:59:31.388]                         ns <- base::getNamespace("future")
[10:59:31.388]                         version <- ns[[".package"]][["version"]]
[10:59:31.388]                         if (is.null(version)) 
[10:59:31.388]                           version <- utils::packageVersion("future")
[10:59:31.388]                       }
[10:59:31.388]                       else {
[10:59:31.388]                         version <- NULL
[10:59:31.388]                       }
[10:59:31.388]                       if (!has_future || version < "1.8.0") {
[10:59:31.388]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.388]                           "", base::R.version$version.string), 
[10:59:31.388]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.388]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.388]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.388]                             "release", "version")], collapse = " "), 
[10:59:31.388]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.388]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.388]                           info)
[10:59:31.388]                         info <- base::paste(info, collapse = "; ")
[10:59:31.388]                         if (!has_future) {
[10:59:31.388]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.388]                             info)
[10:59:31.388]                         }
[10:59:31.388]                         else {
[10:59:31.388]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.388]                             info, version)
[10:59:31.388]                         }
[10:59:31.388]                         base::stop(msg)
[10:59:31.388]                       }
[10:59:31.388]                     })
[10:59:31.388]                   }
[10:59:31.388]                   ...future.strategy.old <- future::plan("list")
[10:59:31.388]                   options(future.plan = NULL)
[10:59:31.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.388]                 }
[10:59:31.388]                 ...future.workdir <- getwd()
[10:59:31.388]             }
[10:59:31.388]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.388]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.388]         }
[10:59:31.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.388]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.388]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.388]             base::names(...future.oldOptions))
[10:59:31.388]     }
[10:59:31.388]     if (FALSE) {
[10:59:31.388]     }
[10:59:31.388]     else {
[10:59:31.388]         if (TRUE) {
[10:59:31.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.388]                 open = "w")
[10:59:31.388]         }
[10:59:31.388]         else {
[10:59:31.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.388]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.388]         }
[10:59:31.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.388]             base::sink(type = "output", split = FALSE)
[10:59:31.388]             base::close(...future.stdout)
[10:59:31.388]         }, add = TRUE)
[10:59:31.388]     }
[10:59:31.388]     ...future.frame <- base::sys.nframe()
[10:59:31.388]     ...future.conditions <- base::list()
[10:59:31.388]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.388]     if (FALSE) {
[10:59:31.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.388]     }
[10:59:31.388]     ...future.result <- base::tryCatch({
[10:59:31.388]         base::withCallingHandlers({
[10:59:31.388]             ...future.value <- base::withVisible(base::local({
[10:59:31.388]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.388]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.388]                   ...future.globals.maxSize)) {
[10:59:31.388]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.388]                   on.exit(options(oopts), add = TRUE)
[10:59:31.388]                 }
[10:59:31.388]                 {
[10:59:31.388]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.388]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.388]                     USE.NAMES = FALSE)
[10:59:31.388]                   do.call(mapply, args = args)
[10:59:31.388]                 }
[10:59:31.388]             }))
[10:59:31.388]             future::FutureResult(value = ...future.value$value, 
[10:59:31.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.388]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.388]                     ...future.globalenv.names))
[10:59:31.388]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.388]         }, condition = base::local({
[10:59:31.388]             c <- base::c
[10:59:31.388]             inherits <- base::inherits
[10:59:31.388]             invokeRestart <- base::invokeRestart
[10:59:31.388]             length <- base::length
[10:59:31.388]             list <- base::list
[10:59:31.388]             seq.int <- base::seq.int
[10:59:31.388]             signalCondition <- base::signalCondition
[10:59:31.388]             sys.calls <- base::sys.calls
[10:59:31.388]             `[[` <- base::`[[`
[10:59:31.388]             `+` <- base::`+`
[10:59:31.388]             `<<-` <- base::`<<-`
[10:59:31.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.388]                   3L)]
[10:59:31.388]             }
[10:59:31.388]             function(cond) {
[10:59:31.388]                 is_error <- inherits(cond, "error")
[10:59:31.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.388]                   NULL)
[10:59:31.388]                 if (is_error) {
[10:59:31.388]                   sessionInformation <- function() {
[10:59:31.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.388]                       search = base::search(), system = base::Sys.info())
[10:59:31.388]                   }
[10:59:31.388]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.388]                     cond$call), session = sessionInformation(), 
[10:59:31.388]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.388]                   signalCondition(cond)
[10:59:31.388]                 }
[10:59:31.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.388]                 "immediateCondition"))) {
[10:59:31.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.388]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.388]                   if (TRUE && !signal) {
[10:59:31.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.388]                     {
[10:59:31.388]                       inherits <- base::inherits
[10:59:31.388]                       invokeRestart <- base::invokeRestart
[10:59:31.388]                       is.null <- base::is.null
[10:59:31.388]                       muffled <- FALSE
[10:59:31.388]                       if (inherits(cond, "message")) {
[10:59:31.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.388]                         if (muffled) 
[10:59:31.388]                           invokeRestart("muffleMessage")
[10:59:31.388]                       }
[10:59:31.388]                       else if (inherits(cond, "warning")) {
[10:59:31.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.388]                         if (muffled) 
[10:59:31.388]                           invokeRestart("muffleWarning")
[10:59:31.388]                       }
[10:59:31.388]                       else if (inherits(cond, "condition")) {
[10:59:31.388]                         if (!is.null(pattern)) {
[10:59:31.388]                           computeRestarts <- base::computeRestarts
[10:59:31.388]                           grepl <- base::grepl
[10:59:31.388]                           restarts <- computeRestarts(cond)
[10:59:31.388]                           for (restart in restarts) {
[10:59:31.388]                             name <- restart$name
[10:59:31.388]                             if (is.null(name)) 
[10:59:31.388]                               next
[10:59:31.388]                             if (!grepl(pattern, name)) 
[10:59:31.388]                               next
[10:59:31.388]                             invokeRestart(restart)
[10:59:31.388]                             muffled <- TRUE
[10:59:31.388]                             break
[10:59:31.388]                           }
[10:59:31.388]                         }
[10:59:31.388]                       }
[10:59:31.388]                       invisible(muffled)
[10:59:31.388]                     }
[10:59:31.388]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.388]                   }
[10:59:31.388]                 }
[10:59:31.388]                 else {
[10:59:31.388]                   if (TRUE) {
[10:59:31.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.388]                     {
[10:59:31.388]                       inherits <- base::inherits
[10:59:31.388]                       invokeRestart <- base::invokeRestart
[10:59:31.388]                       is.null <- base::is.null
[10:59:31.388]                       muffled <- FALSE
[10:59:31.388]                       if (inherits(cond, "message")) {
[10:59:31.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.388]                         if (muffled) 
[10:59:31.388]                           invokeRestart("muffleMessage")
[10:59:31.388]                       }
[10:59:31.388]                       else if (inherits(cond, "warning")) {
[10:59:31.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.388]                         if (muffled) 
[10:59:31.388]                           invokeRestart("muffleWarning")
[10:59:31.388]                       }
[10:59:31.388]                       else if (inherits(cond, "condition")) {
[10:59:31.388]                         if (!is.null(pattern)) {
[10:59:31.388]                           computeRestarts <- base::computeRestarts
[10:59:31.388]                           grepl <- base::grepl
[10:59:31.388]                           restarts <- computeRestarts(cond)
[10:59:31.388]                           for (restart in restarts) {
[10:59:31.388]                             name <- restart$name
[10:59:31.388]                             if (is.null(name)) 
[10:59:31.388]                               next
[10:59:31.388]                             if (!grepl(pattern, name)) 
[10:59:31.388]                               next
[10:59:31.388]                             invokeRestart(restart)
[10:59:31.388]                             muffled <- TRUE
[10:59:31.388]                             break
[10:59:31.388]                           }
[10:59:31.388]                         }
[10:59:31.388]                       }
[10:59:31.388]                       invisible(muffled)
[10:59:31.388]                     }
[10:59:31.388]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.388]                   }
[10:59:31.388]                 }
[10:59:31.388]             }
[10:59:31.388]         }))
[10:59:31.388]     }, error = function(ex) {
[10:59:31.388]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.388]                 ...future.rng), started = ...future.startTime, 
[10:59:31.388]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.388]             version = "1.8"), class = "FutureResult")
[10:59:31.388]     }, finally = {
[10:59:31.388]         if (!identical(...future.workdir, getwd())) 
[10:59:31.388]             setwd(...future.workdir)
[10:59:31.388]         {
[10:59:31.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.388]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.388]             }
[10:59:31.388]             base::options(...future.oldOptions)
[10:59:31.388]             if (.Platform$OS.type == "windows") {
[10:59:31.388]                 old_names <- names(...future.oldEnvVars)
[10:59:31.388]                 envs <- base::Sys.getenv()
[10:59:31.388]                 names <- names(envs)
[10:59:31.388]                 common <- intersect(names, old_names)
[10:59:31.388]                 added <- setdiff(names, old_names)
[10:59:31.388]                 removed <- setdiff(old_names, names)
[10:59:31.388]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.388]                   envs[common]]
[10:59:31.388]                 NAMES <- toupper(changed)
[10:59:31.388]                 args <- list()
[10:59:31.388]                 for (kk in seq_along(NAMES)) {
[10:59:31.388]                   name <- changed[[kk]]
[10:59:31.388]                   NAME <- NAMES[[kk]]
[10:59:31.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.388]                     next
[10:59:31.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.388]                 }
[10:59:31.388]                 NAMES <- toupper(added)
[10:59:31.388]                 for (kk in seq_along(NAMES)) {
[10:59:31.388]                   name <- added[[kk]]
[10:59:31.388]                   NAME <- NAMES[[kk]]
[10:59:31.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.388]                     next
[10:59:31.388]                   args[[name]] <- ""
[10:59:31.388]                 }
[10:59:31.388]                 NAMES <- toupper(removed)
[10:59:31.388]                 for (kk in seq_along(NAMES)) {
[10:59:31.388]                   name <- removed[[kk]]
[10:59:31.388]                   NAME <- NAMES[[kk]]
[10:59:31.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.388]                     next
[10:59:31.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.388]                 }
[10:59:31.388]                 if (length(args) > 0) 
[10:59:31.388]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.388]             }
[10:59:31.388]             else {
[10:59:31.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.388]             }
[10:59:31.388]             {
[10:59:31.388]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.388]                   0L) {
[10:59:31.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.388]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.388]                   base::options(opts)
[10:59:31.388]                 }
[10:59:31.388]                 {
[10:59:31.388]                   {
[10:59:31.388]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.388]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.388]                     1047550554L), envir = base::globalenv(), 
[10:59:31.388]                       inherits = FALSE)
[10:59:31.388]                     NULL
[10:59:31.388]                   }
[10:59:31.388]                   options(future.plan = NULL)
[10:59:31.388]                   if (is.na(NA_character_)) 
[10:59:31.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.388]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.388]                     .init = FALSE)
[10:59:31.388]                 }
[10:59:31.388]             }
[10:59:31.388]         }
[10:59:31.388]     })
[10:59:31.388]     if (TRUE) {
[10:59:31.388]         base::sink(type = "output", split = FALSE)
[10:59:31.388]         if (TRUE) {
[10:59:31.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.388]         }
[10:59:31.388]         else {
[10:59:31.388]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.388]         }
[10:59:31.388]         base::close(...future.stdout)
[10:59:31.388]         ...future.stdout <- NULL
[10:59:31.388]     }
[10:59:31.388]     ...future.result$conditions <- ...future.conditions
[10:59:31.388]     ...future.result$finished <- base::Sys.time()
[10:59:31.388]     ...future.result
[10:59:31.388] }
[10:59:31.389] assign_globals() ...
[10:59:31.390] List of 5
[10:59:31.390]  $ ...future.FUN            :function (C, k)  
[10:59:31.390]  $ MoreArgs                 : NULL
[10:59:31.390]  $ ...future.elements_ii    :List of 2
[10:59:31.390]   ..$ :List of 2
[10:59:31.390]   .. ..$ : chr "E"
[10:59:31.390]   .. ..$ : chr "D"
[10:59:31.390]   ..$ :List of 2
[10:59:31.390]   .. ..$ : int 1
[10:59:31.390]   .. ..$ : int 2
[10:59:31.390]  $ ...future.seeds_ii       : NULL
[10:59:31.390]  $ ...future.globals.maxSize: NULL
[10:59:31.390]  - attr(*, "where")=List of 5
[10:59:31.390]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.390]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.390]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.390]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.390]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.390]  - attr(*, "resolved")= logi FALSE
[10:59:31.390]  - attr(*, "total_size")= num 876
[10:59:31.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.390]  - attr(*, "already-done")= logi TRUE
[10:59:31.394] - reassign environment for ‘...future.FUN’
[10:59:31.395] - copied ‘...future.FUN’ to environment
[10:59:31.395] - copied ‘MoreArgs’ to environment
[10:59:31.395] - copied ‘...future.elements_ii’ to environment
[10:59:31.395] - copied ‘...future.seeds_ii’ to environment
[10:59:31.395] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.395] assign_globals() ... done
[10:59:31.395] plan(): Setting new future strategy stack:
[10:59:31.395] List of future strategies:
[10:59:31.395] 1. sequential:
[10:59:31.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.395]    - tweaked: FALSE
[10:59:31.395]    - call: NULL
[10:59:31.396] plan(): nbrOfWorkers() = 1
[10:59:31.396] plan(): Setting new future strategy stack:
[10:59:31.396] List of future strategies:
[10:59:31.396] 1. sequential:
[10:59:31.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.396]    - tweaked: FALSE
[10:59:31.396]    - call: plan(strategy)
[10:59:31.397] plan(): nbrOfWorkers() = 1
[10:59:31.397] SequentialFuture started (and completed)
[10:59:31.397] - Launch lazy future ... done
[10:59:31.397] run() for ‘SequentialFuture’ ... done
[10:59:31.397] Created future:
[10:59:31.397] SequentialFuture:
[10:59:31.397] Label: ‘future_mapply-1’
[10:59:31.397] Expression:
[10:59:31.397] {
[10:59:31.397]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.397]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.397]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.397]         on.exit(options(oopts), add = TRUE)
[10:59:31.397]     }
[10:59:31.397]     {
[10:59:31.397]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.397]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.397]         do.call(mapply, args = args)
[10:59:31.397]     }
[10:59:31.397] }
[10:59:31.397] Lazy evaluation: FALSE
[10:59:31.397] Asynchronous evaluation: FALSE
[10:59:31.397] Local evaluation: TRUE
[10:59:31.397] Environment: R_GlobalEnv
[10:59:31.397] Capture standard output: TRUE
[10:59:31.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.397] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.397] Packages: <none>
[10:59:31.397] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.397] Resolved: TRUE
[10:59:31.397] Value: 66 bytes of class ‘list’
[10:59:31.397] Early signaling: FALSE
[10:59:31.397] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.397] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.398] Chunk #1 of 2 ... DONE
[10:59:31.398] Chunk #2 of 2 ...
[10:59:31.398]  - Finding globals in '...' for chunk #2 ...
[10:59:31.398] getGlobalsAndPackages() ...
[10:59:31.398] Searching for globals...
[10:59:31.399] 
[10:59:31.399] Searching for globals ... DONE
[10:59:31.399] - globals: [0] <none>
[10:59:31.399] getGlobalsAndPackages() ... DONE
[10:59:31.399]    + additional globals found: [n=0] 
[10:59:31.399]    + additional namespaces needed: [n=0] 
[10:59:31.399]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:31.399]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.399]  - seeds: <none>
[10:59:31.399]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.399] getGlobalsAndPackages() ...
[10:59:31.400] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.400] Resolving globals: FALSE
[10:59:31.400] The total size of the 5 globals is 905 bytes (905 bytes)
[10:59:31.400] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.401] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.401] 
[10:59:31.401] getGlobalsAndPackages() ... DONE
[10:59:31.401] run() for ‘Future’ ...
[10:59:31.401] - state: ‘created’
[10:59:31.401] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.401] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.401] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.402]   - Field: ‘label’
[10:59:31.402]   - Field: ‘local’
[10:59:31.402]   - Field: ‘owner’
[10:59:31.402]   - Field: ‘envir’
[10:59:31.402]   - Field: ‘packages’
[10:59:31.402]   - Field: ‘gc’
[10:59:31.402]   - Field: ‘conditions’
[10:59:31.402]   - Field: ‘expr’
[10:59:31.402]   - Field: ‘uuid’
[10:59:31.402]   - Field: ‘seed’
[10:59:31.402]   - Field: ‘version’
[10:59:31.402]   - Field: ‘result’
[10:59:31.402]   - Field: ‘asynchronous’
[10:59:31.403]   - Field: ‘calls’
[10:59:31.403]   - Field: ‘globals’
[10:59:31.403]   - Field: ‘stdout’
[10:59:31.403]   - Field: ‘earlySignal’
[10:59:31.403]   - Field: ‘lazy’
[10:59:31.403]   - Field: ‘state’
[10:59:31.403] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.403] - Launch lazy future ...
[10:59:31.403] Packages needed by the future expression (n = 0): <none>
[10:59:31.403] Packages needed by future strategies (n = 0): <none>
[10:59:31.404] {
[10:59:31.404]     {
[10:59:31.404]         {
[10:59:31.404]             ...future.startTime <- base::Sys.time()
[10:59:31.404]             {
[10:59:31.404]                 {
[10:59:31.404]                   {
[10:59:31.404]                     base::local({
[10:59:31.404]                       has_future <- base::requireNamespace("future", 
[10:59:31.404]                         quietly = TRUE)
[10:59:31.404]                       if (has_future) {
[10:59:31.404]                         ns <- base::getNamespace("future")
[10:59:31.404]                         version <- ns[[".package"]][["version"]]
[10:59:31.404]                         if (is.null(version)) 
[10:59:31.404]                           version <- utils::packageVersion("future")
[10:59:31.404]                       }
[10:59:31.404]                       else {
[10:59:31.404]                         version <- NULL
[10:59:31.404]                       }
[10:59:31.404]                       if (!has_future || version < "1.8.0") {
[10:59:31.404]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.404]                           "", base::R.version$version.string), 
[10:59:31.404]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.404]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.404]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.404]                             "release", "version")], collapse = " "), 
[10:59:31.404]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.404]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.404]                           info)
[10:59:31.404]                         info <- base::paste(info, collapse = "; ")
[10:59:31.404]                         if (!has_future) {
[10:59:31.404]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.404]                             info)
[10:59:31.404]                         }
[10:59:31.404]                         else {
[10:59:31.404]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.404]                             info, version)
[10:59:31.404]                         }
[10:59:31.404]                         base::stop(msg)
[10:59:31.404]                       }
[10:59:31.404]                     })
[10:59:31.404]                   }
[10:59:31.404]                   ...future.strategy.old <- future::plan("list")
[10:59:31.404]                   options(future.plan = NULL)
[10:59:31.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.404]                 }
[10:59:31.404]                 ...future.workdir <- getwd()
[10:59:31.404]             }
[10:59:31.404]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.404]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.404]         }
[10:59:31.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.404]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.404]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.404]             base::names(...future.oldOptions))
[10:59:31.404]     }
[10:59:31.404]     if (FALSE) {
[10:59:31.404]     }
[10:59:31.404]     else {
[10:59:31.404]         if (TRUE) {
[10:59:31.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.404]                 open = "w")
[10:59:31.404]         }
[10:59:31.404]         else {
[10:59:31.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.404]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.404]         }
[10:59:31.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.404]             base::sink(type = "output", split = FALSE)
[10:59:31.404]             base::close(...future.stdout)
[10:59:31.404]         }, add = TRUE)
[10:59:31.404]     }
[10:59:31.404]     ...future.frame <- base::sys.nframe()
[10:59:31.404]     ...future.conditions <- base::list()
[10:59:31.404]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.404]     if (FALSE) {
[10:59:31.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.404]     }
[10:59:31.404]     ...future.result <- base::tryCatch({
[10:59:31.404]         base::withCallingHandlers({
[10:59:31.404]             ...future.value <- base::withVisible(base::local({
[10:59:31.404]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.404]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.404]                   ...future.globals.maxSize)) {
[10:59:31.404]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.404]                   on.exit(options(oopts), add = TRUE)
[10:59:31.404]                 }
[10:59:31.404]                 {
[10:59:31.404]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.404]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.404]                     USE.NAMES = FALSE)
[10:59:31.404]                   do.call(mapply, args = args)
[10:59:31.404]                 }
[10:59:31.404]             }))
[10:59:31.404]             future::FutureResult(value = ...future.value$value, 
[10:59:31.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.404]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.404]                     ...future.globalenv.names))
[10:59:31.404]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.404]         }, condition = base::local({
[10:59:31.404]             c <- base::c
[10:59:31.404]             inherits <- base::inherits
[10:59:31.404]             invokeRestart <- base::invokeRestart
[10:59:31.404]             length <- base::length
[10:59:31.404]             list <- base::list
[10:59:31.404]             seq.int <- base::seq.int
[10:59:31.404]             signalCondition <- base::signalCondition
[10:59:31.404]             sys.calls <- base::sys.calls
[10:59:31.404]             `[[` <- base::`[[`
[10:59:31.404]             `+` <- base::`+`
[10:59:31.404]             `<<-` <- base::`<<-`
[10:59:31.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.404]                   3L)]
[10:59:31.404]             }
[10:59:31.404]             function(cond) {
[10:59:31.404]                 is_error <- inherits(cond, "error")
[10:59:31.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.404]                   NULL)
[10:59:31.404]                 if (is_error) {
[10:59:31.404]                   sessionInformation <- function() {
[10:59:31.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.404]                       search = base::search(), system = base::Sys.info())
[10:59:31.404]                   }
[10:59:31.404]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.404]                     cond$call), session = sessionInformation(), 
[10:59:31.404]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.404]                   signalCondition(cond)
[10:59:31.404]                 }
[10:59:31.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.404]                 "immediateCondition"))) {
[10:59:31.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.404]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.404]                   if (TRUE && !signal) {
[10:59:31.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.404]                     {
[10:59:31.404]                       inherits <- base::inherits
[10:59:31.404]                       invokeRestart <- base::invokeRestart
[10:59:31.404]                       is.null <- base::is.null
[10:59:31.404]                       muffled <- FALSE
[10:59:31.404]                       if (inherits(cond, "message")) {
[10:59:31.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.404]                         if (muffled) 
[10:59:31.404]                           invokeRestart("muffleMessage")
[10:59:31.404]                       }
[10:59:31.404]                       else if (inherits(cond, "warning")) {
[10:59:31.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.404]                         if (muffled) 
[10:59:31.404]                           invokeRestart("muffleWarning")
[10:59:31.404]                       }
[10:59:31.404]                       else if (inherits(cond, "condition")) {
[10:59:31.404]                         if (!is.null(pattern)) {
[10:59:31.404]                           computeRestarts <- base::computeRestarts
[10:59:31.404]                           grepl <- base::grepl
[10:59:31.404]                           restarts <- computeRestarts(cond)
[10:59:31.404]                           for (restart in restarts) {
[10:59:31.404]                             name <- restart$name
[10:59:31.404]                             if (is.null(name)) 
[10:59:31.404]                               next
[10:59:31.404]                             if (!grepl(pattern, name)) 
[10:59:31.404]                               next
[10:59:31.404]                             invokeRestart(restart)
[10:59:31.404]                             muffled <- TRUE
[10:59:31.404]                             break
[10:59:31.404]                           }
[10:59:31.404]                         }
[10:59:31.404]                       }
[10:59:31.404]                       invisible(muffled)
[10:59:31.404]                     }
[10:59:31.404]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.404]                   }
[10:59:31.404]                 }
[10:59:31.404]                 else {
[10:59:31.404]                   if (TRUE) {
[10:59:31.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.404]                     {
[10:59:31.404]                       inherits <- base::inherits
[10:59:31.404]                       invokeRestart <- base::invokeRestart
[10:59:31.404]                       is.null <- base::is.null
[10:59:31.404]                       muffled <- FALSE
[10:59:31.404]                       if (inherits(cond, "message")) {
[10:59:31.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.404]                         if (muffled) 
[10:59:31.404]                           invokeRestart("muffleMessage")
[10:59:31.404]                       }
[10:59:31.404]                       else if (inherits(cond, "warning")) {
[10:59:31.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.404]                         if (muffled) 
[10:59:31.404]                           invokeRestart("muffleWarning")
[10:59:31.404]                       }
[10:59:31.404]                       else if (inherits(cond, "condition")) {
[10:59:31.404]                         if (!is.null(pattern)) {
[10:59:31.404]                           computeRestarts <- base::computeRestarts
[10:59:31.404]                           grepl <- base::grepl
[10:59:31.404]                           restarts <- computeRestarts(cond)
[10:59:31.404]                           for (restart in restarts) {
[10:59:31.404]                             name <- restart$name
[10:59:31.404]                             if (is.null(name)) 
[10:59:31.404]                               next
[10:59:31.404]                             if (!grepl(pattern, name)) 
[10:59:31.404]                               next
[10:59:31.404]                             invokeRestart(restart)
[10:59:31.404]                             muffled <- TRUE
[10:59:31.404]                             break
[10:59:31.404]                           }
[10:59:31.404]                         }
[10:59:31.404]                       }
[10:59:31.404]                       invisible(muffled)
[10:59:31.404]                     }
[10:59:31.404]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.404]                   }
[10:59:31.404]                 }
[10:59:31.404]             }
[10:59:31.404]         }))
[10:59:31.404]     }, error = function(ex) {
[10:59:31.404]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.404]                 ...future.rng), started = ...future.startTime, 
[10:59:31.404]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.404]             version = "1.8"), class = "FutureResult")
[10:59:31.404]     }, finally = {
[10:59:31.404]         if (!identical(...future.workdir, getwd())) 
[10:59:31.404]             setwd(...future.workdir)
[10:59:31.404]         {
[10:59:31.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.404]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.404]             }
[10:59:31.404]             base::options(...future.oldOptions)
[10:59:31.404]             if (.Platform$OS.type == "windows") {
[10:59:31.404]                 old_names <- names(...future.oldEnvVars)
[10:59:31.404]                 envs <- base::Sys.getenv()
[10:59:31.404]                 names <- names(envs)
[10:59:31.404]                 common <- intersect(names, old_names)
[10:59:31.404]                 added <- setdiff(names, old_names)
[10:59:31.404]                 removed <- setdiff(old_names, names)
[10:59:31.404]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.404]                   envs[common]]
[10:59:31.404]                 NAMES <- toupper(changed)
[10:59:31.404]                 args <- list()
[10:59:31.404]                 for (kk in seq_along(NAMES)) {
[10:59:31.404]                   name <- changed[[kk]]
[10:59:31.404]                   NAME <- NAMES[[kk]]
[10:59:31.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.404]                     next
[10:59:31.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.404]                 }
[10:59:31.404]                 NAMES <- toupper(added)
[10:59:31.404]                 for (kk in seq_along(NAMES)) {
[10:59:31.404]                   name <- added[[kk]]
[10:59:31.404]                   NAME <- NAMES[[kk]]
[10:59:31.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.404]                     next
[10:59:31.404]                   args[[name]] <- ""
[10:59:31.404]                 }
[10:59:31.404]                 NAMES <- toupper(removed)
[10:59:31.404]                 for (kk in seq_along(NAMES)) {
[10:59:31.404]                   name <- removed[[kk]]
[10:59:31.404]                   NAME <- NAMES[[kk]]
[10:59:31.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.404]                     next
[10:59:31.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.404]                 }
[10:59:31.404]                 if (length(args) > 0) 
[10:59:31.404]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.404]             }
[10:59:31.404]             else {
[10:59:31.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.404]             }
[10:59:31.404]             {
[10:59:31.404]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.404]                   0L) {
[10:59:31.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.404]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.404]                   base::options(opts)
[10:59:31.404]                 }
[10:59:31.404]                 {
[10:59:31.404]                   {
[10:59:31.404]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.404]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.404]                     1047550554L), envir = base::globalenv(), 
[10:59:31.404]                       inherits = FALSE)
[10:59:31.404]                     NULL
[10:59:31.404]                   }
[10:59:31.404]                   options(future.plan = NULL)
[10:59:31.404]                   if (is.na(NA_character_)) 
[10:59:31.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.404]                     .init = FALSE)
[10:59:31.404]                 }
[10:59:31.404]             }
[10:59:31.404]         }
[10:59:31.404]     })
[10:59:31.404]     if (TRUE) {
[10:59:31.404]         base::sink(type = "output", split = FALSE)
[10:59:31.404]         if (TRUE) {
[10:59:31.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.404]         }
[10:59:31.404]         else {
[10:59:31.404]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.404]         }
[10:59:31.404]         base::close(...future.stdout)
[10:59:31.404]         ...future.stdout <- NULL
[10:59:31.404]     }
[10:59:31.404]     ...future.result$conditions <- ...future.conditions
[10:59:31.404]     ...future.result$finished <- base::Sys.time()
[10:59:31.404]     ...future.result
[10:59:31.404] }
[10:59:31.405] assign_globals() ...
[10:59:31.406] List of 5
[10:59:31.406]  $ ...future.FUN            :function (C, k)  
[10:59:31.406]  $ MoreArgs                 : NULL
[10:59:31.406]  $ ...future.elements_ii    :List of 2
[10:59:31.406]   ..$ :List of 3
[10:59:31.406]   .. ..$ : chr "C"
[10:59:31.406]   .. ..$ : chr "B"
[10:59:31.406]   .. ..$ : chr "A"
[10:59:31.406]   ..$ :List of 3
[10:59:31.406]   .. ..$ : int 3
[10:59:31.406]   .. ..$ : int 4
[10:59:31.406]   .. ..$ : int 5
[10:59:31.406]  $ ...future.seeds_ii       : NULL
[10:59:31.406]  $ ...future.globals.maxSize: NULL
[10:59:31.406]  - attr(*, "where")=List of 5
[10:59:31.406]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.406]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.406]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.406]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.406]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.406]  - attr(*, "resolved")= logi FALSE
[10:59:31.406]  - attr(*, "total_size")= num 905
[10:59:31.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.406]  - attr(*, "already-done")= logi TRUE
[10:59:31.412] - reassign environment for ‘...future.FUN’
[10:59:31.412] - copied ‘...future.FUN’ to environment
[10:59:31.412] - copied ‘MoreArgs’ to environment
[10:59:31.412] - copied ‘...future.elements_ii’ to environment
[10:59:31.412] - copied ‘...future.seeds_ii’ to environment
[10:59:31.412] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.412] assign_globals() ... done
[10:59:31.413] plan(): Setting new future strategy stack:
[10:59:31.413] List of future strategies:
[10:59:31.413] 1. sequential:
[10:59:31.413]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.413]    - tweaked: FALSE
[10:59:31.413]    - call: NULL
[10:59:31.413] plan(): nbrOfWorkers() = 1
[10:59:31.414] plan(): Setting new future strategy stack:
[10:59:31.414] List of future strategies:
[10:59:31.414] 1. sequential:
[10:59:31.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.414]    - tweaked: FALSE
[10:59:31.414]    - call: plan(strategy)
[10:59:31.414] plan(): nbrOfWorkers() = 1
[10:59:31.414] SequentialFuture started (and completed)
[10:59:31.415] - Launch lazy future ... done
[10:59:31.415] run() for ‘SequentialFuture’ ... done
[10:59:31.415] Created future:
[10:59:31.415] SequentialFuture:
[10:59:31.415] Label: ‘future_mapply-2’
[10:59:31.415] Expression:
[10:59:31.415] {
[10:59:31.415]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.415]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.415]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.415]         on.exit(options(oopts), add = TRUE)
[10:59:31.415]     }
[10:59:31.415]     {
[10:59:31.415]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.415]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.415]         do.call(mapply, args = args)
[10:59:31.415]     }
[10:59:31.415] }
[10:59:31.415] Lazy evaluation: FALSE
[10:59:31.415] Asynchronous evaluation: FALSE
[10:59:31.415] Local evaluation: TRUE
[10:59:31.415] Environment: R_GlobalEnv
[10:59:31.415] Capture standard output: TRUE
[10:59:31.415] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.415] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.415] Packages: <none>
[10:59:31.415] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.415] Resolved: TRUE
[10:59:31.415] Value: 91 bytes of class ‘list’
[10:59:31.415] Early signaling: FALSE
[10:59:31.415] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.415] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.415] Chunk #2 of 2 ... DONE
[10:59:31.416] Launching 2 futures (chunks) ... DONE
[10:59:31.416] Resolving 2 futures (chunks) ...
[10:59:31.416] resolve() on list ...
[10:59:31.416]  recursive: 0
[10:59:31.416]  length: 2
[10:59:31.416] 
[10:59:31.416] resolved() for ‘SequentialFuture’ ...
[10:59:31.416] - state: ‘finished’
[10:59:31.416] - run: TRUE
[10:59:31.416] - result: ‘FutureResult’
[10:59:31.416] resolved() for ‘SequentialFuture’ ... done
[10:59:31.416] Future #1
[10:59:31.417] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.417] - nx: 2
[10:59:31.417] - relay: TRUE
[10:59:31.417] - stdout: TRUE
[10:59:31.417] - signal: TRUE
[10:59:31.417] - resignal: FALSE
[10:59:31.417] - force: TRUE
[10:59:31.417] - relayed: [n=2] FALSE, FALSE
[10:59:31.417] - queued futures: [n=2] FALSE, FALSE
[10:59:31.417]  - until=1
[10:59:31.417]  - relaying element #1
[10:59:31.418] - relayed: [n=2] TRUE, FALSE
[10:59:31.418] - queued futures: [n=2] TRUE, FALSE
[10:59:31.418] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.418]  length: 1 (resolved future 1)
[10:59:31.418] resolved() for ‘SequentialFuture’ ...
[10:59:31.418] - state: ‘finished’
[10:59:31.418] - run: TRUE
[10:59:31.418] - result: ‘FutureResult’
[10:59:31.418] resolved() for ‘SequentialFuture’ ... done
[10:59:31.418] Future #2
[10:59:31.418] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:59:31.418] - nx: 2
[10:59:31.419] - relay: TRUE
[10:59:31.419] - stdout: TRUE
[10:59:31.419] - signal: TRUE
[10:59:31.419] - resignal: FALSE
[10:59:31.419] - force: TRUE
[10:59:31.419] - relayed: [n=2] TRUE, FALSE
[10:59:31.419] - queued futures: [n=2] TRUE, FALSE
[10:59:31.419]  - until=2
[10:59:31.419]  - relaying element #2
[10:59:31.419] - relayed: [n=2] TRUE, TRUE
[10:59:31.419] - queued futures: [n=2] TRUE, TRUE
[10:59:31.419] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:59:31.420]  length: 0 (resolved future 2)
[10:59:31.420] Relaying remaining futures
[10:59:31.420] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.420] - nx: 2
[10:59:31.420] - relay: TRUE
[10:59:31.420] - stdout: TRUE
[10:59:31.420] - signal: TRUE
[10:59:31.420] - resignal: FALSE
[10:59:31.420] - force: TRUE
[10:59:31.420] - relayed: [n=2] TRUE, TRUE
[10:59:31.420] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:31.420] - relayed: [n=2] TRUE, TRUE
[10:59:31.420] - queued futures: [n=2] TRUE, TRUE
[10:59:31.420] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.421] resolve() on list ... DONE
[10:59:31.421]  - Number of value chunks collected: 2
[10:59:31.421] Resolving 2 futures (chunks) ... DONE
[10:59:31.421] Reducing values from 2 chunks ...
[10:59:31.421]  - Number of values collected after concatenation: 5
[10:59:31.421]  - Number of values expected: 5
[10:59:31.421] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:59:31.421] Reducing values from 2 chunks ... DONE
[10:59:31.421] future_mapply() ... DONE
[10:59:31.422] future_mapply() ...
[10:59:31.422] Number of chunks: 1
[10:59:31.422] getGlobalsAndPackagesXApply() ...
[10:59:31.422]  - future.globals: TRUE
[10:59:31.422] getGlobalsAndPackages() ...
[10:59:31.422] Searching for globals...
[10:59:31.423] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:31.423] Searching for globals ... DONE
[10:59:31.423] Resolving globals: FALSE
[10:59:31.424] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:31.424] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:31.424] - globals: [1] ‘FUN’
[10:59:31.424] 
[10:59:31.424] getGlobalsAndPackages() ... DONE
[10:59:31.424]  - globals found/used: [n=1] ‘FUN’
[10:59:31.424]  - needed namespaces: [n=0] 
[10:59:31.424] Finding globals ... DONE
[10:59:31.425] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.425] List of 2
[10:59:31.425]  $ ...future.FUN:function (C, k)  
[10:59:31.425]  $ MoreArgs     : list()
[10:59:31.425]  - attr(*, "where")=List of 2
[10:59:31.425]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.425]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.425]  - attr(*, "resolved")= logi FALSE
[10:59:31.425]  - attr(*, "total_size")= num NA
[10:59:31.427] Packages to be attached in all futures: [n=0] 
[10:59:31.427] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.427] Number of futures (= number of chunks): 1
[10:59:31.427] Launching 1 futures (chunks) ...
[10:59:31.427] Chunk #1 of 1 ...
[10:59:31.427]  - Finding globals in '...' for chunk #1 ...
[10:59:31.428] getGlobalsAndPackages() ...
[10:59:31.428] Searching for globals...
[10:59:31.429] 
[10:59:31.429] Searching for globals ... DONE
[10:59:31.429] - globals: [0] <none>
[10:59:31.429] getGlobalsAndPackages() ... DONE
[10:59:31.429]    + additional globals found: [n=0] 
[10:59:31.429]    + additional namespaces needed: [n=0] 
[10:59:31.429]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.429]  - seeds: <none>
[10:59:31.429]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.429] getGlobalsAndPackages() ...
[10:59:31.430] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.430] Resolving globals: FALSE
[10:59:31.430] The total size of the 5 globals is 967 bytes (967 bytes)
[10:59:31.430] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:31.431] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.431] 
[10:59:31.431] getGlobalsAndPackages() ... DONE
[10:59:31.431] run() for ‘Future’ ...
[10:59:31.431] - state: ‘created’
[10:59:31.431] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.432]   - Field: ‘label’
[10:59:31.432]   - Field: ‘local’
[10:59:31.432]   - Field: ‘owner’
[10:59:31.432]   - Field: ‘envir’
[10:59:31.432]   - Field: ‘packages’
[10:59:31.432]   - Field: ‘gc’
[10:59:31.432]   - Field: ‘conditions’
[10:59:31.432]   - Field: ‘expr’
[10:59:31.432]   - Field: ‘uuid’
[10:59:31.432]   - Field: ‘seed’
[10:59:31.432]   - Field: ‘version’
[10:59:31.433]   - Field: ‘result’
[10:59:31.433]   - Field: ‘asynchronous’
[10:59:31.433]   - Field: ‘calls’
[10:59:31.433]   - Field: ‘globals’
[10:59:31.433]   - Field: ‘stdout’
[10:59:31.433]   - Field: ‘earlySignal’
[10:59:31.433]   - Field: ‘lazy’
[10:59:31.433]   - Field: ‘state’
[10:59:31.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.433] - Launch lazy future ...
[10:59:31.433] Packages needed by the future expression (n = 0): <none>
[10:59:31.433] Packages needed by future strategies (n = 0): <none>
[10:59:31.434] {
[10:59:31.434]     {
[10:59:31.434]         {
[10:59:31.434]             ...future.startTime <- base::Sys.time()
[10:59:31.434]             {
[10:59:31.434]                 {
[10:59:31.434]                   {
[10:59:31.434]                     base::local({
[10:59:31.434]                       has_future <- base::requireNamespace("future", 
[10:59:31.434]                         quietly = TRUE)
[10:59:31.434]                       if (has_future) {
[10:59:31.434]                         ns <- base::getNamespace("future")
[10:59:31.434]                         version <- ns[[".package"]][["version"]]
[10:59:31.434]                         if (is.null(version)) 
[10:59:31.434]                           version <- utils::packageVersion("future")
[10:59:31.434]                       }
[10:59:31.434]                       else {
[10:59:31.434]                         version <- NULL
[10:59:31.434]                       }
[10:59:31.434]                       if (!has_future || version < "1.8.0") {
[10:59:31.434]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.434]                           "", base::R.version$version.string), 
[10:59:31.434]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.434]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.434]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.434]                             "release", "version")], collapse = " "), 
[10:59:31.434]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.434]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.434]                           info)
[10:59:31.434]                         info <- base::paste(info, collapse = "; ")
[10:59:31.434]                         if (!has_future) {
[10:59:31.434]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.434]                             info)
[10:59:31.434]                         }
[10:59:31.434]                         else {
[10:59:31.434]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.434]                             info, version)
[10:59:31.434]                         }
[10:59:31.434]                         base::stop(msg)
[10:59:31.434]                       }
[10:59:31.434]                     })
[10:59:31.434]                   }
[10:59:31.434]                   ...future.strategy.old <- future::plan("list")
[10:59:31.434]                   options(future.plan = NULL)
[10:59:31.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.434]                 }
[10:59:31.434]                 ...future.workdir <- getwd()
[10:59:31.434]             }
[10:59:31.434]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.434]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.434]         }
[10:59:31.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.434]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.434]             base::names(...future.oldOptions))
[10:59:31.434]     }
[10:59:31.434]     if (FALSE) {
[10:59:31.434]     }
[10:59:31.434]     else {
[10:59:31.434]         if (TRUE) {
[10:59:31.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.434]                 open = "w")
[10:59:31.434]         }
[10:59:31.434]         else {
[10:59:31.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.434]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.434]         }
[10:59:31.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.434]             base::sink(type = "output", split = FALSE)
[10:59:31.434]             base::close(...future.stdout)
[10:59:31.434]         }, add = TRUE)
[10:59:31.434]     }
[10:59:31.434]     ...future.frame <- base::sys.nframe()
[10:59:31.434]     ...future.conditions <- base::list()
[10:59:31.434]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.434]     if (FALSE) {
[10:59:31.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.434]     }
[10:59:31.434]     ...future.result <- base::tryCatch({
[10:59:31.434]         base::withCallingHandlers({
[10:59:31.434]             ...future.value <- base::withVisible(base::local({
[10:59:31.434]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.434]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.434]                   ...future.globals.maxSize)) {
[10:59:31.434]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.434]                   on.exit(options(oopts), add = TRUE)
[10:59:31.434]                 }
[10:59:31.434]                 {
[10:59:31.434]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.434]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.434]                     USE.NAMES = FALSE)
[10:59:31.434]                   do.call(mapply, args = args)
[10:59:31.434]                 }
[10:59:31.434]             }))
[10:59:31.434]             future::FutureResult(value = ...future.value$value, 
[10:59:31.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.434]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.434]                     ...future.globalenv.names))
[10:59:31.434]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.434]         }, condition = base::local({
[10:59:31.434]             c <- base::c
[10:59:31.434]             inherits <- base::inherits
[10:59:31.434]             invokeRestart <- base::invokeRestart
[10:59:31.434]             length <- base::length
[10:59:31.434]             list <- base::list
[10:59:31.434]             seq.int <- base::seq.int
[10:59:31.434]             signalCondition <- base::signalCondition
[10:59:31.434]             sys.calls <- base::sys.calls
[10:59:31.434]             `[[` <- base::`[[`
[10:59:31.434]             `+` <- base::`+`
[10:59:31.434]             `<<-` <- base::`<<-`
[10:59:31.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.434]                   3L)]
[10:59:31.434]             }
[10:59:31.434]             function(cond) {
[10:59:31.434]                 is_error <- inherits(cond, "error")
[10:59:31.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.434]                   NULL)
[10:59:31.434]                 if (is_error) {
[10:59:31.434]                   sessionInformation <- function() {
[10:59:31.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.434]                       search = base::search(), system = base::Sys.info())
[10:59:31.434]                   }
[10:59:31.434]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.434]                     cond$call), session = sessionInformation(), 
[10:59:31.434]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.434]                   signalCondition(cond)
[10:59:31.434]                 }
[10:59:31.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.434]                 "immediateCondition"))) {
[10:59:31.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.434]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.434]                   if (TRUE && !signal) {
[10:59:31.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.434]                     {
[10:59:31.434]                       inherits <- base::inherits
[10:59:31.434]                       invokeRestart <- base::invokeRestart
[10:59:31.434]                       is.null <- base::is.null
[10:59:31.434]                       muffled <- FALSE
[10:59:31.434]                       if (inherits(cond, "message")) {
[10:59:31.434]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.434]                         if (muffled) 
[10:59:31.434]                           invokeRestart("muffleMessage")
[10:59:31.434]                       }
[10:59:31.434]                       else if (inherits(cond, "warning")) {
[10:59:31.434]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.434]                         if (muffled) 
[10:59:31.434]                           invokeRestart("muffleWarning")
[10:59:31.434]                       }
[10:59:31.434]                       else if (inherits(cond, "condition")) {
[10:59:31.434]                         if (!is.null(pattern)) {
[10:59:31.434]                           computeRestarts <- base::computeRestarts
[10:59:31.434]                           grepl <- base::grepl
[10:59:31.434]                           restarts <- computeRestarts(cond)
[10:59:31.434]                           for (restart in restarts) {
[10:59:31.434]                             name <- restart$name
[10:59:31.434]                             if (is.null(name)) 
[10:59:31.434]                               next
[10:59:31.434]                             if (!grepl(pattern, name)) 
[10:59:31.434]                               next
[10:59:31.434]                             invokeRestart(restart)
[10:59:31.434]                             muffled <- TRUE
[10:59:31.434]                             break
[10:59:31.434]                           }
[10:59:31.434]                         }
[10:59:31.434]                       }
[10:59:31.434]                       invisible(muffled)
[10:59:31.434]                     }
[10:59:31.434]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.434]                   }
[10:59:31.434]                 }
[10:59:31.434]                 else {
[10:59:31.434]                   if (TRUE) {
[10:59:31.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.434]                     {
[10:59:31.434]                       inherits <- base::inherits
[10:59:31.434]                       invokeRestart <- base::invokeRestart
[10:59:31.434]                       is.null <- base::is.null
[10:59:31.434]                       muffled <- FALSE
[10:59:31.434]                       if (inherits(cond, "message")) {
[10:59:31.434]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.434]                         if (muffled) 
[10:59:31.434]                           invokeRestart("muffleMessage")
[10:59:31.434]                       }
[10:59:31.434]                       else if (inherits(cond, "warning")) {
[10:59:31.434]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.434]                         if (muffled) 
[10:59:31.434]                           invokeRestart("muffleWarning")
[10:59:31.434]                       }
[10:59:31.434]                       else if (inherits(cond, "condition")) {
[10:59:31.434]                         if (!is.null(pattern)) {
[10:59:31.434]                           computeRestarts <- base::computeRestarts
[10:59:31.434]                           grepl <- base::grepl
[10:59:31.434]                           restarts <- computeRestarts(cond)
[10:59:31.434]                           for (restart in restarts) {
[10:59:31.434]                             name <- restart$name
[10:59:31.434]                             if (is.null(name)) 
[10:59:31.434]                               next
[10:59:31.434]                             if (!grepl(pattern, name)) 
[10:59:31.434]                               next
[10:59:31.434]                             invokeRestart(restart)
[10:59:31.434]                             muffled <- TRUE
[10:59:31.434]                             break
[10:59:31.434]                           }
[10:59:31.434]                         }
[10:59:31.434]                       }
[10:59:31.434]                       invisible(muffled)
[10:59:31.434]                     }
[10:59:31.434]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.434]                   }
[10:59:31.434]                 }
[10:59:31.434]             }
[10:59:31.434]         }))
[10:59:31.434]     }, error = function(ex) {
[10:59:31.434]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.434]                 ...future.rng), started = ...future.startTime, 
[10:59:31.434]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.434]             version = "1.8"), class = "FutureResult")
[10:59:31.434]     }, finally = {
[10:59:31.434]         if (!identical(...future.workdir, getwd())) 
[10:59:31.434]             setwd(...future.workdir)
[10:59:31.434]         {
[10:59:31.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.434]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.434]             }
[10:59:31.434]             base::options(...future.oldOptions)
[10:59:31.434]             if (.Platform$OS.type == "windows") {
[10:59:31.434]                 old_names <- names(...future.oldEnvVars)
[10:59:31.434]                 envs <- base::Sys.getenv()
[10:59:31.434]                 names <- names(envs)
[10:59:31.434]                 common <- intersect(names, old_names)
[10:59:31.434]                 added <- setdiff(names, old_names)
[10:59:31.434]                 removed <- setdiff(old_names, names)
[10:59:31.434]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.434]                   envs[common]]
[10:59:31.434]                 NAMES <- toupper(changed)
[10:59:31.434]                 args <- list()
[10:59:31.434]                 for (kk in seq_along(NAMES)) {
[10:59:31.434]                   name <- changed[[kk]]
[10:59:31.434]                   NAME <- NAMES[[kk]]
[10:59:31.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.434]                     next
[10:59:31.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.434]                 }
[10:59:31.434]                 NAMES <- toupper(added)
[10:59:31.434]                 for (kk in seq_along(NAMES)) {
[10:59:31.434]                   name <- added[[kk]]
[10:59:31.434]                   NAME <- NAMES[[kk]]
[10:59:31.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.434]                     next
[10:59:31.434]                   args[[name]] <- ""
[10:59:31.434]                 }
[10:59:31.434]                 NAMES <- toupper(removed)
[10:59:31.434]                 for (kk in seq_along(NAMES)) {
[10:59:31.434]                   name <- removed[[kk]]
[10:59:31.434]                   NAME <- NAMES[[kk]]
[10:59:31.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.434]                     next
[10:59:31.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.434]                 }
[10:59:31.434]                 if (length(args) > 0) 
[10:59:31.434]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.434]             }
[10:59:31.434]             else {
[10:59:31.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.434]             }
[10:59:31.434]             {
[10:59:31.434]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.434]                   0L) {
[10:59:31.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.434]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.434]                   base::options(opts)
[10:59:31.434]                 }
[10:59:31.434]                 {
[10:59:31.434]                   {
[10:59:31.434]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.434]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.434]                     1047550554L), envir = base::globalenv(), 
[10:59:31.434]                       inherits = FALSE)
[10:59:31.434]                     NULL
[10:59:31.434]                   }
[10:59:31.434]                   options(future.plan = NULL)
[10:59:31.434]                   if (is.na(NA_character_)) 
[10:59:31.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.434]                     .init = FALSE)
[10:59:31.434]                 }
[10:59:31.434]             }
[10:59:31.434]         }
[10:59:31.434]     })
[10:59:31.434]     if (TRUE) {
[10:59:31.434]         base::sink(type = "output", split = FALSE)
[10:59:31.434]         if (TRUE) {
[10:59:31.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.434]         }
[10:59:31.434]         else {
[10:59:31.434]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.434]         }
[10:59:31.434]         base::close(...future.stdout)
[10:59:31.434]         ...future.stdout <- NULL
[10:59:31.434]     }
[10:59:31.434]     ...future.result$conditions <- ...future.conditions
[10:59:31.434]     ...future.result$finished <- base::Sys.time()
[10:59:31.434]     ...future.result
[10:59:31.434] }
[10:59:31.435] assign_globals() ...
[10:59:31.436] List of 5
[10:59:31.436]  $ ...future.FUN            :function (C, k)  
[10:59:31.436]  $ MoreArgs                 : list()
[10:59:31.436]  $ ...future.elements_ii    :List of 2
[10:59:31.436]   ..$ :List of 5
[10:59:31.436]   .. ..$ : chr "A"
[10:59:31.436]   .. ..$ : chr "B"
[10:59:31.436]   .. ..$ : chr "C"
[10:59:31.436]   .. ..$ : chr "D"
[10:59:31.436]   .. ..$ : chr "E"
[10:59:31.436]   ..$ :List of 5
[10:59:31.436]   .. ..$ : int 5
[10:59:31.436]   .. ..$ : int 4
[10:59:31.436]   .. ..$ : int 3
[10:59:31.436]   .. ..$ : int 2
[10:59:31.436]   .. ..$ : int 1
[10:59:31.436]  $ ...future.seeds_ii       : NULL
[10:59:31.436]  $ ...future.globals.maxSize: NULL
[10:59:31.436]  - attr(*, "where")=List of 5
[10:59:31.436]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.436]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.436]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.436]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.436]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.436]  - attr(*, "resolved")= logi FALSE
[10:59:31.436]  - attr(*, "total_size")= num 967
[10:59:31.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.436]  - attr(*, "already-done")= logi TRUE
[10:59:31.442] - reassign environment for ‘...future.FUN’
[10:59:31.442] - copied ‘...future.FUN’ to environment
[10:59:31.442] - copied ‘MoreArgs’ to environment
[10:59:31.442] - copied ‘...future.elements_ii’ to environment
[10:59:31.442] - copied ‘...future.seeds_ii’ to environment
[10:59:31.442] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.442] assign_globals() ... done
[10:59:31.443] plan(): Setting new future strategy stack:
[10:59:31.443] List of future strategies:
[10:59:31.443] 1. sequential:
[10:59:31.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.443]    - tweaked: FALSE
[10:59:31.443]    - call: NULL
[10:59:31.443] plan(): nbrOfWorkers() = 1
[10:59:31.444] plan(): Setting new future strategy stack:
[10:59:31.444] List of future strategies:
[10:59:31.444] 1. sequential:
[10:59:31.444]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.444]    - tweaked: FALSE
[10:59:31.444]    - call: plan(strategy)
[10:59:31.444] plan(): nbrOfWorkers() = 1
[10:59:31.444] SequentialFuture started (and completed)
[10:59:31.445] - Launch lazy future ... done
[10:59:31.445] run() for ‘SequentialFuture’ ... done
[10:59:31.445] Created future:
[10:59:31.445] SequentialFuture:
[10:59:31.445] Label: ‘future_.mapply-1’
[10:59:31.445] Expression:
[10:59:31.445] {
[10:59:31.445]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.445]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.445]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.445]         on.exit(options(oopts), add = TRUE)
[10:59:31.445]     }
[10:59:31.445]     {
[10:59:31.445]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.445]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.445]         do.call(mapply, args = args)
[10:59:31.445]     }
[10:59:31.445] }
[10:59:31.445] Lazy evaluation: FALSE
[10:59:31.445] Asynchronous evaluation: FALSE
[10:59:31.445] Local evaluation: TRUE
[10:59:31.445] Environment: R_GlobalEnv
[10:59:31.445] Capture standard output: TRUE
[10:59:31.445] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.445] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.445] Packages: <none>
[10:59:31.445] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.445] Resolved: TRUE
[10:59:31.445] Value: 126 bytes of class ‘list’
[10:59:31.445] Early signaling: FALSE
[10:59:31.445] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.445] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.446] Chunk #1 of 1 ... DONE
[10:59:31.446] Launching 1 futures (chunks) ... DONE
[10:59:31.446] Resolving 1 futures (chunks) ...
[10:59:31.446] resolve() on list ...
[10:59:31.446]  recursive: 0
[10:59:31.446]  length: 1
[10:59:31.446] 
[10:59:31.446] resolved() for ‘SequentialFuture’ ...
[10:59:31.446] - state: ‘finished’
[10:59:31.446] - run: TRUE
[10:59:31.446] - result: ‘FutureResult’
[10:59:31.446] resolved() for ‘SequentialFuture’ ... done
[10:59:31.447] Future #1
[10:59:31.447] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.447] - nx: 1
[10:59:31.447] - relay: TRUE
[10:59:31.447] - stdout: TRUE
[10:59:31.447] - signal: TRUE
[10:59:31.447] - resignal: FALSE
[10:59:31.447] - force: TRUE
[10:59:31.447] - relayed: [n=1] FALSE
[10:59:31.447] - queued futures: [n=1] FALSE
[10:59:31.447]  - until=1
[10:59:31.447]  - relaying element #1
[10:59:31.448] - relayed: [n=1] TRUE
[10:59:31.448] - queued futures: [n=1] TRUE
[10:59:31.448] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.448]  length: 0 (resolved future 1)
[10:59:31.448] Relaying remaining futures
[10:59:31.448] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.448] - nx: 1
[10:59:31.448] - relay: TRUE
[10:59:31.448] - stdout: TRUE
[10:59:31.448] - signal: TRUE
[10:59:31.448] - resignal: FALSE
[10:59:31.448] - force: TRUE
[10:59:31.448] - relayed: [n=1] TRUE
[10:59:31.449] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.449] - relayed: [n=1] TRUE
[10:59:31.449] - queued futures: [n=1] TRUE
[10:59:31.449] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.449] resolve() on list ... DONE
[10:59:31.450]  - Number of value chunks collected: 1
[10:59:31.450] Resolving 1 futures (chunks) ... DONE
[10:59:31.450] Reducing values from 1 chunks ...
[10:59:31.450]  - Number of values collected after concatenation: 5
[10:59:31.450]  - Number of values expected: 5
[10:59:31.450] Reducing values from 1 chunks ... DONE
[10:59:31.450] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:59:31.451] future_mapply() ...
[10:59:31.451] Number of chunks: 1
[10:59:31.451] getGlobalsAndPackagesXApply() ...
[10:59:31.451]  - future.globals: TRUE
[10:59:31.451] getGlobalsAndPackages() ...
[10:59:31.451] Searching for globals...
[10:59:31.452] - globals found: [1] ‘FUN’
[10:59:31.452] Searching for globals ... DONE
[10:59:31.452] Resolving globals: FALSE
[10:59:31.453] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:31.453] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:31.453] - globals: [1] ‘FUN’
[10:59:31.453] 
[10:59:31.453] getGlobalsAndPackages() ... DONE
[10:59:31.453]  - globals found/used: [n=1] ‘FUN’
[10:59:31.453]  - needed namespaces: [n=0] 
[10:59:31.453] Finding globals ... DONE
[10:59:31.454] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.454] List of 2
[10:59:31.454]  $ ...future.FUN:function (x)  
[10:59:31.454]  $ MoreArgs     : NULL
[10:59:31.454]  - attr(*, "where")=List of 2
[10:59:31.454]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.454]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.454]  - attr(*, "resolved")= logi FALSE
[10:59:31.454]  - attr(*, "total_size")= num NA
[10:59:31.456] Packages to be attached in all futures: [n=0] 
[10:59:31.456] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.456] Number of futures (= number of chunks): 1
[10:59:31.456] Launching 1 futures (chunks) ...
[10:59:31.457] Chunk #1 of 1 ...
[10:59:31.457]  - Finding globals in '...' for chunk #1 ...
[10:59:31.457] getGlobalsAndPackages() ...
[10:59:31.457] Searching for globals...
[10:59:31.457] 
[10:59:31.457] Searching for globals ... DONE
[10:59:31.457] - globals: [0] <none>
[10:59:31.457] getGlobalsAndPackages() ... DONE
[10:59:31.457]    + additional globals found: [n=0] 
[10:59:31.457]    + additional namespaces needed: [n=0] 
[10:59:31.458]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.458]  - seeds: <none>
[10:59:31.458]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.458] getGlobalsAndPackages() ...
[10:59:31.458] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.458] Resolving globals: FALSE
[10:59:31.458] The total size of the 5 globals is 366 bytes (366 bytes)
[10:59:31.459] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.459] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.459] 
[10:59:31.459] getGlobalsAndPackages() ... DONE
[10:59:31.459] run() for ‘Future’ ...
[10:59:31.459] - state: ‘created’
[10:59:31.460] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.460]   - Field: ‘label’
[10:59:31.460]   - Field: ‘local’
[10:59:31.460]   - Field: ‘owner’
[10:59:31.460]   - Field: ‘envir’
[10:59:31.460]   - Field: ‘packages’
[10:59:31.460]   - Field: ‘gc’
[10:59:31.460]   - Field: ‘conditions’
[10:59:31.461]   - Field: ‘expr’
[10:59:31.461]   - Field: ‘uuid’
[10:59:31.461]   - Field: ‘seed’
[10:59:31.461]   - Field: ‘version’
[10:59:31.461]   - Field: ‘result’
[10:59:31.461]   - Field: ‘asynchronous’
[10:59:31.461]   - Field: ‘calls’
[10:59:31.461]   - Field: ‘globals’
[10:59:31.461]   - Field: ‘stdout’
[10:59:31.461]   - Field: ‘earlySignal’
[10:59:31.461]   - Field: ‘lazy’
[10:59:31.461]   - Field: ‘state’
[10:59:31.461] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.462] - Launch lazy future ...
[10:59:31.462] Packages needed by the future expression (n = 0): <none>
[10:59:31.462] Packages needed by future strategies (n = 0): <none>
[10:59:31.462] {
[10:59:31.462]     {
[10:59:31.462]         {
[10:59:31.462]             ...future.startTime <- base::Sys.time()
[10:59:31.462]             {
[10:59:31.462]                 {
[10:59:31.462]                   {
[10:59:31.462]                     base::local({
[10:59:31.462]                       has_future <- base::requireNamespace("future", 
[10:59:31.462]                         quietly = TRUE)
[10:59:31.462]                       if (has_future) {
[10:59:31.462]                         ns <- base::getNamespace("future")
[10:59:31.462]                         version <- ns[[".package"]][["version"]]
[10:59:31.462]                         if (is.null(version)) 
[10:59:31.462]                           version <- utils::packageVersion("future")
[10:59:31.462]                       }
[10:59:31.462]                       else {
[10:59:31.462]                         version <- NULL
[10:59:31.462]                       }
[10:59:31.462]                       if (!has_future || version < "1.8.0") {
[10:59:31.462]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.462]                           "", base::R.version$version.string), 
[10:59:31.462]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.462]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.462]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.462]                             "release", "version")], collapse = " "), 
[10:59:31.462]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.462]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.462]                           info)
[10:59:31.462]                         info <- base::paste(info, collapse = "; ")
[10:59:31.462]                         if (!has_future) {
[10:59:31.462]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.462]                             info)
[10:59:31.462]                         }
[10:59:31.462]                         else {
[10:59:31.462]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.462]                             info, version)
[10:59:31.462]                         }
[10:59:31.462]                         base::stop(msg)
[10:59:31.462]                       }
[10:59:31.462]                     })
[10:59:31.462]                   }
[10:59:31.462]                   ...future.strategy.old <- future::plan("list")
[10:59:31.462]                   options(future.plan = NULL)
[10:59:31.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.462]                 }
[10:59:31.462]                 ...future.workdir <- getwd()
[10:59:31.462]             }
[10:59:31.462]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.462]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.462]         }
[10:59:31.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.462]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.462]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.462]             base::names(...future.oldOptions))
[10:59:31.462]     }
[10:59:31.462]     if (FALSE) {
[10:59:31.462]     }
[10:59:31.462]     else {
[10:59:31.462]         if (TRUE) {
[10:59:31.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.462]                 open = "w")
[10:59:31.462]         }
[10:59:31.462]         else {
[10:59:31.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.462]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.462]         }
[10:59:31.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.462]             base::sink(type = "output", split = FALSE)
[10:59:31.462]             base::close(...future.stdout)
[10:59:31.462]         }, add = TRUE)
[10:59:31.462]     }
[10:59:31.462]     ...future.frame <- base::sys.nframe()
[10:59:31.462]     ...future.conditions <- base::list()
[10:59:31.462]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.462]     if (FALSE) {
[10:59:31.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.462]     }
[10:59:31.462]     ...future.result <- base::tryCatch({
[10:59:31.462]         base::withCallingHandlers({
[10:59:31.462]             ...future.value <- base::withVisible(base::local({
[10:59:31.462]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.462]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.462]                   ...future.globals.maxSize)) {
[10:59:31.462]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.462]                   on.exit(options(oopts), add = TRUE)
[10:59:31.462]                 }
[10:59:31.462]                 {
[10:59:31.462]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.462]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.462]                     USE.NAMES = FALSE)
[10:59:31.462]                   do.call(mapply, args = args)
[10:59:31.462]                 }
[10:59:31.462]             }))
[10:59:31.462]             future::FutureResult(value = ...future.value$value, 
[10:59:31.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.462]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.462]                     ...future.globalenv.names))
[10:59:31.462]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.462]         }, condition = base::local({
[10:59:31.462]             c <- base::c
[10:59:31.462]             inherits <- base::inherits
[10:59:31.462]             invokeRestart <- base::invokeRestart
[10:59:31.462]             length <- base::length
[10:59:31.462]             list <- base::list
[10:59:31.462]             seq.int <- base::seq.int
[10:59:31.462]             signalCondition <- base::signalCondition
[10:59:31.462]             sys.calls <- base::sys.calls
[10:59:31.462]             `[[` <- base::`[[`
[10:59:31.462]             `+` <- base::`+`
[10:59:31.462]             `<<-` <- base::`<<-`
[10:59:31.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.462]                   3L)]
[10:59:31.462]             }
[10:59:31.462]             function(cond) {
[10:59:31.462]                 is_error <- inherits(cond, "error")
[10:59:31.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.462]                   NULL)
[10:59:31.462]                 if (is_error) {
[10:59:31.462]                   sessionInformation <- function() {
[10:59:31.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.462]                       search = base::search(), system = base::Sys.info())
[10:59:31.462]                   }
[10:59:31.462]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.462]                     cond$call), session = sessionInformation(), 
[10:59:31.462]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.462]                   signalCondition(cond)
[10:59:31.462]                 }
[10:59:31.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.462]                 "immediateCondition"))) {
[10:59:31.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.462]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.462]                   if (TRUE && !signal) {
[10:59:31.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.462]                     {
[10:59:31.462]                       inherits <- base::inherits
[10:59:31.462]                       invokeRestart <- base::invokeRestart
[10:59:31.462]                       is.null <- base::is.null
[10:59:31.462]                       muffled <- FALSE
[10:59:31.462]                       if (inherits(cond, "message")) {
[10:59:31.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.462]                         if (muffled) 
[10:59:31.462]                           invokeRestart("muffleMessage")
[10:59:31.462]                       }
[10:59:31.462]                       else if (inherits(cond, "warning")) {
[10:59:31.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.462]                         if (muffled) 
[10:59:31.462]                           invokeRestart("muffleWarning")
[10:59:31.462]                       }
[10:59:31.462]                       else if (inherits(cond, "condition")) {
[10:59:31.462]                         if (!is.null(pattern)) {
[10:59:31.462]                           computeRestarts <- base::computeRestarts
[10:59:31.462]                           grepl <- base::grepl
[10:59:31.462]                           restarts <- computeRestarts(cond)
[10:59:31.462]                           for (restart in restarts) {
[10:59:31.462]                             name <- restart$name
[10:59:31.462]                             if (is.null(name)) 
[10:59:31.462]                               next
[10:59:31.462]                             if (!grepl(pattern, name)) 
[10:59:31.462]                               next
[10:59:31.462]                             invokeRestart(restart)
[10:59:31.462]                             muffled <- TRUE
[10:59:31.462]                             break
[10:59:31.462]                           }
[10:59:31.462]                         }
[10:59:31.462]                       }
[10:59:31.462]                       invisible(muffled)
[10:59:31.462]                     }
[10:59:31.462]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.462]                   }
[10:59:31.462]                 }
[10:59:31.462]                 else {
[10:59:31.462]                   if (TRUE) {
[10:59:31.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.462]                     {
[10:59:31.462]                       inherits <- base::inherits
[10:59:31.462]                       invokeRestart <- base::invokeRestart
[10:59:31.462]                       is.null <- base::is.null
[10:59:31.462]                       muffled <- FALSE
[10:59:31.462]                       if (inherits(cond, "message")) {
[10:59:31.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.462]                         if (muffled) 
[10:59:31.462]                           invokeRestart("muffleMessage")
[10:59:31.462]                       }
[10:59:31.462]                       else if (inherits(cond, "warning")) {
[10:59:31.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.462]                         if (muffled) 
[10:59:31.462]                           invokeRestart("muffleWarning")
[10:59:31.462]                       }
[10:59:31.462]                       else if (inherits(cond, "condition")) {
[10:59:31.462]                         if (!is.null(pattern)) {
[10:59:31.462]                           computeRestarts <- base::computeRestarts
[10:59:31.462]                           grepl <- base::grepl
[10:59:31.462]                           restarts <- computeRestarts(cond)
[10:59:31.462]                           for (restart in restarts) {
[10:59:31.462]                             name <- restart$name
[10:59:31.462]                             if (is.null(name)) 
[10:59:31.462]                               next
[10:59:31.462]                             if (!grepl(pattern, name)) 
[10:59:31.462]                               next
[10:59:31.462]                             invokeRestart(restart)
[10:59:31.462]                             muffled <- TRUE
[10:59:31.462]                             break
[10:59:31.462]                           }
[10:59:31.462]                         }
[10:59:31.462]                       }
[10:59:31.462]                       invisible(muffled)
[10:59:31.462]                     }
[10:59:31.462]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.462]                   }
[10:59:31.462]                 }
[10:59:31.462]             }
[10:59:31.462]         }))
[10:59:31.462]     }, error = function(ex) {
[10:59:31.462]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.462]                 ...future.rng), started = ...future.startTime, 
[10:59:31.462]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.462]             version = "1.8"), class = "FutureResult")
[10:59:31.462]     }, finally = {
[10:59:31.462]         if (!identical(...future.workdir, getwd())) 
[10:59:31.462]             setwd(...future.workdir)
[10:59:31.462]         {
[10:59:31.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.462]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.462]             }
[10:59:31.462]             base::options(...future.oldOptions)
[10:59:31.462]             if (.Platform$OS.type == "windows") {
[10:59:31.462]                 old_names <- names(...future.oldEnvVars)
[10:59:31.462]                 envs <- base::Sys.getenv()
[10:59:31.462]                 names <- names(envs)
[10:59:31.462]                 common <- intersect(names, old_names)
[10:59:31.462]                 added <- setdiff(names, old_names)
[10:59:31.462]                 removed <- setdiff(old_names, names)
[10:59:31.462]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.462]                   envs[common]]
[10:59:31.462]                 NAMES <- toupper(changed)
[10:59:31.462]                 args <- list()
[10:59:31.462]                 for (kk in seq_along(NAMES)) {
[10:59:31.462]                   name <- changed[[kk]]
[10:59:31.462]                   NAME <- NAMES[[kk]]
[10:59:31.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.462]                     next
[10:59:31.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.462]                 }
[10:59:31.462]                 NAMES <- toupper(added)
[10:59:31.462]                 for (kk in seq_along(NAMES)) {
[10:59:31.462]                   name <- added[[kk]]
[10:59:31.462]                   NAME <- NAMES[[kk]]
[10:59:31.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.462]                     next
[10:59:31.462]                   args[[name]] <- ""
[10:59:31.462]                 }
[10:59:31.462]                 NAMES <- toupper(removed)
[10:59:31.462]                 for (kk in seq_along(NAMES)) {
[10:59:31.462]                   name <- removed[[kk]]
[10:59:31.462]                   NAME <- NAMES[[kk]]
[10:59:31.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.462]                     next
[10:59:31.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.462]                 }
[10:59:31.462]                 if (length(args) > 0) 
[10:59:31.462]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.462]             }
[10:59:31.462]             else {
[10:59:31.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.462]             }
[10:59:31.462]             {
[10:59:31.462]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.462]                   0L) {
[10:59:31.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.462]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.462]                   base::options(opts)
[10:59:31.462]                 }
[10:59:31.462]                 {
[10:59:31.462]                   {
[10:59:31.462]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.462]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.462]                     1047550554L), envir = base::globalenv(), 
[10:59:31.462]                       inherits = FALSE)
[10:59:31.462]                     NULL
[10:59:31.462]                   }
[10:59:31.462]                   options(future.plan = NULL)
[10:59:31.462]                   if (is.na(NA_character_)) 
[10:59:31.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.462]                     .init = FALSE)
[10:59:31.462]                 }
[10:59:31.462]             }
[10:59:31.462]         }
[10:59:31.462]     })
[10:59:31.462]     if (TRUE) {
[10:59:31.462]         base::sink(type = "output", split = FALSE)
[10:59:31.462]         if (TRUE) {
[10:59:31.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.462]         }
[10:59:31.462]         else {
[10:59:31.462]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.462]         }
[10:59:31.462]         base::close(...future.stdout)
[10:59:31.462]         ...future.stdout <- NULL
[10:59:31.462]     }
[10:59:31.462]     ...future.result$conditions <- ...future.conditions
[10:59:31.462]     ...future.result$finished <- base::Sys.time()
[10:59:31.462]     ...future.result
[10:59:31.462] }
[10:59:31.464] assign_globals() ...
[10:59:31.464] List of 5
[10:59:31.464]  $ ...future.FUN            :function (x)  
[10:59:31.464]  $ MoreArgs                 : NULL
[10:59:31.464]  $ ...future.elements_ii    :List of 1
[10:59:31.464]   ..$ :List of 1
[10:59:31.464]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:59:31.464]  $ ...future.seeds_ii       : NULL
[10:59:31.464]  $ ...future.globals.maxSize: NULL
[10:59:31.464]  - attr(*, "where")=List of 5
[10:59:31.464]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.464]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.464]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.464]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.464]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.464]  - attr(*, "resolved")= logi FALSE
[10:59:31.464]  - attr(*, "total_size")= num 366
[10:59:31.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.464]  - attr(*, "already-done")= logi TRUE
[10:59:31.468] - copied ‘...future.FUN’ to environment
[10:59:31.469] - copied ‘MoreArgs’ to environment
[10:59:31.469] - copied ‘...future.elements_ii’ to environment
[10:59:31.469] - copied ‘...future.seeds_ii’ to environment
[10:59:31.469] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.469] assign_globals() ... done
[10:59:31.469] plan(): Setting new future strategy stack:
[10:59:31.469] List of future strategies:
[10:59:31.469] 1. sequential:
[10:59:31.469]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.469]    - tweaked: FALSE
[10:59:31.469]    - call: NULL
[10:59:31.470] plan(): nbrOfWorkers() = 1
[10:59:31.470] plan(): Setting new future strategy stack:
[10:59:31.470] List of future strategies:
[10:59:31.470] 1. sequential:
[10:59:31.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.470]    - tweaked: FALSE
[10:59:31.470]    - call: plan(strategy)
[10:59:31.471] plan(): nbrOfWorkers() = 1
[10:59:31.471] SequentialFuture started (and completed)
[10:59:31.471] - Launch lazy future ... done
[10:59:31.472] run() for ‘SequentialFuture’ ... done
[10:59:31.472] Created future:
[10:59:31.472] SequentialFuture:
[10:59:31.472] Label: ‘future_mapply-1’
[10:59:31.472] Expression:
[10:59:31.472] {
[10:59:31.472]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.472]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.472]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.472]         on.exit(options(oopts), add = TRUE)
[10:59:31.472]     }
[10:59:31.472]     {
[10:59:31.472]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.472]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.472]         do.call(mapply, args = args)
[10:59:31.472]     }
[10:59:31.472] }
[10:59:31.472] Lazy evaluation: FALSE
[10:59:31.472] Asynchronous evaluation: FALSE
[10:59:31.472] Local evaluation: TRUE
[10:59:31.472] Environment: R_GlobalEnv
[10:59:31.472] Capture standard output: TRUE
[10:59:31.472] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.472] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.472] Packages: <none>
[10:59:31.472] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.472] Resolved: TRUE
[10:59:31.472] Value: 92 bytes of class ‘list’
[10:59:31.472] Early signaling: FALSE
[10:59:31.472] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.472] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.473] Chunk #1 of 1 ... DONE
[10:59:31.473] Launching 1 futures (chunks) ... DONE
[10:59:31.473] Resolving 1 futures (chunks) ...
[10:59:31.474] resolve() on list ...
[10:59:31.474]  recursive: 0
[10:59:31.474]  length: 1
[10:59:31.474] 
[10:59:31.474] resolved() for ‘SequentialFuture’ ...
[10:59:31.474] - state: ‘finished’
[10:59:31.474] - run: TRUE
[10:59:31.474] - result: ‘FutureResult’
[10:59:31.474] resolved() for ‘SequentialFuture’ ... done
[10:59:31.474] Future #1
[10:59:31.474] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.475] - nx: 1
[10:59:31.475] - relay: TRUE
[10:59:31.475] - stdout: TRUE
[10:59:31.475] - signal: TRUE
[10:59:31.475] - resignal: FALSE
[10:59:31.475] - force: TRUE
[10:59:31.475] - relayed: [n=1] FALSE
[10:59:31.475] - queued futures: [n=1] FALSE
[10:59:31.475]  - until=1
[10:59:31.475]  - relaying element #1
[10:59:31.475] - relayed: [n=1] TRUE
[10:59:31.475] - queued futures: [n=1] TRUE
[10:59:31.476] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.476]  length: 0 (resolved future 1)
[10:59:31.476] Relaying remaining futures
[10:59:31.476] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.476] - nx: 1
[10:59:31.476] - relay: TRUE
[10:59:31.476] - stdout: TRUE
[10:59:31.476] - signal: TRUE
[10:59:31.476] - resignal: FALSE
[10:59:31.476] - force: TRUE
[10:59:31.476] - relayed: [n=1] TRUE
[10:59:31.476] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.477] - relayed: [n=1] TRUE
[10:59:31.477] - queued futures: [n=1] TRUE
[10:59:31.477] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.477] resolve() on list ... DONE
[10:59:31.477]  - Number of value chunks collected: 1
[10:59:31.477] Resolving 1 futures (chunks) ... DONE
[10:59:31.477] Reducing values from 1 chunks ...
[10:59:31.477]  - Number of values collected after concatenation: 1
[10:59:31.477]  - Number of values expected: 1
[10:59:31.477] Reducing values from 1 chunks ... DONE
[10:59:31.477] future_mapply() ... DONE
[10:59:31.477] future_mapply() ...
[10:59:31.478] Number of chunks: 1
[10:59:31.478] getGlobalsAndPackagesXApply() ...
[10:59:31.478]  - future.globals: TRUE
[10:59:31.478] getGlobalsAndPackages() ...
[10:59:31.478] Searching for globals...
[10:59:31.479] - globals found: [1] ‘FUN’
[10:59:31.479] Searching for globals ... DONE
[10:59:31.479] Resolving globals: FALSE
[10:59:31.479] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:31.480] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:31.480] - globals: [1] ‘FUN’
[10:59:31.480] 
[10:59:31.480] getGlobalsAndPackages() ... DONE
[10:59:31.480]  - globals found/used: [n=1] ‘FUN’
[10:59:31.480]  - needed namespaces: [n=0] 
[10:59:31.480] Finding globals ... DONE
[10:59:31.480] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.480] List of 2
[10:59:31.480]  $ ...future.FUN:function (x)  
[10:59:31.480]  $ MoreArgs     : list()
[10:59:31.480]  - attr(*, "where")=List of 2
[10:59:31.480]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.480]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.480]  - attr(*, "resolved")= logi FALSE
[10:59:31.480]  - attr(*, "total_size")= num NA
[10:59:31.482] Packages to be attached in all futures: [n=0] 
[10:59:31.483] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.483] Number of futures (= number of chunks): 1
[10:59:31.483] Launching 1 futures (chunks) ...
[10:59:31.483] Chunk #1 of 1 ...
[10:59:31.483]  - Finding globals in '...' for chunk #1 ...
[10:59:31.483] getGlobalsAndPackages() ...
[10:59:31.483] Searching for globals...
[10:59:31.483] 
[10:59:31.484] Searching for globals ... DONE
[10:59:31.484] - globals: [0] <none>
[10:59:31.484] getGlobalsAndPackages() ... DONE
[10:59:31.484]    + additional globals found: [n=0] 
[10:59:31.484]    + additional namespaces needed: [n=0] 
[10:59:31.484]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.484]  - seeds: <none>
[10:59:31.484]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.484] getGlobalsAndPackages() ...
[10:59:31.484] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.484] Resolving globals: FALSE
[10:59:31.485] The total size of the 5 globals is 370 bytes (370 bytes)
[10:59:31.485] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:31.485] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.485] 
[10:59:31.485] getGlobalsAndPackages() ... DONE
[10:59:31.486] run() for ‘Future’ ...
[10:59:31.486] - state: ‘created’
[10:59:31.486] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.486] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.486]   - Field: ‘label’
[10:59:31.486]   - Field: ‘local’
[10:59:31.487]   - Field: ‘owner’
[10:59:31.487]   - Field: ‘envir’
[10:59:31.487]   - Field: ‘packages’
[10:59:31.487]   - Field: ‘gc’
[10:59:31.487]   - Field: ‘conditions’
[10:59:31.487]   - Field: ‘expr’
[10:59:31.487]   - Field: ‘uuid’
[10:59:31.487]   - Field: ‘seed’
[10:59:31.487]   - Field: ‘version’
[10:59:31.487]   - Field: ‘result’
[10:59:31.487]   - Field: ‘asynchronous’
[10:59:31.487]   - Field: ‘calls’
[10:59:31.488]   - Field: ‘globals’
[10:59:31.488]   - Field: ‘stdout’
[10:59:31.488]   - Field: ‘earlySignal’
[10:59:31.488]   - Field: ‘lazy’
[10:59:31.488]   - Field: ‘state’
[10:59:31.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.488] - Launch lazy future ...
[10:59:31.488] Packages needed by the future expression (n = 0): <none>
[10:59:31.489] Packages needed by future strategies (n = 0): <none>
[10:59:31.489] {
[10:59:31.489]     {
[10:59:31.489]         {
[10:59:31.489]             ...future.startTime <- base::Sys.time()
[10:59:31.489]             {
[10:59:31.489]                 {
[10:59:31.489]                   {
[10:59:31.489]                     base::local({
[10:59:31.489]                       has_future <- base::requireNamespace("future", 
[10:59:31.489]                         quietly = TRUE)
[10:59:31.489]                       if (has_future) {
[10:59:31.489]                         ns <- base::getNamespace("future")
[10:59:31.489]                         version <- ns[[".package"]][["version"]]
[10:59:31.489]                         if (is.null(version)) 
[10:59:31.489]                           version <- utils::packageVersion("future")
[10:59:31.489]                       }
[10:59:31.489]                       else {
[10:59:31.489]                         version <- NULL
[10:59:31.489]                       }
[10:59:31.489]                       if (!has_future || version < "1.8.0") {
[10:59:31.489]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.489]                           "", base::R.version$version.string), 
[10:59:31.489]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.489]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.489]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.489]                             "release", "version")], collapse = " "), 
[10:59:31.489]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.489]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.489]                           info)
[10:59:31.489]                         info <- base::paste(info, collapse = "; ")
[10:59:31.489]                         if (!has_future) {
[10:59:31.489]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.489]                             info)
[10:59:31.489]                         }
[10:59:31.489]                         else {
[10:59:31.489]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.489]                             info, version)
[10:59:31.489]                         }
[10:59:31.489]                         base::stop(msg)
[10:59:31.489]                       }
[10:59:31.489]                     })
[10:59:31.489]                   }
[10:59:31.489]                   ...future.strategy.old <- future::plan("list")
[10:59:31.489]                   options(future.plan = NULL)
[10:59:31.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.489]                 }
[10:59:31.489]                 ...future.workdir <- getwd()
[10:59:31.489]             }
[10:59:31.489]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.489]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.489]         }
[10:59:31.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.489]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.489]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.489]             base::names(...future.oldOptions))
[10:59:31.489]     }
[10:59:31.489]     if (FALSE) {
[10:59:31.489]     }
[10:59:31.489]     else {
[10:59:31.489]         if (TRUE) {
[10:59:31.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.489]                 open = "w")
[10:59:31.489]         }
[10:59:31.489]         else {
[10:59:31.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.489]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.489]         }
[10:59:31.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.489]             base::sink(type = "output", split = FALSE)
[10:59:31.489]             base::close(...future.stdout)
[10:59:31.489]         }, add = TRUE)
[10:59:31.489]     }
[10:59:31.489]     ...future.frame <- base::sys.nframe()
[10:59:31.489]     ...future.conditions <- base::list()
[10:59:31.489]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.489]     if (FALSE) {
[10:59:31.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.489]     }
[10:59:31.489]     ...future.result <- base::tryCatch({
[10:59:31.489]         base::withCallingHandlers({
[10:59:31.489]             ...future.value <- base::withVisible(base::local({
[10:59:31.489]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.489]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.489]                   ...future.globals.maxSize)) {
[10:59:31.489]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.489]                   on.exit(options(oopts), add = TRUE)
[10:59:31.489]                 }
[10:59:31.489]                 {
[10:59:31.489]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.489]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.489]                     USE.NAMES = FALSE)
[10:59:31.489]                   do.call(mapply, args = args)
[10:59:31.489]                 }
[10:59:31.489]             }))
[10:59:31.489]             future::FutureResult(value = ...future.value$value, 
[10:59:31.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.489]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.489]                     ...future.globalenv.names))
[10:59:31.489]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.489]         }, condition = base::local({
[10:59:31.489]             c <- base::c
[10:59:31.489]             inherits <- base::inherits
[10:59:31.489]             invokeRestart <- base::invokeRestart
[10:59:31.489]             length <- base::length
[10:59:31.489]             list <- base::list
[10:59:31.489]             seq.int <- base::seq.int
[10:59:31.489]             signalCondition <- base::signalCondition
[10:59:31.489]             sys.calls <- base::sys.calls
[10:59:31.489]             `[[` <- base::`[[`
[10:59:31.489]             `+` <- base::`+`
[10:59:31.489]             `<<-` <- base::`<<-`
[10:59:31.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.489]                   3L)]
[10:59:31.489]             }
[10:59:31.489]             function(cond) {
[10:59:31.489]                 is_error <- inherits(cond, "error")
[10:59:31.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.489]                   NULL)
[10:59:31.489]                 if (is_error) {
[10:59:31.489]                   sessionInformation <- function() {
[10:59:31.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.489]                       search = base::search(), system = base::Sys.info())
[10:59:31.489]                   }
[10:59:31.489]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.489]                     cond$call), session = sessionInformation(), 
[10:59:31.489]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.489]                   signalCondition(cond)
[10:59:31.489]                 }
[10:59:31.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.489]                 "immediateCondition"))) {
[10:59:31.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.489]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.489]                   if (TRUE && !signal) {
[10:59:31.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.489]                     {
[10:59:31.489]                       inherits <- base::inherits
[10:59:31.489]                       invokeRestart <- base::invokeRestart
[10:59:31.489]                       is.null <- base::is.null
[10:59:31.489]                       muffled <- FALSE
[10:59:31.489]                       if (inherits(cond, "message")) {
[10:59:31.489]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.489]                         if (muffled) 
[10:59:31.489]                           invokeRestart("muffleMessage")
[10:59:31.489]                       }
[10:59:31.489]                       else if (inherits(cond, "warning")) {
[10:59:31.489]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.489]                         if (muffled) 
[10:59:31.489]                           invokeRestart("muffleWarning")
[10:59:31.489]                       }
[10:59:31.489]                       else if (inherits(cond, "condition")) {
[10:59:31.489]                         if (!is.null(pattern)) {
[10:59:31.489]                           computeRestarts <- base::computeRestarts
[10:59:31.489]                           grepl <- base::grepl
[10:59:31.489]                           restarts <- computeRestarts(cond)
[10:59:31.489]                           for (restart in restarts) {
[10:59:31.489]                             name <- restart$name
[10:59:31.489]                             if (is.null(name)) 
[10:59:31.489]                               next
[10:59:31.489]                             if (!grepl(pattern, name)) 
[10:59:31.489]                               next
[10:59:31.489]                             invokeRestart(restart)
[10:59:31.489]                             muffled <- TRUE
[10:59:31.489]                             break
[10:59:31.489]                           }
[10:59:31.489]                         }
[10:59:31.489]                       }
[10:59:31.489]                       invisible(muffled)
[10:59:31.489]                     }
[10:59:31.489]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.489]                   }
[10:59:31.489]                 }
[10:59:31.489]                 else {
[10:59:31.489]                   if (TRUE) {
[10:59:31.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.489]                     {
[10:59:31.489]                       inherits <- base::inherits
[10:59:31.489]                       invokeRestart <- base::invokeRestart
[10:59:31.489]                       is.null <- base::is.null
[10:59:31.489]                       muffled <- FALSE
[10:59:31.489]                       if (inherits(cond, "message")) {
[10:59:31.489]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.489]                         if (muffled) 
[10:59:31.489]                           invokeRestart("muffleMessage")
[10:59:31.489]                       }
[10:59:31.489]                       else if (inherits(cond, "warning")) {
[10:59:31.489]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.489]                         if (muffled) 
[10:59:31.489]                           invokeRestart("muffleWarning")
[10:59:31.489]                       }
[10:59:31.489]                       else if (inherits(cond, "condition")) {
[10:59:31.489]                         if (!is.null(pattern)) {
[10:59:31.489]                           computeRestarts <- base::computeRestarts
[10:59:31.489]                           grepl <- base::grepl
[10:59:31.489]                           restarts <- computeRestarts(cond)
[10:59:31.489]                           for (restart in restarts) {
[10:59:31.489]                             name <- restart$name
[10:59:31.489]                             if (is.null(name)) 
[10:59:31.489]                               next
[10:59:31.489]                             if (!grepl(pattern, name)) 
[10:59:31.489]                               next
[10:59:31.489]                             invokeRestart(restart)
[10:59:31.489]                             muffled <- TRUE
[10:59:31.489]                             break
[10:59:31.489]                           }
[10:59:31.489]                         }
[10:59:31.489]                       }
[10:59:31.489]                       invisible(muffled)
[10:59:31.489]                     }
[10:59:31.489]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.489]                   }
[10:59:31.489]                 }
[10:59:31.489]             }
[10:59:31.489]         }))
[10:59:31.489]     }, error = function(ex) {
[10:59:31.489]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.489]                 ...future.rng), started = ...future.startTime, 
[10:59:31.489]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.489]             version = "1.8"), class = "FutureResult")
[10:59:31.489]     }, finally = {
[10:59:31.489]         if (!identical(...future.workdir, getwd())) 
[10:59:31.489]             setwd(...future.workdir)
[10:59:31.489]         {
[10:59:31.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.489]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.489]             }
[10:59:31.489]             base::options(...future.oldOptions)
[10:59:31.489]             if (.Platform$OS.type == "windows") {
[10:59:31.489]                 old_names <- names(...future.oldEnvVars)
[10:59:31.489]                 envs <- base::Sys.getenv()
[10:59:31.489]                 names <- names(envs)
[10:59:31.489]                 common <- intersect(names, old_names)
[10:59:31.489]                 added <- setdiff(names, old_names)
[10:59:31.489]                 removed <- setdiff(old_names, names)
[10:59:31.489]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.489]                   envs[common]]
[10:59:31.489]                 NAMES <- toupper(changed)
[10:59:31.489]                 args <- list()
[10:59:31.489]                 for (kk in seq_along(NAMES)) {
[10:59:31.489]                   name <- changed[[kk]]
[10:59:31.489]                   NAME <- NAMES[[kk]]
[10:59:31.489]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.489]                     next
[10:59:31.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.489]                 }
[10:59:31.489]                 NAMES <- toupper(added)
[10:59:31.489]                 for (kk in seq_along(NAMES)) {
[10:59:31.489]                   name <- added[[kk]]
[10:59:31.489]                   NAME <- NAMES[[kk]]
[10:59:31.489]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.489]                     next
[10:59:31.489]                   args[[name]] <- ""
[10:59:31.489]                 }
[10:59:31.489]                 NAMES <- toupper(removed)
[10:59:31.489]                 for (kk in seq_along(NAMES)) {
[10:59:31.489]                   name <- removed[[kk]]
[10:59:31.489]                   NAME <- NAMES[[kk]]
[10:59:31.489]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.489]                     next
[10:59:31.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.489]                 }
[10:59:31.489]                 if (length(args) > 0) 
[10:59:31.489]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.489]             }
[10:59:31.489]             else {
[10:59:31.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.489]             }
[10:59:31.489]             {
[10:59:31.489]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.489]                   0L) {
[10:59:31.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.489]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.489]                   base::options(opts)
[10:59:31.489]                 }
[10:59:31.489]                 {
[10:59:31.489]                   {
[10:59:31.489]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.489]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.489]                     1047550554L), envir = base::globalenv(), 
[10:59:31.489]                       inherits = FALSE)
[10:59:31.489]                     NULL
[10:59:31.489]                   }
[10:59:31.489]                   options(future.plan = NULL)
[10:59:31.489]                   if (is.na(NA_character_)) 
[10:59:31.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.489]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.489]                     .init = FALSE)
[10:59:31.489]                 }
[10:59:31.489]             }
[10:59:31.489]         }
[10:59:31.489]     })
[10:59:31.489]     if (TRUE) {
[10:59:31.489]         base::sink(type = "output", split = FALSE)
[10:59:31.489]         if (TRUE) {
[10:59:31.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.489]         }
[10:59:31.489]         else {
[10:59:31.489]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.489]         }
[10:59:31.489]         base::close(...future.stdout)
[10:59:31.489]         ...future.stdout <- NULL
[10:59:31.489]     }
[10:59:31.489]     ...future.result$conditions <- ...future.conditions
[10:59:31.489]     ...future.result$finished <- base::Sys.time()
[10:59:31.489]     ...future.result
[10:59:31.489] }
[10:59:31.492] assign_globals() ...
[10:59:31.492] List of 5
[10:59:31.492]  $ ...future.FUN            :function (x)  
[10:59:31.492]  $ MoreArgs                 : list()
[10:59:31.492]  $ ...future.elements_ii    :List of 1
[10:59:31.492]   ..$ :List of 1
[10:59:31.492]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:59:31.492]  $ ...future.seeds_ii       : NULL
[10:59:31.492]  $ ...future.globals.maxSize: NULL
[10:59:31.492]  - attr(*, "where")=List of 5
[10:59:31.492]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.492]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.492]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.492]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.492]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.492]  - attr(*, "resolved")= logi FALSE
[10:59:31.492]  - attr(*, "total_size")= num 370
[10:59:31.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.492]  - attr(*, "already-done")= logi TRUE
[10:59:31.500] - copied ‘...future.FUN’ to environment
[10:59:31.500] - copied ‘MoreArgs’ to environment
[10:59:31.500] - copied ‘...future.elements_ii’ to environment
[10:59:31.500] - copied ‘...future.seeds_ii’ to environment
[10:59:31.500] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.500] assign_globals() ... done
[10:59:31.500] plan(): Setting new future strategy stack:
[10:59:31.500] List of future strategies:
[10:59:31.500] 1. sequential:
[10:59:31.500]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.500]    - tweaked: FALSE
[10:59:31.500]    - call: NULL
[10:59:31.501] plan(): nbrOfWorkers() = 1
[10:59:31.502] plan(): Setting new future strategy stack:
[10:59:31.502] List of future strategies:
[10:59:31.502] 1. sequential:
[10:59:31.502]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.502]    - tweaked: FALSE
[10:59:31.502]    - call: plan(strategy)
[10:59:31.502] plan(): nbrOfWorkers() = 1
[10:59:31.502] SequentialFuture started (and completed)
[10:59:31.502] - Launch lazy future ... done
[10:59:31.502] run() for ‘SequentialFuture’ ... done
[10:59:31.502] Created future:
[10:59:31.503] SequentialFuture:
[10:59:31.503] Label: ‘future_.mapply-1’
[10:59:31.503] Expression:
[10:59:31.503] {
[10:59:31.503]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.503]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.503]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.503]         on.exit(options(oopts), add = TRUE)
[10:59:31.503]     }
[10:59:31.503]     {
[10:59:31.503]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.503]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.503]         do.call(mapply, args = args)
[10:59:31.503]     }
[10:59:31.503] }
[10:59:31.503] Lazy evaluation: FALSE
[10:59:31.503] Asynchronous evaluation: FALSE
[10:59:31.503] Local evaluation: TRUE
[10:59:31.503] Environment: R_GlobalEnv
[10:59:31.503] Capture standard output: TRUE
[10:59:31.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.503] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.503] Packages: <none>
[10:59:31.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.503] Resolved: TRUE
[10:59:31.503] Value: 92 bytes of class ‘list’
[10:59:31.503] Early signaling: FALSE
[10:59:31.503] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.503] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.503] Chunk #1 of 1 ... DONE
[10:59:31.503] Launching 1 futures (chunks) ... DONE
[10:59:31.503] Resolving 1 futures (chunks) ...
[10:59:31.504] resolve() on list ...
[10:59:31.504]  recursive: 0
[10:59:31.504]  length: 1
[10:59:31.504] 
[10:59:31.504] resolved() for ‘SequentialFuture’ ...
[10:59:31.504] - state: ‘finished’
[10:59:31.504] - run: TRUE
[10:59:31.504] - result: ‘FutureResult’
[10:59:31.504] resolved() for ‘SequentialFuture’ ... done
[10:59:31.504] Future #1
[10:59:31.504] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.505] - nx: 1
[10:59:31.505] - relay: TRUE
[10:59:31.505] - stdout: TRUE
[10:59:31.505] - signal: TRUE
[10:59:31.505] - resignal: FALSE
[10:59:31.505] - force: TRUE
[10:59:31.505] - relayed: [n=1] FALSE
[10:59:31.505] - queued futures: [n=1] FALSE
[10:59:31.505]  - until=1
[10:59:31.505]  - relaying element #1
[10:59:31.505] - relayed: [n=1] TRUE
[10:59:31.505] - queued futures: [n=1] TRUE
[10:59:31.506] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.506]  length: 0 (resolved future 1)
[10:59:31.506] Relaying remaining futures
[10:59:31.506] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.506] - nx: 1
[10:59:31.506] - relay: TRUE
[10:59:31.506] - stdout: TRUE
[10:59:31.506] - signal: TRUE
[10:59:31.506] - resignal: FALSE
[10:59:31.506] - force: TRUE
[10:59:31.506] - relayed: [n=1] TRUE
[10:59:31.506] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.507] - relayed: [n=1] TRUE
[10:59:31.507] - queued futures: [n=1] TRUE
[10:59:31.507] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.507] resolve() on list ... DONE
[10:59:31.507]  - Number of value chunks collected: 1
[10:59:31.507] Resolving 1 futures (chunks) ... DONE
[10:59:31.507] Reducing values from 1 chunks ...
[10:59:31.507]  - Number of values collected after concatenation: 1
[10:59:31.507]  - Number of values expected: 1
[10:59:31.507] Reducing values from 1 chunks ... DONE
[10:59:31.507] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:59:31.508] future_mapply() ...
[10:59:31.508] Number of chunks: 1
[10:59:31.508] getGlobalsAndPackagesXApply() ...
[10:59:31.508]  - future.globals: TRUE
[10:59:31.508] getGlobalsAndPackages() ...
[10:59:31.508] Searching for globals...
[10:59:31.509] - globals found: [1] ‘FUN’
[10:59:31.509] Searching for globals ... DONE
[10:59:31.509] Resolving globals: FALSE
[10:59:31.509] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:31.510] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:31.510] - globals: [1] ‘FUN’
[10:59:31.510] 
[10:59:31.510] getGlobalsAndPackages() ... DONE
[10:59:31.510]  - globals found/used: [n=1] ‘FUN’
[10:59:31.510]  - needed namespaces: [n=0] 
[10:59:31.510] Finding globals ... DONE
[10:59:31.510] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.511] List of 2
[10:59:31.511]  $ ...future.FUN:function (x, y)  
[10:59:31.511]  $ MoreArgs     :List of 1
[10:59:31.511]   ..$ y: int [1:2] 3 4
[10:59:31.511]  - attr(*, "where")=List of 2
[10:59:31.511]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.511]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.511]  - attr(*, "resolved")= logi FALSE
[10:59:31.511]  - attr(*, "total_size")= num NA
[10:59:31.513] Packages to be attached in all futures: [n=0] 
[10:59:31.513] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.513] Number of futures (= number of chunks): 1
[10:59:31.514] Launching 1 futures (chunks) ...
[10:59:31.514] Chunk #1 of 1 ...
[10:59:31.514]  - Finding globals in '...' for chunk #1 ...
[10:59:31.514] getGlobalsAndPackages() ...
[10:59:31.514] Searching for globals...
[10:59:31.514] 
[10:59:31.514] Searching for globals ... DONE
[10:59:31.514] - globals: [0] <none>
[10:59:31.514] getGlobalsAndPackages() ... DONE
[10:59:31.514]    + additional globals found: [n=0] 
[10:59:31.515]    + additional namespaces needed: [n=0] 
[10:59:31.515]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.515]  - seeds: <none>
[10:59:31.515]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.515] getGlobalsAndPackages() ...
[10:59:31.515] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.515] Resolving globals: FALSE
[10:59:31.515] The total size of the 5 globals is 668 bytes (668 bytes)
[10:59:31.516] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 668 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[10:59:31.516] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.516] 
[10:59:31.516] getGlobalsAndPackages() ... DONE
[10:59:31.516] run() for ‘Future’ ...
[10:59:31.517] - state: ‘created’
[10:59:31.517] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.517] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.517] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.517]   - Field: ‘label’
[10:59:31.517]   - Field: ‘local’
[10:59:31.518]   - Field: ‘owner’
[10:59:31.518]   - Field: ‘envir’
[10:59:31.518]   - Field: ‘packages’
[10:59:31.519]   - Field: ‘gc’
[10:59:31.519]   - Field: ‘conditions’
[10:59:31.519]   - Field: ‘expr’
[10:59:31.519]   - Field: ‘uuid’
[10:59:31.519]   - Field: ‘seed’
[10:59:31.519]   - Field: ‘version’
[10:59:31.519]   - Field: ‘result’
[10:59:31.519]   - Field: ‘asynchronous’
[10:59:31.519]   - Field: ‘calls’
[10:59:31.519]   - Field: ‘globals’
[10:59:31.519]   - Field: ‘stdout’
[10:59:31.519]   - Field: ‘earlySignal’
[10:59:31.520]   - Field: ‘lazy’
[10:59:31.520]   - Field: ‘state’
[10:59:31.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.520] - Launch lazy future ...
[10:59:31.520] Packages needed by the future expression (n = 0): <none>
[10:59:31.520] Packages needed by future strategies (n = 0): <none>
[10:59:31.520] {
[10:59:31.520]     {
[10:59:31.520]         {
[10:59:31.520]             ...future.startTime <- base::Sys.time()
[10:59:31.520]             {
[10:59:31.520]                 {
[10:59:31.520]                   {
[10:59:31.520]                     base::local({
[10:59:31.520]                       has_future <- base::requireNamespace("future", 
[10:59:31.520]                         quietly = TRUE)
[10:59:31.520]                       if (has_future) {
[10:59:31.520]                         ns <- base::getNamespace("future")
[10:59:31.520]                         version <- ns[[".package"]][["version"]]
[10:59:31.520]                         if (is.null(version)) 
[10:59:31.520]                           version <- utils::packageVersion("future")
[10:59:31.520]                       }
[10:59:31.520]                       else {
[10:59:31.520]                         version <- NULL
[10:59:31.520]                       }
[10:59:31.520]                       if (!has_future || version < "1.8.0") {
[10:59:31.520]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.520]                           "", base::R.version$version.string), 
[10:59:31.520]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.520]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.520]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.520]                             "release", "version")], collapse = " "), 
[10:59:31.520]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.520]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.520]                           info)
[10:59:31.520]                         info <- base::paste(info, collapse = "; ")
[10:59:31.520]                         if (!has_future) {
[10:59:31.520]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.520]                             info)
[10:59:31.520]                         }
[10:59:31.520]                         else {
[10:59:31.520]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.520]                             info, version)
[10:59:31.520]                         }
[10:59:31.520]                         base::stop(msg)
[10:59:31.520]                       }
[10:59:31.520]                     })
[10:59:31.520]                   }
[10:59:31.520]                   ...future.strategy.old <- future::plan("list")
[10:59:31.520]                   options(future.plan = NULL)
[10:59:31.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.520]                 }
[10:59:31.520]                 ...future.workdir <- getwd()
[10:59:31.520]             }
[10:59:31.520]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.520]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.520]         }
[10:59:31.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.520]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.520]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.520]             base::names(...future.oldOptions))
[10:59:31.520]     }
[10:59:31.520]     if (FALSE) {
[10:59:31.520]     }
[10:59:31.520]     else {
[10:59:31.520]         if (TRUE) {
[10:59:31.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.520]                 open = "w")
[10:59:31.520]         }
[10:59:31.520]         else {
[10:59:31.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.520]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.520]         }
[10:59:31.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.520]             base::sink(type = "output", split = FALSE)
[10:59:31.520]             base::close(...future.stdout)
[10:59:31.520]         }, add = TRUE)
[10:59:31.520]     }
[10:59:31.520]     ...future.frame <- base::sys.nframe()
[10:59:31.520]     ...future.conditions <- base::list()
[10:59:31.520]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.520]     if (FALSE) {
[10:59:31.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.520]     }
[10:59:31.520]     ...future.result <- base::tryCatch({
[10:59:31.520]         base::withCallingHandlers({
[10:59:31.520]             ...future.value <- base::withVisible(base::local({
[10:59:31.520]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.520]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.520]                   ...future.globals.maxSize)) {
[10:59:31.520]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.520]                   on.exit(options(oopts), add = TRUE)
[10:59:31.520]                 }
[10:59:31.520]                 {
[10:59:31.520]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.520]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.520]                     USE.NAMES = FALSE)
[10:59:31.520]                   do.call(mapply, args = args)
[10:59:31.520]                 }
[10:59:31.520]             }))
[10:59:31.520]             future::FutureResult(value = ...future.value$value, 
[10:59:31.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.520]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.520]                     ...future.globalenv.names))
[10:59:31.520]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.520]         }, condition = base::local({
[10:59:31.520]             c <- base::c
[10:59:31.520]             inherits <- base::inherits
[10:59:31.520]             invokeRestart <- base::invokeRestart
[10:59:31.520]             length <- base::length
[10:59:31.520]             list <- base::list
[10:59:31.520]             seq.int <- base::seq.int
[10:59:31.520]             signalCondition <- base::signalCondition
[10:59:31.520]             sys.calls <- base::sys.calls
[10:59:31.520]             `[[` <- base::`[[`
[10:59:31.520]             `+` <- base::`+`
[10:59:31.520]             `<<-` <- base::`<<-`
[10:59:31.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.520]                   3L)]
[10:59:31.520]             }
[10:59:31.520]             function(cond) {
[10:59:31.520]                 is_error <- inherits(cond, "error")
[10:59:31.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.520]                   NULL)
[10:59:31.520]                 if (is_error) {
[10:59:31.520]                   sessionInformation <- function() {
[10:59:31.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.520]                       search = base::search(), system = base::Sys.info())
[10:59:31.520]                   }
[10:59:31.520]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.520]                     cond$call), session = sessionInformation(), 
[10:59:31.520]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.520]                   signalCondition(cond)
[10:59:31.520]                 }
[10:59:31.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.520]                 "immediateCondition"))) {
[10:59:31.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.520]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.520]                   if (TRUE && !signal) {
[10:59:31.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.520]                     {
[10:59:31.520]                       inherits <- base::inherits
[10:59:31.520]                       invokeRestart <- base::invokeRestart
[10:59:31.520]                       is.null <- base::is.null
[10:59:31.520]                       muffled <- FALSE
[10:59:31.520]                       if (inherits(cond, "message")) {
[10:59:31.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.520]                         if (muffled) 
[10:59:31.520]                           invokeRestart("muffleMessage")
[10:59:31.520]                       }
[10:59:31.520]                       else if (inherits(cond, "warning")) {
[10:59:31.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.520]                         if (muffled) 
[10:59:31.520]                           invokeRestart("muffleWarning")
[10:59:31.520]                       }
[10:59:31.520]                       else if (inherits(cond, "condition")) {
[10:59:31.520]                         if (!is.null(pattern)) {
[10:59:31.520]                           computeRestarts <- base::computeRestarts
[10:59:31.520]                           grepl <- base::grepl
[10:59:31.520]                           restarts <- computeRestarts(cond)
[10:59:31.520]                           for (restart in restarts) {
[10:59:31.520]                             name <- restart$name
[10:59:31.520]                             if (is.null(name)) 
[10:59:31.520]                               next
[10:59:31.520]                             if (!grepl(pattern, name)) 
[10:59:31.520]                               next
[10:59:31.520]                             invokeRestart(restart)
[10:59:31.520]                             muffled <- TRUE
[10:59:31.520]                             break
[10:59:31.520]                           }
[10:59:31.520]                         }
[10:59:31.520]                       }
[10:59:31.520]                       invisible(muffled)
[10:59:31.520]                     }
[10:59:31.520]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.520]                   }
[10:59:31.520]                 }
[10:59:31.520]                 else {
[10:59:31.520]                   if (TRUE) {
[10:59:31.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.520]                     {
[10:59:31.520]                       inherits <- base::inherits
[10:59:31.520]                       invokeRestart <- base::invokeRestart
[10:59:31.520]                       is.null <- base::is.null
[10:59:31.520]                       muffled <- FALSE
[10:59:31.520]                       if (inherits(cond, "message")) {
[10:59:31.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.520]                         if (muffled) 
[10:59:31.520]                           invokeRestart("muffleMessage")
[10:59:31.520]                       }
[10:59:31.520]                       else if (inherits(cond, "warning")) {
[10:59:31.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.520]                         if (muffled) 
[10:59:31.520]                           invokeRestart("muffleWarning")
[10:59:31.520]                       }
[10:59:31.520]                       else if (inherits(cond, "condition")) {
[10:59:31.520]                         if (!is.null(pattern)) {
[10:59:31.520]                           computeRestarts <- base::computeRestarts
[10:59:31.520]                           grepl <- base::grepl
[10:59:31.520]                           restarts <- computeRestarts(cond)
[10:59:31.520]                           for (restart in restarts) {
[10:59:31.520]                             name <- restart$name
[10:59:31.520]                             if (is.null(name)) 
[10:59:31.520]                               next
[10:59:31.520]                             if (!grepl(pattern, name)) 
[10:59:31.520]                               next
[10:59:31.520]                             invokeRestart(restart)
[10:59:31.520]                             muffled <- TRUE
[10:59:31.520]                             break
[10:59:31.520]                           }
[10:59:31.520]                         }
[10:59:31.520]                       }
[10:59:31.520]                       invisible(muffled)
[10:59:31.520]                     }
[10:59:31.520]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.520]                   }
[10:59:31.520]                 }
[10:59:31.520]             }
[10:59:31.520]         }))
[10:59:31.520]     }, error = function(ex) {
[10:59:31.520]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.520]                 ...future.rng), started = ...future.startTime, 
[10:59:31.520]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.520]             version = "1.8"), class = "FutureResult")
[10:59:31.520]     }, finally = {
[10:59:31.520]         if (!identical(...future.workdir, getwd())) 
[10:59:31.520]             setwd(...future.workdir)
[10:59:31.520]         {
[10:59:31.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.520]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.520]             }
[10:59:31.520]             base::options(...future.oldOptions)
[10:59:31.520]             if (.Platform$OS.type == "windows") {
[10:59:31.520]                 old_names <- names(...future.oldEnvVars)
[10:59:31.520]                 envs <- base::Sys.getenv()
[10:59:31.520]                 names <- names(envs)
[10:59:31.520]                 common <- intersect(names, old_names)
[10:59:31.520]                 added <- setdiff(names, old_names)
[10:59:31.520]                 removed <- setdiff(old_names, names)
[10:59:31.520]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.520]                   envs[common]]
[10:59:31.520]                 NAMES <- toupper(changed)
[10:59:31.520]                 args <- list()
[10:59:31.520]                 for (kk in seq_along(NAMES)) {
[10:59:31.520]                   name <- changed[[kk]]
[10:59:31.520]                   NAME <- NAMES[[kk]]
[10:59:31.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.520]                     next
[10:59:31.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.520]                 }
[10:59:31.520]                 NAMES <- toupper(added)
[10:59:31.520]                 for (kk in seq_along(NAMES)) {
[10:59:31.520]                   name <- added[[kk]]
[10:59:31.520]                   NAME <- NAMES[[kk]]
[10:59:31.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.520]                     next
[10:59:31.520]                   args[[name]] <- ""
[10:59:31.520]                 }
[10:59:31.520]                 NAMES <- toupper(removed)
[10:59:31.520]                 for (kk in seq_along(NAMES)) {
[10:59:31.520]                   name <- removed[[kk]]
[10:59:31.520]                   NAME <- NAMES[[kk]]
[10:59:31.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.520]                     next
[10:59:31.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.520]                 }
[10:59:31.520]                 if (length(args) > 0) 
[10:59:31.520]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.520]             }
[10:59:31.520]             else {
[10:59:31.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.520]             }
[10:59:31.520]             {
[10:59:31.520]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.520]                   0L) {
[10:59:31.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.520]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.520]                   base::options(opts)
[10:59:31.520]                 }
[10:59:31.520]                 {
[10:59:31.520]                   {
[10:59:31.520]                     base::assign(".Random.seed", c(10407L, -1869012937L, 
[10:59:31.520]                     894550048L, -1027017971L, 1041286842L, -199511037L, 
[10:59:31.520]                     1047550554L), envir = base::globalenv(), 
[10:59:31.520]                       inherits = FALSE)
[10:59:31.520]                     NULL
[10:59:31.520]                   }
[10:59:31.520]                   options(future.plan = NULL)
[10:59:31.520]                   if (is.na(NA_character_)) 
[10:59:31.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.520]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.520]                     .init = FALSE)
[10:59:31.520]                 }
[10:59:31.520]             }
[10:59:31.520]         }
[10:59:31.520]     })
[10:59:31.520]     if (TRUE) {
[10:59:31.520]         base::sink(type = "output", split = FALSE)
[10:59:31.520]         if (TRUE) {
[10:59:31.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.520]         }
[10:59:31.520]         else {
[10:59:31.520]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.520]         }
[10:59:31.520]         base::close(...future.stdout)
[10:59:31.520]         ...future.stdout <- NULL
[10:59:31.520]     }
[10:59:31.520]     ...future.result$conditions <- ...future.conditions
[10:59:31.520]     ...future.result$finished <- base::Sys.time()
[10:59:31.520]     ...future.result
[10:59:31.520] }
[10:59:31.522] assign_globals() ...
[10:59:31.522] List of 5
[10:59:31.522]  $ ...future.FUN            :function (x, y)  
[10:59:31.522]  $ MoreArgs                 :List of 1
[10:59:31.522]   ..$ y: int [1:2] 3 4
[10:59:31.522]  $ ...future.elements_ii    :List of 1
[10:59:31.522]   ..$ x:List of 2
[10:59:31.522]   .. ..$ : int 1
[10:59:31.522]   .. ..$ : int 2
[10:59:31.522]  $ ...future.seeds_ii       : NULL
[10:59:31.522]  $ ...future.globals.maxSize: NULL
[10:59:31.522]  - attr(*, "where")=List of 5
[10:59:31.522]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.522]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.522]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.522]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.522]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.522]  - attr(*, "resolved")= logi FALSE
[10:59:31.522]  - attr(*, "total_size")= num 668
[10:59:31.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.522]  - attr(*, "already-done")= logi TRUE
[10:59:31.527] - reassign environment for ‘...future.FUN’
[10:59:31.527] - copied ‘...future.FUN’ to environment
[10:59:31.527] - copied ‘MoreArgs’ to environment
[10:59:31.527] - copied ‘...future.elements_ii’ to environment
[10:59:31.527] - copied ‘...future.seeds_ii’ to environment
[10:59:31.527] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.527] assign_globals() ... done
[10:59:31.528] plan(): Setting new future strategy stack:
[10:59:31.528] List of future strategies:
[10:59:31.528] 1. sequential:
[10:59:31.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.528]    - tweaked: FALSE
[10:59:31.528]    - call: NULL
[10:59:31.528] plan(): nbrOfWorkers() = 1
[10:59:31.529] plan(): Setting new future strategy stack:
[10:59:31.529] List of future strategies:
[10:59:31.529] 1. sequential:
[10:59:31.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.529]    - tweaked: FALSE
[10:59:31.529]    - call: plan(strategy)
[10:59:31.529] plan(): nbrOfWorkers() = 1
[10:59:31.530] SequentialFuture started (and completed)
[10:59:31.530] - Launch lazy future ... done
[10:59:31.530] run() for ‘SequentialFuture’ ... done
[10:59:31.530] Created future:
[10:59:31.530] SequentialFuture:
[10:59:31.530] Label: ‘future_mapply-1’
[10:59:31.530] Expression:
[10:59:31.530] {
[10:59:31.530]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.530]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.530]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.530]         on.exit(options(oopts), add = TRUE)
[10:59:31.530]     }
[10:59:31.530]     {
[10:59:31.530]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.530]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.530]         do.call(mapply, args = args)
[10:59:31.530]     }
[10:59:31.530] }
[10:59:31.530] Lazy evaluation: FALSE
[10:59:31.530] Asynchronous evaluation: FALSE
[10:59:31.530] Local evaluation: TRUE
[10:59:31.530] Environment: R_GlobalEnv
[10:59:31.530] Capture standard output: TRUE
[10:59:31.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.530] Globals: 5 objects totaling 668 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.530] Packages: <none>
[10:59:31.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.530] Resolved: TRUE
[10:59:31.530] Value: 217 bytes of class ‘list’
[10:59:31.530] Early signaling: FALSE
[10:59:31.530] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.530] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.531] Chunk #1 of 1 ... DONE
[10:59:31.531] Launching 1 futures (chunks) ... DONE
[10:59:31.531] Resolving 1 futures (chunks) ...
[10:59:31.531] resolve() on list ...
[10:59:31.531]  recursive: 0
[10:59:31.531]  length: 1
[10:59:31.531] 
[10:59:31.531] resolved() for ‘SequentialFuture’ ...
[10:59:31.531] - state: ‘finished’
[10:59:31.532] - run: TRUE
[10:59:31.532] - result: ‘FutureResult’
[10:59:31.532] resolved() for ‘SequentialFuture’ ... done
[10:59:31.532] Future #1
[10:59:31.532] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.532] - nx: 1
[10:59:31.532] - relay: TRUE
[10:59:31.532] - stdout: TRUE
[10:59:31.532] - signal: TRUE
[10:59:31.532] - resignal: FALSE
[10:59:31.532] - force: TRUE
[10:59:31.532] - relayed: [n=1] FALSE
[10:59:31.532] - queued futures: [n=1] FALSE
[10:59:31.533]  - until=1
[10:59:31.533]  - relaying element #1
[10:59:31.533] - relayed: [n=1] TRUE
[10:59:31.533] - queued futures: [n=1] TRUE
[10:59:31.533] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.533]  length: 0 (resolved future 1)
[10:59:31.533] Relaying remaining futures
[10:59:31.533] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.533] - nx: 1
[10:59:31.533] - relay: TRUE
[10:59:31.533] - stdout: TRUE
[10:59:31.533] - signal: TRUE
[10:59:31.534] - resignal: FALSE
[10:59:31.534] - force: TRUE
[10:59:31.534] - relayed: [n=1] TRUE
[10:59:31.534] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.534] - relayed: [n=1] TRUE
[10:59:31.534] - queued futures: [n=1] TRUE
[10:59:31.534] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.534] resolve() on list ... DONE
[10:59:31.534]  - Number of value chunks collected: 1
[10:59:31.534] Resolving 1 futures (chunks) ... DONE
[10:59:31.534] Reducing values from 1 chunks ...
[10:59:31.534]  - Number of values collected after concatenation: 2
[10:59:31.535]  - Number of values expected: 2
[10:59:31.535] Reducing values from 1 chunks ... DONE
[10:59:31.535] future_mapply() ... DONE
[10:59:31.535] future_mapply() ...
[10:59:31.535] Generating random seeds ...
[10:59:31.535] Generating random seed streams for 2 elements ...
[10:59:31.535] Generating random seed streams for 2 elements ... DONE
[10:59:31.535] Generating random seeds ... DONE
[10:59:31.535] Will set RNG state on exit: 10407, -1027017971, -84354130, -480752092, 1047550554, 409668568, -1174182659
[10:59:31.535] Number of chunks: 1
[10:59:31.536] getGlobalsAndPackagesXApply() ...
[10:59:31.536]  - future.globals: TRUE
[10:59:31.536] getGlobalsAndPackages() ...
[10:59:31.536] Searching for globals...
[10:59:31.537] - globals found: [1] ‘FUN’
[10:59:31.537] Searching for globals ... DONE
[10:59:31.537] Resolving globals: FALSE
[10:59:31.537] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:31.537] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:31.537] - globals: [1] ‘FUN’
[10:59:31.538] 
[10:59:31.538] getGlobalsAndPackages() ... DONE
[10:59:31.538]  - globals found/used: [n=1] ‘FUN’
[10:59:31.538]  - needed namespaces: [n=0] 
[10:59:31.538] Finding globals ... DONE
[10:59:31.538] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.538] List of 2
[10:59:31.538]  $ ...future.FUN:function (x, y)  
[10:59:31.538]  $ MoreArgs     :List of 1
[10:59:31.538]   ..$ y: int [1:2] 3 4
[10:59:31.538]  - attr(*, "where")=List of 2
[10:59:31.538]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.538]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.538]  - attr(*, "resolved")= logi FALSE
[10:59:31.538]  - attr(*, "total_size")= num NA
[10:59:31.542] Packages to be attached in all futures: [n=0] 
[10:59:31.542] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.542] Number of futures (= number of chunks): 1
[10:59:31.542] Launching 1 futures (chunks) ...
[10:59:31.542] Chunk #1 of 1 ...
[10:59:31.542]  - Finding globals in '...' for chunk #1 ...
[10:59:31.542] getGlobalsAndPackages() ...
[10:59:31.542] Searching for globals...
[10:59:31.543] 
[10:59:31.543] Searching for globals ... DONE
[10:59:31.543] - globals: [0] <none>
[10:59:31.543] getGlobalsAndPackages() ... DONE
[10:59:31.543]    + additional globals found: [n=0] 
[10:59:31.543]    + additional namespaces needed: [n=0] 
[10:59:31.543]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.543]  - seeds: [2] <seeds>
[10:59:31.543]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.543] getGlobalsAndPackages() ...
[10:59:31.543] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.544] Resolving globals: FALSE
[10:59:31.544] The total size of the 5 globals is 744 bytes (744 bytes)
[10:59:31.544] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 744 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[10:59:31.544] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.545] 
[10:59:31.545] getGlobalsAndPackages() ... DONE
[10:59:31.545] run() for ‘Future’ ...
[10:59:31.545] - state: ‘created’
[10:59:31.545] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.545]   - Field: ‘label’
[10:59:31.546]   - Field: ‘local’
[10:59:31.546]   - Field: ‘owner’
[10:59:31.546]   - Field: ‘envir’
[10:59:31.546]   - Field: ‘packages’
[10:59:31.546]   - Field: ‘gc’
[10:59:31.546]   - Field: ‘conditions’
[10:59:31.546]   - Field: ‘expr’
[10:59:31.546]   - Field: ‘uuid’
[10:59:31.546]   - Field: ‘seed’
[10:59:31.546]   - Field: ‘version’
[10:59:31.546]   - Field: ‘result’
[10:59:31.546]   - Field: ‘asynchronous’
[10:59:31.547]   - Field: ‘calls’
[10:59:31.547]   - Field: ‘globals’
[10:59:31.547]   - Field: ‘stdout’
[10:59:31.547]   - Field: ‘earlySignal’
[10:59:31.547]   - Field: ‘lazy’
[10:59:31.547]   - Field: ‘state’
[10:59:31.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.547] - Launch lazy future ...
[10:59:31.547] Packages needed by the future expression (n = 0): <none>
[10:59:31.547] Packages needed by future strategies (n = 0): <none>
[10:59:31.548] {
[10:59:31.548]     {
[10:59:31.548]         {
[10:59:31.548]             ...future.startTime <- base::Sys.time()
[10:59:31.548]             {
[10:59:31.548]                 {
[10:59:31.548]                   {
[10:59:31.548]                     base::local({
[10:59:31.548]                       has_future <- base::requireNamespace("future", 
[10:59:31.548]                         quietly = TRUE)
[10:59:31.548]                       if (has_future) {
[10:59:31.548]                         ns <- base::getNamespace("future")
[10:59:31.548]                         version <- ns[[".package"]][["version"]]
[10:59:31.548]                         if (is.null(version)) 
[10:59:31.548]                           version <- utils::packageVersion("future")
[10:59:31.548]                       }
[10:59:31.548]                       else {
[10:59:31.548]                         version <- NULL
[10:59:31.548]                       }
[10:59:31.548]                       if (!has_future || version < "1.8.0") {
[10:59:31.548]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.548]                           "", base::R.version$version.string), 
[10:59:31.548]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.548]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.548]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.548]                             "release", "version")], collapse = " "), 
[10:59:31.548]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.548]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.548]                           info)
[10:59:31.548]                         info <- base::paste(info, collapse = "; ")
[10:59:31.548]                         if (!has_future) {
[10:59:31.548]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.548]                             info)
[10:59:31.548]                         }
[10:59:31.548]                         else {
[10:59:31.548]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.548]                             info, version)
[10:59:31.548]                         }
[10:59:31.548]                         base::stop(msg)
[10:59:31.548]                       }
[10:59:31.548]                     })
[10:59:31.548]                   }
[10:59:31.548]                   ...future.strategy.old <- future::plan("list")
[10:59:31.548]                   options(future.plan = NULL)
[10:59:31.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.548]                 }
[10:59:31.548]                 ...future.workdir <- getwd()
[10:59:31.548]             }
[10:59:31.548]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.548]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.548]         }
[10:59:31.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.548]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.548]             base::names(...future.oldOptions))
[10:59:31.548]     }
[10:59:31.548]     if (FALSE) {
[10:59:31.548]     }
[10:59:31.548]     else {
[10:59:31.548]         if (TRUE) {
[10:59:31.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.548]                 open = "w")
[10:59:31.548]         }
[10:59:31.548]         else {
[10:59:31.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.548]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.548]         }
[10:59:31.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.548]             base::sink(type = "output", split = FALSE)
[10:59:31.548]             base::close(...future.stdout)
[10:59:31.548]         }, add = TRUE)
[10:59:31.548]     }
[10:59:31.548]     ...future.frame <- base::sys.nframe()
[10:59:31.548]     ...future.conditions <- base::list()
[10:59:31.548]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.548]     if (FALSE) {
[10:59:31.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.548]     }
[10:59:31.548]     ...future.result <- base::tryCatch({
[10:59:31.548]         base::withCallingHandlers({
[10:59:31.548]             ...future.value <- base::withVisible(base::local({
[10:59:31.548]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.548]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.548]                   ...future.globals.maxSize)) {
[10:59:31.548]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.548]                   on.exit(options(oopts), add = TRUE)
[10:59:31.548]                 }
[10:59:31.548]                 {
[10:59:31.548]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:31.548]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:31.548]                       envir = globalenv(), inherits = FALSE)
[10:59:31.548]                     ...future.FUN(...)
[10:59:31.548]                   }
[10:59:31.548]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:31.548]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:31.548]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.548]                     USE.NAMES = FALSE)
[10:59:31.548]                   do.call(mapply, args = args)
[10:59:31.548]                 }
[10:59:31.548]             }))
[10:59:31.548]             future::FutureResult(value = ...future.value$value, 
[10:59:31.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.548]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.548]                     ...future.globalenv.names))
[10:59:31.548]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.548]         }, condition = base::local({
[10:59:31.548]             c <- base::c
[10:59:31.548]             inherits <- base::inherits
[10:59:31.548]             invokeRestart <- base::invokeRestart
[10:59:31.548]             length <- base::length
[10:59:31.548]             list <- base::list
[10:59:31.548]             seq.int <- base::seq.int
[10:59:31.548]             signalCondition <- base::signalCondition
[10:59:31.548]             sys.calls <- base::sys.calls
[10:59:31.548]             `[[` <- base::`[[`
[10:59:31.548]             `+` <- base::`+`
[10:59:31.548]             `<<-` <- base::`<<-`
[10:59:31.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.548]                   3L)]
[10:59:31.548]             }
[10:59:31.548]             function(cond) {
[10:59:31.548]                 is_error <- inherits(cond, "error")
[10:59:31.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.548]                   NULL)
[10:59:31.548]                 if (is_error) {
[10:59:31.548]                   sessionInformation <- function() {
[10:59:31.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.548]                       search = base::search(), system = base::Sys.info())
[10:59:31.548]                   }
[10:59:31.548]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.548]                     cond$call), session = sessionInformation(), 
[10:59:31.548]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.548]                   signalCondition(cond)
[10:59:31.548]                 }
[10:59:31.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.548]                 "immediateCondition"))) {
[10:59:31.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.548]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.548]                   if (TRUE && !signal) {
[10:59:31.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.548]                     {
[10:59:31.548]                       inherits <- base::inherits
[10:59:31.548]                       invokeRestart <- base::invokeRestart
[10:59:31.548]                       is.null <- base::is.null
[10:59:31.548]                       muffled <- FALSE
[10:59:31.548]                       if (inherits(cond, "message")) {
[10:59:31.548]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.548]                         if (muffled) 
[10:59:31.548]                           invokeRestart("muffleMessage")
[10:59:31.548]                       }
[10:59:31.548]                       else if (inherits(cond, "warning")) {
[10:59:31.548]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.548]                         if (muffled) 
[10:59:31.548]                           invokeRestart("muffleWarning")
[10:59:31.548]                       }
[10:59:31.548]                       else if (inherits(cond, "condition")) {
[10:59:31.548]                         if (!is.null(pattern)) {
[10:59:31.548]                           computeRestarts <- base::computeRestarts
[10:59:31.548]                           grepl <- base::grepl
[10:59:31.548]                           restarts <- computeRestarts(cond)
[10:59:31.548]                           for (restart in restarts) {
[10:59:31.548]                             name <- restart$name
[10:59:31.548]                             if (is.null(name)) 
[10:59:31.548]                               next
[10:59:31.548]                             if (!grepl(pattern, name)) 
[10:59:31.548]                               next
[10:59:31.548]                             invokeRestart(restart)
[10:59:31.548]                             muffled <- TRUE
[10:59:31.548]                             break
[10:59:31.548]                           }
[10:59:31.548]                         }
[10:59:31.548]                       }
[10:59:31.548]                       invisible(muffled)
[10:59:31.548]                     }
[10:59:31.548]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.548]                   }
[10:59:31.548]                 }
[10:59:31.548]                 else {
[10:59:31.548]                   if (TRUE) {
[10:59:31.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.548]                     {
[10:59:31.548]                       inherits <- base::inherits
[10:59:31.548]                       invokeRestart <- base::invokeRestart
[10:59:31.548]                       is.null <- base::is.null
[10:59:31.548]                       muffled <- FALSE
[10:59:31.548]                       if (inherits(cond, "message")) {
[10:59:31.548]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.548]                         if (muffled) 
[10:59:31.548]                           invokeRestart("muffleMessage")
[10:59:31.548]                       }
[10:59:31.548]                       else if (inherits(cond, "warning")) {
[10:59:31.548]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.548]                         if (muffled) 
[10:59:31.548]                           invokeRestart("muffleWarning")
[10:59:31.548]                       }
[10:59:31.548]                       else if (inherits(cond, "condition")) {
[10:59:31.548]                         if (!is.null(pattern)) {
[10:59:31.548]                           computeRestarts <- base::computeRestarts
[10:59:31.548]                           grepl <- base::grepl
[10:59:31.548]                           restarts <- computeRestarts(cond)
[10:59:31.548]                           for (restart in restarts) {
[10:59:31.548]                             name <- restart$name
[10:59:31.548]                             if (is.null(name)) 
[10:59:31.548]                               next
[10:59:31.548]                             if (!grepl(pattern, name)) 
[10:59:31.548]                               next
[10:59:31.548]                             invokeRestart(restart)
[10:59:31.548]                             muffled <- TRUE
[10:59:31.548]                             break
[10:59:31.548]                           }
[10:59:31.548]                         }
[10:59:31.548]                       }
[10:59:31.548]                       invisible(muffled)
[10:59:31.548]                     }
[10:59:31.548]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.548]                   }
[10:59:31.548]                 }
[10:59:31.548]             }
[10:59:31.548]         }))
[10:59:31.548]     }, error = function(ex) {
[10:59:31.548]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.548]                 ...future.rng), started = ...future.startTime, 
[10:59:31.548]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.548]             version = "1.8"), class = "FutureResult")
[10:59:31.548]     }, finally = {
[10:59:31.548]         if (!identical(...future.workdir, getwd())) 
[10:59:31.548]             setwd(...future.workdir)
[10:59:31.548]         {
[10:59:31.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.548]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.548]             }
[10:59:31.548]             base::options(...future.oldOptions)
[10:59:31.548]             if (.Platform$OS.type == "windows") {
[10:59:31.548]                 old_names <- names(...future.oldEnvVars)
[10:59:31.548]                 envs <- base::Sys.getenv()
[10:59:31.548]                 names <- names(envs)
[10:59:31.548]                 common <- intersect(names, old_names)
[10:59:31.548]                 added <- setdiff(names, old_names)
[10:59:31.548]                 removed <- setdiff(old_names, names)
[10:59:31.548]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.548]                   envs[common]]
[10:59:31.548]                 NAMES <- toupper(changed)
[10:59:31.548]                 args <- list()
[10:59:31.548]                 for (kk in seq_along(NAMES)) {
[10:59:31.548]                   name <- changed[[kk]]
[10:59:31.548]                   NAME <- NAMES[[kk]]
[10:59:31.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.548]                     next
[10:59:31.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.548]                 }
[10:59:31.548]                 NAMES <- toupper(added)
[10:59:31.548]                 for (kk in seq_along(NAMES)) {
[10:59:31.548]                   name <- added[[kk]]
[10:59:31.548]                   NAME <- NAMES[[kk]]
[10:59:31.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.548]                     next
[10:59:31.548]                   args[[name]] <- ""
[10:59:31.548]                 }
[10:59:31.548]                 NAMES <- toupper(removed)
[10:59:31.548]                 for (kk in seq_along(NAMES)) {
[10:59:31.548]                   name <- removed[[kk]]
[10:59:31.548]                   NAME <- NAMES[[kk]]
[10:59:31.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.548]                     next
[10:59:31.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.548]                 }
[10:59:31.548]                 if (length(args) > 0) 
[10:59:31.548]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.548]             }
[10:59:31.548]             else {
[10:59:31.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.548]             }
[10:59:31.548]             {
[10:59:31.548]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.548]                   0L) {
[10:59:31.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.548]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.548]                   base::options(opts)
[10:59:31.548]                 }
[10:59:31.548]                 {
[10:59:31.548]                   {
[10:59:31.548]                     base::assign(".Random.seed", c(10407L, -1027017971L, 
[10:59:31.548]                     -84354130L, -480752092L, 1047550554L, 409668568L, 
[10:59:31.548]                     -1174182659L), envir = base::globalenv(), 
[10:59:31.548]                       inherits = FALSE)
[10:59:31.548]                     NULL
[10:59:31.548]                   }
[10:59:31.548]                   options(future.plan = NULL)
[10:59:31.548]                   if (is.na(NA_character_)) 
[10:59:31.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.548]                     .init = FALSE)
[10:59:31.548]                 }
[10:59:31.548]             }
[10:59:31.548]         }
[10:59:31.548]     })
[10:59:31.548]     if (TRUE) {
[10:59:31.548]         base::sink(type = "output", split = FALSE)
[10:59:31.548]         if (TRUE) {
[10:59:31.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.548]         }
[10:59:31.548]         else {
[10:59:31.548]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.548]         }
[10:59:31.548]         base::close(...future.stdout)
[10:59:31.548]         ...future.stdout <- NULL
[10:59:31.548]     }
[10:59:31.548]     ...future.result$conditions <- ...future.conditions
[10:59:31.548]     ...future.result$finished <- base::Sys.time()
[10:59:31.548]     ...future.result
[10:59:31.548] }
[10:59:31.549] assign_globals() ...
[10:59:31.550] List of 5
[10:59:31.550]  $ ...future.FUN            :function (x, y)  
[10:59:31.550]  $ MoreArgs                 :List of 1
[10:59:31.550]   ..$ y: int [1:2] 3 4
[10:59:31.550]  $ ...future.elements_ii    :List of 1
[10:59:31.550]   ..$ x:List of 2
[10:59:31.550]   .. ..$ : int 1
[10:59:31.550]   .. ..$ : int 2
[10:59:31.550]  $ ...future.seeds_ii       :List of 2
[10:59:31.550]   ..$ : int [1:7] 10407 50945861 -2135747838 1276676640 -156310799 -259722782 -1610235550
[10:59:31.550]   ..$ : int [1:7] 10407 1064346335 1363394975 -821548828 1510397589 -1142617027 140235794
[10:59:31.550]  $ ...future.globals.maxSize: NULL
[10:59:31.550]  - attr(*, "where")=List of 5
[10:59:31.550]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.550]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.550]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.550]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.550]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.550]  - attr(*, "resolved")= logi FALSE
[10:59:31.550]  - attr(*, "total_size")= num 744
[10:59:31.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.550]  - attr(*, "already-done")= logi TRUE
[10:59:31.555] - reassign environment for ‘...future.FUN’
[10:59:31.555] - copied ‘...future.FUN’ to environment
[10:59:31.555] - copied ‘MoreArgs’ to environment
[10:59:31.555] - copied ‘...future.elements_ii’ to environment
[10:59:31.555] - copied ‘...future.seeds_ii’ to environment
[10:59:31.555] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.555] assign_globals() ... done
[10:59:31.555] plan(): Setting new future strategy stack:
[10:59:31.556] List of future strategies:
[10:59:31.556] 1. sequential:
[10:59:31.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.556]    - tweaked: FALSE
[10:59:31.556]    - call: NULL
[10:59:31.556] plan(): nbrOfWorkers() = 1
[10:59:31.557] plan(): Setting new future strategy stack:
[10:59:31.557] List of future strategies:
[10:59:31.557] 1. sequential:
[10:59:31.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.557]    - tweaked: FALSE
[10:59:31.557]    - call: plan(strategy)
[10:59:31.557] plan(): nbrOfWorkers() = 1
[10:59:31.557] SequentialFuture started (and completed)
[10:59:31.557] - Launch lazy future ... done
[10:59:31.557] run() for ‘SequentialFuture’ ... done
[10:59:31.558] Created future:
[10:59:31.558] SequentialFuture:
[10:59:31.558] Label: ‘future_mapply-1’
[10:59:31.558] Expression:
[10:59:31.558] {
[10:59:31.558]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.558]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.558]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.558]         on.exit(options(oopts), add = TRUE)
[10:59:31.558]     }
[10:59:31.558]     {
[10:59:31.558]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:31.558]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:31.558]                 inherits = FALSE)
[10:59:31.558]             ...future.FUN(...)
[10:59:31.558]         }
[10:59:31.558]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:31.558]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:31.558]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.558]         do.call(mapply, args = args)
[10:59:31.558]     }
[10:59:31.558] }
[10:59:31.558] Lazy evaluation: FALSE
[10:59:31.558] Asynchronous evaluation: FALSE
[10:59:31.558] Local evaluation: TRUE
[10:59:31.558] Environment: R_GlobalEnv
[10:59:31.558] Capture standard output: TRUE
[10:59:31.558] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.558] Globals: 5 objects totaling 744 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.558] Packages: <none>
[10:59:31.558] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:31.558] Resolved: TRUE
[10:59:31.558] Value: 217 bytes of class ‘list’
[10:59:31.558] Early signaling: FALSE
[10:59:31.558] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.558] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.558] Chunk #1 of 1 ... DONE
[10:59:31.558] Launching 1 futures (chunks) ... DONE
[10:59:31.559] Resolving 1 futures (chunks) ...
[10:59:31.559] resolve() on list ...
[10:59:31.559]  recursive: 0
[10:59:31.559]  length: 1
[10:59:31.559] 
[10:59:31.559] resolved() for ‘SequentialFuture’ ...
[10:59:31.559] - state: ‘finished’
[10:59:31.560] - run: TRUE
[10:59:31.560] - result: ‘FutureResult’
[10:59:31.560] resolved() for ‘SequentialFuture’ ... done
[10:59:31.560] Future #1
[10:59:31.560] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.560] - nx: 1
[10:59:31.561] - relay: TRUE
[10:59:31.561] - stdout: TRUE
[10:59:31.561] - signal: TRUE
[10:59:31.561] - resignal: FALSE
[10:59:31.561] - force: TRUE
[10:59:31.561] - relayed: [n=1] FALSE
[10:59:31.561] - queued futures: [n=1] FALSE
[10:59:31.561]  - until=1
[10:59:31.561]  - relaying element #1
[10:59:31.561] - relayed: [n=1] TRUE
[10:59:31.561] - queued futures: [n=1] TRUE
[10:59:31.561] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.562]  length: 0 (resolved future 1)
[10:59:31.562] Relaying remaining futures
[10:59:31.562] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.562] - nx: 1
[10:59:31.562] - relay: TRUE
[10:59:31.562] - stdout: TRUE
[10:59:31.562] - signal: TRUE
[10:59:31.562] - resignal: FALSE
[10:59:31.562] - force: TRUE
[10:59:31.562] - relayed: [n=1] TRUE
[10:59:31.562] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.562] - relayed: [n=1] TRUE
[10:59:31.563] - queued futures: [n=1] TRUE
[10:59:31.563] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.563] resolve() on list ... DONE
[10:59:31.563]  - Number of value chunks collected: 1
[10:59:31.563] Resolving 1 futures (chunks) ... DONE
[10:59:31.563] Reducing values from 1 chunks ...
[10:59:31.563]  - Number of values collected after concatenation: 2
[10:59:31.563]  - Number of values expected: 2
[10:59:31.563] Reducing values from 1 chunks ... DONE
[10:59:31.563] future_mapply() ... DONE
[10:59:31.563] future_mapply() ...
[10:59:31.564] Number of chunks: 1
[10:59:31.564] getGlobalsAndPackagesXApply() ...
[10:59:31.564]  - future.globals: TRUE
[10:59:31.564] getGlobalsAndPackages() ...
[10:59:31.564] Searching for globals...
[10:59:31.565] - globals found: [1] ‘FUN’
[10:59:31.565] Searching for globals ... DONE
[10:59:31.565] Resolving globals: FALSE
[10:59:31.565] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:31.565] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:31.566] - globals: [1] ‘FUN’
[10:59:31.566] 
[10:59:31.566] getGlobalsAndPackages() ... DONE
[10:59:31.566]  - globals found/used: [n=1] ‘FUN’
[10:59:31.566]  - needed namespaces: [n=0] 
[10:59:31.566] Finding globals ... DONE
[10:59:31.566] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.566] List of 2
[10:59:31.566]  $ ...future.FUN:function (x, y)  
[10:59:31.566]  $ MoreArgs     :List of 1
[10:59:31.566]   ..$ y: int [1:2] 3 4
[10:59:31.566]  - attr(*, "where")=List of 2
[10:59:31.566]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.566]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.566]  - attr(*, "resolved")= logi FALSE
[10:59:31.566]  - attr(*, "total_size")= num NA
[10:59:31.569] Packages to be attached in all futures: [n=0] 
[10:59:31.569] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.569] Number of futures (= number of chunks): 1
[10:59:31.569] Launching 1 futures (chunks) ...
[10:59:31.569] Chunk #1 of 1 ...
[10:59:31.569]  - Finding globals in '...' for chunk #1 ...
[10:59:31.569] getGlobalsAndPackages() ...
[10:59:31.569] Searching for globals...
[10:59:31.570] 
[10:59:31.570] Searching for globals ... DONE
[10:59:31.570] - globals: [0] <none>
[10:59:31.570] getGlobalsAndPackages() ... DONE
[10:59:31.570]    + additional globals found: [n=0] 
[10:59:31.570]    + additional namespaces needed: [n=0] 
[10:59:31.570]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.570]  - seeds: <none>
[10:59:31.570]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.570] getGlobalsAndPackages() ...
[10:59:31.571] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.571] Resolving globals: FALSE
[10:59:31.571] The total size of the 5 globals is 668 bytes (668 bytes)
[10:59:31.571] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 668 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[10:59:31.572] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.572] 
[10:59:31.572] getGlobalsAndPackages() ... DONE
[10:59:31.572] run() for ‘Future’ ...
[10:59:31.572] - state: ‘created’
[10:59:31.572] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.572] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.573]   - Field: ‘label’
[10:59:31.573]   - Field: ‘local’
[10:59:31.573]   - Field: ‘owner’
[10:59:31.573]   - Field: ‘envir’
[10:59:31.573]   - Field: ‘packages’
[10:59:31.573]   - Field: ‘gc’
[10:59:31.573]   - Field: ‘conditions’
[10:59:31.573]   - Field: ‘expr’
[10:59:31.573]   - Field: ‘uuid’
[10:59:31.573]   - Field: ‘seed’
[10:59:31.573]   - Field: ‘version’
[10:59:31.573]   - Field: ‘result’
[10:59:31.573]   - Field: ‘asynchronous’
[10:59:31.574]   - Field: ‘calls’
[10:59:31.574]   - Field: ‘globals’
[10:59:31.574]   - Field: ‘stdout’
[10:59:31.574]   - Field: ‘earlySignal’
[10:59:31.574]   - Field: ‘lazy’
[10:59:31.574]   - Field: ‘state’
[10:59:31.574] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.574] - Launch lazy future ...
[10:59:31.574] Packages needed by the future expression (n = 0): <none>
[10:59:31.574] Packages needed by future strategies (n = 0): <none>
[10:59:31.575] {
[10:59:31.575]     {
[10:59:31.575]         {
[10:59:31.575]             ...future.startTime <- base::Sys.time()
[10:59:31.575]             {
[10:59:31.575]                 {
[10:59:31.575]                   {
[10:59:31.575]                     base::local({
[10:59:31.575]                       has_future <- base::requireNamespace("future", 
[10:59:31.575]                         quietly = TRUE)
[10:59:31.575]                       if (has_future) {
[10:59:31.575]                         ns <- base::getNamespace("future")
[10:59:31.575]                         version <- ns[[".package"]][["version"]]
[10:59:31.575]                         if (is.null(version)) 
[10:59:31.575]                           version <- utils::packageVersion("future")
[10:59:31.575]                       }
[10:59:31.575]                       else {
[10:59:31.575]                         version <- NULL
[10:59:31.575]                       }
[10:59:31.575]                       if (!has_future || version < "1.8.0") {
[10:59:31.575]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.575]                           "", base::R.version$version.string), 
[10:59:31.575]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.575]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.575]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.575]                             "release", "version")], collapse = " "), 
[10:59:31.575]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.575]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.575]                           info)
[10:59:31.575]                         info <- base::paste(info, collapse = "; ")
[10:59:31.575]                         if (!has_future) {
[10:59:31.575]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.575]                             info)
[10:59:31.575]                         }
[10:59:31.575]                         else {
[10:59:31.575]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.575]                             info, version)
[10:59:31.575]                         }
[10:59:31.575]                         base::stop(msg)
[10:59:31.575]                       }
[10:59:31.575]                     })
[10:59:31.575]                   }
[10:59:31.575]                   ...future.strategy.old <- future::plan("list")
[10:59:31.575]                   options(future.plan = NULL)
[10:59:31.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.575]                 }
[10:59:31.575]                 ...future.workdir <- getwd()
[10:59:31.575]             }
[10:59:31.575]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.575]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.575]         }
[10:59:31.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.575]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.575]             base::names(...future.oldOptions))
[10:59:31.575]     }
[10:59:31.575]     if (FALSE) {
[10:59:31.575]     }
[10:59:31.575]     else {
[10:59:31.575]         if (TRUE) {
[10:59:31.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.575]                 open = "w")
[10:59:31.575]         }
[10:59:31.575]         else {
[10:59:31.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.575]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.575]         }
[10:59:31.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.575]             base::sink(type = "output", split = FALSE)
[10:59:31.575]             base::close(...future.stdout)
[10:59:31.575]         }, add = TRUE)
[10:59:31.575]     }
[10:59:31.575]     ...future.frame <- base::sys.nframe()
[10:59:31.575]     ...future.conditions <- base::list()
[10:59:31.575]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.575]     if (FALSE) {
[10:59:31.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.575]     }
[10:59:31.575]     ...future.result <- base::tryCatch({
[10:59:31.575]         base::withCallingHandlers({
[10:59:31.575]             ...future.value <- base::withVisible(base::local({
[10:59:31.575]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.575]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.575]                   ...future.globals.maxSize)) {
[10:59:31.575]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.575]                   on.exit(options(oopts), add = TRUE)
[10:59:31.575]                 }
[10:59:31.575]                 {
[10:59:31.575]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.575]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.575]                     USE.NAMES = FALSE)
[10:59:31.575]                   do.call(mapply, args = args)
[10:59:31.575]                 }
[10:59:31.575]             }))
[10:59:31.575]             future::FutureResult(value = ...future.value$value, 
[10:59:31.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.575]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.575]                     ...future.globalenv.names))
[10:59:31.575]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.575]         }, condition = base::local({
[10:59:31.575]             c <- base::c
[10:59:31.575]             inherits <- base::inherits
[10:59:31.575]             invokeRestart <- base::invokeRestart
[10:59:31.575]             length <- base::length
[10:59:31.575]             list <- base::list
[10:59:31.575]             seq.int <- base::seq.int
[10:59:31.575]             signalCondition <- base::signalCondition
[10:59:31.575]             sys.calls <- base::sys.calls
[10:59:31.575]             `[[` <- base::`[[`
[10:59:31.575]             `+` <- base::`+`
[10:59:31.575]             `<<-` <- base::`<<-`
[10:59:31.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.575]                   3L)]
[10:59:31.575]             }
[10:59:31.575]             function(cond) {
[10:59:31.575]                 is_error <- inherits(cond, "error")
[10:59:31.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.575]                   NULL)
[10:59:31.575]                 if (is_error) {
[10:59:31.575]                   sessionInformation <- function() {
[10:59:31.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.575]                       search = base::search(), system = base::Sys.info())
[10:59:31.575]                   }
[10:59:31.575]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.575]                     cond$call), session = sessionInformation(), 
[10:59:31.575]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.575]                   signalCondition(cond)
[10:59:31.575]                 }
[10:59:31.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.575]                 "immediateCondition"))) {
[10:59:31.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.575]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.575]                   if (TRUE && !signal) {
[10:59:31.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.575]                     {
[10:59:31.575]                       inherits <- base::inherits
[10:59:31.575]                       invokeRestart <- base::invokeRestart
[10:59:31.575]                       is.null <- base::is.null
[10:59:31.575]                       muffled <- FALSE
[10:59:31.575]                       if (inherits(cond, "message")) {
[10:59:31.575]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.575]                         if (muffled) 
[10:59:31.575]                           invokeRestart("muffleMessage")
[10:59:31.575]                       }
[10:59:31.575]                       else if (inherits(cond, "warning")) {
[10:59:31.575]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.575]                         if (muffled) 
[10:59:31.575]                           invokeRestart("muffleWarning")
[10:59:31.575]                       }
[10:59:31.575]                       else if (inherits(cond, "condition")) {
[10:59:31.575]                         if (!is.null(pattern)) {
[10:59:31.575]                           computeRestarts <- base::computeRestarts
[10:59:31.575]                           grepl <- base::grepl
[10:59:31.575]                           restarts <- computeRestarts(cond)
[10:59:31.575]                           for (restart in restarts) {
[10:59:31.575]                             name <- restart$name
[10:59:31.575]                             if (is.null(name)) 
[10:59:31.575]                               next
[10:59:31.575]                             if (!grepl(pattern, name)) 
[10:59:31.575]                               next
[10:59:31.575]                             invokeRestart(restart)
[10:59:31.575]                             muffled <- TRUE
[10:59:31.575]                             break
[10:59:31.575]                           }
[10:59:31.575]                         }
[10:59:31.575]                       }
[10:59:31.575]                       invisible(muffled)
[10:59:31.575]                     }
[10:59:31.575]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.575]                   }
[10:59:31.575]                 }
[10:59:31.575]                 else {
[10:59:31.575]                   if (TRUE) {
[10:59:31.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.575]                     {
[10:59:31.575]                       inherits <- base::inherits
[10:59:31.575]                       invokeRestart <- base::invokeRestart
[10:59:31.575]                       is.null <- base::is.null
[10:59:31.575]                       muffled <- FALSE
[10:59:31.575]                       if (inherits(cond, "message")) {
[10:59:31.575]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.575]                         if (muffled) 
[10:59:31.575]                           invokeRestart("muffleMessage")
[10:59:31.575]                       }
[10:59:31.575]                       else if (inherits(cond, "warning")) {
[10:59:31.575]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.575]                         if (muffled) 
[10:59:31.575]                           invokeRestart("muffleWarning")
[10:59:31.575]                       }
[10:59:31.575]                       else if (inherits(cond, "condition")) {
[10:59:31.575]                         if (!is.null(pattern)) {
[10:59:31.575]                           computeRestarts <- base::computeRestarts
[10:59:31.575]                           grepl <- base::grepl
[10:59:31.575]                           restarts <- computeRestarts(cond)
[10:59:31.575]                           for (restart in restarts) {
[10:59:31.575]                             name <- restart$name
[10:59:31.575]                             if (is.null(name)) 
[10:59:31.575]                               next
[10:59:31.575]                             if (!grepl(pattern, name)) 
[10:59:31.575]                               next
[10:59:31.575]                             invokeRestart(restart)
[10:59:31.575]                             muffled <- TRUE
[10:59:31.575]                             break
[10:59:31.575]                           }
[10:59:31.575]                         }
[10:59:31.575]                       }
[10:59:31.575]                       invisible(muffled)
[10:59:31.575]                     }
[10:59:31.575]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.575]                   }
[10:59:31.575]                 }
[10:59:31.575]             }
[10:59:31.575]         }))
[10:59:31.575]     }, error = function(ex) {
[10:59:31.575]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.575]                 ...future.rng), started = ...future.startTime, 
[10:59:31.575]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.575]             version = "1.8"), class = "FutureResult")
[10:59:31.575]     }, finally = {
[10:59:31.575]         if (!identical(...future.workdir, getwd())) 
[10:59:31.575]             setwd(...future.workdir)
[10:59:31.575]         {
[10:59:31.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.575]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.575]             }
[10:59:31.575]             base::options(...future.oldOptions)
[10:59:31.575]             if (.Platform$OS.type == "windows") {
[10:59:31.575]                 old_names <- names(...future.oldEnvVars)
[10:59:31.575]                 envs <- base::Sys.getenv()
[10:59:31.575]                 names <- names(envs)
[10:59:31.575]                 common <- intersect(names, old_names)
[10:59:31.575]                 added <- setdiff(names, old_names)
[10:59:31.575]                 removed <- setdiff(old_names, names)
[10:59:31.575]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.575]                   envs[common]]
[10:59:31.575]                 NAMES <- toupper(changed)
[10:59:31.575]                 args <- list()
[10:59:31.575]                 for (kk in seq_along(NAMES)) {
[10:59:31.575]                   name <- changed[[kk]]
[10:59:31.575]                   NAME <- NAMES[[kk]]
[10:59:31.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.575]                     next
[10:59:31.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.575]                 }
[10:59:31.575]                 NAMES <- toupper(added)
[10:59:31.575]                 for (kk in seq_along(NAMES)) {
[10:59:31.575]                   name <- added[[kk]]
[10:59:31.575]                   NAME <- NAMES[[kk]]
[10:59:31.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.575]                     next
[10:59:31.575]                   args[[name]] <- ""
[10:59:31.575]                 }
[10:59:31.575]                 NAMES <- toupper(removed)
[10:59:31.575]                 for (kk in seq_along(NAMES)) {
[10:59:31.575]                   name <- removed[[kk]]
[10:59:31.575]                   NAME <- NAMES[[kk]]
[10:59:31.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.575]                     next
[10:59:31.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.575]                 }
[10:59:31.575]                 if (length(args) > 0) 
[10:59:31.575]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.575]             }
[10:59:31.575]             else {
[10:59:31.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.575]             }
[10:59:31.575]             {
[10:59:31.575]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.575]                   0L) {
[10:59:31.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.575]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.575]                   base::options(opts)
[10:59:31.575]                 }
[10:59:31.575]                 {
[10:59:31.575]                   {
[10:59:31.575]                     base::assign(".Random.seed", c(10407L, -1027017971L, 
[10:59:31.575]                     -84354130L, -480752092L, 1047550554L, 409668568L, 
[10:59:31.575]                     -1174182659L), envir = base::globalenv(), 
[10:59:31.575]                       inherits = FALSE)
[10:59:31.575]                     NULL
[10:59:31.575]                   }
[10:59:31.575]                   options(future.plan = NULL)
[10:59:31.575]                   if (is.na(NA_character_)) 
[10:59:31.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.575]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.575]                     .init = FALSE)
[10:59:31.575]                 }
[10:59:31.575]             }
[10:59:31.575]         }
[10:59:31.575]     })
[10:59:31.575]     if (TRUE) {
[10:59:31.575]         base::sink(type = "output", split = FALSE)
[10:59:31.575]         if (TRUE) {
[10:59:31.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.575]         }
[10:59:31.575]         else {
[10:59:31.575]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.575]         }
[10:59:31.575]         base::close(...future.stdout)
[10:59:31.575]         ...future.stdout <- NULL
[10:59:31.575]     }
[10:59:31.575]     ...future.result$conditions <- ...future.conditions
[10:59:31.575]     ...future.result$finished <- base::Sys.time()
[10:59:31.575]     ...future.result
[10:59:31.575] }
[10:59:31.576] assign_globals() ...
[10:59:31.577] List of 5
[10:59:31.577]  $ ...future.FUN            :function (x, y)  
[10:59:31.577]  $ MoreArgs                 :List of 1
[10:59:31.577]   ..$ y: int [1:2] 3 4
[10:59:31.577]  $ ...future.elements_ii    :List of 1
[10:59:31.577]   ..$ x:List of 2
[10:59:31.577]   .. ..$ : int 1
[10:59:31.577]   .. ..$ : int 2
[10:59:31.577]  $ ...future.seeds_ii       : NULL
[10:59:31.577]  $ ...future.globals.maxSize: NULL
[10:59:31.577]  - attr(*, "where")=List of 5
[10:59:31.577]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.577]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.577]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.577]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.577]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.577]  - attr(*, "resolved")= logi FALSE
[10:59:31.577]  - attr(*, "total_size")= num 668
[10:59:31.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.577]  - attr(*, "already-done")= logi TRUE
[10:59:31.582] - reassign environment for ‘...future.FUN’
[10:59:31.582] - copied ‘...future.FUN’ to environment
[10:59:31.582] - copied ‘MoreArgs’ to environment
[10:59:31.583] - copied ‘...future.elements_ii’ to environment
[10:59:31.583] - copied ‘...future.seeds_ii’ to environment
[10:59:31.583] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.583] assign_globals() ... done
[10:59:31.583] plan(): Setting new future strategy stack:
[10:59:31.583] List of future strategies:
[10:59:31.583] 1. sequential:
[10:59:31.583]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.583]    - tweaked: FALSE
[10:59:31.583]    - call: NULL
[10:59:31.583] plan(): nbrOfWorkers() = 1
[10:59:31.584] plan(): Setting new future strategy stack:
[10:59:31.584] List of future strategies:
[10:59:31.584] 1. sequential:
[10:59:31.584]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.584]    - tweaked: FALSE
[10:59:31.584]    - call: plan(strategy)
[10:59:31.585] plan(): nbrOfWorkers() = 1
[10:59:31.585] SequentialFuture started (and completed)
[10:59:31.585] - Launch lazy future ... done
[10:59:31.585] run() for ‘SequentialFuture’ ... done
[10:59:31.585] Created future:
[10:59:31.585] SequentialFuture:
[10:59:31.585] Label: ‘future_.mapply-1’
[10:59:31.585] Expression:
[10:59:31.585] {
[10:59:31.585]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.585]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.585]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.585]         on.exit(options(oopts), add = TRUE)
[10:59:31.585]     }
[10:59:31.585]     {
[10:59:31.585]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.585]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.585]         do.call(mapply, args = args)
[10:59:31.585]     }
[10:59:31.585] }
[10:59:31.585] Lazy evaluation: FALSE
[10:59:31.585] Asynchronous evaluation: FALSE
[10:59:31.585] Local evaluation: TRUE
[10:59:31.585] Environment: R_GlobalEnv
[10:59:31.585] Capture standard output: TRUE
[10:59:31.585] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.585] Globals: 5 objects totaling 668 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.585] Packages: <none>
[10:59:31.585] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.585] Resolved: TRUE
[10:59:31.585] Value: 217 bytes of class ‘list’
[10:59:31.585] Early signaling: FALSE
[10:59:31.585] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.585] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.586] Chunk #1 of 1 ... DONE
[10:59:31.586] Launching 1 futures (chunks) ... DONE
[10:59:31.586] Resolving 1 futures (chunks) ...
[10:59:31.586] resolve() on list ...
[10:59:31.586]  recursive: 0
[10:59:31.586]  length: 1
[10:59:31.586] 
[10:59:31.586] resolved() for ‘SequentialFuture’ ...
[10:59:31.587] - state: ‘finished’
[10:59:31.587] - run: TRUE
[10:59:31.587] - result: ‘FutureResult’
[10:59:31.587] resolved() for ‘SequentialFuture’ ... done
[10:59:31.587] Future #1
[10:59:31.587] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.587] - nx: 1
[10:59:31.587] - relay: TRUE
[10:59:31.587] - stdout: TRUE
[10:59:31.587] - signal: TRUE
[10:59:31.587] - resignal: FALSE
[10:59:31.587] - force: TRUE
[10:59:31.587] - relayed: [n=1] FALSE
[10:59:31.588] - queued futures: [n=1] FALSE
[10:59:31.588]  - until=1
[10:59:31.588]  - relaying element #1
[10:59:31.588] - relayed: [n=1] TRUE
[10:59:31.588] - queued futures: [n=1] TRUE
[10:59:31.588] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.588]  length: 0 (resolved future 1)
[10:59:31.588] Relaying remaining futures
[10:59:31.588] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.588] - nx: 1
[10:59:31.588] - relay: TRUE
[10:59:31.588] - stdout: TRUE
[10:59:31.589] - signal: TRUE
[10:59:31.589] - resignal: FALSE
[10:59:31.589] - force: TRUE
[10:59:31.589] - relayed: [n=1] TRUE
[10:59:31.589] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.589] - relayed: [n=1] TRUE
[10:59:31.589] - queued futures: [n=1] TRUE
[10:59:31.589] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.589] resolve() on list ... DONE
[10:59:31.589]  - Number of value chunks collected: 1
[10:59:31.589] Resolving 1 futures (chunks) ... DONE
[10:59:31.589] Reducing values from 1 chunks ...
[10:59:31.590]  - Number of values collected after concatenation: 2
[10:59:31.590]  - Number of values expected: 2
[10:59:31.590] Reducing values from 1 chunks ... DONE
[10:59:31.590] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:59:31.590] future_mapply() ...
[10:59:31.590] Number of chunks: 1
[10:59:31.590] getGlobalsAndPackagesXApply() ...
[10:59:31.590]  - future.globals: TRUE
[10:59:31.590] getGlobalsAndPackages() ...
[10:59:31.590] Searching for globals...
[10:59:31.591] - globals found: [1] ‘FUN’
[10:59:31.591] Searching for globals ... DONE
[10:59:31.591] Resolving globals: FALSE
[10:59:31.591] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:31.592] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:31.592] - globals: [1] ‘FUN’
[10:59:31.592] 
[10:59:31.592] getGlobalsAndPackages() ... DONE
[10:59:31.592]  - globals found/used: [n=1] ‘FUN’
[10:59:31.592]  - needed namespaces: [n=0] 
[10:59:31.592] Finding globals ... DONE
[10:59:31.592] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.592] List of 2
[10:59:31.592]  $ ...future.FUN:function (x, ...)  
[10:59:31.592]  $ MoreArgs     : NULL
[10:59:31.592]  - attr(*, "where")=List of 2
[10:59:31.592]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.592]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.592]  - attr(*, "resolved")= logi FALSE
[10:59:31.592]  - attr(*, "total_size")= num NA
[10:59:31.595] Packages to be attached in all futures: [n=0] 
[10:59:31.595] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.595] Number of futures (= number of chunks): 1
[10:59:31.595] Launching 1 futures (chunks) ...
[10:59:31.595] Chunk #1 of 1 ...
[10:59:31.595]  - Finding globals in '...' for chunk #1 ...
[10:59:31.595] getGlobalsAndPackages() ...
[10:59:31.595] Searching for globals...
[10:59:31.596] 
[10:59:31.596] Searching for globals ... DONE
[10:59:31.596] - globals: [0] <none>
[10:59:31.596] getGlobalsAndPackages() ... DONE
[10:59:31.596]    + additional globals found: [n=0] 
[10:59:31.596]    + additional namespaces needed: [n=0] 
[10:59:31.596]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.596]  - seeds: <none>
[10:59:31.596]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.596] getGlobalsAndPackages() ...
[10:59:31.596] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.596] Resolving globals: FALSE
[10:59:31.597] The total size of the 5 globals is 258 bytes (258 bytes)
[10:59:31.597] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.597] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.597] 
[10:59:31.598] getGlobalsAndPackages() ... DONE
[10:59:31.598] run() for ‘Future’ ...
[10:59:31.598] - state: ‘created’
[10:59:31.598] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.598]   - Field: ‘label’
[10:59:31.599]   - Field: ‘local’
[10:59:31.599]   - Field: ‘owner’
[10:59:31.600]   - Field: ‘envir’
[10:59:31.600]   - Field: ‘packages’
[10:59:31.600]   - Field: ‘gc’
[10:59:31.600]   - Field: ‘conditions’
[10:59:31.600]   - Field: ‘expr’
[10:59:31.600]   - Field: ‘uuid’
[10:59:31.600]   - Field: ‘seed’
[10:59:31.600]   - Field: ‘version’
[10:59:31.600]   - Field: ‘result’
[10:59:31.600]   - Field: ‘asynchronous’
[10:59:31.600]   - Field: ‘calls’
[10:59:31.600]   - Field: ‘globals’
[10:59:31.601]   - Field: ‘stdout’
[10:59:31.601]   - Field: ‘earlySignal’
[10:59:31.601]   - Field: ‘lazy’
[10:59:31.601]   - Field: ‘state’
[10:59:31.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.601] - Launch lazy future ...
[10:59:31.601] Packages needed by the future expression (n = 0): <none>
[10:59:31.601] Packages needed by future strategies (n = 0): <none>
[10:59:31.602] {
[10:59:31.602]     {
[10:59:31.602]         {
[10:59:31.602]             ...future.startTime <- base::Sys.time()
[10:59:31.602]             {
[10:59:31.602]                 {
[10:59:31.602]                   {
[10:59:31.602]                     base::local({
[10:59:31.602]                       has_future <- base::requireNamespace("future", 
[10:59:31.602]                         quietly = TRUE)
[10:59:31.602]                       if (has_future) {
[10:59:31.602]                         ns <- base::getNamespace("future")
[10:59:31.602]                         version <- ns[[".package"]][["version"]]
[10:59:31.602]                         if (is.null(version)) 
[10:59:31.602]                           version <- utils::packageVersion("future")
[10:59:31.602]                       }
[10:59:31.602]                       else {
[10:59:31.602]                         version <- NULL
[10:59:31.602]                       }
[10:59:31.602]                       if (!has_future || version < "1.8.0") {
[10:59:31.602]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.602]                           "", base::R.version$version.string), 
[10:59:31.602]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.602]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.602]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.602]                             "release", "version")], collapse = " "), 
[10:59:31.602]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.602]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.602]                           info)
[10:59:31.602]                         info <- base::paste(info, collapse = "; ")
[10:59:31.602]                         if (!has_future) {
[10:59:31.602]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.602]                             info)
[10:59:31.602]                         }
[10:59:31.602]                         else {
[10:59:31.602]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.602]                             info, version)
[10:59:31.602]                         }
[10:59:31.602]                         base::stop(msg)
[10:59:31.602]                       }
[10:59:31.602]                     })
[10:59:31.602]                   }
[10:59:31.602]                   ...future.strategy.old <- future::plan("list")
[10:59:31.602]                   options(future.plan = NULL)
[10:59:31.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.602]                 }
[10:59:31.602]                 ...future.workdir <- getwd()
[10:59:31.602]             }
[10:59:31.602]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.602]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.602]         }
[10:59:31.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.602]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.602]             base::names(...future.oldOptions))
[10:59:31.602]     }
[10:59:31.602]     if (FALSE) {
[10:59:31.602]     }
[10:59:31.602]     else {
[10:59:31.602]         if (TRUE) {
[10:59:31.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.602]                 open = "w")
[10:59:31.602]         }
[10:59:31.602]         else {
[10:59:31.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.602]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.602]         }
[10:59:31.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.602]             base::sink(type = "output", split = FALSE)
[10:59:31.602]             base::close(...future.stdout)
[10:59:31.602]         }, add = TRUE)
[10:59:31.602]     }
[10:59:31.602]     ...future.frame <- base::sys.nframe()
[10:59:31.602]     ...future.conditions <- base::list()
[10:59:31.602]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.602]     if (FALSE) {
[10:59:31.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.602]     }
[10:59:31.602]     ...future.result <- base::tryCatch({
[10:59:31.602]         base::withCallingHandlers({
[10:59:31.602]             ...future.value <- base::withVisible(base::local({
[10:59:31.602]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.602]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.602]                   ...future.globals.maxSize)) {
[10:59:31.602]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.602]                   on.exit(options(oopts), add = TRUE)
[10:59:31.602]                 }
[10:59:31.602]                 {
[10:59:31.602]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.602]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.602]                     USE.NAMES = FALSE)
[10:59:31.602]                   do.call(mapply, args = args)
[10:59:31.602]                 }
[10:59:31.602]             }))
[10:59:31.602]             future::FutureResult(value = ...future.value$value, 
[10:59:31.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.602]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.602]                     ...future.globalenv.names))
[10:59:31.602]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.602]         }, condition = base::local({
[10:59:31.602]             c <- base::c
[10:59:31.602]             inherits <- base::inherits
[10:59:31.602]             invokeRestart <- base::invokeRestart
[10:59:31.602]             length <- base::length
[10:59:31.602]             list <- base::list
[10:59:31.602]             seq.int <- base::seq.int
[10:59:31.602]             signalCondition <- base::signalCondition
[10:59:31.602]             sys.calls <- base::sys.calls
[10:59:31.602]             `[[` <- base::`[[`
[10:59:31.602]             `+` <- base::`+`
[10:59:31.602]             `<<-` <- base::`<<-`
[10:59:31.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.602]                   3L)]
[10:59:31.602]             }
[10:59:31.602]             function(cond) {
[10:59:31.602]                 is_error <- inherits(cond, "error")
[10:59:31.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.602]                   NULL)
[10:59:31.602]                 if (is_error) {
[10:59:31.602]                   sessionInformation <- function() {
[10:59:31.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.602]                       search = base::search(), system = base::Sys.info())
[10:59:31.602]                   }
[10:59:31.602]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.602]                     cond$call), session = sessionInformation(), 
[10:59:31.602]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.602]                   signalCondition(cond)
[10:59:31.602]                 }
[10:59:31.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.602]                 "immediateCondition"))) {
[10:59:31.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.602]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.602]                   if (TRUE && !signal) {
[10:59:31.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.602]                     {
[10:59:31.602]                       inherits <- base::inherits
[10:59:31.602]                       invokeRestart <- base::invokeRestart
[10:59:31.602]                       is.null <- base::is.null
[10:59:31.602]                       muffled <- FALSE
[10:59:31.602]                       if (inherits(cond, "message")) {
[10:59:31.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.602]                         if (muffled) 
[10:59:31.602]                           invokeRestart("muffleMessage")
[10:59:31.602]                       }
[10:59:31.602]                       else if (inherits(cond, "warning")) {
[10:59:31.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.602]                         if (muffled) 
[10:59:31.602]                           invokeRestart("muffleWarning")
[10:59:31.602]                       }
[10:59:31.602]                       else if (inherits(cond, "condition")) {
[10:59:31.602]                         if (!is.null(pattern)) {
[10:59:31.602]                           computeRestarts <- base::computeRestarts
[10:59:31.602]                           grepl <- base::grepl
[10:59:31.602]                           restarts <- computeRestarts(cond)
[10:59:31.602]                           for (restart in restarts) {
[10:59:31.602]                             name <- restart$name
[10:59:31.602]                             if (is.null(name)) 
[10:59:31.602]                               next
[10:59:31.602]                             if (!grepl(pattern, name)) 
[10:59:31.602]                               next
[10:59:31.602]                             invokeRestart(restart)
[10:59:31.602]                             muffled <- TRUE
[10:59:31.602]                             break
[10:59:31.602]                           }
[10:59:31.602]                         }
[10:59:31.602]                       }
[10:59:31.602]                       invisible(muffled)
[10:59:31.602]                     }
[10:59:31.602]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.602]                   }
[10:59:31.602]                 }
[10:59:31.602]                 else {
[10:59:31.602]                   if (TRUE) {
[10:59:31.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.602]                     {
[10:59:31.602]                       inherits <- base::inherits
[10:59:31.602]                       invokeRestart <- base::invokeRestart
[10:59:31.602]                       is.null <- base::is.null
[10:59:31.602]                       muffled <- FALSE
[10:59:31.602]                       if (inherits(cond, "message")) {
[10:59:31.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.602]                         if (muffled) 
[10:59:31.602]                           invokeRestart("muffleMessage")
[10:59:31.602]                       }
[10:59:31.602]                       else if (inherits(cond, "warning")) {
[10:59:31.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.602]                         if (muffled) 
[10:59:31.602]                           invokeRestart("muffleWarning")
[10:59:31.602]                       }
[10:59:31.602]                       else if (inherits(cond, "condition")) {
[10:59:31.602]                         if (!is.null(pattern)) {
[10:59:31.602]                           computeRestarts <- base::computeRestarts
[10:59:31.602]                           grepl <- base::grepl
[10:59:31.602]                           restarts <- computeRestarts(cond)
[10:59:31.602]                           for (restart in restarts) {
[10:59:31.602]                             name <- restart$name
[10:59:31.602]                             if (is.null(name)) 
[10:59:31.602]                               next
[10:59:31.602]                             if (!grepl(pattern, name)) 
[10:59:31.602]                               next
[10:59:31.602]                             invokeRestart(restart)
[10:59:31.602]                             muffled <- TRUE
[10:59:31.602]                             break
[10:59:31.602]                           }
[10:59:31.602]                         }
[10:59:31.602]                       }
[10:59:31.602]                       invisible(muffled)
[10:59:31.602]                     }
[10:59:31.602]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.602]                   }
[10:59:31.602]                 }
[10:59:31.602]             }
[10:59:31.602]         }))
[10:59:31.602]     }, error = function(ex) {
[10:59:31.602]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.602]                 ...future.rng), started = ...future.startTime, 
[10:59:31.602]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.602]             version = "1.8"), class = "FutureResult")
[10:59:31.602]     }, finally = {
[10:59:31.602]         if (!identical(...future.workdir, getwd())) 
[10:59:31.602]             setwd(...future.workdir)
[10:59:31.602]         {
[10:59:31.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.602]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.602]             }
[10:59:31.602]             base::options(...future.oldOptions)
[10:59:31.602]             if (.Platform$OS.type == "windows") {
[10:59:31.602]                 old_names <- names(...future.oldEnvVars)
[10:59:31.602]                 envs <- base::Sys.getenv()
[10:59:31.602]                 names <- names(envs)
[10:59:31.602]                 common <- intersect(names, old_names)
[10:59:31.602]                 added <- setdiff(names, old_names)
[10:59:31.602]                 removed <- setdiff(old_names, names)
[10:59:31.602]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.602]                   envs[common]]
[10:59:31.602]                 NAMES <- toupper(changed)
[10:59:31.602]                 args <- list()
[10:59:31.602]                 for (kk in seq_along(NAMES)) {
[10:59:31.602]                   name <- changed[[kk]]
[10:59:31.602]                   NAME <- NAMES[[kk]]
[10:59:31.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.602]                     next
[10:59:31.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.602]                 }
[10:59:31.602]                 NAMES <- toupper(added)
[10:59:31.602]                 for (kk in seq_along(NAMES)) {
[10:59:31.602]                   name <- added[[kk]]
[10:59:31.602]                   NAME <- NAMES[[kk]]
[10:59:31.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.602]                     next
[10:59:31.602]                   args[[name]] <- ""
[10:59:31.602]                 }
[10:59:31.602]                 NAMES <- toupper(removed)
[10:59:31.602]                 for (kk in seq_along(NAMES)) {
[10:59:31.602]                   name <- removed[[kk]]
[10:59:31.602]                   NAME <- NAMES[[kk]]
[10:59:31.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.602]                     next
[10:59:31.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.602]                 }
[10:59:31.602]                 if (length(args) > 0) 
[10:59:31.602]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.602]             }
[10:59:31.602]             else {
[10:59:31.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.602]             }
[10:59:31.602]             {
[10:59:31.602]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.602]                   0L) {
[10:59:31.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.602]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.602]                   base::options(opts)
[10:59:31.602]                 }
[10:59:31.602]                 {
[10:59:31.602]                   {
[10:59:31.602]                     base::assign(".Random.seed", c(10407L, -1027017971L, 
[10:59:31.602]                     -84354130L, -480752092L, 1047550554L, 409668568L, 
[10:59:31.602]                     -1174182659L), envir = base::globalenv(), 
[10:59:31.602]                       inherits = FALSE)
[10:59:31.602]                     NULL
[10:59:31.602]                   }
[10:59:31.602]                   options(future.plan = NULL)
[10:59:31.602]                   if (is.na(NA_character_)) 
[10:59:31.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.602]                     .init = FALSE)
[10:59:31.602]                 }
[10:59:31.602]             }
[10:59:31.602]         }
[10:59:31.602]     })
[10:59:31.602]     if (TRUE) {
[10:59:31.602]         base::sink(type = "output", split = FALSE)
[10:59:31.602]         if (TRUE) {
[10:59:31.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.602]         }
[10:59:31.602]         else {
[10:59:31.602]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.602]         }
[10:59:31.602]         base::close(...future.stdout)
[10:59:31.602]         ...future.stdout <- NULL
[10:59:31.602]     }
[10:59:31.602]     ...future.result$conditions <- ...future.conditions
[10:59:31.602]     ...future.result$finished <- base::Sys.time()
[10:59:31.602]     ...future.result
[10:59:31.602] }
[10:59:31.603] assign_globals() ...
[10:59:31.603] List of 5
[10:59:31.603]  $ ...future.FUN            :function (x, ...)  
[10:59:31.603]  $ MoreArgs                 : NULL
[10:59:31.603]  $ ...future.elements_ii    :List of 2
[10:59:31.603]   ..$ :List of 4
[10:59:31.603]   .. ..$ : int 1
[10:59:31.603]   .. ..$ : int 2
[10:59:31.603]   .. ..$ : int 3
[10:59:31.603]   .. ..$ : int 4
[10:59:31.603]   ..$ :List of 4
[10:59:31.603]   .. ..$ : int 2
[10:59:31.603]   .. ..$ : int 1
[10:59:31.603]   .. ..$ : int 2
[10:59:31.603]   .. ..$ : int 1
[10:59:31.603]  $ ...future.seeds_ii       : NULL
[10:59:31.603]  $ ...future.globals.maxSize: NULL
[10:59:31.603]  - attr(*, "where")=List of 5
[10:59:31.603]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.603]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.603]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.603]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.603]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.603]  - attr(*, "resolved")= logi FALSE
[10:59:31.603]  - attr(*, "total_size")= num 258
[10:59:31.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.603]  - attr(*, "already-done")= logi TRUE
[10:59:31.610] - copied ‘...future.FUN’ to environment
[10:59:31.610] - copied ‘MoreArgs’ to environment
[10:59:31.610] - copied ‘...future.elements_ii’ to environment
[10:59:31.610] - copied ‘...future.seeds_ii’ to environment
[10:59:31.610] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.610] assign_globals() ... done
[10:59:31.610] plan(): Setting new future strategy stack:
[10:59:31.610] List of future strategies:
[10:59:31.610] 1. sequential:
[10:59:31.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.610]    - tweaked: FALSE
[10:59:31.610]    - call: NULL
[10:59:31.611] plan(): nbrOfWorkers() = 1
[10:59:31.611] plan(): Setting new future strategy stack:
[10:59:31.611] List of future strategies:
[10:59:31.611] 1. sequential:
[10:59:31.611]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.611]    - tweaked: FALSE
[10:59:31.611]    - call: plan(strategy)
[10:59:31.612] plan(): nbrOfWorkers() = 1
[10:59:31.612] SequentialFuture started (and completed)
[10:59:31.612] - Launch lazy future ... done
[10:59:31.612] run() for ‘SequentialFuture’ ... done
[10:59:31.612] Created future:
[10:59:31.612] SequentialFuture:
[10:59:31.612] Label: ‘future_mapply-1’
[10:59:31.612] Expression:
[10:59:31.612] {
[10:59:31.612]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.612]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.612]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.612]         on.exit(options(oopts), add = TRUE)
[10:59:31.612]     }
[10:59:31.612]     {
[10:59:31.612]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.612]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.612]         do.call(mapply, args = args)
[10:59:31.612]     }
[10:59:31.612] }
[10:59:31.612] Lazy evaluation: FALSE
[10:59:31.612] Asynchronous evaluation: FALSE
[10:59:31.612] Local evaluation: TRUE
[10:59:31.612] Environment: R_GlobalEnv
[10:59:31.612] Capture standard output: TRUE
[10:59:31.612] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.612] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.612] Packages: <none>
[10:59:31.612] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.612] Resolved: TRUE
[10:59:31.612] Value: 87 bytes of class ‘list’
[10:59:31.612] Early signaling: FALSE
[10:59:31.612] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.612] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.613] Chunk #1 of 1 ... DONE
[10:59:31.613] Launching 1 futures (chunks) ... DONE
[10:59:31.613] Resolving 1 futures (chunks) ...
[10:59:31.613] resolve() on list ...
[10:59:31.613]  recursive: 0
[10:59:31.613]  length: 1
[10:59:31.614] 
[10:59:31.614] resolved() for ‘SequentialFuture’ ...
[10:59:31.614] - state: ‘finished’
[10:59:31.614] - run: TRUE
[10:59:31.614] - result: ‘FutureResult’
[10:59:31.614] resolved() for ‘SequentialFuture’ ... done
[10:59:31.614] Future #1
[10:59:31.614] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.614] - nx: 1
[10:59:31.614] - relay: TRUE
[10:59:31.614] - stdout: TRUE
[10:59:31.614] - signal: TRUE
[10:59:31.615] - resignal: FALSE
[10:59:31.615] - force: TRUE
[10:59:31.615] - relayed: [n=1] FALSE
[10:59:31.615] - queued futures: [n=1] FALSE
[10:59:31.615]  - until=1
[10:59:31.615]  - relaying element #1
[10:59:31.615] - relayed: [n=1] TRUE
[10:59:31.615] - queued futures: [n=1] TRUE
[10:59:31.615] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.615]  length: 0 (resolved future 1)
[10:59:31.615] Relaying remaining futures
[10:59:31.615] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.616] - nx: 1
[10:59:31.616] - relay: TRUE
[10:59:31.616] - stdout: TRUE
[10:59:31.616] - signal: TRUE
[10:59:31.616] - resignal: FALSE
[10:59:31.616] - force: TRUE
[10:59:31.616] - relayed: [n=1] TRUE
[10:59:31.616] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.616] - relayed: [n=1] TRUE
[10:59:31.616] - queued futures: [n=1] TRUE
[10:59:31.616] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.616] resolve() on list ... DONE
[10:59:31.617]  - Number of value chunks collected: 1
[10:59:31.617] Resolving 1 futures (chunks) ... DONE
[10:59:31.617] Reducing values from 1 chunks ...
[10:59:31.617]  - Number of values collected after concatenation: 4
[10:59:31.617]  - Number of values expected: 4
[10:59:31.617] Reducing values from 1 chunks ... DONE
[10:59:31.617] future_mapply() ... DONE
- Parallel RNG ...
[10:59:31.617] future_mapply() ...
[10:59:31.617] Generating random seeds ...
[10:59:31.617] Generating random seed streams for 4 elements ...
[10:59:31.617] Generating random seed streams for 4 elements ... DONE
[10:59:31.618] Generating random seeds ... DONE
[10:59:31.618] Will set RNG state on exit: 10407, -480752092, -1266986405, -714098766, -1174182659, 1989433655, -1548778925
[10:59:31.618] Number of chunks: 1
[10:59:31.618] getGlobalsAndPackagesXApply() ...
[10:59:31.618]  - future.globals: TRUE
[10:59:31.618] getGlobalsAndPackages() ...
[10:59:31.618] Searching for globals...
[10:59:31.620] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:59:31.620] Searching for globals ... DONE
[10:59:31.620] Resolving globals: FALSE
[10:59:31.621] The total size of the 1 globals is 501 bytes (501 bytes)
[10:59:31.621] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:59:31.621] - globals: [1] ‘FUN’
[10:59:31.621] - packages: [1] ‘stats’
[10:59:31.621] getGlobalsAndPackages() ... DONE
[10:59:31.621]  - globals found/used: [n=1] ‘FUN’
[10:59:31.622]  - needed namespaces: [n=1] ‘stats’
[10:59:31.622] Finding globals ... DONE
[10:59:31.622] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.622] List of 2
[10:59:31.622]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:59:31.622]  $ MoreArgs     :List of 1
[10:59:31.622]   ..$ min: num 1
[10:59:31.622]  - attr(*, "where")=List of 2
[10:59:31.622]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.622]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.622]  - attr(*, "resolved")= logi FALSE
[10:59:31.622]  - attr(*, "total_size")= num NA
[10:59:31.624] Packages to be attached in all futures: [n=1] ‘stats’
[10:59:31.625] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.625] Number of futures (= number of chunks): 1
[10:59:31.625] Launching 1 futures (chunks) ...
[10:59:31.625] Chunk #1 of 1 ...
[10:59:31.625]  - Finding globals in '...' for chunk #1 ...
[10:59:31.625] getGlobalsAndPackages() ...
[10:59:31.625] Searching for globals...
[10:59:31.625] 
[10:59:31.625] Searching for globals ... DONE
[10:59:31.626] - globals: [0] <none>
[10:59:31.626] getGlobalsAndPackages() ... DONE
[10:59:31.626]    + additional globals found: [n=0] 
[10:59:31.626]    + additional namespaces needed: [n=0] 
[10:59:31.626]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.626]  - seeds: [4] <seeds>
[10:59:31.626]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.626] getGlobalsAndPackages() ...
[10:59:31.626] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.626] Resolving globals: FALSE
[10:59:31.627] The total size of the 5 globals is 990 bytes (990 bytes)
[10:59:31.627] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 990 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (196 bytes of class ‘list’) and ‘...future.seeds_ii’ (175 bytes of class ‘list’)
[10:59:31.627] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.627] - packages: [1] ‘stats’
[10:59:31.627] getGlobalsAndPackages() ... DONE
[10:59:31.628] run() for ‘Future’ ...
[10:59:31.628] - state: ‘created’
[10:59:31.628] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.628] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.628]   - Field: ‘label’
[10:59:31.628]   - Field: ‘local’
[10:59:31.628]   - Field: ‘owner’
[10:59:31.629]   - Field: ‘envir’
[10:59:31.629]   - Field: ‘packages’
[10:59:31.629]   - Field: ‘gc’
[10:59:31.629]   - Field: ‘conditions’
[10:59:31.629]   - Field: ‘expr’
[10:59:31.629]   - Field: ‘uuid’
[10:59:31.629]   - Field: ‘seed’
[10:59:31.629]   - Field: ‘version’
[10:59:31.629]   - Field: ‘result’
[10:59:31.629]   - Field: ‘asynchronous’
[10:59:31.629]   - Field: ‘calls’
[10:59:31.629]   - Field: ‘globals’
[10:59:31.630]   - Field: ‘stdout’
[10:59:31.630]   - Field: ‘earlySignal’
[10:59:31.630]   - Field: ‘lazy’
[10:59:31.630]   - Field: ‘state’
[10:59:31.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.630] - Launch lazy future ...
[10:59:31.630] Packages needed by the future expression (n = 1): ‘stats’
[10:59:31.630] Packages needed by future strategies (n = 0): <none>
[10:59:31.631] {
[10:59:31.631]     {
[10:59:31.631]         {
[10:59:31.631]             ...future.startTime <- base::Sys.time()
[10:59:31.631]             {
[10:59:31.631]                 {
[10:59:31.631]                   {
[10:59:31.631]                     {
[10:59:31.631]                       base::local({
[10:59:31.631]                         has_future <- base::requireNamespace("future", 
[10:59:31.631]                           quietly = TRUE)
[10:59:31.631]                         if (has_future) {
[10:59:31.631]                           ns <- base::getNamespace("future")
[10:59:31.631]                           version <- ns[[".package"]][["version"]]
[10:59:31.631]                           if (is.null(version)) 
[10:59:31.631]                             version <- utils::packageVersion("future")
[10:59:31.631]                         }
[10:59:31.631]                         else {
[10:59:31.631]                           version <- NULL
[10:59:31.631]                         }
[10:59:31.631]                         if (!has_future || version < "1.8.0") {
[10:59:31.631]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.631]                             "", base::R.version$version.string), 
[10:59:31.631]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.631]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.631]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.631]                               "release", "version")], collapse = " "), 
[10:59:31.631]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.631]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.631]                             info)
[10:59:31.631]                           info <- base::paste(info, collapse = "; ")
[10:59:31.631]                           if (!has_future) {
[10:59:31.631]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.631]                               info)
[10:59:31.631]                           }
[10:59:31.631]                           else {
[10:59:31.631]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.631]                               info, version)
[10:59:31.631]                           }
[10:59:31.631]                           base::stop(msg)
[10:59:31.631]                         }
[10:59:31.631]                       })
[10:59:31.631]                     }
[10:59:31.631]                     base::local({
[10:59:31.631]                       for (pkg in "stats") {
[10:59:31.631]                         base::loadNamespace(pkg)
[10:59:31.631]                         base::library(pkg, character.only = TRUE)
[10:59:31.631]                       }
[10:59:31.631]                     })
[10:59:31.631]                   }
[10:59:31.631]                   ...future.strategy.old <- future::plan("list")
[10:59:31.631]                   options(future.plan = NULL)
[10:59:31.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.631]                 }
[10:59:31.631]                 ...future.workdir <- getwd()
[10:59:31.631]             }
[10:59:31.631]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.631]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.631]         }
[10:59:31.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.631]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.631]             base::names(...future.oldOptions))
[10:59:31.631]     }
[10:59:31.631]     if (FALSE) {
[10:59:31.631]     }
[10:59:31.631]     else {
[10:59:31.631]         if (TRUE) {
[10:59:31.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.631]                 open = "w")
[10:59:31.631]         }
[10:59:31.631]         else {
[10:59:31.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.631]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.631]         }
[10:59:31.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.631]             base::sink(type = "output", split = FALSE)
[10:59:31.631]             base::close(...future.stdout)
[10:59:31.631]         }, add = TRUE)
[10:59:31.631]     }
[10:59:31.631]     ...future.frame <- base::sys.nframe()
[10:59:31.631]     ...future.conditions <- base::list()
[10:59:31.631]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.631]     if (FALSE) {
[10:59:31.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.631]     }
[10:59:31.631]     ...future.result <- base::tryCatch({
[10:59:31.631]         base::withCallingHandlers({
[10:59:31.631]             ...future.value <- base::withVisible(base::local({
[10:59:31.631]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.631]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.631]                   ...future.globals.maxSize)) {
[10:59:31.631]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.631]                   on.exit(options(oopts), add = TRUE)
[10:59:31.631]                 }
[10:59:31.631]                 {
[10:59:31.631]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:31.631]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:31.631]                       envir = globalenv(), inherits = FALSE)
[10:59:31.631]                     ...future.FUN(...)
[10:59:31.631]                   }
[10:59:31.631]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:31.631]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:31.631]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.631]                     USE.NAMES = FALSE)
[10:59:31.631]                   do.call(mapply, args = args)
[10:59:31.631]                 }
[10:59:31.631]             }))
[10:59:31.631]             future::FutureResult(value = ...future.value$value, 
[10:59:31.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.631]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.631]                     ...future.globalenv.names))
[10:59:31.631]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.631]         }, condition = base::local({
[10:59:31.631]             c <- base::c
[10:59:31.631]             inherits <- base::inherits
[10:59:31.631]             invokeRestart <- base::invokeRestart
[10:59:31.631]             length <- base::length
[10:59:31.631]             list <- base::list
[10:59:31.631]             seq.int <- base::seq.int
[10:59:31.631]             signalCondition <- base::signalCondition
[10:59:31.631]             sys.calls <- base::sys.calls
[10:59:31.631]             `[[` <- base::`[[`
[10:59:31.631]             `+` <- base::`+`
[10:59:31.631]             `<<-` <- base::`<<-`
[10:59:31.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.631]                   3L)]
[10:59:31.631]             }
[10:59:31.631]             function(cond) {
[10:59:31.631]                 is_error <- inherits(cond, "error")
[10:59:31.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.631]                   NULL)
[10:59:31.631]                 if (is_error) {
[10:59:31.631]                   sessionInformation <- function() {
[10:59:31.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.631]                       search = base::search(), system = base::Sys.info())
[10:59:31.631]                   }
[10:59:31.631]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.631]                     cond$call), session = sessionInformation(), 
[10:59:31.631]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.631]                   signalCondition(cond)
[10:59:31.631]                 }
[10:59:31.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.631]                 "immediateCondition"))) {
[10:59:31.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.631]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.631]                   if (TRUE && !signal) {
[10:59:31.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.631]                     {
[10:59:31.631]                       inherits <- base::inherits
[10:59:31.631]                       invokeRestart <- base::invokeRestart
[10:59:31.631]                       is.null <- base::is.null
[10:59:31.631]                       muffled <- FALSE
[10:59:31.631]                       if (inherits(cond, "message")) {
[10:59:31.631]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.631]                         if (muffled) 
[10:59:31.631]                           invokeRestart("muffleMessage")
[10:59:31.631]                       }
[10:59:31.631]                       else if (inherits(cond, "warning")) {
[10:59:31.631]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.631]                         if (muffled) 
[10:59:31.631]                           invokeRestart("muffleWarning")
[10:59:31.631]                       }
[10:59:31.631]                       else if (inherits(cond, "condition")) {
[10:59:31.631]                         if (!is.null(pattern)) {
[10:59:31.631]                           computeRestarts <- base::computeRestarts
[10:59:31.631]                           grepl <- base::grepl
[10:59:31.631]                           restarts <- computeRestarts(cond)
[10:59:31.631]                           for (restart in restarts) {
[10:59:31.631]                             name <- restart$name
[10:59:31.631]                             if (is.null(name)) 
[10:59:31.631]                               next
[10:59:31.631]                             if (!grepl(pattern, name)) 
[10:59:31.631]                               next
[10:59:31.631]                             invokeRestart(restart)
[10:59:31.631]                             muffled <- TRUE
[10:59:31.631]                             break
[10:59:31.631]                           }
[10:59:31.631]                         }
[10:59:31.631]                       }
[10:59:31.631]                       invisible(muffled)
[10:59:31.631]                     }
[10:59:31.631]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.631]                   }
[10:59:31.631]                 }
[10:59:31.631]                 else {
[10:59:31.631]                   if (TRUE) {
[10:59:31.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.631]                     {
[10:59:31.631]                       inherits <- base::inherits
[10:59:31.631]                       invokeRestart <- base::invokeRestart
[10:59:31.631]                       is.null <- base::is.null
[10:59:31.631]                       muffled <- FALSE
[10:59:31.631]                       if (inherits(cond, "message")) {
[10:59:31.631]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.631]                         if (muffled) 
[10:59:31.631]                           invokeRestart("muffleMessage")
[10:59:31.631]                       }
[10:59:31.631]                       else if (inherits(cond, "warning")) {
[10:59:31.631]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.631]                         if (muffled) 
[10:59:31.631]                           invokeRestart("muffleWarning")
[10:59:31.631]                       }
[10:59:31.631]                       else if (inherits(cond, "condition")) {
[10:59:31.631]                         if (!is.null(pattern)) {
[10:59:31.631]                           computeRestarts <- base::computeRestarts
[10:59:31.631]                           grepl <- base::grepl
[10:59:31.631]                           restarts <- computeRestarts(cond)
[10:59:31.631]                           for (restart in restarts) {
[10:59:31.631]                             name <- restart$name
[10:59:31.631]                             if (is.null(name)) 
[10:59:31.631]                               next
[10:59:31.631]                             if (!grepl(pattern, name)) 
[10:59:31.631]                               next
[10:59:31.631]                             invokeRestart(restart)
[10:59:31.631]                             muffled <- TRUE
[10:59:31.631]                             break
[10:59:31.631]                           }
[10:59:31.631]                         }
[10:59:31.631]                       }
[10:59:31.631]                       invisible(muffled)
[10:59:31.631]                     }
[10:59:31.631]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.631]                   }
[10:59:31.631]                 }
[10:59:31.631]             }
[10:59:31.631]         }))
[10:59:31.631]     }, error = function(ex) {
[10:59:31.631]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.631]                 ...future.rng), started = ...future.startTime, 
[10:59:31.631]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.631]             version = "1.8"), class = "FutureResult")
[10:59:31.631]     }, finally = {
[10:59:31.631]         if (!identical(...future.workdir, getwd())) 
[10:59:31.631]             setwd(...future.workdir)
[10:59:31.631]         {
[10:59:31.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.631]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.631]             }
[10:59:31.631]             base::options(...future.oldOptions)
[10:59:31.631]             if (.Platform$OS.type == "windows") {
[10:59:31.631]                 old_names <- names(...future.oldEnvVars)
[10:59:31.631]                 envs <- base::Sys.getenv()
[10:59:31.631]                 names <- names(envs)
[10:59:31.631]                 common <- intersect(names, old_names)
[10:59:31.631]                 added <- setdiff(names, old_names)
[10:59:31.631]                 removed <- setdiff(old_names, names)
[10:59:31.631]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.631]                   envs[common]]
[10:59:31.631]                 NAMES <- toupper(changed)
[10:59:31.631]                 args <- list()
[10:59:31.631]                 for (kk in seq_along(NAMES)) {
[10:59:31.631]                   name <- changed[[kk]]
[10:59:31.631]                   NAME <- NAMES[[kk]]
[10:59:31.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.631]                     next
[10:59:31.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.631]                 }
[10:59:31.631]                 NAMES <- toupper(added)
[10:59:31.631]                 for (kk in seq_along(NAMES)) {
[10:59:31.631]                   name <- added[[kk]]
[10:59:31.631]                   NAME <- NAMES[[kk]]
[10:59:31.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.631]                     next
[10:59:31.631]                   args[[name]] <- ""
[10:59:31.631]                 }
[10:59:31.631]                 NAMES <- toupper(removed)
[10:59:31.631]                 for (kk in seq_along(NAMES)) {
[10:59:31.631]                   name <- removed[[kk]]
[10:59:31.631]                   NAME <- NAMES[[kk]]
[10:59:31.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.631]                     next
[10:59:31.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.631]                 }
[10:59:31.631]                 if (length(args) > 0) 
[10:59:31.631]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.631]             }
[10:59:31.631]             else {
[10:59:31.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.631]             }
[10:59:31.631]             {
[10:59:31.631]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.631]                   0L) {
[10:59:31.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.631]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.631]                   base::options(opts)
[10:59:31.631]                 }
[10:59:31.631]                 {
[10:59:31.631]                   {
[10:59:31.631]                     base::assign(".Random.seed", c(10407L, -480752092L, 
[10:59:31.631]                     -1266986405L, -714098766L, -1174182659L, 
[10:59:31.631]                     1989433655L, -1548778925L), envir = base::globalenv(), 
[10:59:31.631]                       inherits = FALSE)
[10:59:31.631]                     NULL
[10:59:31.631]                   }
[10:59:31.631]                   options(future.plan = NULL)
[10:59:31.631]                   if (is.na(NA_character_)) 
[10:59:31.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.631]                     .init = FALSE)
[10:59:31.631]                 }
[10:59:31.631]             }
[10:59:31.631]         }
[10:59:31.631]     })
[10:59:31.631]     if (TRUE) {
[10:59:31.631]         base::sink(type = "output", split = FALSE)
[10:59:31.631]         if (TRUE) {
[10:59:31.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.631]         }
[10:59:31.631]         else {
[10:59:31.631]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.631]         }
[10:59:31.631]         base::close(...future.stdout)
[10:59:31.631]         ...future.stdout <- NULL
[10:59:31.631]     }
[10:59:31.631]     ...future.result$conditions <- ...future.conditions
[10:59:31.631]     ...future.result$finished <- base::Sys.time()
[10:59:31.631]     ...future.result
[10:59:31.631] }
[10:59:31.632] assign_globals() ...
[10:59:31.633] List of 5
[10:59:31.633]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:59:31.633]  $ MoreArgs                 :List of 1
[10:59:31.633]   ..$ min: num 1
[10:59:31.633]  $ ...future.elements_ii    :List of 2
[10:59:31.633]   ..$ n  :List of 4
[10:59:31.633]   .. ..$ : int 1
[10:59:31.633]   .. ..$ : int 2
[10:59:31.633]   .. ..$ : int 3
[10:59:31.633]   .. ..$ : int 4
[10:59:31.633]   ..$ max:List of 4
[10:59:31.633]   .. ..$ : int 2
[10:59:31.633]   .. ..$ : int 3
[10:59:31.633]   .. ..$ : int 4
[10:59:31.633]   .. ..$ : int 5
[10:59:31.633]  $ ...future.seeds_ii       :List of 4
[10:59:31.633]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:59:31.633]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:59:31.633]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:59:31.633]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:59:31.633]  $ ...future.globals.maxSize: NULL
[10:59:31.633]  - attr(*, "where")=List of 5
[10:59:31.633]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.633]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.633]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.633]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.633]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.633]  - attr(*, "resolved")= logi FALSE
[10:59:31.633]  - attr(*, "total_size")= num 990
[10:59:31.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.633]  - attr(*, "already-done")= logi TRUE
[10:59:31.641] - copied ‘...future.FUN’ to environment
[10:59:31.641] - copied ‘MoreArgs’ to environment
[10:59:31.641] - copied ‘...future.elements_ii’ to environment
[10:59:31.641] - copied ‘...future.seeds_ii’ to environment
[10:59:31.642] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.642] assign_globals() ... done
[10:59:31.642] plan(): Setting new future strategy stack:
[10:59:31.642] List of future strategies:
[10:59:31.642] 1. sequential:
[10:59:31.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.642]    - tweaked: FALSE
[10:59:31.642]    - call: NULL
[10:59:31.642] plan(): nbrOfWorkers() = 1
[10:59:31.643] plan(): Setting new future strategy stack:
[10:59:31.643] List of future strategies:
[10:59:31.643] 1. sequential:
[10:59:31.643]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.643]    - tweaked: FALSE
[10:59:31.643]    - call: plan(strategy)
[10:59:31.644] plan(): nbrOfWorkers() = 1
[10:59:31.644] SequentialFuture started (and completed)
[10:59:31.644] - Launch lazy future ... done
[10:59:31.644] run() for ‘SequentialFuture’ ... done
[10:59:31.644] Created future:
[10:59:31.644] SequentialFuture:
[10:59:31.644] Label: ‘future_mapply-1’
[10:59:31.644] Expression:
[10:59:31.644] {
[10:59:31.644]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.644]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.644]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.644]         on.exit(options(oopts), add = TRUE)
[10:59:31.644]     }
[10:59:31.644]     {
[10:59:31.644]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:31.644]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:31.644]                 inherits = FALSE)
[10:59:31.644]             ...future.FUN(...)
[10:59:31.644]         }
[10:59:31.644]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:31.644]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:31.644]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.644]         do.call(mapply, args = args)
[10:59:31.644]     }
[10:59:31.644] }
[10:59:31.644] Lazy evaluation: FALSE
[10:59:31.644] Asynchronous evaluation: FALSE
[10:59:31.644] Local evaluation: TRUE
[10:59:31.644] Environment: R_GlobalEnv
[10:59:31.644] Capture standard output: TRUE
[10:59:31.644] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.644] Globals: 5 objects totaling 990 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 196 bytes, list ‘...future.seeds_ii’ of 175 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.644] Packages: 1 packages (‘stats’)
[10:59:31.644] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:31.644] Resolved: TRUE
[10:59:31.644] Value: 143 bytes of class ‘list’
[10:59:31.644] Early signaling: FALSE
[10:59:31.644] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.644] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.645] Chunk #1 of 1 ... DONE
[10:59:31.645] Launching 1 futures (chunks) ... DONE
[10:59:31.645] Resolving 1 futures (chunks) ...
[10:59:31.645] resolve() on list ...
[10:59:31.645]  recursive: 0
[10:59:31.645]  length: 1
[10:59:31.645] 
[10:59:31.645] resolved() for ‘SequentialFuture’ ...
[10:59:31.646] - state: ‘finished’
[10:59:31.646] - run: TRUE
[10:59:31.646] - result: ‘FutureResult’
[10:59:31.646] resolved() for ‘SequentialFuture’ ... done
[10:59:31.646] Future #1
[10:59:31.646] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.646] - nx: 1
[10:59:31.646] - relay: TRUE
[10:59:31.646] - stdout: TRUE
[10:59:31.646] - signal: TRUE
[10:59:31.646] - resignal: FALSE
[10:59:31.646] - force: TRUE
[10:59:31.646] - relayed: [n=1] FALSE
[10:59:31.647] - queued futures: [n=1] FALSE
[10:59:31.647]  - until=1
[10:59:31.647]  - relaying element #1
[10:59:31.647] - relayed: [n=1] TRUE
[10:59:31.647] - queued futures: [n=1] TRUE
[10:59:31.647] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.647]  length: 0 (resolved future 1)
[10:59:31.647] Relaying remaining futures
[10:59:31.647] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.647] - nx: 1
[10:59:31.647] - relay: TRUE
[10:59:31.647] - stdout: TRUE
[10:59:31.648] - signal: TRUE
[10:59:31.648] - resignal: FALSE
[10:59:31.648] - force: TRUE
[10:59:31.648] - relayed: [n=1] TRUE
[10:59:31.648] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.648] - relayed: [n=1] TRUE
[10:59:31.648] - queued futures: [n=1] TRUE
[10:59:31.648] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.648] resolve() on list ... DONE
[10:59:31.648]  - Number of value chunks collected: 1
[10:59:31.648] Resolving 1 futures (chunks) ... DONE
[10:59:31.648] Reducing values from 1 chunks ...
[10:59:31.649]  - Number of values collected after concatenation: 4
[10:59:31.649]  - Number of values expected: 4
[10:59:31.649] Reducing values from 1 chunks ... DONE
[10:59:31.649] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:59:31.651] future_mapply() ...
[10:59:31.651] Number of chunks: 1
[10:59:31.651] getGlobalsAndPackagesXApply() ...
[10:59:31.651]  - future.globals: TRUE
[10:59:31.651] getGlobalsAndPackages() ...
[10:59:31.651] Searching for globals...
[10:59:31.652] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:59:31.652] Searching for globals ... DONE
[10:59:31.652] Resolving globals: FALSE
[10:59:31.653] The total size of the 1 globals is 337 bytes (337 bytes)
[10:59:31.653] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[10:59:31.653] - globals: [1] ‘FUN’
[10:59:31.653] - packages: [1] ‘stats’
[10:59:31.653] getGlobalsAndPackages() ... DONE
[10:59:31.653]  - globals found/used: [n=1] ‘FUN’
[10:59:31.654]  - needed namespaces: [n=1] ‘stats’
[10:59:31.654] Finding globals ... DONE
[10:59:31.654] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.654] List of 2
[10:59:31.654]  $ ...future.FUN:function (x, w, ...)  
[10:59:31.654]  $ MoreArgs     : NULL
[10:59:31.654]  - attr(*, "where")=List of 2
[10:59:31.654]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.654]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.654]  - attr(*, "resolved")= logi FALSE
[10:59:31.654]  - attr(*, "total_size")= num NA
[10:59:31.656] Packages to be attached in all futures: [n=1] ‘stats’
[10:59:31.656] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.656] Number of futures (= number of chunks): 1
[10:59:31.656] Launching 1 futures (chunks) ...
[10:59:31.657] Chunk #1 of 1 ...
[10:59:31.657]  - Finding globals in '...' for chunk #1 ...
[10:59:31.657] getGlobalsAndPackages() ...
[10:59:31.657] Searching for globals...
[10:59:31.659] 
[10:59:31.659] Searching for globals ... DONE
[10:59:31.659] - globals: [0] <none>
[10:59:31.659] getGlobalsAndPackages() ... DONE
[10:59:31.660]    + additional globals found: [n=0] 
[10:59:31.660]    + additional namespaces needed: [n=0] 
[10:59:31.660]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.660]  - seeds: <none>
[10:59:31.660]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.660] getGlobalsAndPackages() ...
[10:59:31.660] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.660] Resolving globals: FALSE
[10:59:31.660] The total size of the 5 globals is 1.31 KiB (1345 bytes)
[10:59:31.661] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (927 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.661] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.661] - packages: [1] ‘stats’
[10:59:31.661] getGlobalsAndPackages() ... DONE
[10:59:31.662] run() for ‘Future’ ...
[10:59:31.662] - state: ‘created’
[10:59:31.662] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.662] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.662] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.662]   - Field: ‘label’
[10:59:31.662]   - Field: ‘local’
[10:59:31.662]   - Field: ‘owner’
[10:59:31.662]   - Field: ‘envir’
[10:59:31.663]   - Field: ‘packages’
[10:59:31.663]   - Field: ‘gc’
[10:59:31.663]   - Field: ‘conditions’
[10:59:31.663]   - Field: ‘expr’
[10:59:31.663]   - Field: ‘uuid’
[10:59:31.663]   - Field: ‘seed’
[10:59:31.663]   - Field: ‘version’
[10:59:31.663]   - Field: ‘result’
[10:59:31.663]   - Field: ‘asynchronous’
[10:59:31.663]   - Field: ‘calls’
[10:59:31.663]   - Field: ‘globals’
[10:59:31.663]   - Field: ‘stdout’
[10:59:31.663]   - Field: ‘earlySignal’
[10:59:31.664]   - Field: ‘lazy’
[10:59:31.664]   - Field: ‘state’
[10:59:31.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.664] - Launch lazy future ...
[10:59:31.664] Packages needed by the future expression (n = 1): ‘stats’
[10:59:31.664] Packages needed by future strategies (n = 0): <none>
[10:59:31.664] {
[10:59:31.664]     {
[10:59:31.664]         {
[10:59:31.664]             ...future.startTime <- base::Sys.time()
[10:59:31.664]             {
[10:59:31.664]                 {
[10:59:31.664]                   {
[10:59:31.664]                     {
[10:59:31.664]                       base::local({
[10:59:31.664]                         has_future <- base::requireNamespace("future", 
[10:59:31.664]                           quietly = TRUE)
[10:59:31.664]                         if (has_future) {
[10:59:31.664]                           ns <- base::getNamespace("future")
[10:59:31.664]                           version <- ns[[".package"]][["version"]]
[10:59:31.664]                           if (is.null(version)) 
[10:59:31.664]                             version <- utils::packageVersion("future")
[10:59:31.664]                         }
[10:59:31.664]                         else {
[10:59:31.664]                           version <- NULL
[10:59:31.664]                         }
[10:59:31.664]                         if (!has_future || version < "1.8.0") {
[10:59:31.664]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.664]                             "", base::R.version$version.string), 
[10:59:31.664]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.664]                               "release", "version")], collapse = " "), 
[10:59:31.664]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.664]                             info)
[10:59:31.664]                           info <- base::paste(info, collapse = "; ")
[10:59:31.664]                           if (!has_future) {
[10:59:31.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.664]                               info)
[10:59:31.664]                           }
[10:59:31.664]                           else {
[10:59:31.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.664]                               info, version)
[10:59:31.664]                           }
[10:59:31.664]                           base::stop(msg)
[10:59:31.664]                         }
[10:59:31.664]                       })
[10:59:31.664]                     }
[10:59:31.664]                     base::local({
[10:59:31.664]                       for (pkg in "stats") {
[10:59:31.664]                         base::loadNamespace(pkg)
[10:59:31.664]                         base::library(pkg, character.only = TRUE)
[10:59:31.664]                       }
[10:59:31.664]                     })
[10:59:31.664]                   }
[10:59:31.664]                   ...future.strategy.old <- future::plan("list")
[10:59:31.664]                   options(future.plan = NULL)
[10:59:31.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.664]                 }
[10:59:31.664]                 ...future.workdir <- getwd()
[10:59:31.664]             }
[10:59:31.664]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.664]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.664]         }
[10:59:31.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.664]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.664]             base::names(...future.oldOptions))
[10:59:31.664]     }
[10:59:31.664]     if (FALSE) {
[10:59:31.664]     }
[10:59:31.664]     else {
[10:59:31.664]         if (TRUE) {
[10:59:31.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.664]                 open = "w")
[10:59:31.664]         }
[10:59:31.664]         else {
[10:59:31.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.664]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.664]         }
[10:59:31.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.664]             base::sink(type = "output", split = FALSE)
[10:59:31.664]             base::close(...future.stdout)
[10:59:31.664]         }, add = TRUE)
[10:59:31.664]     }
[10:59:31.664]     ...future.frame <- base::sys.nframe()
[10:59:31.664]     ...future.conditions <- base::list()
[10:59:31.664]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.664]     if (FALSE) {
[10:59:31.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.664]     }
[10:59:31.664]     ...future.result <- base::tryCatch({
[10:59:31.664]         base::withCallingHandlers({
[10:59:31.664]             ...future.value <- base::withVisible(base::local({
[10:59:31.664]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.664]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.664]                   ...future.globals.maxSize)) {
[10:59:31.664]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.664]                   on.exit(options(oopts), add = TRUE)
[10:59:31.664]                 }
[10:59:31.664]                 {
[10:59:31.664]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.664]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.664]                     USE.NAMES = FALSE)
[10:59:31.664]                   do.call(mapply, args = args)
[10:59:31.664]                 }
[10:59:31.664]             }))
[10:59:31.664]             future::FutureResult(value = ...future.value$value, 
[10:59:31.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.664]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.664]                     ...future.globalenv.names))
[10:59:31.664]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.664]         }, condition = base::local({
[10:59:31.664]             c <- base::c
[10:59:31.664]             inherits <- base::inherits
[10:59:31.664]             invokeRestart <- base::invokeRestart
[10:59:31.664]             length <- base::length
[10:59:31.664]             list <- base::list
[10:59:31.664]             seq.int <- base::seq.int
[10:59:31.664]             signalCondition <- base::signalCondition
[10:59:31.664]             sys.calls <- base::sys.calls
[10:59:31.664]             `[[` <- base::`[[`
[10:59:31.664]             `+` <- base::`+`
[10:59:31.664]             `<<-` <- base::`<<-`
[10:59:31.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.664]                   3L)]
[10:59:31.664]             }
[10:59:31.664]             function(cond) {
[10:59:31.664]                 is_error <- inherits(cond, "error")
[10:59:31.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.664]                   NULL)
[10:59:31.664]                 if (is_error) {
[10:59:31.664]                   sessionInformation <- function() {
[10:59:31.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.664]                       search = base::search(), system = base::Sys.info())
[10:59:31.664]                   }
[10:59:31.664]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.664]                     cond$call), session = sessionInformation(), 
[10:59:31.664]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.664]                   signalCondition(cond)
[10:59:31.664]                 }
[10:59:31.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.664]                 "immediateCondition"))) {
[10:59:31.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.664]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.664]                   if (TRUE && !signal) {
[10:59:31.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.664]                     {
[10:59:31.664]                       inherits <- base::inherits
[10:59:31.664]                       invokeRestart <- base::invokeRestart
[10:59:31.664]                       is.null <- base::is.null
[10:59:31.664]                       muffled <- FALSE
[10:59:31.664]                       if (inherits(cond, "message")) {
[10:59:31.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.664]                         if (muffled) 
[10:59:31.664]                           invokeRestart("muffleMessage")
[10:59:31.664]                       }
[10:59:31.664]                       else if (inherits(cond, "warning")) {
[10:59:31.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.664]                         if (muffled) 
[10:59:31.664]                           invokeRestart("muffleWarning")
[10:59:31.664]                       }
[10:59:31.664]                       else if (inherits(cond, "condition")) {
[10:59:31.664]                         if (!is.null(pattern)) {
[10:59:31.664]                           computeRestarts <- base::computeRestarts
[10:59:31.664]                           grepl <- base::grepl
[10:59:31.664]                           restarts <- computeRestarts(cond)
[10:59:31.664]                           for (restart in restarts) {
[10:59:31.664]                             name <- restart$name
[10:59:31.664]                             if (is.null(name)) 
[10:59:31.664]                               next
[10:59:31.664]                             if (!grepl(pattern, name)) 
[10:59:31.664]                               next
[10:59:31.664]                             invokeRestart(restart)
[10:59:31.664]                             muffled <- TRUE
[10:59:31.664]                             break
[10:59:31.664]                           }
[10:59:31.664]                         }
[10:59:31.664]                       }
[10:59:31.664]                       invisible(muffled)
[10:59:31.664]                     }
[10:59:31.664]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.664]                   }
[10:59:31.664]                 }
[10:59:31.664]                 else {
[10:59:31.664]                   if (TRUE) {
[10:59:31.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.664]                     {
[10:59:31.664]                       inherits <- base::inherits
[10:59:31.664]                       invokeRestart <- base::invokeRestart
[10:59:31.664]                       is.null <- base::is.null
[10:59:31.664]                       muffled <- FALSE
[10:59:31.664]                       if (inherits(cond, "message")) {
[10:59:31.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.664]                         if (muffled) 
[10:59:31.664]                           invokeRestart("muffleMessage")
[10:59:31.664]                       }
[10:59:31.664]                       else if (inherits(cond, "warning")) {
[10:59:31.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.664]                         if (muffled) 
[10:59:31.664]                           invokeRestart("muffleWarning")
[10:59:31.664]                       }
[10:59:31.664]                       else if (inherits(cond, "condition")) {
[10:59:31.664]                         if (!is.null(pattern)) {
[10:59:31.664]                           computeRestarts <- base::computeRestarts
[10:59:31.664]                           grepl <- base::grepl
[10:59:31.664]                           restarts <- computeRestarts(cond)
[10:59:31.664]                           for (restart in restarts) {
[10:59:31.664]                             name <- restart$name
[10:59:31.664]                             if (is.null(name)) 
[10:59:31.664]                               next
[10:59:31.664]                             if (!grepl(pattern, name)) 
[10:59:31.664]                               next
[10:59:31.664]                             invokeRestart(restart)
[10:59:31.664]                             muffled <- TRUE
[10:59:31.664]                             break
[10:59:31.664]                           }
[10:59:31.664]                         }
[10:59:31.664]                       }
[10:59:31.664]                       invisible(muffled)
[10:59:31.664]                     }
[10:59:31.664]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.664]                   }
[10:59:31.664]                 }
[10:59:31.664]             }
[10:59:31.664]         }))
[10:59:31.664]     }, error = function(ex) {
[10:59:31.664]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.664]                 ...future.rng), started = ...future.startTime, 
[10:59:31.664]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.664]             version = "1.8"), class = "FutureResult")
[10:59:31.664]     }, finally = {
[10:59:31.664]         if (!identical(...future.workdir, getwd())) 
[10:59:31.664]             setwd(...future.workdir)
[10:59:31.664]         {
[10:59:31.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.664]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.664]             }
[10:59:31.664]             base::options(...future.oldOptions)
[10:59:31.664]             if (.Platform$OS.type == "windows") {
[10:59:31.664]                 old_names <- names(...future.oldEnvVars)
[10:59:31.664]                 envs <- base::Sys.getenv()
[10:59:31.664]                 names <- names(envs)
[10:59:31.664]                 common <- intersect(names, old_names)
[10:59:31.664]                 added <- setdiff(names, old_names)
[10:59:31.664]                 removed <- setdiff(old_names, names)
[10:59:31.664]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.664]                   envs[common]]
[10:59:31.664]                 NAMES <- toupper(changed)
[10:59:31.664]                 args <- list()
[10:59:31.664]                 for (kk in seq_along(NAMES)) {
[10:59:31.664]                   name <- changed[[kk]]
[10:59:31.664]                   NAME <- NAMES[[kk]]
[10:59:31.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.664]                     next
[10:59:31.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.664]                 }
[10:59:31.664]                 NAMES <- toupper(added)
[10:59:31.664]                 for (kk in seq_along(NAMES)) {
[10:59:31.664]                   name <- added[[kk]]
[10:59:31.664]                   NAME <- NAMES[[kk]]
[10:59:31.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.664]                     next
[10:59:31.664]                   args[[name]] <- ""
[10:59:31.664]                 }
[10:59:31.664]                 NAMES <- toupper(removed)
[10:59:31.664]                 for (kk in seq_along(NAMES)) {
[10:59:31.664]                   name <- removed[[kk]]
[10:59:31.664]                   NAME <- NAMES[[kk]]
[10:59:31.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.664]                     next
[10:59:31.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.664]                 }
[10:59:31.664]                 if (length(args) > 0) 
[10:59:31.664]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.664]             }
[10:59:31.664]             else {
[10:59:31.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.664]             }
[10:59:31.664]             {
[10:59:31.664]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.664]                   0L) {
[10:59:31.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.664]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.664]                   base::options(opts)
[10:59:31.664]                 }
[10:59:31.664]                 {
[10:59:31.664]                   {
[10:59:31.664]                     base::assign(".Random.seed", c(10407L, -54483287L, 
[10:59:31.664]                     805746024L, -1268229531L, -880604942L, -655286988L, 
[10:59:31.664]                     724716582L), envir = base::globalenv(), inherits = FALSE)
[10:59:31.664]                     NULL
[10:59:31.664]                   }
[10:59:31.664]                   options(future.plan = NULL)
[10:59:31.664]                   if (is.na(NA_character_)) 
[10:59:31.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.664]                     .init = FALSE)
[10:59:31.664]                 }
[10:59:31.664]             }
[10:59:31.664]         }
[10:59:31.664]     })
[10:59:31.664]     if (TRUE) {
[10:59:31.664]         base::sink(type = "output", split = FALSE)
[10:59:31.664]         if (TRUE) {
[10:59:31.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.664]         }
[10:59:31.664]         else {
[10:59:31.664]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.664]         }
[10:59:31.664]         base::close(...future.stdout)
[10:59:31.664]         ...future.stdout <- NULL
[10:59:31.664]     }
[10:59:31.664]     ...future.result$conditions <- ...future.conditions
[10:59:31.664]     ...future.result$finished <- base::Sys.time()
[10:59:31.664]     ...future.result
[10:59:31.664] }
[10:59:31.666] assign_globals() ...
[10:59:31.666] List of 5
[10:59:31.666]  $ ...future.FUN            :function (x, w, ...)  
[10:59:31.666]  $ MoreArgs                 : NULL
[10:59:31.666]  $ ...future.elements_ii    :List of 2
[10:59:31.666]   ..$ :List of 5
[10:59:31.666]   .. ..$ : num [1:10] 0.8916 0.0924 0.5055 0.2841 0.1376 ...
[10:59:31.666]   .. ..$ : num [1:10] 0.332 0.675 0.53 0.02 0.366 ...
[10:59:31.666]   .. ..$ : num [1:10] 0.0791 0.824 0.5096 0.0399 0.2948 ...
[10:59:31.666]   .. ..$ : num [1:10] 0.139 0.728 0.847 0.471 0.804 ...
[10:59:31.666]   .. ..$ : num [1:10] 0.278 0.985 0.751 0.421 0.483 ...
[10:59:31.666]   ..$ :List of 5
[10:59:31.666]   .. ..$ : num [1:10] 4 2 6 5 10 10 5 6 10 5
[10:59:31.666]   .. ..$ : num [1:10] 5 7 6 7 6 6 5 5 8 3
[10:59:31.666]   .. ..$ : num [1:10] 9 5 10 5 6 5 6 7 6 10
[10:59:31.666]   .. ..$ : num [1:10] 3 5 7 3 9 2 6 5 5 4
[10:59:31.666]   .. ..$ : num [1:10] 9 9 3 6 7 4 5 4 5 6
[10:59:31.666]  $ ...future.seeds_ii       : NULL
[10:59:31.666]  $ ...future.globals.maxSize: NULL
[10:59:31.666]  - attr(*, "where")=List of 5
[10:59:31.666]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.666]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.666]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.666]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.666]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.666]  - attr(*, "resolved")= logi FALSE
[10:59:31.666]  - attr(*, "total_size")= num 1345
[10:59:31.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.666]  - attr(*, "already-done")= logi TRUE
[10:59:31.673] - copied ‘...future.FUN’ to environment
[10:59:31.673] - copied ‘MoreArgs’ to environment
[10:59:31.673] - copied ‘...future.elements_ii’ to environment
[10:59:31.673] - copied ‘...future.seeds_ii’ to environment
[10:59:31.674] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.674] assign_globals() ... done
[10:59:31.674] plan(): Setting new future strategy stack:
[10:59:31.674] List of future strategies:
[10:59:31.674] 1. sequential:
[10:59:31.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.674]    - tweaked: FALSE
[10:59:31.674]    - call: NULL
[10:59:31.674] plan(): nbrOfWorkers() = 1
[10:59:31.675] plan(): Setting new future strategy stack:
[10:59:31.675] List of future strategies:
[10:59:31.675] 1. sequential:
[10:59:31.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.675]    - tweaked: FALSE
[10:59:31.675]    - call: plan(strategy)
[10:59:31.676] plan(): nbrOfWorkers() = 1
[10:59:31.676] SequentialFuture started (and completed)
[10:59:31.676] - Launch lazy future ... done
[10:59:31.676] run() for ‘SequentialFuture’ ... done
[10:59:31.676] Created future:
[10:59:31.676] SequentialFuture:
[10:59:31.676] Label: ‘future_Map-1’
[10:59:31.676] Expression:
[10:59:31.676] {
[10:59:31.676]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.676]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.676]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.676]         on.exit(options(oopts), add = TRUE)
[10:59:31.676]     }
[10:59:31.676]     {
[10:59:31.676]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.676]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.676]         do.call(mapply, args = args)
[10:59:31.676]     }
[10:59:31.676] }
[10:59:31.676] Lazy evaluation: FALSE
[10:59:31.676] Asynchronous evaluation: FALSE
[10:59:31.676] Local evaluation: TRUE
[10:59:31.676] Environment: R_GlobalEnv
[10:59:31.676] Capture standard output: TRUE
[10:59:31.676] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.676] Globals: 5 objects totaling 1.31 KiB (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 927 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.676] Packages: 1 packages (‘stats’)
[10:59:31.676] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.676] Resolved: TRUE
[10:59:31.676] Value: 111 bytes of class ‘list’
[10:59:31.676] Early signaling: FALSE
[10:59:31.676] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.676] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.677] Chunk #1 of 1 ... DONE
[10:59:31.677] Launching 1 futures (chunks) ... DONE
[10:59:31.677] Resolving 1 futures (chunks) ...
[10:59:31.677] resolve() on list ...
[10:59:31.677]  recursive: 0
[10:59:31.677]  length: 1
[10:59:31.677] 
[10:59:31.677] resolved() for ‘SequentialFuture’ ...
[10:59:31.678] - state: ‘finished’
[10:59:31.678] - run: TRUE
[10:59:31.678] - result: ‘FutureResult’
[10:59:31.678] resolved() for ‘SequentialFuture’ ... done
[10:59:31.678] Future #1
[10:59:31.678] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.678] - nx: 1
[10:59:31.678] - relay: TRUE
[10:59:31.678] - stdout: TRUE
[10:59:31.678] - signal: TRUE
[10:59:31.678] - resignal: FALSE
[10:59:31.678] - force: TRUE
[10:59:31.679] - relayed: [n=1] FALSE
[10:59:31.679] - queued futures: [n=1] FALSE
[10:59:31.679]  - until=1
[10:59:31.679]  - relaying element #1
[10:59:31.679] - relayed: [n=1] TRUE
[10:59:31.679] - queued futures: [n=1] TRUE
[10:59:31.679] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.679]  length: 0 (resolved future 1)
[10:59:31.679] Relaying remaining futures
[10:59:31.679] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.679] - nx: 1
[10:59:31.679] - relay: TRUE
[10:59:31.680] - stdout: TRUE
[10:59:31.680] - signal: TRUE
[10:59:31.680] - resignal: FALSE
[10:59:31.680] - force: TRUE
[10:59:31.680] - relayed: [n=1] TRUE
[10:59:31.680] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.681] - relayed: [n=1] TRUE
[10:59:31.681] - queued futures: [n=1] TRUE
[10:59:31.681] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.681] resolve() on list ... DONE
[10:59:31.681]  - Number of value chunks collected: 1
[10:59:31.681] Resolving 1 futures (chunks) ... DONE
[10:59:31.681] Reducing values from 1 chunks ...
[10:59:31.682]  - Number of values collected after concatenation: 5
[10:59:31.682]  - Number of values expected: 5
[10:59:31.682] Reducing values from 1 chunks ... DONE
[10:59:31.682] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:59:31.683] future_mapply() ...
[10:59:31.684] Number of chunks: 1
[10:59:31.684] getGlobalsAndPackagesXApply() ...
[10:59:31.684]  - future.globals: TRUE
[10:59:31.684] getGlobalsAndPackages() ...
[10:59:31.684] Searching for globals...
[10:59:31.684] - globals found: [1] ‘FUN’
[10:59:31.684] Searching for globals ... DONE
[10:59:31.685] Resolving globals: FALSE
[10:59:31.685] The total size of the 1 globals is 32 bytes (32 bytes)
[10:59:31.685] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[10:59:31.685] - globals: [1] ‘FUN’
[10:59:31.685] 
[10:59:31.685] getGlobalsAndPackages() ... DONE
[10:59:31.685]  - globals found/used: [n=1] ‘FUN’
[10:59:31.686]  - needed namespaces: [n=0] 
[10:59:31.686] Finding globals ... DONE
[10:59:31.686] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.686] List of 2
[10:59:31.686]  $ ...future.FUN:function (e1, e2)  
[10:59:31.686]  $ MoreArgs     : NULL
[10:59:31.686]  - attr(*, "where")=List of 2
[10:59:31.686]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.686]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.686]  - attr(*, "resolved")= logi FALSE
[10:59:31.686]  - attr(*, "total_size")= num NA
[10:59:31.688] Packages to be attached in all futures: [n=0] 
[10:59:31.688] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.688] Number of futures (= number of chunks): 1
[10:59:31.688] Launching 1 futures (chunks) ...
[10:59:31.689] Chunk #1 of 1 ...
[10:59:31.689]  - Finding globals in '...' for chunk #1 ...
[10:59:31.689] getGlobalsAndPackages() ...
[10:59:31.689] Searching for globals...
[10:59:31.689] 
[10:59:31.689] Searching for globals ... DONE
[10:59:31.689] - globals: [0] <none>
[10:59:31.689] getGlobalsAndPackages() ... DONE
[10:59:31.689]    + additional globals found: [n=0] 
[10:59:31.690]    + additional namespaces needed: [n=0] 
[10:59:31.690]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.690]  - seeds: <none>
[10:59:31.690]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.690] getGlobalsAndPackages() ...
[10:59:31.690] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.690] Resolving globals: FALSE
[10:59:31.690] The total size of the 5 globals is 244 bytes (244 bytes)
[10:59:31.691] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 244 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (131 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.691] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.691] 
[10:59:31.691] getGlobalsAndPackages() ... DONE
[10:59:31.691] run() for ‘Future’ ...
[10:59:31.691] - state: ‘created’
[10:59:31.691] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.692] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.692]   - Field: ‘label’
[10:59:31.692]   - Field: ‘local’
[10:59:31.692]   - Field: ‘owner’
[10:59:31.692]   - Field: ‘envir’
[10:59:31.692]   - Field: ‘packages’
[10:59:31.692]   - Field: ‘gc’
[10:59:31.692]   - Field: ‘conditions’
[10:59:31.692]   - Field: ‘expr’
[10:59:31.693]   - Field: ‘uuid’
[10:59:31.693]   - Field: ‘seed’
[10:59:31.693]   - Field: ‘version’
[10:59:31.693]   - Field: ‘result’
[10:59:31.693]   - Field: ‘asynchronous’
[10:59:31.693]   - Field: ‘calls’
[10:59:31.693]   - Field: ‘globals’
[10:59:31.693]   - Field: ‘stdout’
[10:59:31.693]   - Field: ‘earlySignal’
[10:59:31.693]   - Field: ‘lazy’
[10:59:31.693]   - Field: ‘state’
[10:59:31.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.694] - Launch lazy future ...
[10:59:31.694] Packages needed by the future expression (n = 0): <none>
[10:59:31.694] Packages needed by future strategies (n = 0): <none>
[10:59:31.694] {
[10:59:31.694]     {
[10:59:31.694]         {
[10:59:31.694]             ...future.startTime <- base::Sys.time()
[10:59:31.694]             {
[10:59:31.694]                 {
[10:59:31.694]                   {
[10:59:31.694]                     base::local({
[10:59:31.694]                       has_future <- base::requireNamespace("future", 
[10:59:31.694]                         quietly = TRUE)
[10:59:31.694]                       if (has_future) {
[10:59:31.694]                         ns <- base::getNamespace("future")
[10:59:31.694]                         version <- ns[[".package"]][["version"]]
[10:59:31.694]                         if (is.null(version)) 
[10:59:31.694]                           version <- utils::packageVersion("future")
[10:59:31.694]                       }
[10:59:31.694]                       else {
[10:59:31.694]                         version <- NULL
[10:59:31.694]                       }
[10:59:31.694]                       if (!has_future || version < "1.8.0") {
[10:59:31.694]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.694]                           "", base::R.version$version.string), 
[10:59:31.694]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.694]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.694]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.694]                             "release", "version")], collapse = " "), 
[10:59:31.694]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.694]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.694]                           info)
[10:59:31.694]                         info <- base::paste(info, collapse = "; ")
[10:59:31.694]                         if (!has_future) {
[10:59:31.694]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.694]                             info)
[10:59:31.694]                         }
[10:59:31.694]                         else {
[10:59:31.694]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.694]                             info, version)
[10:59:31.694]                         }
[10:59:31.694]                         base::stop(msg)
[10:59:31.694]                       }
[10:59:31.694]                     })
[10:59:31.694]                   }
[10:59:31.694]                   ...future.strategy.old <- future::plan("list")
[10:59:31.694]                   options(future.plan = NULL)
[10:59:31.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.694]                 }
[10:59:31.694]                 ...future.workdir <- getwd()
[10:59:31.694]             }
[10:59:31.694]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.694]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.694]         }
[10:59:31.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.694]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.694]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.694]             base::names(...future.oldOptions))
[10:59:31.694]     }
[10:59:31.694]     if (FALSE) {
[10:59:31.694]     }
[10:59:31.694]     else {
[10:59:31.694]         if (TRUE) {
[10:59:31.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.694]                 open = "w")
[10:59:31.694]         }
[10:59:31.694]         else {
[10:59:31.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.694]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.694]         }
[10:59:31.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.694]             base::sink(type = "output", split = FALSE)
[10:59:31.694]             base::close(...future.stdout)
[10:59:31.694]         }, add = TRUE)
[10:59:31.694]     }
[10:59:31.694]     ...future.frame <- base::sys.nframe()
[10:59:31.694]     ...future.conditions <- base::list()
[10:59:31.694]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.694]     if (FALSE) {
[10:59:31.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.694]     }
[10:59:31.694]     ...future.result <- base::tryCatch({
[10:59:31.694]         base::withCallingHandlers({
[10:59:31.694]             ...future.value <- base::withVisible(base::local({
[10:59:31.694]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.694]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.694]                   ...future.globals.maxSize)) {
[10:59:31.694]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.694]                   on.exit(options(oopts), add = TRUE)
[10:59:31.694]                 }
[10:59:31.694]                 {
[10:59:31.694]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.694]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.694]                     USE.NAMES = FALSE)
[10:59:31.694]                   do.call(mapply, args = args)
[10:59:31.694]                 }
[10:59:31.694]             }))
[10:59:31.694]             future::FutureResult(value = ...future.value$value, 
[10:59:31.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.694]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.694]                     ...future.globalenv.names))
[10:59:31.694]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.694]         }, condition = base::local({
[10:59:31.694]             c <- base::c
[10:59:31.694]             inherits <- base::inherits
[10:59:31.694]             invokeRestart <- base::invokeRestart
[10:59:31.694]             length <- base::length
[10:59:31.694]             list <- base::list
[10:59:31.694]             seq.int <- base::seq.int
[10:59:31.694]             signalCondition <- base::signalCondition
[10:59:31.694]             sys.calls <- base::sys.calls
[10:59:31.694]             `[[` <- base::`[[`
[10:59:31.694]             `+` <- base::`+`
[10:59:31.694]             `<<-` <- base::`<<-`
[10:59:31.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.694]                   3L)]
[10:59:31.694]             }
[10:59:31.694]             function(cond) {
[10:59:31.694]                 is_error <- inherits(cond, "error")
[10:59:31.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.694]                   NULL)
[10:59:31.694]                 if (is_error) {
[10:59:31.694]                   sessionInformation <- function() {
[10:59:31.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.694]                       search = base::search(), system = base::Sys.info())
[10:59:31.694]                   }
[10:59:31.694]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.694]                     cond$call), session = sessionInformation(), 
[10:59:31.694]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.694]                   signalCondition(cond)
[10:59:31.694]                 }
[10:59:31.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.694]                 "immediateCondition"))) {
[10:59:31.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.694]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.694]                   if (TRUE && !signal) {
[10:59:31.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.694]                     {
[10:59:31.694]                       inherits <- base::inherits
[10:59:31.694]                       invokeRestart <- base::invokeRestart
[10:59:31.694]                       is.null <- base::is.null
[10:59:31.694]                       muffled <- FALSE
[10:59:31.694]                       if (inherits(cond, "message")) {
[10:59:31.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.694]                         if (muffled) 
[10:59:31.694]                           invokeRestart("muffleMessage")
[10:59:31.694]                       }
[10:59:31.694]                       else if (inherits(cond, "warning")) {
[10:59:31.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.694]                         if (muffled) 
[10:59:31.694]                           invokeRestart("muffleWarning")
[10:59:31.694]                       }
[10:59:31.694]                       else if (inherits(cond, "condition")) {
[10:59:31.694]                         if (!is.null(pattern)) {
[10:59:31.694]                           computeRestarts <- base::computeRestarts
[10:59:31.694]                           grepl <- base::grepl
[10:59:31.694]                           restarts <- computeRestarts(cond)
[10:59:31.694]                           for (restart in restarts) {
[10:59:31.694]                             name <- restart$name
[10:59:31.694]                             if (is.null(name)) 
[10:59:31.694]                               next
[10:59:31.694]                             if (!grepl(pattern, name)) 
[10:59:31.694]                               next
[10:59:31.694]                             invokeRestart(restart)
[10:59:31.694]                             muffled <- TRUE
[10:59:31.694]                             break
[10:59:31.694]                           }
[10:59:31.694]                         }
[10:59:31.694]                       }
[10:59:31.694]                       invisible(muffled)
[10:59:31.694]                     }
[10:59:31.694]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.694]                   }
[10:59:31.694]                 }
[10:59:31.694]                 else {
[10:59:31.694]                   if (TRUE) {
[10:59:31.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.694]                     {
[10:59:31.694]                       inherits <- base::inherits
[10:59:31.694]                       invokeRestart <- base::invokeRestart
[10:59:31.694]                       is.null <- base::is.null
[10:59:31.694]                       muffled <- FALSE
[10:59:31.694]                       if (inherits(cond, "message")) {
[10:59:31.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.694]                         if (muffled) 
[10:59:31.694]                           invokeRestart("muffleMessage")
[10:59:31.694]                       }
[10:59:31.694]                       else if (inherits(cond, "warning")) {
[10:59:31.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.694]                         if (muffled) 
[10:59:31.694]                           invokeRestart("muffleWarning")
[10:59:31.694]                       }
[10:59:31.694]                       else if (inherits(cond, "condition")) {
[10:59:31.694]                         if (!is.null(pattern)) {
[10:59:31.694]                           computeRestarts <- base::computeRestarts
[10:59:31.694]                           grepl <- base::grepl
[10:59:31.694]                           restarts <- computeRestarts(cond)
[10:59:31.694]                           for (restart in restarts) {
[10:59:31.694]                             name <- restart$name
[10:59:31.694]                             if (is.null(name)) 
[10:59:31.694]                               next
[10:59:31.694]                             if (!grepl(pattern, name)) 
[10:59:31.694]                               next
[10:59:31.694]                             invokeRestart(restart)
[10:59:31.694]                             muffled <- TRUE
[10:59:31.694]                             break
[10:59:31.694]                           }
[10:59:31.694]                         }
[10:59:31.694]                       }
[10:59:31.694]                       invisible(muffled)
[10:59:31.694]                     }
[10:59:31.694]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.694]                   }
[10:59:31.694]                 }
[10:59:31.694]             }
[10:59:31.694]         }))
[10:59:31.694]     }, error = function(ex) {
[10:59:31.694]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.694]                 ...future.rng), started = ...future.startTime, 
[10:59:31.694]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.694]             version = "1.8"), class = "FutureResult")
[10:59:31.694]     }, finally = {
[10:59:31.694]         if (!identical(...future.workdir, getwd())) 
[10:59:31.694]             setwd(...future.workdir)
[10:59:31.694]         {
[10:59:31.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.694]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.694]             }
[10:59:31.694]             base::options(...future.oldOptions)
[10:59:31.694]             if (.Platform$OS.type == "windows") {
[10:59:31.694]                 old_names <- names(...future.oldEnvVars)
[10:59:31.694]                 envs <- base::Sys.getenv()
[10:59:31.694]                 names <- names(envs)
[10:59:31.694]                 common <- intersect(names, old_names)
[10:59:31.694]                 added <- setdiff(names, old_names)
[10:59:31.694]                 removed <- setdiff(old_names, names)
[10:59:31.694]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.694]                   envs[common]]
[10:59:31.694]                 NAMES <- toupper(changed)
[10:59:31.694]                 args <- list()
[10:59:31.694]                 for (kk in seq_along(NAMES)) {
[10:59:31.694]                   name <- changed[[kk]]
[10:59:31.694]                   NAME <- NAMES[[kk]]
[10:59:31.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.694]                     next
[10:59:31.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.694]                 }
[10:59:31.694]                 NAMES <- toupper(added)
[10:59:31.694]                 for (kk in seq_along(NAMES)) {
[10:59:31.694]                   name <- added[[kk]]
[10:59:31.694]                   NAME <- NAMES[[kk]]
[10:59:31.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.694]                     next
[10:59:31.694]                   args[[name]] <- ""
[10:59:31.694]                 }
[10:59:31.694]                 NAMES <- toupper(removed)
[10:59:31.694]                 for (kk in seq_along(NAMES)) {
[10:59:31.694]                   name <- removed[[kk]]
[10:59:31.694]                   NAME <- NAMES[[kk]]
[10:59:31.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.694]                     next
[10:59:31.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.694]                 }
[10:59:31.694]                 if (length(args) > 0) 
[10:59:31.694]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.694]             }
[10:59:31.694]             else {
[10:59:31.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.694]             }
[10:59:31.694]             {
[10:59:31.694]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.694]                   0L) {
[10:59:31.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.694]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.694]                   base::options(opts)
[10:59:31.694]                 }
[10:59:31.694]                 {
[10:59:31.694]                   {
[10:59:31.694]                     base::assign(".Random.seed", c(10407L, -54483287L, 
[10:59:31.694]                     805746024L, -1268229531L, -880604942L, -655286988L, 
[10:59:31.694]                     724716582L), envir = base::globalenv(), inherits = FALSE)
[10:59:31.694]                     NULL
[10:59:31.694]                   }
[10:59:31.694]                   options(future.plan = NULL)
[10:59:31.694]                   if (is.na(NA_character_)) 
[10:59:31.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.694]                     .init = FALSE)
[10:59:31.694]                 }
[10:59:31.694]             }
[10:59:31.694]         }
[10:59:31.694]     })
[10:59:31.694]     if (TRUE) {
[10:59:31.694]         base::sink(type = "output", split = FALSE)
[10:59:31.694]         if (TRUE) {
[10:59:31.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.694]         }
[10:59:31.694]         else {
[10:59:31.694]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.694]         }
[10:59:31.694]         base::close(...future.stdout)
[10:59:31.694]         ...future.stdout <- NULL
[10:59:31.694]     }
[10:59:31.694]     ...future.result$conditions <- ...future.conditions
[10:59:31.694]     ...future.result$finished <- base::Sys.time()
[10:59:31.694]     ...future.result
[10:59:31.694] }
[10:59:31.696] assign_globals() ...
[10:59:31.696] List of 5
[10:59:31.696]  $ ...future.FUN            :function (e1, e2)  
[10:59:31.696]  $ MoreArgs                 : NULL
[10:59:31.696]  $ ...future.elements_ii    :List of 2
[10:59:31.696]   ..$ :List of 3
[10:59:31.696]   .. ..$ : num 1
[10:59:31.696]   .. ..$ : num 1
[10:59:31.696]   .. ..$ : num 1
[10:59:31.696]   ..$ :List of 3
[10:59:31.696]   .. ..$ : int 1
[10:59:31.696]   .. ..$ : int 2
[10:59:31.696]   .. ..$ : int 3
[10:59:31.696]  $ ...future.seeds_ii       : NULL
[10:59:31.696]  $ ...future.globals.maxSize: NULL
[10:59:31.696]  - attr(*, "where")=List of 5
[10:59:31.696]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.696]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.696]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.696]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.696]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.696]  - attr(*, "resolved")= logi FALSE
[10:59:31.696]  - attr(*, "total_size")= num 244
[10:59:31.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.696]  - attr(*, "already-done")= logi TRUE
[10:59:31.703] - copied ‘...future.FUN’ to environment
[10:59:31.703] - copied ‘MoreArgs’ to environment
[10:59:31.703] - copied ‘...future.elements_ii’ to environment
[10:59:31.703] - copied ‘...future.seeds_ii’ to environment
[10:59:31.703] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.703] assign_globals() ... done
[10:59:31.703] plan(): Setting new future strategy stack:
[10:59:31.703] List of future strategies:
[10:59:31.703] 1. sequential:
[10:59:31.703]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.703]    - tweaked: FALSE
[10:59:31.703]    - call: NULL
[10:59:31.704] plan(): nbrOfWorkers() = 1
[10:59:31.704] plan(): Setting new future strategy stack:
[10:59:31.705] List of future strategies:
[10:59:31.705] 1. sequential:
[10:59:31.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.705]    - tweaked: FALSE
[10:59:31.705]    - call: plan(strategy)
[10:59:31.705] plan(): nbrOfWorkers() = 1
[10:59:31.705] SequentialFuture started (and completed)
[10:59:31.705] - Launch lazy future ... done
[10:59:31.705] run() for ‘SequentialFuture’ ... done
[10:59:31.706] Created future:
[10:59:31.706] SequentialFuture:
[10:59:31.706] Label: ‘future_Map-1’
[10:59:31.706] Expression:
[10:59:31.706] {
[10:59:31.706]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.706]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.706]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.706]         on.exit(options(oopts), add = TRUE)
[10:59:31.706]     }
[10:59:31.706]     {
[10:59:31.706]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.706]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.706]         do.call(mapply, args = args)
[10:59:31.706]     }
[10:59:31.706] }
[10:59:31.706] Lazy evaluation: FALSE
[10:59:31.706] Asynchronous evaluation: FALSE
[10:59:31.706] Local evaluation: TRUE
[10:59:31.706] Environment: R_GlobalEnv
[10:59:31.706] Capture standard output: TRUE
[10:59:31.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.706] Globals: 5 objects totaling 244 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 131 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.706] Packages: <none>
[10:59:31.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.706] Resolved: TRUE
[10:59:31.706] Value: 79 bytes of class ‘list’
[10:59:31.706] Early signaling: FALSE
[10:59:31.706] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.706] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.706] Chunk #1 of 1 ... DONE
[10:59:31.706] Launching 1 futures (chunks) ... DONE
[10:59:31.707] Resolving 1 futures (chunks) ...
[10:59:31.707] resolve() on list ...
[10:59:31.707]  recursive: 0
[10:59:31.707]  length: 1
[10:59:31.707] 
[10:59:31.707] resolved() for ‘SequentialFuture’ ...
[10:59:31.707] - state: ‘finished’
[10:59:31.707] - run: TRUE
[10:59:31.707] - result: ‘FutureResult’
[10:59:31.707] resolved() for ‘SequentialFuture’ ... done
[10:59:31.707] Future #1
[10:59:31.707] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.708] - nx: 1
[10:59:31.708] - relay: TRUE
[10:59:31.708] - stdout: TRUE
[10:59:31.708] - signal: TRUE
[10:59:31.708] - resignal: FALSE
[10:59:31.708] - force: TRUE
[10:59:31.708] - relayed: [n=1] FALSE
[10:59:31.708] - queued futures: [n=1] FALSE
[10:59:31.708]  - until=1
[10:59:31.708]  - relaying element #1
[10:59:31.708] - relayed: [n=1] TRUE
[10:59:31.708] - queued futures: [n=1] TRUE
[10:59:31.709] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.709]  length: 0 (resolved future 1)
[10:59:31.709] Relaying remaining futures
[10:59:31.709] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.709] - nx: 1
[10:59:31.709] - relay: TRUE
[10:59:31.709] - stdout: TRUE
[10:59:31.709] - signal: TRUE
[10:59:31.709] - resignal: FALSE
[10:59:31.709] - force: TRUE
[10:59:31.709] - relayed: [n=1] TRUE
[10:59:31.709] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.710] - relayed: [n=1] TRUE
[10:59:31.710] - queued futures: [n=1] TRUE
[10:59:31.710] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.710] resolve() on list ... DONE
[10:59:31.710]  - Number of value chunks collected: 1
[10:59:31.710] Resolving 1 futures (chunks) ... DONE
[10:59:31.710] Reducing values from 1 chunks ...
[10:59:31.710]  - Number of values collected after concatenation: 3
[10:59:31.710]  - Number of values expected: 3
[10:59:31.710] Reducing values from 1 chunks ... DONE
[10:59:31.710] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:59:31.711] future_mapply() ...
[10:59:31.711] Number of chunks: 1
[10:59:31.711] getGlobalsAndPackagesXApply() ...
[10:59:31.711]  - future.globals: TRUE
[10:59:31.711] getGlobalsAndPackages() ...
[10:59:31.711] Searching for globals...
[10:59:31.712] - globals found: [1] ‘FUN’
[10:59:31.712] Searching for globals ... DONE
[10:59:31.712] Resolving globals: FALSE
[10:59:31.712] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:31.713] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:31.713] - globals: [1] ‘FUN’
[10:59:31.713] 
[10:59:31.713] getGlobalsAndPackages() ... DONE
[10:59:31.713]  - globals found/used: [n=1] ‘FUN’
[10:59:31.713]  - needed namespaces: [n=0] 
[10:59:31.713] Finding globals ... DONE
[10:59:31.713] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.713] List of 2
[10:59:31.713]  $ ...future.FUN:function (x)  
[10:59:31.713]  $ MoreArgs     : NULL
[10:59:31.713]  - attr(*, "where")=List of 2
[10:59:31.713]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.713]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.713]  - attr(*, "resolved")= logi FALSE
[10:59:31.713]  - attr(*, "total_size")= num NA
[10:59:31.716] Packages to be attached in all futures: [n=0] 
[10:59:31.716] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.716] Number of futures (= number of chunks): 1
[10:59:31.716] Launching 1 futures (chunks) ...
[10:59:31.716] Chunk #1 of 1 ...
[10:59:31.716]  - Finding globals in '...' for chunk #1 ...
[10:59:31.716] getGlobalsAndPackages() ...
[10:59:31.716] Searching for globals...
[10:59:31.717] 
[10:59:31.717] Searching for globals ... DONE
[10:59:31.717] - globals: [0] <none>
[10:59:31.717] getGlobalsAndPackages() ... DONE
[10:59:31.717]    + additional globals found: [n=0] 
[10:59:31.717]    + additional namespaces needed: [n=0] 
[10:59:31.717]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.717]  - seeds: <none>
[10:59:31.717]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.717] getGlobalsAndPackages() ...
[10:59:31.717] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.718] Resolving globals: FALSE
[10:59:31.718] The total size of the 5 globals is 388 bytes (388 bytes)
[10:59:31.718] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 388 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (122 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.718] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.719] 
[10:59:31.719] getGlobalsAndPackages() ... DONE
[10:59:31.719] run() for ‘Future’ ...
[10:59:31.719] - state: ‘created’
[10:59:31.719] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:59:31.719] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:59:31.719]   - Field: ‘label’
[10:59:31.720]   - Field: ‘local’
[10:59:31.720]   - Field: ‘owner’
[10:59:31.720]   - Field: ‘envir’
[10:59:31.720]   - Field: ‘packages’
[10:59:31.720]   - Field: ‘gc’
[10:59:31.720]   - Field: ‘conditions’
[10:59:31.720]   - Field: ‘expr’
[10:59:31.720]   - Field: ‘uuid’
[10:59:31.720]   - Field: ‘seed’
[10:59:31.720]   - Field: ‘version’
[10:59:31.720]   - Field: ‘result’
[10:59:31.720]   - Field: ‘asynchronous’
[10:59:31.720]   - Field: ‘calls’
[10:59:31.721]   - Field: ‘globals’
[10:59:31.721]   - Field: ‘stdout’
[10:59:31.721]   - Field: ‘earlySignal’
[10:59:31.721]   - Field: ‘lazy’
[10:59:31.721]   - Field: ‘state’
[10:59:31.721] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:59:31.721] - Launch lazy future ...
[10:59:31.721] Packages needed by the future expression (n = 0): <none>
[10:59:31.721] Packages needed by future strategies (n = 0): <none>
[10:59:31.722] {
[10:59:31.722]     {
[10:59:31.722]         {
[10:59:31.722]             ...future.startTime <- base::Sys.time()
[10:59:31.722]             {
[10:59:31.722]                 {
[10:59:31.722]                   {
[10:59:31.722]                     base::local({
[10:59:31.722]                       has_future <- base::requireNamespace("future", 
[10:59:31.722]                         quietly = TRUE)
[10:59:31.722]                       if (has_future) {
[10:59:31.722]                         ns <- base::getNamespace("future")
[10:59:31.722]                         version <- ns[[".package"]][["version"]]
[10:59:31.722]                         if (is.null(version)) 
[10:59:31.722]                           version <- utils::packageVersion("future")
[10:59:31.722]                       }
[10:59:31.722]                       else {
[10:59:31.722]                         version <- NULL
[10:59:31.722]                       }
[10:59:31.722]                       if (!has_future || version < "1.8.0") {
[10:59:31.722]                         info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.722]                           "", base::R.version$version.string), 
[10:59:31.722]                           platform = base::sprintf("%s (%s-bit)", 
[10:59:31.722]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.722]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.722]                             "release", "version")], collapse = " "), 
[10:59:31.722]                           hostname = base::Sys.info()[["nodename"]])
[10:59:31.722]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.722]                           info)
[10:59:31.722]                         info <- base::paste(info, collapse = "; ")
[10:59:31.722]                         if (!has_future) {
[10:59:31.722]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.722]                             info)
[10:59:31.722]                         }
[10:59:31.722]                         else {
[10:59:31.722]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.722]                             info, version)
[10:59:31.722]                         }
[10:59:31.722]                         base::stop(msg)
[10:59:31.722]                       }
[10:59:31.722]                     })
[10:59:31.722]                   }
[10:59:31.722]                   ...future.strategy.old <- future::plan("list")
[10:59:31.722]                   options(future.plan = NULL)
[10:59:31.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.722]                 }
[10:59:31.722]                 ...future.workdir <- getwd()
[10:59:31.722]             }
[10:59:31.722]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.722]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.722]         }
[10:59:31.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.722]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:31.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.722]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.722]             base::names(...future.oldOptions))
[10:59:31.722]     }
[10:59:31.722]     if (FALSE) {
[10:59:31.722]     }
[10:59:31.722]     else {
[10:59:31.722]         if (TRUE) {
[10:59:31.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.722]                 open = "w")
[10:59:31.722]         }
[10:59:31.722]         else {
[10:59:31.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.722]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.722]         }
[10:59:31.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.722]             base::sink(type = "output", split = FALSE)
[10:59:31.722]             base::close(...future.stdout)
[10:59:31.722]         }, add = TRUE)
[10:59:31.722]     }
[10:59:31.722]     ...future.frame <- base::sys.nframe()
[10:59:31.722]     ...future.conditions <- base::list()
[10:59:31.722]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.722]     if (FALSE) {
[10:59:31.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.722]     }
[10:59:31.722]     ...future.result <- base::tryCatch({
[10:59:31.722]         base::withCallingHandlers({
[10:59:31.722]             ...future.value <- base::withVisible(base::local({
[10:59:31.722]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.722]                 if (!identical(...future.globals.maxSize.org, 
[10:59:31.722]                   ...future.globals.maxSize)) {
[10:59:31.722]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.722]                   on.exit(options(oopts), add = TRUE)
[10:59:31.722]                 }
[10:59:31.722]                 {
[10:59:31.722]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.722]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.722]                     USE.NAMES = FALSE)
[10:59:31.722]                   do.call(mapply, args = args)
[10:59:31.722]                 }
[10:59:31.722]             }))
[10:59:31.722]             future::FutureResult(value = ...future.value$value, 
[10:59:31.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.722]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.722]                     ...future.globalenv.names))
[10:59:31.722]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.722]         }, condition = base::local({
[10:59:31.722]             c <- base::c
[10:59:31.722]             inherits <- base::inherits
[10:59:31.722]             invokeRestart <- base::invokeRestart
[10:59:31.722]             length <- base::length
[10:59:31.722]             list <- base::list
[10:59:31.722]             seq.int <- base::seq.int
[10:59:31.722]             signalCondition <- base::signalCondition
[10:59:31.722]             sys.calls <- base::sys.calls
[10:59:31.722]             `[[` <- base::`[[`
[10:59:31.722]             `+` <- base::`+`
[10:59:31.722]             `<<-` <- base::`<<-`
[10:59:31.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.722]                   3L)]
[10:59:31.722]             }
[10:59:31.722]             function(cond) {
[10:59:31.722]                 is_error <- inherits(cond, "error")
[10:59:31.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.722]                   NULL)
[10:59:31.722]                 if (is_error) {
[10:59:31.722]                   sessionInformation <- function() {
[10:59:31.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.722]                       search = base::search(), system = base::Sys.info())
[10:59:31.722]                   }
[10:59:31.722]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.722]                     cond$call), session = sessionInformation(), 
[10:59:31.722]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.722]                   signalCondition(cond)
[10:59:31.722]                 }
[10:59:31.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.722]                 "immediateCondition"))) {
[10:59:31.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.722]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.722]                   if (TRUE && !signal) {
[10:59:31.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.722]                     {
[10:59:31.722]                       inherits <- base::inherits
[10:59:31.722]                       invokeRestart <- base::invokeRestart
[10:59:31.722]                       is.null <- base::is.null
[10:59:31.722]                       muffled <- FALSE
[10:59:31.722]                       if (inherits(cond, "message")) {
[10:59:31.722]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.722]                         if (muffled) 
[10:59:31.722]                           invokeRestart("muffleMessage")
[10:59:31.722]                       }
[10:59:31.722]                       else if (inherits(cond, "warning")) {
[10:59:31.722]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.722]                         if (muffled) 
[10:59:31.722]                           invokeRestart("muffleWarning")
[10:59:31.722]                       }
[10:59:31.722]                       else if (inherits(cond, "condition")) {
[10:59:31.722]                         if (!is.null(pattern)) {
[10:59:31.722]                           computeRestarts <- base::computeRestarts
[10:59:31.722]                           grepl <- base::grepl
[10:59:31.722]                           restarts <- computeRestarts(cond)
[10:59:31.722]                           for (restart in restarts) {
[10:59:31.722]                             name <- restart$name
[10:59:31.722]                             if (is.null(name)) 
[10:59:31.722]                               next
[10:59:31.722]                             if (!grepl(pattern, name)) 
[10:59:31.722]                               next
[10:59:31.722]                             invokeRestart(restart)
[10:59:31.722]                             muffled <- TRUE
[10:59:31.722]                             break
[10:59:31.722]                           }
[10:59:31.722]                         }
[10:59:31.722]                       }
[10:59:31.722]                       invisible(muffled)
[10:59:31.722]                     }
[10:59:31.722]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.722]                   }
[10:59:31.722]                 }
[10:59:31.722]                 else {
[10:59:31.722]                   if (TRUE) {
[10:59:31.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.722]                     {
[10:59:31.722]                       inherits <- base::inherits
[10:59:31.722]                       invokeRestart <- base::invokeRestart
[10:59:31.722]                       is.null <- base::is.null
[10:59:31.722]                       muffled <- FALSE
[10:59:31.722]                       if (inherits(cond, "message")) {
[10:59:31.722]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.722]                         if (muffled) 
[10:59:31.722]                           invokeRestart("muffleMessage")
[10:59:31.722]                       }
[10:59:31.722]                       else if (inherits(cond, "warning")) {
[10:59:31.722]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.722]                         if (muffled) 
[10:59:31.722]                           invokeRestart("muffleWarning")
[10:59:31.722]                       }
[10:59:31.722]                       else if (inherits(cond, "condition")) {
[10:59:31.722]                         if (!is.null(pattern)) {
[10:59:31.722]                           computeRestarts <- base::computeRestarts
[10:59:31.722]                           grepl <- base::grepl
[10:59:31.722]                           restarts <- computeRestarts(cond)
[10:59:31.722]                           for (restart in restarts) {
[10:59:31.722]                             name <- restart$name
[10:59:31.722]                             if (is.null(name)) 
[10:59:31.722]                               next
[10:59:31.722]                             if (!grepl(pattern, name)) 
[10:59:31.722]                               next
[10:59:31.722]                             invokeRestart(restart)
[10:59:31.722]                             muffled <- TRUE
[10:59:31.722]                             break
[10:59:31.722]                           }
[10:59:31.722]                         }
[10:59:31.722]                       }
[10:59:31.722]                       invisible(muffled)
[10:59:31.722]                     }
[10:59:31.722]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.722]                   }
[10:59:31.722]                 }
[10:59:31.722]             }
[10:59:31.722]         }))
[10:59:31.722]     }, error = function(ex) {
[10:59:31.722]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.722]                 ...future.rng), started = ...future.startTime, 
[10:59:31.722]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.722]             version = "1.8"), class = "FutureResult")
[10:59:31.722]     }, finally = {
[10:59:31.722]         if (!identical(...future.workdir, getwd())) 
[10:59:31.722]             setwd(...future.workdir)
[10:59:31.722]         {
[10:59:31.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.722]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.722]             }
[10:59:31.722]             base::options(...future.oldOptions)
[10:59:31.722]             if (.Platform$OS.type == "windows") {
[10:59:31.722]                 old_names <- names(...future.oldEnvVars)
[10:59:31.722]                 envs <- base::Sys.getenv()
[10:59:31.722]                 names <- names(envs)
[10:59:31.722]                 common <- intersect(names, old_names)
[10:59:31.722]                 added <- setdiff(names, old_names)
[10:59:31.722]                 removed <- setdiff(old_names, names)
[10:59:31.722]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.722]                   envs[common]]
[10:59:31.722]                 NAMES <- toupper(changed)
[10:59:31.722]                 args <- list()
[10:59:31.722]                 for (kk in seq_along(NAMES)) {
[10:59:31.722]                   name <- changed[[kk]]
[10:59:31.722]                   NAME <- NAMES[[kk]]
[10:59:31.722]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.722]                     next
[10:59:31.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.722]                 }
[10:59:31.722]                 NAMES <- toupper(added)
[10:59:31.722]                 for (kk in seq_along(NAMES)) {
[10:59:31.722]                   name <- added[[kk]]
[10:59:31.722]                   NAME <- NAMES[[kk]]
[10:59:31.722]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.722]                     next
[10:59:31.722]                   args[[name]] <- ""
[10:59:31.722]                 }
[10:59:31.722]                 NAMES <- toupper(removed)
[10:59:31.722]                 for (kk in seq_along(NAMES)) {
[10:59:31.722]                   name <- removed[[kk]]
[10:59:31.722]                   NAME <- NAMES[[kk]]
[10:59:31.722]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.722]                     next
[10:59:31.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.722]                 }
[10:59:31.722]                 if (length(args) > 0) 
[10:59:31.722]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.722]             }
[10:59:31.722]             else {
[10:59:31.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.722]             }
[10:59:31.722]             {
[10:59:31.722]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.722]                   0L) {
[10:59:31.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.722]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.722]                   base::options(opts)
[10:59:31.722]                 }
[10:59:31.722]                 {
[10:59:31.722]                   {
[10:59:31.722]                     base::assign(".Random.seed", c(10407L, -54483287L, 
[10:59:31.722]                     805746024L, -1268229531L, -880604942L, -655286988L, 
[10:59:31.722]                     724716582L), envir = base::globalenv(), inherits = FALSE)
[10:59:31.722]                     NULL
[10:59:31.722]                   }
[10:59:31.722]                   options(future.plan = NULL)
[10:59:31.722]                   if (is.na(NA_character_)) 
[10:59:31.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.722]                     .init = FALSE)
[10:59:31.722]                 }
[10:59:31.722]             }
[10:59:31.722]         }
[10:59:31.722]     })
[10:59:31.722]     if (TRUE) {
[10:59:31.722]         base::sink(type = "output", split = FALSE)
[10:59:31.722]         if (TRUE) {
[10:59:31.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.722]         }
[10:59:31.722]         else {
[10:59:31.722]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.722]         }
[10:59:31.722]         base::close(...future.stdout)
[10:59:31.722]         ...future.stdout <- NULL
[10:59:31.722]     }
[10:59:31.722]     ...future.result$conditions <- ...future.conditions
[10:59:31.722]     ...future.result$finished <- base::Sys.time()
[10:59:31.722]     ...future.result
[10:59:31.722] }
[10:59:31.723] assign_globals() ...
[10:59:31.723] List of 5
[10:59:31.723]  $ ...future.FUN            :function (x)  
[10:59:31.723]  $ MoreArgs                 : NULL
[10:59:31.723]  $ ...future.elements_ii    :List of 1
[10:59:31.723]   ..$ :List of 2
[10:59:31.723]   .. ..$ a: num 0
[10:59:31.723]   .. ..$ b: num 0
[10:59:31.723]  $ ...future.seeds_ii       : NULL
[10:59:31.723]  $ ...future.globals.maxSize: NULL
[10:59:31.723]  - attr(*, "where")=List of 5
[10:59:31.723]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.723]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.723]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.723]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.723]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.723]  - attr(*, "resolved")= logi FALSE
[10:59:31.723]  - attr(*, "total_size")= num 388
[10:59:31.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.723]  - attr(*, "already-done")= logi TRUE
[10:59:31.729] - copied ‘...future.FUN’ to environment
[10:59:31.729] - copied ‘MoreArgs’ to environment
[10:59:31.729] - copied ‘...future.elements_ii’ to environment
[10:59:31.729] - copied ‘...future.seeds_ii’ to environment
[10:59:31.729] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.730] assign_globals() ... done
[10:59:31.730] plan(): Setting new future strategy stack:
[10:59:31.730] List of future strategies:
[10:59:31.730] 1. sequential:
[10:59:31.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.730]    - tweaked: FALSE
[10:59:31.730]    - call: NULL
[10:59:31.730] plan(): nbrOfWorkers() = 1
[10:59:31.731] plan(): Setting new future strategy stack:
[10:59:31.731] List of future strategies:
[10:59:31.731] 1. sequential:
[10:59:31.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.731]    - tweaked: FALSE
[10:59:31.731]    - call: plan(strategy)
[10:59:31.731] plan(): nbrOfWorkers() = 1
[10:59:31.732] SequentialFuture started (and completed)
[10:59:31.732] - Launch lazy future ... done
[10:59:31.732] run() for ‘SequentialFuture’ ... done
[10:59:31.732] Created future:
[10:59:31.732] SequentialFuture:
[10:59:31.732] Label: ‘future_mapply-1’
[10:59:31.732] Expression:
[10:59:31.732] {
[10:59:31.732]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.732]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.732]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.732]         on.exit(options(oopts), add = TRUE)
[10:59:31.732]     }
[10:59:31.732]     {
[10:59:31.732]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.732]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.732]         do.call(mapply, args = args)
[10:59:31.732]     }
[10:59:31.732] }
[10:59:31.732] Lazy evaluation: FALSE
[10:59:31.732] Asynchronous evaluation: FALSE
[10:59:31.732] Local evaluation: TRUE
[10:59:31.732] Environment: R_GlobalEnv
[10:59:31.732] Capture standard output: TRUE
[10:59:31.732] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.732] Globals: 5 objects totaling 388 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 122 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.732] Packages: <none>
[10:59:31.732] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.732] Resolved: TRUE
[10:59:31.732] Value: 63 bytes of class ‘list’
[10:59:31.732] Early signaling: FALSE
[10:59:31.732] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.732] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:59:31.733] Chunk #1 of 1 ... DONE
[10:59:31.733] Launching 1 futures (chunks) ... DONE
[10:59:31.733] Resolving 1 futures (chunks) ...
[10:59:31.733] resolve() on list ...
[10:59:31.733]  recursive: 0
[10:59:31.733]  length: 1
[10:59:31.733] 
[10:59:31.733] resolved() for ‘SequentialFuture’ ...
[10:59:31.733] - state: ‘finished’
[10:59:31.733] - run: TRUE
[10:59:31.733] - result: ‘FutureResult’
[10:59:31.734] resolved() for ‘SequentialFuture’ ... done
[10:59:31.734] Future #1
[10:59:31.734] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:59:31.734] - nx: 1
[10:59:31.734] - relay: TRUE
[10:59:31.734] - stdout: TRUE
[10:59:31.734] - signal: TRUE
[10:59:31.734] - resignal: FALSE
[10:59:31.734] - force: TRUE
[10:59:31.734] - relayed: [n=1] FALSE
[10:59:31.734] - queued futures: [n=1] FALSE
[10:59:31.734]  - until=1
[10:59:31.735]  - relaying element #1
[10:59:31.735] - relayed: [n=1] TRUE
[10:59:31.735] - queued futures: [n=1] TRUE
[10:59:31.735] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:59:31.735]  length: 0 (resolved future 1)
[10:59:31.735] Relaying remaining futures
[10:59:31.735] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.735] - nx: 1
[10:59:31.735] - relay: TRUE
[10:59:31.735] - stdout: TRUE
[10:59:31.735] - signal: TRUE
[10:59:31.736] - resignal: FALSE
[10:59:31.736] - force: TRUE
[10:59:31.736] - relayed: [n=1] TRUE
[10:59:31.736] - queued futures: [n=1] TRUE
 - flush all
[10:59:31.736] - relayed: [n=1] TRUE
[10:59:31.736] - queued futures: [n=1] TRUE
[10:59:31.736] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.736] resolve() on list ... DONE
[10:59:31.736]  - Number of value chunks collected: 1
[10:59:31.736] Resolving 1 futures (chunks) ... DONE
[10:59:31.736] Reducing values from 1 chunks ...
[10:59:31.736]  - Number of values collected after concatenation: 2
[10:59:31.737]  - Number of values expected: 2
[10:59:31.737] Reducing values from 1 chunks ... DONE
[10:59:31.737] future_mapply() ... DONE
[10:59:31.737] plan(): Setting new future strategy stack:
[10:59:31.737] List of future strategies:
[10:59:31.737] 1. sequential:
[10:59:31.737]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.737]    - tweaked: FALSE
[10:59:31.737]    - call: plan(sequential)
[10:59:31.737] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:59:31.738] plan(): Setting new future strategy stack:
[10:59:31.738] List of future strategies:
[10:59:31.738] 1. multicore:
[10:59:31.738]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:31.738]    - tweaked: FALSE
[10:59:31.738]    - call: plan(strategy)
[10:59:31.739] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[10:59:31.740] future_mapply() ...
[10:59:31.741] Number of chunks: 2
[10:59:31.741] getGlobalsAndPackagesXApply() ...
[10:59:31.741]  - future.globals: TRUE
[10:59:31.741] getGlobalsAndPackages() ...
[10:59:31.741] Searching for globals...
[10:59:31.742] - globals found: [1] ‘FUN’
[10:59:31.742] Searching for globals ... DONE
[10:59:31.742] Resolving globals: FALSE
[10:59:31.742] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:31.743] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:31.743] - globals: [1] ‘FUN’
[10:59:31.743] 
[10:59:31.743] getGlobalsAndPackages() ... DONE
[10:59:31.743]  - globals found/used: [n=1] ‘FUN’
[10:59:31.743]  - needed namespaces: [n=0] 
[10:59:31.743] Finding globals ... DONE
[10:59:31.743] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.743] List of 2
[10:59:31.743]  $ ...future.FUN:function (x, ...)  
[10:59:31.743]  $ MoreArgs     : NULL
[10:59:31.743]  - attr(*, "where")=List of 2
[10:59:31.743]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.743]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.743]  - attr(*, "resolved")= logi FALSE
[10:59:31.743]  - attr(*, "total_size")= num NA
[10:59:31.747] Packages to be attached in all futures: [n=0] 
[10:59:31.747] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.747] Number of futures (= number of chunks): 2
[10:59:31.747] Launching 2 futures (chunks) ...
[10:59:31.747] Chunk #1 of 2 ...
[10:59:31.747]  - Finding globals in '...' for chunk #1 ...
[10:59:31.747] getGlobalsAndPackages() ...
[10:59:31.747] Searching for globals...
[10:59:31.748] 
[10:59:31.748] Searching for globals ... DONE
[10:59:31.748] - globals: [0] <none>
[10:59:31.748] getGlobalsAndPackages() ... DONE
[10:59:31.748]    + additional globals found: [n=0] 
[10:59:31.748]    + additional namespaces needed: [n=0] 
[10:59:31.748]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.748]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.748]  - seeds: <none>
[10:59:31.748]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.749] getGlobalsAndPackages() ...
[10:59:31.749] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.749] Resolving globals: FALSE
[10:59:31.749] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:31.750] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.750] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.750] 
[10:59:31.750] getGlobalsAndPackages() ... DONE
[10:59:31.750] run() for ‘Future’ ...
[10:59:31.750] - state: ‘created’
[10:59:31.750] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:31.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:31.752]   - Field: ‘label’
[10:59:31.752]   - Field: ‘local’
[10:59:31.752]   - Field: ‘owner’
[10:59:31.752]   - Field: ‘envir’
[10:59:31.752]   - Field: ‘workers’
[10:59:31.752]   - Field: ‘packages’
[10:59:31.753]   - Field: ‘gc’
[10:59:31.753]   - Field: ‘job’
[10:59:31.753]   - Field: ‘conditions’
[10:59:31.753]   - Field: ‘expr’
[10:59:31.753]   - Field: ‘uuid’
[10:59:31.753]   - Field: ‘seed’
[10:59:31.753]   - Field: ‘version’
[10:59:31.753]   - Field: ‘result’
[10:59:31.753]   - Field: ‘asynchronous’
[10:59:31.753]   - Field: ‘calls’
[10:59:31.753]   - Field: ‘globals’
[10:59:31.753]   - Field: ‘stdout’
[10:59:31.753]   - Field: ‘earlySignal’
[10:59:31.754]   - Field: ‘lazy’
[10:59:31.754]   - Field: ‘state’
[10:59:31.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:31.754] - Launch lazy future ...
[10:59:31.755] Packages needed by the future expression (n = 0): <none>
[10:59:31.755] Packages needed by future strategies (n = 0): <none>
[10:59:31.755] {
[10:59:31.755]     {
[10:59:31.755]         {
[10:59:31.755]             ...future.startTime <- base::Sys.time()
[10:59:31.755]             {
[10:59:31.755]                 {
[10:59:31.755]                   {
[10:59:31.755]                     {
[10:59:31.755]                       base::local({
[10:59:31.755]                         has_future <- base::requireNamespace("future", 
[10:59:31.755]                           quietly = TRUE)
[10:59:31.755]                         if (has_future) {
[10:59:31.755]                           ns <- base::getNamespace("future")
[10:59:31.755]                           version <- ns[[".package"]][["version"]]
[10:59:31.755]                           if (is.null(version)) 
[10:59:31.755]                             version <- utils::packageVersion("future")
[10:59:31.755]                         }
[10:59:31.755]                         else {
[10:59:31.755]                           version <- NULL
[10:59:31.755]                         }
[10:59:31.755]                         if (!has_future || version < "1.8.0") {
[10:59:31.755]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.755]                             "", base::R.version$version.string), 
[10:59:31.755]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.755]                               "release", "version")], collapse = " "), 
[10:59:31.755]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.755]                             info)
[10:59:31.755]                           info <- base::paste(info, collapse = "; ")
[10:59:31.755]                           if (!has_future) {
[10:59:31.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.755]                               info)
[10:59:31.755]                           }
[10:59:31.755]                           else {
[10:59:31.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.755]                               info, version)
[10:59:31.755]                           }
[10:59:31.755]                           base::stop(msg)
[10:59:31.755]                         }
[10:59:31.755]                       })
[10:59:31.755]                     }
[10:59:31.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:31.755]                     base::options(mc.cores = 1L)
[10:59:31.755]                   }
[10:59:31.755]                   ...future.strategy.old <- future::plan("list")
[10:59:31.755]                   options(future.plan = NULL)
[10:59:31.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.755]                 }
[10:59:31.755]                 ...future.workdir <- getwd()
[10:59:31.755]             }
[10:59:31.755]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.755]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.755]         }
[10:59:31.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.755]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.755]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.755]             base::names(...future.oldOptions))
[10:59:31.755]     }
[10:59:31.755]     if (FALSE) {
[10:59:31.755]     }
[10:59:31.755]     else {
[10:59:31.755]         if (TRUE) {
[10:59:31.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.755]                 open = "w")
[10:59:31.755]         }
[10:59:31.755]         else {
[10:59:31.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.755]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.755]         }
[10:59:31.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.755]             base::sink(type = "output", split = FALSE)
[10:59:31.755]             base::close(...future.stdout)
[10:59:31.755]         }, add = TRUE)
[10:59:31.755]     }
[10:59:31.755]     ...future.frame <- base::sys.nframe()
[10:59:31.755]     ...future.conditions <- base::list()
[10:59:31.755]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.755]     if (FALSE) {
[10:59:31.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.755]     }
[10:59:31.755]     ...future.result <- base::tryCatch({
[10:59:31.755]         base::withCallingHandlers({
[10:59:31.755]             ...future.value <- base::withVisible(base::local({
[10:59:31.755]                 withCallingHandlers({
[10:59:31.755]                   {
[10:59:31.755]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.755]                     if (!identical(...future.globals.maxSize.org, 
[10:59:31.755]                       ...future.globals.maxSize)) {
[10:59:31.755]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.755]                       on.exit(options(oopts), add = TRUE)
[10:59:31.755]                     }
[10:59:31.755]                     {
[10:59:31.755]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.755]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.755]                         USE.NAMES = FALSE)
[10:59:31.755]                       do.call(mapply, args = args)
[10:59:31.755]                     }
[10:59:31.755]                   }
[10:59:31.755]                 }, immediateCondition = function(cond) {
[10:59:31.755]                   save_rds <- function (object, pathname, ...) 
[10:59:31.755]                   {
[10:59:31.755]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:31.755]                     if (file_test("-f", pathname_tmp)) {
[10:59:31.755]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.755]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:31.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.755]                         fi_tmp[["mtime"]])
[10:59:31.755]                     }
[10:59:31.755]                     tryCatch({
[10:59:31.755]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:31.755]                     }, error = function(ex) {
[10:59:31.755]                       msg <- conditionMessage(ex)
[10:59:31.755]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.755]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:31.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.755]                         fi_tmp[["mtime"]], msg)
[10:59:31.755]                       ex$message <- msg
[10:59:31.755]                       stop(ex)
[10:59:31.755]                     })
[10:59:31.755]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:31.755]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:31.755]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:31.755]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.755]                       fi <- file.info(pathname)
[10:59:31.755]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:31.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.755]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:31.755]                         fi[["size"]], fi[["mtime"]])
[10:59:31.755]                       stop(msg)
[10:59:31.755]                     }
[10:59:31.755]                     invisible(pathname)
[10:59:31.755]                   }
[10:59:31.755]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:31.755]                     rootPath = tempdir()) 
[10:59:31.755]                   {
[10:59:31.755]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:31.755]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:31.755]                       tmpdir = path, fileext = ".rds")
[10:59:31.755]                     save_rds(obj, file)
[10:59:31.755]                   }
[10:59:31.755]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:31.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.755]                   {
[10:59:31.755]                     inherits <- base::inherits
[10:59:31.755]                     invokeRestart <- base::invokeRestart
[10:59:31.755]                     is.null <- base::is.null
[10:59:31.755]                     muffled <- FALSE
[10:59:31.755]                     if (inherits(cond, "message")) {
[10:59:31.755]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:31.755]                       if (muffled) 
[10:59:31.755]                         invokeRestart("muffleMessage")
[10:59:31.755]                     }
[10:59:31.755]                     else if (inherits(cond, "warning")) {
[10:59:31.755]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:31.755]                       if (muffled) 
[10:59:31.755]                         invokeRestart("muffleWarning")
[10:59:31.755]                     }
[10:59:31.755]                     else if (inherits(cond, "condition")) {
[10:59:31.755]                       if (!is.null(pattern)) {
[10:59:31.755]                         computeRestarts <- base::computeRestarts
[10:59:31.755]                         grepl <- base::grepl
[10:59:31.755]                         restarts <- computeRestarts(cond)
[10:59:31.755]                         for (restart in restarts) {
[10:59:31.755]                           name <- restart$name
[10:59:31.755]                           if (is.null(name)) 
[10:59:31.755]                             next
[10:59:31.755]                           if (!grepl(pattern, name)) 
[10:59:31.755]                             next
[10:59:31.755]                           invokeRestart(restart)
[10:59:31.755]                           muffled <- TRUE
[10:59:31.755]                           break
[10:59:31.755]                         }
[10:59:31.755]                       }
[10:59:31.755]                     }
[10:59:31.755]                     invisible(muffled)
[10:59:31.755]                   }
[10:59:31.755]                   muffleCondition(cond)
[10:59:31.755]                 })
[10:59:31.755]             }))
[10:59:31.755]             future::FutureResult(value = ...future.value$value, 
[10:59:31.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.755]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.755]                     ...future.globalenv.names))
[10:59:31.755]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.755]         }, condition = base::local({
[10:59:31.755]             c <- base::c
[10:59:31.755]             inherits <- base::inherits
[10:59:31.755]             invokeRestart <- base::invokeRestart
[10:59:31.755]             length <- base::length
[10:59:31.755]             list <- base::list
[10:59:31.755]             seq.int <- base::seq.int
[10:59:31.755]             signalCondition <- base::signalCondition
[10:59:31.755]             sys.calls <- base::sys.calls
[10:59:31.755]             `[[` <- base::`[[`
[10:59:31.755]             `+` <- base::`+`
[10:59:31.755]             `<<-` <- base::`<<-`
[10:59:31.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.755]                   3L)]
[10:59:31.755]             }
[10:59:31.755]             function(cond) {
[10:59:31.755]                 is_error <- inherits(cond, "error")
[10:59:31.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.755]                   NULL)
[10:59:31.755]                 if (is_error) {
[10:59:31.755]                   sessionInformation <- function() {
[10:59:31.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.755]                       search = base::search(), system = base::Sys.info())
[10:59:31.755]                   }
[10:59:31.755]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.755]                     cond$call), session = sessionInformation(), 
[10:59:31.755]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.755]                   signalCondition(cond)
[10:59:31.755]                 }
[10:59:31.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.755]                 "immediateCondition"))) {
[10:59:31.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.755]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.755]                   if (TRUE && !signal) {
[10:59:31.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.755]                     {
[10:59:31.755]                       inherits <- base::inherits
[10:59:31.755]                       invokeRestart <- base::invokeRestart
[10:59:31.755]                       is.null <- base::is.null
[10:59:31.755]                       muffled <- FALSE
[10:59:31.755]                       if (inherits(cond, "message")) {
[10:59:31.755]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.755]                         if (muffled) 
[10:59:31.755]                           invokeRestart("muffleMessage")
[10:59:31.755]                       }
[10:59:31.755]                       else if (inherits(cond, "warning")) {
[10:59:31.755]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.755]                         if (muffled) 
[10:59:31.755]                           invokeRestart("muffleWarning")
[10:59:31.755]                       }
[10:59:31.755]                       else if (inherits(cond, "condition")) {
[10:59:31.755]                         if (!is.null(pattern)) {
[10:59:31.755]                           computeRestarts <- base::computeRestarts
[10:59:31.755]                           grepl <- base::grepl
[10:59:31.755]                           restarts <- computeRestarts(cond)
[10:59:31.755]                           for (restart in restarts) {
[10:59:31.755]                             name <- restart$name
[10:59:31.755]                             if (is.null(name)) 
[10:59:31.755]                               next
[10:59:31.755]                             if (!grepl(pattern, name)) 
[10:59:31.755]                               next
[10:59:31.755]                             invokeRestart(restart)
[10:59:31.755]                             muffled <- TRUE
[10:59:31.755]                             break
[10:59:31.755]                           }
[10:59:31.755]                         }
[10:59:31.755]                       }
[10:59:31.755]                       invisible(muffled)
[10:59:31.755]                     }
[10:59:31.755]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.755]                   }
[10:59:31.755]                 }
[10:59:31.755]                 else {
[10:59:31.755]                   if (TRUE) {
[10:59:31.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.755]                     {
[10:59:31.755]                       inherits <- base::inherits
[10:59:31.755]                       invokeRestart <- base::invokeRestart
[10:59:31.755]                       is.null <- base::is.null
[10:59:31.755]                       muffled <- FALSE
[10:59:31.755]                       if (inherits(cond, "message")) {
[10:59:31.755]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.755]                         if (muffled) 
[10:59:31.755]                           invokeRestart("muffleMessage")
[10:59:31.755]                       }
[10:59:31.755]                       else if (inherits(cond, "warning")) {
[10:59:31.755]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.755]                         if (muffled) 
[10:59:31.755]                           invokeRestart("muffleWarning")
[10:59:31.755]                       }
[10:59:31.755]                       else if (inherits(cond, "condition")) {
[10:59:31.755]                         if (!is.null(pattern)) {
[10:59:31.755]                           computeRestarts <- base::computeRestarts
[10:59:31.755]                           grepl <- base::grepl
[10:59:31.755]                           restarts <- computeRestarts(cond)
[10:59:31.755]                           for (restart in restarts) {
[10:59:31.755]                             name <- restart$name
[10:59:31.755]                             if (is.null(name)) 
[10:59:31.755]                               next
[10:59:31.755]                             if (!grepl(pattern, name)) 
[10:59:31.755]                               next
[10:59:31.755]                             invokeRestart(restart)
[10:59:31.755]                             muffled <- TRUE
[10:59:31.755]                             break
[10:59:31.755]                           }
[10:59:31.755]                         }
[10:59:31.755]                       }
[10:59:31.755]                       invisible(muffled)
[10:59:31.755]                     }
[10:59:31.755]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.755]                   }
[10:59:31.755]                 }
[10:59:31.755]             }
[10:59:31.755]         }))
[10:59:31.755]     }, error = function(ex) {
[10:59:31.755]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.755]                 ...future.rng), started = ...future.startTime, 
[10:59:31.755]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.755]             version = "1.8"), class = "FutureResult")
[10:59:31.755]     }, finally = {
[10:59:31.755]         if (!identical(...future.workdir, getwd())) 
[10:59:31.755]             setwd(...future.workdir)
[10:59:31.755]         {
[10:59:31.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.755]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.755]             }
[10:59:31.755]             base::options(...future.oldOptions)
[10:59:31.755]             if (.Platform$OS.type == "windows") {
[10:59:31.755]                 old_names <- names(...future.oldEnvVars)
[10:59:31.755]                 envs <- base::Sys.getenv()
[10:59:31.755]                 names <- names(envs)
[10:59:31.755]                 common <- intersect(names, old_names)
[10:59:31.755]                 added <- setdiff(names, old_names)
[10:59:31.755]                 removed <- setdiff(old_names, names)
[10:59:31.755]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.755]                   envs[common]]
[10:59:31.755]                 NAMES <- toupper(changed)
[10:59:31.755]                 args <- list()
[10:59:31.755]                 for (kk in seq_along(NAMES)) {
[10:59:31.755]                   name <- changed[[kk]]
[10:59:31.755]                   NAME <- NAMES[[kk]]
[10:59:31.755]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.755]                     next
[10:59:31.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.755]                 }
[10:59:31.755]                 NAMES <- toupper(added)
[10:59:31.755]                 for (kk in seq_along(NAMES)) {
[10:59:31.755]                   name <- added[[kk]]
[10:59:31.755]                   NAME <- NAMES[[kk]]
[10:59:31.755]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.755]                     next
[10:59:31.755]                   args[[name]] <- ""
[10:59:31.755]                 }
[10:59:31.755]                 NAMES <- toupper(removed)
[10:59:31.755]                 for (kk in seq_along(NAMES)) {
[10:59:31.755]                   name <- removed[[kk]]
[10:59:31.755]                   NAME <- NAMES[[kk]]
[10:59:31.755]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.755]                     next
[10:59:31.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.755]                 }
[10:59:31.755]                 if (length(args) > 0) 
[10:59:31.755]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.755]             }
[10:59:31.755]             else {
[10:59:31.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.755]             }
[10:59:31.755]             {
[10:59:31.755]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.755]                   0L) {
[10:59:31.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.755]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.755]                   base::options(opts)
[10:59:31.755]                 }
[10:59:31.755]                 {
[10:59:31.755]                   {
[10:59:31.755]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:31.755]                     NULL
[10:59:31.755]                   }
[10:59:31.755]                   options(future.plan = NULL)
[10:59:31.755]                   if (is.na(NA_character_)) 
[10:59:31.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.755]                     .init = FALSE)
[10:59:31.755]                 }
[10:59:31.755]             }
[10:59:31.755]         }
[10:59:31.755]     })
[10:59:31.755]     if (TRUE) {
[10:59:31.755]         base::sink(type = "output", split = FALSE)
[10:59:31.755]         if (TRUE) {
[10:59:31.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.755]         }
[10:59:31.755]         else {
[10:59:31.755]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.755]         }
[10:59:31.755]         base::close(...future.stdout)
[10:59:31.755]         ...future.stdout <- NULL
[10:59:31.755]     }
[10:59:31.755]     ...future.result$conditions <- ...future.conditions
[10:59:31.755]     ...future.result$finished <- base::Sys.time()
[10:59:31.755]     ...future.result
[10:59:31.755] }
[10:59:31.757] assign_globals() ...
[10:59:31.758] List of 5
[10:59:31.758]  $ ...future.FUN            :function (x, ...)  
[10:59:31.758]  $ MoreArgs                 : NULL
[10:59:31.758]  $ ...future.elements_ii    :List of 2
[10:59:31.758]   ..$ :List of 2
[10:59:31.758]   .. ..$ : int 1
[10:59:31.758]   .. ..$ : int 2
[10:59:31.758]   ..$ :List of 2
[10:59:31.758]   .. ..$ : int 4
[10:59:31.758]   .. ..$ : int 3
[10:59:31.758]  $ ...future.seeds_ii       : NULL
[10:59:31.758]  $ ...future.globals.maxSize: NULL
[10:59:31.758]  - attr(*, "where")=List of 5
[10:59:31.758]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.758]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.758]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.758]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.758]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.758]  - attr(*, "resolved")= logi FALSE
[10:59:31.758]  - attr(*, "total_size")= num 210
[10:59:31.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.758]  - attr(*, "already-done")= logi TRUE
[10:59:31.763] - copied ‘...future.FUN’ to environment
[10:59:31.763] - copied ‘MoreArgs’ to environment
[10:59:31.763] - copied ‘...future.elements_ii’ to environment
[10:59:31.763] - copied ‘...future.seeds_ii’ to environment
[10:59:31.763] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.763] assign_globals() ... done
[10:59:31.763] requestCore(): workers = 2
[10:59:31.766] MulticoreFuture started
[10:59:31.767] - Launch lazy future ... done
[10:59:31.767] plan(): Setting new future strategy stack:
[10:59:31.767] run() for ‘MulticoreFuture’ ... done
[10:59:31.767] Created future:
[10:59:31.767] List of future strategies:
[10:59:31.767] 1. sequential:
[10:59:31.767]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.767]    - tweaked: FALSE
[10:59:31.767]    - call: NULL
[10:59:31.768] plan(): nbrOfWorkers() = 1
[10:59:31.770] plan(): Setting new future strategy stack:
[10:59:31.770] List of future strategies:
[10:59:31.770] 1. multicore:
[10:59:31.770]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:31.770]    - tweaked: FALSE
[10:59:31.770]    - call: plan(strategy)
[10:59:31.773] plan(): nbrOfWorkers() = 2
[10:59:31.767] MulticoreFuture:
[10:59:31.767] Label: ‘future_mapply-1’
[10:59:31.767] Expression:
[10:59:31.767] {
[10:59:31.767]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.767]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.767]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.767]         on.exit(options(oopts), add = TRUE)
[10:59:31.767]     }
[10:59:31.767]     {
[10:59:31.767]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.767]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.767]         do.call(mapply, args = args)
[10:59:31.767]     }
[10:59:31.767] }
[10:59:31.767] Lazy evaluation: FALSE
[10:59:31.767] Asynchronous evaluation: TRUE
[10:59:31.767] Local evaluation: TRUE
[10:59:31.767] Environment: R_GlobalEnv
[10:59:31.767] Capture standard output: TRUE
[10:59:31.767] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.767] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.767] Packages: <none>
[10:59:31.767] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.767] Resolved: TRUE
[10:59:31.767] Value: <not collected>
[10:59:31.767] Conditions captured: <none>
[10:59:31.767] Early signaling: FALSE
[10:59:31.767] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.767] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.775] Chunk #1 of 2 ... DONE
[10:59:31.775] Chunk #2 of 2 ...
[10:59:31.775]  - Finding globals in '...' for chunk #2 ...
[10:59:31.775] getGlobalsAndPackages() ...
[10:59:31.775] Searching for globals...
[10:59:31.776] 
[10:59:31.776] Searching for globals ... DONE
[10:59:31.776] - globals: [0] <none>
[10:59:31.776] getGlobalsAndPackages() ... DONE
[10:59:31.776]    + additional globals found: [n=0] 
[10:59:31.776]    + additional namespaces needed: [n=0] 
[10:59:31.777]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:31.777]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.777]  - seeds: <none>
[10:59:31.777]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.777] getGlobalsAndPackages() ...
[10:59:31.777] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.777] Resolving globals: FALSE
[10:59:31.778] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:31.779] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.779] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.779] 
[10:59:31.779] getGlobalsAndPackages() ... DONE
[10:59:31.780] run() for ‘Future’ ...
[10:59:31.780] - state: ‘created’
[10:59:31.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:31.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:31.788]   - Field: ‘label’
[10:59:31.788]   - Field: ‘local’
[10:59:31.789]   - Field: ‘owner’
[10:59:31.789]   - Field: ‘envir’
[10:59:31.789]   - Field: ‘workers’
[10:59:31.789]   - Field: ‘packages’
[10:59:31.789]   - Field: ‘gc’
[10:59:31.790]   - Field: ‘job’
[10:59:31.790]   - Field: ‘conditions’
[10:59:31.790]   - Field: ‘expr’
[10:59:31.790]   - Field: ‘uuid’
[10:59:31.790]   - Field: ‘seed’
[10:59:31.791]   - Field: ‘version’
[10:59:31.791]   - Field: ‘result’
[10:59:31.791]   - Field: ‘asynchronous’
[10:59:31.791]   - Field: ‘calls’
[10:59:31.792]   - Field: ‘globals’
[10:59:31.792]   - Field: ‘stdout’
[10:59:31.792]   - Field: ‘earlySignal’
[10:59:31.792]   - Field: ‘lazy’
[10:59:31.792]   - Field: ‘state’
[10:59:31.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:31.793] - Launch lazy future ...
[10:59:31.793] Packages needed by the future expression (n = 0): <none>
[10:59:31.793] Packages needed by future strategies (n = 0): <none>
[10:59:31.794] {
[10:59:31.794]     {
[10:59:31.794]         {
[10:59:31.794]             ...future.startTime <- base::Sys.time()
[10:59:31.794]             {
[10:59:31.794]                 {
[10:59:31.794]                   {
[10:59:31.794]                     {
[10:59:31.794]                       base::local({
[10:59:31.794]                         has_future <- base::requireNamespace("future", 
[10:59:31.794]                           quietly = TRUE)
[10:59:31.794]                         if (has_future) {
[10:59:31.794]                           ns <- base::getNamespace("future")
[10:59:31.794]                           version <- ns[[".package"]][["version"]]
[10:59:31.794]                           if (is.null(version)) 
[10:59:31.794]                             version <- utils::packageVersion("future")
[10:59:31.794]                         }
[10:59:31.794]                         else {
[10:59:31.794]                           version <- NULL
[10:59:31.794]                         }
[10:59:31.794]                         if (!has_future || version < "1.8.0") {
[10:59:31.794]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.794]                             "", base::R.version$version.string), 
[10:59:31.794]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.794]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.794]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.794]                               "release", "version")], collapse = " "), 
[10:59:31.794]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.794]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.794]                             info)
[10:59:31.794]                           info <- base::paste(info, collapse = "; ")
[10:59:31.794]                           if (!has_future) {
[10:59:31.794]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.794]                               info)
[10:59:31.794]                           }
[10:59:31.794]                           else {
[10:59:31.794]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.794]                               info, version)
[10:59:31.794]                           }
[10:59:31.794]                           base::stop(msg)
[10:59:31.794]                         }
[10:59:31.794]                       })
[10:59:31.794]                     }
[10:59:31.794]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:31.794]                     base::options(mc.cores = 1L)
[10:59:31.794]                   }
[10:59:31.794]                   ...future.strategy.old <- future::plan("list")
[10:59:31.794]                   options(future.plan = NULL)
[10:59:31.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.794]                 }
[10:59:31.794]                 ...future.workdir <- getwd()
[10:59:31.794]             }
[10:59:31.794]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.794]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.794]         }
[10:59:31.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.794]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.794]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.794]             base::names(...future.oldOptions))
[10:59:31.794]     }
[10:59:31.794]     if (FALSE) {
[10:59:31.794]     }
[10:59:31.794]     else {
[10:59:31.794]         if (TRUE) {
[10:59:31.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.794]                 open = "w")
[10:59:31.794]         }
[10:59:31.794]         else {
[10:59:31.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.794]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.794]         }
[10:59:31.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.794]             base::sink(type = "output", split = FALSE)
[10:59:31.794]             base::close(...future.stdout)
[10:59:31.794]         }, add = TRUE)
[10:59:31.794]     }
[10:59:31.794]     ...future.frame <- base::sys.nframe()
[10:59:31.794]     ...future.conditions <- base::list()
[10:59:31.794]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.794]     if (FALSE) {
[10:59:31.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.794]     }
[10:59:31.794]     ...future.result <- base::tryCatch({
[10:59:31.794]         base::withCallingHandlers({
[10:59:31.794]             ...future.value <- base::withVisible(base::local({
[10:59:31.794]                 withCallingHandlers({
[10:59:31.794]                   {
[10:59:31.794]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.794]                     if (!identical(...future.globals.maxSize.org, 
[10:59:31.794]                       ...future.globals.maxSize)) {
[10:59:31.794]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.794]                       on.exit(options(oopts), add = TRUE)
[10:59:31.794]                     }
[10:59:31.794]                     {
[10:59:31.794]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.794]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.794]                         USE.NAMES = FALSE)
[10:59:31.794]                       do.call(mapply, args = args)
[10:59:31.794]                     }
[10:59:31.794]                   }
[10:59:31.794]                 }, immediateCondition = function(cond) {
[10:59:31.794]                   save_rds <- function (object, pathname, ...) 
[10:59:31.794]                   {
[10:59:31.794]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:31.794]                     if (file_test("-f", pathname_tmp)) {
[10:59:31.794]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.794]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:31.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.794]                         fi_tmp[["mtime"]])
[10:59:31.794]                     }
[10:59:31.794]                     tryCatch({
[10:59:31.794]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:31.794]                     }, error = function(ex) {
[10:59:31.794]                       msg <- conditionMessage(ex)
[10:59:31.794]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.794]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:31.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.794]                         fi_tmp[["mtime"]], msg)
[10:59:31.794]                       ex$message <- msg
[10:59:31.794]                       stop(ex)
[10:59:31.794]                     })
[10:59:31.794]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:31.794]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:31.794]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:31.794]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.794]                       fi <- file.info(pathname)
[10:59:31.794]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:31.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.794]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:31.794]                         fi[["size"]], fi[["mtime"]])
[10:59:31.794]                       stop(msg)
[10:59:31.794]                     }
[10:59:31.794]                     invisible(pathname)
[10:59:31.794]                   }
[10:59:31.794]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:31.794]                     rootPath = tempdir()) 
[10:59:31.794]                   {
[10:59:31.794]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:31.794]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:31.794]                       tmpdir = path, fileext = ".rds")
[10:59:31.794]                     save_rds(obj, file)
[10:59:31.794]                   }
[10:59:31.794]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:31.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.794]                   {
[10:59:31.794]                     inherits <- base::inherits
[10:59:31.794]                     invokeRestart <- base::invokeRestart
[10:59:31.794]                     is.null <- base::is.null
[10:59:31.794]                     muffled <- FALSE
[10:59:31.794]                     if (inherits(cond, "message")) {
[10:59:31.794]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:31.794]                       if (muffled) 
[10:59:31.794]                         invokeRestart("muffleMessage")
[10:59:31.794]                     }
[10:59:31.794]                     else if (inherits(cond, "warning")) {
[10:59:31.794]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:31.794]                       if (muffled) 
[10:59:31.794]                         invokeRestart("muffleWarning")
[10:59:31.794]                     }
[10:59:31.794]                     else if (inherits(cond, "condition")) {
[10:59:31.794]                       if (!is.null(pattern)) {
[10:59:31.794]                         computeRestarts <- base::computeRestarts
[10:59:31.794]                         grepl <- base::grepl
[10:59:31.794]                         restarts <- computeRestarts(cond)
[10:59:31.794]                         for (restart in restarts) {
[10:59:31.794]                           name <- restart$name
[10:59:31.794]                           if (is.null(name)) 
[10:59:31.794]                             next
[10:59:31.794]                           if (!grepl(pattern, name)) 
[10:59:31.794]                             next
[10:59:31.794]                           invokeRestart(restart)
[10:59:31.794]                           muffled <- TRUE
[10:59:31.794]                           break
[10:59:31.794]                         }
[10:59:31.794]                       }
[10:59:31.794]                     }
[10:59:31.794]                     invisible(muffled)
[10:59:31.794]                   }
[10:59:31.794]                   muffleCondition(cond)
[10:59:31.794]                 })
[10:59:31.794]             }))
[10:59:31.794]             future::FutureResult(value = ...future.value$value, 
[10:59:31.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.794]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.794]                     ...future.globalenv.names))
[10:59:31.794]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.794]         }, condition = base::local({
[10:59:31.794]             c <- base::c
[10:59:31.794]             inherits <- base::inherits
[10:59:31.794]             invokeRestart <- base::invokeRestart
[10:59:31.794]             length <- base::length
[10:59:31.794]             list <- base::list
[10:59:31.794]             seq.int <- base::seq.int
[10:59:31.794]             signalCondition <- base::signalCondition
[10:59:31.794]             sys.calls <- base::sys.calls
[10:59:31.794]             `[[` <- base::`[[`
[10:59:31.794]             `+` <- base::`+`
[10:59:31.794]             `<<-` <- base::`<<-`
[10:59:31.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.794]                   3L)]
[10:59:31.794]             }
[10:59:31.794]             function(cond) {
[10:59:31.794]                 is_error <- inherits(cond, "error")
[10:59:31.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.794]                   NULL)
[10:59:31.794]                 if (is_error) {
[10:59:31.794]                   sessionInformation <- function() {
[10:59:31.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.794]                       search = base::search(), system = base::Sys.info())
[10:59:31.794]                   }
[10:59:31.794]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.794]                     cond$call), session = sessionInformation(), 
[10:59:31.794]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.794]                   signalCondition(cond)
[10:59:31.794]                 }
[10:59:31.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.794]                 "immediateCondition"))) {
[10:59:31.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.794]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.794]                   if (TRUE && !signal) {
[10:59:31.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.794]                     {
[10:59:31.794]                       inherits <- base::inherits
[10:59:31.794]                       invokeRestart <- base::invokeRestart
[10:59:31.794]                       is.null <- base::is.null
[10:59:31.794]                       muffled <- FALSE
[10:59:31.794]                       if (inherits(cond, "message")) {
[10:59:31.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.794]                         if (muffled) 
[10:59:31.794]                           invokeRestart("muffleMessage")
[10:59:31.794]                       }
[10:59:31.794]                       else if (inherits(cond, "warning")) {
[10:59:31.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.794]                         if (muffled) 
[10:59:31.794]                           invokeRestart("muffleWarning")
[10:59:31.794]                       }
[10:59:31.794]                       else if (inherits(cond, "condition")) {
[10:59:31.794]                         if (!is.null(pattern)) {
[10:59:31.794]                           computeRestarts <- base::computeRestarts
[10:59:31.794]                           grepl <- base::grepl
[10:59:31.794]                           restarts <- computeRestarts(cond)
[10:59:31.794]                           for (restart in restarts) {
[10:59:31.794]                             name <- restart$name
[10:59:31.794]                             if (is.null(name)) 
[10:59:31.794]                               next
[10:59:31.794]                             if (!grepl(pattern, name)) 
[10:59:31.794]                               next
[10:59:31.794]                             invokeRestart(restart)
[10:59:31.794]                             muffled <- TRUE
[10:59:31.794]                             break
[10:59:31.794]                           }
[10:59:31.794]                         }
[10:59:31.794]                       }
[10:59:31.794]                       invisible(muffled)
[10:59:31.794]                     }
[10:59:31.794]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.794]                   }
[10:59:31.794]                 }
[10:59:31.794]                 else {
[10:59:31.794]                   if (TRUE) {
[10:59:31.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.794]                     {
[10:59:31.794]                       inherits <- base::inherits
[10:59:31.794]                       invokeRestart <- base::invokeRestart
[10:59:31.794]                       is.null <- base::is.null
[10:59:31.794]                       muffled <- FALSE
[10:59:31.794]                       if (inherits(cond, "message")) {
[10:59:31.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.794]                         if (muffled) 
[10:59:31.794]                           invokeRestart("muffleMessage")
[10:59:31.794]                       }
[10:59:31.794]                       else if (inherits(cond, "warning")) {
[10:59:31.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.794]                         if (muffled) 
[10:59:31.794]                           invokeRestart("muffleWarning")
[10:59:31.794]                       }
[10:59:31.794]                       else if (inherits(cond, "condition")) {
[10:59:31.794]                         if (!is.null(pattern)) {
[10:59:31.794]                           computeRestarts <- base::computeRestarts
[10:59:31.794]                           grepl <- base::grepl
[10:59:31.794]                           restarts <- computeRestarts(cond)
[10:59:31.794]                           for (restart in restarts) {
[10:59:31.794]                             name <- restart$name
[10:59:31.794]                             if (is.null(name)) 
[10:59:31.794]                               next
[10:59:31.794]                             if (!grepl(pattern, name)) 
[10:59:31.794]                               next
[10:59:31.794]                             invokeRestart(restart)
[10:59:31.794]                             muffled <- TRUE
[10:59:31.794]                             break
[10:59:31.794]                           }
[10:59:31.794]                         }
[10:59:31.794]                       }
[10:59:31.794]                       invisible(muffled)
[10:59:31.794]                     }
[10:59:31.794]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.794]                   }
[10:59:31.794]                 }
[10:59:31.794]             }
[10:59:31.794]         }))
[10:59:31.794]     }, error = function(ex) {
[10:59:31.794]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.794]                 ...future.rng), started = ...future.startTime, 
[10:59:31.794]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.794]             version = "1.8"), class = "FutureResult")
[10:59:31.794]     }, finally = {
[10:59:31.794]         if (!identical(...future.workdir, getwd())) 
[10:59:31.794]             setwd(...future.workdir)
[10:59:31.794]         {
[10:59:31.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.794]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.794]             }
[10:59:31.794]             base::options(...future.oldOptions)
[10:59:31.794]             if (.Platform$OS.type == "windows") {
[10:59:31.794]                 old_names <- names(...future.oldEnvVars)
[10:59:31.794]                 envs <- base::Sys.getenv()
[10:59:31.794]                 names <- names(envs)
[10:59:31.794]                 common <- intersect(names, old_names)
[10:59:31.794]                 added <- setdiff(names, old_names)
[10:59:31.794]                 removed <- setdiff(old_names, names)
[10:59:31.794]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.794]                   envs[common]]
[10:59:31.794]                 NAMES <- toupper(changed)
[10:59:31.794]                 args <- list()
[10:59:31.794]                 for (kk in seq_along(NAMES)) {
[10:59:31.794]                   name <- changed[[kk]]
[10:59:31.794]                   NAME <- NAMES[[kk]]
[10:59:31.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.794]                     next
[10:59:31.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.794]                 }
[10:59:31.794]                 NAMES <- toupper(added)
[10:59:31.794]                 for (kk in seq_along(NAMES)) {
[10:59:31.794]                   name <- added[[kk]]
[10:59:31.794]                   NAME <- NAMES[[kk]]
[10:59:31.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.794]                     next
[10:59:31.794]                   args[[name]] <- ""
[10:59:31.794]                 }
[10:59:31.794]                 NAMES <- toupper(removed)
[10:59:31.794]                 for (kk in seq_along(NAMES)) {
[10:59:31.794]                   name <- removed[[kk]]
[10:59:31.794]                   NAME <- NAMES[[kk]]
[10:59:31.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.794]                     next
[10:59:31.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.794]                 }
[10:59:31.794]                 if (length(args) > 0) 
[10:59:31.794]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.794]             }
[10:59:31.794]             else {
[10:59:31.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.794]             }
[10:59:31.794]             {
[10:59:31.794]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.794]                   0L) {
[10:59:31.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.794]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.794]                   base::options(opts)
[10:59:31.794]                 }
[10:59:31.794]                 {
[10:59:31.794]                   {
[10:59:31.794]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:31.794]                     NULL
[10:59:31.794]                   }
[10:59:31.794]                   options(future.plan = NULL)
[10:59:31.794]                   if (is.na(NA_character_)) 
[10:59:31.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.794]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.794]                     .init = FALSE)
[10:59:31.794]                 }
[10:59:31.794]             }
[10:59:31.794]         }
[10:59:31.794]     })
[10:59:31.794]     if (TRUE) {
[10:59:31.794]         base::sink(type = "output", split = FALSE)
[10:59:31.794]         if (TRUE) {
[10:59:31.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.794]         }
[10:59:31.794]         else {
[10:59:31.794]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.794]         }
[10:59:31.794]         base::close(...future.stdout)
[10:59:31.794]         ...future.stdout <- NULL
[10:59:31.794]     }
[10:59:31.794]     ...future.result$conditions <- ...future.conditions
[10:59:31.794]     ...future.result$finished <- base::Sys.time()
[10:59:31.794]     ...future.result
[10:59:31.794] }
[10:59:31.797] assign_globals() ...
[10:59:31.797] List of 5
[10:59:31.797]  $ ...future.FUN            :function (x, ...)  
[10:59:31.797]  $ MoreArgs                 : NULL
[10:59:31.797]  $ ...future.elements_ii    :List of 2
[10:59:31.797]   ..$ :List of 2
[10:59:31.797]   .. ..$ : int 3
[10:59:31.797]   .. ..$ : int 4
[10:59:31.797]   ..$ :List of 2
[10:59:31.797]   .. ..$ : int 2
[10:59:31.797]   .. ..$ : int 1
[10:59:31.797]  $ ...future.seeds_ii       : NULL
[10:59:31.797]  $ ...future.globals.maxSize: NULL
[10:59:31.797]  - attr(*, "where")=List of 5
[10:59:31.797]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.797]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.797]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.797]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.797]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.797]  - attr(*, "resolved")= logi FALSE
[10:59:31.797]  - attr(*, "total_size")= num 210
[10:59:31.797]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.797]  - attr(*, "already-done")= logi TRUE
[10:59:31.804] - copied ‘...future.FUN’ to environment
[10:59:31.804] - copied ‘MoreArgs’ to environment
[10:59:31.805] - copied ‘...future.elements_ii’ to environment
[10:59:31.805] - copied ‘...future.seeds_ii’ to environment
[10:59:31.805] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.805] assign_globals() ... done
[10:59:31.805] requestCore(): workers = 2
[10:59:31.810] MulticoreFuture started
[10:59:31.811] - Launch lazy future ... done
[10:59:31.811] run() for ‘MulticoreFuture’ ... done
[10:59:31.811] Created future:
[10:59:31.811] plan(): Setting new future strategy stack:
[10:59:31.812] List of future strategies:
[10:59:31.812] 1. sequential:
[10:59:31.812]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.812]    - tweaked: FALSE
[10:59:31.812]    - call: NULL
[10:59:31.812] plan(): nbrOfWorkers() = 1
[10:59:31.815] plan(): Setting new future strategy stack:
[10:59:31.815] List of future strategies:
[10:59:31.815] 1. multicore:
[10:59:31.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:31.815]    - tweaked: FALSE
[10:59:31.815]    - call: plan(strategy)
[10:59:31.818] plan(): nbrOfWorkers() = 2
[10:59:31.811] MulticoreFuture:
[10:59:31.811] Label: ‘future_mapply-2’
[10:59:31.811] Expression:
[10:59:31.811] {
[10:59:31.811]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.811]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.811]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.811]         on.exit(options(oopts), add = TRUE)
[10:59:31.811]     }
[10:59:31.811]     {
[10:59:31.811]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.811]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.811]         do.call(mapply, args = args)
[10:59:31.811]     }
[10:59:31.811] }
[10:59:31.811] Lazy evaluation: FALSE
[10:59:31.811] Asynchronous evaluation: TRUE
[10:59:31.811] Local evaluation: TRUE
[10:59:31.811] Environment: R_GlobalEnv
[10:59:31.811] Capture standard output: TRUE
[10:59:31.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.811] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.811] Packages: <none>
[10:59:31.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.811] Resolved: TRUE
[10:59:31.811] Value: <not collected>
[10:59:31.811] Conditions captured: <none>
[10:59:31.811] Early signaling: FALSE
[10:59:31.811] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.811] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.819] Chunk #2 of 2 ... DONE
[10:59:31.819] Launching 2 futures (chunks) ... DONE
[10:59:31.819] Resolving 2 futures (chunks) ...
[10:59:31.819] resolve() on list ...
[10:59:31.819]  recursive: 0
[10:59:31.820]  length: 2
[10:59:31.820] 
[10:59:31.820] Future #1
[10:59:31.821] result() for MulticoreFuture ...
[10:59:31.822] result() for MulticoreFuture ...
[10:59:31.822] result() for MulticoreFuture ... done
[10:59:31.823] result() for MulticoreFuture ... done
[10:59:31.823] result() for MulticoreFuture ...
[10:59:31.823] result() for MulticoreFuture ... done
[10:59:31.823] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:31.823] - nx: 2
[10:59:31.823] - relay: TRUE
[10:59:31.824] - stdout: TRUE
[10:59:31.824] - signal: TRUE
[10:59:31.824] - resignal: FALSE
[10:59:31.824] - force: TRUE
[10:59:31.824] - relayed: [n=2] FALSE, FALSE
[10:59:31.824] - queued futures: [n=2] FALSE, FALSE
[10:59:31.824]  - until=1
[10:59:31.825]  - relaying element #1
[10:59:31.825] result() for MulticoreFuture ...
[10:59:31.825] result() for MulticoreFuture ... done
[10:59:31.825] result() for MulticoreFuture ...
[10:59:31.825] result() for MulticoreFuture ... done
[10:59:31.825] result() for MulticoreFuture ...
[10:59:31.825] result() for MulticoreFuture ... done
[10:59:31.826] result() for MulticoreFuture ...
[10:59:31.826] result() for MulticoreFuture ... done
[10:59:31.826] - relayed: [n=2] TRUE, FALSE
[10:59:31.826] - queued futures: [n=2] TRUE, FALSE
[10:59:31.826] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:31.826]  length: 1 (resolved future 1)
[10:59:31.827] Future #2
[10:59:31.827] result() for MulticoreFuture ...
[10:59:31.827] result() for MulticoreFuture ...
[10:59:31.828] result() for MulticoreFuture ... done
[10:59:31.828] result() for MulticoreFuture ... done
[10:59:31.828] result() for MulticoreFuture ...
[10:59:31.828] result() for MulticoreFuture ... done
[10:59:31.828] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:31.831] - nx: 2
[10:59:31.831] - relay: TRUE
[10:59:31.831] - stdout: TRUE
[10:59:31.831] - signal: TRUE
[10:59:31.832] - resignal: FALSE
[10:59:31.832] - force: TRUE
[10:59:31.832] - relayed: [n=2] TRUE, FALSE
[10:59:31.832] - queued futures: [n=2] TRUE, FALSE
[10:59:31.832]  - until=2
[10:59:31.832]  - relaying element #2
[10:59:31.832] result() for MulticoreFuture ...
[10:59:31.833] result() for MulticoreFuture ... done
[10:59:31.833] result() for MulticoreFuture ...
[10:59:31.833] result() for MulticoreFuture ... done
[10:59:31.833] result() for MulticoreFuture ...
[10:59:31.833] result() for MulticoreFuture ... done
[10:59:31.833] result() for MulticoreFuture ...
[10:59:31.833] result() for MulticoreFuture ... done
[10:59:31.834] - relayed: [n=2] TRUE, TRUE
[10:59:31.834] - queued futures: [n=2] TRUE, TRUE
[10:59:31.834] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:31.834]  length: 0 (resolved future 2)
[10:59:31.834] Relaying remaining futures
[10:59:31.834] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.834] - nx: 2
[10:59:31.835] - relay: TRUE
[10:59:31.835] - stdout: TRUE
[10:59:31.835] - signal: TRUE
[10:59:31.835] - resignal: FALSE
[10:59:31.835] - force: TRUE
[10:59:31.835] - relayed: [n=2] TRUE, TRUE
[10:59:31.835] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:31.836] - relayed: [n=2] TRUE, TRUE
[10:59:31.836] - queued futures: [n=2] TRUE, TRUE
[10:59:31.836] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.836] resolve() on list ... DONE
[10:59:31.836] result() for MulticoreFuture ...
[10:59:31.836] result() for MulticoreFuture ... done
[10:59:31.836] result() for MulticoreFuture ...
[10:59:31.836] result() for MulticoreFuture ... done
[10:59:31.837] result() for MulticoreFuture ...
[10:59:31.837] result() for MulticoreFuture ... done
[10:59:31.837] result() for MulticoreFuture ...
[10:59:31.837] result() for MulticoreFuture ... done
[10:59:31.837]  - Number of value chunks collected: 2
[10:59:31.837] Resolving 2 futures (chunks) ... DONE
[10:59:31.837] Reducing values from 2 chunks ...
[10:59:31.837]  - Number of values collected after concatenation: 4
[10:59:31.837]  - Number of values expected: 4
[10:59:31.837] Reducing values from 2 chunks ... DONE
[10:59:31.838] future_mapply() ... DONE
[10:59:31.838] future_mapply() ...
[10:59:31.840] Number of chunks: 2
[10:59:31.840] getGlobalsAndPackagesXApply() ...
[10:59:31.840]  - future.globals: TRUE
[10:59:31.840] getGlobalsAndPackages() ...
[10:59:31.840] Searching for globals...
[10:59:31.841] - globals found: [1] ‘FUN’
[10:59:31.841] Searching for globals ... DONE
[10:59:31.841] Resolving globals: FALSE
[10:59:31.841] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:31.842] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:31.842] - globals: [1] ‘FUN’
[10:59:31.842] 
[10:59:31.842] getGlobalsAndPackages() ... DONE
[10:59:31.842]  - globals found/used: [n=1] ‘FUN’
[10:59:31.842]  - needed namespaces: [n=0] 
[10:59:31.843] Finding globals ... DONE
[10:59:31.843] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.843] List of 2
[10:59:31.843]  $ ...future.FUN:function (x, ...)  
[10:59:31.843]  $ MoreArgs     : NULL
[10:59:31.843]  - attr(*, "where")=List of 2
[10:59:31.843]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.843]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.843]  - attr(*, "resolved")= logi FALSE
[10:59:31.843]  - attr(*, "total_size")= num NA
[10:59:31.846] Packages to be attached in all futures: [n=0] 
[10:59:31.846] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.846] Number of futures (= number of chunks): 2
[10:59:31.846] Launching 2 futures (chunks) ...
[10:59:31.846] Chunk #1 of 2 ...
[10:59:31.846]  - Finding globals in '...' for chunk #1 ...
[10:59:31.846] getGlobalsAndPackages() ...
[10:59:31.846] Searching for globals...
[10:59:31.847] 
[10:59:31.847] Searching for globals ... DONE
[10:59:31.847] - globals: [0] <none>
[10:59:31.847] getGlobalsAndPackages() ... DONE
[10:59:31.847]    + additional globals found: [n=0] 
[10:59:31.847]    + additional namespaces needed: [n=0] 
[10:59:31.847]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.847]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.848]  - seeds: <none>
[10:59:31.848]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.848] getGlobalsAndPackages() ...
[10:59:31.848] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.848] Resolving globals: FALSE
[10:59:31.848] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:31.849] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.849] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.849] 
[10:59:31.849] getGlobalsAndPackages() ... DONE
[10:59:31.849] run() for ‘Future’ ...
[10:59:31.850] - state: ‘created’
[10:59:31.850] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:31.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:31.852]   - Field: ‘label’
[10:59:31.852]   - Field: ‘local’
[10:59:31.852]   - Field: ‘owner’
[10:59:31.852]   - Field: ‘envir’
[10:59:31.852]   - Field: ‘workers’
[10:59:31.852]   - Field: ‘packages’
[10:59:31.852]   - Field: ‘gc’
[10:59:31.852]   - Field: ‘job’
[10:59:31.852]   - Field: ‘conditions’
[10:59:31.852]   - Field: ‘expr’
[10:59:31.852]   - Field: ‘uuid’
[10:59:31.852]   - Field: ‘seed’
[10:59:31.853]   - Field: ‘version’
[10:59:31.853]   - Field: ‘result’
[10:59:31.853]   - Field: ‘asynchronous’
[10:59:31.853]   - Field: ‘calls’
[10:59:31.853]   - Field: ‘globals’
[10:59:31.853]   - Field: ‘stdout’
[10:59:31.853]   - Field: ‘earlySignal’
[10:59:31.853]   - Field: ‘lazy’
[10:59:31.853]   - Field: ‘state’
[10:59:31.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:31.853] - Launch lazy future ...
[10:59:31.854] Packages needed by the future expression (n = 0): <none>
[10:59:31.854] Packages needed by future strategies (n = 0): <none>
[10:59:31.854] {
[10:59:31.854]     {
[10:59:31.854]         {
[10:59:31.854]             ...future.startTime <- base::Sys.time()
[10:59:31.854]             {
[10:59:31.854]                 {
[10:59:31.854]                   {
[10:59:31.854]                     {
[10:59:31.854]                       base::local({
[10:59:31.854]                         has_future <- base::requireNamespace("future", 
[10:59:31.854]                           quietly = TRUE)
[10:59:31.854]                         if (has_future) {
[10:59:31.854]                           ns <- base::getNamespace("future")
[10:59:31.854]                           version <- ns[[".package"]][["version"]]
[10:59:31.854]                           if (is.null(version)) 
[10:59:31.854]                             version <- utils::packageVersion("future")
[10:59:31.854]                         }
[10:59:31.854]                         else {
[10:59:31.854]                           version <- NULL
[10:59:31.854]                         }
[10:59:31.854]                         if (!has_future || version < "1.8.0") {
[10:59:31.854]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.854]                             "", base::R.version$version.string), 
[10:59:31.854]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.854]                               "release", "version")], collapse = " "), 
[10:59:31.854]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.854]                             info)
[10:59:31.854]                           info <- base::paste(info, collapse = "; ")
[10:59:31.854]                           if (!has_future) {
[10:59:31.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.854]                               info)
[10:59:31.854]                           }
[10:59:31.854]                           else {
[10:59:31.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.854]                               info, version)
[10:59:31.854]                           }
[10:59:31.854]                           base::stop(msg)
[10:59:31.854]                         }
[10:59:31.854]                       })
[10:59:31.854]                     }
[10:59:31.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:31.854]                     base::options(mc.cores = 1L)
[10:59:31.854]                   }
[10:59:31.854]                   ...future.strategy.old <- future::plan("list")
[10:59:31.854]                   options(future.plan = NULL)
[10:59:31.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.854]                 }
[10:59:31.854]                 ...future.workdir <- getwd()
[10:59:31.854]             }
[10:59:31.854]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.854]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.854]         }
[10:59:31.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.854]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.854]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.854]             base::names(...future.oldOptions))
[10:59:31.854]     }
[10:59:31.854]     if (FALSE) {
[10:59:31.854]     }
[10:59:31.854]     else {
[10:59:31.854]         if (TRUE) {
[10:59:31.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.854]                 open = "w")
[10:59:31.854]         }
[10:59:31.854]         else {
[10:59:31.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.854]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.854]         }
[10:59:31.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.854]             base::sink(type = "output", split = FALSE)
[10:59:31.854]             base::close(...future.stdout)
[10:59:31.854]         }, add = TRUE)
[10:59:31.854]     }
[10:59:31.854]     ...future.frame <- base::sys.nframe()
[10:59:31.854]     ...future.conditions <- base::list()
[10:59:31.854]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.854]     if (FALSE) {
[10:59:31.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.854]     }
[10:59:31.854]     ...future.result <- base::tryCatch({
[10:59:31.854]         base::withCallingHandlers({
[10:59:31.854]             ...future.value <- base::withVisible(base::local({
[10:59:31.854]                 withCallingHandlers({
[10:59:31.854]                   {
[10:59:31.854]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.854]                     if (!identical(...future.globals.maxSize.org, 
[10:59:31.854]                       ...future.globals.maxSize)) {
[10:59:31.854]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.854]                       on.exit(options(oopts), add = TRUE)
[10:59:31.854]                     }
[10:59:31.854]                     {
[10:59:31.854]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.854]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.854]                         USE.NAMES = FALSE)
[10:59:31.854]                       do.call(mapply, args = args)
[10:59:31.854]                     }
[10:59:31.854]                   }
[10:59:31.854]                 }, immediateCondition = function(cond) {
[10:59:31.854]                   save_rds <- function (object, pathname, ...) 
[10:59:31.854]                   {
[10:59:31.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:31.854]                     if (file_test("-f", pathname_tmp)) {
[10:59:31.854]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:31.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.854]                         fi_tmp[["mtime"]])
[10:59:31.854]                     }
[10:59:31.854]                     tryCatch({
[10:59:31.854]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:31.854]                     }, error = function(ex) {
[10:59:31.854]                       msg <- conditionMessage(ex)
[10:59:31.854]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:31.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.854]                         fi_tmp[["mtime"]], msg)
[10:59:31.854]                       ex$message <- msg
[10:59:31.854]                       stop(ex)
[10:59:31.854]                     })
[10:59:31.854]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:31.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:31.854]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:31.854]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.854]                       fi <- file.info(pathname)
[10:59:31.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:31.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:31.854]                         fi[["size"]], fi[["mtime"]])
[10:59:31.854]                       stop(msg)
[10:59:31.854]                     }
[10:59:31.854]                     invisible(pathname)
[10:59:31.854]                   }
[10:59:31.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:31.854]                     rootPath = tempdir()) 
[10:59:31.854]                   {
[10:59:31.854]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:31.854]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:31.854]                       tmpdir = path, fileext = ".rds")
[10:59:31.854]                     save_rds(obj, file)
[10:59:31.854]                   }
[10:59:31.854]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:31.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.854]                   {
[10:59:31.854]                     inherits <- base::inherits
[10:59:31.854]                     invokeRestart <- base::invokeRestart
[10:59:31.854]                     is.null <- base::is.null
[10:59:31.854]                     muffled <- FALSE
[10:59:31.854]                     if (inherits(cond, "message")) {
[10:59:31.854]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:31.854]                       if (muffled) 
[10:59:31.854]                         invokeRestart("muffleMessage")
[10:59:31.854]                     }
[10:59:31.854]                     else if (inherits(cond, "warning")) {
[10:59:31.854]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:31.854]                       if (muffled) 
[10:59:31.854]                         invokeRestart("muffleWarning")
[10:59:31.854]                     }
[10:59:31.854]                     else if (inherits(cond, "condition")) {
[10:59:31.854]                       if (!is.null(pattern)) {
[10:59:31.854]                         computeRestarts <- base::computeRestarts
[10:59:31.854]                         grepl <- base::grepl
[10:59:31.854]                         restarts <- computeRestarts(cond)
[10:59:31.854]                         for (restart in restarts) {
[10:59:31.854]                           name <- restart$name
[10:59:31.854]                           if (is.null(name)) 
[10:59:31.854]                             next
[10:59:31.854]                           if (!grepl(pattern, name)) 
[10:59:31.854]                             next
[10:59:31.854]                           invokeRestart(restart)
[10:59:31.854]                           muffled <- TRUE
[10:59:31.854]                           break
[10:59:31.854]                         }
[10:59:31.854]                       }
[10:59:31.854]                     }
[10:59:31.854]                     invisible(muffled)
[10:59:31.854]                   }
[10:59:31.854]                   muffleCondition(cond)
[10:59:31.854]                 })
[10:59:31.854]             }))
[10:59:31.854]             future::FutureResult(value = ...future.value$value, 
[10:59:31.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.854]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.854]                     ...future.globalenv.names))
[10:59:31.854]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.854]         }, condition = base::local({
[10:59:31.854]             c <- base::c
[10:59:31.854]             inherits <- base::inherits
[10:59:31.854]             invokeRestart <- base::invokeRestart
[10:59:31.854]             length <- base::length
[10:59:31.854]             list <- base::list
[10:59:31.854]             seq.int <- base::seq.int
[10:59:31.854]             signalCondition <- base::signalCondition
[10:59:31.854]             sys.calls <- base::sys.calls
[10:59:31.854]             `[[` <- base::`[[`
[10:59:31.854]             `+` <- base::`+`
[10:59:31.854]             `<<-` <- base::`<<-`
[10:59:31.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.854]                   3L)]
[10:59:31.854]             }
[10:59:31.854]             function(cond) {
[10:59:31.854]                 is_error <- inherits(cond, "error")
[10:59:31.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.854]                   NULL)
[10:59:31.854]                 if (is_error) {
[10:59:31.854]                   sessionInformation <- function() {
[10:59:31.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.854]                       search = base::search(), system = base::Sys.info())
[10:59:31.854]                   }
[10:59:31.854]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.854]                     cond$call), session = sessionInformation(), 
[10:59:31.854]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.854]                   signalCondition(cond)
[10:59:31.854]                 }
[10:59:31.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.854]                 "immediateCondition"))) {
[10:59:31.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.854]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.854]                   if (TRUE && !signal) {
[10:59:31.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.854]                     {
[10:59:31.854]                       inherits <- base::inherits
[10:59:31.854]                       invokeRestart <- base::invokeRestart
[10:59:31.854]                       is.null <- base::is.null
[10:59:31.854]                       muffled <- FALSE
[10:59:31.854]                       if (inherits(cond, "message")) {
[10:59:31.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.854]                         if (muffled) 
[10:59:31.854]                           invokeRestart("muffleMessage")
[10:59:31.854]                       }
[10:59:31.854]                       else if (inherits(cond, "warning")) {
[10:59:31.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.854]                         if (muffled) 
[10:59:31.854]                           invokeRestart("muffleWarning")
[10:59:31.854]                       }
[10:59:31.854]                       else if (inherits(cond, "condition")) {
[10:59:31.854]                         if (!is.null(pattern)) {
[10:59:31.854]                           computeRestarts <- base::computeRestarts
[10:59:31.854]                           grepl <- base::grepl
[10:59:31.854]                           restarts <- computeRestarts(cond)
[10:59:31.854]                           for (restart in restarts) {
[10:59:31.854]                             name <- restart$name
[10:59:31.854]                             if (is.null(name)) 
[10:59:31.854]                               next
[10:59:31.854]                             if (!grepl(pattern, name)) 
[10:59:31.854]                               next
[10:59:31.854]                             invokeRestart(restart)
[10:59:31.854]                             muffled <- TRUE
[10:59:31.854]                             break
[10:59:31.854]                           }
[10:59:31.854]                         }
[10:59:31.854]                       }
[10:59:31.854]                       invisible(muffled)
[10:59:31.854]                     }
[10:59:31.854]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.854]                   }
[10:59:31.854]                 }
[10:59:31.854]                 else {
[10:59:31.854]                   if (TRUE) {
[10:59:31.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.854]                     {
[10:59:31.854]                       inherits <- base::inherits
[10:59:31.854]                       invokeRestart <- base::invokeRestart
[10:59:31.854]                       is.null <- base::is.null
[10:59:31.854]                       muffled <- FALSE
[10:59:31.854]                       if (inherits(cond, "message")) {
[10:59:31.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.854]                         if (muffled) 
[10:59:31.854]                           invokeRestart("muffleMessage")
[10:59:31.854]                       }
[10:59:31.854]                       else if (inherits(cond, "warning")) {
[10:59:31.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.854]                         if (muffled) 
[10:59:31.854]                           invokeRestart("muffleWarning")
[10:59:31.854]                       }
[10:59:31.854]                       else if (inherits(cond, "condition")) {
[10:59:31.854]                         if (!is.null(pattern)) {
[10:59:31.854]                           computeRestarts <- base::computeRestarts
[10:59:31.854]                           grepl <- base::grepl
[10:59:31.854]                           restarts <- computeRestarts(cond)
[10:59:31.854]                           for (restart in restarts) {
[10:59:31.854]                             name <- restart$name
[10:59:31.854]                             if (is.null(name)) 
[10:59:31.854]                               next
[10:59:31.854]                             if (!grepl(pattern, name)) 
[10:59:31.854]                               next
[10:59:31.854]                             invokeRestart(restart)
[10:59:31.854]                             muffled <- TRUE
[10:59:31.854]                             break
[10:59:31.854]                           }
[10:59:31.854]                         }
[10:59:31.854]                       }
[10:59:31.854]                       invisible(muffled)
[10:59:31.854]                     }
[10:59:31.854]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.854]                   }
[10:59:31.854]                 }
[10:59:31.854]             }
[10:59:31.854]         }))
[10:59:31.854]     }, error = function(ex) {
[10:59:31.854]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.854]                 ...future.rng), started = ...future.startTime, 
[10:59:31.854]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.854]             version = "1.8"), class = "FutureResult")
[10:59:31.854]     }, finally = {
[10:59:31.854]         if (!identical(...future.workdir, getwd())) 
[10:59:31.854]             setwd(...future.workdir)
[10:59:31.854]         {
[10:59:31.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.854]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.854]             }
[10:59:31.854]             base::options(...future.oldOptions)
[10:59:31.854]             if (.Platform$OS.type == "windows") {
[10:59:31.854]                 old_names <- names(...future.oldEnvVars)
[10:59:31.854]                 envs <- base::Sys.getenv()
[10:59:31.854]                 names <- names(envs)
[10:59:31.854]                 common <- intersect(names, old_names)
[10:59:31.854]                 added <- setdiff(names, old_names)
[10:59:31.854]                 removed <- setdiff(old_names, names)
[10:59:31.854]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.854]                   envs[common]]
[10:59:31.854]                 NAMES <- toupper(changed)
[10:59:31.854]                 args <- list()
[10:59:31.854]                 for (kk in seq_along(NAMES)) {
[10:59:31.854]                   name <- changed[[kk]]
[10:59:31.854]                   NAME <- NAMES[[kk]]
[10:59:31.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.854]                     next
[10:59:31.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.854]                 }
[10:59:31.854]                 NAMES <- toupper(added)
[10:59:31.854]                 for (kk in seq_along(NAMES)) {
[10:59:31.854]                   name <- added[[kk]]
[10:59:31.854]                   NAME <- NAMES[[kk]]
[10:59:31.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.854]                     next
[10:59:31.854]                   args[[name]] <- ""
[10:59:31.854]                 }
[10:59:31.854]                 NAMES <- toupper(removed)
[10:59:31.854]                 for (kk in seq_along(NAMES)) {
[10:59:31.854]                   name <- removed[[kk]]
[10:59:31.854]                   NAME <- NAMES[[kk]]
[10:59:31.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.854]                     next
[10:59:31.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.854]                 }
[10:59:31.854]                 if (length(args) > 0) 
[10:59:31.854]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.854]             }
[10:59:31.854]             else {
[10:59:31.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.854]             }
[10:59:31.854]             {
[10:59:31.854]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.854]                   0L) {
[10:59:31.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.854]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.854]                   base::options(opts)
[10:59:31.854]                 }
[10:59:31.854]                 {
[10:59:31.854]                   {
[10:59:31.854]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:31.854]                     NULL
[10:59:31.854]                   }
[10:59:31.854]                   options(future.plan = NULL)
[10:59:31.854]                   if (is.na(NA_character_)) 
[10:59:31.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.854]                     .init = FALSE)
[10:59:31.854]                 }
[10:59:31.854]             }
[10:59:31.854]         }
[10:59:31.854]     })
[10:59:31.854]     if (TRUE) {
[10:59:31.854]         base::sink(type = "output", split = FALSE)
[10:59:31.854]         if (TRUE) {
[10:59:31.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.854]         }
[10:59:31.854]         else {
[10:59:31.854]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.854]         }
[10:59:31.854]         base::close(...future.stdout)
[10:59:31.854]         ...future.stdout <- NULL
[10:59:31.854]     }
[10:59:31.854]     ...future.result$conditions <- ...future.conditions
[10:59:31.854]     ...future.result$finished <- base::Sys.time()
[10:59:31.854]     ...future.result
[10:59:31.854] }
[10:59:31.856] assign_globals() ...
[10:59:31.857] List of 5
[10:59:31.857]  $ ...future.FUN            :function (x, ...)  
[10:59:31.857]  $ MoreArgs                 : NULL
[10:59:31.857]  $ ...future.elements_ii    :List of 2
[10:59:31.857]   ..$ :List of 2
[10:59:31.857]   .. ..$ : int 1
[10:59:31.857]   .. ..$ : int 2
[10:59:31.857]   ..$ :List of 2
[10:59:31.857]   .. ..$ : int 4
[10:59:31.857]   .. ..$ : int 3
[10:59:31.857]  $ ...future.seeds_ii       : NULL
[10:59:31.857]  $ ...future.globals.maxSize: NULL
[10:59:31.857]  - attr(*, "where")=List of 5
[10:59:31.857]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.857]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.857]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.857]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.857]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.857]  - attr(*, "resolved")= logi FALSE
[10:59:31.857]  - attr(*, "total_size")= num 210
[10:59:31.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.857]  - attr(*, "already-done")= logi TRUE
[10:59:31.863] - copied ‘...future.FUN’ to environment
[10:59:31.863] - copied ‘MoreArgs’ to environment
[10:59:31.863] - copied ‘...future.elements_ii’ to environment
[10:59:31.864] - copied ‘...future.seeds_ii’ to environment
[10:59:31.864] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.864] assign_globals() ... done
[10:59:31.864] requestCore(): workers = 2
[10:59:31.866] MulticoreFuture started
[10:59:31.866] - Launch lazy future ... done
[10:59:31.866] run() for ‘MulticoreFuture’ ... done
[10:59:31.867] Created future:
[10:59:31.867] plan(): Setting new future strategy stack:
[10:59:31.867] List of future strategies:
[10:59:31.867] 1. sequential:
[10:59:31.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.867]    - tweaked: FALSE
[10:59:31.867]    - call: NULL
[10:59:31.868] plan(): nbrOfWorkers() = 1
[10:59:31.870] plan(): Setting new future strategy stack:
[10:59:31.870] List of future strategies:
[10:59:31.870] 1. multicore:
[10:59:31.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:31.870]    - tweaked: FALSE
[10:59:31.870]    - call: plan(strategy)
[10:59:31.873] plan(): nbrOfWorkers() = 2
[10:59:31.867] MulticoreFuture:
[10:59:31.867] Label: ‘future_mapply-1’
[10:59:31.867] Expression:
[10:59:31.867] {
[10:59:31.867]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.867]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.867]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.867]         on.exit(options(oopts), add = TRUE)
[10:59:31.867]     }
[10:59:31.867]     {
[10:59:31.867]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.867]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.867]         do.call(mapply, args = args)
[10:59:31.867]     }
[10:59:31.867] }
[10:59:31.867] Lazy evaluation: FALSE
[10:59:31.867] Asynchronous evaluation: TRUE
[10:59:31.867] Local evaluation: TRUE
[10:59:31.867] Environment: R_GlobalEnv
[10:59:31.867] Capture standard output: TRUE
[10:59:31.867] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.867] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.867] Packages: <none>
[10:59:31.867] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.867] Resolved: TRUE
[10:59:31.867] Value: <not collected>
[10:59:31.867] Conditions captured: <none>
[10:59:31.867] Early signaling: FALSE
[10:59:31.867] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.867] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.874] Chunk #1 of 2 ... DONE
[10:59:31.875] Chunk #2 of 2 ...
[10:59:31.875]  - Finding globals in '...' for chunk #2 ...
[10:59:31.875] getGlobalsAndPackages() ...
[10:59:31.875] Searching for globals...
[10:59:31.876] 
[10:59:31.876] Searching for globals ... DONE
[10:59:31.876] - globals: [0] <none>
[10:59:31.876] getGlobalsAndPackages() ... DONE
[10:59:31.876]    + additional globals found: [n=0] 
[10:59:31.876]    + additional namespaces needed: [n=0] 
[10:59:31.876]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:31.876]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.877]  - seeds: <none>
[10:59:31.877]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.877] getGlobalsAndPackages() ...
[10:59:31.877] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.877] Resolving globals: FALSE
[10:59:31.878] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:31.879] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.879] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.879] 
[10:59:31.879] getGlobalsAndPackages() ... DONE
[10:59:31.880] run() for ‘Future’ ...
[10:59:31.880] - state: ‘created’
[10:59:31.880] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:31.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:31.883]   - Field: ‘label’
[10:59:31.883]   - Field: ‘local’
[10:59:31.883]   - Field: ‘owner’
[10:59:31.883]   - Field: ‘envir’
[10:59:31.883]   - Field: ‘workers’
[10:59:31.884]   - Field: ‘packages’
[10:59:31.884]   - Field: ‘gc’
[10:59:31.884]   - Field: ‘job’
[10:59:31.884]   - Field: ‘conditions’
[10:59:31.884]   - Field: ‘expr’
[10:59:31.884]   - Field: ‘uuid’
[10:59:31.884]   - Field: ‘seed’
[10:59:31.884]   - Field: ‘version’
[10:59:31.885]   - Field: ‘result’
[10:59:31.885]   - Field: ‘asynchronous’
[10:59:31.885]   - Field: ‘calls’
[10:59:31.885]   - Field: ‘globals’
[10:59:31.885]   - Field: ‘stdout’
[10:59:31.885]   - Field: ‘earlySignal’
[10:59:31.886]   - Field: ‘lazy’
[10:59:31.886]   - Field: ‘state’
[10:59:31.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:31.886] - Launch lazy future ...
[10:59:31.886] Packages needed by the future expression (n = 0): <none>
[10:59:31.886] Packages needed by future strategies (n = 0): <none>
[10:59:31.887] {
[10:59:31.887]     {
[10:59:31.887]         {
[10:59:31.887]             ...future.startTime <- base::Sys.time()
[10:59:31.887]             {
[10:59:31.887]                 {
[10:59:31.887]                   {
[10:59:31.887]                     {
[10:59:31.887]                       base::local({
[10:59:31.887]                         has_future <- base::requireNamespace("future", 
[10:59:31.887]                           quietly = TRUE)
[10:59:31.887]                         if (has_future) {
[10:59:31.887]                           ns <- base::getNamespace("future")
[10:59:31.887]                           version <- ns[[".package"]][["version"]]
[10:59:31.887]                           if (is.null(version)) 
[10:59:31.887]                             version <- utils::packageVersion("future")
[10:59:31.887]                         }
[10:59:31.887]                         else {
[10:59:31.887]                           version <- NULL
[10:59:31.887]                         }
[10:59:31.887]                         if (!has_future || version < "1.8.0") {
[10:59:31.887]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.887]                             "", base::R.version$version.string), 
[10:59:31.887]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.887]                               "release", "version")], collapse = " "), 
[10:59:31.887]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.887]                             info)
[10:59:31.887]                           info <- base::paste(info, collapse = "; ")
[10:59:31.887]                           if (!has_future) {
[10:59:31.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.887]                               info)
[10:59:31.887]                           }
[10:59:31.887]                           else {
[10:59:31.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.887]                               info, version)
[10:59:31.887]                           }
[10:59:31.887]                           base::stop(msg)
[10:59:31.887]                         }
[10:59:31.887]                       })
[10:59:31.887]                     }
[10:59:31.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:31.887]                     base::options(mc.cores = 1L)
[10:59:31.887]                   }
[10:59:31.887]                   ...future.strategy.old <- future::plan("list")
[10:59:31.887]                   options(future.plan = NULL)
[10:59:31.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.887]                 }
[10:59:31.887]                 ...future.workdir <- getwd()
[10:59:31.887]             }
[10:59:31.887]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.887]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.887]         }
[10:59:31.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.887]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.887]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.887]             base::names(...future.oldOptions))
[10:59:31.887]     }
[10:59:31.887]     if (FALSE) {
[10:59:31.887]     }
[10:59:31.887]     else {
[10:59:31.887]         if (TRUE) {
[10:59:31.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.887]                 open = "w")
[10:59:31.887]         }
[10:59:31.887]         else {
[10:59:31.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.887]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.887]         }
[10:59:31.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.887]             base::sink(type = "output", split = FALSE)
[10:59:31.887]             base::close(...future.stdout)
[10:59:31.887]         }, add = TRUE)
[10:59:31.887]     }
[10:59:31.887]     ...future.frame <- base::sys.nframe()
[10:59:31.887]     ...future.conditions <- base::list()
[10:59:31.887]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.887]     if (FALSE) {
[10:59:31.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.887]     }
[10:59:31.887]     ...future.result <- base::tryCatch({
[10:59:31.887]         base::withCallingHandlers({
[10:59:31.887]             ...future.value <- base::withVisible(base::local({
[10:59:31.887]                 withCallingHandlers({
[10:59:31.887]                   {
[10:59:31.887]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.887]                     if (!identical(...future.globals.maxSize.org, 
[10:59:31.887]                       ...future.globals.maxSize)) {
[10:59:31.887]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.887]                       on.exit(options(oopts), add = TRUE)
[10:59:31.887]                     }
[10:59:31.887]                     {
[10:59:31.887]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.887]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.887]                         USE.NAMES = FALSE)
[10:59:31.887]                       do.call(mapply, args = args)
[10:59:31.887]                     }
[10:59:31.887]                   }
[10:59:31.887]                 }, immediateCondition = function(cond) {
[10:59:31.887]                   save_rds <- function (object, pathname, ...) 
[10:59:31.887]                   {
[10:59:31.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:31.887]                     if (file_test("-f", pathname_tmp)) {
[10:59:31.887]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:31.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.887]                         fi_tmp[["mtime"]])
[10:59:31.887]                     }
[10:59:31.887]                     tryCatch({
[10:59:31.887]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:31.887]                     }, error = function(ex) {
[10:59:31.887]                       msg <- conditionMessage(ex)
[10:59:31.887]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:31.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.887]                         fi_tmp[["mtime"]], msg)
[10:59:31.887]                       ex$message <- msg
[10:59:31.887]                       stop(ex)
[10:59:31.887]                     })
[10:59:31.887]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:31.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:31.887]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:31.887]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.887]                       fi <- file.info(pathname)
[10:59:31.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:31.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:31.887]                         fi[["size"]], fi[["mtime"]])
[10:59:31.887]                       stop(msg)
[10:59:31.887]                     }
[10:59:31.887]                     invisible(pathname)
[10:59:31.887]                   }
[10:59:31.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:31.887]                     rootPath = tempdir()) 
[10:59:31.887]                   {
[10:59:31.887]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:31.887]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:31.887]                       tmpdir = path, fileext = ".rds")
[10:59:31.887]                     save_rds(obj, file)
[10:59:31.887]                   }
[10:59:31.887]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:31.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.887]                   {
[10:59:31.887]                     inherits <- base::inherits
[10:59:31.887]                     invokeRestart <- base::invokeRestart
[10:59:31.887]                     is.null <- base::is.null
[10:59:31.887]                     muffled <- FALSE
[10:59:31.887]                     if (inherits(cond, "message")) {
[10:59:31.887]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:31.887]                       if (muffled) 
[10:59:31.887]                         invokeRestart("muffleMessage")
[10:59:31.887]                     }
[10:59:31.887]                     else if (inherits(cond, "warning")) {
[10:59:31.887]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:31.887]                       if (muffled) 
[10:59:31.887]                         invokeRestart("muffleWarning")
[10:59:31.887]                     }
[10:59:31.887]                     else if (inherits(cond, "condition")) {
[10:59:31.887]                       if (!is.null(pattern)) {
[10:59:31.887]                         computeRestarts <- base::computeRestarts
[10:59:31.887]                         grepl <- base::grepl
[10:59:31.887]                         restarts <- computeRestarts(cond)
[10:59:31.887]                         for (restart in restarts) {
[10:59:31.887]                           name <- restart$name
[10:59:31.887]                           if (is.null(name)) 
[10:59:31.887]                             next
[10:59:31.887]                           if (!grepl(pattern, name)) 
[10:59:31.887]                             next
[10:59:31.887]                           invokeRestart(restart)
[10:59:31.887]                           muffled <- TRUE
[10:59:31.887]                           break
[10:59:31.887]                         }
[10:59:31.887]                       }
[10:59:31.887]                     }
[10:59:31.887]                     invisible(muffled)
[10:59:31.887]                   }
[10:59:31.887]                   muffleCondition(cond)
[10:59:31.887]                 })
[10:59:31.887]             }))
[10:59:31.887]             future::FutureResult(value = ...future.value$value, 
[10:59:31.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.887]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.887]                     ...future.globalenv.names))
[10:59:31.887]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.887]         }, condition = base::local({
[10:59:31.887]             c <- base::c
[10:59:31.887]             inherits <- base::inherits
[10:59:31.887]             invokeRestart <- base::invokeRestart
[10:59:31.887]             length <- base::length
[10:59:31.887]             list <- base::list
[10:59:31.887]             seq.int <- base::seq.int
[10:59:31.887]             signalCondition <- base::signalCondition
[10:59:31.887]             sys.calls <- base::sys.calls
[10:59:31.887]             `[[` <- base::`[[`
[10:59:31.887]             `+` <- base::`+`
[10:59:31.887]             `<<-` <- base::`<<-`
[10:59:31.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.887]                   3L)]
[10:59:31.887]             }
[10:59:31.887]             function(cond) {
[10:59:31.887]                 is_error <- inherits(cond, "error")
[10:59:31.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.887]                   NULL)
[10:59:31.887]                 if (is_error) {
[10:59:31.887]                   sessionInformation <- function() {
[10:59:31.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.887]                       search = base::search(), system = base::Sys.info())
[10:59:31.887]                   }
[10:59:31.887]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.887]                     cond$call), session = sessionInformation(), 
[10:59:31.887]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.887]                   signalCondition(cond)
[10:59:31.887]                 }
[10:59:31.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.887]                 "immediateCondition"))) {
[10:59:31.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.887]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.887]                   if (TRUE && !signal) {
[10:59:31.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.887]                     {
[10:59:31.887]                       inherits <- base::inherits
[10:59:31.887]                       invokeRestart <- base::invokeRestart
[10:59:31.887]                       is.null <- base::is.null
[10:59:31.887]                       muffled <- FALSE
[10:59:31.887]                       if (inherits(cond, "message")) {
[10:59:31.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.887]                         if (muffled) 
[10:59:31.887]                           invokeRestart("muffleMessage")
[10:59:31.887]                       }
[10:59:31.887]                       else if (inherits(cond, "warning")) {
[10:59:31.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.887]                         if (muffled) 
[10:59:31.887]                           invokeRestart("muffleWarning")
[10:59:31.887]                       }
[10:59:31.887]                       else if (inherits(cond, "condition")) {
[10:59:31.887]                         if (!is.null(pattern)) {
[10:59:31.887]                           computeRestarts <- base::computeRestarts
[10:59:31.887]                           grepl <- base::grepl
[10:59:31.887]                           restarts <- computeRestarts(cond)
[10:59:31.887]                           for (restart in restarts) {
[10:59:31.887]                             name <- restart$name
[10:59:31.887]                             if (is.null(name)) 
[10:59:31.887]                               next
[10:59:31.887]                             if (!grepl(pattern, name)) 
[10:59:31.887]                               next
[10:59:31.887]                             invokeRestart(restart)
[10:59:31.887]                             muffled <- TRUE
[10:59:31.887]                             break
[10:59:31.887]                           }
[10:59:31.887]                         }
[10:59:31.887]                       }
[10:59:31.887]                       invisible(muffled)
[10:59:31.887]                     }
[10:59:31.887]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.887]                   }
[10:59:31.887]                 }
[10:59:31.887]                 else {
[10:59:31.887]                   if (TRUE) {
[10:59:31.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.887]                     {
[10:59:31.887]                       inherits <- base::inherits
[10:59:31.887]                       invokeRestart <- base::invokeRestart
[10:59:31.887]                       is.null <- base::is.null
[10:59:31.887]                       muffled <- FALSE
[10:59:31.887]                       if (inherits(cond, "message")) {
[10:59:31.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.887]                         if (muffled) 
[10:59:31.887]                           invokeRestart("muffleMessage")
[10:59:31.887]                       }
[10:59:31.887]                       else if (inherits(cond, "warning")) {
[10:59:31.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.887]                         if (muffled) 
[10:59:31.887]                           invokeRestart("muffleWarning")
[10:59:31.887]                       }
[10:59:31.887]                       else if (inherits(cond, "condition")) {
[10:59:31.887]                         if (!is.null(pattern)) {
[10:59:31.887]                           computeRestarts <- base::computeRestarts
[10:59:31.887]                           grepl <- base::grepl
[10:59:31.887]                           restarts <- computeRestarts(cond)
[10:59:31.887]                           for (restart in restarts) {
[10:59:31.887]                             name <- restart$name
[10:59:31.887]                             if (is.null(name)) 
[10:59:31.887]                               next
[10:59:31.887]                             if (!grepl(pattern, name)) 
[10:59:31.887]                               next
[10:59:31.887]                             invokeRestart(restart)
[10:59:31.887]                             muffled <- TRUE
[10:59:31.887]                             break
[10:59:31.887]                           }
[10:59:31.887]                         }
[10:59:31.887]                       }
[10:59:31.887]                       invisible(muffled)
[10:59:31.887]                     }
[10:59:31.887]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.887]                   }
[10:59:31.887]                 }
[10:59:31.887]             }
[10:59:31.887]         }))
[10:59:31.887]     }, error = function(ex) {
[10:59:31.887]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.887]                 ...future.rng), started = ...future.startTime, 
[10:59:31.887]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.887]             version = "1.8"), class = "FutureResult")
[10:59:31.887]     }, finally = {
[10:59:31.887]         if (!identical(...future.workdir, getwd())) 
[10:59:31.887]             setwd(...future.workdir)
[10:59:31.887]         {
[10:59:31.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.887]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.887]             }
[10:59:31.887]             base::options(...future.oldOptions)
[10:59:31.887]             if (.Platform$OS.type == "windows") {
[10:59:31.887]                 old_names <- names(...future.oldEnvVars)
[10:59:31.887]                 envs <- base::Sys.getenv()
[10:59:31.887]                 names <- names(envs)
[10:59:31.887]                 common <- intersect(names, old_names)
[10:59:31.887]                 added <- setdiff(names, old_names)
[10:59:31.887]                 removed <- setdiff(old_names, names)
[10:59:31.887]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.887]                   envs[common]]
[10:59:31.887]                 NAMES <- toupper(changed)
[10:59:31.887]                 args <- list()
[10:59:31.887]                 for (kk in seq_along(NAMES)) {
[10:59:31.887]                   name <- changed[[kk]]
[10:59:31.887]                   NAME <- NAMES[[kk]]
[10:59:31.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.887]                     next
[10:59:31.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.887]                 }
[10:59:31.887]                 NAMES <- toupper(added)
[10:59:31.887]                 for (kk in seq_along(NAMES)) {
[10:59:31.887]                   name <- added[[kk]]
[10:59:31.887]                   NAME <- NAMES[[kk]]
[10:59:31.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.887]                     next
[10:59:31.887]                   args[[name]] <- ""
[10:59:31.887]                 }
[10:59:31.887]                 NAMES <- toupper(removed)
[10:59:31.887]                 for (kk in seq_along(NAMES)) {
[10:59:31.887]                   name <- removed[[kk]]
[10:59:31.887]                   NAME <- NAMES[[kk]]
[10:59:31.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.887]                     next
[10:59:31.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.887]                 }
[10:59:31.887]                 if (length(args) > 0) 
[10:59:31.887]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.887]             }
[10:59:31.887]             else {
[10:59:31.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.887]             }
[10:59:31.887]             {
[10:59:31.887]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.887]                   0L) {
[10:59:31.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.887]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.887]                   base::options(opts)
[10:59:31.887]                 }
[10:59:31.887]                 {
[10:59:31.887]                   {
[10:59:31.887]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:31.887]                     NULL
[10:59:31.887]                   }
[10:59:31.887]                   options(future.plan = NULL)
[10:59:31.887]                   if (is.na(NA_character_)) 
[10:59:31.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.887]                     .init = FALSE)
[10:59:31.887]                 }
[10:59:31.887]             }
[10:59:31.887]         }
[10:59:31.887]     })
[10:59:31.887]     if (TRUE) {
[10:59:31.887]         base::sink(type = "output", split = FALSE)
[10:59:31.887]         if (TRUE) {
[10:59:31.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.887]         }
[10:59:31.887]         else {
[10:59:31.887]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.887]         }
[10:59:31.887]         base::close(...future.stdout)
[10:59:31.887]         ...future.stdout <- NULL
[10:59:31.887]     }
[10:59:31.887]     ...future.result$conditions <- ...future.conditions
[10:59:31.887]     ...future.result$finished <- base::Sys.time()
[10:59:31.887]     ...future.result
[10:59:31.887] }
[10:59:31.891] assign_globals() ...
[10:59:31.891] List of 5
[10:59:31.891]  $ ...future.FUN            :function (x, ...)  
[10:59:31.891]  $ MoreArgs                 : NULL
[10:59:31.891]  $ ...future.elements_ii    :List of 2
[10:59:31.891]   ..$ :List of 2
[10:59:31.891]   .. ..$ : int 3
[10:59:31.891]   .. ..$ : int 4
[10:59:31.891]   ..$ :List of 2
[10:59:31.891]   .. ..$ : int 2
[10:59:31.891]   .. ..$ : int 1
[10:59:31.891]  $ ...future.seeds_ii       : NULL
[10:59:31.891]  $ ...future.globals.maxSize: NULL
[10:59:31.891]  - attr(*, "where")=List of 5
[10:59:31.891]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.891]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.891]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.891]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.891]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.891]  - attr(*, "resolved")= logi FALSE
[10:59:31.891]  - attr(*, "total_size")= num 210
[10:59:31.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.891]  - attr(*, "already-done")= logi TRUE
[10:59:31.902] - copied ‘...future.FUN’ to environment
[10:59:31.902] - copied ‘MoreArgs’ to environment
[10:59:31.902] - copied ‘...future.elements_ii’ to environment
[10:59:31.903] - copied ‘...future.seeds_ii’ to environment
[10:59:31.903] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.903] assign_globals() ... done
[10:59:31.903] requestCore(): workers = 2
[10:59:31.906] MulticoreFuture started
[10:59:31.906] - Launch lazy future ... done
[10:59:31.907] plan(): Setting new future strategy stack:
[10:59:31.907] run() for ‘MulticoreFuture’ ... done
[10:59:31.908] Created future:
[10:59:31.907] List of future strategies:
[10:59:31.907] 1. sequential:
[10:59:31.907]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.907]    - tweaked: FALSE
[10:59:31.907]    - call: NULL
[10:59:31.909] plan(): nbrOfWorkers() = 1
[10:59:31.912] plan(): Setting new future strategy stack:
[10:59:31.912] List of future strategies:
[10:59:31.912] 1. multicore:
[10:59:31.912]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:31.912]    - tweaked: FALSE
[10:59:31.912]    - call: plan(strategy)
[10:59:31.916] plan(): nbrOfWorkers() = 2
[10:59:31.908] MulticoreFuture:
[10:59:31.908] Label: ‘future_mapply-2’
[10:59:31.908] Expression:
[10:59:31.908] {
[10:59:31.908]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.908]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.908]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.908]         on.exit(options(oopts), add = TRUE)
[10:59:31.908]     }
[10:59:31.908]     {
[10:59:31.908]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.908]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.908]         do.call(mapply, args = args)
[10:59:31.908]     }
[10:59:31.908] }
[10:59:31.908] Lazy evaluation: FALSE
[10:59:31.908] Asynchronous evaluation: TRUE
[10:59:31.908] Local evaluation: TRUE
[10:59:31.908] Environment: R_GlobalEnv
[10:59:31.908] Capture standard output: TRUE
[10:59:31.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.908] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.908] Packages: <none>
[10:59:31.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.908] Resolved: TRUE
[10:59:31.908] Value: <not collected>
[10:59:31.908] Conditions captured: <none>
[10:59:31.908] Early signaling: FALSE
[10:59:31.908] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.908] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.917] Chunk #2 of 2 ... DONE
[10:59:31.917] Launching 2 futures (chunks) ... DONE
[10:59:31.917] Resolving 2 futures (chunks) ...
[10:59:31.917] resolve() on list ...
[10:59:31.917]  recursive: 0
[10:59:31.917]  length: 2
[10:59:31.918] 
[10:59:31.918] Future #1
[10:59:31.918] result() for MulticoreFuture ...
[10:59:31.919] result() for MulticoreFuture ...
[10:59:31.919] result() for MulticoreFuture ... done
[10:59:31.919] result() for MulticoreFuture ... done
[10:59:31.920] result() for MulticoreFuture ...
[10:59:31.920] result() for MulticoreFuture ... done
[10:59:31.920] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:31.920] - nx: 2
[10:59:31.920] - relay: TRUE
[10:59:31.920] - stdout: TRUE
[10:59:31.921] - signal: TRUE
[10:59:31.921] - resignal: FALSE
[10:59:31.921] - force: TRUE
[10:59:31.921] - relayed: [n=2] FALSE, FALSE
[10:59:31.921] - queued futures: [n=2] FALSE, FALSE
[10:59:31.921]  - until=1
[10:59:31.922]  - relaying element #1
[10:59:31.922] result() for MulticoreFuture ...
[10:59:31.922] result() for MulticoreFuture ... done
[10:59:31.922] result() for MulticoreFuture ...
[10:59:31.922] result() for MulticoreFuture ... done
[10:59:31.922] result() for MulticoreFuture ...
[10:59:31.923] result() for MulticoreFuture ... done
[10:59:31.923] result() for MulticoreFuture ...
[10:59:31.923] result() for MulticoreFuture ... done
[10:59:31.923] - relayed: [n=2] TRUE, FALSE
[10:59:31.923] - queued futures: [n=2] TRUE, FALSE
[10:59:31.923] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:31.923]  length: 1 (resolved future 1)
[10:59:31.924] Future #2
[10:59:31.924] result() for MulticoreFuture ...
[10:59:31.925] result() for MulticoreFuture ...
[10:59:31.925] result() for MulticoreFuture ... done
[10:59:31.925] result() for MulticoreFuture ... done
[10:59:31.925] result() for MulticoreFuture ...
[10:59:31.925] result() for MulticoreFuture ... done
[10:59:31.925] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:31.925] - nx: 2
[10:59:31.925] - relay: TRUE
[10:59:31.926] - stdout: TRUE
[10:59:31.926] - signal: TRUE
[10:59:31.926] - resignal: FALSE
[10:59:31.926] - force: TRUE
[10:59:31.926] - relayed: [n=2] TRUE, FALSE
[10:59:31.926] - queued futures: [n=2] TRUE, FALSE
[10:59:31.926]  - until=2
[10:59:31.926]  - relaying element #2
[10:59:31.926] result() for MulticoreFuture ...
[10:59:31.926] result() for MulticoreFuture ... done
[10:59:31.927] result() for MulticoreFuture ...
[10:59:31.927] result() for MulticoreFuture ... done
[10:59:31.927] result() for MulticoreFuture ...
[10:59:31.927] result() for MulticoreFuture ... done
[10:59:31.927] result() for MulticoreFuture ...
[10:59:31.927] result() for MulticoreFuture ... done
[10:59:31.927] - relayed: [n=2] TRUE, TRUE
[10:59:31.927] - queued futures: [n=2] TRUE, TRUE
[10:59:31.927] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:31.928]  length: 0 (resolved future 2)
[10:59:31.928] Relaying remaining futures
[10:59:31.928] signalConditionsASAP(NULL, pos=0) ...
[10:59:31.928] - nx: 2
[10:59:31.928] - relay: TRUE
[10:59:31.928] - stdout: TRUE
[10:59:31.928] - signal: TRUE
[10:59:31.928] - resignal: FALSE
[10:59:31.928] - force: TRUE
[10:59:31.928] - relayed: [n=2] TRUE, TRUE
[10:59:31.929] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:31.929] - relayed: [n=2] TRUE, TRUE
[10:59:31.929] - queued futures: [n=2] TRUE, TRUE
[10:59:31.929] signalConditionsASAP(NULL, pos=0) ... done
[10:59:31.929] resolve() on list ... DONE
[10:59:31.929] result() for MulticoreFuture ...
[10:59:31.929] result() for MulticoreFuture ... done
[10:59:31.929] result() for MulticoreFuture ...
[10:59:31.930] result() for MulticoreFuture ... done
[10:59:31.930] result() for MulticoreFuture ...
[10:59:31.930] result() for MulticoreFuture ... done
[10:59:31.930] result() for MulticoreFuture ...
[10:59:31.930] result() for MulticoreFuture ... done
[10:59:31.930]  - Number of value chunks collected: 2
[10:59:31.930] Resolving 2 futures (chunks) ... DONE
[10:59:31.930] Reducing values from 2 chunks ...
[10:59:31.930]  - Number of values collected after concatenation: 4
[10:59:31.930]  - Number of values expected: 4
[10:59:31.931] Reducing values from 2 chunks ... DONE
[10:59:31.931] future_mapply() ... DONE
[10:59:31.931] future_mapply() ...
[10:59:31.933] Number of chunks: 2
[10:59:31.933] getGlobalsAndPackagesXApply() ...
[10:59:31.933]  - future.globals: TRUE
[10:59:31.933] getGlobalsAndPackages() ...
[10:59:31.933] Searching for globals...
[10:59:31.934] - globals found: [1] ‘FUN’
[10:59:31.934] Searching for globals ... DONE
[10:59:31.934] Resolving globals: FALSE
[10:59:31.935] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:31.935] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:31.935] - globals: [1] ‘FUN’
[10:59:31.935] 
[10:59:31.935] getGlobalsAndPackages() ... DONE
[10:59:31.936]  - globals found/used: [n=1] ‘FUN’
[10:59:31.936]  - needed namespaces: [n=0] 
[10:59:31.936] Finding globals ... DONE
[10:59:31.936] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:31.936] List of 2
[10:59:31.936]  $ ...future.FUN:function (x, ...)  
[10:59:31.936]  $ MoreArgs     : NULL
[10:59:31.936]  - attr(*, "where")=List of 2
[10:59:31.936]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:31.936]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:31.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.936]  - attr(*, "resolved")= logi FALSE
[10:59:31.936]  - attr(*, "total_size")= num NA
[10:59:31.941] Packages to be attached in all futures: [n=0] 
[10:59:31.941] getGlobalsAndPackagesXApply() ... DONE
[10:59:31.941] Number of futures (= number of chunks): 2
[10:59:31.941] Launching 2 futures (chunks) ...
[10:59:31.941] Chunk #1 of 2 ...
[10:59:31.942]  - Finding globals in '...' for chunk #1 ...
[10:59:31.942] getGlobalsAndPackages() ...
[10:59:31.942] Searching for globals...
[10:59:31.942] 
[10:59:31.942] Searching for globals ... DONE
[10:59:31.942] - globals: [0] <none>
[10:59:31.942] getGlobalsAndPackages() ... DONE
[10:59:31.943]    + additional globals found: [n=0] 
[10:59:31.943]    + additional namespaces needed: [n=0] 
[10:59:31.943]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:31.943]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.943]  - seeds: <none>
[10:59:31.943]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.943] getGlobalsAndPackages() ...
[10:59:31.943] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.944] Resolving globals: FALSE
[10:59:31.944] The total size of the 5 globals is 265 bytes (265 bytes)
[10:59:31.945] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.945] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.945] 
[10:59:31.945] getGlobalsAndPackages() ... DONE
[10:59:31.945] run() for ‘Future’ ...
[10:59:31.945] - state: ‘created’
[10:59:31.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:31.947] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:31.947]   - Field: ‘label’
[10:59:31.947]   - Field: ‘local’
[10:59:31.947]   - Field: ‘owner’
[10:59:31.948]   - Field: ‘envir’
[10:59:31.948]   - Field: ‘workers’
[10:59:31.948]   - Field: ‘packages’
[10:59:31.948]   - Field: ‘gc’
[10:59:31.948]   - Field: ‘job’
[10:59:31.948]   - Field: ‘conditions’
[10:59:31.948]   - Field: ‘expr’
[10:59:31.948]   - Field: ‘uuid’
[10:59:31.948]   - Field: ‘seed’
[10:59:31.948]   - Field: ‘version’
[10:59:31.948]   - Field: ‘result’
[10:59:31.948]   - Field: ‘asynchronous’
[10:59:31.949]   - Field: ‘calls’
[10:59:31.949]   - Field: ‘globals’
[10:59:31.949]   - Field: ‘stdout’
[10:59:31.949]   - Field: ‘earlySignal’
[10:59:31.949]   - Field: ‘lazy’
[10:59:31.949]   - Field: ‘state’
[10:59:31.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:31.949] - Launch lazy future ...
[10:59:31.949] Packages needed by the future expression (n = 0): <none>
[10:59:31.949] Packages needed by future strategies (n = 0): <none>
[10:59:31.950] {
[10:59:31.950]     {
[10:59:31.950]         {
[10:59:31.950]             ...future.startTime <- base::Sys.time()
[10:59:31.950]             {
[10:59:31.950]                 {
[10:59:31.950]                   {
[10:59:31.950]                     {
[10:59:31.950]                       base::local({
[10:59:31.950]                         has_future <- base::requireNamespace("future", 
[10:59:31.950]                           quietly = TRUE)
[10:59:31.950]                         if (has_future) {
[10:59:31.950]                           ns <- base::getNamespace("future")
[10:59:31.950]                           version <- ns[[".package"]][["version"]]
[10:59:31.950]                           if (is.null(version)) 
[10:59:31.950]                             version <- utils::packageVersion("future")
[10:59:31.950]                         }
[10:59:31.950]                         else {
[10:59:31.950]                           version <- NULL
[10:59:31.950]                         }
[10:59:31.950]                         if (!has_future || version < "1.8.0") {
[10:59:31.950]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.950]                             "", base::R.version$version.string), 
[10:59:31.950]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.950]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.950]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.950]                               "release", "version")], collapse = " "), 
[10:59:31.950]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.950]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.950]                             info)
[10:59:31.950]                           info <- base::paste(info, collapse = "; ")
[10:59:31.950]                           if (!has_future) {
[10:59:31.950]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.950]                               info)
[10:59:31.950]                           }
[10:59:31.950]                           else {
[10:59:31.950]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.950]                               info, version)
[10:59:31.950]                           }
[10:59:31.950]                           base::stop(msg)
[10:59:31.950]                         }
[10:59:31.950]                       })
[10:59:31.950]                     }
[10:59:31.950]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:31.950]                     base::options(mc.cores = 1L)
[10:59:31.950]                   }
[10:59:31.950]                   ...future.strategy.old <- future::plan("list")
[10:59:31.950]                   options(future.plan = NULL)
[10:59:31.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.950]                 }
[10:59:31.950]                 ...future.workdir <- getwd()
[10:59:31.950]             }
[10:59:31.950]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.950]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.950]         }
[10:59:31.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.950]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.950]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.950]             base::names(...future.oldOptions))
[10:59:31.950]     }
[10:59:31.950]     if (FALSE) {
[10:59:31.950]     }
[10:59:31.950]     else {
[10:59:31.950]         if (TRUE) {
[10:59:31.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.950]                 open = "w")
[10:59:31.950]         }
[10:59:31.950]         else {
[10:59:31.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.950]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.950]         }
[10:59:31.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.950]             base::sink(type = "output", split = FALSE)
[10:59:31.950]             base::close(...future.stdout)
[10:59:31.950]         }, add = TRUE)
[10:59:31.950]     }
[10:59:31.950]     ...future.frame <- base::sys.nframe()
[10:59:31.950]     ...future.conditions <- base::list()
[10:59:31.950]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.950]     if (FALSE) {
[10:59:31.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.950]     }
[10:59:31.950]     ...future.result <- base::tryCatch({
[10:59:31.950]         base::withCallingHandlers({
[10:59:31.950]             ...future.value <- base::withVisible(base::local({
[10:59:31.950]                 withCallingHandlers({
[10:59:31.950]                   {
[10:59:31.950]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.950]                     if (!identical(...future.globals.maxSize.org, 
[10:59:31.950]                       ...future.globals.maxSize)) {
[10:59:31.950]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.950]                       on.exit(options(oopts), add = TRUE)
[10:59:31.950]                     }
[10:59:31.950]                     {
[10:59:31.950]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.950]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.950]                         USE.NAMES = FALSE)
[10:59:31.950]                       do.call(mapply, args = args)
[10:59:31.950]                     }
[10:59:31.950]                   }
[10:59:31.950]                 }, immediateCondition = function(cond) {
[10:59:31.950]                   save_rds <- function (object, pathname, ...) 
[10:59:31.950]                   {
[10:59:31.950]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:31.950]                     if (file_test("-f", pathname_tmp)) {
[10:59:31.950]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.950]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:31.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.950]                         fi_tmp[["mtime"]])
[10:59:31.950]                     }
[10:59:31.950]                     tryCatch({
[10:59:31.950]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:31.950]                     }, error = function(ex) {
[10:59:31.950]                       msg <- conditionMessage(ex)
[10:59:31.950]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.950]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:31.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.950]                         fi_tmp[["mtime"]], msg)
[10:59:31.950]                       ex$message <- msg
[10:59:31.950]                       stop(ex)
[10:59:31.950]                     })
[10:59:31.950]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:31.950]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:31.950]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:31.950]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.950]                       fi <- file.info(pathname)
[10:59:31.950]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:31.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.950]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:31.950]                         fi[["size"]], fi[["mtime"]])
[10:59:31.950]                       stop(msg)
[10:59:31.950]                     }
[10:59:31.950]                     invisible(pathname)
[10:59:31.950]                   }
[10:59:31.950]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:31.950]                     rootPath = tempdir()) 
[10:59:31.950]                   {
[10:59:31.950]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:31.950]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:31.950]                       tmpdir = path, fileext = ".rds")
[10:59:31.950]                     save_rds(obj, file)
[10:59:31.950]                   }
[10:59:31.950]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:31.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.950]                   {
[10:59:31.950]                     inherits <- base::inherits
[10:59:31.950]                     invokeRestart <- base::invokeRestart
[10:59:31.950]                     is.null <- base::is.null
[10:59:31.950]                     muffled <- FALSE
[10:59:31.950]                     if (inherits(cond, "message")) {
[10:59:31.950]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:31.950]                       if (muffled) 
[10:59:31.950]                         invokeRestart("muffleMessage")
[10:59:31.950]                     }
[10:59:31.950]                     else if (inherits(cond, "warning")) {
[10:59:31.950]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:31.950]                       if (muffled) 
[10:59:31.950]                         invokeRestart("muffleWarning")
[10:59:31.950]                     }
[10:59:31.950]                     else if (inherits(cond, "condition")) {
[10:59:31.950]                       if (!is.null(pattern)) {
[10:59:31.950]                         computeRestarts <- base::computeRestarts
[10:59:31.950]                         grepl <- base::grepl
[10:59:31.950]                         restarts <- computeRestarts(cond)
[10:59:31.950]                         for (restart in restarts) {
[10:59:31.950]                           name <- restart$name
[10:59:31.950]                           if (is.null(name)) 
[10:59:31.950]                             next
[10:59:31.950]                           if (!grepl(pattern, name)) 
[10:59:31.950]                             next
[10:59:31.950]                           invokeRestart(restart)
[10:59:31.950]                           muffled <- TRUE
[10:59:31.950]                           break
[10:59:31.950]                         }
[10:59:31.950]                       }
[10:59:31.950]                     }
[10:59:31.950]                     invisible(muffled)
[10:59:31.950]                   }
[10:59:31.950]                   muffleCondition(cond)
[10:59:31.950]                 })
[10:59:31.950]             }))
[10:59:31.950]             future::FutureResult(value = ...future.value$value, 
[10:59:31.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.950]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.950]                     ...future.globalenv.names))
[10:59:31.950]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.950]         }, condition = base::local({
[10:59:31.950]             c <- base::c
[10:59:31.950]             inherits <- base::inherits
[10:59:31.950]             invokeRestart <- base::invokeRestart
[10:59:31.950]             length <- base::length
[10:59:31.950]             list <- base::list
[10:59:31.950]             seq.int <- base::seq.int
[10:59:31.950]             signalCondition <- base::signalCondition
[10:59:31.950]             sys.calls <- base::sys.calls
[10:59:31.950]             `[[` <- base::`[[`
[10:59:31.950]             `+` <- base::`+`
[10:59:31.950]             `<<-` <- base::`<<-`
[10:59:31.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.950]                   3L)]
[10:59:31.950]             }
[10:59:31.950]             function(cond) {
[10:59:31.950]                 is_error <- inherits(cond, "error")
[10:59:31.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.950]                   NULL)
[10:59:31.950]                 if (is_error) {
[10:59:31.950]                   sessionInformation <- function() {
[10:59:31.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.950]                       search = base::search(), system = base::Sys.info())
[10:59:31.950]                   }
[10:59:31.950]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.950]                     cond$call), session = sessionInformation(), 
[10:59:31.950]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.950]                   signalCondition(cond)
[10:59:31.950]                 }
[10:59:31.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.950]                 "immediateCondition"))) {
[10:59:31.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.950]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.950]                   if (TRUE && !signal) {
[10:59:31.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.950]                     {
[10:59:31.950]                       inherits <- base::inherits
[10:59:31.950]                       invokeRestart <- base::invokeRestart
[10:59:31.950]                       is.null <- base::is.null
[10:59:31.950]                       muffled <- FALSE
[10:59:31.950]                       if (inherits(cond, "message")) {
[10:59:31.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.950]                         if (muffled) 
[10:59:31.950]                           invokeRestart("muffleMessage")
[10:59:31.950]                       }
[10:59:31.950]                       else if (inherits(cond, "warning")) {
[10:59:31.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.950]                         if (muffled) 
[10:59:31.950]                           invokeRestart("muffleWarning")
[10:59:31.950]                       }
[10:59:31.950]                       else if (inherits(cond, "condition")) {
[10:59:31.950]                         if (!is.null(pattern)) {
[10:59:31.950]                           computeRestarts <- base::computeRestarts
[10:59:31.950]                           grepl <- base::grepl
[10:59:31.950]                           restarts <- computeRestarts(cond)
[10:59:31.950]                           for (restart in restarts) {
[10:59:31.950]                             name <- restart$name
[10:59:31.950]                             if (is.null(name)) 
[10:59:31.950]                               next
[10:59:31.950]                             if (!grepl(pattern, name)) 
[10:59:31.950]                               next
[10:59:31.950]                             invokeRestart(restart)
[10:59:31.950]                             muffled <- TRUE
[10:59:31.950]                             break
[10:59:31.950]                           }
[10:59:31.950]                         }
[10:59:31.950]                       }
[10:59:31.950]                       invisible(muffled)
[10:59:31.950]                     }
[10:59:31.950]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.950]                   }
[10:59:31.950]                 }
[10:59:31.950]                 else {
[10:59:31.950]                   if (TRUE) {
[10:59:31.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.950]                     {
[10:59:31.950]                       inherits <- base::inherits
[10:59:31.950]                       invokeRestart <- base::invokeRestart
[10:59:31.950]                       is.null <- base::is.null
[10:59:31.950]                       muffled <- FALSE
[10:59:31.950]                       if (inherits(cond, "message")) {
[10:59:31.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.950]                         if (muffled) 
[10:59:31.950]                           invokeRestart("muffleMessage")
[10:59:31.950]                       }
[10:59:31.950]                       else if (inherits(cond, "warning")) {
[10:59:31.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.950]                         if (muffled) 
[10:59:31.950]                           invokeRestart("muffleWarning")
[10:59:31.950]                       }
[10:59:31.950]                       else if (inherits(cond, "condition")) {
[10:59:31.950]                         if (!is.null(pattern)) {
[10:59:31.950]                           computeRestarts <- base::computeRestarts
[10:59:31.950]                           grepl <- base::grepl
[10:59:31.950]                           restarts <- computeRestarts(cond)
[10:59:31.950]                           for (restart in restarts) {
[10:59:31.950]                             name <- restart$name
[10:59:31.950]                             if (is.null(name)) 
[10:59:31.950]                               next
[10:59:31.950]                             if (!grepl(pattern, name)) 
[10:59:31.950]                               next
[10:59:31.950]                             invokeRestart(restart)
[10:59:31.950]                             muffled <- TRUE
[10:59:31.950]                             break
[10:59:31.950]                           }
[10:59:31.950]                         }
[10:59:31.950]                       }
[10:59:31.950]                       invisible(muffled)
[10:59:31.950]                     }
[10:59:31.950]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.950]                   }
[10:59:31.950]                 }
[10:59:31.950]             }
[10:59:31.950]         }))
[10:59:31.950]     }, error = function(ex) {
[10:59:31.950]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.950]                 ...future.rng), started = ...future.startTime, 
[10:59:31.950]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.950]             version = "1.8"), class = "FutureResult")
[10:59:31.950]     }, finally = {
[10:59:31.950]         if (!identical(...future.workdir, getwd())) 
[10:59:31.950]             setwd(...future.workdir)
[10:59:31.950]         {
[10:59:31.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.950]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.950]             }
[10:59:31.950]             base::options(...future.oldOptions)
[10:59:31.950]             if (.Platform$OS.type == "windows") {
[10:59:31.950]                 old_names <- names(...future.oldEnvVars)
[10:59:31.950]                 envs <- base::Sys.getenv()
[10:59:31.950]                 names <- names(envs)
[10:59:31.950]                 common <- intersect(names, old_names)
[10:59:31.950]                 added <- setdiff(names, old_names)
[10:59:31.950]                 removed <- setdiff(old_names, names)
[10:59:31.950]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.950]                   envs[common]]
[10:59:31.950]                 NAMES <- toupper(changed)
[10:59:31.950]                 args <- list()
[10:59:31.950]                 for (kk in seq_along(NAMES)) {
[10:59:31.950]                   name <- changed[[kk]]
[10:59:31.950]                   NAME <- NAMES[[kk]]
[10:59:31.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.950]                     next
[10:59:31.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.950]                 }
[10:59:31.950]                 NAMES <- toupper(added)
[10:59:31.950]                 for (kk in seq_along(NAMES)) {
[10:59:31.950]                   name <- added[[kk]]
[10:59:31.950]                   NAME <- NAMES[[kk]]
[10:59:31.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.950]                     next
[10:59:31.950]                   args[[name]] <- ""
[10:59:31.950]                 }
[10:59:31.950]                 NAMES <- toupper(removed)
[10:59:31.950]                 for (kk in seq_along(NAMES)) {
[10:59:31.950]                   name <- removed[[kk]]
[10:59:31.950]                   NAME <- NAMES[[kk]]
[10:59:31.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.950]                     next
[10:59:31.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.950]                 }
[10:59:31.950]                 if (length(args) > 0) 
[10:59:31.950]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.950]             }
[10:59:31.950]             else {
[10:59:31.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.950]             }
[10:59:31.950]             {
[10:59:31.950]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.950]                   0L) {
[10:59:31.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.950]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.950]                   base::options(opts)
[10:59:31.950]                 }
[10:59:31.950]                 {
[10:59:31.950]                   {
[10:59:31.950]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:31.950]                     NULL
[10:59:31.950]                   }
[10:59:31.950]                   options(future.plan = NULL)
[10:59:31.950]                   if (is.na(NA_character_)) 
[10:59:31.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.950]                     .init = FALSE)
[10:59:31.950]                 }
[10:59:31.950]             }
[10:59:31.950]         }
[10:59:31.950]     })
[10:59:31.950]     if (TRUE) {
[10:59:31.950]         base::sink(type = "output", split = FALSE)
[10:59:31.950]         if (TRUE) {
[10:59:31.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.950]         }
[10:59:31.950]         else {
[10:59:31.950]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.950]         }
[10:59:31.950]         base::close(...future.stdout)
[10:59:31.950]         ...future.stdout <- NULL
[10:59:31.950]     }
[10:59:31.950]     ...future.result$conditions <- ...future.conditions
[10:59:31.950]     ...future.result$finished <- base::Sys.time()
[10:59:31.950]     ...future.result
[10:59:31.950] }
[10:59:31.952] assign_globals() ...
[10:59:31.953] List of 5
[10:59:31.953]  $ ...future.FUN            :function (x, ...)  
[10:59:31.953]  $ MoreArgs                 : NULL
[10:59:31.953]  $ ...future.elements_ii    :List of 2
[10:59:31.953]   ..$ times:List of 2
[10:59:31.953]   .. ..$ : int 1
[10:59:31.953]   .. ..$ : int 2
[10:59:31.953]   ..$ x    :List of 2
[10:59:31.953]   .. ..$ : int 4
[10:59:31.953]   .. ..$ : int 3
[10:59:31.953]  $ ...future.seeds_ii       : NULL
[10:59:31.953]  $ ...future.globals.maxSize: NULL
[10:59:31.953]  - attr(*, "where")=List of 5
[10:59:31.953]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.953]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.953]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.953]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.953]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.953]  - attr(*, "resolved")= logi FALSE
[10:59:31.953]  - attr(*, "total_size")= num 265
[10:59:31.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.953]  - attr(*, "already-done")= logi TRUE
[10:59:31.958] - copied ‘...future.FUN’ to environment
[10:59:31.958] - copied ‘MoreArgs’ to environment
[10:59:31.958] - copied ‘...future.elements_ii’ to environment
[10:59:31.958] - copied ‘...future.seeds_ii’ to environment
[10:59:31.958] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.958] assign_globals() ... done
[10:59:31.958] requestCore(): workers = 2
[10:59:31.960] MulticoreFuture started
[10:59:31.961] - Launch lazy future ... done
[10:59:31.961] run() for ‘MulticoreFuture’ ... done
[10:59:31.961] Created future:
[10:59:31.961] plan(): Setting new future strategy stack:
[10:59:31.961] List of future strategies:
[10:59:31.961] 1. sequential:
[10:59:31.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:31.961]    - tweaked: FALSE
[10:59:31.961]    - call: NULL
[10:59:31.962] plan(): nbrOfWorkers() = 1
[10:59:31.964] plan(): Setting new future strategy stack:
[10:59:31.964] List of future strategies:
[10:59:31.964] 1. multicore:
[10:59:31.964]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:31.964]    - tweaked: FALSE
[10:59:31.964]    - call: plan(strategy)
[10:59:31.967] plan(): nbrOfWorkers() = 2
[10:59:31.961] MulticoreFuture:
[10:59:31.961] Label: ‘future_mapply-1’
[10:59:31.961] Expression:
[10:59:31.961] {
[10:59:31.961]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.961]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:31.961]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.961]         on.exit(options(oopts), add = TRUE)
[10:59:31.961]     }
[10:59:31.961]     {
[10:59:31.961]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.961]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:31.961]         do.call(mapply, args = args)
[10:59:31.961]     }
[10:59:31.961] }
[10:59:31.961] Lazy evaluation: FALSE
[10:59:31.961] Asynchronous evaluation: TRUE
[10:59:31.961] Local evaluation: TRUE
[10:59:31.961] Environment: R_GlobalEnv
[10:59:31.961] Capture standard output: TRUE
[10:59:31.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:31.961] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:31.961] Packages: <none>
[10:59:31.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:31.961] Resolved: TRUE
[10:59:31.961] Value: <not collected>
[10:59:31.961] Conditions captured: <none>
[10:59:31.961] Early signaling: FALSE
[10:59:31.961] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:31.961] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.968] Chunk #1 of 2 ... DONE
[10:59:31.969] Chunk #2 of 2 ...
[10:59:31.969]  - Finding globals in '...' for chunk #2 ...
[10:59:31.969] getGlobalsAndPackages() ...
[10:59:31.969] Searching for globals...
[10:59:31.970] 
[10:59:31.970] Searching for globals ... DONE
[10:59:31.970] - globals: [0] <none>
[10:59:31.970] getGlobalsAndPackages() ... DONE
[10:59:31.970]    + additional globals found: [n=0] 
[10:59:31.970]    + additional namespaces needed: [n=0] 
[10:59:31.970]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:31.970]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:31.971]  - seeds: <none>
[10:59:31.971]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.971] getGlobalsAndPackages() ...
[10:59:31.971] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.971] Resolving globals: FALSE
[10:59:31.972] The total size of the 5 globals is 265 bytes (265 bytes)
[10:59:31.973] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:31.973] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:31.973] 
[10:59:31.973] getGlobalsAndPackages() ... DONE
[10:59:31.977] run() for ‘Future’ ...
[10:59:31.978] - state: ‘created’
[10:59:31.978] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:31.982] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:31.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:31.982]   - Field: ‘label’
[10:59:31.982]   - Field: ‘local’
[10:59:31.983]   - Field: ‘owner’
[10:59:31.983]   - Field: ‘envir’
[10:59:31.983]   - Field: ‘workers’
[10:59:31.983]   - Field: ‘packages’
[10:59:31.983]   - Field: ‘gc’
[10:59:31.984]   - Field: ‘job’
[10:59:31.984]   - Field: ‘conditions’
[10:59:31.984]   - Field: ‘expr’
[10:59:31.984]   - Field: ‘uuid’
[10:59:31.985]   - Field: ‘seed’
[10:59:31.985]   - Field: ‘version’
[10:59:31.985]   - Field: ‘result’
[10:59:31.985]   - Field: ‘asynchronous’
[10:59:31.986]   - Field: ‘calls’
[10:59:31.986]   - Field: ‘globals’
[10:59:31.986]   - Field: ‘stdout’
[10:59:31.986]   - Field: ‘earlySignal’
[10:59:31.986]   - Field: ‘lazy’
[10:59:31.986]   - Field: ‘state’
[10:59:31.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:31.987] - Launch lazy future ...
[10:59:31.987] Packages needed by the future expression (n = 0): <none>
[10:59:31.987] Packages needed by future strategies (n = 0): <none>
[10:59:31.988] {
[10:59:31.988]     {
[10:59:31.988]         {
[10:59:31.988]             ...future.startTime <- base::Sys.time()
[10:59:31.988]             {
[10:59:31.988]                 {
[10:59:31.988]                   {
[10:59:31.988]                     {
[10:59:31.988]                       base::local({
[10:59:31.988]                         has_future <- base::requireNamespace("future", 
[10:59:31.988]                           quietly = TRUE)
[10:59:31.988]                         if (has_future) {
[10:59:31.988]                           ns <- base::getNamespace("future")
[10:59:31.988]                           version <- ns[[".package"]][["version"]]
[10:59:31.988]                           if (is.null(version)) 
[10:59:31.988]                             version <- utils::packageVersion("future")
[10:59:31.988]                         }
[10:59:31.988]                         else {
[10:59:31.988]                           version <- NULL
[10:59:31.988]                         }
[10:59:31.988]                         if (!has_future || version < "1.8.0") {
[10:59:31.988]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:31.988]                             "", base::R.version$version.string), 
[10:59:31.988]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:31.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:31.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:31.988]                               "release", "version")], collapse = " "), 
[10:59:31.988]                             hostname = base::Sys.info()[["nodename"]])
[10:59:31.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:31.988]                             info)
[10:59:31.988]                           info <- base::paste(info, collapse = "; ")
[10:59:31.988]                           if (!has_future) {
[10:59:31.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:31.988]                               info)
[10:59:31.988]                           }
[10:59:31.988]                           else {
[10:59:31.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:31.988]                               info, version)
[10:59:31.988]                           }
[10:59:31.988]                           base::stop(msg)
[10:59:31.988]                         }
[10:59:31.988]                       })
[10:59:31.988]                     }
[10:59:31.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:31.988]                     base::options(mc.cores = 1L)
[10:59:31.988]                   }
[10:59:31.988]                   ...future.strategy.old <- future::plan("list")
[10:59:31.988]                   options(future.plan = NULL)
[10:59:31.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:31.988]                 }
[10:59:31.988]                 ...future.workdir <- getwd()
[10:59:31.988]             }
[10:59:31.988]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:31.988]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:31.988]         }
[10:59:31.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:31.988]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:31.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:31.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:31.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:31.988]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:31.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:31.988]             base::names(...future.oldOptions))
[10:59:31.988]     }
[10:59:31.988]     if (FALSE) {
[10:59:31.988]     }
[10:59:31.988]     else {
[10:59:31.988]         if (TRUE) {
[10:59:31.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:31.988]                 open = "w")
[10:59:31.988]         }
[10:59:31.988]         else {
[10:59:31.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:31.988]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:31.988]         }
[10:59:31.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:31.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:31.988]             base::sink(type = "output", split = FALSE)
[10:59:31.988]             base::close(...future.stdout)
[10:59:31.988]         }, add = TRUE)
[10:59:31.988]     }
[10:59:31.988]     ...future.frame <- base::sys.nframe()
[10:59:31.988]     ...future.conditions <- base::list()
[10:59:31.988]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:31.988]     if (FALSE) {
[10:59:31.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:31.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:31.988]     }
[10:59:31.988]     ...future.result <- base::tryCatch({
[10:59:31.988]         base::withCallingHandlers({
[10:59:31.988]             ...future.value <- base::withVisible(base::local({
[10:59:31.988]                 withCallingHandlers({
[10:59:31.988]                   {
[10:59:31.988]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:31.988]                     if (!identical(...future.globals.maxSize.org, 
[10:59:31.988]                       ...future.globals.maxSize)) {
[10:59:31.988]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:31.988]                       on.exit(options(oopts), add = TRUE)
[10:59:31.988]                     }
[10:59:31.988]                     {
[10:59:31.988]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:31.988]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:31.988]                         USE.NAMES = FALSE)
[10:59:31.988]                       do.call(mapply, args = args)
[10:59:31.988]                     }
[10:59:31.988]                   }
[10:59:31.988]                 }, immediateCondition = function(cond) {
[10:59:31.988]                   save_rds <- function (object, pathname, ...) 
[10:59:31.988]                   {
[10:59:31.988]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:31.988]                     if (file_test("-f", pathname_tmp)) {
[10:59:31.988]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.988]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:31.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.988]                         fi_tmp[["mtime"]])
[10:59:31.988]                     }
[10:59:31.988]                     tryCatch({
[10:59:31.988]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:31.988]                     }, error = function(ex) {
[10:59:31.988]                       msg <- conditionMessage(ex)
[10:59:31.988]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.988]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:31.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.988]                         fi_tmp[["mtime"]], msg)
[10:59:31.988]                       ex$message <- msg
[10:59:31.988]                       stop(ex)
[10:59:31.988]                     })
[10:59:31.988]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:31.988]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:31.988]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:31.988]                       fi_tmp <- file.info(pathname_tmp)
[10:59:31.988]                       fi <- file.info(pathname)
[10:59:31.988]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:31.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:31.988]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:31.988]                         fi[["size"]], fi[["mtime"]])
[10:59:31.988]                       stop(msg)
[10:59:31.988]                     }
[10:59:31.988]                     invisible(pathname)
[10:59:31.988]                   }
[10:59:31.988]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:31.988]                     rootPath = tempdir()) 
[10:59:31.988]                   {
[10:59:31.988]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:31.988]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:31.988]                       tmpdir = path, fileext = ".rds")
[10:59:31.988]                     save_rds(obj, file)
[10:59:31.988]                   }
[10:59:31.988]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:31.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.988]                   {
[10:59:31.988]                     inherits <- base::inherits
[10:59:31.988]                     invokeRestart <- base::invokeRestart
[10:59:31.988]                     is.null <- base::is.null
[10:59:31.988]                     muffled <- FALSE
[10:59:31.988]                     if (inherits(cond, "message")) {
[10:59:31.988]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:31.988]                       if (muffled) 
[10:59:31.988]                         invokeRestart("muffleMessage")
[10:59:31.988]                     }
[10:59:31.988]                     else if (inherits(cond, "warning")) {
[10:59:31.988]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:31.988]                       if (muffled) 
[10:59:31.988]                         invokeRestart("muffleWarning")
[10:59:31.988]                     }
[10:59:31.988]                     else if (inherits(cond, "condition")) {
[10:59:31.988]                       if (!is.null(pattern)) {
[10:59:31.988]                         computeRestarts <- base::computeRestarts
[10:59:31.988]                         grepl <- base::grepl
[10:59:31.988]                         restarts <- computeRestarts(cond)
[10:59:31.988]                         for (restart in restarts) {
[10:59:31.988]                           name <- restart$name
[10:59:31.988]                           if (is.null(name)) 
[10:59:31.988]                             next
[10:59:31.988]                           if (!grepl(pattern, name)) 
[10:59:31.988]                             next
[10:59:31.988]                           invokeRestart(restart)
[10:59:31.988]                           muffled <- TRUE
[10:59:31.988]                           break
[10:59:31.988]                         }
[10:59:31.988]                       }
[10:59:31.988]                     }
[10:59:31.988]                     invisible(muffled)
[10:59:31.988]                   }
[10:59:31.988]                   muffleCondition(cond)
[10:59:31.988]                 })
[10:59:31.988]             }))
[10:59:31.988]             future::FutureResult(value = ...future.value$value, 
[10:59:31.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.988]                   ...future.rng), globalenv = if (FALSE) 
[10:59:31.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:31.988]                     ...future.globalenv.names))
[10:59:31.988]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:31.988]         }, condition = base::local({
[10:59:31.988]             c <- base::c
[10:59:31.988]             inherits <- base::inherits
[10:59:31.988]             invokeRestart <- base::invokeRestart
[10:59:31.988]             length <- base::length
[10:59:31.988]             list <- base::list
[10:59:31.988]             seq.int <- base::seq.int
[10:59:31.988]             signalCondition <- base::signalCondition
[10:59:31.988]             sys.calls <- base::sys.calls
[10:59:31.988]             `[[` <- base::`[[`
[10:59:31.988]             `+` <- base::`+`
[10:59:31.988]             `<<-` <- base::`<<-`
[10:59:31.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:31.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:31.988]                   3L)]
[10:59:31.988]             }
[10:59:31.988]             function(cond) {
[10:59:31.988]                 is_error <- inherits(cond, "error")
[10:59:31.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:31.988]                   NULL)
[10:59:31.988]                 if (is_error) {
[10:59:31.988]                   sessionInformation <- function() {
[10:59:31.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:31.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:31.988]                       search = base::search(), system = base::Sys.info())
[10:59:31.988]                   }
[10:59:31.988]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:31.988]                     cond$call), session = sessionInformation(), 
[10:59:31.988]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:31.988]                   signalCondition(cond)
[10:59:31.988]                 }
[10:59:31.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:31.988]                 "immediateCondition"))) {
[10:59:31.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:31.988]                   ...future.conditions[[length(...future.conditions) + 
[10:59:31.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:31.988]                   if (TRUE && !signal) {
[10:59:31.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.988]                     {
[10:59:31.988]                       inherits <- base::inherits
[10:59:31.988]                       invokeRestart <- base::invokeRestart
[10:59:31.988]                       is.null <- base::is.null
[10:59:31.988]                       muffled <- FALSE
[10:59:31.988]                       if (inherits(cond, "message")) {
[10:59:31.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.988]                         if (muffled) 
[10:59:31.988]                           invokeRestart("muffleMessage")
[10:59:31.988]                       }
[10:59:31.988]                       else if (inherits(cond, "warning")) {
[10:59:31.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.988]                         if (muffled) 
[10:59:31.988]                           invokeRestart("muffleWarning")
[10:59:31.988]                       }
[10:59:31.988]                       else if (inherits(cond, "condition")) {
[10:59:31.988]                         if (!is.null(pattern)) {
[10:59:31.988]                           computeRestarts <- base::computeRestarts
[10:59:31.988]                           grepl <- base::grepl
[10:59:31.988]                           restarts <- computeRestarts(cond)
[10:59:31.988]                           for (restart in restarts) {
[10:59:31.988]                             name <- restart$name
[10:59:31.988]                             if (is.null(name)) 
[10:59:31.988]                               next
[10:59:31.988]                             if (!grepl(pattern, name)) 
[10:59:31.988]                               next
[10:59:31.988]                             invokeRestart(restart)
[10:59:31.988]                             muffled <- TRUE
[10:59:31.988]                             break
[10:59:31.988]                           }
[10:59:31.988]                         }
[10:59:31.988]                       }
[10:59:31.988]                       invisible(muffled)
[10:59:31.988]                     }
[10:59:31.988]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.988]                   }
[10:59:31.988]                 }
[10:59:31.988]                 else {
[10:59:31.988]                   if (TRUE) {
[10:59:31.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:31.988]                     {
[10:59:31.988]                       inherits <- base::inherits
[10:59:31.988]                       invokeRestart <- base::invokeRestart
[10:59:31.988]                       is.null <- base::is.null
[10:59:31.988]                       muffled <- FALSE
[10:59:31.988]                       if (inherits(cond, "message")) {
[10:59:31.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:31.988]                         if (muffled) 
[10:59:31.988]                           invokeRestart("muffleMessage")
[10:59:31.988]                       }
[10:59:31.988]                       else if (inherits(cond, "warning")) {
[10:59:31.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:31.988]                         if (muffled) 
[10:59:31.988]                           invokeRestart("muffleWarning")
[10:59:31.988]                       }
[10:59:31.988]                       else if (inherits(cond, "condition")) {
[10:59:31.988]                         if (!is.null(pattern)) {
[10:59:31.988]                           computeRestarts <- base::computeRestarts
[10:59:31.988]                           grepl <- base::grepl
[10:59:31.988]                           restarts <- computeRestarts(cond)
[10:59:31.988]                           for (restart in restarts) {
[10:59:31.988]                             name <- restart$name
[10:59:31.988]                             if (is.null(name)) 
[10:59:31.988]                               next
[10:59:31.988]                             if (!grepl(pattern, name)) 
[10:59:31.988]                               next
[10:59:31.988]                             invokeRestart(restart)
[10:59:31.988]                             muffled <- TRUE
[10:59:31.988]                             break
[10:59:31.988]                           }
[10:59:31.988]                         }
[10:59:31.988]                       }
[10:59:31.988]                       invisible(muffled)
[10:59:31.988]                     }
[10:59:31.988]                     muffleCondition(cond, pattern = "^muffle")
[10:59:31.988]                   }
[10:59:31.988]                 }
[10:59:31.988]             }
[10:59:31.988]         }))
[10:59:31.988]     }, error = function(ex) {
[10:59:31.988]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:31.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:31.988]                 ...future.rng), started = ...future.startTime, 
[10:59:31.988]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:31.988]             version = "1.8"), class = "FutureResult")
[10:59:31.988]     }, finally = {
[10:59:31.988]         if (!identical(...future.workdir, getwd())) 
[10:59:31.988]             setwd(...future.workdir)
[10:59:31.988]         {
[10:59:31.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:31.988]                 ...future.oldOptions$nwarnings <- NULL
[10:59:31.988]             }
[10:59:31.988]             base::options(...future.oldOptions)
[10:59:31.988]             if (.Platform$OS.type == "windows") {
[10:59:31.988]                 old_names <- names(...future.oldEnvVars)
[10:59:31.988]                 envs <- base::Sys.getenv()
[10:59:31.988]                 names <- names(envs)
[10:59:31.988]                 common <- intersect(names, old_names)
[10:59:31.988]                 added <- setdiff(names, old_names)
[10:59:31.988]                 removed <- setdiff(old_names, names)
[10:59:31.988]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:31.988]                   envs[common]]
[10:59:31.988]                 NAMES <- toupper(changed)
[10:59:31.988]                 args <- list()
[10:59:31.988]                 for (kk in seq_along(NAMES)) {
[10:59:31.988]                   name <- changed[[kk]]
[10:59:31.988]                   NAME <- NAMES[[kk]]
[10:59:31.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.988]                     next
[10:59:31.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.988]                 }
[10:59:31.988]                 NAMES <- toupper(added)
[10:59:31.988]                 for (kk in seq_along(NAMES)) {
[10:59:31.988]                   name <- added[[kk]]
[10:59:31.988]                   NAME <- NAMES[[kk]]
[10:59:31.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.988]                     next
[10:59:31.988]                   args[[name]] <- ""
[10:59:31.988]                 }
[10:59:31.988]                 NAMES <- toupper(removed)
[10:59:31.988]                 for (kk in seq_along(NAMES)) {
[10:59:31.988]                   name <- removed[[kk]]
[10:59:31.988]                   NAME <- NAMES[[kk]]
[10:59:31.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:31.988]                     next
[10:59:31.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:31.988]                 }
[10:59:31.988]                 if (length(args) > 0) 
[10:59:31.988]                   base::do.call(base::Sys.setenv, args = args)
[10:59:31.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:31.988]             }
[10:59:31.988]             else {
[10:59:31.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:31.988]             }
[10:59:31.988]             {
[10:59:31.988]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:31.988]                   0L) {
[10:59:31.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:31.988]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:31.988]                   base::options(opts)
[10:59:31.988]                 }
[10:59:31.988]                 {
[10:59:31.988]                   {
[10:59:31.988]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:31.988]                     NULL
[10:59:31.988]                   }
[10:59:31.988]                   options(future.plan = NULL)
[10:59:31.988]                   if (is.na(NA_character_)) 
[10:59:31.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:31.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:31.988]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:31.988]                     .init = FALSE)
[10:59:31.988]                 }
[10:59:31.988]             }
[10:59:31.988]         }
[10:59:31.988]     })
[10:59:31.988]     if (TRUE) {
[10:59:31.988]         base::sink(type = "output", split = FALSE)
[10:59:31.988]         if (TRUE) {
[10:59:31.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:31.988]         }
[10:59:31.988]         else {
[10:59:31.988]             ...future.result["stdout"] <- base::list(NULL)
[10:59:31.988]         }
[10:59:31.988]         base::close(...future.stdout)
[10:59:31.988]         ...future.stdout <- NULL
[10:59:31.988]     }
[10:59:31.988]     ...future.result$conditions <- ...future.conditions
[10:59:31.988]     ...future.result$finished <- base::Sys.time()
[10:59:31.988]     ...future.result
[10:59:31.988] }
[10:59:31.991] assign_globals() ...
[10:59:31.991] List of 5
[10:59:31.991]  $ ...future.FUN            :function (x, ...)  
[10:59:31.991]  $ MoreArgs                 : NULL
[10:59:31.991]  $ ...future.elements_ii    :List of 2
[10:59:31.991]   ..$ times:List of 2
[10:59:31.991]   .. ..$ : int 3
[10:59:31.991]   .. ..$ : int 4
[10:59:31.991]   ..$ x    :List of 2
[10:59:31.991]   .. ..$ : int 2
[10:59:31.991]   .. ..$ : int 1
[10:59:31.991]  $ ...future.seeds_ii       : NULL
[10:59:31.991]  $ ...future.globals.maxSize: NULL
[10:59:31.991]  - attr(*, "where")=List of 5
[10:59:31.991]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:31.991]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:31.991]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:31.991]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:31.991]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:31.991]  - attr(*, "resolved")= logi FALSE
[10:59:31.991]  - attr(*, "total_size")= num 265
[10:59:31.991]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:31.991]  - attr(*, "already-done")= logi TRUE
[10:59:31.998] - copied ‘...future.FUN’ to environment
[10:59:31.998] - copied ‘MoreArgs’ to environment
[10:59:31.998] - copied ‘...future.elements_ii’ to environment
[10:59:31.998] - copied ‘...future.seeds_ii’ to environment
[10:59:31.999] - copied ‘...future.globals.maxSize’ to environment
[10:59:31.999] assign_globals() ... done
[10:59:31.999] requestCore(): workers = 2
[10:59:32.001] MulticoreFuture started
[10:59:32.001] - Launch lazy future ... done
[10:59:32.001] run() for ‘MulticoreFuture’ ... done
[10:59:32.002] Created future:
[10:59:32.002] plan(): Setting new future strategy stack:
[10:59:32.002] List of future strategies:
[10:59:32.002] 1. sequential:
[10:59:32.002]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.002]    - tweaked: FALSE
[10:59:32.002]    - call: NULL
[10:59:32.003] plan(): nbrOfWorkers() = 1
[10:59:32.005] plan(): Setting new future strategy stack:
[10:59:32.005] List of future strategies:
[10:59:32.005] 1. multicore:
[10:59:32.005]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.005]    - tweaked: FALSE
[10:59:32.005]    - call: plan(strategy)
[10:59:32.008] plan(): nbrOfWorkers() = 2
[10:59:32.002] MulticoreFuture:
[10:59:32.002] Label: ‘future_mapply-2’
[10:59:32.002] Expression:
[10:59:32.002] {
[10:59:32.002]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.002]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.002]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.002]         on.exit(options(oopts), add = TRUE)
[10:59:32.002]     }
[10:59:32.002]     {
[10:59:32.002]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.002]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.002]         do.call(mapply, args = args)
[10:59:32.002]     }
[10:59:32.002] }
[10:59:32.002] Lazy evaluation: FALSE
[10:59:32.002] Asynchronous evaluation: TRUE
[10:59:32.002] Local evaluation: TRUE
[10:59:32.002] Environment: R_GlobalEnv
[10:59:32.002] Capture standard output: TRUE
[10:59:32.002] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.002] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.002] Packages: <none>
[10:59:32.002] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.002] Resolved: TRUE
[10:59:32.002] Value: <not collected>
[10:59:32.002] Conditions captured: <none>
[10:59:32.002] Early signaling: FALSE
[10:59:32.002] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.002] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.010] Chunk #2 of 2 ... DONE
[10:59:32.010] Launching 2 futures (chunks) ... DONE
[10:59:32.010] Resolving 2 futures (chunks) ...
[10:59:32.010] resolve() on list ...
[10:59:32.010]  recursive: 0
[10:59:32.010]  length: 2
[10:59:32.010] 
[10:59:32.011] Future #1
[10:59:32.011] result() for MulticoreFuture ...
[10:59:32.012] result() for MulticoreFuture ...
[10:59:32.012] result() for MulticoreFuture ... done
[10:59:32.012] result() for MulticoreFuture ... done
[10:59:32.012] result() for MulticoreFuture ...
[10:59:32.012] result() for MulticoreFuture ... done
[10:59:32.013] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.013] - nx: 2
[10:59:32.013] - relay: TRUE
[10:59:32.013] - stdout: TRUE
[10:59:32.013] - signal: TRUE
[10:59:32.013] - resignal: FALSE
[10:59:32.013] - force: TRUE
[10:59:32.014] - relayed: [n=2] FALSE, FALSE
[10:59:32.014] - queued futures: [n=2] FALSE, FALSE
[10:59:32.014]  - until=1
[10:59:32.014]  - relaying element #1
[10:59:32.014] result() for MulticoreFuture ...
[10:59:32.014] result() for MulticoreFuture ... done
[10:59:32.014] result() for MulticoreFuture ...
[10:59:32.015] result() for MulticoreFuture ... done
[10:59:32.015] result() for MulticoreFuture ...
[10:59:32.015] result() for MulticoreFuture ... done
[10:59:32.015] result() for MulticoreFuture ...
[10:59:32.015] result() for MulticoreFuture ... done
[10:59:32.015] - relayed: [n=2] TRUE, FALSE
[10:59:32.015] - queued futures: [n=2] TRUE, FALSE
[10:59:32.016] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.016]  length: 1 (resolved future 1)
[10:59:32.016] Future #2
[10:59:32.016] result() for MulticoreFuture ...
[10:59:32.017] result() for MulticoreFuture ...
[10:59:32.017] result() for MulticoreFuture ... done
[10:59:32.017] result() for MulticoreFuture ... done
[10:59:32.017] result() for MulticoreFuture ...
[10:59:32.017] result() for MulticoreFuture ... done
[10:59:32.018] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.018] - nx: 2
[10:59:32.018] - relay: TRUE
[10:59:32.018] - stdout: TRUE
[10:59:32.018] - signal: TRUE
[10:59:32.018] - resignal: FALSE
[10:59:32.018] - force: TRUE
[10:59:32.018] - relayed: [n=2] TRUE, FALSE
[10:59:32.019] - queued futures: [n=2] TRUE, FALSE
[10:59:32.019]  - until=2
[10:59:32.019]  - relaying element #2
[10:59:32.019] result() for MulticoreFuture ...
[10:59:32.019] result() for MulticoreFuture ... done
[10:59:32.019] result() for MulticoreFuture ...
[10:59:32.019] result() for MulticoreFuture ... done
[10:59:32.020] result() for MulticoreFuture ...
[10:59:32.022] result() for MulticoreFuture ... done
[10:59:32.022] result() for MulticoreFuture ...
[10:59:32.022] result() for MulticoreFuture ... done
[10:59:32.022] - relayed: [n=2] TRUE, TRUE
[10:59:32.023] - queued futures: [n=2] TRUE, TRUE
[10:59:32.023] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.023]  length: 0 (resolved future 2)
[10:59:32.023] Relaying remaining futures
[10:59:32.023] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.023] - nx: 2
[10:59:32.023] - relay: TRUE
[10:59:32.024] - stdout: TRUE
[10:59:32.024] - signal: TRUE
[10:59:32.024] - resignal: FALSE
[10:59:32.024] - force: TRUE
[10:59:32.024] - relayed: [n=2] TRUE, TRUE
[10:59:32.024] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:32.024] - relayed: [n=2] TRUE, TRUE
[10:59:32.025] - queued futures: [n=2] TRUE, TRUE
[10:59:32.025] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.025] resolve() on list ... DONE
[10:59:32.025] result() for MulticoreFuture ...
[10:59:32.025] result() for MulticoreFuture ... done
[10:59:32.025] result() for MulticoreFuture ...
[10:59:32.025] result() for MulticoreFuture ... done
[10:59:32.026] result() for MulticoreFuture ...
[10:59:32.026] result() for MulticoreFuture ... done
[10:59:32.026] result() for MulticoreFuture ...
[10:59:32.026] result() for MulticoreFuture ... done
[10:59:32.026]  - Number of value chunks collected: 2
[10:59:32.026] Resolving 2 futures (chunks) ... DONE
[10:59:32.027] Reducing values from 2 chunks ...
[10:59:32.027]  - Number of values collected after concatenation: 4
[10:59:32.027]  - Number of values expected: 4
[10:59:32.027] Reducing values from 2 chunks ... DONE
[10:59:32.027] future_mapply() ... DONE
[10:59:32.027] future_mapply() ...
[10:59:32.029] Number of chunks: 2
[10:59:32.029] getGlobalsAndPackagesXApply() ...
[10:59:32.030]  - future.globals: TRUE
[10:59:32.030] getGlobalsAndPackages() ...
[10:59:32.030] Searching for globals...
[10:59:32.031] - globals found: [1] ‘FUN’
[10:59:32.031] Searching for globals ... DONE
[10:59:32.031] Resolving globals: FALSE
[10:59:32.031] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:32.031] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:32.032] - globals: [1] ‘FUN’
[10:59:32.032] 
[10:59:32.032] getGlobalsAndPackages() ... DONE
[10:59:32.032]  - globals found/used: [n=1] ‘FUN’
[10:59:32.032]  - needed namespaces: [n=0] 
[10:59:32.032] Finding globals ... DONE
[10:59:32.032] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.032] List of 2
[10:59:32.032]  $ ...future.FUN:function (x, ...)  
[10:59:32.032]  $ MoreArgs     :List of 1
[10:59:32.032]   ..$ x: num 42
[10:59:32.032]  - attr(*, "where")=List of 2
[10:59:32.032]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.032]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.032]  - attr(*, "resolved")= logi FALSE
[10:59:32.032]  - attr(*, "total_size")= num NA
[10:59:32.036] Packages to be attached in all futures: [n=0] 
[10:59:32.036] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.036] Number of futures (= number of chunks): 2
[10:59:32.036] Launching 2 futures (chunks) ...
[10:59:32.036] Chunk #1 of 2 ...
[10:59:32.036]  - Finding globals in '...' for chunk #1 ...
[10:59:32.036] getGlobalsAndPackages() ...
[10:59:32.036] Searching for globals...
[10:59:32.037] 
[10:59:32.037] Searching for globals ... DONE
[10:59:32.037] - globals: [0] <none>
[10:59:32.037] getGlobalsAndPackages() ... DONE
[10:59:32.037]    + additional globals found: [n=0] 
[10:59:32.037]    + additional namespaces needed: [n=0] 
[10:59:32.037]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.037]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.038]  - seeds: <none>
[10:59:32.038]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.038] getGlobalsAndPackages() ...
[10:59:32.038] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.038] Resolving globals: FALSE
[10:59:32.038] The total size of the 5 globals is 286 bytes (286 bytes)
[10:59:32.039] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:59:32.039] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.039] 
[10:59:32.039] getGlobalsAndPackages() ... DONE
[10:59:32.039] run() for ‘Future’ ...
[10:59:32.039] - state: ‘created’
[10:59:32.040] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.041] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.041]   - Field: ‘label’
[10:59:32.042]   - Field: ‘local’
[10:59:32.042]   - Field: ‘owner’
[10:59:32.042]   - Field: ‘envir’
[10:59:32.042]   - Field: ‘workers’
[10:59:32.042]   - Field: ‘packages’
[10:59:32.042]   - Field: ‘gc’
[10:59:32.042]   - Field: ‘job’
[10:59:32.042]   - Field: ‘conditions’
[10:59:32.042]   - Field: ‘expr’
[10:59:32.042]   - Field: ‘uuid’
[10:59:32.042]   - Field: ‘seed’
[10:59:32.042]   - Field: ‘version’
[10:59:32.043]   - Field: ‘result’
[10:59:32.043]   - Field: ‘asynchronous’
[10:59:32.043]   - Field: ‘calls’
[10:59:32.043]   - Field: ‘globals’
[10:59:32.043]   - Field: ‘stdout’
[10:59:32.043]   - Field: ‘earlySignal’
[10:59:32.043]   - Field: ‘lazy’
[10:59:32.043]   - Field: ‘state’
[10:59:32.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.043] - Launch lazy future ...
[10:59:32.043] Packages needed by the future expression (n = 0): <none>
[10:59:32.044] Packages needed by future strategies (n = 0): <none>
[10:59:32.044] {
[10:59:32.044]     {
[10:59:32.044]         {
[10:59:32.044]             ...future.startTime <- base::Sys.time()
[10:59:32.044]             {
[10:59:32.044]                 {
[10:59:32.044]                   {
[10:59:32.044]                     {
[10:59:32.044]                       base::local({
[10:59:32.044]                         has_future <- base::requireNamespace("future", 
[10:59:32.044]                           quietly = TRUE)
[10:59:32.044]                         if (has_future) {
[10:59:32.044]                           ns <- base::getNamespace("future")
[10:59:32.044]                           version <- ns[[".package"]][["version"]]
[10:59:32.044]                           if (is.null(version)) 
[10:59:32.044]                             version <- utils::packageVersion("future")
[10:59:32.044]                         }
[10:59:32.044]                         else {
[10:59:32.044]                           version <- NULL
[10:59:32.044]                         }
[10:59:32.044]                         if (!has_future || version < "1.8.0") {
[10:59:32.044]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.044]                             "", base::R.version$version.string), 
[10:59:32.044]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.044]                               "release", "version")], collapse = " "), 
[10:59:32.044]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.044]                             info)
[10:59:32.044]                           info <- base::paste(info, collapse = "; ")
[10:59:32.044]                           if (!has_future) {
[10:59:32.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.044]                               info)
[10:59:32.044]                           }
[10:59:32.044]                           else {
[10:59:32.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.044]                               info, version)
[10:59:32.044]                           }
[10:59:32.044]                           base::stop(msg)
[10:59:32.044]                         }
[10:59:32.044]                       })
[10:59:32.044]                     }
[10:59:32.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.044]                     base::options(mc.cores = 1L)
[10:59:32.044]                   }
[10:59:32.044]                   ...future.strategy.old <- future::plan("list")
[10:59:32.044]                   options(future.plan = NULL)
[10:59:32.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.044]                 }
[10:59:32.044]                 ...future.workdir <- getwd()
[10:59:32.044]             }
[10:59:32.044]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.044]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.044]         }
[10:59:32.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.044]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.044]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.044]             base::names(...future.oldOptions))
[10:59:32.044]     }
[10:59:32.044]     if (FALSE) {
[10:59:32.044]     }
[10:59:32.044]     else {
[10:59:32.044]         if (TRUE) {
[10:59:32.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.044]                 open = "w")
[10:59:32.044]         }
[10:59:32.044]         else {
[10:59:32.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.044]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.044]         }
[10:59:32.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.044]             base::sink(type = "output", split = FALSE)
[10:59:32.044]             base::close(...future.stdout)
[10:59:32.044]         }, add = TRUE)
[10:59:32.044]     }
[10:59:32.044]     ...future.frame <- base::sys.nframe()
[10:59:32.044]     ...future.conditions <- base::list()
[10:59:32.044]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.044]     if (FALSE) {
[10:59:32.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.044]     }
[10:59:32.044]     ...future.result <- base::tryCatch({
[10:59:32.044]         base::withCallingHandlers({
[10:59:32.044]             ...future.value <- base::withVisible(base::local({
[10:59:32.044]                 withCallingHandlers({
[10:59:32.044]                   {
[10:59:32.044]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.044]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.044]                       ...future.globals.maxSize)) {
[10:59:32.044]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.044]                       on.exit(options(oopts), add = TRUE)
[10:59:32.044]                     }
[10:59:32.044]                     {
[10:59:32.044]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.044]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.044]                         USE.NAMES = FALSE)
[10:59:32.044]                       do.call(mapply, args = args)
[10:59:32.044]                     }
[10:59:32.044]                   }
[10:59:32.044]                 }, immediateCondition = function(cond) {
[10:59:32.044]                   save_rds <- function (object, pathname, ...) 
[10:59:32.044]                   {
[10:59:32.044]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.044]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.044]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.044]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.044]                         fi_tmp[["mtime"]])
[10:59:32.044]                     }
[10:59:32.044]                     tryCatch({
[10:59:32.044]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.044]                     }, error = function(ex) {
[10:59:32.044]                       msg <- conditionMessage(ex)
[10:59:32.044]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.044]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.044]                         fi_tmp[["mtime"]], msg)
[10:59:32.044]                       ex$message <- msg
[10:59:32.044]                       stop(ex)
[10:59:32.044]                     })
[10:59:32.044]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.044]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.044]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.044]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.044]                       fi <- file.info(pathname)
[10:59:32.044]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.044]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.044]                         fi[["size"]], fi[["mtime"]])
[10:59:32.044]                       stop(msg)
[10:59:32.044]                     }
[10:59:32.044]                     invisible(pathname)
[10:59:32.044]                   }
[10:59:32.044]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.044]                     rootPath = tempdir()) 
[10:59:32.044]                   {
[10:59:32.044]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.044]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.044]                       tmpdir = path, fileext = ".rds")
[10:59:32.044]                     save_rds(obj, file)
[10:59:32.044]                   }
[10:59:32.044]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.044]                   {
[10:59:32.044]                     inherits <- base::inherits
[10:59:32.044]                     invokeRestart <- base::invokeRestart
[10:59:32.044]                     is.null <- base::is.null
[10:59:32.044]                     muffled <- FALSE
[10:59:32.044]                     if (inherits(cond, "message")) {
[10:59:32.044]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.044]                       if (muffled) 
[10:59:32.044]                         invokeRestart("muffleMessage")
[10:59:32.044]                     }
[10:59:32.044]                     else if (inherits(cond, "warning")) {
[10:59:32.044]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.044]                       if (muffled) 
[10:59:32.044]                         invokeRestart("muffleWarning")
[10:59:32.044]                     }
[10:59:32.044]                     else if (inherits(cond, "condition")) {
[10:59:32.044]                       if (!is.null(pattern)) {
[10:59:32.044]                         computeRestarts <- base::computeRestarts
[10:59:32.044]                         grepl <- base::grepl
[10:59:32.044]                         restarts <- computeRestarts(cond)
[10:59:32.044]                         for (restart in restarts) {
[10:59:32.044]                           name <- restart$name
[10:59:32.044]                           if (is.null(name)) 
[10:59:32.044]                             next
[10:59:32.044]                           if (!grepl(pattern, name)) 
[10:59:32.044]                             next
[10:59:32.044]                           invokeRestart(restart)
[10:59:32.044]                           muffled <- TRUE
[10:59:32.044]                           break
[10:59:32.044]                         }
[10:59:32.044]                       }
[10:59:32.044]                     }
[10:59:32.044]                     invisible(muffled)
[10:59:32.044]                   }
[10:59:32.044]                   muffleCondition(cond)
[10:59:32.044]                 })
[10:59:32.044]             }))
[10:59:32.044]             future::FutureResult(value = ...future.value$value, 
[10:59:32.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.044]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.044]                     ...future.globalenv.names))
[10:59:32.044]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.044]         }, condition = base::local({
[10:59:32.044]             c <- base::c
[10:59:32.044]             inherits <- base::inherits
[10:59:32.044]             invokeRestart <- base::invokeRestart
[10:59:32.044]             length <- base::length
[10:59:32.044]             list <- base::list
[10:59:32.044]             seq.int <- base::seq.int
[10:59:32.044]             signalCondition <- base::signalCondition
[10:59:32.044]             sys.calls <- base::sys.calls
[10:59:32.044]             `[[` <- base::`[[`
[10:59:32.044]             `+` <- base::`+`
[10:59:32.044]             `<<-` <- base::`<<-`
[10:59:32.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.044]                   3L)]
[10:59:32.044]             }
[10:59:32.044]             function(cond) {
[10:59:32.044]                 is_error <- inherits(cond, "error")
[10:59:32.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.044]                   NULL)
[10:59:32.044]                 if (is_error) {
[10:59:32.044]                   sessionInformation <- function() {
[10:59:32.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.044]                       search = base::search(), system = base::Sys.info())
[10:59:32.044]                   }
[10:59:32.044]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.044]                     cond$call), session = sessionInformation(), 
[10:59:32.044]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.044]                   signalCondition(cond)
[10:59:32.044]                 }
[10:59:32.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.044]                 "immediateCondition"))) {
[10:59:32.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.044]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.044]                   if (TRUE && !signal) {
[10:59:32.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.044]                     {
[10:59:32.044]                       inherits <- base::inherits
[10:59:32.044]                       invokeRestart <- base::invokeRestart
[10:59:32.044]                       is.null <- base::is.null
[10:59:32.044]                       muffled <- FALSE
[10:59:32.044]                       if (inherits(cond, "message")) {
[10:59:32.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.044]                         if (muffled) 
[10:59:32.044]                           invokeRestart("muffleMessage")
[10:59:32.044]                       }
[10:59:32.044]                       else if (inherits(cond, "warning")) {
[10:59:32.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.044]                         if (muffled) 
[10:59:32.044]                           invokeRestart("muffleWarning")
[10:59:32.044]                       }
[10:59:32.044]                       else if (inherits(cond, "condition")) {
[10:59:32.044]                         if (!is.null(pattern)) {
[10:59:32.044]                           computeRestarts <- base::computeRestarts
[10:59:32.044]                           grepl <- base::grepl
[10:59:32.044]                           restarts <- computeRestarts(cond)
[10:59:32.044]                           for (restart in restarts) {
[10:59:32.044]                             name <- restart$name
[10:59:32.044]                             if (is.null(name)) 
[10:59:32.044]                               next
[10:59:32.044]                             if (!grepl(pattern, name)) 
[10:59:32.044]                               next
[10:59:32.044]                             invokeRestart(restart)
[10:59:32.044]                             muffled <- TRUE
[10:59:32.044]                             break
[10:59:32.044]                           }
[10:59:32.044]                         }
[10:59:32.044]                       }
[10:59:32.044]                       invisible(muffled)
[10:59:32.044]                     }
[10:59:32.044]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.044]                   }
[10:59:32.044]                 }
[10:59:32.044]                 else {
[10:59:32.044]                   if (TRUE) {
[10:59:32.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.044]                     {
[10:59:32.044]                       inherits <- base::inherits
[10:59:32.044]                       invokeRestart <- base::invokeRestart
[10:59:32.044]                       is.null <- base::is.null
[10:59:32.044]                       muffled <- FALSE
[10:59:32.044]                       if (inherits(cond, "message")) {
[10:59:32.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.044]                         if (muffled) 
[10:59:32.044]                           invokeRestart("muffleMessage")
[10:59:32.044]                       }
[10:59:32.044]                       else if (inherits(cond, "warning")) {
[10:59:32.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.044]                         if (muffled) 
[10:59:32.044]                           invokeRestart("muffleWarning")
[10:59:32.044]                       }
[10:59:32.044]                       else if (inherits(cond, "condition")) {
[10:59:32.044]                         if (!is.null(pattern)) {
[10:59:32.044]                           computeRestarts <- base::computeRestarts
[10:59:32.044]                           grepl <- base::grepl
[10:59:32.044]                           restarts <- computeRestarts(cond)
[10:59:32.044]                           for (restart in restarts) {
[10:59:32.044]                             name <- restart$name
[10:59:32.044]                             if (is.null(name)) 
[10:59:32.044]                               next
[10:59:32.044]                             if (!grepl(pattern, name)) 
[10:59:32.044]                               next
[10:59:32.044]                             invokeRestart(restart)
[10:59:32.044]                             muffled <- TRUE
[10:59:32.044]                             break
[10:59:32.044]                           }
[10:59:32.044]                         }
[10:59:32.044]                       }
[10:59:32.044]                       invisible(muffled)
[10:59:32.044]                     }
[10:59:32.044]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.044]                   }
[10:59:32.044]                 }
[10:59:32.044]             }
[10:59:32.044]         }))
[10:59:32.044]     }, error = function(ex) {
[10:59:32.044]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.044]                 ...future.rng), started = ...future.startTime, 
[10:59:32.044]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.044]             version = "1.8"), class = "FutureResult")
[10:59:32.044]     }, finally = {
[10:59:32.044]         if (!identical(...future.workdir, getwd())) 
[10:59:32.044]             setwd(...future.workdir)
[10:59:32.044]         {
[10:59:32.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.044]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.044]             }
[10:59:32.044]             base::options(...future.oldOptions)
[10:59:32.044]             if (.Platform$OS.type == "windows") {
[10:59:32.044]                 old_names <- names(...future.oldEnvVars)
[10:59:32.044]                 envs <- base::Sys.getenv()
[10:59:32.044]                 names <- names(envs)
[10:59:32.044]                 common <- intersect(names, old_names)
[10:59:32.044]                 added <- setdiff(names, old_names)
[10:59:32.044]                 removed <- setdiff(old_names, names)
[10:59:32.044]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.044]                   envs[common]]
[10:59:32.044]                 NAMES <- toupper(changed)
[10:59:32.044]                 args <- list()
[10:59:32.044]                 for (kk in seq_along(NAMES)) {
[10:59:32.044]                   name <- changed[[kk]]
[10:59:32.044]                   NAME <- NAMES[[kk]]
[10:59:32.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.044]                     next
[10:59:32.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.044]                 }
[10:59:32.044]                 NAMES <- toupper(added)
[10:59:32.044]                 for (kk in seq_along(NAMES)) {
[10:59:32.044]                   name <- added[[kk]]
[10:59:32.044]                   NAME <- NAMES[[kk]]
[10:59:32.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.044]                     next
[10:59:32.044]                   args[[name]] <- ""
[10:59:32.044]                 }
[10:59:32.044]                 NAMES <- toupper(removed)
[10:59:32.044]                 for (kk in seq_along(NAMES)) {
[10:59:32.044]                   name <- removed[[kk]]
[10:59:32.044]                   NAME <- NAMES[[kk]]
[10:59:32.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.044]                     next
[10:59:32.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.044]                 }
[10:59:32.044]                 if (length(args) > 0) 
[10:59:32.044]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.044]             }
[10:59:32.044]             else {
[10:59:32.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.044]             }
[10:59:32.044]             {
[10:59:32.044]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.044]                   0L) {
[10:59:32.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.044]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.044]                   base::options(opts)
[10:59:32.044]                 }
[10:59:32.044]                 {
[10:59:32.044]                   {
[10:59:32.044]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.044]                     NULL
[10:59:32.044]                   }
[10:59:32.044]                   options(future.plan = NULL)
[10:59:32.044]                   if (is.na(NA_character_)) 
[10:59:32.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.044]                     .init = FALSE)
[10:59:32.044]                 }
[10:59:32.044]             }
[10:59:32.044]         }
[10:59:32.044]     })
[10:59:32.044]     if (TRUE) {
[10:59:32.044]         base::sink(type = "output", split = FALSE)
[10:59:32.044]         if (TRUE) {
[10:59:32.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.044]         }
[10:59:32.044]         else {
[10:59:32.044]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.044]         }
[10:59:32.044]         base::close(...future.stdout)
[10:59:32.044]         ...future.stdout <- NULL
[10:59:32.044]     }
[10:59:32.044]     ...future.result$conditions <- ...future.conditions
[10:59:32.044]     ...future.result$finished <- base::Sys.time()
[10:59:32.044]     ...future.result
[10:59:32.044] }
[10:59:32.046] assign_globals() ...
[10:59:32.046] List of 5
[10:59:32.046]  $ ...future.FUN            :function (x, ...)  
[10:59:32.046]  $ MoreArgs                 :List of 1
[10:59:32.046]   ..$ x: num 42
[10:59:32.046]  $ ...future.elements_ii    :List of 1
[10:59:32.046]   ..$ times:List of 2
[10:59:32.046]   .. ..$ : int 1
[10:59:32.046]   .. ..$ : int 2
[10:59:32.046]  $ ...future.seeds_ii       : NULL
[10:59:32.046]  $ ...future.globals.maxSize: NULL
[10:59:32.046]  - attr(*, "where")=List of 5
[10:59:32.046]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.046]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.046]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.046]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.046]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.046]  - attr(*, "resolved")= logi FALSE
[10:59:32.046]  - attr(*, "total_size")= num 286
[10:59:32.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.046]  - attr(*, "already-done")= logi TRUE
[10:59:32.053] - copied ‘...future.FUN’ to environment
[10:59:32.053] - copied ‘MoreArgs’ to environment
[10:59:32.053] - copied ‘...future.elements_ii’ to environment
[10:59:32.053] - copied ‘...future.seeds_ii’ to environment
[10:59:32.053] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.053] assign_globals() ... done
[10:59:32.053] requestCore(): workers = 2
[10:59:32.055] MulticoreFuture started
[10:59:32.056] - Launch lazy future ... done
[10:59:32.056] run() for ‘MulticoreFuture’ ... done
[10:59:32.056] plan(): Setting new future strategy stack:
[10:59:32.056] Created future:
[10:59:32.057] List of future strategies:
[10:59:32.057] 1. sequential:
[10:59:32.057]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.057]    - tweaked: FALSE
[10:59:32.057]    - call: NULL
[10:59:32.058] plan(): nbrOfWorkers() = 1
[10:59:32.060] plan(): Setting new future strategy stack:
[10:59:32.060] List of future strategies:
[10:59:32.060] 1. multicore:
[10:59:32.060]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.060]    - tweaked: FALSE
[10:59:32.060]    - call: plan(strategy)
[10:59:32.063] plan(): nbrOfWorkers() = 2
[10:59:32.057] MulticoreFuture:
[10:59:32.057] Label: ‘future_mapply-1’
[10:59:32.057] Expression:
[10:59:32.057] {
[10:59:32.057]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.057]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.057]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.057]         on.exit(options(oopts), add = TRUE)
[10:59:32.057]     }
[10:59:32.057]     {
[10:59:32.057]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.057]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.057]         do.call(mapply, args = args)
[10:59:32.057]     }
[10:59:32.057] }
[10:59:32.057] Lazy evaluation: FALSE
[10:59:32.057] Asynchronous evaluation: TRUE
[10:59:32.057] Local evaluation: TRUE
[10:59:32.057] Environment: R_GlobalEnv
[10:59:32.057] Capture standard output: TRUE
[10:59:32.057] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.057] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.057] Packages: <none>
[10:59:32.057] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.057] Resolved: TRUE
[10:59:32.057] Value: <not collected>
[10:59:32.057] Conditions captured: <none>
[10:59:32.057] Early signaling: FALSE
[10:59:32.057] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.057] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.064] Chunk #1 of 2 ... DONE
[10:59:32.064] Chunk #2 of 2 ...
[10:59:32.065]  - Finding globals in '...' for chunk #2 ...
[10:59:32.065] getGlobalsAndPackages() ...
[10:59:32.065] Searching for globals...
[10:59:32.066] 
[10:59:32.066] Searching for globals ... DONE
[10:59:32.066] - globals: [0] <none>
[10:59:32.066] getGlobalsAndPackages() ... DONE
[10:59:32.066]    + additional globals found: [n=0] 
[10:59:32.066]    + additional namespaces needed: [n=0] 
[10:59:32.066]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:32.066]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.067]  - seeds: <none>
[10:59:32.067]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.067] getGlobalsAndPackages() ...
[10:59:32.067] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.067] Resolving globals: FALSE
[10:59:32.068] The total size of the 5 globals is 286 bytes (286 bytes)
[10:59:32.069] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:59:32.069] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.069] 
[10:59:32.069] getGlobalsAndPackages() ... DONE
[10:59:32.070] run() for ‘Future’ ...
[10:59:32.070] - state: ‘created’
[10:59:32.070] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.072] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.073]   - Field: ‘label’
[10:59:32.073]   - Field: ‘local’
[10:59:32.073]   - Field: ‘owner’
[10:59:32.073]   - Field: ‘envir’
[10:59:32.073]   - Field: ‘workers’
[10:59:32.073]   - Field: ‘packages’
[10:59:32.074]   - Field: ‘gc’
[10:59:32.074]   - Field: ‘job’
[10:59:32.074]   - Field: ‘conditions’
[10:59:32.074]   - Field: ‘expr’
[10:59:32.074]   - Field: ‘uuid’
[10:59:32.074]   - Field: ‘seed’
[10:59:32.074]   - Field: ‘version’
[10:59:32.075]   - Field: ‘result’
[10:59:32.075]   - Field: ‘asynchronous’
[10:59:32.075]   - Field: ‘calls’
[10:59:32.075]   - Field: ‘globals’
[10:59:32.075]   - Field: ‘stdout’
[10:59:32.075]   - Field: ‘earlySignal’
[10:59:32.075]   - Field: ‘lazy’
[10:59:32.075]   - Field: ‘state’
[10:59:32.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.076] - Launch lazy future ...
[10:59:32.076] Packages needed by the future expression (n = 0): <none>
[10:59:32.076] Packages needed by future strategies (n = 0): <none>
[10:59:32.077] {
[10:59:32.077]     {
[10:59:32.077]         {
[10:59:32.077]             ...future.startTime <- base::Sys.time()
[10:59:32.077]             {
[10:59:32.077]                 {
[10:59:32.077]                   {
[10:59:32.077]                     {
[10:59:32.077]                       base::local({
[10:59:32.077]                         has_future <- base::requireNamespace("future", 
[10:59:32.077]                           quietly = TRUE)
[10:59:32.077]                         if (has_future) {
[10:59:32.077]                           ns <- base::getNamespace("future")
[10:59:32.077]                           version <- ns[[".package"]][["version"]]
[10:59:32.077]                           if (is.null(version)) 
[10:59:32.077]                             version <- utils::packageVersion("future")
[10:59:32.077]                         }
[10:59:32.077]                         else {
[10:59:32.077]                           version <- NULL
[10:59:32.077]                         }
[10:59:32.077]                         if (!has_future || version < "1.8.0") {
[10:59:32.077]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.077]                             "", base::R.version$version.string), 
[10:59:32.077]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.077]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.077]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.077]                               "release", "version")], collapse = " "), 
[10:59:32.077]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.077]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.077]                             info)
[10:59:32.077]                           info <- base::paste(info, collapse = "; ")
[10:59:32.077]                           if (!has_future) {
[10:59:32.077]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.077]                               info)
[10:59:32.077]                           }
[10:59:32.077]                           else {
[10:59:32.077]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.077]                               info, version)
[10:59:32.077]                           }
[10:59:32.077]                           base::stop(msg)
[10:59:32.077]                         }
[10:59:32.077]                       })
[10:59:32.077]                     }
[10:59:32.077]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.077]                     base::options(mc.cores = 1L)
[10:59:32.077]                   }
[10:59:32.077]                   ...future.strategy.old <- future::plan("list")
[10:59:32.077]                   options(future.plan = NULL)
[10:59:32.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.077]                 }
[10:59:32.077]                 ...future.workdir <- getwd()
[10:59:32.077]             }
[10:59:32.077]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.077]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.077]         }
[10:59:32.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.077]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.077]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.077]             base::names(...future.oldOptions))
[10:59:32.077]     }
[10:59:32.077]     if (FALSE) {
[10:59:32.077]     }
[10:59:32.077]     else {
[10:59:32.077]         if (TRUE) {
[10:59:32.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.077]                 open = "w")
[10:59:32.077]         }
[10:59:32.077]         else {
[10:59:32.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.077]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.077]         }
[10:59:32.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.077]             base::sink(type = "output", split = FALSE)
[10:59:32.077]             base::close(...future.stdout)
[10:59:32.077]         }, add = TRUE)
[10:59:32.077]     }
[10:59:32.077]     ...future.frame <- base::sys.nframe()
[10:59:32.077]     ...future.conditions <- base::list()
[10:59:32.077]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.077]     if (FALSE) {
[10:59:32.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.077]     }
[10:59:32.077]     ...future.result <- base::tryCatch({
[10:59:32.077]         base::withCallingHandlers({
[10:59:32.077]             ...future.value <- base::withVisible(base::local({
[10:59:32.077]                 withCallingHandlers({
[10:59:32.077]                   {
[10:59:32.077]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.077]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.077]                       ...future.globals.maxSize)) {
[10:59:32.077]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.077]                       on.exit(options(oopts), add = TRUE)
[10:59:32.077]                     }
[10:59:32.077]                     {
[10:59:32.077]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.077]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.077]                         USE.NAMES = FALSE)
[10:59:32.077]                       do.call(mapply, args = args)
[10:59:32.077]                     }
[10:59:32.077]                   }
[10:59:32.077]                 }, immediateCondition = function(cond) {
[10:59:32.077]                   save_rds <- function (object, pathname, ...) 
[10:59:32.077]                   {
[10:59:32.077]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.077]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.077]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.077]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.077]                         fi_tmp[["mtime"]])
[10:59:32.077]                     }
[10:59:32.077]                     tryCatch({
[10:59:32.077]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.077]                     }, error = function(ex) {
[10:59:32.077]                       msg <- conditionMessage(ex)
[10:59:32.077]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.077]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.077]                         fi_tmp[["mtime"]], msg)
[10:59:32.077]                       ex$message <- msg
[10:59:32.077]                       stop(ex)
[10:59:32.077]                     })
[10:59:32.077]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.077]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.077]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.077]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.077]                       fi <- file.info(pathname)
[10:59:32.077]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.077]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.077]                         fi[["size"]], fi[["mtime"]])
[10:59:32.077]                       stop(msg)
[10:59:32.077]                     }
[10:59:32.077]                     invisible(pathname)
[10:59:32.077]                   }
[10:59:32.077]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.077]                     rootPath = tempdir()) 
[10:59:32.077]                   {
[10:59:32.077]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.077]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.077]                       tmpdir = path, fileext = ".rds")
[10:59:32.077]                     save_rds(obj, file)
[10:59:32.077]                   }
[10:59:32.077]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.077]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.077]                   {
[10:59:32.077]                     inherits <- base::inherits
[10:59:32.077]                     invokeRestart <- base::invokeRestart
[10:59:32.077]                     is.null <- base::is.null
[10:59:32.077]                     muffled <- FALSE
[10:59:32.077]                     if (inherits(cond, "message")) {
[10:59:32.077]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.077]                       if (muffled) 
[10:59:32.077]                         invokeRestart("muffleMessage")
[10:59:32.077]                     }
[10:59:32.077]                     else if (inherits(cond, "warning")) {
[10:59:32.077]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.077]                       if (muffled) 
[10:59:32.077]                         invokeRestart("muffleWarning")
[10:59:32.077]                     }
[10:59:32.077]                     else if (inherits(cond, "condition")) {
[10:59:32.077]                       if (!is.null(pattern)) {
[10:59:32.077]                         computeRestarts <- base::computeRestarts
[10:59:32.077]                         grepl <- base::grepl
[10:59:32.077]                         restarts <- computeRestarts(cond)
[10:59:32.077]                         for (restart in restarts) {
[10:59:32.077]                           name <- restart$name
[10:59:32.077]                           if (is.null(name)) 
[10:59:32.077]                             next
[10:59:32.077]                           if (!grepl(pattern, name)) 
[10:59:32.077]                             next
[10:59:32.077]                           invokeRestart(restart)
[10:59:32.077]                           muffled <- TRUE
[10:59:32.077]                           break
[10:59:32.077]                         }
[10:59:32.077]                       }
[10:59:32.077]                     }
[10:59:32.077]                     invisible(muffled)
[10:59:32.077]                   }
[10:59:32.077]                   muffleCondition(cond)
[10:59:32.077]                 })
[10:59:32.077]             }))
[10:59:32.077]             future::FutureResult(value = ...future.value$value, 
[10:59:32.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.077]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.077]                     ...future.globalenv.names))
[10:59:32.077]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.077]         }, condition = base::local({
[10:59:32.077]             c <- base::c
[10:59:32.077]             inherits <- base::inherits
[10:59:32.077]             invokeRestart <- base::invokeRestart
[10:59:32.077]             length <- base::length
[10:59:32.077]             list <- base::list
[10:59:32.077]             seq.int <- base::seq.int
[10:59:32.077]             signalCondition <- base::signalCondition
[10:59:32.077]             sys.calls <- base::sys.calls
[10:59:32.077]             `[[` <- base::`[[`
[10:59:32.077]             `+` <- base::`+`
[10:59:32.077]             `<<-` <- base::`<<-`
[10:59:32.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.077]                   3L)]
[10:59:32.077]             }
[10:59:32.077]             function(cond) {
[10:59:32.077]                 is_error <- inherits(cond, "error")
[10:59:32.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.077]                   NULL)
[10:59:32.077]                 if (is_error) {
[10:59:32.077]                   sessionInformation <- function() {
[10:59:32.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.077]                       search = base::search(), system = base::Sys.info())
[10:59:32.077]                   }
[10:59:32.077]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.077]                     cond$call), session = sessionInformation(), 
[10:59:32.077]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.077]                   signalCondition(cond)
[10:59:32.077]                 }
[10:59:32.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.077]                 "immediateCondition"))) {
[10:59:32.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.077]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.077]                   if (TRUE && !signal) {
[10:59:32.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.077]                     {
[10:59:32.077]                       inherits <- base::inherits
[10:59:32.077]                       invokeRestart <- base::invokeRestart
[10:59:32.077]                       is.null <- base::is.null
[10:59:32.077]                       muffled <- FALSE
[10:59:32.077]                       if (inherits(cond, "message")) {
[10:59:32.077]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.077]                         if (muffled) 
[10:59:32.077]                           invokeRestart("muffleMessage")
[10:59:32.077]                       }
[10:59:32.077]                       else if (inherits(cond, "warning")) {
[10:59:32.077]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.077]                         if (muffled) 
[10:59:32.077]                           invokeRestart("muffleWarning")
[10:59:32.077]                       }
[10:59:32.077]                       else if (inherits(cond, "condition")) {
[10:59:32.077]                         if (!is.null(pattern)) {
[10:59:32.077]                           computeRestarts <- base::computeRestarts
[10:59:32.077]                           grepl <- base::grepl
[10:59:32.077]                           restarts <- computeRestarts(cond)
[10:59:32.077]                           for (restart in restarts) {
[10:59:32.077]                             name <- restart$name
[10:59:32.077]                             if (is.null(name)) 
[10:59:32.077]                               next
[10:59:32.077]                             if (!grepl(pattern, name)) 
[10:59:32.077]                               next
[10:59:32.077]                             invokeRestart(restart)
[10:59:32.077]                             muffled <- TRUE
[10:59:32.077]                             break
[10:59:32.077]                           }
[10:59:32.077]                         }
[10:59:32.077]                       }
[10:59:32.077]                       invisible(muffled)
[10:59:32.077]                     }
[10:59:32.077]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.077]                   }
[10:59:32.077]                 }
[10:59:32.077]                 else {
[10:59:32.077]                   if (TRUE) {
[10:59:32.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.077]                     {
[10:59:32.077]                       inherits <- base::inherits
[10:59:32.077]                       invokeRestart <- base::invokeRestart
[10:59:32.077]                       is.null <- base::is.null
[10:59:32.077]                       muffled <- FALSE
[10:59:32.077]                       if (inherits(cond, "message")) {
[10:59:32.077]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.077]                         if (muffled) 
[10:59:32.077]                           invokeRestart("muffleMessage")
[10:59:32.077]                       }
[10:59:32.077]                       else if (inherits(cond, "warning")) {
[10:59:32.077]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.077]                         if (muffled) 
[10:59:32.077]                           invokeRestart("muffleWarning")
[10:59:32.077]                       }
[10:59:32.077]                       else if (inherits(cond, "condition")) {
[10:59:32.077]                         if (!is.null(pattern)) {
[10:59:32.077]                           computeRestarts <- base::computeRestarts
[10:59:32.077]                           grepl <- base::grepl
[10:59:32.077]                           restarts <- computeRestarts(cond)
[10:59:32.077]                           for (restart in restarts) {
[10:59:32.077]                             name <- restart$name
[10:59:32.077]                             if (is.null(name)) 
[10:59:32.077]                               next
[10:59:32.077]                             if (!grepl(pattern, name)) 
[10:59:32.077]                               next
[10:59:32.077]                             invokeRestart(restart)
[10:59:32.077]                             muffled <- TRUE
[10:59:32.077]                             break
[10:59:32.077]                           }
[10:59:32.077]                         }
[10:59:32.077]                       }
[10:59:32.077]                       invisible(muffled)
[10:59:32.077]                     }
[10:59:32.077]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.077]                   }
[10:59:32.077]                 }
[10:59:32.077]             }
[10:59:32.077]         }))
[10:59:32.077]     }, error = function(ex) {
[10:59:32.077]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.077]                 ...future.rng), started = ...future.startTime, 
[10:59:32.077]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.077]             version = "1.8"), class = "FutureResult")
[10:59:32.077]     }, finally = {
[10:59:32.077]         if (!identical(...future.workdir, getwd())) 
[10:59:32.077]             setwd(...future.workdir)
[10:59:32.077]         {
[10:59:32.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.077]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.077]             }
[10:59:32.077]             base::options(...future.oldOptions)
[10:59:32.077]             if (.Platform$OS.type == "windows") {
[10:59:32.077]                 old_names <- names(...future.oldEnvVars)
[10:59:32.077]                 envs <- base::Sys.getenv()
[10:59:32.077]                 names <- names(envs)
[10:59:32.077]                 common <- intersect(names, old_names)
[10:59:32.077]                 added <- setdiff(names, old_names)
[10:59:32.077]                 removed <- setdiff(old_names, names)
[10:59:32.077]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.077]                   envs[common]]
[10:59:32.077]                 NAMES <- toupper(changed)
[10:59:32.077]                 args <- list()
[10:59:32.077]                 for (kk in seq_along(NAMES)) {
[10:59:32.077]                   name <- changed[[kk]]
[10:59:32.077]                   NAME <- NAMES[[kk]]
[10:59:32.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.077]                     next
[10:59:32.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.077]                 }
[10:59:32.077]                 NAMES <- toupper(added)
[10:59:32.077]                 for (kk in seq_along(NAMES)) {
[10:59:32.077]                   name <- added[[kk]]
[10:59:32.077]                   NAME <- NAMES[[kk]]
[10:59:32.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.077]                     next
[10:59:32.077]                   args[[name]] <- ""
[10:59:32.077]                 }
[10:59:32.077]                 NAMES <- toupper(removed)
[10:59:32.077]                 for (kk in seq_along(NAMES)) {
[10:59:32.077]                   name <- removed[[kk]]
[10:59:32.077]                   NAME <- NAMES[[kk]]
[10:59:32.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.077]                     next
[10:59:32.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.077]                 }
[10:59:32.077]                 if (length(args) > 0) 
[10:59:32.077]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.077]             }
[10:59:32.077]             else {
[10:59:32.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.077]             }
[10:59:32.077]             {
[10:59:32.077]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.077]                   0L) {
[10:59:32.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.077]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.077]                   base::options(opts)
[10:59:32.077]                 }
[10:59:32.077]                 {
[10:59:32.077]                   {
[10:59:32.077]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.077]                     NULL
[10:59:32.077]                   }
[10:59:32.077]                   options(future.plan = NULL)
[10:59:32.077]                   if (is.na(NA_character_)) 
[10:59:32.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.077]                     .init = FALSE)
[10:59:32.077]                 }
[10:59:32.077]             }
[10:59:32.077]         }
[10:59:32.077]     })
[10:59:32.077]     if (TRUE) {
[10:59:32.077]         base::sink(type = "output", split = FALSE)
[10:59:32.077]         if (TRUE) {
[10:59:32.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.077]         }
[10:59:32.077]         else {
[10:59:32.077]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.077]         }
[10:59:32.077]         base::close(...future.stdout)
[10:59:32.077]         ...future.stdout <- NULL
[10:59:32.077]     }
[10:59:32.077]     ...future.result$conditions <- ...future.conditions
[10:59:32.077]     ...future.result$finished <- base::Sys.time()
[10:59:32.077]     ...future.result
[10:59:32.077] }
[10:59:32.081] assign_globals() ...
[10:59:32.081] List of 5
[10:59:32.081]  $ ...future.FUN            :function (x, ...)  
[10:59:32.081]  $ MoreArgs                 :List of 1
[10:59:32.081]   ..$ x: num 42
[10:59:32.081]  $ ...future.elements_ii    :List of 1
[10:59:32.081]   ..$ times:List of 2
[10:59:32.081]   .. ..$ : int 3
[10:59:32.081]   .. ..$ : int 4
[10:59:32.081]  $ ...future.seeds_ii       : NULL
[10:59:32.081]  $ ...future.globals.maxSize: NULL
[10:59:32.081]  - attr(*, "where")=List of 5
[10:59:32.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.081]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.081]  - attr(*, "resolved")= logi FALSE
[10:59:32.081]  - attr(*, "total_size")= num 286
[10:59:32.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.081]  - attr(*, "already-done")= logi TRUE
[10:59:32.091] - copied ‘...future.FUN’ to environment
[10:59:32.091] - copied ‘MoreArgs’ to environment
[10:59:32.092] - copied ‘...future.elements_ii’ to environment
[10:59:32.092] - copied ‘...future.seeds_ii’ to environment
[10:59:32.092] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.092] assign_globals() ... done
[10:59:32.092] requestCore(): workers = 2
[10:59:32.095] MulticoreFuture started
[10:59:32.095] - Launch lazy future ... done
[10:59:32.096] run() for ‘MulticoreFuture’ ... done
[10:59:32.096] plan(): Setting new future strategy stack:
[10:59:32.096] Created future:
[10:59:32.096] List of future strategies:
[10:59:32.096] 1. sequential:
[10:59:32.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.096]    - tweaked: FALSE
[10:59:32.096]    - call: NULL
[10:59:32.098] plan(): nbrOfWorkers() = 1
[10:59:32.101] plan(): Setting new future strategy stack:
[10:59:32.101] List of future strategies:
[10:59:32.101] 1. multicore:
[10:59:32.101]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.101]    - tweaked: FALSE
[10:59:32.101]    - call: plan(strategy)
[10:59:32.105] plan(): nbrOfWorkers() = 2
[10:59:32.097] MulticoreFuture:
[10:59:32.097] Label: ‘future_mapply-2’
[10:59:32.097] Expression:
[10:59:32.097] {
[10:59:32.097]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.097]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.097]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.097]         on.exit(options(oopts), add = TRUE)
[10:59:32.097]     }
[10:59:32.097]     {
[10:59:32.097]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.097]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.097]         do.call(mapply, args = args)
[10:59:32.097]     }
[10:59:32.097] }
[10:59:32.097] Lazy evaluation: FALSE
[10:59:32.097] Asynchronous evaluation: TRUE
[10:59:32.097] Local evaluation: TRUE
[10:59:32.097] Environment: R_GlobalEnv
[10:59:32.097] Capture standard output: TRUE
[10:59:32.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.097] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.097] Packages: <none>
[10:59:32.097] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.097] Resolved: TRUE
[10:59:32.097] Value: <not collected>
[10:59:32.097] Conditions captured: <none>
[10:59:32.097] Early signaling: FALSE
[10:59:32.097] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.097] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.106] Chunk #2 of 2 ... DONE
[10:59:32.106] Launching 2 futures (chunks) ... DONE
[10:59:32.107] Resolving 2 futures (chunks) ...
[10:59:32.107] resolve() on list ...
[10:59:32.107]  recursive: 0
[10:59:32.107]  length: 2
[10:59:32.107] 
[10:59:32.108] Future #1
[10:59:32.108] result() for MulticoreFuture ...
[10:59:32.109] result() for MulticoreFuture ...
[10:59:32.109] result() for MulticoreFuture ... done
[10:59:32.109] result() for MulticoreFuture ... done
[10:59:32.109] result() for MulticoreFuture ...
[10:59:32.109] result() for MulticoreFuture ... done
[10:59:32.110] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.110] - nx: 2
[10:59:32.110] - relay: TRUE
[10:59:32.110] - stdout: TRUE
[10:59:32.110] - signal: TRUE
[10:59:32.110] - resignal: FALSE
[10:59:32.110] - force: TRUE
[10:59:32.111] - relayed: [n=2] FALSE, FALSE
[10:59:32.111] - queued futures: [n=2] FALSE, FALSE
[10:59:32.111]  - until=1
[10:59:32.111]  - relaying element #1
[10:59:32.111] result() for MulticoreFuture ...
[10:59:32.111] result() for MulticoreFuture ... done
[10:59:32.112] result() for MulticoreFuture ...
[10:59:32.112] result() for MulticoreFuture ... done
[10:59:32.112] result() for MulticoreFuture ...
[10:59:32.112] result() for MulticoreFuture ... done
[10:59:32.112] result() for MulticoreFuture ...
[10:59:32.112] result() for MulticoreFuture ... done
[10:59:32.113] - relayed: [n=2] TRUE, FALSE
[10:59:32.113] - queued futures: [n=2] TRUE, FALSE
[10:59:32.113] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.113]  length: 1 (resolved future 1)
[10:59:32.113] Future #2
[10:59:32.113] result() for MulticoreFuture ...
[10:59:32.114] result() for MulticoreFuture ...
[10:59:32.114] result() for MulticoreFuture ... done
[10:59:32.114] result() for MulticoreFuture ... done
[10:59:32.115] result() for MulticoreFuture ...
[10:59:32.115] result() for MulticoreFuture ... done
[10:59:32.115] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.115] - nx: 2
[10:59:32.115] - relay: TRUE
[10:59:32.115] - stdout: TRUE
[10:59:32.115] - signal: TRUE
[10:59:32.115] - resignal: FALSE
[10:59:32.115] - force: TRUE
[10:59:32.116] - relayed: [n=2] TRUE, FALSE
[10:59:32.116] - queued futures: [n=2] TRUE, FALSE
[10:59:32.116]  - until=2
[10:59:32.116]  - relaying element #2
[10:59:32.116] result() for MulticoreFuture ...
[10:59:32.116] result() for MulticoreFuture ... done
[10:59:32.116] result() for MulticoreFuture ...
[10:59:32.116] result() for MulticoreFuture ... done
[10:59:32.116] result() for MulticoreFuture ...
[10:59:32.116] result() for MulticoreFuture ... done
[10:59:32.117] result() for MulticoreFuture ...
[10:59:32.117] result() for MulticoreFuture ... done
[10:59:32.117] - relayed: [n=2] TRUE, TRUE
[10:59:32.117] - queued futures: [n=2] TRUE, TRUE
[10:59:32.117] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.117]  length: 0 (resolved future 2)
[10:59:32.117] Relaying remaining futures
[10:59:32.117] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.117] - nx: 2
[10:59:32.118] - relay: TRUE
[10:59:32.118] - stdout: TRUE
[10:59:32.118] - signal: TRUE
[10:59:32.118] - resignal: FALSE
[10:59:32.118] - force: TRUE
[10:59:32.118] - relayed: [n=2] TRUE, TRUE
[10:59:32.118] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:32.118] - relayed: [n=2] TRUE, TRUE
[10:59:32.118] - queued futures: [n=2] TRUE, TRUE
[10:59:32.118] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.119] resolve() on list ... DONE
[10:59:32.119] result() for MulticoreFuture ...
[10:59:32.119] result() for MulticoreFuture ... done
[10:59:32.119] result() for MulticoreFuture ...
[10:59:32.119] result() for MulticoreFuture ... done
[10:59:32.119] result() for MulticoreFuture ...
[10:59:32.119] result() for MulticoreFuture ... done
[10:59:32.119] result() for MulticoreFuture ...
[10:59:32.119] result() for MulticoreFuture ... done
[10:59:32.120]  - Number of value chunks collected: 2
[10:59:32.120] Resolving 2 futures (chunks) ... DONE
[10:59:32.120] Reducing values from 2 chunks ...
[10:59:32.120]  - Number of values collected after concatenation: 4
[10:59:32.120]  - Number of values expected: 4
[10:59:32.120] Reducing values from 2 chunks ... DONE
[10:59:32.120] future_mapply() ... DONE
[10:59:32.120] future_mapply() ...
[10:59:32.122] Number of chunks: 2
[10:59:32.123] getGlobalsAndPackagesXApply() ...
[10:59:32.123]  - future.globals: TRUE
[10:59:32.123] getGlobalsAndPackages() ...
[10:59:32.123] Searching for globals...
[10:59:32.124] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:59:32.125] Searching for globals ... DONE
[10:59:32.125] Resolving globals: FALSE
[10:59:32.125] The total size of the 1 globals is 414 bytes (414 bytes)
[10:59:32.125] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:59:32.126] - globals: [1] ‘FUN’
[10:59:32.126] 
[10:59:32.126] getGlobalsAndPackages() ... DONE
[10:59:32.126]  - globals found/used: [n=1] ‘FUN’
[10:59:32.126]  - needed namespaces: [n=0] 
[10:59:32.126] Finding globals ... DONE
[10:59:32.126] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.126] List of 2
[10:59:32.126]  $ ...future.FUN:function (x, y)  
[10:59:32.126]  $ MoreArgs     : NULL
[10:59:32.126]  - attr(*, "where")=List of 2
[10:59:32.126]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.126]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.126]  - attr(*, "resolved")= logi FALSE
[10:59:32.126]  - attr(*, "total_size")= num NA
[10:59:32.131] Packages to be attached in all futures: [n=0] 
[10:59:32.131] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.132] Number of futures (= number of chunks): 2
[10:59:32.132] Launching 2 futures (chunks) ...
[10:59:32.132] Chunk #1 of 2 ...
[10:59:32.132]  - Finding globals in '...' for chunk #1 ...
[10:59:32.132] getGlobalsAndPackages() ...
[10:59:32.132] Searching for globals...
[10:59:32.133] 
[10:59:32.133] Searching for globals ... DONE
[10:59:32.133] - globals: [0] <none>
[10:59:32.133] getGlobalsAndPackages() ... DONE
[10:59:32.133]    + additional globals found: [n=0] 
[10:59:32.133]    + additional namespaces needed: [n=0] 
[10:59:32.133]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.133]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.134]  - seeds: <none>
[10:59:32.134]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.134] getGlobalsAndPackages() ...
[10:59:32.134] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.134] Resolving globals: FALSE
[10:59:32.134] The total size of the 5 globals is 645 bytes (645 bytes)
[10:59:32.135] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 645 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.135] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.135] 
[10:59:32.135] getGlobalsAndPackages() ... DONE
[10:59:32.135] run() for ‘Future’ ...
[10:59:32.136] - state: ‘created’
[10:59:32.136] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.137] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.137]   - Field: ‘label’
[10:59:32.138]   - Field: ‘local’
[10:59:32.138]   - Field: ‘owner’
[10:59:32.138]   - Field: ‘envir’
[10:59:32.138]   - Field: ‘workers’
[10:59:32.138]   - Field: ‘packages’
[10:59:32.138]   - Field: ‘gc’
[10:59:32.138]   - Field: ‘job’
[10:59:32.138]   - Field: ‘conditions’
[10:59:32.138]   - Field: ‘expr’
[10:59:32.138]   - Field: ‘uuid’
[10:59:32.138]   - Field: ‘seed’
[10:59:32.138]   - Field: ‘version’
[10:59:32.139]   - Field: ‘result’
[10:59:32.139]   - Field: ‘asynchronous’
[10:59:32.139]   - Field: ‘calls’
[10:59:32.139]   - Field: ‘globals’
[10:59:32.139]   - Field: ‘stdout’
[10:59:32.139]   - Field: ‘earlySignal’
[10:59:32.139]   - Field: ‘lazy’
[10:59:32.139]   - Field: ‘state’
[10:59:32.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.139] - Launch lazy future ...
[10:59:32.140] Packages needed by the future expression (n = 0): <none>
[10:59:32.140] Packages needed by future strategies (n = 0): <none>
[10:59:32.140] {
[10:59:32.140]     {
[10:59:32.140]         {
[10:59:32.140]             ...future.startTime <- base::Sys.time()
[10:59:32.140]             {
[10:59:32.140]                 {
[10:59:32.140]                   {
[10:59:32.140]                     {
[10:59:32.140]                       base::local({
[10:59:32.140]                         has_future <- base::requireNamespace("future", 
[10:59:32.140]                           quietly = TRUE)
[10:59:32.140]                         if (has_future) {
[10:59:32.140]                           ns <- base::getNamespace("future")
[10:59:32.140]                           version <- ns[[".package"]][["version"]]
[10:59:32.140]                           if (is.null(version)) 
[10:59:32.140]                             version <- utils::packageVersion("future")
[10:59:32.140]                         }
[10:59:32.140]                         else {
[10:59:32.140]                           version <- NULL
[10:59:32.140]                         }
[10:59:32.140]                         if (!has_future || version < "1.8.0") {
[10:59:32.140]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.140]                             "", base::R.version$version.string), 
[10:59:32.140]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.140]                               "release", "version")], collapse = " "), 
[10:59:32.140]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.140]                             info)
[10:59:32.140]                           info <- base::paste(info, collapse = "; ")
[10:59:32.140]                           if (!has_future) {
[10:59:32.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.140]                               info)
[10:59:32.140]                           }
[10:59:32.140]                           else {
[10:59:32.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.140]                               info, version)
[10:59:32.140]                           }
[10:59:32.140]                           base::stop(msg)
[10:59:32.140]                         }
[10:59:32.140]                       })
[10:59:32.140]                     }
[10:59:32.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.140]                     base::options(mc.cores = 1L)
[10:59:32.140]                   }
[10:59:32.140]                   ...future.strategy.old <- future::plan("list")
[10:59:32.140]                   options(future.plan = NULL)
[10:59:32.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.140]                 }
[10:59:32.140]                 ...future.workdir <- getwd()
[10:59:32.140]             }
[10:59:32.140]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.140]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.140]         }
[10:59:32.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.140]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.140]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.140]             base::names(...future.oldOptions))
[10:59:32.140]     }
[10:59:32.140]     if (FALSE) {
[10:59:32.140]     }
[10:59:32.140]     else {
[10:59:32.140]         if (TRUE) {
[10:59:32.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.140]                 open = "w")
[10:59:32.140]         }
[10:59:32.140]         else {
[10:59:32.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.140]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.140]         }
[10:59:32.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.140]             base::sink(type = "output", split = FALSE)
[10:59:32.140]             base::close(...future.stdout)
[10:59:32.140]         }, add = TRUE)
[10:59:32.140]     }
[10:59:32.140]     ...future.frame <- base::sys.nframe()
[10:59:32.140]     ...future.conditions <- base::list()
[10:59:32.140]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.140]     if (FALSE) {
[10:59:32.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.140]     }
[10:59:32.140]     ...future.result <- base::tryCatch({
[10:59:32.140]         base::withCallingHandlers({
[10:59:32.140]             ...future.value <- base::withVisible(base::local({
[10:59:32.140]                 withCallingHandlers({
[10:59:32.140]                   {
[10:59:32.140]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.140]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.140]                       ...future.globals.maxSize)) {
[10:59:32.140]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.140]                       on.exit(options(oopts), add = TRUE)
[10:59:32.140]                     }
[10:59:32.140]                     {
[10:59:32.140]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.140]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.140]                         USE.NAMES = FALSE)
[10:59:32.140]                       do.call(mapply, args = args)
[10:59:32.140]                     }
[10:59:32.140]                   }
[10:59:32.140]                 }, immediateCondition = function(cond) {
[10:59:32.140]                   save_rds <- function (object, pathname, ...) 
[10:59:32.140]                   {
[10:59:32.140]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.140]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.140]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.140]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.140]                         fi_tmp[["mtime"]])
[10:59:32.140]                     }
[10:59:32.140]                     tryCatch({
[10:59:32.140]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.140]                     }, error = function(ex) {
[10:59:32.140]                       msg <- conditionMessage(ex)
[10:59:32.140]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.140]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.140]                         fi_tmp[["mtime"]], msg)
[10:59:32.140]                       ex$message <- msg
[10:59:32.140]                       stop(ex)
[10:59:32.140]                     })
[10:59:32.140]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.140]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.140]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.140]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.140]                       fi <- file.info(pathname)
[10:59:32.140]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.140]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.140]                         fi[["size"]], fi[["mtime"]])
[10:59:32.140]                       stop(msg)
[10:59:32.140]                     }
[10:59:32.140]                     invisible(pathname)
[10:59:32.140]                   }
[10:59:32.140]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.140]                     rootPath = tempdir()) 
[10:59:32.140]                   {
[10:59:32.140]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.140]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.140]                       tmpdir = path, fileext = ".rds")
[10:59:32.140]                     save_rds(obj, file)
[10:59:32.140]                   }
[10:59:32.140]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.140]                   {
[10:59:32.140]                     inherits <- base::inherits
[10:59:32.140]                     invokeRestart <- base::invokeRestart
[10:59:32.140]                     is.null <- base::is.null
[10:59:32.140]                     muffled <- FALSE
[10:59:32.140]                     if (inherits(cond, "message")) {
[10:59:32.140]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.140]                       if (muffled) 
[10:59:32.140]                         invokeRestart("muffleMessage")
[10:59:32.140]                     }
[10:59:32.140]                     else if (inherits(cond, "warning")) {
[10:59:32.140]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.140]                       if (muffled) 
[10:59:32.140]                         invokeRestart("muffleWarning")
[10:59:32.140]                     }
[10:59:32.140]                     else if (inherits(cond, "condition")) {
[10:59:32.140]                       if (!is.null(pattern)) {
[10:59:32.140]                         computeRestarts <- base::computeRestarts
[10:59:32.140]                         grepl <- base::grepl
[10:59:32.140]                         restarts <- computeRestarts(cond)
[10:59:32.140]                         for (restart in restarts) {
[10:59:32.140]                           name <- restart$name
[10:59:32.140]                           if (is.null(name)) 
[10:59:32.140]                             next
[10:59:32.140]                           if (!grepl(pattern, name)) 
[10:59:32.140]                             next
[10:59:32.140]                           invokeRestart(restart)
[10:59:32.140]                           muffled <- TRUE
[10:59:32.140]                           break
[10:59:32.140]                         }
[10:59:32.140]                       }
[10:59:32.140]                     }
[10:59:32.140]                     invisible(muffled)
[10:59:32.140]                   }
[10:59:32.140]                   muffleCondition(cond)
[10:59:32.140]                 })
[10:59:32.140]             }))
[10:59:32.140]             future::FutureResult(value = ...future.value$value, 
[10:59:32.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.140]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.140]                     ...future.globalenv.names))
[10:59:32.140]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.140]         }, condition = base::local({
[10:59:32.140]             c <- base::c
[10:59:32.140]             inherits <- base::inherits
[10:59:32.140]             invokeRestart <- base::invokeRestart
[10:59:32.140]             length <- base::length
[10:59:32.140]             list <- base::list
[10:59:32.140]             seq.int <- base::seq.int
[10:59:32.140]             signalCondition <- base::signalCondition
[10:59:32.140]             sys.calls <- base::sys.calls
[10:59:32.140]             `[[` <- base::`[[`
[10:59:32.140]             `+` <- base::`+`
[10:59:32.140]             `<<-` <- base::`<<-`
[10:59:32.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.140]                   3L)]
[10:59:32.140]             }
[10:59:32.140]             function(cond) {
[10:59:32.140]                 is_error <- inherits(cond, "error")
[10:59:32.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.140]                   NULL)
[10:59:32.140]                 if (is_error) {
[10:59:32.140]                   sessionInformation <- function() {
[10:59:32.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.140]                       search = base::search(), system = base::Sys.info())
[10:59:32.140]                   }
[10:59:32.140]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.140]                     cond$call), session = sessionInformation(), 
[10:59:32.140]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.140]                   signalCondition(cond)
[10:59:32.140]                 }
[10:59:32.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.140]                 "immediateCondition"))) {
[10:59:32.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.140]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.140]                   if (TRUE && !signal) {
[10:59:32.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.140]                     {
[10:59:32.140]                       inherits <- base::inherits
[10:59:32.140]                       invokeRestart <- base::invokeRestart
[10:59:32.140]                       is.null <- base::is.null
[10:59:32.140]                       muffled <- FALSE
[10:59:32.140]                       if (inherits(cond, "message")) {
[10:59:32.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.140]                         if (muffled) 
[10:59:32.140]                           invokeRestart("muffleMessage")
[10:59:32.140]                       }
[10:59:32.140]                       else if (inherits(cond, "warning")) {
[10:59:32.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.140]                         if (muffled) 
[10:59:32.140]                           invokeRestart("muffleWarning")
[10:59:32.140]                       }
[10:59:32.140]                       else if (inherits(cond, "condition")) {
[10:59:32.140]                         if (!is.null(pattern)) {
[10:59:32.140]                           computeRestarts <- base::computeRestarts
[10:59:32.140]                           grepl <- base::grepl
[10:59:32.140]                           restarts <- computeRestarts(cond)
[10:59:32.140]                           for (restart in restarts) {
[10:59:32.140]                             name <- restart$name
[10:59:32.140]                             if (is.null(name)) 
[10:59:32.140]                               next
[10:59:32.140]                             if (!grepl(pattern, name)) 
[10:59:32.140]                               next
[10:59:32.140]                             invokeRestart(restart)
[10:59:32.140]                             muffled <- TRUE
[10:59:32.140]                             break
[10:59:32.140]                           }
[10:59:32.140]                         }
[10:59:32.140]                       }
[10:59:32.140]                       invisible(muffled)
[10:59:32.140]                     }
[10:59:32.140]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.140]                   }
[10:59:32.140]                 }
[10:59:32.140]                 else {
[10:59:32.140]                   if (TRUE) {
[10:59:32.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.140]                     {
[10:59:32.140]                       inherits <- base::inherits
[10:59:32.140]                       invokeRestart <- base::invokeRestart
[10:59:32.140]                       is.null <- base::is.null
[10:59:32.140]                       muffled <- FALSE
[10:59:32.140]                       if (inherits(cond, "message")) {
[10:59:32.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.140]                         if (muffled) 
[10:59:32.140]                           invokeRestart("muffleMessage")
[10:59:32.140]                       }
[10:59:32.140]                       else if (inherits(cond, "warning")) {
[10:59:32.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.140]                         if (muffled) 
[10:59:32.140]                           invokeRestart("muffleWarning")
[10:59:32.140]                       }
[10:59:32.140]                       else if (inherits(cond, "condition")) {
[10:59:32.140]                         if (!is.null(pattern)) {
[10:59:32.140]                           computeRestarts <- base::computeRestarts
[10:59:32.140]                           grepl <- base::grepl
[10:59:32.140]                           restarts <- computeRestarts(cond)
[10:59:32.140]                           for (restart in restarts) {
[10:59:32.140]                             name <- restart$name
[10:59:32.140]                             if (is.null(name)) 
[10:59:32.140]                               next
[10:59:32.140]                             if (!grepl(pattern, name)) 
[10:59:32.140]                               next
[10:59:32.140]                             invokeRestart(restart)
[10:59:32.140]                             muffled <- TRUE
[10:59:32.140]                             break
[10:59:32.140]                           }
[10:59:32.140]                         }
[10:59:32.140]                       }
[10:59:32.140]                       invisible(muffled)
[10:59:32.140]                     }
[10:59:32.140]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.140]                   }
[10:59:32.140]                 }
[10:59:32.140]             }
[10:59:32.140]         }))
[10:59:32.140]     }, error = function(ex) {
[10:59:32.140]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.140]                 ...future.rng), started = ...future.startTime, 
[10:59:32.140]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.140]             version = "1.8"), class = "FutureResult")
[10:59:32.140]     }, finally = {
[10:59:32.140]         if (!identical(...future.workdir, getwd())) 
[10:59:32.140]             setwd(...future.workdir)
[10:59:32.140]         {
[10:59:32.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.140]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.140]             }
[10:59:32.140]             base::options(...future.oldOptions)
[10:59:32.140]             if (.Platform$OS.type == "windows") {
[10:59:32.140]                 old_names <- names(...future.oldEnvVars)
[10:59:32.140]                 envs <- base::Sys.getenv()
[10:59:32.140]                 names <- names(envs)
[10:59:32.140]                 common <- intersect(names, old_names)
[10:59:32.140]                 added <- setdiff(names, old_names)
[10:59:32.140]                 removed <- setdiff(old_names, names)
[10:59:32.140]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.140]                   envs[common]]
[10:59:32.140]                 NAMES <- toupper(changed)
[10:59:32.140]                 args <- list()
[10:59:32.140]                 for (kk in seq_along(NAMES)) {
[10:59:32.140]                   name <- changed[[kk]]
[10:59:32.140]                   NAME <- NAMES[[kk]]
[10:59:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.140]                     next
[10:59:32.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.140]                 }
[10:59:32.140]                 NAMES <- toupper(added)
[10:59:32.140]                 for (kk in seq_along(NAMES)) {
[10:59:32.140]                   name <- added[[kk]]
[10:59:32.140]                   NAME <- NAMES[[kk]]
[10:59:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.140]                     next
[10:59:32.140]                   args[[name]] <- ""
[10:59:32.140]                 }
[10:59:32.140]                 NAMES <- toupper(removed)
[10:59:32.140]                 for (kk in seq_along(NAMES)) {
[10:59:32.140]                   name <- removed[[kk]]
[10:59:32.140]                   NAME <- NAMES[[kk]]
[10:59:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.140]                     next
[10:59:32.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.140]                 }
[10:59:32.140]                 if (length(args) > 0) 
[10:59:32.140]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.140]             }
[10:59:32.140]             else {
[10:59:32.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.140]             }
[10:59:32.140]             {
[10:59:32.140]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.140]                   0L) {
[10:59:32.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.140]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.140]                   base::options(opts)
[10:59:32.140]                 }
[10:59:32.140]                 {
[10:59:32.140]                   {
[10:59:32.140]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.140]                     NULL
[10:59:32.140]                   }
[10:59:32.140]                   options(future.plan = NULL)
[10:59:32.140]                   if (is.na(NA_character_)) 
[10:59:32.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.140]                     .init = FALSE)
[10:59:32.140]                 }
[10:59:32.140]             }
[10:59:32.140]         }
[10:59:32.140]     })
[10:59:32.140]     if (TRUE) {
[10:59:32.140]         base::sink(type = "output", split = FALSE)
[10:59:32.140]         if (TRUE) {
[10:59:32.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.140]         }
[10:59:32.140]         else {
[10:59:32.140]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.140]         }
[10:59:32.140]         base::close(...future.stdout)
[10:59:32.140]         ...future.stdout <- NULL
[10:59:32.140]     }
[10:59:32.140]     ...future.result$conditions <- ...future.conditions
[10:59:32.140]     ...future.result$finished <- base::Sys.time()
[10:59:32.140]     ...future.result
[10:59:32.140] }
[10:59:32.143] assign_globals() ...
[10:59:32.143] List of 5
[10:59:32.143]  $ ...future.FUN            :function (x, y)  
[10:59:32.143]  $ MoreArgs                 : NULL
[10:59:32.143]  $ ...future.elements_ii    :List of 2
[10:59:32.143]   ..$ :List of 1
[10:59:32.143]   .. ..$ a: num 1
[10:59:32.143]   ..$ :List of 1
[10:59:32.143]   .. ..$ A: num 10
[10:59:32.143]  $ ...future.seeds_ii       : NULL
[10:59:32.143]  $ ...future.globals.maxSize: NULL
[10:59:32.143]  - attr(*, "where")=List of 5
[10:59:32.143]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.143]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.143]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.143]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.143]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.143]  - attr(*, "resolved")= logi FALSE
[10:59:32.143]  - attr(*, "total_size")= num 645
[10:59:32.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.143]  - attr(*, "already-done")= logi TRUE
[10:59:32.148] - reassign environment for ‘...future.FUN’
[10:59:32.148] - copied ‘...future.FUN’ to environment
[10:59:32.148] - copied ‘MoreArgs’ to environment
[10:59:32.148] - copied ‘...future.elements_ii’ to environment
[10:59:32.148] - copied ‘...future.seeds_ii’ to environment
[10:59:32.148] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.148] assign_globals() ... done
[10:59:32.148] requestCore(): workers = 2
[10:59:32.150] MulticoreFuture started
[10:59:32.150] - Launch lazy future ... done
[10:59:32.151] run() for ‘MulticoreFuture’ ... done
[10:59:32.151] Created future:
[10:59:32.151] plan(): Setting new future strategy stack:
[10:59:32.151] List of future strategies:
[10:59:32.151] 1. sequential:
[10:59:32.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.151]    - tweaked: FALSE
[10:59:32.151]    - call: NULL
[10:59:32.152] plan(): nbrOfWorkers() = 1
[10:59:32.154] plan(): Setting new future strategy stack:
[10:59:32.154] List of future strategies:
[10:59:32.154] 1. multicore:
[10:59:32.154]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.154]    - tweaked: FALSE
[10:59:32.154]    - call: plan(strategy)
[10:59:32.157] plan(): nbrOfWorkers() = 2
[10:59:32.151] MulticoreFuture:
[10:59:32.151] Label: ‘future_mapply-1’
[10:59:32.151] Expression:
[10:59:32.151] {
[10:59:32.151]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.151]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.151]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.151]         on.exit(options(oopts), add = TRUE)
[10:59:32.151]     }
[10:59:32.151]     {
[10:59:32.151]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.151]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.151]         do.call(mapply, args = args)
[10:59:32.151]     }
[10:59:32.151] }
[10:59:32.151] Lazy evaluation: FALSE
[10:59:32.151] Asynchronous evaluation: TRUE
[10:59:32.151] Local evaluation: TRUE
[10:59:32.151] Environment: R_GlobalEnv
[10:59:32.151] Capture standard output: TRUE
[10:59:32.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.151] Globals: 5 objects totaling 645 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.151] Packages: <none>
[10:59:32.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.151] Resolved: TRUE
[10:59:32.151] Value: <not collected>
[10:59:32.151] Conditions captured: <none>
[10:59:32.151] Early signaling: FALSE
[10:59:32.151] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.151] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.158] Chunk #1 of 2 ... DONE
[10:59:32.159] Chunk #2 of 2 ...
[10:59:32.159]  - Finding globals in '...' for chunk #2 ...
[10:59:32.159] getGlobalsAndPackages() ...
[10:59:32.159] Searching for globals...
[10:59:32.160] 
[10:59:32.160] Searching for globals ... DONE
[10:59:32.160] - globals: [0] <none>
[10:59:32.160] getGlobalsAndPackages() ... DONE
[10:59:32.160]    + additional globals found: [n=0] 
[10:59:32.160]    + additional namespaces needed: [n=0] 
[10:59:32.161]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:32.161]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.161]  - seeds: <none>
[10:59:32.164]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.164] getGlobalsAndPackages() ...
[10:59:32.165] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.165] Resolving globals: FALSE
[10:59:32.166] The total size of the 5 globals is 695 bytes (695 bytes)
[10:59:32.168] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 695 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.168] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.168] 
[10:59:32.168] getGlobalsAndPackages() ... DONE
[10:59:32.169] run() for ‘Future’ ...
[10:59:32.169] - state: ‘created’
[10:59:32.170] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.173] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.173]   - Field: ‘label’
[10:59:32.174]   - Field: ‘local’
[10:59:32.174]   - Field: ‘owner’
[10:59:32.174]   - Field: ‘envir’
[10:59:32.174]   - Field: ‘workers’
[10:59:32.174]   - Field: ‘packages’
[10:59:32.174]   - Field: ‘gc’
[10:59:32.175]   - Field: ‘job’
[10:59:32.175]   - Field: ‘conditions’
[10:59:32.175]   - Field: ‘expr’
[10:59:32.175]   - Field: ‘uuid’
[10:59:32.175]   - Field: ‘seed’
[10:59:32.175]   - Field: ‘version’
[10:59:32.176]   - Field: ‘result’
[10:59:32.176]   - Field: ‘asynchronous’
[10:59:32.176]   - Field: ‘calls’
[10:59:32.176]   - Field: ‘globals’
[10:59:32.176]   - Field: ‘stdout’
[10:59:32.176]   - Field: ‘earlySignal’
[10:59:32.176]   - Field: ‘lazy’
[10:59:32.177]   - Field: ‘state’
[10:59:32.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.177] - Launch lazy future ...
[10:59:32.177] Packages needed by the future expression (n = 0): <none>
[10:59:32.177] Packages needed by future strategies (n = 0): <none>
[10:59:32.178] {
[10:59:32.178]     {
[10:59:32.178]         {
[10:59:32.178]             ...future.startTime <- base::Sys.time()
[10:59:32.178]             {
[10:59:32.178]                 {
[10:59:32.178]                   {
[10:59:32.178]                     {
[10:59:32.178]                       base::local({
[10:59:32.178]                         has_future <- base::requireNamespace("future", 
[10:59:32.178]                           quietly = TRUE)
[10:59:32.178]                         if (has_future) {
[10:59:32.178]                           ns <- base::getNamespace("future")
[10:59:32.178]                           version <- ns[[".package"]][["version"]]
[10:59:32.178]                           if (is.null(version)) 
[10:59:32.178]                             version <- utils::packageVersion("future")
[10:59:32.178]                         }
[10:59:32.178]                         else {
[10:59:32.178]                           version <- NULL
[10:59:32.178]                         }
[10:59:32.178]                         if (!has_future || version < "1.8.0") {
[10:59:32.178]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.178]                             "", base::R.version$version.string), 
[10:59:32.178]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.178]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.178]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.178]                               "release", "version")], collapse = " "), 
[10:59:32.178]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.178]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.178]                             info)
[10:59:32.178]                           info <- base::paste(info, collapse = "; ")
[10:59:32.178]                           if (!has_future) {
[10:59:32.178]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.178]                               info)
[10:59:32.178]                           }
[10:59:32.178]                           else {
[10:59:32.178]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.178]                               info, version)
[10:59:32.178]                           }
[10:59:32.178]                           base::stop(msg)
[10:59:32.178]                         }
[10:59:32.178]                       })
[10:59:32.178]                     }
[10:59:32.178]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.178]                     base::options(mc.cores = 1L)
[10:59:32.178]                   }
[10:59:32.178]                   ...future.strategy.old <- future::plan("list")
[10:59:32.178]                   options(future.plan = NULL)
[10:59:32.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.178]                 }
[10:59:32.178]                 ...future.workdir <- getwd()
[10:59:32.178]             }
[10:59:32.178]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.178]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.178]         }
[10:59:32.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.178]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.178]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.178]             base::names(...future.oldOptions))
[10:59:32.178]     }
[10:59:32.178]     if (FALSE) {
[10:59:32.178]     }
[10:59:32.178]     else {
[10:59:32.178]         if (TRUE) {
[10:59:32.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.178]                 open = "w")
[10:59:32.178]         }
[10:59:32.178]         else {
[10:59:32.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.178]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.178]         }
[10:59:32.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.178]             base::sink(type = "output", split = FALSE)
[10:59:32.178]             base::close(...future.stdout)
[10:59:32.178]         }, add = TRUE)
[10:59:32.178]     }
[10:59:32.178]     ...future.frame <- base::sys.nframe()
[10:59:32.178]     ...future.conditions <- base::list()
[10:59:32.178]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.178]     if (FALSE) {
[10:59:32.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.178]     }
[10:59:32.178]     ...future.result <- base::tryCatch({
[10:59:32.178]         base::withCallingHandlers({
[10:59:32.178]             ...future.value <- base::withVisible(base::local({
[10:59:32.178]                 withCallingHandlers({
[10:59:32.178]                   {
[10:59:32.178]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.178]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.178]                       ...future.globals.maxSize)) {
[10:59:32.178]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.178]                       on.exit(options(oopts), add = TRUE)
[10:59:32.178]                     }
[10:59:32.178]                     {
[10:59:32.178]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.178]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.178]                         USE.NAMES = FALSE)
[10:59:32.178]                       do.call(mapply, args = args)
[10:59:32.178]                     }
[10:59:32.178]                   }
[10:59:32.178]                 }, immediateCondition = function(cond) {
[10:59:32.178]                   save_rds <- function (object, pathname, ...) 
[10:59:32.178]                   {
[10:59:32.178]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.178]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.178]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.178]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.178]                         fi_tmp[["mtime"]])
[10:59:32.178]                     }
[10:59:32.178]                     tryCatch({
[10:59:32.178]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.178]                     }, error = function(ex) {
[10:59:32.178]                       msg <- conditionMessage(ex)
[10:59:32.178]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.178]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.178]                         fi_tmp[["mtime"]], msg)
[10:59:32.178]                       ex$message <- msg
[10:59:32.178]                       stop(ex)
[10:59:32.178]                     })
[10:59:32.178]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.178]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.178]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.178]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.178]                       fi <- file.info(pathname)
[10:59:32.178]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.178]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.178]                         fi[["size"]], fi[["mtime"]])
[10:59:32.178]                       stop(msg)
[10:59:32.178]                     }
[10:59:32.178]                     invisible(pathname)
[10:59:32.178]                   }
[10:59:32.178]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.178]                     rootPath = tempdir()) 
[10:59:32.178]                   {
[10:59:32.178]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.178]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.178]                       tmpdir = path, fileext = ".rds")
[10:59:32.178]                     save_rds(obj, file)
[10:59:32.178]                   }
[10:59:32.178]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.178]                   {
[10:59:32.178]                     inherits <- base::inherits
[10:59:32.178]                     invokeRestart <- base::invokeRestart
[10:59:32.178]                     is.null <- base::is.null
[10:59:32.178]                     muffled <- FALSE
[10:59:32.178]                     if (inherits(cond, "message")) {
[10:59:32.178]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.178]                       if (muffled) 
[10:59:32.178]                         invokeRestart("muffleMessage")
[10:59:32.178]                     }
[10:59:32.178]                     else if (inherits(cond, "warning")) {
[10:59:32.178]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.178]                       if (muffled) 
[10:59:32.178]                         invokeRestart("muffleWarning")
[10:59:32.178]                     }
[10:59:32.178]                     else if (inherits(cond, "condition")) {
[10:59:32.178]                       if (!is.null(pattern)) {
[10:59:32.178]                         computeRestarts <- base::computeRestarts
[10:59:32.178]                         grepl <- base::grepl
[10:59:32.178]                         restarts <- computeRestarts(cond)
[10:59:32.178]                         for (restart in restarts) {
[10:59:32.178]                           name <- restart$name
[10:59:32.178]                           if (is.null(name)) 
[10:59:32.178]                             next
[10:59:32.178]                           if (!grepl(pattern, name)) 
[10:59:32.178]                             next
[10:59:32.178]                           invokeRestart(restart)
[10:59:32.178]                           muffled <- TRUE
[10:59:32.178]                           break
[10:59:32.178]                         }
[10:59:32.178]                       }
[10:59:32.178]                     }
[10:59:32.178]                     invisible(muffled)
[10:59:32.178]                   }
[10:59:32.178]                   muffleCondition(cond)
[10:59:32.178]                 })
[10:59:32.178]             }))
[10:59:32.178]             future::FutureResult(value = ...future.value$value, 
[10:59:32.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.178]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.178]                     ...future.globalenv.names))
[10:59:32.178]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.178]         }, condition = base::local({
[10:59:32.178]             c <- base::c
[10:59:32.178]             inherits <- base::inherits
[10:59:32.178]             invokeRestart <- base::invokeRestart
[10:59:32.178]             length <- base::length
[10:59:32.178]             list <- base::list
[10:59:32.178]             seq.int <- base::seq.int
[10:59:32.178]             signalCondition <- base::signalCondition
[10:59:32.178]             sys.calls <- base::sys.calls
[10:59:32.178]             `[[` <- base::`[[`
[10:59:32.178]             `+` <- base::`+`
[10:59:32.178]             `<<-` <- base::`<<-`
[10:59:32.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.178]                   3L)]
[10:59:32.178]             }
[10:59:32.178]             function(cond) {
[10:59:32.178]                 is_error <- inherits(cond, "error")
[10:59:32.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.178]                   NULL)
[10:59:32.178]                 if (is_error) {
[10:59:32.178]                   sessionInformation <- function() {
[10:59:32.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.178]                       search = base::search(), system = base::Sys.info())
[10:59:32.178]                   }
[10:59:32.178]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.178]                     cond$call), session = sessionInformation(), 
[10:59:32.178]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.178]                   signalCondition(cond)
[10:59:32.178]                 }
[10:59:32.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.178]                 "immediateCondition"))) {
[10:59:32.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.178]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.178]                   if (TRUE && !signal) {
[10:59:32.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.178]                     {
[10:59:32.178]                       inherits <- base::inherits
[10:59:32.178]                       invokeRestart <- base::invokeRestart
[10:59:32.178]                       is.null <- base::is.null
[10:59:32.178]                       muffled <- FALSE
[10:59:32.178]                       if (inherits(cond, "message")) {
[10:59:32.178]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.178]                         if (muffled) 
[10:59:32.178]                           invokeRestart("muffleMessage")
[10:59:32.178]                       }
[10:59:32.178]                       else if (inherits(cond, "warning")) {
[10:59:32.178]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.178]                         if (muffled) 
[10:59:32.178]                           invokeRestart("muffleWarning")
[10:59:32.178]                       }
[10:59:32.178]                       else if (inherits(cond, "condition")) {
[10:59:32.178]                         if (!is.null(pattern)) {
[10:59:32.178]                           computeRestarts <- base::computeRestarts
[10:59:32.178]                           grepl <- base::grepl
[10:59:32.178]                           restarts <- computeRestarts(cond)
[10:59:32.178]                           for (restart in restarts) {
[10:59:32.178]                             name <- restart$name
[10:59:32.178]                             if (is.null(name)) 
[10:59:32.178]                               next
[10:59:32.178]                             if (!grepl(pattern, name)) 
[10:59:32.178]                               next
[10:59:32.178]                             invokeRestart(restart)
[10:59:32.178]                             muffled <- TRUE
[10:59:32.178]                             break
[10:59:32.178]                           }
[10:59:32.178]                         }
[10:59:32.178]                       }
[10:59:32.178]                       invisible(muffled)
[10:59:32.178]                     }
[10:59:32.178]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.178]                   }
[10:59:32.178]                 }
[10:59:32.178]                 else {
[10:59:32.178]                   if (TRUE) {
[10:59:32.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.178]                     {
[10:59:32.178]                       inherits <- base::inherits
[10:59:32.178]                       invokeRestart <- base::invokeRestart
[10:59:32.178]                       is.null <- base::is.null
[10:59:32.178]                       muffled <- FALSE
[10:59:32.178]                       if (inherits(cond, "message")) {
[10:59:32.178]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.178]                         if (muffled) 
[10:59:32.178]                           invokeRestart("muffleMessage")
[10:59:32.178]                       }
[10:59:32.178]                       else if (inherits(cond, "warning")) {
[10:59:32.178]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.178]                         if (muffled) 
[10:59:32.178]                           invokeRestart("muffleWarning")
[10:59:32.178]                       }
[10:59:32.178]                       else if (inherits(cond, "condition")) {
[10:59:32.178]                         if (!is.null(pattern)) {
[10:59:32.178]                           computeRestarts <- base::computeRestarts
[10:59:32.178]                           grepl <- base::grepl
[10:59:32.178]                           restarts <- computeRestarts(cond)
[10:59:32.178]                           for (restart in restarts) {
[10:59:32.178]                             name <- restart$name
[10:59:32.178]                             if (is.null(name)) 
[10:59:32.178]                               next
[10:59:32.178]                             if (!grepl(pattern, name)) 
[10:59:32.178]                               next
[10:59:32.178]                             invokeRestart(restart)
[10:59:32.178]                             muffled <- TRUE
[10:59:32.178]                             break
[10:59:32.178]                           }
[10:59:32.178]                         }
[10:59:32.178]                       }
[10:59:32.178]                       invisible(muffled)
[10:59:32.178]                     }
[10:59:32.178]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.178]                   }
[10:59:32.178]                 }
[10:59:32.178]             }
[10:59:32.178]         }))
[10:59:32.178]     }, error = function(ex) {
[10:59:32.178]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.178]                 ...future.rng), started = ...future.startTime, 
[10:59:32.178]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.178]             version = "1.8"), class = "FutureResult")
[10:59:32.178]     }, finally = {
[10:59:32.178]         if (!identical(...future.workdir, getwd())) 
[10:59:32.178]             setwd(...future.workdir)
[10:59:32.178]         {
[10:59:32.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.178]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.178]             }
[10:59:32.178]             base::options(...future.oldOptions)
[10:59:32.178]             if (.Platform$OS.type == "windows") {
[10:59:32.178]                 old_names <- names(...future.oldEnvVars)
[10:59:32.178]                 envs <- base::Sys.getenv()
[10:59:32.178]                 names <- names(envs)
[10:59:32.178]                 common <- intersect(names, old_names)
[10:59:32.178]                 added <- setdiff(names, old_names)
[10:59:32.178]                 removed <- setdiff(old_names, names)
[10:59:32.178]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.178]                   envs[common]]
[10:59:32.178]                 NAMES <- toupper(changed)
[10:59:32.178]                 args <- list()
[10:59:32.178]                 for (kk in seq_along(NAMES)) {
[10:59:32.178]                   name <- changed[[kk]]
[10:59:32.178]                   NAME <- NAMES[[kk]]
[10:59:32.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.178]                     next
[10:59:32.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.178]                 }
[10:59:32.178]                 NAMES <- toupper(added)
[10:59:32.178]                 for (kk in seq_along(NAMES)) {
[10:59:32.178]                   name <- added[[kk]]
[10:59:32.178]                   NAME <- NAMES[[kk]]
[10:59:32.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.178]                     next
[10:59:32.178]                   args[[name]] <- ""
[10:59:32.178]                 }
[10:59:32.178]                 NAMES <- toupper(removed)
[10:59:32.178]                 for (kk in seq_along(NAMES)) {
[10:59:32.178]                   name <- removed[[kk]]
[10:59:32.178]                   NAME <- NAMES[[kk]]
[10:59:32.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.178]                     next
[10:59:32.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.178]                 }
[10:59:32.178]                 if (length(args) > 0) 
[10:59:32.178]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.178]             }
[10:59:32.178]             else {
[10:59:32.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.178]             }
[10:59:32.178]             {
[10:59:32.178]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.178]                   0L) {
[10:59:32.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.178]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.178]                   base::options(opts)
[10:59:32.178]                 }
[10:59:32.178]                 {
[10:59:32.178]                   {
[10:59:32.178]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.178]                     NULL
[10:59:32.178]                   }
[10:59:32.178]                   options(future.plan = NULL)
[10:59:32.178]                   if (is.na(NA_character_)) 
[10:59:32.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.178]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.178]                     .init = FALSE)
[10:59:32.178]                 }
[10:59:32.178]             }
[10:59:32.178]         }
[10:59:32.178]     })
[10:59:32.178]     if (TRUE) {
[10:59:32.178]         base::sink(type = "output", split = FALSE)
[10:59:32.178]         if (TRUE) {
[10:59:32.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.178]         }
[10:59:32.178]         else {
[10:59:32.178]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.178]         }
[10:59:32.178]         base::close(...future.stdout)
[10:59:32.178]         ...future.stdout <- NULL
[10:59:32.178]     }
[10:59:32.178]     ...future.result$conditions <- ...future.conditions
[10:59:32.178]     ...future.result$finished <- base::Sys.time()
[10:59:32.178]     ...future.result
[10:59:32.178] }
[10:59:32.181] assign_globals() ...
[10:59:32.181] List of 5
[10:59:32.181]  $ ...future.FUN            :function (x, y)  
[10:59:32.181]  $ MoreArgs                 : NULL
[10:59:32.181]  $ ...future.elements_ii    :List of 2
[10:59:32.181]   ..$ :List of 2
[10:59:32.181]   .. ..$ b: num 2
[10:59:32.181]   .. ..$ c: num 3
[10:59:32.181]   ..$ :List of 2
[10:59:32.181]   .. ..$ B: num 0
[10:59:32.181]   .. ..$ C: num -10
[10:59:32.181]  $ ...future.seeds_ii       : NULL
[10:59:32.181]  $ ...future.globals.maxSize: NULL
[10:59:32.181]  - attr(*, "where")=List of 5
[10:59:32.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.181]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.181]  - attr(*, "resolved")= logi FALSE
[10:59:32.181]  - attr(*, "total_size")= num 695
[10:59:32.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.181]  - attr(*, "already-done")= logi TRUE
[10:59:32.188] - reassign environment for ‘...future.FUN’
[10:59:32.188] - copied ‘...future.FUN’ to environment
[10:59:32.188] - copied ‘MoreArgs’ to environment
[10:59:32.188] - copied ‘...future.elements_ii’ to environment
[10:59:32.188] - copied ‘...future.seeds_ii’ to environment
[10:59:32.189] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.189] assign_globals() ... done
[10:59:32.189] requestCore(): workers = 2
[10:59:32.191] MulticoreFuture started
[10:59:32.191] - Launch lazy future ... done
[10:59:32.192] run() for ‘MulticoreFuture’ ... done
[10:59:32.192] Created future:
[10:59:32.192] plan(): Setting new future strategy stack:
[10:59:32.192] List of future strategies:
[10:59:32.192] 1. sequential:
[10:59:32.192]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.192]    - tweaked: FALSE
[10:59:32.192]    - call: NULL
[10:59:32.193] plan(): nbrOfWorkers() = 1
[10:59:32.195] plan(): Setting new future strategy stack:
[10:59:32.196] List of future strategies:
[10:59:32.196] 1. multicore:
[10:59:32.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.196]    - tweaked: FALSE
[10:59:32.196]    - call: plan(strategy)
[10:59:32.199] plan(): nbrOfWorkers() = 2
[10:59:32.192] MulticoreFuture:
[10:59:32.192] Label: ‘future_mapply-2’
[10:59:32.192] Expression:
[10:59:32.192] {
[10:59:32.192]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.192]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.192]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.192]         on.exit(options(oopts), add = TRUE)
[10:59:32.192]     }
[10:59:32.192]     {
[10:59:32.192]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.192]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.192]         do.call(mapply, args = args)
[10:59:32.192]     }
[10:59:32.192] }
[10:59:32.192] Lazy evaluation: FALSE
[10:59:32.192] Asynchronous evaluation: TRUE
[10:59:32.192] Local evaluation: TRUE
[10:59:32.192] Environment: R_GlobalEnv
[10:59:32.192] Capture standard output: TRUE
[10:59:32.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.192] Globals: 5 objects totaling 695 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.192] Packages: <none>
[10:59:32.192] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.192] Resolved: TRUE
[10:59:32.192] Value: <not collected>
[10:59:32.192] Conditions captured: <none>
[10:59:32.192] Early signaling: FALSE
[10:59:32.192] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.192] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.200] Chunk #2 of 2 ... DONE
[10:59:32.200] Launching 2 futures (chunks) ... DONE
[10:59:32.200] Resolving 2 futures (chunks) ...
[10:59:32.200] resolve() on list ...
[10:59:32.200]  recursive: 0
[10:59:32.201]  length: 2
[10:59:32.201] 
[10:59:32.201] Future #1
[10:59:32.201] result() for MulticoreFuture ...
[10:59:32.202] result() for MulticoreFuture ...
[10:59:32.202] result() for MulticoreFuture ... done
[10:59:32.202] result() for MulticoreFuture ... done
[10:59:32.202] result() for MulticoreFuture ...
[10:59:32.203] result() for MulticoreFuture ... done
[10:59:32.203] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.203] - nx: 2
[10:59:32.203] - relay: TRUE
[10:59:32.203] - stdout: TRUE
[10:59:32.203] - signal: TRUE
[10:59:32.203] - resignal: FALSE
[10:59:32.204] - force: TRUE
[10:59:32.204] - relayed: [n=2] FALSE, FALSE
[10:59:32.204] - queued futures: [n=2] FALSE, FALSE
[10:59:32.204]  - until=1
[10:59:32.204]  - relaying element #1
[10:59:32.204] result() for MulticoreFuture ...
[10:59:32.204] result() for MulticoreFuture ... done
[10:59:32.205] result() for MulticoreFuture ...
[10:59:32.205] result() for MulticoreFuture ... done
[10:59:32.205] result() for MulticoreFuture ...
[10:59:32.205] result() for MulticoreFuture ... done
[10:59:32.205] result() for MulticoreFuture ...
[10:59:32.205] result() for MulticoreFuture ... done
[10:59:32.205] - relayed: [n=2] TRUE, FALSE
[10:59:32.206] - queued futures: [n=2] TRUE, FALSE
[10:59:32.206] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.206]  length: 1 (resolved future 1)
[10:59:32.206] Future #2
[10:59:32.210] result() for MulticoreFuture ...
[10:59:32.211] result() for MulticoreFuture ...
[10:59:32.211] result() for MulticoreFuture ... done
[10:59:32.211] result() for MulticoreFuture ... done
[10:59:32.212] result() for MulticoreFuture ...
[10:59:32.212] result() for MulticoreFuture ... done
[10:59:32.212] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.212] - nx: 2
[10:59:32.213] - relay: TRUE
[10:59:32.213] - stdout: TRUE
[10:59:32.213] - signal: TRUE
[10:59:32.213] - resignal: FALSE
[10:59:32.213] - force: TRUE
[10:59:32.213] - relayed: [n=2] TRUE, FALSE
[10:59:32.213] - queued futures: [n=2] TRUE, FALSE
[10:59:32.214]  - until=2
[10:59:32.214]  - relaying element #2
[10:59:32.214] result() for MulticoreFuture ...
[10:59:32.214] result() for MulticoreFuture ... done
[10:59:32.214] result() for MulticoreFuture ...
[10:59:32.214] result() for MulticoreFuture ... done
[10:59:32.214] result() for MulticoreFuture ...
[10:59:32.215] result() for MulticoreFuture ... done
[10:59:32.215] result() for MulticoreFuture ...
[10:59:32.215] result() for MulticoreFuture ... done
[10:59:32.215] - relayed: [n=2] TRUE, TRUE
[10:59:32.215] - queued futures: [n=2] TRUE, TRUE
[10:59:32.215] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.215]  length: 0 (resolved future 2)
[10:59:32.216] Relaying remaining futures
[10:59:32.216] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.216] - nx: 2
[10:59:32.216] - relay: TRUE
[10:59:32.216] - stdout: TRUE
[10:59:32.216] - signal: TRUE
[10:59:32.216] - resignal: FALSE
[10:59:32.216] - force: TRUE
[10:59:32.216] - relayed: [n=2] TRUE, TRUE
[10:59:32.217] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:32.217] - relayed: [n=2] TRUE, TRUE
[10:59:32.217] - queued futures: [n=2] TRUE, TRUE
[10:59:32.217] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.217] resolve() on list ... DONE
[10:59:32.217] result() for MulticoreFuture ...
[10:59:32.217] result() for MulticoreFuture ... done
[10:59:32.217] result() for MulticoreFuture ...
[10:59:32.217] result() for MulticoreFuture ... done
[10:59:32.218] result() for MulticoreFuture ...
[10:59:32.218] result() for MulticoreFuture ... done
[10:59:32.218] result() for MulticoreFuture ...
[10:59:32.218] result() for MulticoreFuture ... done
[10:59:32.218]  - Number of value chunks collected: 2
[10:59:32.218] Resolving 2 futures (chunks) ... DONE
[10:59:32.218] Reducing values from 2 chunks ...
[10:59:32.218]  - Number of values collected after concatenation: 3
[10:59:32.219]  - Number of values expected: 3
[10:59:32.219] Reducing values from 2 chunks ... DONE
[10:59:32.219] future_mapply() ... DONE
- future_.mapply()
[10:59:32.219] future_mapply() ...
[10:59:32.221] Number of chunks: 2
[10:59:32.221] getGlobalsAndPackagesXApply() ...
[10:59:32.221]  - future.globals: TRUE
[10:59:32.221] getGlobalsAndPackages() ...
[10:59:32.222] Searching for globals...
[10:59:32.223] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:59:32.223] Searching for globals ... DONE
[10:59:32.223] Resolving globals: FALSE
[10:59:32.224] The total size of the 1 globals is 414 bytes (414 bytes)
[10:59:32.224] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:59:32.224] - globals: [1] ‘FUN’
[10:59:32.224] 
[10:59:32.224] getGlobalsAndPackages() ... DONE
[10:59:32.224]  - globals found/used: [n=1] ‘FUN’
[10:59:32.225]  - needed namespaces: [n=0] 
[10:59:32.225] Finding globals ... DONE
[10:59:32.225] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.225] List of 2
[10:59:32.225]  $ ...future.FUN:function (x, y)  
[10:59:32.225]  $ MoreArgs     : list()
[10:59:32.225]  - attr(*, "where")=List of 2
[10:59:32.225]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.225]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.225]  - attr(*, "resolved")= logi FALSE
[10:59:32.225]  - attr(*, "total_size")= num NA
[10:59:32.228] Packages to be attached in all futures: [n=0] 
[10:59:32.228] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.228] Number of futures (= number of chunks): 2
[10:59:32.228] Launching 2 futures (chunks) ...
[10:59:32.228] Chunk #1 of 2 ...
[10:59:32.228]  - Finding globals in '...' for chunk #1 ...
[10:59:32.228] getGlobalsAndPackages() ...
[10:59:32.229] Searching for globals...
[10:59:32.229] 
[10:59:32.229] Searching for globals ... DONE
[10:59:32.229] - globals: [0] <none>
[10:59:32.229] getGlobalsAndPackages() ... DONE
[10:59:32.229]    + additional globals found: [n=0] 
[10:59:32.229]    + additional namespaces needed: [n=0] 
[10:59:32.229]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.229]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.230]  - seeds: <none>
[10:59:32.230]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.230] getGlobalsAndPackages() ...
[10:59:32.230] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.230] Resolving globals: FALSE
[10:59:32.230] The total size of the 5 globals is 649 bytes (649 bytes)
[10:59:32.231] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 649 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:32.231] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.231] 
[10:59:32.231] getGlobalsAndPackages() ... DONE
[10:59:32.231] run() for ‘Future’ ...
[10:59:32.231] - state: ‘created’
[10:59:32.232] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.233] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.233]   - Field: ‘label’
[10:59:32.233]   - Field: ‘local’
[10:59:32.234]   - Field: ‘owner’
[10:59:32.234]   - Field: ‘envir’
[10:59:32.235]   - Field: ‘workers’
[10:59:32.235]   - Field: ‘packages’
[10:59:32.235]   - Field: ‘gc’
[10:59:32.236]   - Field: ‘job’
[10:59:32.236]   - Field: ‘conditions’
[10:59:32.236]   - Field: ‘expr’
[10:59:32.236]   - Field: ‘uuid’
[10:59:32.236]   - Field: ‘seed’
[10:59:32.236]   - Field: ‘version’
[10:59:32.236]   - Field: ‘result’
[10:59:32.236]   - Field: ‘asynchronous’
[10:59:32.236]   - Field: ‘calls’
[10:59:32.236]   - Field: ‘globals’
[10:59:32.236]   - Field: ‘stdout’
[10:59:32.236]   - Field: ‘earlySignal’
[10:59:32.237]   - Field: ‘lazy’
[10:59:32.237]   - Field: ‘state’
[10:59:32.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.237] - Launch lazy future ...
[10:59:32.237] Packages needed by the future expression (n = 0): <none>
[10:59:32.237] Packages needed by future strategies (n = 0): <none>
[10:59:32.238] {
[10:59:32.238]     {
[10:59:32.238]         {
[10:59:32.238]             ...future.startTime <- base::Sys.time()
[10:59:32.238]             {
[10:59:32.238]                 {
[10:59:32.238]                   {
[10:59:32.238]                     {
[10:59:32.238]                       base::local({
[10:59:32.238]                         has_future <- base::requireNamespace("future", 
[10:59:32.238]                           quietly = TRUE)
[10:59:32.238]                         if (has_future) {
[10:59:32.238]                           ns <- base::getNamespace("future")
[10:59:32.238]                           version <- ns[[".package"]][["version"]]
[10:59:32.238]                           if (is.null(version)) 
[10:59:32.238]                             version <- utils::packageVersion("future")
[10:59:32.238]                         }
[10:59:32.238]                         else {
[10:59:32.238]                           version <- NULL
[10:59:32.238]                         }
[10:59:32.238]                         if (!has_future || version < "1.8.0") {
[10:59:32.238]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.238]                             "", base::R.version$version.string), 
[10:59:32.238]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.238]                               "release", "version")], collapse = " "), 
[10:59:32.238]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.238]                             info)
[10:59:32.238]                           info <- base::paste(info, collapse = "; ")
[10:59:32.238]                           if (!has_future) {
[10:59:32.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.238]                               info)
[10:59:32.238]                           }
[10:59:32.238]                           else {
[10:59:32.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.238]                               info, version)
[10:59:32.238]                           }
[10:59:32.238]                           base::stop(msg)
[10:59:32.238]                         }
[10:59:32.238]                       })
[10:59:32.238]                     }
[10:59:32.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.238]                     base::options(mc.cores = 1L)
[10:59:32.238]                   }
[10:59:32.238]                   ...future.strategy.old <- future::plan("list")
[10:59:32.238]                   options(future.plan = NULL)
[10:59:32.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.238]                 }
[10:59:32.238]                 ...future.workdir <- getwd()
[10:59:32.238]             }
[10:59:32.238]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.238]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.238]         }
[10:59:32.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.238]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.238]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.238]             base::names(...future.oldOptions))
[10:59:32.238]     }
[10:59:32.238]     if (FALSE) {
[10:59:32.238]     }
[10:59:32.238]     else {
[10:59:32.238]         if (TRUE) {
[10:59:32.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.238]                 open = "w")
[10:59:32.238]         }
[10:59:32.238]         else {
[10:59:32.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.238]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.238]         }
[10:59:32.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.238]             base::sink(type = "output", split = FALSE)
[10:59:32.238]             base::close(...future.stdout)
[10:59:32.238]         }, add = TRUE)
[10:59:32.238]     }
[10:59:32.238]     ...future.frame <- base::sys.nframe()
[10:59:32.238]     ...future.conditions <- base::list()
[10:59:32.238]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.238]     if (FALSE) {
[10:59:32.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.238]     }
[10:59:32.238]     ...future.result <- base::tryCatch({
[10:59:32.238]         base::withCallingHandlers({
[10:59:32.238]             ...future.value <- base::withVisible(base::local({
[10:59:32.238]                 withCallingHandlers({
[10:59:32.238]                   {
[10:59:32.238]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.238]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.238]                       ...future.globals.maxSize)) {
[10:59:32.238]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.238]                       on.exit(options(oopts), add = TRUE)
[10:59:32.238]                     }
[10:59:32.238]                     {
[10:59:32.238]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.238]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.238]                         USE.NAMES = FALSE)
[10:59:32.238]                       do.call(mapply, args = args)
[10:59:32.238]                     }
[10:59:32.238]                   }
[10:59:32.238]                 }, immediateCondition = function(cond) {
[10:59:32.238]                   save_rds <- function (object, pathname, ...) 
[10:59:32.238]                   {
[10:59:32.238]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.238]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.238]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.238]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.238]                         fi_tmp[["mtime"]])
[10:59:32.238]                     }
[10:59:32.238]                     tryCatch({
[10:59:32.238]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.238]                     }, error = function(ex) {
[10:59:32.238]                       msg <- conditionMessage(ex)
[10:59:32.238]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.238]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.238]                         fi_tmp[["mtime"]], msg)
[10:59:32.238]                       ex$message <- msg
[10:59:32.238]                       stop(ex)
[10:59:32.238]                     })
[10:59:32.238]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.238]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.238]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.238]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.238]                       fi <- file.info(pathname)
[10:59:32.238]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.238]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.238]                         fi[["size"]], fi[["mtime"]])
[10:59:32.238]                       stop(msg)
[10:59:32.238]                     }
[10:59:32.238]                     invisible(pathname)
[10:59:32.238]                   }
[10:59:32.238]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.238]                     rootPath = tempdir()) 
[10:59:32.238]                   {
[10:59:32.238]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.238]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.238]                       tmpdir = path, fileext = ".rds")
[10:59:32.238]                     save_rds(obj, file)
[10:59:32.238]                   }
[10:59:32.238]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.238]                   {
[10:59:32.238]                     inherits <- base::inherits
[10:59:32.238]                     invokeRestart <- base::invokeRestart
[10:59:32.238]                     is.null <- base::is.null
[10:59:32.238]                     muffled <- FALSE
[10:59:32.238]                     if (inherits(cond, "message")) {
[10:59:32.238]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.238]                       if (muffled) 
[10:59:32.238]                         invokeRestart("muffleMessage")
[10:59:32.238]                     }
[10:59:32.238]                     else if (inherits(cond, "warning")) {
[10:59:32.238]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.238]                       if (muffled) 
[10:59:32.238]                         invokeRestart("muffleWarning")
[10:59:32.238]                     }
[10:59:32.238]                     else if (inherits(cond, "condition")) {
[10:59:32.238]                       if (!is.null(pattern)) {
[10:59:32.238]                         computeRestarts <- base::computeRestarts
[10:59:32.238]                         grepl <- base::grepl
[10:59:32.238]                         restarts <- computeRestarts(cond)
[10:59:32.238]                         for (restart in restarts) {
[10:59:32.238]                           name <- restart$name
[10:59:32.238]                           if (is.null(name)) 
[10:59:32.238]                             next
[10:59:32.238]                           if (!grepl(pattern, name)) 
[10:59:32.238]                             next
[10:59:32.238]                           invokeRestart(restart)
[10:59:32.238]                           muffled <- TRUE
[10:59:32.238]                           break
[10:59:32.238]                         }
[10:59:32.238]                       }
[10:59:32.238]                     }
[10:59:32.238]                     invisible(muffled)
[10:59:32.238]                   }
[10:59:32.238]                   muffleCondition(cond)
[10:59:32.238]                 })
[10:59:32.238]             }))
[10:59:32.238]             future::FutureResult(value = ...future.value$value, 
[10:59:32.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.238]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.238]                     ...future.globalenv.names))
[10:59:32.238]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.238]         }, condition = base::local({
[10:59:32.238]             c <- base::c
[10:59:32.238]             inherits <- base::inherits
[10:59:32.238]             invokeRestart <- base::invokeRestart
[10:59:32.238]             length <- base::length
[10:59:32.238]             list <- base::list
[10:59:32.238]             seq.int <- base::seq.int
[10:59:32.238]             signalCondition <- base::signalCondition
[10:59:32.238]             sys.calls <- base::sys.calls
[10:59:32.238]             `[[` <- base::`[[`
[10:59:32.238]             `+` <- base::`+`
[10:59:32.238]             `<<-` <- base::`<<-`
[10:59:32.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.238]                   3L)]
[10:59:32.238]             }
[10:59:32.238]             function(cond) {
[10:59:32.238]                 is_error <- inherits(cond, "error")
[10:59:32.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.238]                   NULL)
[10:59:32.238]                 if (is_error) {
[10:59:32.238]                   sessionInformation <- function() {
[10:59:32.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.238]                       search = base::search(), system = base::Sys.info())
[10:59:32.238]                   }
[10:59:32.238]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.238]                     cond$call), session = sessionInformation(), 
[10:59:32.238]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.238]                   signalCondition(cond)
[10:59:32.238]                 }
[10:59:32.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.238]                 "immediateCondition"))) {
[10:59:32.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.238]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.238]                   if (TRUE && !signal) {
[10:59:32.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.238]                     {
[10:59:32.238]                       inherits <- base::inherits
[10:59:32.238]                       invokeRestart <- base::invokeRestart
[10:59:32.238]                       is.null <- base::is.null
[10:59:32.238]                       muffled <- FALSE
[10:59:32.238]                       if (inherits(cond, "message")) {
[10:59:32.238]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.238]                         if (muffled) 
[10:59:32.238]                           invokeRestart("muffleMessage")
[10:59:32.238]                       }
[10:59:32.238]                       else if (inherits(cond, "warning")) {
[10:59:32.238]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.238]                         if (muffled) 
[10:59:32.238]                           invokeRestart("muffleWarning")
[10:59:32.238]                       }
[10:59:32.238]                       else if (inherits(cond, "condition")) {
[10:59:32.238]                         if (!is.null(pattern)) {
[10:59:32.238]                           computeRestarts <- base::computeRestarts
[10:59:32.238]                           grepl <- base::grepl
[10:59:32.238]                           restarts <- computeRestarts(cond)
[10:59:32.238]                           for (restart in restarts) {
[10:59:32.238]                             name <- restart$name
[10:59:32.238]                             if (is.null(name)) 
[10:59:32.238]                               next
[10:59:32.238]                             if (!grepl(pattern, name)) 
[10:59:32.238]                               next
[10:59:32.238]                             invokeRestart(restart)
[10:59:32.238]                             muffled <- TRUE
[10:59:32.238]                             break
[10:59:32.238]                           }
[10:59:32.238]                         }
[10:59:32.238]                       }
[10:59:32.238]                       invisible(muffled)
[10:59:32.238]                     }
[10:59:32.238]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.238]                   }
[10:59:32.238]                 }
[10:59:32.238]                 else {
[10:59:32.238]                   if (TRUE) {
[10:59:32.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.238]                     {
[10:59:32.238]                       inherits <- base::inherits
[10:59:32.238]                       invokeRestart <- base::invokeRestart
[10:59:32.238]                       is.null <- base::is.null
[10:59:32.238]                       muffled <- FALSE
[10:59:32.238]                       if (inherits(cond, "message")) {
[10:59:32.238]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.238]                         if (muffled) 
[10:59:32.238]                           invokeRestart("muffleMessage")
[10:59:32.238]                       }
[10:59:32.238]                       else if (inherits(cond, "warning")) {
[10:59:32.238]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.238]                         if (muffled) 
[10:59:32.238]                           invokeRestart("muffleWarning")
[10:59:32.238]                       }
[10:59:32.238]                       else if (inherits(cond, "condition")) {
[10:59:32.238]                         if (!is.null(pattern)) {
[10:59:32.238]                           computeRestarts <- base::computeRestarts
[10:59:32.238]                           grepl <- base::grepl
[10:59:32.238]                           restarts <- computeRestarts(cond)
[10:59:32.238]                           for (restart in restarts) {
[10:59:32.238]                             name <- restart$name
[10:59:32.238]                             if (is.null(name)) 
[10:59:32.238]                               next
[10:59:32.238]                             if (!grepl(pattern, name)) 
[10:59:32.238]                               next
[10:59:32.238]                             invokeRestart(restart)
[10:59:32.238]                             muffled <- TRUE
[10:59:32.238]                             break
[10:59:32.238]                           }
[10:59:32.238]                         }
[10:59:32.238]                       }
[10:59:32.238]                       invisible(muffled)
[10:59:32.238]                     }
[10:59:32.238]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.238]                   }
[10:59:32.238]                 }
[10:59:32.238]             }
[10:59:32.238]         }))
[10:59:32.238]     }, error = function(ex) {
[10:59:32.238]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.238]                 ...future.rng), started = ...future.startTime, 
[10:59:32.238]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.238]             version = "1.8"), class = "FutureResult")
[10:59:32.238]     }, finally = {
[10:59:32.238]         if (!identical(...future.workdir, getwd())) 
[10:59:32.238]             setwd(...future.workdir)
[10:59:32.238]         {
[10:59:32.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.238]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.238]             }
[10:59:32.238]             base::options(...future.oldOptions)
[10:59:32.238]             if (.Platform$OS.type == "windows") {
[10:59:32.238]                 old_names <- names(...future.oldEnvVars)
[10:59:32.238]                 envs <- base::Sys.getenv()
[10:59:32.238]                 names <- names(envs)
[10:59:32.238]                 common <- intersect(names, old_names)
[10:59:32.238]                 added <- setdiff(names, old_names)
[10:59:32.238]                 removed <- setdiff(old_names, names)
[10:59:32.238]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.238]                   envs[common]]
[10:59:32.238]                 NAMES <- toupper(changed)
[10:59:32.238]                 args <- list()
[10:59:32.238]                 for (kk in seq_along(NAMES)) {
[10:59:32.238]                   name <- changed[[kk]]
[10:59:32.238]                   NAME <- NAMES[[kk]]
[10:59:32.238]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.238]                     next
[10:59:32.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.238]                 }
[10:59:32.238]                 NAMES <- toupper(added)
[10:59:32.238]                 for (kk in seq_along(NAMES)) {
[10:59:32.238]                   name <- added[[kk]]
[10:59:32.238]                   NAME <- NAMES[[kk]]
[10:59:32.238]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.238]                     next
[10:59:32.238]                   args[[name]] <- ""
[10:59:32.238]                 }
[10:59:32.238]                 NAMES <- toupper(removed)
[10:59:32.238]                 for (kk in seq_along(NAMES)) {
[10:59:32.238]                   name <- removed[[kk]]
[10:59:32.238]                   NAME <- NAMES[[kk]]
[10:59:32.238]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.238]                     next
[10:59:32.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.238]                 }
[10:59:32.238]                 if (length(args) > 0) 
[10:59:32.238]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.238]             }
[10:59:32.238]             else {
[10:59:32.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.238]             }
[10:59:32.238]             {
[10:59:32.238]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.238]                   0L) {
[10:59:32.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.238]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.238]                   base::options(opts)
[10:59:32.238]                 }
[10:59:32.238]                 {
[10:59:32.238]                   {
[10:59:32.238]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.238]                     NULL
[10:59:32.238]                   }
[10:59:32.238]                   options(future.plan = NULL)
[10:59:32.238]                   if (is.na(NA_character_)) 
[10:59:32.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.238]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.238]                     .init = FALSE)
[10:59:32.238]                 }
[10:59:32.238]             }
[10:59:32.238]         }
[10:59:32.238]     })
[10:59:32.238]     if (TRUE) {
[10:59:32.238]         base::sink(type = "output", split = FALSE)
[10:59:32.238]         if (TRUE) {
[10:59:32.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.238]         }
[10:59:32.238]         else {
[10:59:32.238]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.238]         }
[10:59:32.238]         base::close(...future.stdout)
[10:59:32.238]         ...future.stdout <- NULL
[10:59:32.238]     }
[10:59:32.238]     ...future.result$conditions <- ...future.conditions
[10:59:32.238]     ...future.result$finished <- base::Sys.time()
[10:59:32.238]     ...future.result
[10:59:32.238] }
[10:59:32.240] assign_globals() ...
[10:59:32.240] List of 5
[10:59:32.240]  $ ...future.FUN            :function (x, y)  
[10:59:32.240]  $ MoreArgs                 : list()
[10:59:32.240]  $ ...future.elements_ii    :List of 2
[10:59:32.240]   ..$ :List of 1
[10:59:32.240]   .. ..$ a: num 1
[10:59:32.240]   ..$ :List of 1
[10:59:32.240]   .. ..$ A: num 10
[10:59:32.240]  $ ...future.seeds_ii       : NULL
[10:59:32.240]  $ ...future.globals.maxSize: NULL
[10:59:32.240]  - attr(*, "where")=List of 5
[10:59:32.240]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.240]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.240]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.240]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.240]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.240]  - attr(*, "resolved")= logi FALSE
[10:59:32.240]  - attr(*, "total_size")= num 649
[10:59:32.240]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.240]  - attr(*, "already-done")= logi TRUE
[10:59:32.245] - reassign environment for ‘...future.FUN’
[10:59:32.245] - copied ‘...future.FUN’ to environment
[10:59:32.245] - copied ‘MoreArgs’ to environment
[10:59:32.245] - copied ‘...future.elements_ii’ to environment
[10:59:32.245] - copied ‘...future.seeds_ii’ to environment
[10:59:32.245] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.246] assign_globals() ... done
[10:59:32.246] requestCore(): workers = 2
[10:59:32.247] MulticoreFuture started
[10:59:32.248] - Launch lazy future ... done
[10:59:32.248] run() for ‘MulticoreFuture’ ... done
[10:59:32.248] Created future:
[10:59:32.248] plan(): Setting new future strategy stack:
[10:59:32.249] List of future strategies:
[10:59:32.249] 1. sequential:
[10:59:32.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.249]    - tweaked: FALSE
[10:59:32.249]    - call: NULL
[10:59:32.250] plan(): nbrOfWorkers() = 1
[10:59:32.252] plan(): Setting new future strategy stack:
[10:59:32.252] List of future strategies:
[10:59:32.252] 1. multicore:
[10:59:32.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.252]    - tweaked: FALSE
[10:59:32.252]    - call: plan(strategy)
[10:59:32.255] plan(): nbrOfWorkers() = 2
[10:59:32.248] MulticoreFuture:
[10:59:32.248] Label: ‘future_.mapply-1’
[10:59:32.248] Expression:
[10:59:32.248] {
[10:59:32.248]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.248]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.248]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.248]         on.exit(options(oopts), add = TRUE)
[10:59:32.248]     }
[10:59:32.248]     {
[10:59:32.248]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.248]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.248]         do.call(mapply, args = args)
[10:59:32.248]     }
[10:59:32.248] }
[10:59:32.248] Lazy evaluation: FALSE
[10:59:32.248] Asynchronous evaluation: TRUE
[10:59:32.248] Local evaluation: TRUE
[10:59:32.248] Environment: R_GlobalEnv
[10:59:32.248] Capture standard output: TRUE
[10:59:32.248] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.248] Globals: 5 objects totaling 649 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.248] Packages: <none>
[10:59:32.248] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.248] Resolved: TRUE
[10:59:32.248] Value: <not collected>
[10:59:32.248] Conditions captured: <none>
[10:59:32.248] Early signaling: FALSE
[10:59:32.248] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.248] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.256] Chunk #1 of 2 ... DONE
[10:59:32.256] Chunk #2 of 2 ...
[10:59:32.256]  - Finding globals in '...' for chunk #2 ...
[10:59:32.256] getGlobalsAndPackages() ...
[10:59:32.256] Searching for globals...
[10:59:32.257] 
[10:59:32.257] Searching for globals ... DONE
[10:59:32.257] - globals: [0] <none>
[10:59:32.257] getGlobalsAndPackages() ... DONE
[10:59:32.257]    + additional globals found: [n=0] 
[10:59:32.258]    + additional namespaces needed: [n=0] 
[10:59:32.258]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:32.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.258]  - seeds: <none>
[10:59:32.258]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.258] getGlobalsAndPackages() ...
[10:59:32.258] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.259] Resolving globals: FALSE
[10:59:32.259] The total size of the 5 globals is 699 bytes (699 bytes)
[10:59:32.260] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 699 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:32.260] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.260] 
[10:59:32.261] getGlobalsAndPackages() ... DONE
[10:59:32.261] run() for ‘Future’ ...
[10:59:32.261] - state: ‘created’
[10:59:32.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.264] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.264] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.264]   - Field: ‘label’
[10:59:32.265]   - Field: ‘local’
[10:59:32.265]   - Field: ‘owner’
[10:59:32.265]   - Field: ‘envir’
[10:59:32.265]   - Field: ‘workers’
[10:59:32.265]   - Field: ‘packages’
[10:59:32.266]   - Field: ‘gc’
[10:59:32.266]   - Field: ‘job’
[10:59:32.266]   - Field: ‘conditions’
[10:59:32.266]   - Field: ‘expr’
[10:59:32.266]   - Field: ‘uuid’
[10:59:32.266]   - Field: ‘seed’
[10:59:32.266]   - Field: ‘version’
[10:59:32.266]   - Field: ‘result’
[10:59:32.267]   - Field: ‘asynchronous’
[10:59:32.267]   - Field: ‘calls’
[10:59:32.267]   - Field: ‘globals’
[10:59:32.267]   - Field: ‘stdout’
[10:59:32.267]   - Field: ‘earlySignal’
[10:59:32.267]   - Field: ‘lazy’
[10:59:32.267]   - Field: ‘state’
[10:59:32.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.268] - Launch lazy future ...
[10:59:32.268] Packages needed by the future expression (n = 0): <none>
[10:59:32.268] Packages needed by future strategies (n = 0): <none>
[10:59:32.269] {
[10:59:32.269]     {
[10:59:32.269]         {
[10:59:32.269]             ...future.startTime <- base::Sys.time()
[10:59:32.269]             {
[10:59:32.269]                 {
[10:59:32.269]                   {
[10:59:32.269]                     {
[10:59:32.269]                       base::local({
[10:59:32.269]                         has_future <- base::requireNamespace("future", 
[10:59:32.269]                           quietly = TRUE)
[10:59:32.269]                         if (has_future) {
[10:59:32.269]                           ns <- base::getNamespace("future")
[10:59:32.269]                           version <- ns[[".package"]][["version"]]
[10:59:32.269]                           if (is.null(version)) 
[10:59:32.269]                             version <- utils::packageVersion("future")
[10:59:32.269]                         }
[10:59:32.269]                         else {
[10:59:32.269]                           version <- NULL
[10:59:32.269]                         }
[10:59:32.269]                         if (!has_future || version < "1.8.0") {
[10:59:32.269]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.269]                             "", base::R.version$version.string), 
[10:59:32.269]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.269]                               "release", "version")], collapse = " "), 
[10:59:32.269]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.269]                             info)
[10:59:32.269]                           info <- base::paste(info, collapse = "; ")
[10:59:32.269]                           if (!has_future) {
[10:59:32.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.269]                               info)
[10:59:32.269]                           }
[10:59:32.269]                           else {
[10:59:32.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.269]                               info, version)
[10:59:32.269]                           }
[10:59:32.269]                           base::stop(msg)
[10:59:32.269]                         }
[10:59:32.269]                       })
[10:59:32.269]                     }
[10:59:32.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.269]                     base::options(mc.cores = 1L)
[10:59:32.269]                   }
[10:59:32.269]                   ...future.strategy.old <- future::plan("list")
[10:59:32.269]                   options(future.plan = NULL)
[10:59:32.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.269]                 }
[10:59:32.269]                 ...future.workdir <- getwd()
[10:59:32.269]             }
[10:59:32.269]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.269]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.269]         }
[10:59:32.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.269]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.269]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.269]             base::names(...future.oldOptions))
[10:59:32.269]     }
[10:59:32.269]     if (FALSE) {
[10:59:32.269]     }
[10:59:32.269]     else {
[10:59:32.269]         if (TRUE) {
[10:59:32.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.269]                 open = "w")
[10:59:32.269]         }
[10:59:32.269]         else {
[10:59:32.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.269]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.269]         }
[10:59:32.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.269]             base::sink(type = "output", split = FALSE)
[10:59:32.269]             base::close(...future.stdout)
[10:59:32.269]         }, add = TRUE)
[10:59:32.269]     }
[10:59:32.269]     ...future.frame <- base::sys.nframe()
[10:59:32.269]     ...future.conditions <- base::list()
[10:59:32.269]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.269]     if (FALSE) {
[10:59:32.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.269]     }
[10:59:32.269]     ...future.result <- base::tryCatch({
[10:59:32.269]         base::withCallingHandlers({
[10:59:32.269]             ...future.value <- base::withVisible(base::local({
[10:59:32.269]                 withCallingHandlers({
[10:59:32.269]                   {
[10:59:32.269]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.269]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.269]                       ...future.globals.maxSize)) {
[10:59:32.269]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.269]                       on.exit(options(oopts), add = TRUE)
[10:59:32.269]                     }
[10:59:32.269]                     {
[10:59:32.269]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.269]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.269]                         USE.NAMES = FALSE)
[10:59:32.269]                       do.call(mapply, args = args)
[10:59:32.269]                     }
[10:59:32.269]                   }
[10:59:32.269]                 }, immediateCondition = function(cond) {
[10:59:32.269]                   save_rds <- function (object, pathname, ...) 
[10:59:32.269]                   {
[10:59:32.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.269]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.269]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.269]                         fi_tmp[["mtime"]])
[10:59:32.269]                     }
[10:59:32.269]                     tryCatch({
[10:59:32.269]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.269]                     }, error = function(ex) {
[10:59:32.269]                       msg <- conditionMessage(ex)
[10:59:32.269]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.269]                         fi_tmp[["mtime"]], msg)
[10:59:32.269]                       ex$message <- msg
[10:59:32.269]                       stop(ex)
[10:59:32.269]                     })
[10:59:32.269]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.269]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.269]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.269]                       fi <- file.info(pathname)
[10:59:32.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.269]                         fi[["size"]], fi[["mtime"]])
[10:59:32.269]                       stop(msg)
[10:59:32.269]                     }
[10:59:32.269]                     invisible(pathname)
[10:59:32.269]                   }
[10:59:32.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.269]                     rootPath = tempdir()) 
[10:59:32.269]                   {
[10:59:32.269]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.269]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.269]                       tmpdir = path, fileext = ".rds")
[10:59:32.269]                     save_rds(obj, file)
[10:59:32.269]                   }
[10:59:32.269]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.269]                   {
[10:59:32.269]                     inherits <- base::inherits
[10:59:32.269]                     invokeRestart <- base::invokeRestart
[10:59:32.269]                     is.null <- base::is.null
[10:59:32.269]                     muffled <- FALSE
[10:59:32.269]                     if (inherits(cond, "message")) {
[10:59:32.269]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.269]                       if (muffled) 
[10:59:32.269]                         invokeRestart("muffleMessage")
[10:59:32.269]                     }
[10:59:32.269]                     else if (inherits(cond, "warning")) {
[10:59:32.269]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.269]                       if (muffled) 
[10:59:32.269]                         invokeRestart("muffleWarning")
[10:59:32.269]                     }
[10:59:32.269]                     else if (inherits(cond, "condition")) {
[10:59:32.269]                       if (!is.null(pattern)) {
[10:59:32.269]                         computeRestarts <- base::computeRestarts
[10:59:32.269]                         grepl <- base::grepl
[10:59:32.269]                         restarts <- computeRestarts(cond)
[10:59:32.269]                         for (restart in restarts) {
[10:59:32.269]                           name <- restart$name
[10:59:32.269]                           if (is.null(name)) 
[10:59:32.269]                             next
[10:59:32.269]                           if (!grepl(pattern, name)) 
[10:59:32.269]                             next
[10:59:32.269]                           invokeRestart(restart)
[10:59:32.269]                           muffled <- TRUE
[10:59:32.269]                           break
[10:59:32.269]                         }
[10:59:32.269]                       }
[10:59:32.269]                     }
[10:59:32.269]                     invisible(muffled)
[10:59:32.269]                   }
[10:59:32.269]                   muffleCondition(cond)
[10:59:32.269]                 })
[10:59:32.269]             }))
[10:59:32.269]             future::FutureResult(value = ...future.value$value, 
[10:59:32.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.269]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.269]                     ...future.globalenv.names))
[10:59:32.269]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.269]         }, condition = base::local({
[10:59:32.269]             c <- base::c
[10:59:32.269]             inherits <- base::inherits
[10:59:32.269]             invokeRestart <- base::invokeRestart
[10:59:32.269]             length <- base::length
[10:59:32.269]             list <- base::list
[10:59:32.269]             seq.int <- base::seq.int
[10:59:32.269]             signalCondition <- base::signalCondition
[10:59:32.269]             sys.calls <- base::sys.calls
[10:59:32.269]             `[[` <- base::`[[`
[10:59:32.269]             `+` <- base::`+`
[10:59:32.269]             `<<-` <- base::`<<-`
[10:59:32.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.269]                   3L)]
[10:59:32.269]             }
[10:59:32.269]             function(cond) {
[10:59:32.269]                 is_error <- inherits(cond, "error")
[10:59:32.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.269]                   NULL)
[10:59:32.269]                 if (is_error) {
[10:59:32.269]                   sessionInformation <- function() {
[10:59:32.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.269]                       search = base::search(), system = base::Sys.info())
[10:59:32.269]                   }
[10:59:32.269]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.269]                     cond$call), session = sessionInformation(), 
[10:59:32.269]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.269]                   signalCondition(cond)
[10:59:32.269]                 }
[10:59:32.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.269]                 "immediateCondition"))) {
[10:59:32.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.269]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.269]                   if (TRUE && !signal) {
[10:59:32.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.269]                     {
[10:59:32.269]                       inherits <- base::inherits
[10:59:32.269]                       invokeRestart <- base::invokeRestart
[10:59:32.269]                       is.null <- base::is.null
[10:59:32.269]                       muffled <- FALSE
[10:59:32.269]                       if (inherits(cond, "message")) {
[10:59:32.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.269]                         if (muffled) 
[10:59:32.269]                           invokeRestart("muffleMessage")
[10:59:32.269]                       }
[10:59:32.269]                       else if (inherits(cond, "warning")) {
[10:59:32.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.269]                         if (muffled) 
[10:59:32.269]                           invokeRestart("muffleWarning")
[10:59:32.269]                       }
[10:59:32.269]                       else if (inherits(cond, "condition")) {
[10:59:32.269]                         if (!is.null(pattern)) {
[10:59:32.269]                           computeRestarts <- base::computeRestarts
[10:59:32.269]                           grepl <- base::grepl
[10:59:32.269]                           restarts <- computeRestarts(cond)
[10:59:32.269]                           for (restart in restarts) {
[10:59:32.269]                             name <- restart$name
[10:59:32.269]                             if (is.null(name)) 
[10:59:32.269]                               next
[10:59:32.269]                             if (!grepl(pattern, name)) 
[10:59:32.269]                               next
[10:59:32.269]                             invokeRestart(restart)
[10:59:32.269]                             muffled <- TRUE
[10:59:32.269]                             break
[10:59:32.269]                           }
[10:59:32.269]                         }
[10:59:32.269]                       }
[10:59:32.269]                       invisible(muffled)
[10:59:32.269]                     }
[10:59:32.269]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.269]                   }
[10:59:32.269]                 }
[10:59:32.269]                 else {
[10:59:32.269]                   if (TRUE) {
[10:59:32.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.269]                     {
[10:59:32.269]                       inherits <- base::inherits
[10:59:32.269]                       invokeRestart <- base::invokeRestart
[10:59:32.269]                       is.null <- base::is.null
[10:59:32.269]                       muffled <- FALSE
[10:59:32.269]                       if (inherits(cond, "message")) {
[10:59:32.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.269]                         if (muffled) 
[10:59:32.269]                           invokeRestart("muffleMessage")
[10:59:32.269]                       }
[10:59:32.269]                       else if (inherits(cond, "warning")) {
[10:59:32.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.269]                         if (muffled) 
[10:59:32.269]                           invokeRestart("muffleWarning")
[10:59:32.269]                       }
[10:59:32.269]                       else if (inherits(cond, "condition")) {
[10:59:32.269]                         if (!is.null(pattern)) {
[10:59:32.269]                           computeRestarts <- base::computeRestarts
[10:59:32.269]                           grepl <- base::grepl
[10:59:32.269]                           restarts <- computeRestarts(cond)
[10:59:32.269]                           for (restart in restarts) {
[10:59:32.269]                             name <- restart$name
[10:59:32.269]                             if (is.null(name)) 
[10:59:32.269]                               next
[10:59:32.269]                             if (!grepl(pattern, name)) 
[10:59:32.269]                               next
[10:59:32.269]                             invokeRestart(restart)
[10:59:32.269]                             muffled <- TRUE
[10:59:32.269]                             break
[10:59:32.269]                           }
[10:59:32.269]                         }
[10:59:32.269]                       }
[10:59:32.269]                       invisible(muffled)
[10:59:32.269]                     }
[10:59:32.269]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.269]                   }
[10:59:32.269]                 }
[10:59:32.269]             }
[10:59:32.269]         }))
[10:59:32.269]     }, error = function(ex) {
[10:59:32.269]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.269]                 ...future.rng), started = ...future.startTime, 
[10:59:32.269]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.269]             version = "1.8"), class = "FutureResult")
[10:59:32.269]     }, finally = {
[10:59:32.269]         if (!identical(...future.workdir, getwd())) 
[10:59:32.269]             setwd(...future.workdir)
[10:59:32.269]         {
[10:59:32.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.269]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.269]             }
[10:59:32.269]             base::options(...future.oldOptions)
[10:59:32.269]             if (.Platform$OS.type == "windows") {
[10:59:32.269]                 old_names <- names(...future.oldEnvVars)
[10:59:32.269]                 envs <- base::Sys.getenv()
[10:59:32.269]                 names <- names(envs)
[10:59:32.269]                 common <- intersect(names, old_names)
[10:59:32.269]                 added <- setdiff(names, old_names)
[10:59:32.269]                 removed <- setdiff(old_names, names)
[10:59:32.269]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.269]                   envs[common]]
[10:59:32.269]                 NAMES <- toupper(changed)
[10:59:32.269]                 args <- list()
[10:59:32.269]                 for (kk in seq_along(NAMES)) {
[10:59:32.269]                   name <- changed[[kk]]
[10:59:32.269]                   NAME <- NAMES[[kk]]
[10:59:32.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.269]                     next
[10:59:32.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.269]                 }
[10:59:32.269]                 NAMES <- toupper(added)
[10:59:32.269]                 for (kk in seq_along(NAMES)) {
[10:59:32.269]                   name <- added[[kk]]
[10:59:32.269]                   NAME <- NAMES[[kk]]
[10:59:32.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.269]                     next
[10:59:32.269]                   args[[name]] <- ""
[10:59:32.269]                 }
[10:59:32.269]                 NAMES <- toupper(removed)
[10:59:32.269]                 for (kk in seq_along(NAMES)) {
[10:59:32.269]                   name <- removed[[kk]]
[10:59:32.269]                   NAME <- NAMES[[kk]]
[10:59:32.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.269]                     next
[10:59:32.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.269]                 }
[10:59:32.269]                 if (length(args) > 0) 
[10:59:32.269]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.269]             }
[10:59:32.269]             else {
[10:59:32.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.269]             }
[10:59:32.269]             {
[10:59:32.269]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.269]                   0L) {
[10:59:32.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.269]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.269]                   base::options(opts)
[10:59:32.269]                 }
[10:59:32.269]                 {
[10:59:32.269]                   {
[10:59:32.269]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.269]                     NULL
[10:59:32.269]                   }
[10:59:32.269]                   options(future.plan = NULL)
[10:59:32.269]                   if (is.na(NA_character_)) 
[10:59:32.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.269]                     .init = FALSE)
[10:59:32.269]                 }
[10:59:32.269]             }
[10:59:32.269]         }
[10:59:32.269]     })
[10:59:32.269]     if (TRUE) {
[10:59:32.269]         base::sink(type = "output", split = FALSE)
[10:59:32.269]         if (TRUE) {
[10:59:32.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.269]         }
[10:59:32.269]         else {
[10:59:32.269]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.269]         }
[10:59:32.269]         base::close(...future.stdout)
[10:59:32.269]         ...future.stdout <- NULL
[10:59:32.269]     }
[10:59:32.269]     ...future.result$conditions <- ...future.conditions
[10:59:32.269]     ...future.result$finished <- base::Sys.time()
[10:59:32.269]     ...future.result
[10:59:32.269] }
[10:59:32.275] assign_globals() ...
[10:59:32.275] List of 5
[10:59:32.275]  $ ...future.FUN            :function (x, y)  
[10:59:32.275]  $ MoreArgs                 : list()
[10:59:32.275]  $ ...future.elements_ii    :List of 2
[10:59:32.275]   ..$ :List of 2
[10:59:32.275]   .. ..$ b: num 2
[10:59:32.275]   .. ..$ c: num 3
[10:59:32.275]   ..$ :List of 2
[10:59:32.275]   .. ..$ B: num 0
[10:59:32.275]   .. ..$ C: num -10
[10:59:32.275]  $ ...future.seeds_ii       : NULL
[10:59:32.275]  $ ...future.globals.maxSize: NULL
[10:59:32.275]  - attr(*, "where")=List of 5
[10:59:32.275]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.275]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.275]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.275]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.275]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.275]  - attr(*, "resolved")= logi FALSE
[10:59:32.275]  - attr(*, "total_size")= num 699
[10:59:32.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.275]  - attr(*, "already-done")= logi TRUE
[10:59:32.286] - reassign environment for ‘...future.FUN’
[10:59:32.286] - copied ‘...future.FUN’ to environment
[10:59:32.286] - copied ‘MoreArgs’ to environment
[10:59:32.286] - copied ‘...future.elements_ii’ to environment
[10:59:32.286] - copied ‘...future.seeds_ii’ to environment
[10:59:32.286] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.286] assign_globals() ... done
[10:59:32.286] requestCore(): workers = 2
[10:59:32.289] MulticoreFuture started
[10:59:32.289] - Launch lazy future ... done
[10:59:32.289] run() for ‘MulticoreFuture’ ... done
[10:59:32.289] Created future:
[10:59:32.290] plan(): Setting new future strategy stack:
[10:59:32.290] List of future strategies:
[10:59:32.290] 1. sequential:
[10:59:32.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.290]    - tweaked: FALSE
[10:59:32.290]    - call: NULL
[10:59:32.291] plan(): nbrOfWorkers() = 1
[10:59:32.293] plan(): Setting new future strategy stack:
[10:59:32.293] List of future strategies:
[10:59:32.293] 1. multicore:
[10:59:32.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.293]    - tweaked: FALSE
[10:59:32.293]    - call: plan(strategy)
[10:59:32.296] plan(): nbrOfWorkers() = 2
[10:59:32.290] MulticoreFuture:
[10:59:32.290] Label: ‘future_.mapply-2’
[10:59:32.290] Expression:
[10:59:32.290] {
[10:59:32.290]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.290]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.290]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.290]         on.exit(options(oopts), add = TRUE)
[10:59:32.290]     }
[10:59:32.290]     {
[10:59:32.290]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.290]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.290]         do.call(mapply, args = args)
[10:59:32.290]     }
[10:59:32.290] }
[10:59:32.290] Lazy evaluation: FALSE
[10:59:32.290] Asynchronous evaluation: TRUE
[10:59:32.290] Local evaluation: TRUE
[10:59:32.290] Environment: R_GlobalEnv
[10:59:32.290] Capture standard output: TRUE
[10:59:32.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.290] Globals: 5 objects totaling 699 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.290] Packages: <none>
[10:59:32.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.290] Resolved: TRUE
[10:59:32.290] Value: <not collected>
[10:59:32.290] Conditions captured: <none>
[10:59:32.290] Early signaling: FALSE
[10:59:32.290] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.290] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.297] Chunk #2 of 2 ... DONE
[10:59:32.297] Launching 2 futures (chunks) ... DONE
[10:59:32.297] Resolving 2 futures (chunks) ...
[10:59:32.298] resolve() on list ...
[10:59:32.298]  recursive: 0
[10:59:32.298]  length: 2
[10:59:32.298] 
[10:59:32.298] Future #1
[10:59:32.299] result() for MulticoreFuture ...
[10:59:32.299] result() for MulticoreFuture ...
[10:59:32.299] result() for MulticoreFuture ... done
[10:59:32.300] result() for MulticoreFuture ... done
[10:59:32.300] result() for MulticoreFuture ...
[10:59:32.300] result() for MulticoreFuture ... done
[10:59:32.300] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.300] - nx: 2
[10:59:32.300] - relay: TRUE
[10:59:32.300] - stdout: TRUE
[10:59:32.301] - signal: TRUE
[10:59:32.301] - resignal: FALSE
[10:59:32.301] - force: TRUE
[10:59:32.301] - relayed: [n=2] FALSE, FALSE
[10:59:32.301] - queued futures: [n=2] FALSE, FALSE
[10:59:32.301]  - until=1
[10:59:32.301]  - relaying element #1
[10:59:32.302] result() for MulticoreFuture ...
[10:59:32.302] result() for MulticoreFuture ... done
[10:59:32.302] result() for MulticoreFuture ...
[10:59:32.302] result() for MulticoreFuture ... done
[10:59:32.302] result() for MulticoreFuture ...
[10:59:32.302] result() for MulticoreFuture ... done
[10:59:32.302] result() for MulticoreFuture ...
[10:59:32.303] result() for MulticoreFuture ... done
[10:59:32.303] - relayed: [n=2] TRUE, FALSE
[10:59:32.303] - queued futures: [n=2] TRUE, FALSE
[10:59:32.303] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.303]  length: 1 (resolved future 1)
[10:59:32.303] Future #2
[10:59:32.304] result() for MulticoreFuture ...
[10:59:32.304] result() for MulticoreFuture ...
[10:59:32.305] result() for MulticoreFuture ... done
[10:59:32.305] result() for MulticoreFuture ... done
[10:59:32.305] result() for MulticoreFuture ...
[10:59:32.305] result() for MulticoreFuture ... done
[10:59:32.305] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.305] - nx: 2
[10:59:32.305] - relay: TRUE
[10:59:32.306] - stdout: TRUE
[10:59:32.306] - signal: TRUE
[10:59:32.306] - resignal: FALSE
[10:59:32.306] - force: TRUE
[10:59:32.306] - relayed: [n=2] TRUE, FALSE
[10:59:32.306] - queued futures: [n=2] TRUE, FALSE
[10:59:32.306]  - until=2
[10:59:32.306]  - relaying element #2
[10:59:32.306] result() for MulticoreFuture ...
[10:59:32.307] result() for MulticoreFuture ... done
[10:59:32.307] result() for MulticoreFuture ...
[10:59:32.307] result() for MulticoreFuture ... done
[10:59:32.307] result() for MulticoreFuture ...
[10:59:32.307] result() for MulticoreFuture ... done
[10:59:32.307] result() for MulticoreFuture ...
[10:59:32.307] result() for MulticoreFuture ... done
[10:59:32.307] - relayed: [n=2] TRUE, TRUE
[10:59:32.308] - queued futures: [n=2] TRUE, TRUE
[10:59:32.308] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.308]  length: 0 (resolved future 2)
[10:59:32.308] Relaying remaining futures
[10:59:32.308] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.308] - nx: 2
[10:59:32.308] - relay: TRUE
[10:59:32.308] - stdout: TRUE
[10:59:32.308] - signal: TRUE
[10:59:32.309] - resignal: FALSE
[10:59:32.309] - force: TRUE
[10:59:32.309] - relayed: [n=2] TRUE, TRUE
[10:59:32.309] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:32.309] - relayed: [n=2] TRUE, TRUE
[10:59:32.309] - queued futures: [n=2] TRUE, TRUE
[10:59:32.309] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.309] resolve() on list ... DONE
[10:59:32.309] result() for MulticoreFuture ...
[10:59:32.310] result() for MulticoreFuture ... done
[10:59:32.310] result() for MulticoreFuture ...
[10:59:32.310] result() for MulticoreFuture ... done
[10:59:32.310] result() for MulticoreFuture ...
[10:59:32.310] result() for MulticoreFuture ... done
[10:59:32.310] result() for MulticoreFuture ...
[10:59:32.310] result() for MulticoreFuture ... done
[10:59:32.310]  - Number of value chunks collected: 2
[10:59:32.310] Resolving 2 futures (chunks) ... DONE
[10:59:32.311] Reducing values from 2 chunks ...
[10:59:32.311]  - Number of values collected after concatenation: 3
[10:59:32.311]  - Number of values expected: 3
[10:59:32.311] Reducing values from 2 chunks ... DONE
[10:59:32.313] future_mapply() ... DONE
[10:59:32.313] future_mapply() ...
[10:59:32.316] Number of chunks: 5
[10:59:32.316] getGlobalsAndPackagesXApply() ...
[10:59:32.316]  - future.globals: TRUE
[10:59:32.316] getGlobalsAndPackages() ...
[10:59:32.317] Searching for globals...
[10:59:32.318] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:32.319] Searching for globals ... DONE
[10:59:32.319] Resolving globals: FALSE
[10:59:32.319] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:32.320] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:32.320] - globals: [1] ‘FUN’
[10:59:32.320] 
[10:59:32.320] getGlobalsAndPackages() ... DONE
[10:59:32.320]  - globals found/used: [n=1] ‘FUN’
[10:59:32.320]  - needed namespaces: [n=0] 
[10:59:32.320] Finding globals ... DONE
[10:59:32.320] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.321] List of 2
[10:59:32.321]  $ ...future.FUN:function (C, k)  
[10:59:32.321]  $ MoreArgs     : NULL
[10:59:32.321]  - attr(*, "where")=List of 2
[10:59:32.321]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.321]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.321]  - attr(*, "resolved")= logi FALSE
[10:59:32.321]  - attr(*, "total_size")= num NA
[10:59:32.323] Packages to be attached in all futures: [n=0] 
[10:59:32.324] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.324] Number of futures (= number of chunks): 5
[10:59:32.324] Launching 5 futures (chunks) ...
[10:59:32.324] Chunk #1 of 5 ...
[10:59:32.324]  - Finding globals in '...' for chunk #1 ...
[10:59:32.324] getGlobalsAndPackages() ...
[10:59:32.324] Searching for globals...
[10:59:32.325] 
[10:59:32.325] Searching for globals ... DONE
[10:59:32.325] - globals: [0] <none>
[10:59:32.325] getGlobalsAndPackages() ... DONE
[10:59:32.325]    + additional globals found: [n=0] 
[10:59:32.325]    + additional namespaces needed: [n=0] 
[10:59:32.325]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.325]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:32.325]  - seeds: <none>
[10:59:32.325]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.326] getGlobalsAndPackages() ...
[10:59:32.326] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.326] Resolving globals: FALSE
[10:59:32.326] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:32.327] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.327] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.327] 
[10:59:32.327] getGlobalsAndPackages() ... DONE
[10:59:32.327] run() for ‘Future’ ...
[10:59:32.327] - state: ‘created’
[10:59:32.327] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.329] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.329]   - Field: ‘label’
[10:59:32.329]   - Field: ‘local’
[10:59:32.329]   - Field: ‘owner’
[10:59:32.330]   - Field: ‘envir’
[10:59:32.330]   - Field: ‘workers’
[10:59:32.330]   - Field: ‘packages’
[10:59:32.330]   - Field: ‘gc’
[10:59:32.330]   - Field: ‘job’
[10:59:32.330]   - Field: ‘conditions’
[10:59:32.330]   - Field: ‘expr’
[10:59:32.330]   - Field: ‘uuid’
[10:59:32.330]   - Field: ‘seed’
[10:59:32.330]   - Field: ‘version’
[10:59:32.330]   - Field: ‘result’
[10:59:32.330]   - Field: ‘asynchronous’
[10:59:32.331]   - Field: ‘calls’
[10:59:32.331]   - Field: ‘globals’
[10:59:32.331]   - Field: ‘stdout’
[10:59:32.331]   - Field: ‘earlySignal’
[10:59:32.331]   - Field: ‘lazy’
[10:59:32.331]   - Field: ‘state’
[10:59:32.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.331] - Launch lazy future ...
[10:59:32.331] Packages needed by the future expression (n = 0): <none>
[10:59:32.332] Packages needed by future strategies (n = 0): <none>
[10:59:32.332] {
[10:59:32.332]     {
[10:59:32.332]         {
[10:59:32.332]             ...future.startTime <- base::Sys.time()
[10:59:32.332]             {
[10:59:32.332]                 {
[10:59:32.332]                   {
[10:59:32.332]                     {
[10:59:32.332]                       base::local({
[10:59:32.332]                         has_future <- base::requireNamespace("future", 
[10:59:32.332]                           quietly = TRUE)
[10:59:32.332]                         if (has_future) {
[10:59:32.332]                           ns <- base::getNamespace("future")
[10:59:32.332]                           version <- ns[[".package"]][["version"]]
[10:59:32.332]                           if (is.null(version)) 
[10:59:32.332]                             version <- utils::packageVersion("future")
[10:59:32.332]                         }
[10:59:32.332]                         else {
[10:59:32.332]                           version <- NULL
[10:59:32.332]                         }
[10:59:32.332]                         if (!has_future || version < "1.8.0") {
[10:59:32.332]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.332]                             "", base::R.version$version.string), 
[10:59:32.332]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.332]                               "release", "version")], collapse = " "), 
[10:59:32.332]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.332]                             info)
[10:59:32.332]                           info <- base::paste(info, collapse = "; ")
[10:59:32.332]                           if (!has_future) {
[10:59:32.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.332]                               info)
[10:59:32.332]                           }
[10:59:32.332]                           else {
[10:59:32.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.332]                               info, version)
[10:59:32.332]                           }
[10:59:32.332]                           base::stop(msg)
[10:59:32.332]                         }
[10:59:32.332]                       })
[10:59:32.332]                     }
[10:59:32.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.332]                     base::options(mc.cores = 1L)
[10:59:32.332]                   }
[10:59:32.332]                   ...future.strategy.old <- future::plan("list")
[10:59:32.332]                   options(future.plan = NULL)
[10:59:32.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.332]                 }
[10:59:32.332]                 ...future.workdir <- getwd()
[10:59:32.332]             }
[10:59:32.332]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.332]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.332]         }
[10:59:32.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.332]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:32.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.332]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.332]             base::names(...future.oldOptions))
[10:59:32.332]     }
[10:59:32.332]     if (FALSE) {
[10:59:32.332]     }
[10:59:32.332]     else {
[10:59:32.332]         if (TRUE) {
[10:59:32.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.332]                 open = "w")
[10:59:32.332]         }
[10:59:32.332]         else {
[10:59:32.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.332]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.332]         }
[10:59:32.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.332]             base::sink(type = "output", split = FALSE)
[10:59:32.332]             base::close(...future.stdout)
[10:59:32.332]         }, add = TRUE)
[10:59:32.332]     }
[10:59:32.332]     ...future.frame <- base::sys.nframe()
[10:59:32.332]     ...future.conditions <- base::list()
[10:59:32.332]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.332]     if (FALSE) {
[10:59:32.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.332]     }
[10:59:32.332]     ...future.result <- base::tryCatch({
[10:59:32.332]         base::withCallingHandlers({
[10:59:32.332]             ...future.value <- base::withVisible(base::local({
[10:59:32.332]                 withCallingHandlers({
[10:59:32.332]                   {
[10:59:32.332]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.332]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.332]                       ...future.globals.maxSize)) {
[10:59:32.332]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.332]                       on.exit(options(oopts), add = TRUE)
[10:59:32.332]                     }
[10:59:32.332]                     {
[10:59:32.332]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.332]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.332]                         USE.NAMES = FALSE)
[10:59:32.332]                       do.call(mapply, args = args)
[10:59:32.332]                     }
[10:59:32.332]                   }
[10:59:32.332]                 }, immediateCondition = function(cond) {
[10:59:32.332]                   save_rds <- function (object, pathname, ...) 
[10:59:32.332]                   {
[10:59:32.332]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.332]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.332]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.332]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.332]                         fi_tmp[["mtime"]])
[10:59:32.332]                     }
[10:59:32.332]                     tryCatch({
[10:59:32.332]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.332]                     }, error = function(ex) {
[10:59:32.332]                       msg <- conditionMessage(ex)
[10:59:32.332]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.332]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.332]                         fi_tmp[["mtime"]], msg)
[10:59:32.332]                       ex$message <- msg
[10:59:32.332]                       stop(ex)
[10:59:32.332]                     })
[10:59:32.332]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.332]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.332]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.332]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.332]                       fi <- file.info(pathname)
[10:59:32.332]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.332]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.332]                         fi[["size"]], fi[["mtime"]])
[10:59:32.332]                       stop(msg)
[10:59:32.332]                     }
[10:59:32.332]                     invisible(pathname)
[10:59:32.332]                   }
[10:59:32.332]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.332]                     rootPath = tempdir()) 
[10:59:32.332]                   {
[10:59:32.332]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.332]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.332]                       tmpdir = path, fileext = ".rds")
[10:59:32.332]                     save_rds(obj, file)
[10:59:32.332]                   }
[10:59:32.332]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.332]                   {
[10:59:32.332]                     inherits <- base::inherits
[10:59:32.332]                     invokeRestart <- base::invokeRestart
[10:59:32.332]                     is.null <- base::is.null
[10:59:32.332]                     muffled <- FALSE
[10:59:32.332]                     if (inherits(cond, "message")) {
[10:59:32.332]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.332]                       if (muffled) 
[10:59:32.332]                         invokeRestart("muffleMessage")
[10:59:32.332]                     }
[10:59:32.332]                     else if (inherits(cond, "warning")) {
[10:59:32.332]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.332]                       if (muffled) 
[10:59:32.332]                         invokeRestart("muffleWarning")
[10:59:32.332]                     }
[10:59:32.332]                     else if (inherits(cond, "condition")) {
[10:59:32.332]                       if (!is.null(pattern)) {
[10:59:32.332]                         computeRestarts <- base::computeRestarts
[10:59:32.332]                         grepl <- base::grepl
[10:59:32.332]                         restarts <- computeRestarts(cond)
[10:59:32.332]                         for (restart in restarts) {
[10:59:32.332]                           name <- restart$name
[10:59:32.332]                           if (is.null(name)) 
[10:59:32.332]                             next
[10:59:32.332]                           if (!grepl(pattern, name)) 
[10:59:32.332]                             next
[10:59:32.332]                           invokeRestart(restart)
[10:59:32.332]                           muffled <- TRUE
[10:59:32.332]                           break
[10:59:32.332]                         }
[10:59:32.332]                       }
[10:59:32.332]                     }
[10:59:32.332]                     invisible(muffled)
[10:59:32.332]                   }
[10:59:32.332]                   muffleCondition(cond)
[10:59:32.332]                 })
[10:59:32.332]             }))
[10:59:32.332]             future::FutureResult(value = ...future.value$value, 
[10:59:32.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.332]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.332]                     ...future.globalenv.names))
[10:59:32.332]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.332]         }, condition = base::local({
[10:59:32.332]             c <- base::c
[10:59:32.332]             inherits <- base::inherits
[10:59:32.332]             invokeRestart <- base::invokeRestart
[10:59:32.332]             length <- base::length
[10:59:32.332]             list <- base::list
[10:59:32.332]             seq.int <- base::seq.int
[10:59:32.332]             signalCondition <- base::signalCondition
[10:59:32.332]             sys.calls <- base::sys.calls
[10:59:32.332]             `[[` <- base::`[[`
[10:59:32.332]             `+` <- base::`+`
[10:59:32.332]             `<<-` <- base::`<<-`
[10:59:32.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.332]                   3L)]
[10:59:32.332]             }
[10:59:32.332]             function(cond) {
[10:59:32.332]                 is_error <- inherits(cond, "error")
[10:59:32.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.332]                   NULL)
[10:59:32.332]                 if (is_error) {
[10:59:32.332]                   sessionInformation <- function() {
[10:59:32.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.332]                       search = base::search(), system = base::Sys.info())
[10:59:32.332]                   }
[10:59:32.332]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.332]                     cond$call), session = sessionInformation(), 
[10:59:32.332]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.332]                   signalCondition(cond)
[10:59:32.332]                 }
[10:59:32.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.332]                 "immediateCondition"))) {
[10:59:32.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.332]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.332]                   if (TRUE && !signal) {
[10:59:32.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.332]                     {
[10:59:32.332]                       inherits <- base::inherits
[10:59:32.332]                       invokeRestart <- base::invokeRestart
[10:59:32.332]                       is.null <- base::is.null
[10:59:32.332]                       muffled <- FALSE
[10:59:32.332]                       if (inherits(cond, "message")) {
[10:59:32.332]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.332]                         if (muffled) 
[10:59:32.332]                           invokeRestart("muffleMessage")
[10:59:32.332]                       }
[10:59:32.332]                       else if (inherits(cond, "warning")) {
[10:59:32.332]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.332]                         if (muffled) 
[10:59:32.332]                           invokeRestart("muffleWarning")
[10:59:32.332]                       }
[10:59:32.332]                       else if (inherits(cond, "condition")) {
[10:59:32.332]                         if (!is.null(pattern)) {
[10:59:32.332]                           computeRestarts <- base::computeRestarts
[10:59:32.332]                           grepl <- base::grepl
[10:59:32.332]                           restarts <- computeRestarts(cond)
[10:59:32.332]                           for (restart in restarts) {
[10:59:32.332]                             name <- restart$name
[10:59:32.332]                             if (is.null(name)) 
[10:59:32.332]                               next
[10:59:32.332]                             if (!grepl(pattern, name)) 
[10:59:32.332]                               next
[10:59:32.332]                             invokeRestart(restart)
[10:59:32.332]                             muffled <- TRUE
[10:59:32.332]                             break
[10:59:32.332]                           }
[10:59:32.332]                         }
[10:59:32.332]                       }
[10:59:32.332]                       invisible(muffled)
[10:59:32.332]                     }
[10:59:32.332]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.332]                   }
[10:59:32.332]                 }
[10:59:32.332]                 else {
[10:59:32.332]                   if (TRUE) {
[10:59:32.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.332]                     {
[10:59:32.332]                       inherits <- base::inherits
[10:59:32.332]                       invokeRestart <- base::invokeRestart
[10:59:32.332]                       is.null <- base::is.null
[10:59:32.332]                       muffled <- FALSE
[10:59:32.332]                       if (inherits(cond, "message")) {
[10:59:32.332]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.332]                         if (muffled) 
[10:59:32.332]                           invokeRestart("muffleMessage")
[10:59:32.332]                       }
[10:59:32.332]                       else if (inherits(cond, "warning")) {
[10:59:32.332]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.332]                         if (muffled) 
[10:59:32.332]                           invokeRestart("muffleWarning")
[10:59:32.332]                       }
[10:59:32.332]                       else if (inherits(cond, "condition")) {
[10:59:32.332]                         if (!is.null(pattern)) {
[10:59:32.332]                           computeRestarts <- base::computeRestarts
[10:59:32.332]                           grepl <- base::grepl
[10:59:32.332]                           restarts <- computeRestarts(cond)
[10:59:32.332]                           for (restart in restarts) {
[10:59:32.332]                             name <- restart$name
[10:59:32.332]                             if (is.null(name)) 
[10:59:32.332]                               next
[10:59:32.332]                             if (!grepl(pattern, name)) 
[10:59:32.332]                               next
[10:59:32.332]                             invokeRestart(restart)
[10:59:32.332]                             muffled <- TRUE
[10:59:32.332]                             break
[10:59:32.332]                           }
[10:59:32.332]                         }
[10:59:32.332]                       }
[10:59:32.332]                       invisible(muffled)
[10:59:32.332]                     }
[10:59:32.332]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.332]                   }
[10:59:32.332]                 }
[10:59:32.332]             }
[10:59:32.332]         }))
[10:59:32.332]     }, error = function(ex) {
[10:59:32.332]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.332]                 ...future.rng), started = ...future.startTime, 
[10:59:32.332]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.332]             version = "1.8"), class = "FutureResult")
[10:59:32.332]     }, finally = {
[10:59:32.332]         if (!identical(...future.workdir, getwd())) 
[10:59:32.332]             setwd(...future.workdir)
[10:59:32.332]         {
[10:59:32.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.332]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.332]             }
[10:59:32.332]             base::options(...future.oldOptions)
[10:59:32.332]             if (.Platform$OS.type == "windows") {
[10:59:32.332]                 old_names <- names(...future.oldEnvVars)
[10:59:32.332]                 envs <- base::Sys.getenv()
[10:59:32.332]                 names <- names(envs)
[10:59:32.332]                 common <- intersect(names, old_names)
[10:59:32.332]                 added <- setdiff(names, old_names)
[10:59:32.332]                 removed <- setdiff(old_names, names)
[10:59:32.332]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.332]                   envs[common]]
[10:59:32.332]                 NAMES <- toupper(changed)
[10:59:32.332]                 args <- list()
[10:59:32.332]                 for (kk in seq_along(NAMES)) {
[10:59:32.332]                   name <- changed[[kk]]
[10:59:32.332]                   NAME <- NAMES[[kk]]
[10:59:32.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.332]                     next
[10:59:32.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.332]                 }
[10:59:32.332]                 NAMES <- toupper(added)
[10:59:32.332]                 for (kk in seq_along(NAMES)) {
[10:59:32.332]                   name <- added[[kk]]
[10:59:32.332]                   NAME <- NAMES[[kk]]
[10:59:32.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.332]                     next
[10:59:32.332]                   args[[name]] <- ""
[10:59:32.332]                 }
[10:59:32.332]                 NAMES <- toupper(removed)
[10:59:32.332]                 for (kk in seq_along(NAMES)) {
[10:59:32.332]                   name <- removed[[kk]]
[10:59:32.332]                   NAME <- NAMES[[kk]]
[10:59:32.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.332]                     next
[10:59:32.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.332]                 }
[10:59:32.332]                 if (length(args) > 0) 
[10:59:32.332]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.332]             }
[10:59:32.332]             else {
[10:59:32.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.332]             }
[10:59:32.332]             {
[10:59:32.332]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.332]                   0L) {
[10:59:32.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.332]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.332]                   base::options(opts)
[10:59:32.332]                 }
[10:59:32.332]                 {
[10:59:32.332]                   {
[10:59:32.332]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.332]                     NULL
[10:59:32.332]                   }
[10:59:32.332]                   options(future.plan = NULL)
[10:59:32.332]                   if (is.na(NA_character_)) 
[10:59:32.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.332]                     .init = FALSE)
[10:59:32.332]                 }
[10:59:32.332]             }
[10:59:32.332]         }
[10:59:32.332]     })
[10:59:32.332]     if (TRUE) {
[10:59:32.332]         base::sink(type = "output", split = FALSE)
[10:59:32.332]         if (TRUE) {
[10:59:32.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.332]         }
[10:59:32.332]         else {
[10:59:32.332]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.332]         }
[10:59:32.332]         base::close(...future.stdout)
[10:59:32.332]         ...future.stdout <- NULL
[10:59:32.332]     }
[10:59:32.332]     ...future.result$conditions <- ...future.conditions
[10:59:32.332]     ...future.result$finished <- base::Sys.time()
[10:59:32.332]     ...future.result
[10:59:32.332] }
[10:59:32.335] assign_globals() ...
[10:59:32.335] List of 5
[10:59:32.335]  $ ...future.FUN            :function (C, k)  
[10:59:32.335]  $ MoreArgs                 : NULL
[10:59:32.335]  $ ...future.elements_ii    :List of 2
[10:59:32.335]   ..$ :List of 1
[10:59:32.335]   .. ..$ : chr "A"
[10:59:32.335]   ..$ :List of 1
[10:59:32.335]   .. ..$ : int 5
[10:59:32.335]  $ ...future.seeds_ii       : NULL
[10:59:32.335]  $ ...future.globals.maxSize: NULL
[10:59:32.335]  - attr(*, "where")=List of 5
[10:59:32.335]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.335]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.335]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.335]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.335]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.335]  - attr(*, "resolved")= logi FALSE
[10:59:32.335]  - attr(*, "total_size")= num 847
[10:59:32.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.335]  - attr(*, "already-done")= logi TRUE
[10:59:32.341] - reassign environment for ‘...future.FUN’
[10:59:32.341] - copied ‘...future.FUN’ to environment
[10:59:32.341] - copied ‘MoreArgs’ to environment
[10:59:32.341] - copied ‘...future.elements_ii’ to environment
[10:59:32.341] - copied ‘...future.seeds_ii’ to environment
[10:59:32.341] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.342] assign_globals() ... done
[10:59:32.342] requestCore(): workers = 2
[10:59:32.344] MulticoreFuture started
[10:59:32.344] - Launch lazy future ... done
[10:59:32.344] run() for ‘MulticoreFuture’ ... done
[10:59:32.345] Created future:
[10:59:32.345] plan(): Setting new future strategy stack:
[10:59:32.345] List of future strategies:
[10:59:32.345] 1. sequential:
[10:59:32.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.345]    - tweaked: FALSE
[10:59:32.345]    - call: NULL
[10:59:32.346] plan(): nbrOfWorkers() = 1
[10:59:32.349] plan(): Setting new future strategy stack:
[10:59:32.349] List of future strategies:
[10:59:32.349] 1. multicore:
[10:59:32.349]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.349]    - tweaked: FALSE
[10:59:32.349]    - call: plan(strategy)
[10:59:32.352] plan(): nbrOfWorkers() = 2
[10:59:32.345] MulticoreFuture:
[10:59:32.345] Label: ‘future_mapply-1’
[10:59:32.345] Expression:
[10:59:32.345] {
[10:59:32.345]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.345]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.345]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.345]         on.exit(options(oopts), add = TRUE)
[10:59:32.345]     }
[10:59:32.345]     {
[10:59:32.345]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.345]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.345]         do.call(mapply, args = args)
[10:59:32.345]     }
[10:59:32.345] }
[10:59:32.345] Lazy evaluation: FALSE
[10:59:32.345] Asynchronous evaluation: TRUE
[10:59:32.345] Local evaluation: TRUE
[10:59:32.345] Environment: R_GlobalEnv
[10:59:32.345] Capture standard output: TRUE
[10:59:32.345] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.345] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.345] Packages: <none>
[10:59:32.345] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.345] Resolved: TRUE
[10:59:32.345] Value: <not collected>
[10:59:32.345] Conditions captured: <none>
[10:59:32.345] Early signaling: FALSE
[10:59:32.345] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.345] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.353] Chunk #1 of 5 ... DONE
[10:59:32.353] Chunk #2 of 5 ...
[10:59:32.354]  - Finding globals in '...' for chunk #2 ...
[10:59:32.354] getGlobalsAndPackages() ...
[10:59:32.354] Searching for globals...
[10:59:32.354] 
[10:59:32.355] Searching for globals ... DONE
[10:59:32.355] - globals: [0] <none>
[10:59:32.355] getGlobalsAndPackages() ... DONE
[10:59:32.355]    + additional globals found: [n=0] 
[10:59:32.355]    + additional namespaces needed: [n=0] 
[10:59:32.355]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:32.355]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:32.356]  - seeds: <none>
[10:59:32.356]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.356] getGlobalsAndPackages() ...
[10:59:32.356] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.356] Resolving globals: FALSE
[10:59:32.357] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:32.358] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.358] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.358] 
[10:59:32.358] getGlobalsAndPackages() ... DONE
[10:59:32.359] run() for ‘Future’ ...
[10:59:32.359] - state: ‘created’
[10:59:32.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.361] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.362] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.362]   - Field: ‘label’
[10:59:32.362]   - Field: ‘local’
[10:59:32.362]   - Field: ‘owner’
[10:59:32.362]   - Field: ‘envir’
[10:59:32.362]   - Field: ‘workers’
[10:59:32.362]   - Field: ‘packages’
[10:59:32.363]   - Field: ‘gc’
[10:59:32.363]   - Field: ‘job’
[10:59:32.363]   - Field: ‘conditions’
[10:59:32.363]   - Field: ‘expr’
[10:59:32.363]   - Field: ‘uuid’
[10:59:32.363]   - Field: ‘seed’
[10:59:32.363]   - Field: ‘version’
[10:59:32.363]   - Field: ‘result’
[10:59:32.364]   - Field: ‘asynchronous’
[10:59:32.364]   - Field: ‘calls’
[10:59:32.364]   - Field: ‘globals’
[10:59:32.364]   - Field: ‘stdout’
[10:59:32.364]   - Field: ‘earlySignal’
[10:59:32.364]   - Field: ‘lazy’
[10:59:32.364]   - Field: ‘state’
[10:59:32.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.365] - Launch lazy future ...
[10:59:32.365] Packages needed by the future expression (n = 0): <none>
[10:59:32.365] Packages needed by future strategies (n = 0): <none>
[10:59:32.366] {
[10:59:32.366]     {
[10:59:32.366]         {
[10:59:32.366]             ...future.startTime <- base::Sys.time()
[10:59:32.366]             {
[10:59:32.366]                 {
[10:59:32.366]                   {
[10:59:32.366]                     {
[10:59:32.366]                       base::local({
[10:59:32.366]                         has_future <- base::requireNamespace("future", 
[10:59:32.366]                           quietly = TRUE)
[10:59:32.366]                         if (has_future) {
[10:59:32.366]                           ns <- base::getNamespace("future")
[10:59:32.366]                           version <- ns[[".package"]][["version"]]
[10:59:32.366]                           if (is.null(version)) 
[10:59:32.366]                             version <- utils::packageVersion("future")
[10:59:32.366]                         }
[10:59:32.366]                         else {
[10:59:32.366]                           version <- NULL
[10:59:32.366]                         }
[10:59:32.366]                         if (!has_future || version < "1.8.0") {
[10:59:32.366]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.366]                             "", base::R.version$version.string), 
[10:59:32.366]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.366]                               "release", "version")], collapse = " "), 
[10:59:32.366]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.366]                             info)
[10:59:32.366]                           info <- base::paste(info, collapse = "; ")
[10:59:32.366]                           if (!has_future) {
[10:59:32.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.366]                               info)
[10:59:32.366]                           }
[10:59:32.366]                           else {
[10:59:32.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.366]                               info, version)
[10:59:32.366]                           }
[10:59:32.366]                           base::stop(msg)
[10:59:32.366]                         }
[10:59:32.366]                       })
[10:59:32.366]                     }
[10:59:32.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.366]                     base::options(mc.cores = 1L)
[10:59:32.366]                   }
[10:59:32.366]                   ...future.strategy.old <- future::plan("list")
[10:59:32.366]                   options(future.plan = NULL)
[10:59:32.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.366]                 }
[10:59:32.366]                 ...future.workdir <- getwd()
[10:59:32.366]             }
[10:59:32.366]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.366]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.366]         }
[10:59:32.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.366]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:32.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.366]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.366]             base::names(...future.oldOptions))
[10:59:32.366]     }
[10:59:32.366]     if (FALSE) {
[10:59:32.366]     }
[10:59:32.366]     else {
[10:59:32.366]         if (TRUE) {
[10:59:32.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.366]                 open = "w")
[10:59:32.366]         }
[10:59:32.366]         else {
[10:59:32.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.366]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.366]         }
[10:59:32.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.366]             base::sink(type = "output", split = FALSE)
[10:59:32.366]             base::close(...future.stdout)
[10:59:32.366]         }, add = TRUE)
[10:59:32.366]     }
[10:59:32.366]     ...future.frame <- base::sys.nframe()
[10:59:32.366]     ...future.conditions <- base::list()
[10:59:32.366]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.366]     if (FALSE) {
[10:59:32.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.366]     }
[10:59:32.366]     ...future.result <- base::tryCatch({
[10:59:32.366]         base::withCallingHandlers({
[10:59:32.366]             ...future.value <- base::withVisible(base::local({
[10:59:32.366]                 withCallingHandlers({
[10:59:32.366]                   {
[10:59:32.366]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.366]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.366]                       ...future.globals.maxSize)) {
[10:59:32.366]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.366]                       on.exit(options(oopts), add = TRUE)
[10:59:32.366]                     }
[10:59:32.366]                     {
[10:59:32.366]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.366]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.366]                         USE.NAMES = FALSE)
[10:59:32.366]                       do.call(mapply, args = args)
[10:59:32.366]                     }
[10:59:32.366]                   }
[10:59:32.366]                 }, immediateCondition = function(cond) {
[10:59:32.366]                   save_rds <- function (object, pathname, ...) 
[10:59:32.366]                   {
[10:59:32.366]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.366]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.366]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.366]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.366]                         fi_tmp[["mtime"]])
[10:59:32.366]                     }
[10:59:32.366]                     tryCatch({
[10:59:32.366]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.366]                     }, error = function(ex) {
[10:59:32.366]                       msg <- conditionMessage(ex)
[10:59:32.366]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.366]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.366]                         fi_tmp[["mtime"]], msg)
[10:59:32.366]                       ex$message <- msg
[10:59:32.366]                       stop(ex)
[10:59:32.366]                     })
[10:59:32.366]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.366]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.366]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.366]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.366]                       fi <- file.info(pathname)
[10:59:32.366]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.366]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.366]                         fi[["size"]], fi[["mtime"]])
[10:59:32.366]                       stop(msg)
[10:59:32.366]                     }
[10:59:32.366]                     invisible(pathname)
[10:59:32.366]                   }
[10:59:32.366]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.366]                     rootPath = tempdir()) 
[10:59:32.366]                   {
[10:59:32.366]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.366]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.366]                       tmpdir = path, fileext = ".rds")
[10:59:32.366]                     save_rds(obj, file)
[10:59:32.366]                   }
[10:59:32.366]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.366]                   {
[10:59:32.366]                     inherits <- base::inherits
[10:59:32.366]                     invokeRestart <- base::invokeRestart
[10:59:32.366]                     is.null <- base::is.null
[10:59:32.366]                     muffled <- FALSE
[10:59:32.366]                     if (inherits(cond, "message")) {
[10:59:32.366]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.366]                       if (muffled) 
[10:59:32.366]                         invokeRestart("muffleMessage")
[10:59:32.366]                     }
[10:59:32.366]                     else if (inherits(cond, "warning")) {
[10:59:32.366]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.366]                       if (muffled) 
[10:59:32.366]                         invokeRestart("muffleWarning")
[10:59:32.366]                     }
[10:59:32.366]                     else if (inherits(cond, "condition")) {
[10:59:32.366]                       if (!is.null(pattern)) {
[10:59:32.366]                         computeRestarts <- base::computeRestarts
[10:59:32.366]                         grepl <- base::grepl
[10:59:32.366]                         restarts <- computeRestarts(cond)
[10:59:32.366]                         for (restart in restarts) {
[10:59:32.366]                           name <- restart$name
[10:59:32.366]                           if (is.null(name)) 
[10:59:32.366]                             next
[10:59:32.366]                           if (!grepl(pattern, name)) 
[10:59:32.366]                             next
[10:59:32.366]                           invokeRestart(restart)
[10:59:32.366]                           muffled <- TRUE
[10:59:32.366]                           break
[10:59:32.366]                         }
[10:59:32.366]                       }
[10:59:32.366]                     }
[10:59:32.366]                     invisible(muffled)
[10:59:32.366]                   }
[10:59:32.366]                   muffleCondition(cond)
[10:59:32.366]                 })
[10:59:32.366]             }))
[10:59:32.366]             future::FutureResult(value = ...future.value$value, 
[10:59:32.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.366]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.366]                     ...future.globalenv.names))
[10:59:32.366]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.366]         }, condition = base::local({
[10:59:32.366]             c <- base::c
[10:59:32.366]             inherits <- base::inherits
[10:59:32.366]             invokeRestart <- base::invokeRestart
[10:59:32.366]             length <- base::length
[10:59:32.366]             list <- base::list
[10:59:32.366]             seq.int <- base::seq.int
[10:59:32.366]             signalCondition <- base::signalCondition
[10:59:32.366]             sys.calls <- base::sys.calls
[10:59:32.366]             `[[` <- base::`[[`
[10:59:32.366]             `+` <- base::`+`
[10:59:32.366]             `<<-` <- base::`<<-`
[10:59:32.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.366]                   3L)]
[10:59:32.366]             }
[10:59:32.366]             function(cond) {
[10:59:32.366]                 is_error <- inherits(cond, "error")
[10:59:32.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.366]                   NULL)
[10:59:32.366]                 if (is_error) {
[10:59:32.366]                   sessionInformation <- function() {
[10:59:32.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.366]                       search = base::search(), system = base::Sys.info())
[10:59:32.366]                   }
[10:59:32.366]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.366]                     cond$call), session = sessionInformation(), 
[10:59:32.366]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.366]                   signalCondition(cond)
[10:59:32.366]                 }
[10:59:32.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.366]                 "immediateCondition"))) {
[10:59:32.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.366]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.366]                   if (TRUE && !signal) {
[10:59:32.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.366]                     {
[10:59:32.366]                       inherits <- base::inherits
[10:59:32.366]                       invokeRestart <- base::invokeRestart
[10:59:32.366]                       is.null <- base::is.null
[10:59:32.366]                       muffled <- FALSE
[10:59:32.366]                       if (inherits(cond, "message")) {
[10:59:32.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.366]                         if (muffled) 
[10:59:32.366]                           invokeRestart("muffleMessage")
[10:59:32.366]                       }
[10:59:32.366]                       else if (inherits(cond, "warning")) {
[10:59:32.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.366]                         if (muffled) 
[10:59:32.366]                           invokeRestart("muffleWarning")
[10:59:32.366]                       }
[10:59:32.366]                       else if (inherits(cond, "condition")) {
[10:59:32.366]                         if (!is.null(pattern)) {
[10:59:32.366]                           computeRestarts <- base::computeRestarts
[10:59:32.366]                           grepl <- base::grepl
[10:59:32.366]                           restarts <- computeRestarts(cond)
[10:59:32.366]                           for (restart in restarts) {
[10:59:32.366]                             name <- restart$name
[10:59:32.366]                             if (is.null(name)) 
[10:59:32.366]                               next
[10:59:32.366]                             if (!grepl(pattern, name)) 
[10:59:32.366]                               next
[10:59:32.366]                             invokeRestart(restart)
[10:59:32.366]                             muffled <- TRUE
[10:59:32.366]                             break
[10:59:32.366]                           }
[10:59:32.366]                         }
[10:59:32.366]                       }
[10:59:32.366]                       invisible(muffled)
[10:59:32.366]                     }
[10:59:32.366]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.366]                   }
[10:59:32.366]                 }
[10:59:32.366]                 else {
[10:59:32.366]                   if (TRUE) {
[10:59:32.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.366]                     {
[10:59:32.366]                       inherits <- base::inherits
[10:59:32.366]                       invokeRestart <- base::invokeRestart
[10:59:32.366]                       is.null <- base::is.null
[10:59:32.366]                       muffled <- FALSE
[10:59:32.366]                       if (inherits(cond, "message")) {
[10:59:32.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.366]                         if (muffled) 
[10:59:32.366]                           invokeRestart("muffleMessage")
[10:59:32.366]                       }
[10:59:32.366]                       else if (inherits(cond, "warning")) {
[10:59:32.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.366]                         if (muffled) 
[10:59:32.366]                           invokeRestart("muffleWarning")
[10:59:32.366]                       }
[10:59:32.366]                       else if (inherits(cond, "condition")) {
[10:59:32.366]                         if (!is.null(pattern)) {
[10:59:32.366]                           computeRestarts <- base::computeRestarts
[10:59:32.366]                           grepl <- base::grepl
[10:59:32.366]                           restarts <- computeRestarts(cond)
[10:59:32.366]                           for (restart in restarts) {
[10:59:32.366]                             name <- restart$name
[10:59:32.366]                             if (is.null(name)) 
[10:59:32.366]                               next
[10:59:32.366]                             if (!grepl(pattern, name)) 
[10:59:32.366]                               next
[10:59:32.366]                             invokeRestart(restart)
[10:59:32.366]                             muffled <- TRUE
[10:59:32.366]                             break
[10:59:32.366]                           }
[10:59:32.366]                         }
[10:59:32.366]                       }
[10:59:32.366]                       invisible(muffled)
[10:59:32.366]                     }
[10:59:32.366]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.366]                   }
[10:59:32.366]                 }
[10:59:32.366]             }
[10:59:32.366]         }))
[10:59:32.366]     }, error = function(ex) {
[10:59:32.366]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.366]                 ...future.rng), started = ...future.startTime, 
[10:59:32.366]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.366]             version = "1.8"), class = "FutureResult")
[10:59:32.366]     }, finally = {
[10:59:32.366]         if (!identical(...future.workdir, getwd())) 
[10:59:32.366]             setwd(...future.workdir)
[10:59:32.366]         {
[10:59:32.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.366]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.366]             }
[10:59:32.366]             base::options(...future.oldOptions)
[10:59:32.366]             if (.Platform$OS.type == "windows") {
[10:59:32.366]                 old_names <- names(...future.oldEnvVars)
[10:59:32.366]                 envs <- base::Sys.getenv()
[10:59:32.366]                 names <- names(envs)
[10:59:32.366]                 common <- intersect(names, old_names)
[10:59:32.366]                 added <- setdiff(names, old_names)
[10:59:32.366]                 removed <- setdiff(old_names, names)
[10:59:32.366]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.366]                   envs[common]]
[10:59:32.366]                 NAMES <- toupper(changed)
[10:59:32.366]                 args <- list()
[10:59:32.366]                 for (kk in seq_along(NAMES)) {
[10:59:32.366]                   name <- changed[[kk]]
[10:59:32.366]                   NAME <- NAMES[[kk]]
[10:59:32.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.366]                     next
[10:59:32.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.366]                 }
[10:59:32.366]                 NAMES <- toupper(added)
[10:59:32.366]                 for (kk in seq_along(NAMES)) {
[10:59:32.366]                   name <- added[[kk]]
[10:59:32.366]                   NAME <- NAMES[[kk]]
[10:59:32.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.366]                     next
[10:59:32.366]                   args[[name]] <- ""
[10:59:32.366]                 }
[10:59:32.366]                 NAMES <- toupper(removed)
[10:59:32.366]                 for (kk in seq_along(NAMES)) {
[10:59:32.366]                   name <- removed[[kk]]
[10:59:32.366]                   NAME <- NAMES[[kk]]
[10:59:32.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.366]                     next
[10:59:32.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.366]                 }
[10:59:32.366]                 if (length(args) > 0) 
[10:59:32.366]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.366]             }
[10:59:32.366]             else {
[10:59:32.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.366]             }
[10:59:32.366]             {
[10:59:32.366]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.366]                   0L) {
[10:59:32.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.366]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.366]                   base::options(opts)
[10:59:32.366]                 }
[10:59:32.366]                 {
[10:59:32.366]                   {
[10:59:32.366]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.366]                     NULL
[10:59:32.366]                   }
[10:59:32.366]                   options(future.plan = NULL)
[10:59:32.366]                   if (is.na(NA_character_)) 
[10:59:32.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.366]                     .init = FALSE)
[10:59:32.366]                 }
[10:59:32.366]             }
[10:59:32.366]         }
[10:59:32.366]     })
[10:59:32.366]     if (TRUE) {
[10:59:32.366]         base::sink(type = "output", split = FALSE)
[10:59:32.366]         if (TRUE) {
[10:59:32.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.366]         }
[10:59:32.366]         else {
[10:59:32.366]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.366]         }
[10:59:32.366]         base::close(...future.stdout)
[10:59:32.366]         ...future.stdout <- NULL
[10:59:32.366]     }
[10:59:32.366]     ...future.result$conditions <- ...future.conditions
[10:59:32.366]     ...future.result$finished <- base::Sys.time()
[10:59:32.366]     ...future.result
[10:59:32.366] }
[10:59:32.369] assign_globals() ...
[10:59:32.370] List of 5
[10:59:32.370]  $ ...future.FUN            :function (C, k)  
[10:59:32.370]  $ MoreArgs                 : NULL
[10:59:32.370]  $ ...future.elements_ii    :List of 2
[10:59:32.370]   ..$ :List of 1
[10:59:32.370]   .. ..$ : chr "B"
[10:59:32.370]   ..$ :List of 1
[10:59:32.370]   .. ..$ : int 4
[10:59:32.370]  $ ...future.seeds_ii       : NULL
[10:59:32.370]  $ ...future.globals.maxSize: NULL
[10:59:32.370]  - attr(*, "where")=List of 5
[10:59:32.370]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.370]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.370]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.370]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.370]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.370]  - attr(*, "resolved")= logi FALSE
[10:59:32.370]  - attr(*, "total_size")= num 847
[10:59:32.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.370]  - attr(*, "already-done")= logi TRUE
[10:59:32.382] - reassign environment for ‘...future.FUN’
[10:59:32.382] - copied ‘...future.FUN’ to environment
[10:59:32.382] - copied ‘MoreArgs’ to environment
[10:59:32.383] - copied ‘...future.elements_ii’ to environment
[10:59:32.383] - copied ‘...future.seeds_ii’ to environment
[10:59:32.383] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.383] assign_globals() ... done
[10:59:32.383] requestCore(): workers = 2
[10:59:32.385] MulticoreFuture started
[10:59:32.386] - Launch lazy future ... done
[10:59:32.386] plan(): Setting new future strategy stack:
[10:59:32.386] run() for ‘MulticoreFuture’ ... done
[10:59:32.387] Created future:
[10:59:32.387] List of future strategies:
[10:59:32.387] 1. sequential:
[10:59:32.387]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.387]    - tweaked: FALSE
[10:59:32.387]    - call: NULL
[10:59:32.389] plan(): nbrOfWorkers() = 1
[10:59:32.392] plan(): Setting new future strategy stack:
[10:59:32.392] List of future strategies:
[10:59:32.392] 1. multicore:
[10:59:32.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.392]    - tweaked: FALSE
[10:59:32.392]    - call: plan(strategy)
[10:59:32.396] plan(): nbrOfWorkers() = 2
[10:59:32.388] MulticoreFuture:
[10:59:32.388] Label: ‘future_mapply-2’
[10:59:32.388] Expression:
[10:59:32.388] {
[10:59:32.388]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.388]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.388]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.388]         on.exit(options(oopts), add = TRUE)
[10:59:32.388]     }
[10:59:32.388]     {
[10:59:32.388]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.388]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.388]         do.call(mapply, args = args)
[10:59:32.388]     }
[10:59:32.388] }
[10:59:32.388] Lazy evaluation: FALSE
[10:59:32.388] Asynchronous evaluation: TRUE
[10:59:32.388] Local evaluation: TRUE
[10:59:32.388] Environment: R_GlobalEnv
[10:59:32.388] Capture standard output: TRUE
[10:59:32.388] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.388] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.388] Packages: <none>
[10:59:32.388] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.388] Resolved: TRUE
[10:59:32.388] Value: <not collected>
[10:59:32.388] Conditions captured: <none>
[10:59:32.388] Early signaling: FALSE
[10:59:32.388] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.388] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.397] Chunk #2 of 5 ... DONE
[10:59:32.398] Chunk #3 of 5 ...
[10:59:32.398]  - Finding globals in '...' for chunk #3 ...
[10:59:32.398] getGlobalsAndPackages() ...
[10:59:32.398] Searching for globals...
[10:59:32.399] 
[10:59:32.399] Searching for globals ... DONE
[10:59:32.399] - globals: [0] <none>
[10:59:32.400] getGlobalsAndPackages() ... DONE
[10:59:32.400]    + additional globals found: [n=0] 
[10:59:32.400]    + additional namespaces needed: [n=0] 
[10:59:32.400]  - Finding globals in '...' for chunk #3 ... DONE
[10:59:32.400]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:32.401]  - seeds: <none>
[10:59:32.401]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.401] getGlobalsAndPackages() ...
[10:59:32.401] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.402] Resolving globals: FALSE
[10:59:32.403] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:32.404] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.404] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.404] 
[10:59:32.404] getGlobalsAndPackages() ... DONE
[10:59:32.405] run() for ‘Future’ ...
[10:59:32.405] - state: ‘created’
[10:59:32.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.408]   - Field: ‘label’
[10:59:32.408]   - Field: ‘local’
[10:59:32.408]   - Field: ‘owner’
[10:59:32.408]   - Field: ‘envir’
[10:59:32.409]   - Field: ‘workers’
[10:59:32.409]   - Field: ‘packages’
[10:59:32.409]   - Field: ‘gc’
[10:59:32.409]   - Field: ‘job’
[10:59:32.409]   - Field: ‘conditions’
[10:59:32.409]   - Field: ‘expr’
[10:59:32.409]   - Field: ‘uuid’
[10:59:32.410]   - Field: ‘seed’
[10:59:32.410]   - Field: ‘version’
[10:59:32.410]   - Field: ‘result’
[10:59:32.410]   - Field: ‘asynchronous’
[10:59:32.410]   - Field: ‘calls’
[10:59:32.410]   - Field: ‘globals’
[10:59:32.410]   - Field: ‘stdout’
[10:59:32.410]   - Field: ‘earlySignal’
[10:59:32.411]   - Field: ‘lazy’
[10:59:32.411]   - Field: ‘state’
[10:59:32.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.411] - Launch lazy future ...
[10:59:32.411] Packages needed by the future expression (n = 0): <none>
[10:59:32.411] Packages needed by future strategies (n = 0): <none>
[10:59:32.412] {
[10:59:32.412]     {
[10:59:32.412]         {
[10:59:32.412]             ...future.startTime <- base::Sys.time()
[10:59:32.412]             {
[10:59:32.412]                 {
[10:59:32.412]                   {
[10:59:32.412]                     {
[10:59:32.412]                       base::local({
[10:59:32.412]                         has_future <- base::requireNamespace("future", 
[10:59:32.412]                           quietly = TRUE)
[10:59:32.412]                         if (has_future) {
[10:59:32.412]                           ns <- base::getNamespace("future")
[10:59:32.412]                           version <- ns[[".package"]][["version"]]
[10:59:32.412]                           if (is.null(version)) 
[10:59:32.412]                             version <- utils::packageVersion("future")
[10:59:32.412]                         }
[10:59:32.412]                         else {
[10:59:32.412]                           version <- NULL
[10:59:32.412]                         }
[10:59:32.412]                         if (!has_future || version < "1.8.0") {
[10:59:32.412]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.412]                             "", base::R.version$version.string), 
[10:59:32.412]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.412]                               "release", "version")], collapse = " "), 
[10:59:32.412]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.412]                             info)
[10:59:32.412]                           info <- base::paste(info, collapse = "; ")
[10:59:32.412]                           if (!has_future) {
[10:59:32.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.412]                               info)
[10:59:32.412]                           }
[10:59:32.412]                           else {
[10:59:32.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.412]                               info, version)
[10:59:32.412]                           }
[10:59:32.412]                           base::stop(msg)
[10:59:32.412]                         }
[10:59:32.412]                       })
[10:59:32.412]                     }
[10:59:32.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.412]                     base::options(mc.cores = 1L)
[10:59:32.412]                   }
[10:59:32.412]                   ...future.strategy.old <- future::plan("list")
[10:59:32.412]                   options(future.plan = NULL)
[10:59:32.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.412]                 }
[10:59:32.412]                 ...future.workdir <- getwd()
[10:59:32.412]             }
[10:59:32.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.412]         }
[10:59:32.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.412]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:32.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.412]             base::names(...future.oldOptions))
[10:59:32.412]     }
[10:59:32.412]     if (FALSE) {
[10:59:32.412]     }
[10:59:32.412]     else {
[10:59:32.412]         if (TRUE) {
[10:59:32.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.412]                 open = "w")
[10:59:32.412]         }
[10:59:32.412]         else {
[10:59:32.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.412]         }
[10:59:32.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.412]             base::sink(type = "output", split = FALSE)
[10:59:32.412]             base::close(...future.stdout)
[10:59:32.412]         }, add = TRUE)
[10:59:32.412]     }
[10:59:32.412]     ...future.frame <- base::sys.nframe()
[10:59:32.412]     ...future.conditions <- base::list()
[10:59:32.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.412]     if (FALSE) {
[10:59:32.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.412]     }
[10:59:32.412]     ...future.result <- base::tryCatch({
[10:59:32.412]         base::withCallingHandlers({
[10:59:32.412]             ...future.value <- base::withVisible(base::local({
[10:59:32.412]                 withCallingHandlers({
[10:59:32.412]                   {
[10:59:32.412]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.412]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.412]                       ...future.globals.maxSize)) {
[10:59:32.412]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.412]                       on.exit(options(oopts), add = TRUE)
[10:59:32.412]                     }
[10:59:32.412]                     {
[10:59:32.412]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.412]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.412]                         USE.NAMES = FALSE)
[10:59:32.412]                       do.call(mapply, args = args)
[10:59:32.412]                     }
[10:59:32.412]                   }
[10:59:32.412]                 }, immediateCondition = function(cond) {
[10:59:32.412]                   save_rds <- function (object, pathname, ...) 
[10:59:32.412]                   {
[10:59:32.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.412]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.412]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.412]                         fi_tmp[["mtime"]])
[10:59:32.412]                     }
[10:59:32.412]                     tryCatch({
[10:59:32.412]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.412]                     }, error = function(ex) {
[10:59:32.412]                       msg <- conditionMessage(ex)
[10:59:32.412]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.412]                         fi_tmp[["mtime"]], msg)
[10:59:32.412]                       ex$message <- msg
[10:59:32.412]                       stop(ex)
[10:59:32.412]                     })
[10:59:32.412]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.412]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.412]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.412]                       fi <- file.info(pathname)
[10:59:32.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.412]                         fi[["size"]], fi[["mtime"]])
[10:59:32.412]                       stop(msg)
[10:59:32.412]                     }
[10:59:32.412]                     invisible(pathname)
[10:59:32.412]                   }
[10:59:32.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.412]                     rootPath = tempdir()) 
[10:59:32.412]                   {
[10:59:32.412]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.412]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.412]                       tmpdir = path, fileext = ".rds")
[10:59:32.412]                     save_rds(obj, file)
[10:59:32.412]                   }
[10:59:32.412]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.412]                   {
[10:59:32.412]                     inherits <- base::inherits
[10:59:32.412]                     invokeRestart <- base::invokeRestart
[10:59:32.412]                     is.null <- base::is.null
[10:59:32.412]                     muffled <- FALSE
[10:59:32.412]                     if (inherits(cond, "message")) {
[10:59:32.412]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.412]                       if (muffled) 
[10:59:32.412]                         invokeRestart("muffleMessage")
[10:59:32.412]                     }
[10:59:32.412]                     else if (inherits(cond, "warning")) {
[10:59:32.412]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.412]                       if (muffled) 
[10:59:32.412]                         invokeRestart("muffleWarning")
[10:59:32.412]                     }
[10:59:32.412]                     else if (inherits(cond, "condition")) {
[10:59:32.412]                       if (!is.null(pattern)) {
[10:59:32.412]                         computeRestarts <- base::computeRestarts
[10:59:32.412]                         grepl <- base::grepl
[10:59:32.412]                         restarts <- computeRestarts(cond)
[10:59:32.412]                         for (restart in restarts) {
[10:59:32.412]                           name <- restart$name
[10:59:32.412]                           if (is.null(name)) 
[10:59:32.412]                             next
[10:59:32.412]                           if (!grepl(pattern, name)) 
[10:59:32.412]                             next
[10:59:32.412]                           invokeRestart(restart)
[10:59:32.412]                           muffled <- TRUE
[10:59:32.412]                           break
[10:59:32.412]                         }
[10:59:32.412]                       }
[10:59:32.412]                     }
[10:59:32.412]                     invisible(muffled)
[10:59:32.412]                   }
[10:59:32.412]                   muffleCondition(cond)
[10:59:32.412]                 })
[10:59:32.412]             }))
[10:59:32.412]             future::FutureResult(value = ...future.value$value, 
[10:59:32.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.412]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.412]                     ...future.globalenv.names))
[10:59:32.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.412]         }, condition = base::local({
[10:59:32.412]             c <- base::c
[10:59:32.412]             inherits <- base::inherits
[10:59:32.412]             invokeRestart <- base::invokeRestart
[10:59:32.412]             length <- base::length
[10:59:32.412]             list <- base::list
[10:59:32.412]             seq.int <- base::seq.int
[10:59:32.412]             signalCondition <- base::signalCondition
[10:59:32.412]             sys.calls <- base::sys.calls
[10:59:32.412]             `[[` <- base::`[[`
[10:59:32.412]             `+` <- base::`+`
[10:59:32.412]             `<<-` <- base::`<<-`
[10:59:32.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.412]                   3L)]
[10:59:32.412]             }
[10:59:32.412]             function(cond) {
[10:59:32.412]                 is_error <- inherits(cond, "error")
[10:59:32.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.412]                   NULL)
[10:59:32.412]                 if (is_error) {
[10:59:32.412]                   sessionInformation <- function() {
[10:59:32.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.412]                       search = base::search(), system = base::Sys.info())
[10:59:32.412]                   }
[10:59:32.412]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.412]                     cond$call), session = sessionInformation(), 
[10:59:32.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.412]                   signalCondition(cond)
[10:59:32.412]                 }
[10:59:32.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.412]                 "immediateCondition"))) {
[10:59:32.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.412]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.412]                   if (TRUE && !signal) {
[10:59:32.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.412]                     {
[10:59:32.412]                       inherits <- base::inherits
[10:59:32.412]                       invokeRestart <- base::invokeRestart
[10:59:32.412]                       is.null <- base::is.null
[10:59:32.412]                       muffled <- FALSE
[10:59:32.412]                       if (inherits(cond, "message")) {
[10:59:32.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.412]                         if (muffled) 
[10:59:32.412]                           invokeRestart("muffleMessage")
[10:59:32.412]                       }
[10:59:32.412]                       else if (inherits(cond, "warning")) {
[10:59:32.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.412]                         if (muffled) 
[10:59:32.412]                           invokeRestart("muffleWarning")
[10:59:32.412]                       }
[10:59:32.412]                       else if (inherits(cond, "condition")) {
[10:59:32.412]                         if (!is.null(pattern)) {
[10:59:32.412]                           computeRestarts <- base::computeRestarts
[10:59:32.412]                           grepl <- base::grepl
[10:59:32.412]                           restarts <- computeRestarts(cond)
[10:59:32.412]                           for (restart in restarts) {
[10:59:32.412]                             name <- restart$name
[10:59:32.412]                             if (is.null(name)) 
[10:59:32.412]                               next
[10:59:32.412]                             if (!grepl(pattern, name)) 
[10:59:32.412]                               next
[10:59:32.412]                             invokeRestart(restart)
[10:59:32.412]                             muffled <- TRUE
[10:59:32.412]                             break
[10:59:32.412]                           }
[10:59:32.412]                         }
[10:59:32.412]                       }
[10:59:32.412]                       invisible(muffled)
[10:59:32.412]                     }
[10:59:32.412]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.412]                   }
[10:59:32.412]                 }
[10:59:32.412]                 else {
[10:59:32.412]                   if (TRUE) {
[10:59:32.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.412]                     {
[10:59:32.412]                       inherits <- base::inherits
[10:59:32.412]                       invokeRestart <- base::invokeRestart
[10:59:32.412]                       is.null <- base::is.null
[10:59:32.412]                       muffled <- FALSE
[10:59:32.412]                       if (inherits(cond, "message")) {
[10:59:32.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.412]                         if (muffled) 
[10:59:32.412]                           invokeRestart("muffleMessage")
[10:59:32.412]                       }
[10:59:32.412]                       else if (inherits(cond, "warning")) {
[10:59:32.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.412]                         if (muffled) 
[10:59:32.412]                           invokeRestart("muffleWarning")
[10:59:32.412]                       }
[10:59:32.412]                       else if (inherits(cond, "condition")) {
[10:59:32.412]                         if (!is.null(pattern)) {
[10:59:32.412]                           computeRestarts <- base::computeRestarts
[10:59:32.412]                           grepl <- base::grepl
[10:59:32.412]                           restarts <- computeRestarts(cond)
[10:59:32.412]                           for (restart in restarts) {
[10:59:32.412]                             name <- restart$name
[10:59:32.412]                             if (is.null(name)) 
[10:59:32.412]                               next
[10:59:32.412]                             if (!grepl(pattern, name)) 
[10:59:32.412]                               next
[10:59:32.412]                             invokeRestart(restart)
[10:59:32.412]                             muffled <- TRUE
[10:59:32.412]                             break
[10:59:32.412]                           }
[10:59:32.412]                         }
[10:59:32.412]                       }
[10:59:32.412]                       invisible(muffled)
[10:59:32.412]                     }
[10:59:32.412]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.412]                   }
[10:59:32.412]                 }
[10:59:32.412]             }
[10:59:32.412]         }))
[10:59:32.412]     }, error = function(ex) {
[10:59:32.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.412]                 ...future.rng), started = ...future.startTime, 
[10:59:32.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.412]             version = "1.8"), class = "FutureResult")
[10:59:32.412]     }, finally = {
[10:59:32.412]         if (!identical(...future.workdir, getwd())) 
[10:59:32.412]             setwd(...future.workdir)
[10:59:32.412]         {
[10:59:32.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.412]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.412]             }
[10:59:32.412]             base::options(...future.oldOptions)
[10:59:32.412]             if (.Platform$OS.type == "windows") {
[10:59:32.412]                 old_names <- names(...future.oldEnvVars)
[10:59:32.412]                 envs <- base::Sys.getenv()
[10:59:32.412]                 names <- names(envs)
[10:59:32.412]                 common <- intersect(names, old_names)
[10:59:32.412]                 added <- setdiff(names, old_names)
[10:59:32.412]                 removed <- setdiff(old_names, names)
[10:59:32.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.412]                   envs[common]]
[10:59:32.412]                 NAMES <- toupper(changed)
[10:59:32.412]                 args <- list()
[10:59:32.412]                 for (kk in seq_along(NAMES)) {
[10:59:32.412]                   name <- changed[[kk]]
[10:59:32.412]                   NAME <- NAMES[[kk]]
[10:59:32.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.412]                     next
[10:59:32.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.412]                 }
[10:59:32.412]                 NAMES <- toupper(added)
[10:59:32.412]                 for (kk in seq_along(NAMES)) {
[10:59:32.412]                   name <- added[[kk]]
[10:59:32.412]                   NAME <- NAMES[[kk]]
[10:59:32.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.412]                     next
[10:59:32.412]                   args[[name]] <- ""
[10:59:32.412]                 }
[10:59:32.412]                 NAMES <- toupper(removed)
[10:59:32.412]                 for (kk in seq_along(NAMES)) {
[10:59:32.412]                   name <- removed[[kk]]
[10:59:32.412]                   NAME <- NAMES[[kk]]
[10:59:32.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.412]                     next
[10:59:32.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.412]                 }
[10:59:32.412]                 if (length(args) > 0) 
[10:59:32.412]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.412]             }
[10:59:32.412]             else {
[10:59:32.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.412]             }
[10:59:32.412]             {
[10:59:32.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.412]                   0L) {
[10:59:32.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.412]                   base::options(opts)
[10:59:32.412]                 }
[10:59:32.412]                 {
[10:59:32.412]                   {
[10:59:32.412]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.412]                     NULL
[10:59:32.412]                   }
[10:59:32.412]                   options(future.plan = NULL)
[10:59:32.412]                   if (is.na(NA_character_)) 
[10:59:32.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.412]                     .init = FALSE)
[10:59:32.412]                 }
[10:59:32.412]             }
[10:59:32.412]         }
[10:59:32.412]     })
[10:59:32.412]     if (TRUE) {
[10:59:32.412]         base::sink(type = "output", split = FALSE)
[10:59:32.412]         if (TRUE) {
[10:59:32.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.412]         }
[10:59:32.412]         else {
[10:59:32.412]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.412]         }
[10:59:32.412]         base::close(...future.stdout)
[10:59:32.412]         ...future.stdout <- NULL
[10:59:32.412]     }
[10:59:32.412]     ...future.result$conditions <- ...future.conditions
[10:59:32.412]     ...future.result$finished <- base::Sys.time()
[10:59:32.412]     ...future.result
[10:59:32.412] }
[10:59:32.416] assign_globals() ...
[10:59:32.416] List of 5
[10:59:32.416]  $ ...future.FUN            :function (C, k)  
[10:59:32.416]  $ MoreArgs                 : NULL
[10:59:32.416]  $ ...future.elements_ii    :List of 2
[10:59:32.416]   ..$ :List of 1
[10:59:32.416]   .. ..$ : chr "C"
[10:59:32.416]   ..$ :List of 1
[10:59:32.416]   .. ..$ : int 3
[10:59:32.416]  $ ...future.seeds_ii       : NULL
[10:59:32.416]  $ ...future.globals.maxSize: NULL
[10:59:32.416]  - attr(*, "where")=List of 5
[10:59:32.416]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.416]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.416]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.416]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.416]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.416]  - attr(*, "resolved")= logi FALSE
[10:59:32.416]  - attr(*, "total_size")= num 847
[10:59:32.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.416]  - attr(*, "already-done")= logi TRUE
[10:59:32.422] - reassign environment for ‘...future.FUN’
[10:59:32.422] - copied ‘...future.FUN’ to environment
[10:59:32.422] - copied ‘MoreArgs’ to environment
[10:59:32.422] - copied ‘...future.elements_ii’ to environment
[10:59:32.422] - copied ‘...future.seeds_ii’ to environment
[10:59:32.422] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.423] assign_globals() ... done
[10:59:32.423] requestCore(): workers = 2
[10:59:32.423] Poll #1 (0): usedCores() = 2, workers = 2
[10:59:32.434] result() for MulticoreFuture ...
[10:59:32.434] result() for MulticoreFuture ...
[10:59:32.435] result() for MulticoreFuture ... done
[10:59:32.435] result() for MulticoreFuture ... done
[10:59:32.435] result() for MulticoreFuture ...
[10:59:32.435] result() for MulticoreFuture ... done
[10:59:32.437] MulticoreFuture started
[10:59:32.438] - Launch lazy future ... done
[10:59:32.438] run() for ‘MulticoreFuture’ ... done
[10:59:32.439] Created future:
[10:59:32.439] plan(): Setting new future strategy stack:
[10:59:32.439] List of future strategies:
[10:59:32.439] 1. sequential:
[10:59:32.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.439]    - tweaked: FALSE
[10:59:32.439]    - call: NULL
[10:59:32.440] plan(): nbrOfWorkers() = 1
[10:59:32.443] plan(): Setting new future strategy stack:
[10:59:32.443] List of future strategies:
[10:59:32.443] 1. multicore:
[10:59:32.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.443]    - tweaked: FALSE
[10:59:32.443]    - call: plan(strategy)
[10:59:32.439] MulticoreFuture:
[10:59:32.439] Label: ‘future_mapply-3’
[10:59:32.439] Expression:
[10:59:32.439] {
[10:59:32.439]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.439]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.439]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.439]         on.exit(options(oopts), add = TRUE)
[10:59:32.439]     }
[10:59:32.439]     {
[10:59:32.439]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.439]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.439]         do.call(mapply, args = args)
[10:59:32.439]     }
[10:59:32.439] }
[10:59:32.439] Lazy evaluation: FALSE
[10:59:32.439] Asynchronous evaluation: TRUE
[10:59:32.439] Local evaluation: TRUE
[10:59:32.439] Environment: R_GlobalEnv
[10:59:32.439] Capture standard output: TRUE
[10:59:32.439] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.439] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.439] Packages: <none>
[10:59:32.439] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.439] Resolved: FALSE
[10:59:32.439] Value: <not collected>
[10:59:32.439] Conditions captured: <none>
[10:59:32.439] Early signaling: FALSE
[10:59:32.439] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.439] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.452] Chunk #3 of 5 ... DONE
[10:59:32.452] Chunk #4 of 5 ...
[10:59:32.452] plan(): nbrOfWorkers() = 2
[10:59:32.452]  - Finding globals in '...' for chunk #4 ...
[10:59:32.453] getGlobalsAndPackages() ...
[10:59:32.455] Searching for globals...
[10:59:32.456] 
[10:59:32.457] Searching for globals ... DONE
[10:59:32.457] - globals: [0] <none>
[10:59:32.457] getGlobalsAndPackages() ... DONE
[10:59:32.457]    + additional globals found: [n=0] 
[10:59:32.457]    + additional namespaces needed: [n=0] 
[10:59:32.458]  - Finding globals in '...' for chunk #4 ... DONE
[10:59:32.458]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:32.458]  - seeds: <none>
[10:59:32.458]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.458] getGlobalsAndPackages() ...
[10:59:32.459] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.459] Resolving globals: FALSE
[10:59:32.460] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:32.461] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.461] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.462] 
[10:59:32.462] getGlobalsAndPackages() ... DONE
[10:59:32.462] run() for ‘Future’ ...
[10:59:32.463] - state: ‘created’
[10:59:32.463] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.466] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.466]   - Field: ‘label’
[10:59:32.467]   - Field: ‘local’
[10:59:32.467]   - Field: ‘owner’
[10:59:32.467]   - Field: ‘envir’
[10:59:32.467]   - Field: ‘workers’
[10:59:32.467]   - Field: ‘packages’
[10:59:32.468]   - Field: ‘gc’
[10:59:32.468]   - Field: ‘job’
[10:59:32.468]   - Field: ‘conditions’
[10:59:32.468]   - Field: ‘expr’
[10:59:32.468]   - Field: ‘uuid’
[10:59:32.468]   - Field: ‘seed’
[10:59:32.469]   - Field: ‘version’
[10:59:32.469]   - Field: ‘result’
[10:59:32.469]   - Field: ‘asynchronous’
[10:59:32.469]   - Field: ‘calls’
[10:59:32.469]   - Field: ‘globals’
[10:59:32.469]   - Field: ‘stdout’
[10:59:32.469]   - Field: ‘earlySignal’
[10:59:32.470]   - Field: ‘lazy’
[10:59:32.470]   - Field: ‘state’
[10:59:32.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.470] - Launch lazy future ...
[10:59:32.470] Packages needed by the future expression (n = 0): <none>
[10:59:32.471] Packages needed by future strategies (n = 0): <none>
[10:59:32.471] {
[10:59:32.471]     {
[10:59:32.471]         {
[10:59:32.471]             ...future.startTime <- base::Sys.time()
[10:59:32.471]             {
[10:59:32.471]                 {
[10:59:32.471]                   {
[10:59:32.471]                     {
[10:59:32.471]                       base::local({
[10:59:32.471]                         has_future <- base::requireNamespace("future", 
[10:59:32.471]                           quietly = TRUE)
[10:59:32.471]                         if (has_future) {
[10:59:32.471]                           ns <- base::getNamespace("future")
[10:59:32.471]                           version <- ns[[".package"]][["version"]]
[10:59:32.471]                           if (is.null(version)) 
[10:59:32.471]                             version <- utils::packageVersion("future")
[10:59:32.471]                         }
[10:59:32.471]                         else {
[10:59:32.471]                           version <- NULL
[10:59:32.471]                         }
[10:59:32.471]                         if (!has_future || version < "1.8.0") {
[10:59:32.471]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.471]                             "", base::R.version$version.string), 
[10:59:32.471]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.471]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.471]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.471]                               "release", "version")], collapse = " "), 
[10:59:32.471]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.471]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.471]                             info)
[10:59:32.471]                           info <- base::paste(info, collapse = "; ")
[10:59:32.471]                           if (!has_future) {
[10:59:32.471]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.471]                               info)
[10:59:32.471]                           }
[10:59:32.471]                           else {
[10:59:32.471]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.471]                               info, version)
[10:59:32.471]                           }
[10:59:32.471]                           base::stop(msg)
[10:59:32.471]                         }
[10:59:32.471]                       })
[10:59:32.471]                     }
[10:59:32.471]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.471]                     base::options(mc.cores = 1L)
[10:59:32.471]                   }
[10:59:32.471]                   ...future.strategy.old <- future::plan("list")
[10:59:32.471]                   options(future.plan = NULL)
[10:59:32.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.471]                 }
[10:59:32.471]                 ...future.workdir <- getwd()
[10:59:32.471]             }
[10:59:32.471]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.471]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.471]         }
[10:59:32.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.471]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:32.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.471]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.471]             base::names(...future.oldOptions))
[10:59:32.471]     }
[10:59:32.471]     if (FALSE) {
[10:59:32.471]     }
[10:59:32.471]     else {
[10:59:32.471]         if (TRUE) {
[10:59:32.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.471]                 open = "w")
[10:59:32.471]         }
[10:59:32.471]         else {
[10:59:32.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.471]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.471]         }
[10:59:32.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.471]             base::sink(type = "output", split = FALSE)
[10:59:32.471]             base::close(...future.stdout)
[10:59:32.471]         }, add = TRUE)
[10:59:32.471]     }
[10:59:32.471]     ...future.frame <- base::sys.nframe()
[10:59:32.471]     ...future.conditions <- base::list()
[10:59:32.471]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.471]     if (FALSE) {
[10:59:32.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.471]     }
[10:59:32.471]     ...future.result <- base::tryCatch({
[10:59:32.471]         base::withCallingHandlers({
[10:59:32.471]             ...future.value <- base::withVisible(base::local({
[10:59:32.471]                 withCallingHandlers({
[10:59:32.471]                   {
[10:59:32.471]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.471]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.471]                       ...future.globals.maxSize)) {
[10:59:32.471]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.471]                       on.exit(options(oopts), add = TRUE)
[10:59:32.471]                     }
[10:59:32.471]                     {
[10:59:32.471]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.471]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.471]                         USE.NAMES = FALSE)
[10:59:32.471]                       do.call(mapply, args = args)
[10:59:32.471]                     }
[10:59:32.471]                   }
[10:59:32.471]                 }, immediateCondition = function(cond) {
[10:59:32.471]                   save_rds <- function (object, pathname, ...) 
[10:59:32.471]                   {
[10:59:32.471]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.471]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.471]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.471]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.471]                         fi_tmp[["mtime"]])
[10:59:32.471]                     }
[10:59:32.471]                     tryCatch({
[10:59:32.471]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.471]                     }, error = function(ex) {
[10:59:32.471]                       msg <- conditionMessage(ex)
[10:59:32.471]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.471]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.471]                         fi_tmp[["mtime"]], msg)
[10:59:32.471]                       ex$message <- msg
[10:59:32.471]                       stop(ex)
[10:59:32.471]                     })
[10:59:32.471]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.471]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.471]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.471]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.471]                       fi <- file.info(pathname)
[10:59:32.471]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.471]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.471]                         fi[["size"]], fi[["mtime"]])
[10:59:32.471]                       stop(msg)
[10:59:32.471]                     }
[10:59:32.471]                     invisible(pathname)
[10:59:32.471]                   }
[10:59:32.471]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.471]                     rootPath = tempdir()) 
[10:59:32.471]                   {
[10:59:32.471]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.471]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.471]                       tmpdir = path, fileext = ".rds")
[10:59:32.471]                     save_rds(obj, file)
[10:59:32.471]                   }
[10:59:32.471]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.471]                   {
[10:59:32.471]                     inherits <- base::inherits
[10:59:32.471]                     invokeRestart <- base::invokeRestart
[10:59:32.471]                     is.null <- base::is.null
[10:59:32.471]                     muffled <- FALSE
[10:59:32.471]                     if (inherits(cond, "message")) {
[10:59:32.471]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.471]                       if (muffled) 
[10:59:32.471]                         invokeRestart("muffleMessage")
[10:59:32.471]                     }
[10:59:32.471]                     else if (inherits(cond, "warning")) {
[10:59:32.471]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.471]                       if (muffled) 
[10:59:32.471]                         invokeRestart("muffleWarning")
[10:59:32.471]                     }
[10:59:32.471]                     else if (inherits(cond, "condition")) {
[10:59:32.471]                       if (!is.null(pattern)) {
[10:59:32.471]                         computeRestarts <- base::computeRestarts
[10:59:32.471]                         grepl <- base::grepl
[10:59:32.471]                         restarts <- computeRestarts(cond)
[10:59:32.471]                         for (restart in restarts) {
[10:59:32.471]                           name <- restart$name
[10:59:32.471]                           if (is.null(name)) 
[10:59:32.471]                             next
[10:59:32.471]                           if (!grepl(pattern, name)) 
[10:59:32.471]                             next
[10:59:32.471]                           invokeRestart(restart)
[10:59:32.471]                           muffled <- TRUE
[10:59:32.471]                           break
[10:59:32.471]                         }
[10:59:32.471]                       }
[10:59:32.471]                     }
[10:59:32.471]                     invisible(muffled)
[10:59:32.471]                   }
[10:59:32.471]                   muffleCondition(cond)
[10:59:32.471]                 })
[10:59:32.471]             }))
[10:59:32.471]             future::FutureResult(value = ...future.value$value, 
[10:59:32.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.471]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.471]                     ...future.globalenv.names))
[10:59:32.471]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.471]         }, condition = base::local({
[10:59:32.471]             c <- base::c
[10:59:32.471]             inherits <- base::inherits
[10:59:32.471]             invokeRestart <- base::invokeRestart
[10:59:32.471]             length <- base::length
[10:59:32.471]             list <- base::list
[10:59:32.471]             seq.int <- base::seq.int
[10:59:32.471]             signalCondition <- base::signalCondition
[10:59:32.471]             sys.calls <- base::sys.calls
[10:59:32.471]             `[[` <- base::`[[`
[10:59:32.471]             `+` <- base::`+`
[10:59:32.471]             `<<-` <- base::`<<-`
[10:59:32.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.471]                   3L)]
[10:59:32.471]             }
[10:59:32.471]             function(cond) {
[10:59:32.471]                 is_error <- inherits(cond, "error")
[10:59:32.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.471]                   NULL)
[10:59:32.471]                 if (is_error) {
[10:59:32.471]                   sessionInformation <- function() {
[10:59:32.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.471]                       search = base::search(), system = base::Sys.info())
[10:59:32.471]                   }
[10:59:32.471]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.471]                     cond$call), session = sessionInformation(), 
[10:59:32.471]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.471]                   signalCondition(cond)
[10:59:32.471]                 }
[10:59:32.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.471]                 "immediateCondition"))) {
[10:59:32.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.471]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.471]                   if (TRUE && !signal) {
[10:59:32.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.471]                     {
[10:59:32.471]                       inherits <- base::inherits
[10:59:32.471]                       invokeRestart <- base::invokeRestart
[10:59:32.471]                       is.null <- base::is.null
[10:59:32.471]                       muffled <- FALSE
[10:59:32.471]                       if (inherits(cond, "message")) {
[10:59:32.471]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.471]                         if (muffled) 
[10:59:32.471]                           invokeRestart("muffleMessage")
[10:59:32.471]                       }
[10:59:32.471]                       else if (inherits(cond, "warning")) {
[10:59:32.471]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.471]                         if (muffled) 
[10:59:32.471]                           invokeRestart("muffleWarning")
[10:59:32.471]                       }
[10:59:32.471]                       else if (inherits(cond, "condition")) {
[10:59:32.471]                         if (!is.null(pattern)) {
[10:59:32.471]                           computeRestarts <- base::computeRestarts
[10:59:32.471]                           grepl <- base::grepl
[10:59:32.471]                           restarts <- computeRestarts(cond)
[10:59:32.471]                           for (restart in restarts) {
[10:59:32.471]                             name <- restart$name
[10:59:32.471]                             if (is.null(name)) 
[10:59:32.471]                               next
[10:59:32.471]                             if (!grepl(pattern, name)) 
[10:59:32.471]                               next
[10:59:32.471]                             invokeRestart(restart)
[10:59:32.471]                             muffled <- TRUE
[10:59:32.471]                             break
[10:59:32.471]                           }
[10:59:32.471]                         }
[10:59:32.471]                       }
[10:59:32.471]                       invisible(muffled)
[10:59:32.471]                     }
[10:59:32.471]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.471]                   }
[10:59:32.471]                 }
[10:59:32.471]                 else {
[10:59:32.471]                   if (TRUE) {
[10:59:32.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.471]                     {
[10:59:32.471]                       inherits <- base::inherits
[10:59:32.471]                       invokeRestart <- base::invokeRestart
[10:59:32.471]                       is.null <- base::is.null
[10:59:32.471]                       muffled <- FALSE
[10:59:32.471]                       if (inherits(cond, "message")) {
[10:59:32.471]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.471]                         if (muffled) 
[10:59:32.471]                           invokeRestart("muffleMessage")
[10:59:32.471]                       }
[10:59:32.471]                       else if (inherits(cond, "warning")) {
[10:59:32.471]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.471]                         if (muffled) 
[10:59:32.471]                           invokeRestart("muffleWarning")
[10:59:32.471]                       }
[10:59:32.471]                       else if (inherits(cond, "condition")) {
[10:59:32.471]                         if (!is.null(pattern)) {
[10:59:32.471]                           computeRestarts <- base::computeRestarts
[10:59:32.471]                           grepl <- base::grepl
[10:59:32.471]                           restarts <- computeRestarts(cond)
[10:59:32.471]                           for (restart in restarts) {
[10:59:32.471]                             name <- restart$name
[10:59:32.471]                             if (is.null(name)) 
[10:59:32.471]                               next
[10:59:32.471]                             if (!grepl(pattern, name)) 
[10:59:32.471]                               next
[10:59:32.471]                             invokeRestart(restart)
[10:59:32.471]                             muffled <- TRUE
[10:59:32.471]                             break
[10:59:32.471]                           }
[10:59:32.471]                         }
[10:59:32.471]                       }
[10:59:32.471]                       invisible(muffled)
[10:59:32.471]                     }
[10:59:32.471]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.471]                   }
[10:59:32.471]                 }
[10:59:32.471]             }
[10:59:32.471]         }))
[10:59:32.471]     }, error = function(ex) {
[10:59:32.471]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.471]                 ...future.rng), started = ...future.startTime, 
[10:59:32.471]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.471]             version = "1.8"), class = "FutureResult")
[10:59:32.471]     }, finally = {
[10:59:32.471]         if (!identical(...future.workdir, getwd())) 
[10:59:32.471]             setwd(...future.workdir)
[10:59:32.471]         {
[10:59:32.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.471]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.471]             }
[10:59:32.471]             base::options(...future.oldOptions)
[10:59:32.471]             if (.Platform$OS.type == "windows") {
[10:59:32.471]                 old_names <- names(...future.oldEnvVars)
[10:59:32.471]                 envs <- base::Sys.getenv()
[10:59:32.471]                 names <- names(envs)
[10:59:32.471]                 common <- intersect(names, old_names)
[10:59:32.471]                 added <- setdiff(names, old_names)
[10:59:32.471]                 removed <- setdiff(old_names, names)
[10:59:32.471]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.471]                   envs[common]]
[10:59:32.471]                 NAMES <- toupper(changed)
[10:59:32.471]                 args <- list()
[10:59:32.471]                 for (kk in seq_along(NAMES)) {
[10:59:32.471]                   name <- changed[[kk]]
[10:59:32.471]                   NAME <- NAMES[[kk]]
[10:59:32.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.471]                     next
[10:59:32.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.471]                 }
[10:59:32.471]                 NAMES <- toupper(added)
[10:59:32.471]                 for (kk in seq_along(NAMES)) {
[10:59:32.471]                   name <- added[[kk]]
[10:59:32.471]                   NAME <- NAMES[[kk]]
[10:59:32.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.471]                     next
[10:59:32.471]                   args[[name]] <- ""
[10:59:32.471]                 }
[10:59:32.471]                 NAMES <- toupper(removed)
[10:59:32.471]                 for (kk in seq_along(NAMES)) {
[10:59:32.471]                   name <- removed[[kk]]
[10:59:32.471]                   NAME <- NAMES[[kk]]
[10:59:32.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.471]                     next
[10:59:32.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.471]                 }
[10:59:32.471]                 if (length(args) > 0) 
[10:59:32.471]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.471]             }
[10:59:32.471]             else {
[10:59:32.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.471]             }
[10:59:32.471]             {
[10:59:32.471]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.471]                   0L) {
[10:59:32.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.471]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.471]                   base::options(opts)
[10:59:32.471]                 }
[10:59:32.471]                 {
[10:59:32.471]                   {
[10:59:32.471]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.471]                     NULL
[10:59:32.471]                   }
[10:59:32.471]                   options(future.plan = NULL)
[10:59:32.471]                   if (is.na(NA_character_)) 
[10:59:32.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.471]                     .init = FALSE)
[10:59:32.471]                 }
[10:59:32.471]             }
[10:59:32.471]         }
[10:59:32.471]     })
[10:59:32.471]     if (TRUE) {
[10:59:32.471]         base::sink(type = "output", split = FALSE)
[10:59:32.471]         if (TRUE) {
[10:59:32.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.471]         }
[10:59:32.471]         else {
[10:59:32.471]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.471]         }
[10:59:32.471]         base::close(...future.stdout)
[10:59:32.471]         ...future.stdout <- NULL
[10:59:32.471]     }
[10:59:32.471]     ...future.result$conditions <- ...future.conditions
[10:59:32.471]     ...future.result$finished <- base::Sys.time()
[10:59:32.471]     ...future.result
[10:59:32.471] }
[10:59:32.474] assign_globals() ...
[10:59:32.474] List of 5
[10:59:32.474]  $ ...future.FUN            :function (C, k)  
[10:59:32.474]  $ MoreArgs                 : NULL
[10:59:32.474]  $ ...future.elements_ii    :List of 2
[10:59:32.474]   ..$ :List of 1
[10:59:32.474]   .. ..$ : chr "D"
[10:59:32.474]   ..$ :List of 1
[10:59:32.474]   .. ..$ : int 2
[10:59:32.474]  $ ...future.seeds_ii       : NULL
[10:59:32.474]  $ ...future.globals.maxSize: NULL
[10:59:32.474]  - attr(*, "where")=List of 5
[10:59:32.474]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.474]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.474]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.474]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.474]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.474]  - attr(*, "resolved")= logi FALSE
[10:59:32.474]  - attr(*, "total_size")= num 847
[10:59:32.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.474]  - attr(*, "already-done")= logi TRUE
[10:59:32.480] - reassign environment for ‘...future.FUN’
[10:59:32.480] - copied ‘...future.FUN’ to environment
[10:59:32.480] - copied ‘MoreArgs’ to environment
[10:59:32.480] - copied ‘...future.elements_ii’ to environment
[10:59:32.480] - copied ‘...future.seeds_ii’ to environment
[10:59:32.481] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.481] assign_globals() ... done
[10:59:32.481] requestCore(): workers = 2
[10:59:32.481] Poll #1 (0): usedCores() = 2, workers = 2
[10:59:32.505] result() for MulticoreFuture ...
[10:59:32.506] result() for MulticoreFuture ...
[10:59:32.506] result() for MulticoreFuture ... done
[10:59:32.506] result() for MulticoreFuture ... done
[10:59:32.506] result() for MulticoreFuture ...
[10:59:32.507] result() for MulticoreFuture ... done
[10:59:32.510] MulticoreFuture started
[10:59:32.511] - Launch lazy future ... done
[10:59:32.511] run() for ‘MulticoreFuture’ ... done
[10:59:32.511] plan(): Setting new future strategy stack:
[10:59:32.512] Created future:
[10:59:32.512] List of future strategies:
[10:59:32.512] 1. sequential:
[10:59:32.512]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.512]    - tweaked: FALSE
[10:59:32.512]    - call: NULL
[10:59:32.513] plan(): nbrOfWorkers() = 1
[10:59:32.516] plan(): Setting new future strategy stack:
[10:59:32.516] List of future strategies:
[10:59:32.516] 1. multicore:
[10:59:32.516]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.516]    - tweaked: FALSE
[10:59:32.516]    - call: plan(strategy)
[10:59:32.520] plan(): nbrOfWorkers() = 2
[10:59:32.512] MulticoreFuture:
[10:59:32.512] Label: ‘future_mapply-4’
[10:59:32.512] Expression:
[10:59:32.512] {
[10:59:32.512]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.512]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.512]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.512]         on.exit(options(oopts), add = TRUE)
[10:59:32.512]     }
[10:59:32.512]     {
[10:59:32.512]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.512]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.512]         do.call(mapply, args = args)
[10:59:32.512]     }
[10:59:32.512] }
[10:59:32.512] Lazy evaluation: FALSE
[10:59:32.512] Asynchronous evaluation: TRUE
[10:59:32.512] Local evaluation: TRUE
[10:59:32.512] Environment: R_GlobalEnv
[10:59:32.512] Capture standard output: TRUE
[10:59:32.512] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.512] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.512] Packages: <none>
[10:59:32.512] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.512] Resolved: TRUE
[10:59:32.512] Value: <not collected>
[10:59:32.512] Conditions captured: <none>
[10:59:32.512] Early signaling: FALSE
[10:59:32.512] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.512] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.521] Chunk #4 of 5 ... DONE
[10:59:32.521] Chunk #5 of 5 ...
[10:59:32.522]  - Finding globals in '...' for chunk #5 ...
[10:59:32.522] getGlobalsAndPackages() ...
[10:59:32.522] Searching for globals...
[10:59:32.523] 
[10:59:32.523] Searching for globals ... DONE
[10:59:32.523] - globals: [0] <none>
[10:59:32.523] getGlobalsAndPackages() ... DONE
[10:59:32.523]    + additional globals found: [n=0] 
[10:59:32.523]    + additional namespaces needed: [n=0] 
[10:59:32.523]  - Finding globals in '...' for chunk #5 ... DONE
[10:59:32.523]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:32.524]  - seeds: <none>
[10:59:32.524]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.524] getGlobalsAndPackages() ...
[10:59:32.524] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.524] Resolving globals: FALSE
[10:59:32.525] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:32.526] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.526] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.526] 
[10:59:32.526] getGlobalsAndPackages() ... DONE
[10:59:32.527] run() for ‘Future’ ...
[10:59:32.527] - state: ‘created’
[10:59:32.527] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.530]   - Field: ‘label’
[10:59:32.530]   - Field: ‘local’
[10:59:32.530]   - Field: ‘owner’
[10:59:32.530]   - Field: ‘envir’
[10:59:32.530]   - Field: ‘workers’
[10:59:32.531]   - Field: ‘packages’
[10:59:32.531]   - Field: ‘gc’
[10:59:32.531]   - Field: ‘job’
[10:59:32.531]   - Field: ‘conditions’
[10:59:32.531]   - Field: ‘expr’
[10:59:32.531]   - Field: ‘uuid’
[10:59:32.531]   - Field: ‘seed’
[10:59:32.532]   - Field: ‘version’
[10:59:32.532]   - Field: ‘result’
[10:59:32.532]   - Field: ‘asynchronous’
[10:59:32.532]   - Field: ‘calls’
[10:59:32.532]   - Field: ‘globals’
[10:59:32.532]   - Field: ‘stdout’
[10:59:32.532]   - Field: ‘earlySignal’
[10:59:32.533]   - Field: ‘lazy’
[10:59:32.533]   - Field: ‘state’
[10:59:32.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.533] - Launch lazy future ...
[10:59:32.533] Packages needed by the future expression (n = 0): <none>
[10:59:32.534] Packages needed by future strategies (n = 0): <none>
[10:59:32.534] {
[10:59:32.534]     {
[10:59:32.534]         {
[10:59:32.534]             ...future.startTime <- base::Sys.time()
[10:59:32.534]             {
[10:59:32.534]                 {
[10:59:32.534]                   {
[10:59:32.534]                     {
[10:59:32.534]                       base::local({
[10:59:32.534]                         has_future <- base::requireNamespace("future", 
[10:59:32.534]                           quietly = TRUE)
[10:59:32.534]                         if (has_future) {
[10:59:32.534]                           ns <- base::getNamespace("future")
[10:59:32.534]                           version <- ns[[".package"]][["version"]]
[10:59:32.534]                           if (is.null(version)) 
[10:59:32.534]                             version <- utils::packageVersion("future")
[10:59:32.534]                         }
[10:59:32.534]                         else {
[10:59:32.534]                           version <- NULL
[10:59:32.534]                         }
[10:59:32.534]                         if (!has_future || version < "1.8.0") {
[10:59:32.534]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.534]                             "", base::R.version$version.string), 
[10:59:32.534]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.534]                               "release", "version")], collapse = " "), 
[10:59:32.534]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.534]                             info)
[10:59:32.534]                           info <- base::paste(info, collapse = "; ")
[10:59:32.534]                           if (!has_future) {
[10:59:32.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.534]                               info)
[10:59:32.534]                           }
[10:59:32.534]                           else {
[10:59:32.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.534]                               info, version)
[10:59:32.534]                           }
[10:59:32.534]                           base::stop(msg)
[10:59:32.534]                         }
[10:59:32.534]                       })
[10:59:32.534]                     }
[10:59:32.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.534]                     base::options(mc.cores = 1L)
[10:59:32.534]                   }
[10:59:32.534]                   ...future.strategy.old <- future::plan("list")
[10:59:32.534]                   options(future.plan = NULL)
[10:59:32.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.534]                 }
[10:59:32.534]                 ...future.workdir <- getwd()
[10:59:32.534]             }
[10:59:32.534]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.534]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.534]         }
[10:59:32.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.534]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:32.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.534]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.534]             base::names(...future.oldOptions))
[10:59:32.534]     }
[10:59:32.534]     if (FALSE) {
[10:59:32.534]     }
[10:59:32.534]     else {
[10:59:32.534]         if (TRUE) {
[10:59:32.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.534]                 open = "w")
[10:59:32.534]         }
[10:59:32.534]         else {
[10:59:32.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.534]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.534]         }
[10:59:32.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.534]             base::sink(type = "output", split = FALSE)
[10:59:32.534]             base::close(...future.stdout)
[10:59:32.534]         }, add = TRUE)
[10:59:32.534]     }
[10:59:32.534]     ...future.frame <- base::sys.nframe()
[10:59:32.534]     ...future.conditions <- base::list()
[10:59:32.534]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.534]     if (FALSE) {
[10:59:32.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.534]     }
[10:59:32.534]     ...future.result <- base::tryCatch({
[10:59:32.534]         base::withCallingHandlers({
[10:59:32.534]             ...future.value <- base::withVisible(base::local({
[10:59:32.534]                 withCallingHandlers({
[10:59:32.534]                   {
[10:59:32.534]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.534]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.534]                       ...future.globals.maxSize)) {
[10:59:32.534]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.534]                       on.exit(options(oopts), add = TRUE)
[10:59:32.534]                     }
[10:59:32.534]                     {
[10:59:32.534]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.534]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.534]                         USE.NAMES = FALSE)
[10:59:32.534]                       do.call(mapply, args = args)
[10:59:32.534]                     }
[10:59:32.534]                   }
[10:59:32.534]                 }, immediateCondition = function(cond) {
[10:59:32.534]                   save_rds <- function (object, pathname, ...) 
[10:59:32.534]                   {
[10:59:32.534]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.534]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.534]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.534]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.534]                         fi_tmp[["mtime"]])
[10:59:32.534]                     }
[10:59:32.534]                     tryCatch({
[10:59:32.534]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.534]                     }, error = function(ex) {
[10:59:32.534]                       msg <- conditionMessage(ex)
[10:59:32.534]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.534]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.534]                         fi_tmp[["mtime"]], msg)
[10:59:32.534]                       ex$message <- msg
[10:59:32.534]                       stop(ex)
[10:59:32.534]                     })
[10:59:32.534]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.534]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.534]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.534]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.534]                       fi <- file.info(pathname)
[10:59:32.534]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.534]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.534]                         fi[["size"]], fi[["mtime"]])
[10:59:32.534]                       stop(msg)
[10:59:32.534]                     }
[10:59:32.534]                     invisible(pathname)
[10:59:32.534]                   }
[10:59:32.534]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.534]                     rootPath = tempdir()) 
[10:59:32.534]                   {
[10:59:32.534]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.534]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.534]                       tmpdir = path, fileext = ".rds")
[10:59:32.534]                     save_rds(obj, file)
[10:59:32.534]                   }
[10:59:32.534]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.534]                   {
[10:59:32.534]                     inherits <- base::inherits
[10:59:32.534]                     invokeRestart <- base::invokeRestart
[10:59:32.534]                     is.null <- base::is.null
[10:59:32.534]                     muffled <- FALSE
[10:59:32.534]                     if (inherits(cond, "message")) {
[10:59:32.534]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.534]                       if (muffled) 
[10:59:32.534]                         invokeRestart("muffleMessage")
[10:59:32.534]                     }
[10:59:32.534]                     else if (inherits(cond, "warning")) {
[10:59:32.534]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.534]                       if (muffled) 
[10:59:32.534]                         invokeRestart("muffleWarning")
[10:59:32.534]                     }
[10:59:32.534]                     else if (inherits(cond, "condition")) {
[10:59:32.534]                       if (!is.null(pattern)) {
[10:59:32.534]                         computeRestarts <- base::computeRestarts
[10:59:32.534]                         grepl <- base::grepl
[10:59:32.534]                         restarts <- computeRestarts(cond)
[10:59:32.534]                         for (restart in restarts) {
[10:59:32.534]                           name <- restart$name
[10:59:32.534]                           if (is.null(name)) 
[10:59:32.534]                             next
[10:59:32.534]                           if (!grepl(pattern, name)) 
[10:59:32.534]                             next
[10:59:32.534]                           invokeRestart(restart)
[10:59:32.534]                           muffled <- TRUE
[10:59:32.534]                           break
[10:59:32.534]                         }
[10:59:32.534]                       }
[10:59:32.534]                     }
[10:59:32.534]                     invisible(muffled)
[10:59:32.534]                   }
[10:59:32.534]                   muffleCondition(cond)
[10:59:32.534]                 })
[10:59:32.534]             }))
[10:59:32.534]             future::FutureResult(value = ...future.value$value, 
[10:59:32.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.534]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.534]                     ...future.globalenv.names))
[10:59:32.534]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.534]         }, condition = base::local({
[10:59:32.534]             c <- base::c
[10:59:32.534]             inherits <- base::inherits
[10:59:32.534]             invokeRestart <- base::invokeRestart
[10:59:32.534]             length <- base::length
[10:59:32.534]             list <- base::list
[10:59:32.534]             seq.int <- base::seq.int
[10:59:32.534]             signalCondition <- base::signalCondition
[10:59:32.534]             sys.calls <- base::sys.calls
[10:59:32.534]             `[[` <- base::`[[`
[10:59:32.534]             `+` <- base::`+`
[10:59:32.534]             `<<-` <- base::`<<-`
[10:59:32.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.534]                   3L)]
[10:59:32.534]             }
[10:59:32.534]             function(cond) {
[10:59:32.534]                 is_error <- inherits(cond, "error")
[10:59:32.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.534]                   NULL)
[10:59:32.534]                 if (is_error) {
[10:59:32.534]                   sessionInformation <- function() {
[10:59:32.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.534]                       search = base::search(), system = base::Sys.info())
[10:59:32.534]                   }
[10:59:32.534]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.534]                     cond$call), session = sessionInformation(), 
[10:59:32.534]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.534]                   signalCondition(cond)
[10:59:32.534]                 }
[10:59:32.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.534]                 "immediateCondition"))) {
[10:59:32.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.534]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.534]                   if (TRUE && !signal) {
[10:59:32.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.534]                     {
[10:59:32.534]                       inherits <- base::inherits
[10:59:32.534]                       invokeRestart <- base::invokeRestart
[10:59:32.534]                       is.null <- base::is.null
[10:59:32.534]                       muffled <- FALSE
[10:59:32.534]                       if (inherits(cond, "message")) {
[10:59:32.534]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.534]                         if (muffled) 
[10:59:32.534]                           invokeRestart("muffleMessage")
[10:59:32.534]                       }
[10:59:32.534]                       else if (inherits(cond, "warning")) {
[10:59:32.534]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.534]                         if (muffled) 
[10:59:32.534]                           invokeRestart("muffleWarning")
[10:59:32.534]                       }
[10:59:32.534]                       else if (inherits(cond, "condition")) {
[10:59:32.534]                         if (!is.null(pattern)) {
[10:59:32.534]                           computeRestarts <- base::computeRestarts
[10:59:32.534]                           grepl <- base::grepl
[10:59:32.534]                           restarts <- computeRestarts(cond)
[10:59:32.534]                           for (restart in restarts) {
[10:59:32.534]                             name <- restart$name
[10:59:32.534]                             if (is.null(name)) 
[10:59:32.534]                               next
[10:59:32.534]                             if (!grepl(pattern, name)) 
[10:59:32.534]                               next
[10:59:32.534]                             invokeRestart(restart)
[10:59:32.534]                             muffled <- TRUE
[10:59:32.534]                             break
[10:59:32.534]                           }
[10:59:32.534]                         }
[10:59:32.534]                       }
[10:59:32.534]                       invisible(muffled)
[10:59:32.534]                     }
[10:59:32.534]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.534]                   }
[10:59:32.534]                 }
[10:59:32.534]                 else {
[10:59:32.534]                   if (TRUE) {
[10:59:32.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.534]                     {
[10:59:32.534]                       inherits <- base::inherits
[10:59:32.534]                       invokeRestart <- base::invokeRestart
[10:59:32.534]                       is.null <- base::is.null
[10:59:32.534]                       muffled <- FALSE
[10:59:32.534]                       if (inherits(cond, "message")) {
[10:59:32.534]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.534]                         if (muffled) 
[10:59:32.534]                           invokeRestart("muffleMessage")
[10:59:32.534]                       }
[10:59:32.534]                       else if (inherits(cond, "warning")) {
[10:59:32.534]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.534]                         if (muffled) 
[10:59:32.534]                           invokeRestart("muffleWarning")
[10:59:32.534]                       }
[10:59:32.534]                       else if (inherits(cond, "condition")) {
[10:59:32.534]                         if (!is.null(pattern)) {
[10:59:32.534]                           computeRestarts <- base::computeRestarts
[10:59:32.534]                           grepl <- base::grepl
[10:59:32.534]                           restarts <- computeRestarts(cond)
[10:59:32.534]                           for (restart in restarts) {
[10:59:32.534]                             name <- restart$name
[10:59:32.534]                             if (is.null(name)) 
[10:59:32.534]                               next
[10:59:32.534]                             if (!grepl(pattern, name)) 
[10:59:32.534]                               next
[10:59:32.534]                             invokeRestart(restart)
[10:59:32.534]                             muffled <- TRUE
[10:59:32.534]                             break
[10:59:32.534]                           }
[10:59:32.534]                         }
[10:59:32.534]                       }
[10:59:32.534]                       invisible(muffled)
[10:59:32.534]                     }
[10:59:32.534]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.534]                   }
[10:59:32.534]                 }
[10:59:32.534]             }
[10:59:32.534]         }))
[10:59:32.534]     }, error = function(ex) {
[10:59:32.534]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.534]                 ...future.rng), started = ...future.startTime, 
[10:59:32.534]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.534]             version = "1.8"), class = "FutureResult")
[10:59:32.534]     }, finally = {
[10:59:32.534]         if (!identical(...future.workdir, getwd())) 
[10:59:32.534]             setwd(...future.workdir)
[10:59:32.534]         {
[10:59:32.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.534]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.534]             }
[10:59:32.534]             base::options(...future.oldOptions)
[10:59:32.534]             if (.Platform$OS.type == "windows") {
[10:59:32.534]                 old_names <- names(...future.oldEnvVars)
[10:59:32.534]                 envs <- base::Sys.getenv()
[10:59:32.534]                 names <- names(envs)
[10:59:32.534]                 common <- intersect(names, old_names)
[10:59:32.534]                 added <- setdiff(names, old_names)
[10:59:32.534]                 removed <- setdiff(old_names, names)
[10:59:32.534]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.534]                   envs[common]]
[10:59:32.534]                 NAMES <- toupper(changed)
[10:59:32.534]                 args <- list()
[10:59:32.534]                 for (kk in seq_along(NAMES)) {
[10:59:32.534]                   name <- changed[[kk]]
[10:59:32.534]                   NAME <- NAMES[[kk]]
[10:59:32.534]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.534]                     next
[10:59:32.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.534]                 }
[10:59:32.534]                 NAMES <- toupper(added)
[10:59:32.534]                 for (kk in seq_along(NAMES)) {
[10:59:32.534]                   name <- added[[kk]]
[10:59:32.534]                   NAME <- NAMES[[kk]]
[10:59:32.534]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.534]                     next
[10:59:32.534]                   args[[name]] <- ""
[10:59:32.534]                 }
[10:59:32.534]                 NAMES <- toupper(removed)
[10:59:32.534]                 for (kk in seq_along(NAMES)) {
[10:59:32.534]                   name <- removed[[kk]]
[10:59:32.534]                   NAME <- NAMES[[kk]]
[10:59:32.534]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.534]                     next
[10:59:32.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.534]                 }
[10:59:32.534]                 if (length(args) > 0) 
[10:59:32.534]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.534]             }
[10:59:32.534]             else {
[10:59:32.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.534]             }
[10:59:32.534]             {
[10:59:32.534]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.534]                   0L) {
[10:59:32.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.534]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.534]                   base::options(opts)
[10:59:32.534]                 }
[10:59:32.534]                 {
[10:59:32.534]                   {
[10:59:32.534]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.534]                     NULL
[10:59:32.534]                   }
[10:59:32.534]                   options(future.plan = NULL)
[10:59:32.534]                   if (is.na(NA_character_)) 
[10:59:32.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.534]                     .init = FALSE)
[10:59:32.534]                 }
[10:59:32.534]             }
[10:59:32.534]         }
[10:59:32.534]     })
[10:59:32.534]     if (TRUE) {
[10:59:32.534]         base::sink(type = "output", split = FALSE)
[10:59:32.534]         if (TRUE) {
[10:59:32.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.534]         }
[10:59:32.534]         else {
[10:59:32.534]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.534]         }
[10:59:32.534]         base::close(...future.stdout)
[10:59:32.534]         ...future.stdout <- NULL
[10:59:32.534]     }
[10:59:32.534]     ...future.result$conditions <- ...future.conditions
[10:59:32.534]     ...future.result$finished <- base::Sys.time()
[10:59:32.534]     ...future.result
[10:59:32.534] }
[10:59:32.538] assign_globals() ...
[10:59:32.538] List of 5
[10:59:32.538]  $ ...future.FUN            :function (C, k)  
[10:59:32.538]  $ MoreArgs                 : NULL
[10:59:32.538]  $ ...future.elements_ii    :List of 2
[10:59:32.538]   ..$ :List of 1
[10:59:32.538]   .. ..$ : chr "E"
[10:59:32.538]   ..$ :List of 1
[10:59:32.538]   .. ..$ : int 1
[10:59:32.538]  $ ...future.seeds_ii       : NULL
[10:59:32.538]  $ ...future.globals.maxSize: NULL
[10:59:32.538]  - attr(*, "where")=List of 5
[10:59:32.538]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.538]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.538]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.538]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.538]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.538]  - attr(*, "resolved")= logi FALSE
[10:59:32.538]  - attr(*, "total_size")= num 847
[10:59:32.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.538]  - attr(*, "already-done")= logi TRUE
[10:59:32.548] - reassign environment for ‘...future.FUN’
[10:59:32.548] - copied ‘...future.FUN’ to environment
[10:59:32.549] - copied ‘MoreArgs’ to environment
[10:59:32.549] - copied ‘...future.elements_ii’ to environment
[10:59:32.549] - copied ‘...future.seeds_ii’ to environment
[10:59:32.549] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.549] assign_globals() ... done
[10:59:32.549] requestCore(): workers = 2
[10:59:32.550] Poll #1 (0): usedCores() = 2, workers = 2
[10:59:32.560] result() for MulticoreFuture ...
[10:59:32.561] result() for MulticoreFuture ...
[10:59:32.561] result() for MulticoreFuture ... done
[10:59:32.562] result() for MulticoreFuture ... done
[10:59:32.562] result() for MulticoreFuture ...
[10:59:32.562] result() for MulticoreFuture ... done
[10:59:32.565] MulticoreFuture started
[10:59:32.566] - Launch lazy future ... done
[10:59:32.566] plan(): Setting new future strategy stack:
[10:59:32.566] run() for ‘MulticoreFuture’ ... done
[10:59:32.567] Created future:
[10:59:32.567] List of future strategies:
[10:59:32.567] 1. sequential:
[10:59:32.567]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.567]    - tweaked: FALSE
[10:59:32.567]    - call: NULL
[10:59:32.569] plan(): nbrOfWorkers() = 1
[10:59:32.572] plan(): Setting new future strategy stack:
[10:59:32.572] List of future strategies:
[10:59:32.572] 1. multicore:
[10:59:32.572]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.572]    - tweaked: FALSE
[10:59:32.572]    - call: plan(strategy)
[10:59:32.576] plan(): nbrOfWorkers() = 2
[10:59:32.567] MulticoreFuture:
[10:59:32.567] Label: ‘future_mapply-5’
[10:59:32.567] Expression:
[10:59:32.567] {
[10:59:32.567]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.567]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.567]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.567]         on.exit(options(oopts), add = TRUE)
[10:59:32.567]     }
[10:59:32.567]     {
[10:59:32.567]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.567]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.567]         do.call(mapply, args = args)
[10:59:32.567]     }
[10:59:32.567] }
[10:59:32.567] Lazy evaluation: FALSE
[10:59:32.567] Asynchronous evaluation: TRUE
[10:59:32.567] Local evaluation: TRUE
[10:59:32.567] Environment: R_GlobalEnv
[10:59:32.567] Capture standard output: TRUE
[10:59:32.567] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.567] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.567] Packages: <none>
[10:59:32.567] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.567] Resolved: TRUE
[10:59:32.567] Value: <not collected>
[10:59:32.567] Conditions captured: <none>
[10:59:32.567] Early signaling: FALSE
[10:59:32.567] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.567] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.577] Chunk #5 of 5 ... DONE
[10:59:32.577] Launching 5 futures (chunks) ... DONE
[10:59:32.578] Resolving 5 futures (chunks) ...
[10:59:32.578] resolve() on list ...
[10:59:32.578]  recursive: 0
[10:59:32.578]  length: 5
[10:59:32.579] 
[10:59:32.579] Future #1
[10:59:32.579] result() for MulticoreFuture ...
[10:59:32.579] result() for MulticoreFuture ... done
[10:59:32.579] result() for MulticoreFuture ...
[10:59:32.580] result() for MulticoreFuture ... done
[10:59:32.580] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.580] - nx: 5
[10:59:32.580] - relay: TRUE
[10:59:32.580] - stdout: TRUE
[10:59:32.580] - signal: TRUE
[10:59:32.580] - resignal: FALSE
[10:59:32.581] - force: TRUE
[10:59:32.581] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:59:32.581] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:59:32.581]  - until=1
[10:59:32.581]  - relaying element #1
[10:59:32.581] result() for MulticoreFuture ...
[10:59:32.582] result() for MulticoreFuture ... done
[10:59:32.582] result() for MulticoreFuture ...
[10:59:32.582] result() for MulticoreFuture ... done
[10:59:32.582] result() for MulticoreFuture ...
[10:59:32.582] result() for MulticoreFuture ... done
[10:59:32.582] result() for MulticoreFuture ...
[10:59:32.583] result() for MulticoreFuture ... done
[10:59:32.583] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:32.583] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:32.583] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.583]  length: 4 (resolved future 1)
[10:59:32.583] Future #2
[10:59:32.584] result() for MulticoreFuture ...
[10:59:32.584] result() for MulticoreFuture ... done
[10:59:32.584] result() for MulticoreFuture ...
[10:59:32.584] result() for MulticoreFuture ... done
[10:59:32.584] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.584] - nx: 5
[10:59:32.584] - relay: TRUE
[10:59:32.585] - stdout: TRUE
[10:59:32.585] - signal: TRUE
[10:59:32.585] - resignal: FALSE
[10:59:32.585] - force: TRUE
[10:59:32.585] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:32.585] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:32.585]  - until=2
[10:59:32.585]  - relaying element #2
[10:59:32.585] result() for MulticoreFuture ...
[10:59:32.586] result() for MulticoreFuture ... done
[10:59:32.586] result() for MulticoreFuture ...
[10:59:32.586] result() for MulticoreFuture ... done
[10:59:32.586] result() for MulticoreFuture ...
[10:59:32.586] result() for MulticoreFuture ... done
[10:59:32.586] result() for MulticoreFuture ...
[10:59:32.586] result() for MulticoreFuture ... done
[10:59:32.586] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:32.587] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:32.587] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.587]  length: 3 (resolved future 2)
[10:59:32.587] Future #3
[10:59:32.587] result() for MulticoreFuture ...
[10:59:32.587] result() for MulticoreFuture ... done
[10:59:32.587] result() for MulticoreFuture ...
[10:59:32.588] result() for MulticoreFuture ... done
[10:59:32.588] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:59:32.588] - nx: 5
[10:59:32.588] - relay: TRUE
[10:59:32.588] - stdout: TRUE
[10:59:32.588] - signal: TRUE
[10:59:32.588] - resignal: FALSE
[10:59:32.588] - force: TRUE
[10:59:32.588] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:32.589] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:32.589]  - until=3
[10:59:32.589]  - relaying element #3
[10:59:32.589] result() for MulticoreFuture ...
[10:59:32.589] result() for MulticoreFuture ... done
[10:59:32.589] result() for MulticoreFuture ...
[10:59:32.589] result() for MulticoreFuture ... done
[10:59:32.589] result() for MulticoreFuture ...
[10:59:32.590] result() for MulticoreFuture ... done
[10:59:32.590] result() for MulticoreFuture ...
[10:59:32.590] result() for MulticoreFuture ... done
[10:59:32.590] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:32.590] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:32.590] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:59:32.590]  length: 2 (resolved future 3)
[10:59:32.591] Future #4
[10:59:32.591] result() for MulticoreFuture ...
[10:59:32.592] result() for MulticoreFuture ...
[10:59:32.592] result() for MulticoreFuture ... done
[10:59:32.592] result() for MulticoreFuture ... done
[10:59:32.592] result() for MulticoreFuture ...
[10:59:32.592] result() for MulticoreFuture ... done
[10:59:32.592] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:59:32.593] - nx: 5
[10:59:32.593] - relay: TRUE
[10:59:32.593] - stdout: TRUE
[10:59:32.593] - signal: TRUE
[10:59:32.593] - resignal: FALSE
[10:59:32.593] - force: TRUE
[10:59:32.593] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:32.594] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:32.594]  - until=4
[10:59:32.594]  - relaying element #4
[10:59:32.594] result() for MulticoreFuture ...
[10:59:32.594] result() for MulticoreFuture ... done
[10:59:32.594] result() for MulticoreFuture ...
[10:59:32.595] result() for MulticoreFuture ... done
[10:59:32.595] result() for MulticoreFuture ...
[10:59:32.595] result() for MulticoreFuture ... done
[10:59:32.595] result() for MulticoreFuture ...
[10:59:32.595] result() for MulticoreFuture ... done
[10:59:32.595] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:32.596] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:32.596] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:59:32.596]  length: 1 (resolved future 4)
[10:59:32.596] Future #5
[10:59:32.597] result() for MulticoreFuture ...
[10:59:32.597] result() for MulticoreFuture ...
[10:59:32.597] result() for MulticoreFuture ... done
[10:59:32.598] result() for MulticoreFuture ... done
[10:59:32.598] result() for MulticoreFuture ...
[10:59:32.598] result() for MulticoreFuture ... done
[10:59:32.598] signalConditionsASAP(MulticoreFuture, pos=5) ...
[10:59:32.598] - nx: 5
[10:59:32.598] - relay: TRUE
[10:59:32.598] - stdout: TRUE
[10:59:32.598] - signal: TRUE
[10:59:32.599] - resignal: FALSE
[10:59:32.599] - force: TRUE
[10:59:32.599] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:32.599] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:32.599]  - until=5
[10:59:32.599]  - relaying element #5
[10:59:32.599] result() for MulticoreFuture ...
[10:59:32.599] result() for MulticoreFuture ... done
[10:59:32.599] result() for MulticoreFuture ...
[10:59:32.599] result() for MulticoreFuture ... done
[10:59:32.600] result() for MulticoreFuture ...
[10:59:32.600] result() for MulticoreFuture ... done
[10:59:32.600] result() for MulticoreFuture ...
[10:59:32.602] result() for MulticoreFuture ... done
[10:59:32.602] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:32.602] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:32.602] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[10:59:32.603]  length: 0 (resolved future 5)
[10:59:32.603] Relaying remaining futures
[10:59:32.603] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.603] - nx: 5
[10:59:32.603] - relay: TRUE
[10:59:32.603] - stdout: TRUE
[10:59:32.603] - signal: TRUE
[10:59:32.603] - resignal: FALSE
[10:59:32.603] - force: TRUE
[10:59:32.604] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:32.604] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:59:32.604] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:32.604] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:32.604] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.604] resolve() on list ... DONE
[10:59:32.604] result() for MulticoreFuture ...
[10:59:32.604] result() for MulticoreFuture ... done
[10:59:32.604] result() for MulticoreFuture ...
[10:59:32.605] result() for MulticoreFuture ... done
[10:59:32.605] result() for MulticoreFuture ...
[10:59:32.605] result() for MulticoreFuture ... done
[10:59:32.605] result() for MulticoreFuture ...
[10:59:32.605] result() for MulticoreFuture ... done
[10:59:32.605] result() for MulticoreFuture ...
[10:59:32.605] result() for MulticoreFuture ... done
[10:59:32.605] result() for MulticoreFuture ...
[10:59:32.606] result() for MulticoreFuture ... done
[10:59:32.606] result() for MulticoreFuture ...
[10:59:32.606] result() for MulticoreFuture ... done
[10:59:32.606] result() for MulticoreFuture ...
[10:59:32.606] result() for MulticoreFuture ... done
[10:59:32.606] result() for MulticoreFuture ...
[10:59:32.606] result() for MulticoreFuture ... done
[10:59:32.606] result() for MulticoreFuture ...
[10:59:32.606] result() for MulticoreFuture ... done
[10:59:32.607]  - Number of value chunks collected: 5
[10:59:32.607] Resolving 5 futures (chunks) ... DONE
[10:59:32.607] Reducing values from 5 chunks ...
[10:59:32.607]  - Number of values collected after concatenation: 5
[10:59:32.607]  - Number of values expected: 5
[10:59:32.607] Reducing values from 5 chunks ... DONE
[10:59:32.607] future_mapply() ... DONE
[10:59:32.607] future_mapply() ...
[10:59:32.610] Number of chunks: 2
[10:59:32.610] getGlobalsAndPackagesXApply() ...
[10:59:32.610]  - future.globals: TRUE
[10:59:32.610] getGlobalsAndPackages() ...
[10:59:32.610] Searching for globals...
[10:59:32.611] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:32.611] Searching for globals ... DONE
[10:59:32.612] Resolving globals: FALSE
[10:59:32.612] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:32.612] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:32.612] - globals: [1] ‘FUN’
[10:59:32.612] 
[10:59:32.613] getGlobalsAndPackages() ... DONE
[10:59:32.613]  - globals found/used: [n=1] ‘FUN’
[10:59:32.613]  - needed namespaces: [n=0] 
[10:59:32.613] Finding globals ... DONE
[10:59:32.613] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.613] List of 2
[10:59:32.613]  $ ...future.FUN:function (C, k)  
[10:59:32.613]  $ MoreArgs     : list()
[10:59:32.613]  - attr(*, "where")=List of 2
[10:59:32.613]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.613]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.613]  - attr(*, "resolved")= logi FALSE
[10:59:32.613]  - attr(*, "total_size")= num NA
[10:59:32.616] Packages to be attached in all futures: [n=0] 
[10:59:32.616] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.616] Number of futures (= number of chunks): 2
[10:59:32.616] Launching 2 futures (chunks) ...
[10:59:32.616] Chunk #1 of 2 ...
[10:59:32.616]  - Finding globals in '...' for chunk #1 ...
[10:59:32.616] getGlobalsAndPackages() ...
[10:59:32.616] Searching for globals...
[10:59:32.617] 
[10:59:32.617] Searching for globals ... DONE
[10:59:32.617] - globals: [0] <none>
[10:59:32.617] getGlobalsAndPackages() ... DONE
[10:59:32.617]    + additional globals found: [n=0] 
[10:59:32.617]    + additional namespaces needed: [n=0] 
[10:59:32.617]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.617]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.617]  - seeds: <none>
[10:59:32.618]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.618] getGlobalsAndPackages() ...
[10:59:32.618] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.618] Resolving globals: FALSE
[10:59:32.618] The total size of the 5 globals is 880 bytes (880 bytes)
[10:59:32.619] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:32.619] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.619] 
[10:59:32.619] getGlobalsAndPackages() ... DONE
[10:59:32.619] run() for ‘Future’ ...
[10:59:32.619] - state: ‘created’
[10:59:32.620] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.621] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.621]   - Field: ‘label’
[10:59:32.622]   - Field: ‘local’
[10:59:32.622]   - Field: ‘owner’
[10:59:32.622]   - Field: ‘envir’
[10:59:32.622]   - Field: ‘workers’
[10:59:32.622]   - Field: ‘packages’
[10:59:32.622]   - Field: ‘gc’
[10:59:32.622]   - Field: ‘job’
[10:59:32.622]   - Field: ‘conditions’
[10:59:32.622]   - Field: ‘expr’
[10:59:32.622]   - Field: ‘uuid’
[10:59:32.622]   - Field: ‘seed’
[10:59:32.622]   - Field: ‘version’
[10:59:32.623]   - Field: ‘result’
[10:59:32.623]   - Field: ‘asynchronous’
[10:59:32.623]   - Field: ‘calls’
[10:59:32.623]   - Field: ‘globals’
[10:59:32.623]   - Field: ‘stdout’
[10:59:32.623]   - Field: ‘earlySignal’
[10:59:32.623]   - Field: ‘lazy’
[10:59:32.623]   - Field: ‘state’
[10:59:32.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.625] - Launch lazy future ...
[10:59:32.625] Packages needed by the future expression (n = 0): <none>
[10:59:32.625] Packages needed by future strategies (n = 0): <none>
[10:59:32.626] {
[10:59:32.626]     {
[10:59:32.626]         {
[10:59:32.626]             ...future.startTime <- base::Sys.time()
[10:59:32.626]             {
[10:59:32.626]                 {
[10:59:32.626]                   {
[10:59:32.626]                     {
[10:59:32.626]                       base::local({
[10:59:32.626]                         has_future <- base::requireNamespace("future", 
[10:59:32.626]                           quietly = TRUE)
[10:59:32.626]                         if (has_future) {
[10:59:32.626]                           ns <- base::getNamespace("future")
[10:59:32.626]                           version <- ns[[".package"]][["version"]]
[10:59:32.626]                           if (is.null(version)) 
[10:59:32.626]                             version <- utils::packageVersion("future")
[10:59:32.626]                         }
[10:59:32.626]                         else {
[10:59:32.626]                           version <- NULL
[10:59:32.626]                         }
[10:59:32.626]                         if (!has_future || version < "1.8.0") {
[10:59:32.626]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.626]                             "", base::R.version$version.string), 
[10:59:32.626]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.626]                               "release", "version")], collapse = " "), 
[10:59:32.626]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.626]                             info)
[10:59:32.626]                           info <- base::paste(info, collapse = "; ")
[10:59:32.626]                           if (!has_future) {
[10:59:32.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.626]                               info)
[10:59:32.626]                           }
[10:59:32.626]                           else {
[10:59:32.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.626]                               info, version)
[10:59:32.626]                           }
[10:59:32.626]                           base::stop(msg)
[10:59:32.626]                         }
[10:59:32.626]                       })
[10:59:32.626]                     }
[10:59:32.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.626]                     base::options(mc.cores = 1L)
[10:59:32.626]                   }
[10:59:32.626]                   ...future.strategy.old <- future::plan("list")
[10:59:32.626]                   options(future.plan = NULL)
[10:59:32.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.626]                 }
[10:59:32.626]                 ...future.workdir <- getwd()
[10:59:32.626]             }
[10:59:32.626]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.626]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.626]         }
[10:59:32.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.626]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.626]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.626]             base::names(...future.oldOptions))
[10:59:32.626]     }
[10:59:32.626]     if (FALSE) {
[10:59:32.626]     }
[10:59:32.626]     else {
[10:59:32.626]         if (TRUE) {
[10:59:32.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.626]                 open = "w")
[10:59:32.626]         }
[10:59:32.626]         else {
[10:59:32.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.626]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.626]         }
[10:59:32.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.626]             base::sink(type = "output", split = FALSE)
[10:59:32.626]             base::close(...future.stdout)
[10:59:32.626]         }, add = TRUE)
[10:59:32.626]     }
[10:59:32.626]     ...future.frame <- base::sys.nframe()
[10:59:32.626]     ...future.conditions <- base::list()
[10:59:32.626]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.626]     if (FALSE) {
[10:59:32.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.626]     }
[10:59:32.626]     ...future.result <- base::tryCatch({
[10:59:32.626]         base::withCallingHandlers({
[10:59:32.626]             ...future.value <- base::withVisible(base::local({
[10:59:32.626]                 withCallingHandlers({
[10:59:32.626]                   {
[10:59:32.626]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.626]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.626]                       ...future.globals.maxSize)) {
[10:59:32.626]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.626]                       on.exit(options(oopts), add = TRUE)
[10:59:32.626]                     }
[10:59:32.626]                     {
[10:59:32.626]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.626]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.626]                         USE.NAMES = FALSE)
[10:59:32.626]                       do.call(mapply, args = args)
[10:59:32.626]                     }
[10:59:32.626]                   }
[10:59:32.626]                 }, immediateCondition = function(cond) {
[10:59:32.626]                   save_rds <- function (object, pathname, ...) 
[10:59:32.626]                   {
[10:59:32.626]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.626]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.626]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.626]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.626]                         fi_tmp[["mtime"]])
[10:59:32.626]                     }
[10:59:32.626]                     tryCatch({
[10:59:32.626]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.626]                     }, error = function(ex) {
[10:59:32.626]                       msg <- conditionMessage(ex)
[10:59:32.626]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.626]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.626]                         fi_tmp[["mtime"]], msg)
[10:59:32.626]                       ex$message <- msg
[10:59:32.626]                       stop(ex)
[10:59:32.626]                     })
[10:59:32.626]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.626]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.626]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.626]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.626]                       fi <- file.info(pathname)
[10:59:32.626]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.626]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.626]                         fi[["size"]], fi[["mtime"]])
[10:59:32.626]                       stop(msg)
[10:59:32.626]                     }
[10:59:32.626]                     invisible(pathname)
[10:59:32.626]                   }
[10:59:32.626]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.626]                     rootPath = tempdir()) 
[10:59:32.626]                   {
[10:59:32.626]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.626]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.626]                       tmpdir = path, fileext = ".rds")
[10:59:32.626]                     save_rds(obj, file)
[10:59:32.626]                   }
[10:59:32.626]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.626]                   {
[10:59:32.626]                     inherits <- base::inherits
[10:59:32.626]                     invokeRestart <- base::invokeRestart
[10:59:32.626]                     is.null <- base::is.null
[10:59:32.626]                     muffled <- FALSE
[10:59:32.626]                     if (inherits(cond, "message")) {
[10:59:32.626]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.626]                       if (muffled) 
[10:59:32.626]                         invokeRestart("muffleMessage")
[10:59:32.626]                     }
[10:59:32.626]                     else if (inherits(cond, "warning")) {
[10:59:32.626]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.626]                       if (muffled) 
[10:59:32.626]                         invokeRestart("muffleWarning")
[10:59:32.626]                     }
[10:59:32.626]                     else if (inherits(cond, "condition")) {
[10:59:32.626]                       if (!is.null(pattern)) {
[10:59:32.626]                         computeRestarts <- base::computeRestarts
[10:59:32.626]                         grepl <- base::grepl
[10:59:32.626]                         restarts <- computeRestarts(cond)
[10:59:32.626]                         for (restart in restarts) {
[10:59:32.626]                           name <- restart$name
[10:59:32.626]                           if (is.null(name)) 
[10:59:32.626]                             next
[10:59:32.626]                           if (!grepl(pattern, name)) 
[10:59:32.626]                             next
[10:59:32.626]                           invokeRestart(restart)
[10:59:32.626]                           muffled <- TRUE
[10:59:32.626]                           break
[10:59:32.626]                         }
[10:59:32.626]                       }
[10:59:32.626]                     }
[10:59:32.626]                     invisible(muffled)
[10:59:32.626]                   }
[10:59:32.626]                   muffleCondition(cond)
[10:59:32.626]                 })
[10:59:32.626]             }))
[10:59:32.626]             future::FutureResult(value = ...future.value$value, 
[10:59:32.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.626]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.626]                     ...future.globalenv.names))
[10:59:32.626]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.626]         }, condition = base::local({
[10:59:32.626]             c <- base::c
[10:59:32.626]             inherits <- base::inherits
[10:59:32.626]             invokeRestart <- base::invokeRestart
[10:59:32.626]             length <- base::length
[10:59:32.626]             list <- base::list
[10:59:32.626]             seq.int <- base::seq.int
[10:59:32.626]             signalCondition <- base::signalCondition
[10:59:32.626]             sys.calls <- base::sys.calls
[10:59:32.626]             `[[` <- base::`[[`
[10:59:32.626]             `+` <- base::`+`
[10:59:32.626]             `<<-` <- base::`<<-`
[10:59:32.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.626]                   3L)]
[10:59:32.626]             }
[10:59:32.626]             function(cond) {
[10:59:32.626]                 is_error <- inherits(cond, "error")
[10:59:32.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.626]                   NULL)
[10:59:32.626]                 if (is_error) {
[10:59:32.626]                   sessionInformation <- function() {
[10:59:32.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.626]                       search = base::search(), system = base::Sys.info())
[10:59:32.626]                   }
[10:59:32.626]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.626]                     cond$call), session = sessionInformation(), 
[10:59:32.626]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.626]                   signalCondition(cond)
[10:59:32.626]                 }
[10:59:32.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.626]                 "immediateCondition"))) {
[10:59:32.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.626]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.626]                   if (TRUE && !signal) {
[10:59:32.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.626]                     {
[10:59:32.626]                       inherits <- base::inherits
[10:59:32.626]                       invokeRestart <- base::invokeRestart
[10:59:32.626]                       is.null <- base::is.null
[10:59:32.626]                       muffled <- FALSE
[10:59:32.626]                       if (inherits(cond, "message")) {
[10:59:32.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.626]                         if (muffled) 
[10:59:32.626]                           invokeRestart("muffleMessage")
[10:59:32.626]                       }
[10:59:32.626]                       else if (inherits(cond, "warning")) {
[10:59:32.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.626]                         if (muffled) 
[10:59:32.626]                           invokeRestart("muffleWarning")
[10:59:32.626]                       }
[10:59:32.626]                       else if (inherits(cond, "condition")) {
[10:59:32.626]                         if (!is.null(pattern)) {
[10:59:32.626]                           computeRestarts <- base::computeRestarts
[10:59:32.626]                           grepl <- base::grepl
[10:59:32.626]                           restarts <- computeRestarts(cond)
[10:59:32.626]                           for (restart in restarts) {
[10:59:32.626]                             name <- restart$name
[10:59:32.626]                             if (is.null(name)) 
[10:59:32.626]                               next
[10:59:32.626]                             if (!grepl(pattern, name)) 
[10:59:32.626]                               next
[10:59:32.626]                             invokeRestart(restart)
[10:59:32.626]                             muffled <- TRUE
[10:59:32.626]                             break
[10:59:32.626]                           }
[10:59:32.626]                         }
[10:59:32.626]                       }
[10:59:32.626]                       invisible(muffled)
[10:59:32.626]                     }
[10:59:32.626]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.626]                   }
[10:59:32.626]                 }
[10:59:32.626]                 else {
[10:59:32.626]                   if (TRUE) {
[10:59:32.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.626]                     {
[10:59:32.626]                       inherits <- base::inherits
[10:59:32.626]                       invokeRestart <- base::invokeRestart
[10:59:32.626]                       is.null <- base::is.null
[10:59:32.626]                       muffled <- FALSE
[10:59:32.626]                       if (inherits(cond, "message")) {
[10:59:32.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.626]                         if (muffled) 
[10:59:32.626]                           invokeRestart("muffleMessage")
[10:59:32.626]                       }
[10:59:32.626]                       else if (inherits(cond, "warning")) {
[10:59:32.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.626]                         if (muffled) 
[10:59:32.626]                           invokeRestart("muffleWarning")
[10:59:32.626]                       }
[10:59:32.626]                       else if (inherits(cond, "condition")) {
[10:59:32.626]                         if (!is.null(pattern)) {
[10:59:32.626]                           computeRestarts <- base::computeRestarts
[10:59:32.626]                           grepl <- base::grepl
[10:59:32.626]                           restarts <- computeRestarts(cond)
[10:59:32.626]                           for (restart in restarts) {
[10:59:32.626]                             name <- restart$name
[10:59:32.626]                             if (is.null(name)) 
[10:59:32.626]                               next
[10:59:32.626]                             if (!grepl(pattern, name)) 
[10:59:32.626]                               next
[10:59:32.626]                             invokeRestart(restart)
[10:59:32.626]                             muffled <- TRUE
[10:59:32.626]                             break
[10:59:32.626]                           }
[10:59:32.626]                         }
[10:59:32.626]                       }
[10:59:32.626]                       invisible(muffled)
[10:59:32.626]                     }
[10:59:32.626]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.626]                   }
[10:59:32.626]                 }
[10:59:32.626]             }
[10:59:32.626]         }))
[10:59:32.626]     }, error = function(ex) {
[10:59:32.626]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.626]                 ...future.rng), started = ...future.startTime, 
[10:59:32.626]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.626]             version = "1.8"), class = "FutureResult")
[10:59:32.626]     }, finally = {
[10:59:32.626]         if (!identical(...future.workdir, getwd())) 
[10:59:32.626]             setwd(...future.workdir)
[10:59:32.626]         {
[10:59:32.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.626]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.626]             }
[10:59:32.626]             base::options(...future.oldOptions)
[10:59:32.626]             if (.Platform$OS.type == "windows") {
[10:59:32.626]                 old_names <- names(...future.oldEnvVars)
[10:59:32.626]                 envs <- base::Sys.getenv()
[10:59:32.626]                 names <- names(envs)
[10:59:32.626]                 common <- intersect(names, old_names)
[10:59:32.626]                 added <- setdiff(names, old_names)
[10:59:32.626]                 removed <- setdiff(old_names, names)
[10:59:32.626]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.626]                   envs[common]]
[10:59:32.626]                 NAMES <- toupper(changed)
[10:59:32.626]                 args <- list()
[10:59:32.626]                 for (kk in seq_along(NAMES)) {
[10:59:32.626]                   name <- changed[[kk]]
[10:59:32.626]                   NAME <- NAMES[[kk]]
[10:59:32.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.626]                     next
[10:59:32.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.626]                 }
[10:59:32.626]                 NAMES <- toupper(added)
[10:59:32.626]                 for (kk in seq_along(NAMES)) {
[10:59:32.626]                   name <- added[[kk]]
[10:59:32.626]                   NAME <- NAMES[[kk]]
[10:59:32.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.626]                     next
[10:59:32.626]                   args[[name]] <- ""
[10:59:32.626]                 }
[10:59:32.626]                 NAMES <- toupper(removed)
[10:59:32.626]                 for (kk in seq_along(NAMES)) {
[10:59:32.626]                   name <- removed[[kk]]
[10:59:32.626]                   NAME <- NAMES[[kk]]
[10:59:32.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.626]                     next
[10:59:32.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.626]                 }
[10:59:32.626]                 if (length(args) > 0) 
[10:59:32.626]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.626]             }
[10:59:32.626]             else {
[10:59:32.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.626]             }
[10:59:32.626]             {
[10:59:32.626]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.626]                   0L) {
[10:59:32.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.626]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.626]                   base::options(opts)
[10:59:32.626]                 }
[10:59:32.626]                 {
[10:59:32.626]                   {
[10:59:32.626]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.626]                     NULL
[10:59:32.626]                   }
[10:59:32.626]                   options(future.plan = NULL)
[10:59:32.626]                   if (is.na(NA_character_)) 
[10:59:32.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.626]                     .init = FALSE)
[10:59:32.626]                 }
[10:59:32.626]             }
[10:59:32.626]         }
[10:59:32.626]     })
[10:59:32.626]     if (TRUE) {
[10:59:32.626]         base::sink(type = "output", split = FALSE)
[10:59:32.626]         if (TRUE) {
[10:59:32.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.626]         }
[10:59:32.626]         else {
[10:59:32.626]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.626]         }
[10:59:32.626]         base::close(...future.stdout)
[10:59:32.626]         ...future.stdout <- NULL
[10:59:32.626]     }
[10:59:32.626]     ...future.result$conditions <- ...future.conditions
[10:59:32.626]     ...future.result$finished <- base::Sys.time()
[10:59:32.626]     ...future.result
[10:59:32.626] }
[10:59:32.628] assign_globals() ...
[10:59:32.628] List of 5
[10:59:32.628]  $ ...future.FUN            :function (C, k)  
[10:59:32.628]  $ MoreArgs                 : list()
[10:59:32.628]  $ ...future.elements_ii    :List of 2
[10:59:32.628]   ..$ :List of 2
[10:59:32.628]   .. ..$ : chr "A"
[10:59:32.628]   .. ..$ : chr "B"
[10:59:32.628]   ..$ :List of 2
[10:59:32.628]   .. ..$ : int 5
[10:59:32.628]   .. ..$ : int 4
[10:59:32.628]  $ ...future.seeds_ii       : NULL
[10:59:32.628]  $ ...future.globals.maxSize: NULL
[10:59:32.628]  - attr(*, "where")=List of 5
[10:59:32.628]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.628]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.628]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.628]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.628]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.628]  - attr(*, "resolved")= logi FALSE
[10:59:32.628]  - attr(*, "total_size")= num 880
[10:59:32.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.628]  - attr(*, "already-done")= logi TRUE
[10:59:32.634] - reassign environment for ‘...future.FUN’
[10:59:32.634] - copied ‘...future.FUN’ to environment
[10:59:32.634] - copied ‘MoreArgs’ to environment
[10:59:32.634] - copied ‘...future.elements_ii’ to environment
[10:59:32.634] - copied ‘...future.seeds_ii’ to environment
[10:59:32.634] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.634] assign_globals() ... done
[10:59:32.634] requestCore(): workers = 2
[10:59:32.636] MulticoreFuture started
[10:59:32.637] - Launch lazy future ... done
[10:59:32.637] run() for ‘MulticoreFuture’ ... done
[10:59:32.637] Created future:
[10:59:32.637] plan(): Setting new future strategy stack:
[10:59:32.638] List of future strategies:
[10:59:32.638] 1. sequential:
[10:59:32.638]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.638]    - tweaked: FALSE
[10:59:32.638]    - call: NULL
[10:59:32.639] plan(): nbrOfWorkers() = 1
[10:59:32.641] plan(): Setting new future strategy stack:
[10:59:32.641] List of future strategies:
[10:59:32.641] 1. multicore:
[10:59:32.641]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.641]    - tweaked: FALSE
[10:59:32.641]    - call: plan(strategy)
[10:59:32.644] plan(): nbrOfWorkers() = 2
[10:59:32.638] MulticoreFuture:
[10:59:32.638] Label: ‘future_.mapply-1’
[10:59:32.638] Expression:
[10:59:32.638] {
[10:59:32.638]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.638]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.638]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.638]         on.exit(options(oopts), add = TRUE)
[10:59:32.638]     }
[10:59:32.638]     {
[10:59:32.638]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.638]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.638]         do.call(mapply, args = args)
[10:59:32.638]     }
[10:59:32.638] }
[10:59:32.638] Lazy evaluation: FALSE
[10:59:32.638] Asynchronous evaluation: TRUE
[10:59:32.638] Local evaluation: TRUE
[10:59:32.638] Environment: R_GlobalEnv
[10:59:32.638] Capture standard output: TRUE
[10:59:32.638] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.638] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.638] Packages: <none>
[10:59:32.638] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.638] Resolved: TRUE
[10:59:32.638] Value: <not collected>
[10:59:32.638] Conditions captured: <none>
[10:59:32.638] Early signaling: FALSE
[10:59:32.638] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.638] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.645] Chunk #1 of 2 ... DONE
[10:59:32.645] Chunk #2 of 2 ...
[10:59:32.646]  - Finding globals in '...' for chunk #2 ...
[10:59:32.646] getGlobalsAndPackages() ...
[10:59:32.646] Searching for globals...
[10:59:32.646] 
[10:59:32.646] Searching for globals ... DONE
[10:59:32.647] - globals: [0] <none>
[10:59:32.647] getGlobalsAndPackages() ... DONE
[10:59:32.647]    + additional globals found: [n=0] 
[10:59:32.647]    + additional namespaces needed: [n=0] 
[10:59:32.647]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:32.647]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.647]  - seeds: <none>
[10:59:32.647]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.648] getGlobalsAndPackages() ...
[10:59:32.648] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.648] Resolving globals: FALSE
[10:59:32.649] The total size of the 5 globals is 909 bytes (909 bytes)
[10:59:32.649] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:32.650] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.650] 
[10:59:32.650] getGlobalsAndPackages() ... DONE
[10:59:32.650] run() for ‘Future’ ...
[10:59:32.650] - state: ‘created’
[10:59:32.651] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.653] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.653]   - Field: ‘label’
[10:59:32.654]   - Field: ‘local’
[10:59:32.654]   - Field: ‘owner’
[10:59:32.654]   - Field: ‘envir’
[10:59:32.654]   - Field: ‘workers’
[10:59:32.654]   - Field: ‘packages’
[10:59:32.654]   - Field: ‘gc’
[10:59:32.654]   - Field: ‘job’
[10:59:32.655]   - Field: ‘conditions’
[10:59:32.655]   - Field: ‘expr’
[10:59:32.655]   - Field: ‘uuid’
[10:59:32.655]   - Field: ‘seed’
[10:59:32.655]   - Field: ‘version’
[10:59:32.655]   - Field: ‘result’
[10:59:32.656]   - Field: ‘asynchronous’
[10:59:32.656]   - Field: ‘calls’
[10:59:32.656]   - Field: ‘globals’
[10:59:32.656]   - Field: ‘stdout’
[10:59:32.656]   - Field: ‘earlySignal’
[10:59:32.656]   - Field: ‘lazy’
[10:59:32.656]   - Field: ‘state’
[10:59:32.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.657] - Launch lazy future ...
[10:59:32.657] Packages needed by the future expression (n = 0): <none>
[10:59:32.657] Packages needed by future strategies (n = 0): <none>
[10:59:32.658] {
[10:59:32.658]     {
[10:59:32.658]         {
[10:59:32.658]             ...future.startTime <- base::Sys.time()
[10:59:32.658]             {
[10:59:32.658]                 {
[10:59:32.658]                   {
[10:59:32.658]                     {
[10:59:32.658]                       base::local({
[10:59:32.658]                         has_future <- base::requireNamespace("future", 
[10:59:32.658]                           quietly = TRUE)
[10:59:32.658]                         if (has_future) {
[10:59:32.658]                           ns <- base::getNamespace("future")
[10:59:32.658]                           version <- ns[[".package"]][["version"]]
[10:59:32.658]                           if (is.null(version)) 
[10:59:32.658]                             version <- utils::packageVersion("future")
[10:59:32.658]                         }
[10:59:32.658]                         else {
[10:59:32.658]                           version <- NULL
[10:59:32.658]                         }
[10:59:32.658]                         if (!has_future || version < "1.8.0") {
[10:59:32.658]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.658]                             "", base::R.version$version.string), 
[10:59:32.658]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.658]                               "release", "version")], collapse = " "), 
[10:59:32.658]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.658]                             info)
[10:59:32.658]                           info <- base::paste(info, collapse = "; ")
[10:59:32.658]                           if (!has_future) {
[10:59:32.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.658]                               info)
[10:59:32.658]                           }
[10:59:32.658]                           else {
[10:59:32.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.658]                               info, version)
[10:59:32.658]                           }
[10:59:32.658]                           base::stop(msg)
[10:59:32.658]                         }
[10:59:32.658]                       })
[10:59:32.658]                     }
[10:59:32.658]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.658]                     base::options(mc.cores = 1L)
[10:59:32.658]                   }
[10:59:32.658]                   ...future.strategy.old <- future::plan("list")
[10:59:32.658]                   options(future.plan = NULL)
[10:59:32.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.658]                 }
[10:59:32.658]                 ...future.workdir <- getwd()
[10:59:32.658]             }
[10:59:32.658]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.658]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.658]         }
[10:59:32.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.658]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.658]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.658]             base::names(...future.oldOptions))
[10:59:32.658]     }
[10:59:32.658]     if (FALSE) {
[10:59:32.658]     }
[10:59:32.658]     else {
[10:59:32.658]         if (TRUE) {
[10:59:32.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.658]                 open = "w")
[10:59:32.658]         }
[10:59:32.658]         else {
[10:59:32.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.658]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.658]         }
[10:59:32.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.658]             base::sink(type = "output", split = FALSE)
[10:59:32.658]             base::close(...future.stdout)
[10:59:32.658]         }, add = TRUE)
[10:59:32.658]     }
[10:59:32.658]     ...future.frame <- base::sys.nframe()
[10:59:32.658]     ...future.conditions <- base::list()
[10:59:32.658]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.658]     if (FALSE) {
[10:59:32.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.658]     }
[10:59:32.658]     ...future.result <- base::tryCatch({
[10:59:32.658]         base::withCallingHandlers({
[10:59:32.658]             ...future.value <- base::withVisible(base::local({
[10:59:32.658]                 withCallingHandlers({
[10:59:32.658]                   {
[10:59:32.658]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.658]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.658]                       ...future.globals.maxSize)) {
[10:59:32.658]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.658]                       on.exit(options(oopts), add = TRUE)
[10:59:32.658]                     }
[10:59:32.658]                     {
[10:59:32.658]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.658]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.658]                         USE.NAMES = FALSE)
[10:59:32.658]                       do.call(mapply, args = args)
[10:59:32.658]                     }
[10:59:32.658]                   }
[10:59:32.658]                 }, immediateCondition = function(cond) {
[10:59:32.658]                   save_rds <- function (object, pathname, ...) 
[10:59:32.658]                   {
[10:59:32.658]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.658]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.658]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.658]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.658]                         fi_tmp[["mtime"]])
[10:59:32.658]                     }
[10:59:32.658]                     tryCatch({
[10:59:32.658]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.658]                     }, error = function(ex) {
[10:59:32.658]                       msg <- conditionMessage(ex)
[10:59:32.658]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.658]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.658]                         fi_tmp[["mtime"]], msg)
[10:59:32.658]                       ex$message <- msg
[10:59:32.658]                       stop(ex)
[10:59:32.658]                     })
[10:59:32.658]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.658]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.658]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.658]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.658]                       fi <- file.info(pathname)
[10:59:32.658]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.658]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.658]                         fi[["size"]], fi[["mtime"]])
[10:59:32.658]                       stop(msg)
[10:59:32.658]                     }
[10:59:32.658]                     invisible(pathname)
[10:59:32.658]                   }
[10:59:32.658]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.658]                     rootPath = tempdir()) 
[10:59:32.658]                   {
[10:59:32.658]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.658]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.658]                       tmpdir = path, fileext = ".rds")
[10:59:32.658]                     save_rds(obj, file)
[10:59:32.658]                   }
[10:59:32.658]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.658]                   {
[10:59:32.658]                     inherits <- base::inherits
[10:59:32.658]                     invokeRestart <- base::invokeRestart
[10:59:32.658]                     is.null <- base::is.null
[10:59:32.658]                     muffled <- FALSE
[10:59:32.658]                     if (inherits(cond, "message")) {
[10:59:32.658]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.658]                       if (muffled) 
[10:59:32.658]                         invokeRestart("muffleMessage")
[10:59:32.658]                     }
[10:59:32.658]                     else if (inherits(cond, "warning")) {
[10:59:32.658]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.658]                       if (muffled) 
[10:59:32.658]                         invokeRestart("muffleWarning")
[10:59:32.658]                     }
[10:59:32.658]                     else if (inherits(cond, "condition")) {
[10:59:32.658]                       if (!is.null(pattern)) {
[10:59:32.658]                         computeRestarts <- base::computeRestarts
[10:59:32.658]                         grepl <- base::grepl
[10:59:32.658]                         restarts <- computeRestarts(cond)
[10:59:32.658]                         for (restart in restarts) {
[10:59:32.658]                           name <- restart$name
[10:59:32.658]                           if (is.null(name)) 
[10:59:32.658]                             next
[10:59:32.658]                           if (!grepl(pattern, name)) 
[10:59:32.658]                             next
[10:59:32.658]                           invokeRestart(restart)
[10:59:32.658]                           muffled <- TRUE
[10:59:32.658]                           break
[10:59:32.658]                         }
[10:59:32.658]                       }
[10:59:32.658]                     }
[10:59:32.658]                     invisible(muffled)
[10:59:32.658]                   }
[10:59:32.658]                   muffleCondition(cond)
[10:59:32.658]                 })
[10:59:32.658]             }))
[10:59:32.658]             future::FutureResult(value = ...future.value$value, 
[10:59:32.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.658]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.658]                     ...future.globalenv.names))
[10:59:32.658]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.658]         }, condition = base::local({
[10:59:32.658]             c <- base::c
[10:59:32.658]             inherits <- base::inherits
[10:59:32.658]             invokeRestart <- base::invokeRestart
[10:59:32.658]             length <- base::length
[10:59:32.658]             list <- base::list
[10:59:32.658]             seq.int <- base::seq.int
[10:59:32.658]             signalCondition <- base::signalCondition
[10:59:32.658]             sys.calls <- base::sys.calls
[10:59:32.658]             `[[` <- base::`[[`
[10:59:32.658]             `+` <- base::`+`
[10:59:32.658]             `<<-` <- base::`<<-`
[10:59:32.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.658]                   3L)]
[10:59:32.658]             }
[10:59:32.658]             function(cond) {
[10:59:32.658]                 is_error <- inherits(cond, "error")
[10:59:32.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.658]                   NULL)
[10:59:32.658]                 if (is_error) {
[10:59:32.658]                   sessionInformation <- function() {
[10:59:32.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.658]                       search = base::search(), system = base::Sys.info())
[10:59:32.658]                   }
[10:59:32.658]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.658]                     cond$call), session = sessionInformation(), 
[10:59:32.658]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.658]                   signalCondition(cond)
[10:59:32.658]                 }
[10:59:32.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.658]                 "immediateCondition"))) {
[10:59:32.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.658]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.658]                   if (TRUE && !signal) {
[10:59:32.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.658]                     {
[10:59:32.658]                       inherits <- base::inherits
[10:59:32.658]                       invokeRestart <- base::invokeRestart
[10:59:32.658]                       is.null <- base::is.null
[10:59:32.658]                       muffled <- FALSE
[10:59:32.658]                       if (inherits(cond, "message")) {
[10:59:32.658]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.658]                         if (muffled) 
[10:59:32.658]                           invokeRestart("muffleMessage")
[10:59:32.658]                       }
[10:59:32.658]                       else if (inherits(cond, "warning")) {
[10:59:32.658]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.658]                         if (muffled) 
[10:59:32.658]                           invokeRestart("muffleWarning")
[10:59:32.658]                       }
[10:59:32.658]                       else if (inherits(cond, "condition")) {
[10:59:32.658]                         if (!is.null(pattern)) {
[10:59:32.658]                           computeRestarts <- base::computeRestarts
[10:59:32.658]                           grepl <- base::grepl
[10:59:32.658]                           restarts <- computeRestarts(cond)
[10:59:32.658]                           for (restart in restarts) {
[10:59:32.658]                             name <- restart$name
[10:59:32.658]                             if (is.null(name)) 
[10:59:32.658]                               next
[10:59:32.658]                             if (!grepl(pattern, name)) 
[10:59:32.658]                               next
[10:59:32.658]                             invokeRestart(restart)
[10:59:32.658]                             muffled <- TRUE
[10:59:32.658]                             break
[10:59:32.658]                           }
[10:59:32.658]                         }
[10:59:32.658]                       }
[10:59:32.658]                       invisible(muffled)
[10:59:32.658]                     }
[10:59:32.658]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.658]                   }
[10:59:32.658]                 }
[10:59:32.658]                 else {
[10:59:32.658]                   if (TRUE) {
[10:59:32.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.658]                     {
[10:59:32.658]                       inherits <- base::inherits
[10:59:32.658]                       invokeRestart <- base::invokeRestart
[10:59:32.658]                       is.null <- base::is.null
[10:59:32.658]                       muffled <- FALSE
[10:59:32.658]                       if (inherits(cond, "message")) {
[10:59:32.658]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.658]                         if (muffled) 
[10:59:32.658]                           invokeRestart("muffleMessage")
[10:59:32.658]                       }
[10:59:32.658]                       else if (inherits(cond, "warning")) {
[10:59:32.658]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.658]                         if (muffled) 
[10:59:32.658]                           invokeRestart("muffleWarning")
[10:59:32.658]                       }
[10:59:32.658]                       else if (inherits(cond, "condition")) {
[10:59:32.658]                         if (!is.null(pattern)) {
[10:59:32.658]                           computeRestarts <- base::computeRestarts
[10:59:32.658]                           grepl <- base::grepl
[10:59:32.658]                           restarts <- computeRestarts(cond)
[10:59:32.658]                           for (restart in restarts) {
[10:59:32.658]                             name <- restart$name
[10:59:32.658]                             if (is.null(name)) 
[10:59:32.658]                               next
[10:59:32.658]                             if (!grepl(pattern, name)) 
[10:59:32.658]                               next
[10:59:32.658]                             invokeRestart(restart)
[10:59:32.658]                             muffled <- TRUE
[10:59:32.658]                             break
[10:59:32.658]                           }
[10:59:32.658]                         }
[10:59:32.658]                       }
[10:59:32.658]                       invisible(muffled)
[10:59:32.658]                     }
[10:59:32.658]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.658]                   }
[10:59:32.658]                 }
[10:59:32.658]             }
[10:59:32.658]         }))
[10:59:32.658]     }, error = function(ex) {
[10:59:32.658]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.658]                 ...future.rng), started = ...future.startTime, 
[10:59:32.658]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.658]             version = "1.8"), class = "FutureResult")
[10:59:32.658]     }, finally = {
[10:59:32.658]         if (!identical(...future.workdir, getwd())) 
[10:59:32.658]             setwd(...future.workdir)
[10:59:32.658]         {
[10:59:32.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.658]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.658]             }
[10:59:32.658]             base::options(...future.oldOptions)
[10:59:32.658]             if (.Platform$OS.type == "windows") {
[10:59:32.658]                 old_names <- names(...future.oldEnvVars)
[10:59:32.658]                 envs <- base::Sys.getenv()
[10:59:32.658]                 names <- names(envs)
[10:59:32.658]                 common <- intersect(names, old_names)
[10:59:32.658]                 added <- setdiff(names, old_names)
[10:59:32.658]                 removed <- setdiff(old_names, names)
[10:59:32.658]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.658]                   envs[common]]
[10:59:32.658]                 NAMES <- toupper(changed)
[10:59:32.658]                 args <- list()
[10:59:32.658]                 for (kk in seq_along(NAMES)) {
[10:59:32.658]                   name <- changed[[kk]]
[10:59:32.658]                   NAME <- NAMES[[kk]]
[10:59:32.658]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.658]                     next
[10:59:32.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.658]                 }
[10:59:32.658]                 NAMES <- toupper(added)
[10:59:32.658]                 for (kk in seq_along(NAMES)) {
[10:59:32.658]                   name <- added[[kk]]
[10:59:32.658]                   NAME <- NAMES[[kk]]
[10:59:32.658]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.658]                     next
[10:59:32.658]                   args[[name]] <- ""
[10:59:32.658]                 }
[10:59:32.658]                 NAMES <- toupper(removed)
[10:59:32.658]                 for (kk in seq_along(NAMES)) {
[10:59:32.658]                   name <- removed[[kk]]
[10:59:32.658]                   NAME <- NAMES[[kk]]
[10:59:32.658]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.658]                     next
[10:59:32.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.658]                 }
[10:59:32.658]                 if (length(args) > 0) 
[10:59:32.658]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.658]             }
[10:59:32.658]             else {
[10:59:32.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.658]             }
[10:59:32.658]             {
[10:59:32.658]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.658]                   0L) {
[10:59:32.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.658]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.658]                   base::options(opts)
[10:59:32.658]                 }
[10:59:32.658]                 {
[10:59:32.658]                   {
[10:59:32.658]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.658]                     NULL
[10:59:32.658]                   }
[10:59:32.658]                   options(future.plan = NULL)
[10:59:32.658]                   if (is.na(NA_character_)) 
[10:59:32.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.658]                     .init = FALSE)
[10:59:32.658]                 }
[10:59:32.658]             }
[10:59:32.658]         }
[10:59:32.658]     })
[10:59:32.658]     if (TRUE) {
[10:59:32.658]         base::sink(type = "output", split = FALSE)
[10:59:32.658]         if (TRUE) {
[10:59:32.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.658]         }
[10:59:32.658]         else {
[10:59:32.658]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.658]         }
[10:59:32.658]         base::close(...future.stdout)
[10:59:32.658]         ...future.stdout <- NULL
[10:59:32.658]     }
[10:59:32.658]     ...future.result$conditions <- ...future.conditions
[10:59:32.658]     ...future.result$finished <- base::Sys.time()
[10:59:32.658]     ...future.result
[10:59:32.658] }
[10:59:32.661] assign_globals() ...
[10:59:32.661] List of 5
[10:59:32.661]  $ ...future.FUN            :function (C, k)  
[10:59:32.661]  $ MoreArgs                 : list()
[10:59:32.661]  $ ...future.elements_ii    :List of 2
[10:59:32.661]   ..$ :List of 3
[10:59:32.661]   .. ..$ : chr "C"
[10:59:32.661]   .. ..$ : chr "D"
[10:59:32.661]   .. ..$ : chr "E"
[10:59:32.661]   ..$ :List of 3
[10:59:32.661]   .. ..$ : int 3
[10:59:32.661]   .. ..$ : int 2
[10:59:32.661]   .. ..$ : int 1
[10:59:32.661]  $ ...future.seeds_ii       : NULL
[10:59:32.661]  $ ...future.globals.maxSize: NULL
[10:59:32.661]  - attr(*, "where")=List of 5
[10:59:32.661]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.661]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.661]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.661]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.661]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.661]  - attr(*, "resolved")= logi FALSE
[10:59:32.661]  - attr(*, "total_size")= num 909
[10:59:32.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.661]  - attr(*, "already-done")= logi TRUE
[10:59:32.675] - reassign environment for ‘...future.FUN’
[10:59:32.675] - copied ‘...future.FUN’ to environment
[10:59:32.675] - copied ‘MoreArgs’ to environment
[10:59:32.676] - copied ‘...future.elements_ii’ to environment
[10:59:32.676] - copied ‘...future.seeds_ii’ to environment
[10:59:32.676] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.676] assign_globals() ... done
[10:59:32.676] requestCore(): workers = 2
[10:59:32.678] MulticoreFuture started
[10:59:32.679] - Launch lazy future ... done
[10:59:32.679] run() for ‘MulticoreFuture’ ... done
[10:59:32.680] plan(): Setting new future strategy stack:
[10:59:32.680] Created future:
[10:59:32.680] List of future strategies:
[10:59:32.680] 1. sequential:
[10:59:32.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.680]    - tweaked: FALSE
[10:59:32.680]    - call: NULL
[10:59:32.681] plan(): nbrOfWorkers() = 1
[10:59:32.684] plan(): Setting new future strategy stack:
[10:59:32.684] List of future strategies:
[10:59:32.684] 1. multicore:
[10:59:32.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.684]    - tweaked: FALSE
[10:59:32.684]    - call: plan(strategy)
[10:59:32.687] plan(): nbrOfWorkers() = 2
[10:59:32.680] MulticoreFuture:
[10:59:32.680] Label: ‘future_.mapply-2’
[10:59:32.680] Expression:
[10:59:32.680] {
[10:59:32.680]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.680]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.680]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.680]         on.exit(options(oopts), add = TRUE)
[10:59:32.680]     }
[10:59:32.680]     {
[10:59:32.680]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.680]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.680]         do.call(mapply, args = args)
[10:59:32.680]     }
[10:59:32.680] }
[10:59:32.680] Lazy evaluation: FALSE
[10:59:32.680] Asynchronous evaluation: TRUE
[10:59:32.680] Local evaluation: TRUE
[10:59:32.680] Environment: R_GlobalEnv
[10:59:32.680] Capture standard output: TRUE
[10:59:32.680] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.680] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.680] Packages: <none>
[10:59:32.680] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.680] Resolved: TRUE
[10:59:32.680] Value: <not collected>
[10:59:32.680] Conditions captured: <none>
[10:59:32.680] Early signaling: FALSE
[10:59:32.680] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.680] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.689] Chunk #2 of 2 ... DONE
[10:59:32.689] Launching 2 futures (chunks) ... DONE
[10:59:32.689] Resolving 2 futures (chunks) ...
[10:59:32.689] resolve() on list ...
[10:59:32.689]  recursive: 0
[10:59:32.689]  length: 2
[10:59:32.690] 
[10:59:32.690] Future #1
[10:59:32.690] result() for MulticoreFuture ...
[10:59:32.691] result() for MulticoreFuture ...
[10:59:32.691] result() for MulticoreFuture ... done
[10:59:32.691] result() for MulticoreFuture ... done
[10:59:32.691] result() for MulticoreFuture ...
[10:59:32.692] result() for MulticoreFuture ... done
[10:59:32.692] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.692] - nx: 2
[10:59:32.692] - relay: TRUE
[10:59:32.692] - stdout: TRUE
[10:59:32.692] - signal: TRUE
[10:59:32.692] - resignal: FALSE
[10:59:32.693] - force: TRUE
[10:59:32.693] - relayed: [n=2] FALSE, FALSE
[10:59:32.693] - queued futures: [n=2] FALSE, FALSE
[10:59:32.693]  - until=1
[10:59:32.693]  - relaying element #1
[10:59:32.693] result() for MulticoreFuture ...
[10:59:32.693] result() for MulticoreFuture ... done
[10:59:32.693] result() for MulticoreFuture ...
[10:59:32.694] result() for MulticoreFuture ... done
[10:59:32.694] result() for MulticoreFuture ...
[10:59:32.694] result() for MulticoreFuture ... done
[10:59:32.694] result() for MulticoreFuture ...
[10:59:32.694] result() for MulticoreFuture ... done
[10:59:32.694] - relayed: [n=2] TRUE, FALSE
[10:59:32.694] - queued futures: [n=2] TRUE, FALSE
[10:59:32.695] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.695]  length: 1 (resolved future 1)
[10:59:32.695] Future #2
[10:59:32.695] result() for MulticoreFuture ...
[10:59:32.696] result() for MulticoreFuture ...
[10:59:32.696] result() for MulticoreFuture ... done
[10:59:32.696] result() for MulticoreFuture ... done
[10:59:32.696] result() for MulticoreFuture ...
[10:59:32.696] result() for MulticoreFuture ... done
[10:59:32.696] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.697] - nx: 2
[10:59:32.697] - relay: TRUE
[10:59:32.697] - stdout: TRUE
[10:59:32.697] - signal: TRUE
[10:59:32.697] - resignal: FALSE
[10:59:32.697] - force: TRUE
[10:59:32.697] - relayed: [n=2] TRUE, FALSE
[10:59:32.697] - queued futures: [n=2] TRUE, FALSE
[10:59:32.697]  - until=2
[10:59:32.698]  - relaying element #2
[10:59:32.698] result() for MulticoreFuture ...
[10:59:32.698] result() for MulticoreFuture ... done
[10:59:32.698] result() for MulticoreFuture ...
[10:59:32.698] result() for MulticoreFuture ... done
[10:59:32.698] result() for MulticoreFuture ...
[10:59:32.698] result() for MulticoreFuture ... done
[10:59:32.698] result() for MulticoreFuture ...
[10:59:32.699] result() for MulticoreFuture ... done
[10:59:32.699] - relayed: [n=2] TRUE, TRUE
[10:59:32.699] - queued futures: [n=2] TRUE, TRUE
[10:59:32.699] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.699]  length: 0 (resolved future 2)
[10:59:32.699] Relaying remaining futures
[10:59:32.699] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.699] - nx: 2
[10:59:32.699] - relay: TRUE
[10:59:32.700] - stdout: TRUE
[10:59:32.700] - signal: TRUE
[10:59:32.700] - resignal: FALSE
[10:59:32.700] - force: TRUE
[10:59:32.700] - relayed: [n=2] TRUE, TRUE
[10:59:32.700] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:32.700] - relayed: [n=2] TRUE, TRUE
[10:59:32.700] - queued futures: [n=2] TRUE, TRUE
[10:59:32.700] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.701] resolve() on list ... DONE
[10:59:32.701] result() for MulticoreFuture ...
[10:59:32.701] result() for MulticoreFuture ... done
[10:59:32.701] result() for MulticoreFuture ...
[10:59:32.701] result() for MulticoreFuture ... done
[10:59:32.701] result() for MulticoreFuture ...
[10:59:32.701] result() for MulticoreFuture ... done
[10:59:32.701] result() for MulticoreFuture ...
[10:59:32.701] result() for MulticoreFuture ... done
[10:59:32.702]  - Number of value chunks collected: 2
[10:59:32.702] Resolving 2 futures (chunks) ... DONE
[10:59:32.702] Reducing values from 2 chunks ...
[10:59:32.702]  - Number of values collected after concatenation: 5
[10:59:32.702]  - Number of values expected: 5
[10:59:32.702] Reducing values from 2 chunks ... DONE
[10:59:32.702] future_mapply() ... DONE
[10:59:32.703] future_mapply() ...
[10:59:32.705] Number of chunks: 3
[10:59:32.705] Index remapping (attribute 'ordering'): [n = 5] 1, 3, 5, 4, 2
[10:59:32.707] getGlobalsAndPackagesXApply() ...
[10:59:32.707]  - future.globals: TRUE
[10:59:32.707] getGlobalsAndPackages() ...
[10:59:32.707] Searching for globals...
[10:59:32.709] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:32.709] Searching for globals ... DONE
[10:59:32.709] Resolving globals: FALSE
[10:59:32.710] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:32.710] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:32.710] - globals: [1] ‘FUN’
[10:59:32.711] 
[10:59:32.711] getGlobalsAndPackages() ... DONE
[10:59:32.711]  - globals found/used: [n=1] ‘FUN’
[10:59:32.711]  - needed namespaces: [n=0] 
[10:59:32.711] Finding globals ... DONE
[10:59:32.711] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.711] List of 2
[10:59:32.711]  $ ...future.FUN:function (C, k)  
[10:59:32.711]  $ MoreArgs     : NULL
[10:59:32.711]  - attr(*, "where")=List of 2
[10:59:32.711]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.711]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.711]  - attr(*, "resolved")= logi FALSE
[10:59:32.711]  - attr(*, "total_size")= num NA
[10:59:32.714] Packages to be attached in all futures: [n=0] 
[10:59:32.715] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.715] Number of futures (= number of chunks): 3
[10:59:32.715] Launching 3 futures (chunks) ...
[10:59:32.715] Chunk #1 of 3 ...
[10:59:32.715]  - Finding globals in '...' for chunk #1 ...
[10:59:32.715] getGlobalsAndPackages() ...
[10:59:32.715] Searching for globals...
[10:59:32.716] 
[10:59:32.716] Searching for globals ... DONE
[10:59:32.716] - globals: [0] <none>
[10:59:32.716] getGlobalsAndPackages() ... DONE
[10:59:32.716]    + additional globals found: [n=0] 
[10:59:32.716]    + additional namespaces needed: [n=0] 
[10:59:32.716]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.716]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:32.716]  - seeds: <none>
[10:59:32.716]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.717] getGlobalsAndPackages() ...
[10:59:32.717] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.717] Resolving globals: FALSE
[10:59:32.717] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:32.718] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.718] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.718] 
[10:59:32.718] getGlobalsAndPackages() ... DONE
[10:59:32.718] run() for ‘Future’ ...
[10:59:32.718] - state: ‘created’
[10:59:32.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.720] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.720]   - Field: ‘label’
[10:59:32.720]   - Field: ‘local’
[10:59:32.720]   - Field: ‘owner’
[10:59:32.720]   - Field: ‘envir’
[10:59:32.721]   - Field: ‘workers’
[10:59:32.721]   - Field: ‘packages’
[10:59:32.721]   - Field: ‘gc’
[10:59:32.721]   - Field: ‘job’
[10:59:32.721]   - Field: ‘conditions’
[10:59:32.721]   - Field: ‘expr’
[10:59:32.721]   - Field: ‘uuid’
[10:59:32.721]   - Field: ‘seed’
[10:59:32.721]   - Field: ‘version’
[10:59:32.721]   - Field: ‘result’
[10:59:32.721]   - Field: ‘asynchronous’
[10:59:32.721]   - Field: ‘calls’
[10:59:32.722]   - Field: ‘globals’
[10:59:32.722]   - Field: ‘stdout’
[10:59:32.722]   - Field: ‘earlySignal’
[10:59:32.722]   - Field: ‘lazy’
[10:59:32.722]   - Field: ‘state’
[10:59:32.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.722] - Launch lazy future ...
[10:59:32.722] Packages needed by the future expression (n = 0): <none>
[10:59:32.722] Packages needed by future strategies (n = 0): <none>
[10:59:32.723] {
[10:59:32.723]     {
[10:59:32.723]         {
[10:59:32.723]             ...future.startTime <- base::Sys.time()
[10:59:32.723]             {
[10:59:32.723]                 {
[10:59:32.723]                   {
[10:59:32.723]                     {
[10:59:32.723]                       base::local({
[10:59:32.723]                         has_future <- base::requireNamespace("future", 
[10:59:32.723]                           quietly = TRUE)
[10:59:32.723]                         if (has_future) {
[10:59:32.723]                           ns <- base::getNamespace("future")
[10:59:32.723]                           version <- ns[[".package"]][["version"]]
[10:59:32.723]                           if (is.null(version)) 
[10:59:32.723]                             version <- utils::packageVersion("future")
[10:59:32.723]                         }
[10:59:32.723]                         else {
[10:59:32.723]                           version <- NULL
[10:59:32.723]                         }
[10:59:32.723]                         if (!has_future || version < "1.8.0") {
[10:59:32.723]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.723]                             "", base::R.version$version.string), 
[10:59:32.723]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.723]                               "release", "version")], collapse = " "), 
[10:59:32.723]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.723]                             info)
[10:59:32.723]                           info <- base::paste(info, collapse = "; ")
[10:59:32.723]                           if (!has_future) {
[10:59:32.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.723]                               info)
[10:59:32.723]                           }
[10:59:32.723]                           else {
[10:59:32.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.723]                               info, version)
[10:59:32.723]                           }
[10:59:32.723]                           base::stop(msg)
[10:59:32.723]                         }
[10:59:32.723]                       })
[10:59:32.723]                     }
[10:59:32.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.723]                     base::options(mc.cores = 1L)
[10:59:32.723]                   }
[10:59:32.723]                   ...future.strategy.old <- future::plan("list")
[10:59:32.723]                   options(future.plan = NULL)
[10:59:32.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.723]                 }
[10:59:32.723]                 ...future.workdir <- getwd()
[10:59:32.723]             }
[10:59:32.723]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.723]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.723]         }
[10:59:32.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.723]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:32.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.723]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.723]             base::names(...future.oldOptions))
[10:59:32.723]     }
[10:59:32.723]     if (FALSE) {
[10:59:32.723]     }
[10:59:32.723]     else {
[10:59:32.723]         if (TRUE) {
[10:59:32.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.723]                 open = "w")
[10:59:32.723]         }
[10:59:32.723]         else {
[10:59:32.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.723]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.723]         }
[10:59:32.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.723]             base::sink(type = "output", split = FALSE)
[10:59:32.723]             base::close(...future.stdout)
[10:59:32.723]         }, add = TRUE)
[10:59:32.723]     }
[10:59:32.723]     ...future.frame <- base::sys.nframe()
[10:59:32.723]     ...future.conditions <- base::list()
[10:59:32.723]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.723]     if (FALSE) {
[10:59:32.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.723]     }
[10:59:32.723]     ...future.result <- base::tryCatch({
[10:59:32.723]         base::withCallingHandlers({
[10:59:32.723]             ...future.value <- base::withVisible(base::local({
[10:59:32.723]                 withCallingHandlers({
[10:59:32.723]                   {
[10:59:32.723]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.723]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.723]                       ...future.globals.maxSize)) {
[10:59:32.723]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.723]                       on.exit(options(oopts), add = TRUE)
[10:59:32.723]                     }
[10:59:32.723]                     {
[10:59:32.723]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.723]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.723]                         USE.NAMES = FALSE)
[10:59:32.723]                       do.call(mapply, args = args)
[10:59:32.723]                     }
[10:59:32.723]                   }
[10:59:32.723]                 }, immediateCondition = function(cond) {
[10:59:32.723]                   save_rds <- function (object, pathname, ...) 
[10:59:32.723]                   {
[10:59:32.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.723]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.723]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.723]                         fi_tmp[["mtime"]])
[10:59:32.723]                     }
[10:59:32.723]                     tryCatch({
[10:59:32.723]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.723]                     }, error = function(ex) {
[10:59:32.723]                       msg <- conditionMessage(ex)
[10:59:32.723]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.723]                         fi_tmp[["mtime"]], msg)
[10:59:32.723]                       ex$message <- msg
[10:59:32.723]                       stop(ex)
[10:59:32.723]                     })
[10:59:32.723]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.723]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.723]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.723]                       fi <- file.info(pathname)
[10:59:32.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.723]                         fi[["size"]], fi[["mtime"]])
[10:59:32.723]                       stop(msg)
[10:59:32.723]                     }
[10:59:32.723]                     invisible(pathname)
[10:59:32.723]                   }
[10:59:32.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.723]                     rootPath = tempdir()) 
[10:59:32.723]                   {
[10:59:32.723]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.723]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.723]                       tmpdir = path, fileext = ".rds")
[10:59:32.723]                     save_rds(obj, file)
[10:59:32.723]                   }
[10:59:32.723]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.723]                   {
[10:59:32.723]                     inherits <- base::inherits
[10:59:32.723]                     invokeRestart <- base::invokeRestart
[10:59:32.723]                     is.null <- base::is.null
[10:59:32.723]                     muffled <- FALSE
[10:59:32.723]                     if (inherits(cond, "message")) {
[10:59:32.723]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.723]                       if (muffled) 
[10:59:32.723]                         invokeRestart("muffleMessage")
[10:59:32.723]                     }
[10:59:32.723]                     else if (inherits(cond, "warning")) {
[10:59:32.723]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.723]                       if (muffled) 
[10:59:32.723]                         invokeRestart("muffleWarning")
[10:59:32.723]                     }
[10:59:32.723]                     else if (inherits(cond, "condition")) {
[10:59:32.723]                       if (!is.null(pattern)) {
[10:59:32.723]                         computeRestarts <- base::computeRestarts
[10:59:32.723]                         grepl <- base::grepl
[10:59:32.723]                         restarts <- computeRestarts(cond)
[10:59:32.723]                         for (restart in restarts) {
[10:59:32.723]                           name <- restart$name
[10:59:32.723]                           if (is.null(name)) 
[10:59:32.723]                             next
[10:59:32.723]                           if (!grepl(pattern, name)) 
[10:59:32.723]                             next
[10:59:32.723]                           invokeRestart(restart)
[10:59:32.723]                           muffled <- TRUE
[10:59:32.723]                           break
[10:59:32.723]                         }
[10:59:32.723]                       }
[10:59:32.723]                     }
[10:59:32.723]                     invisible(muffled)
[10:59:32.723]                   }
[10:59:32.723]                   muffleCondition(cond)
[10:59:32.723]                 })
[10:59:32.723]             }))
[10:59:32.723]             future::FutureResult(value = ...future.value$value, 
[10:59:32.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.723]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.723]                     ...future.globalenv.names))
[10:59:32.723]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.723]         }, condition = base::local({
[10:59:32.723]             c <- base::c
[10:59:32.723]             inherits <- base::inherits
[10:59:32.723]             invokeRestart <- base::invokeRestart
[10:59:32.723]             length <- base::length
[10:59:32.723]             list <- base::list
[10:59:32.723]             seq.int <- base::seq.int
[10:59:32.723]             signalCondition <- base::signalCondition
[10:59:32.723]             sys.calls <- base::sys.calls
[10:59:32.723]             `[[` <- base::`[[`
[10:59:32.723]             `+` <- base::`+`
[10:59:32.723]             `<<-` <- base::`<<-`
[10:59:32.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.723]                   3L)]
[10:59:32.723]             }
[10:59:32.723]             function(cond) {
[10:59:32.723]                 is_error <- inherits(cond, "error")
[10:59:32.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.723]                   NULL)
[10:59:32.723]                 if (is_error) {
[10:59:32.723]                   sessionInformation <- function() {
[10:59:32.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.723]                       search = base::search(), system = base::Sys.info())
[10:59:32.723]                   }
[10:59:32.723]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.723]                     cond$call), session = sessionInformation(), 
[10:59:32.723]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.723]                   signalCondition(cond)
[10:59:32.723]                 }
[10:59:32.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.723]                 "immediateCondition"))) {
[10:59:32.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.723]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.723]                   if (TRUE && !signal) {
[10:59:32.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.723]                     {
[10:59:32.723]                       inherits <- base::inherits
[10:59:32.723]                       invokeRestart <- base::invokeRestart
[10:59:32.723]                       is.null <- base::is.null
[10:59:32.723]                       muffled <- FALSE
[10:59:32.723]                       if (inherits(cond, "message")) {
[10:59:32.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.723]                         if (muffled) 
[10:59:32.723]                           invokeRestart("muffleMessage")
[10:59:32.723]                       }
[10:59:32.723]                       else if (inherits(cond, "warning")) {
[10:59:32.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.723]                         if (muffled) 
[10:59:32.723]                           invokeRestart("muffleWarning")
[10:59:32.723]                       }
[10:59:32.723]                       else if (inherits(cond, "condition")) {
[10:59:32.723]                         if (!is.null(pattern)) {
[10:59:32.723]                           computeRestarts <- base::computeRestarts
[10:59:32.723]                           grepl <- base::grepl
[10:59:32.723]                           restarts <- computeRestarts(cond)
[10:59:32.723]                           for (restart in restarts) {
[10:59:32.723]                             name <- restart$name
[10:59:32.723]                             if (is.null(name)) 
[10:59:32.723]                               next
[10:59:32.723]                             if (!grepl(pattern, name)) 
[10:59:32.723]                               next
[10:59:32.723]                             invokeRestart(restart)
[10:59:32.723]                             muffled <- TRUE
[10:59:32.723]                             break
[10:59:32.723]                           }
[10:59:32.723]                         }
[10:59:32.723]                       }
[10:59:32.723]                       invisible(muffled)
[10:59:32.723]                     }
[10:59:32.723]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.723]                   }
[10:59:32.723]                 }
[10:59:32.723]                 else {
[10:59:32.723]                   if (TRUE) {
[10:59:32.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.723]                     {
[10:59:32.723]                       inherits <- base::inherits
[10:59:32.723]                       invokeRestart <- base::invokeRestart
[10:59:32.723]                       is.null <- base::is.null
[10:59:32.723]                       muffled <- FALSE
[10:59:32.723]                       if (inherits(cond, "message")) {
[10:59:32.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.723]                         if (muffled) 
[10:59:32.723]                           invokeRestart("muffleMessage")
[10:59:32.723]                       }
[10:59:32.723]                       else if (inherits(cond, "warning")) {
[10:59:32.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.723]                         if (muffled) 
[10:59:32.723]                           invokeRestart("muffleWarning")
[10:59:32.723]                       }
[10:59:32.723]                       else if (inherits(cond, "condition")) {
[10:59:32.723]                         if (!is.null(pattern)) {
[10:59:32.723]                           computeRestarts <- base::computeRestarts
[10:59:32.723]                           grepl <- base::grepl
[10:59:32.723]                           restarts <- computeRestarts(cond)
[10:59:32.723]                           for (restart in restarts) {
[10:59:32.723]                             name <- restart$name
[10:59:32.723]                             if (is.null(name)) 
[10:59:32.723]                               next
[10:59:32.723]                             if (!grepl(pattern, name)) 
[10:59:32.723]                               next
[10:59:32.723]                             invokeRestart(restart)
[10:59:32.723]                             muffled <- TRUE
[10:59:32.723]                             break
[10:59:32.723]                           }
[10:59:32.723]                         }
[10:59:32.723]                       }
[10:59:32.723]                       invisible(muffled)
[10:59:32.723]                     }
[10:59:32.723]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.723]                   }
[10:59:32.723]                 }
[10:59:32.723]             }
[10:59:32.723]         }))
[10:59:32.723]     }, error = function(ex) {
[10:59:32.723]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.723]                 ...future.rng), started = ...future.startTime, 
[10:59:32.723]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.723]             version = "1.8"), class = "FutureResult")
[10:59:32.723]     }, finally = {
[10:59:32.723]         if (!identical(...future.workdir, getwd())) 
[10:59:32.723]             setwd(...future.workdir)
[10:59:32.723]         {
[10:59:32.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.723]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.723]             }
[10:59:32.723]             base::options(...future.oldOptions)
[10:59:32.723]             if (.Platform$OS.type == "windows") {
[10:59:32.723]                 old_names <- names(...future.oldEnvVars)
[10:59:32.723]                 envs <- base::Sys.getenv()
[10:59:32.723]                 names <- names(envs)
[10:59:32.723]                 common <- intersect(names, old_names)
[10:59:32.723]                 added <- setdiff(names, old_names)
[10:59:32.723]                 removed <- setdiff(old_names, names)
[10:59:32.723]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.723]                   envs[common]]
[10:59:32.723]                 NAMES <- toupper(changed)
[10:59:32.723]                 args <- list()
[10:59:32.723]                 for (kk in seq_along(NAMES)) {
[10:59:32.723]                   name <- changed[[kk]]
[10:59:32.723]                   NAME <- NAMES[[kk]]
[10:59:32.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.723]                     next
[10:59:32.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.723]                 }
[10:59:32.723]                 NAMES <- toupper(added)
[10:59:32.723]                 for (kk in seq_along(NAMES)) {
[10:59:32.723]                   name <- added[[kk]]
[10:59:32.723]                   NAME <- NAMES[[kk]]
[10:59:32.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.723]                     next
[10:59:32.723]                   args[[name]] <- ""
[10:59:32.723]                 }
[10:59:32.723]                 NAMES <- toupper(removed)
[10:59:32.723]                 for (kk in seq_along(NAMES)) {
[10:59:32.723]                   name <- removed[[kk]]
[10:59:32.723]                   NAME <- NAMES[[kk]]
[10:59:32.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.723]                     next
[10:59:32.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.723]                 }
[10:59:32.723]                 if (length(args) > 0) 
[10:59:32.723]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.723]             }
[10:59:32.723]             else {
[10:59:32.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.723]             }
[10:59:32.723]             {
[10:59:32.723]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.723]                   0L) {
[10:59:32.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.723]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.723]                   base::options(opts)
[10:59:32.723]                 }
[10:59:32.723]                 {
[10:59:32.723]                   {
[10:59:32.723]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.723]                     NULL
[10:59:32.723]                   }
[10:59:32.723]                   options(future.plan = NULL)
[10:59:32.723]                   if (is.na(NA_character_)) 
[10:59:32.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.723]                     .init = FALSE)
[10:59:32.723]                 }
[10:59:32.723]             }
[10:59:32.723]         }
[10:59:32.723]     })
[10:59:32.723]     if (TRUE) {
[10:59:32.723]         base::sink(type = "output", split = FALSE)
[10:59:32.723]         if (TRUE) {
[10:59:32.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.723]         }
[10:59:32.723]         else {
[10:59:32.723]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.723]         }
[10:59:32.723]         base::close(...future.stdout)
[10:59:32.723]         ...future.stdout <- NULL
[10:59:32.723]     }
[10:59:32.723]     ...future.result$conditions <- ...future.conditions
[10:59:32.723]     ...future.result$finished <- base::Sys.time()
[10:59:32.723]     ...future.result
[10:59:32.723] }
[10:59:32.725] assign_globals() ...
[10:59:32.725] List of 5
[10:59:32.725]  $ ...future.FUN            :function (C, k)  
[10:59:32.725]  $ MoreArgs                 : NULL
[10:59:32.725]  $ ...future.elements_ii    :List of 2
[10:59:32.725]   ..$ :List of 2
[10:59:32.725]   .. ..$ : chr "A"
[10:59:32.725]   .. ..$ : chr "C"
[10:59:32.725]   ..$ :List of 2
[10:59:32.725]   .. ..$ : int 5
[10:59:32.725]   .. ..$ : int 3
[10:59:32.725]  $ ...future.seeds_ii       : NULL
[10:59:32.725]  $ ...future.globals.maxSize: NULL
[10:59:32.725]  - attr(*, "where")=List of 5
[10:59:32.725]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.725]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.725]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.725]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.725]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.725]  - attr(*, "resolved")= logi FALSE
[10:59:32.725]  - attr(*, "total_size")= num 876
[10:59:32.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.725]  - attr(*, "already-done")= logi TRUE
[10:59:32.732] - reassign environment for ‘...future.FUN’
[10:59:32.732] - copied ‘...future.FUN’ to environment
[10:59:32.733] - copied ‘MoreArgs’ to environment
[10:59:32.733] - copied ‘...future.elements_ii’ to environment
[10:59:32.733] - copied ‘...future.seeds_ii’ to environment
[10:59:32.733] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.733] assign_globals() ... done
[10:59:32.733] requestCore(): workers = 2
[10:59:32.735] MulticoreFuture started
[10:59:32.736] - Launch lazy future ... done
[10:59:32.736] run() for ‘MulticoreFuture’ ... done
[10:59:32.737] plan(): Setting new future strategy stack:
[10:59:32.737] Created future:
[10:59:32.737] List of future strategies:
[10:59:32.737] 1. sequential:
[10:59:32.737]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.737]    - tweaked: FALSE
[10:59:32.737]    - call: NULL
[10:59:32.739] plan(): nbrOfWorkers() = 1
[10:59:32.742] plan(): Setting new future strategy stack:
[10:59:32.742] List of future strategies:
[10:59:32.742] 1. multicore:
[10:59:32.742]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.742]    - tweaked: FALSE
[10:59:32.742]    - call: plan(strategy)
[10:59:32.746] plan(): nbrOfWorkers() = 2
[10:59:32.737] MulticoreFuture:
[10:59:32.737] Label: ‘future_mapply-1’
[10:59:32.737] Expression:
[10:59:32.737] {
[10:59:32.737]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.737]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.737]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.737]         on.exit(options(oopts), add = TRUE)
[10:59:32.737]     }
[10:59:32.737]     {
[10:59:32.737]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.737]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.737]         do.call(mapply, args = args)
[10:59:32.737]     }
[10:59:32.737] }
[10:59:32.737] Lazy evaluation: FALSE
[10:59:32.737] Asynchronous evaluation: TRUE
[10:59:32.737] Local evaluation: TRUE
[10:59:32.737] Environment: R_GlobalEnv
[10:59:32.737] Capture standard output: TRUE
[10:59:32.737] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.737] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.737] Packages: <none>
[10:59:32.737] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.737] Resolved: TRUE
[10:59:32.737] Value: <not collected>
[10:59:32.737] Conditions captured: <none>
[10:59:32.737] Early signaling: FALSE
[10:59:32.737] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.737] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.748] Chunk #1 of 3 ... DONE
[10:59:32.748] Chunk #2 of 3 ...
[10:59:32.748]  - Finding globals in '...' for chunk #2 ...
[10:59:32.748] getGlobalsAndPackages() ...
[10:59:32.749] Searching for globals...
[10:59:32.749] 
[10:59:32.749] Searching for globals ... DONE
[10:59:32.750] - globals: [0] <none>
[10:59:32.750] getGlobalsAndPackages() ... DONE
[10:59:32.750]    + additional globals found: [n=0] 
[10:59:32.750]    + additional namespaces needed: [n=0] 
[10:59:32.750]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:32.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:32.751]  - seeds: <none>
[10:59:32.751]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.751] getGlobalsAndPackages() ...
[10:59:32.751] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.751] Resolving globals: FALSE
[10:59:32.752] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:32.753] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.753] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.753] 
[10:59:32.753] getGlobalsAndPackages() ... DONE
[10:59:32.754] run() for ‘Future’ ...
[10:59:32.754] - state: ‘created’
[10:59:32.754] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.757] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.757]   - Field: ‘label’
[10:59:32.757]   - Field: ‘local’
[10:59:32.757]   - Field: ‘owner’
[10:59:32.757]   - Field: ‘envir’
[10:59:32.758]   - Field: ‘workers’
[10:59:32.758]   - Field: ‘packages’
[10:59:32.758]   - Field: ‘gc’
[10:59:32.758]   - Field: ‘job’
[10:59:32.758]   - Field: ‘conditions’
[10:59:32.758]   - Field: ‘expr’
[10:59:32.758]   - Field: ‘uuid’
[10:59:32.758]   - Field: ‘seed’
[10:59:32.759]   - Field: ‘version’
[10:59:32.759]   - Field: ‘result’
[10:59:32.759]   - Field: ‘asynchronous’
[10:59:32.759]   - Field: ‘calls’
[10:59:32.759]   - Field: ‘globals’
[10:59:32.759]   - Field: ‘stdout’
[10:59:32.759]   - Field: ‘earlySignal’
[10:59:32.759]   - Field: ‘lazy’
[10:59:32.759]   - Field: ‘state’
[10:59:32.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.760] - Launch lazy future ...
[10:59:32.760] Packages needed by the future expression (n = 0): <none>
[10:59:32.760] Packages needed by future strategies (n = 0): <none>
[10:59:32.761] {
[10:59:32.761]     {
[10:59:32.761]         {
[10:59:32.761]             ...future.startTime <- base::Sys.time()
[10:59:32.761]             {
[10:59:32.761]                 {
[10:59:32.761]                   {
[10:59:32.761]                     {
[10:59:32.761]                       base::local({
[10:59:32.761]                         has_future <- base::requireNamespace("future", 
[10:59:32.761]                           quietly = TRUE)
[10:59:32.761]                         if (has_future) {
[10:59:32.761]                           ns <- base::getNamespace("future")
[10:59:32.761]                           version <- ns[[".package"]][["version"]]
[10:59:32.761]                           if (is.null(version)) 
[10:59:32.761]                             version <- utils::packageVersion("future")
[10:59:32.761]                         }
[10:59:32.761]                         else {
[10:59:32.761]                           version <- NULL
[10:59:32.761]                         }
[10:59:32.761]                         if (!has_future || version < "1.8.0") {
[10:59:32.761]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.761]                             "", base::R.version$version.string), 
[10:59:32.761]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.761]                               "release", "version")], collapse = " "), 
[10:59:32.761]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.761]                             info)
[10:59:32.761]                           info <- base::paste(info, collapse = "; ")
[10:59:32.761]                           if (!has_future) {
[10:59:32.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.761]                               info)
[10:59:32.761]                           }
[10:59:32.761]                           else {
[10:59:32.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.761]                               info, version)
[10:59:32.761]                           }
[10:59:32.761]                           base::stop(msg)
[10:59:32.761]                         }
[10:59:32.761]                       })
[10:59:32.761]                     }
[10:59:32.761]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.761]                     base::options(mc.cores = 1L)
[10:59:32.761]                   }
[10:59:32.761]                   ...future.strategy.old <- future::plan("list")
[10:59:32.761]                   options(future.plan = NULL)
[10:59:32.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.761]                 }
[10:59:32.761]                 ...future.workdir <- getwd()
[10:59:32.761]             }
[10:59:32.761]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.761]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.761]         }
[10:59:32.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.761]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:32.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.761]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.761]             base::names(...future.oldOptions))
[10:59:32.761]     }
[10:59:32.761]     if (FALSE) {
[10:59:32.761]     }
[10:59:32.761]     else {
[10:59:32.761]         if (TRUE) {
[10:59:32.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.761]                 open = "w")
[10:59:32.761]         }
[10:59:32.761]         else {
[10:59:32.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.761]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.761]         }
[10:59:32.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.761]             base::sink(type = "output", split = FALSE)
[10:59:32.761]             base::close(...future.stdout)
[10:59:32.761]         }, add = TRUE)
[10:59:32.761]     }
[10:59:32.761]     ...future.frame <- base::sys.nframe()
[10:59:32.761]     ...future.conditions <- base::list()
[10:59:32.761]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.761]     if (FALSE) {
[10:59:32.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.761]     }
[10:59:32.761]     ...future.result <- base::tryCatch({
[10:59:32.761]         base::withCallingHandlers({
[10:59:32.761]             ...future.value <- base::withVisible(base::local({
[10:59:32.761]                 withCallingHandlers({
[10:59:32.761]                   {
[10:59:32.761]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.761]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.761]                       ...future.globals.maxSize)) {
[10:59:32.761]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.761]                       on.exit(options(oopts), add = TRUE)
[10:59:32.761]                     }
[10:59:32.761]                     {
[10:59:32.761]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.761]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.761]                         USE.NAMES = FALSE)
[10:59:32.761]                       do.call(mapply, args = args)
[10:59:32.761]                     }
[10:59:32.761]                   }
[10:59:32.761]                 }, immediateCondition = function(cond) {
[10:59:32.761]                   save_rds <- function (object, pathname, ...) 
[10:59:32.761]                   {
[10:59:32.761]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.761]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.761]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.761]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.761]                         fi_tmp[["mtime"]])
[10:59:32.761]                     }
[10:59:32.761]                     tryCatch({
[10:59:32.761]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.761]                     }, error = function(ex) {
[10:59:32.761]                       msg <- conditionMessage(ex)
[10:59:32.761]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.761]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.761]                         fi_tmp[["mtime"]], msg)
[10:59:32.761]                       ex$message <- msg
[10:59:32.761]                       stop(ex)
[10:59:32.761]                     })
[10:59:32.761]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.761]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.761]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.761]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.761]                       fi <- file.info(pathname)
[10:59:32.761]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.761]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.761]                         fi[["size"]], fi[["mtime"]])
[10:59:32.761]                       stop(msg)
[10:59:32.761]                     }
[10:59:32.761]                     invisible(pathname)
[10:59:32.761]                   }
[10:59:32.761]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.761]                     rootPath = tempdir()) 
[10:59:32.761]                   {
[10:59:32.761]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.761]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.761]                       tmpdir = path, fileext = ".rds")
[10:59:32.761]                     save_rds(obj, file)
[10:59:32.761]                   }
[10:59:32.761]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.761]                   {
[10:59:32.761]                     inherits <- base::inherits
[10:59:32.761]                     invokeRestart <- base::invokeRestart
[10:59:32.761]                     is.null <- base::is.null
[10:59:32.761]                     muffled <- FALSE
[10:59:32.761]                     if (inherits(cond, "message")) {
[10:59:32.761]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.761]                       if (muffled) 
[10:59:32.761]                         invokeRestart("muffleMessage")
[10:59:32.761]                     }
[10:59:32.761]                     else if (inherits(cond, "warning")) {
[10:59:32.761]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.761]                       if (muffled) 
[10:59:32.761]                         invokeRestart("muffleWarning")
[10:59:32.761]                     }
[10:59:32.761]                     else if (inherits(cond, "condition")) {
[10:59:32.761]                       if (!is.null(pattern)) {
[10:59:32.761]                         computeRestarts <- base::computeRestarts
[10:59:32.761]                         grepl <- base::grepl
[10:59:32.761]                         restarts <- computeRestarts(cond)
[10:59:32.761]                         for (restart in restarts) {
[10:59:32.761]                           name <- restart$name
[10:59:32.761]                           if (is.null(name)) 
[10:59:32.761]                             next
[10:59:32.761]                           if (!grepl(pattern, name)) 
[10:59:32.761]                             next
[10:59:32.761]                           invokeRestart(restart)
[10:59:32.761]                           muffled <- TRUE
[10:59:32.761]                           break
[10:59:32.761]                         }
[10:59:32.761]                       }
[10:59:32.761]                     }
[10:59:32.761]                     invisible(muffled)
[10:59:32.761]                   }
[10:59:32.761]                   muffleCondition(cond)
[10:59:32.761]                 })
[10:59:32.761]             }))
[10:59:32.761]             future::FutureResult(value = ...future.value$value, 
[10:59:32.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.761]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.761]                     ...future.globalenv.names))
[10:59:32.761]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.761]         }, condition = base::local({
[10:59:32.761]             c <- base::c
[10:59:32.761]             inherits <- base::inherits
[10:59:32.761]             invokeRestart <- base::invokeRestart
[10:59:32.761]             length <- base::length
[10:59:32.761]             list <- base::list
[10:59:32.761]             seq.int <- base::seq.int
[10:59:32.761]             signalCondition <- base::signalCondition
[10:59:32.761]             sys.calls <- base::sys.calls
[10:59:32.761]             `[[` <- base::`[[`
[10:59:32.761]             `+` <- base::`+`
[10:59:32.761]             `<<-` <- base::`<<-`
[10:59:32.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.761]                   3L)]
[10:59:32.761]             }
[10:59:32.761]             function(cond) {
[10:59:32.761]                 is_error <- inherits(cond, "error")
[10:59:32.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.761]                   NULL)
[10:59:32.761]                 if (is_error) {
[10:59:32.761]                   sessionInformation <- function() {
[10:59:32.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.761]                       search = base::search(), system = base::Sys.info())
[10:59:32.761]                   }
[10:59:32.761]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.761]                     cond$call), session = sessionInformation(), 
[10:59:32.761]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.761]                   signalCondition(cond)
[10:59:32.761]                 }
[10:59:32.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.761]                 "immediateCondition"))) {
[10:59:32.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.761]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.761]                   if (TRUE && !signal) {
[10:59:32.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.761]                     {
[10:59:32.761]                       inherits <- base::inherits
[10:59:32.761]                       invokeRestart <- base::invokeRestart
[10:59:32.761]                       is.null <- base::is.null
[10:59:32.761]                       muffled <- FALSE
[10:59:32.761]                       if (inherits(cond, "message")) {
[10:59:32.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.761]                         if (muffled) 
[10:59:32.761]                           invokeRestart("muffleMessage")
[10:59:32.761]                       }
[10:59:32.761]                       else if (inherits(cond, "warning")) {
[10:59:32.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.761]                         if (muffled) 
[10:59:32.761]                           invokeRestart("muffleWarning")
[10:59:32.761]                       }
[10:59:32.761]                       else if (inherits(cond, "condition")) {
[10:59:32.761]                         if (!is.null(pattern)) {
[10:59:32.761]                           computeRestarts <- base::computeRestarts
[10:59:32.761]                           grepl <- base::grepl
[10:59:32.761]                           restarts <- computeRestarts(cond)
[10:59:32.761]                           for (restart in restarts) {
[10:59:32.761]                             name <- restart$name
[10:59:32.761]                             if (is.null(name)) 
[10:59:32.761]                               next
[10:59:32.761]                             if (!grepl(pattern, name)) 
[10:59:32.761]                               next
[10:59:32.761]                             invokeRestart(restart)
[10:59:32.761]                             muffled <- TRUE
[10:59:32.761]                             break
[10:59:32.761]                           }
[10:59:32.761]                         }
[10:59:32.761]                       }
[10:59:32.761]                       invisible(muffled)
[10:59:32.761]                     }
[10:59:32.761]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.761]                   }
[10:59:32.761]                 }
[10:59:32.761]                 else {
[10:59:32.761]                   if (TRUE) {
[10:59:32.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.761]                     {
[10:59:32.761]                       inherits <- base::inherits
[10:59:32.761]                       invokeRestart <- base::invokeRestart
[10:59:32.761]                       is.null <- base::is.null
[10:59:32.761]                       muffled <- FALSE
[10:59:32.761]                       if (inherits(cond, "message")) {
[10:59:32.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.761]                         if (muffled) 
[10:59:32.761]                           invokeRestart("muffleMessage")
[10:59:32.761]                       }
[10:59:32.761]                       else if (inherits(cond, "warning")) {
[10:59:32.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.761]                         if (muffled) 
[10:59:32.761]                           invokeRestart("muffleWarning")
[10:59:32.761]                       }
[10:59:32.761]                       else if (inherits(cond, "condition")) {
[10:59:32.761]                         if (!is.null(pattern)) {
[10:59:32.761]                           computeRestarts <- base::computeRestarts
[10:59:32.761]                           grepl <- base::grepl
[10:59:32.761]                           restarts <- computeRestarts(cond)
[10:59:32.761]                           for (restart in restarts) {
[10:59:32.761]                             name <- restart$name
[10:59:32.761]                             if (is.null(name)) 
[10:59:32.761]                               next
[10:59:32.761]                             if (!grepl(pattern, name)) 
[10:59:32.761]                               next
[10:59:32.761]                             invokeRestart(restart)
[10:59:32.761]                             muffled <- TRUE
[10:59:32.761]                             break
[10:59:32.761]                           }
[10:59:32.761]                         }
[10:59:32.761]                       }
[10:59:32.761]                       invisible(muffled)
[10:59:32.761]                     }
[10:59:32.761]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.761]                   }
[10:59:32.761]                 }
[10:59:32.761]             }
[10:59:32.761]         }))
[10:59:32.761]     }, error = function(ex) {
[10:59:32.761]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.761]                 ...future.rng), started = ...future.startTime, 
[10:59:32.761]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.761]             version = "1.8"), class = "FutureResult")
[10:59:32.761]     }, finally = {
[10:59:32.761]         if (!identical(...future.workdir, getwd())) 
[10:59:32.761]             setwd(...future.workdir)
[10:59:32.761]         {
[10:59:32.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.761]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.761]             }
[10:59:32.761]             base::options(...future.oldOptions)
[10:59:32.761]             if (.Platform$OS.type == "windows") {
[10:59:32.761]                 old_names <- names(...future.oldEnvVars)
[10:59:32.761]                 envs <- base::Sys.getenv()
[10:59:32.761]                 names <- names(envs)
[10:59:32.761]                 common <- intersect(names, old_names)
[10:59:32.761]                 added <- setdiff(names, old_names)
[10:59:32.761]                 removed <- setdiff(old_names, names)
[10:59:32.761]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.761]                   envs[common]]
[10:59:32.761]                 NAMES <- toupper(changed)
[10:59:32.761]                 args <- list()
[10:59:32.761]                 for (kk in seq_along(NAMES)) {
[10:59:32.761]                   name <- changed[[kk]]
[10:59:32.761]                   NAME <- NAMES[[kk]]
[10:59:32.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.761]                     next
[10:59:32.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.761]                 }
[10:59:32.761]                 NAMES <- toupper(added)
[10:59:32.761]                 for (kk in seq_along(NAMES)) {
[10:59:32.761]                   name <- added[[kk]]
[10:59:32.761]                   NAME <- NAMES[[kk]]
[10:59:32.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.761]                     next
[10:59:32.761]                   args[[name]] <- ""
[10:59:32.761]                 }
[10:59:32.761]                 NAMES <- toupper(removed)
[10:59:32.761]                 for (kk in seq_along(NAMES)) {
[10:59:32.761]                   name <- removed[[kk]]
[10:59:32.761]                   NAME <- NAMES[[kk]]
[10:59:32.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.761]                     next
[10:59:32.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.761]                 }
[10:59:32.761]                 if (length(args) > 0) 
[10:59:32.761]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.761]             }
[10:59:32.761]             else {
[10:59:32.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.761]             }
[10:59:32.761]             {
[10:59:32.761]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.761]                   0L) {
[10:59:32.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.761]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.761]                   base::options(opts)
[10:59:32.761]                 }
[10:59:32.761]                 {
[10:59:32.761]                   {
[10:59:32.761]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.761]                     NULL
[10:59:32.761]                   }
[10:59:32.761]                   options(future.plan = NULL)
[10:59:32.761]                   if (is.na(NA_character_)) 
[10:59:32.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.761]                     .init = FALSE)
[10:59:32.761]                 }
[10:59:32.761]             }
[10:59:32.761]         }
[10:59:32.761]     })
[10:59:32.761]     if (TRUE) {
[10:59:32.761]         base::sink(type = "output", split = FALSE)
[10:59:32.761]         if (TRUE) {
[10:59:32.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.761]         }
[10:59:32.761]         else {
[10:59:32.761]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.761]         }
[10:59:32.761]         base::close(...future.stdout)
[10:59:32.761]         ...future.stdout <- NULL
[10:59:32.761]     }
[10:59:32.761]     ...future.result$conditions <- ...future.conditions
[10:59:32.761]     ...future.result$finished <- base::Sys.time()
[10:59:32.761]     ...future.result
[10:59:32.761] }
[10:59:32.764] assign_globals() ...
[10:59:32.764] List of 5
[10:59:32.764]  $ ...future.FUN            :function (C, k)  
[10:59:32.764]  $ MoreArgs                 : NULL
[10:59:32.764]  $ ...future.elements_ii    :List of 2
[10:59:32.764]   ..$ :List of 1
[10:59:32.764]   .. ..$ : chr "E"
[10:59:32.764]   ..$ :List of 1
[10:59:32.764]   .. ..$ : int 1
[10:59:32.764]  $ ...future.seeds_ii       : NULL
[10:59:32.764]  $ ...future.globals.maxSize: NULL
[10:59:32.764]  - attr(*, "where")=List of 5
[10:59:32.764]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.764]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.764]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.764]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.764]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.764]  - attr(*, "resolved")= logi FALSE
[10:59:32.764]  - attr(*, "total_size")= num 847
[10:59:32.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.764]  - attr(*, "already-done")= logi TRUE
[10:59:32.771] - reassign environment for ‘...future.FUN’
[10:59:32.771] - copied ‘...future.FUN’ to environment
[10:59:32.771] - copied ‘MoreArgs’ to environment
[10:59:32.771] - copied ‘...future.elements_ii’ to environment
[10:59:32.772] - copied ‘...future.seeds_ii’ to environment
[10:59:32.772] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.772] assign_globals() ... done
[10:59:32.772] requestCore(): workers = 2
[10:59:32.774] MulticoreFuture started
[10:59:32.778] - Launch lazy future ... done
[10:59:32.779] plan(): Setting new future strategy stack:
[10:59:32.779] run() for ‘MulticoreFuture’ ... done
[10:59:32.779] Created future:
[10:59:32.779] List of future strategies:
[10:59:32.779] 1. sequential:
[10:59:32.779]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.779]    - tweaked: FALSE
[10:59:32.779]    - call: NULL
[10:59:32.781] plan(): nbrOfWorkers() = 1
[10:59:32.784] plan(): Setting new future strategy stack:
[10:59:32.784] List of future strategies:
[10:59:32.784] 1. multicore:
[10:59:32.784]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.784]    - tweaked: FALSE
[10:59:32.784]    - call: plan(strategy)
[10:59:32.788] plan(): nbrOfWorkers() = 2
[10:59:32.780] MulticoreFuture:
[10:59:32.780] Label: ‘future_mapply-2’
[10:59:32.780] Expression:
[10:59:32.780] {
[10:59:32.780]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.780]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.780]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.780]         on.exit(options(oopts), add = TRUE)
[10:59:32.780]     }
[10:59:32.780]     {
[10:59:32.780]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.780]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.780]         do.call(mapply, args = args)
[10:59:32.780]     }
[10:59:32.780] }
[10:59:32.780] Lazy evaluation: FALSE
[10:59:32.780] Asynchronous evaluation: TRUE
[10:59:32.780] Local evaluation: TRUE
[10:59:32.780] Environment: R_GlobalEnv
[10:59:32.780] Capture standard output: TRUE
[10:59:32.780] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.780] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.780] Packages: <none>
[10:59:32.780] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.780] Resolved: TRUE
[10:59:32.780] Value: <not collected>
[10:59:32.780] Conditions captured: <none>
[10:59:32.780] Early signaling: FALSE
[10:59:32.780] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.780] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.789] Chunk #2 of 3 ... DONE
[10:59:32.789] Chunk #3 of 3 ...
[10:59:32.790]  - Finding globals in '...' for chunk #3 ...
[10:59:32.790] getGlobalsAndPackages() ...
[10:59:32.790] Searching for globals...
[10:59:32.791] 
[10:59:32.791] Searching for globals ... DONE
[10:59:32.791] - globals: [0] <none>
[10:59:32.791] getGlobalsAndPackages() ... DONE
[10:59:32.792]    + additional globals found: [n=0] 
[10:59:32.792]    + additional namespaces needed: [n=0] 
[10:59:32.792]  - Finding globals in '...' for chunk #3 ... DONE
[10:59:32.792]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:32.792]  - seeds: <none>
[10:59:32.793]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.793] getGlobalsAndPackages() ...
[10:59:32.793] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.793] Resolving globals: FALSE
[10:59:32.794] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:32.795] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.795] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.795] 
[10:59:32.796] getGlobalsAndPackages() ... DONE
[10:59:32.796] run() for ‘Future’ ...
[10:59:32.796] - state: ‘created’
[10:59:32.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.799] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.800]   - Field: ‘label’
[10:59:32.800]   - Field: ‘local’
[10:59:32.800]   - Field: ‘owner’
[10:59:32.800]   - Field: ‘envir’
[10:59:32.800]   - Field: ‘workers’
[10:59:32.800]   - Field: ‘packages’
[10:59:32.800]   - Field: ‘gc’
[10:59:32.801]   - Field: ‘job’
[10:59:32.801]   - Field: ‘conditions’
[10:59:32.801]   - Field: ‘expr’
[10:59:32.801]   - Field: ‘uuid’
[10:59:32.801]   - Field: ‘seed’
[10:59:32.801]   - Field: ‘version’
[10:59:32.801]   - Field: ‘result’
[10:59:32.802]   - Field: ‘asynchronous’
[10:59:32.802]   - Field: ‘calls’
[10:59:32.802]   - Field: ‘globals’
[10:59:32.802]   - Field: ‘stdout’
[10:59:32.802]   - Field: ‘earlySignal’
[10:59:32.802]   - Field: ‘lazy’
[10:59:32.802]   - Field: ‘state’
[10:59:32.802] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.803] - Launch lazy future ...
[10:59:32.803] Packages needed by the future expression (n = 0): <none>
[10:59:32.803] Packages needed by future strategies (n = 0): <none>
[10:59:32.804] {
[10:59:32.804]     {
[10:59:32.804]         {
[10:59:32.804]             ...future.startTime <- base::Sys.time()
[10:59:32.804]             {
[10:59:32.804]                 {
[10:59:32.804]                   {
[10:59:32.804]                     {
[10:59:32.804]                       base::local({
[10:59:32.804]                         has_future <- base::requireNamespace("future", 
[10:59:32.804]                           quietly = TRUE)
[10:59:32.804]                         if (has_future) {
[10:59:32.804]                           ns <- base::getNamespace("future")
[10:59:32.804]                           version <- ns[[".package"]][["version"]]
[10:59:32.804]                           if (is.null(version)) 
[10:59:32.804]                             version <- utils::packageVersion("future")
[10:59:32.804]                         }
[10:59:32.804]                         else {
[10:59:32.804]                           version <- NULL
[10:59:32.804]                         }
[10:59:32.804]                         if (!has_future || version < "1.8.0") {
[10:59:32.804]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.804]                             "", base::R.version$version.string), 
[10:59:32.804]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.804]                               "release", "version")], collapse = " "), 
[10:59:32.804]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.804]                             info)
[10:59:32.804]                           info <- base::paste(info, collapse = "; ")
[10:59:32.804]                           if (!has_future) {
[10:59:32.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.804]                               info)
[10:59:32.804]                           }
[10:59:32.804]                           else {
[10:59:32.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.804]                               info, version)
[10:59:32.804]                           }
[10:59:32.804]                           base::stop(msg)
[10:59:32.804]                         }
[10:59:32.804]                       })
[10:59:32.804]                     }
[10:59:32.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.804]                     base::options(mc.cores = 1L)
[10:59:32.804]                   }
[10:59:32.804]                   ...future.strategy.old <- future::plan("list")
[10:59:32.804]                   options(future.plan = NULL)
[10:59:32.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.804]                 }
[10:59:32.804]                 ...future.workdir <- getwd()
[10:59:32.804]             }
[10:59:32.804]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.804]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.804]         }
[10:59:32.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.804]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:32.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.804]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.804]             base::names(...future.oldOptions))
[10:59:32.804]     }
[10:59:32.804]     if (FALSE) {
[10:59:32.804]     }
[10:59:32.804]     else {
[10:59:32.804]         if (TRUE) {
[10:59:32.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.804]                 open = "w")
[10:59:32.804]         }
[10:59:32.804]         else {
[10:59:32.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.804]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.804]         }
[10:59:32.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.804]             base::sink(type = "output", split = FALSE)
[10:59:32.804]             base::close(...future.stdout)
[10:59:32.804]         }, add = TRUE)
[10:59:32.804]     }
[10:59:32.804]     ...future.frame <- base::sys.nframe()
[10:59:32.804]     ...future.conditions <- base::list()
[10:59:32.804]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.804]     if (FALSE) {
[10:59:32.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.804]     }
[10:59:32.804]     ...future.result <- base::tryCatch({
[10:59:32.804]         base::withCallingHandlers({
[10:59:32.804]             ...future.value <- base::withVisible(base::local({
[10:59:32.804]                 withCallingHandlers({
[10:59:32.804]                   {
[10:59:32.804]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.804]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.804]                       ...future.globals.maxSize)) {
[10:59:32.804]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.804]                       on.exit(options(oopts), add = TRUE)
[10:59:32.804]                     }
[10:59:32.804]                     {
[10:59:32.804]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.804]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.804]                         USE.NAMES = FALSE)
[10:59:32.804]                       do.call(mapply, args = args)
[10:59:32.804]                     }
[10:59:32.804]                   }
[10:59:32.804]                 }, immediateCondition = function(cond) {
[10:59:32.804]                   save_rds <- function (object, pathname, ...) 
[10:59:32.804]                   {
[10:59:32.804]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.804]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.804]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.804]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.804]                         fi_tmp[["mtime"]])
[10:59:32.804]                     }
[10:59:32.804]                     tryCatch({
[10:59:32.804]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.804]                     }, error = function(ex) {
[10:59:32.804]                       msg <- conditionMessage(ex)
[10:59:32.804]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.804]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.804]                         fi_tmp[["mtime"]], msg)
[10:59:32.804]                       ex$message <- msg
[10:59:32.804]                       stop(ex)
[10:59:32.804]                     })
[10:59:32.804]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.804]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.804]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.804]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.804]                       fi <- file.info(pathname)
[10:59:32.804]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.804]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.804]                         fi[["size"]], fi[["mtime"]])
[10:59:32.804]                       stop(msg)
[10:59:32.804]                     }
[10:59:32.804]                     invisible(pathname)
[10:59:32.804]                   }
[10:59:32.804]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.804]                     rootPath = tempdir()) 
[10:59:32.804]                   {
[10:59:32.804]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.804]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.804]                       tmpdir = path, fileext = ".rds")
[10:59:32.804]                     save_rds(obj, file)
[10:59:32.804]                   }
[10:59:32.804]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.804]                   {
[10:59:32.804]                     inherits <- base::inherits
[10:59:32.804]                     invokeRestart <- base::invokeRestart
[10:59:32.804]                     is.null <- base::is.null
[10:59:32.804]                     muffled <- FALSE
[10:59:32.804]                     if (inherits(cond, "message")) {
[10:59:32.804]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.804]                       if (muffled) 
[10:59:32.804]                         invokeRestart("muffleMessage")
[10:59:32.804]                     }
[10:59:32.804]                     else if (inherits(cond, "warning")) {
[10:59:32.804]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.804]                       if (muffled) 
[10:59:32.804]                         invokeRestart("muffleWarning")
[10:59:32.804]                     }
[10:59:32.804]                     else if (inherits(cond, "condition")) {
[10:59:32.804]                       if (!is.null(pattern)) {
[10:59:32.804]                         computeRestarts <- base::computeRestarts
[10:59:32.804]                         grepl <- base::grepl
[10:59:32.804]                         restarts <- computeRestarts(cond)
[10:59:32.804]                         for (restart in restarts) {
[10:59:32.804]                           name <- restart$name
[10:59:32.804]                           if (is.null(name)) 
[10:59:32.804]                             next
[10:59:32.804]                           if (!grepl(pattern, name)) 
[10:59:32.804]                             next
[10:59:32.804]                           invokeRestart(restart)
[10:59:32.804]                           muffled <- TRUE
[10:59:32.804]                           break
[10:59:32.804]                         }
[10:59:32.804]                       }
[10:59:32.804]                     }
[10:59:32.804]                     invisible(muffled)
[10:59:32.804]                   }
[10:59:32.804]                   muffleCondition(cond)
[10:59:32.804]                 })
[10:59:32.804]             }))
[10:59:32.804]             future::FutureResult(value = ...future.value$value, 
[10:59:32.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.804]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.804]                     ...future.globalenv.names))
[10:59:32.804]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.804]         }, condition = base::local({
[10:59:32.804]             c <- base::c
[10:59:32.804]             inherits <- base::inherits
[10:59:32.804]             invokeRestart <- base::invokeRestart
[10:59:32.804]             length <- base::length
[10:59:32.804]             list <- base::list
[10:59:32.804]             seq.int <- base::seq.int
[10:59:32.804]             signalCondition <- base::signalCondition
[10:59:32.804]             sys.calls <- base::sys.calls
[10:59:32.804]             `[[` <- base::`[[`
[10:59:32.804]             `+` <- base::`+`
[10:59:32.804]             `<<-` <- base::`<<-`
[10:59:32.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.804]                   3L)]
[10:59:32.804]             }
[10:59:32.804]             function(cond) {
[10:59:32.804]                 is_error <- inherits(cond, "error")
[10:59:32.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.804]                   NULL)
[10:59:32.804]                 if (is_error) {
[10:59:32.804]                   sessionInformation <- function() {
[10:59:32.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.804]                       search = base::search(), system = base::Sys.info())
[10:59:32.804]                   }
[10:59:32.804]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.804]                     cond$call), session = sessionInformation(), 
[10:59:32.804]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.804]                   signalCondition(cond)
[10:59:32.804]                 }
[10:59:32.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.804]                 "immediateCondition"))) {
[10:59:32.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.804]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.804]                   if (TRUE && !signal) {
[10:59:32.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.804]                     {
[10:59:32.804]                       inherits <- base::inherits
[10:59:32.804]                       invokeRestart <- base::invokeRestart
[10:59:32.804]                       is.null <- base::is.null
[10:59:32.804]                       muffled <- FALSE
[10:59:32.804]                       if (inherits(cond, "message")) {
[10:59:32.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.804]                         if (muffled) 
[10:59:32.804]                           invokeRestart("muffleMessage")
[10:59:32.804]                       }
[10:59:32.804]                       else if (inherits(cond, "warning")) {
[10:59:32.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.804]                         if (muffled) 
[10:59:32.804]                           invokeRestart("muffleWarning")
[10:59:32.804]                       }
[10:59:32.804]                       else if (inherits(cond, "condition")) {
[10:59:32.804]                         if (!is.null(pattern)) {
[10:59:32.804]                           computeRestarts <- base::computeRestarts
[10:59:32.804]                           grepl <- base::grepl
[10:59:32.804]                           restarts <- computeRestarts(cond)
[10:59:32.804]                           for (restart in restarts) {
[10:59:32.804]                             name <- restart$name
[10:59:32.804]                             if (is.null(name)) 
[10:59:32.804]                               next
[10:59:32.804]                             if (!grepl(pattern, name)) 
[10:59:32.804]                               next
[10:59:32.804]                             invokeRestart(restart)
[10:59:32.804]                             muffled <- TRUE
[10:59:32.804]                             break
[10:59:32.804]                           }
[10:59:32.804]                         }
[10:59:32.804]                       }
[10:59:32.804]                       invisible(muffled)
[10:59:32.804]                     }
[10:59:32.804]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.804]                   }
[10:59:32.804]                 }
[10:59:32.804]                 else {
[10:59:32.804]                   if (TRUE) {
[10:59:32.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.804]                     {
[10:59:32.804]                       inherits <- base::inherits
[10:59:32.804]                       invokeRestart <- base::invokeRestart
[10:59:32.804]                       is.null <- base::is.null
[10:59:32.804]                       muffled <- FALSE
[10:59:32.804]                       if (inherits(cond, "message")) {
[10:59:32.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.804]                         if (muffled) 
[10:59:32.804]                           invokeRestart("muffleMessage")
[10:59:32.804]                       }
[10:59:32.804]                       else if (inherits(cond, "warning")) {
[10:59:32.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.804]                         if (muffled) 
[10:59:32.804]                           invokeRestart("muffleWarning")
[10:59:32.804]                       }
[10:59:32.804]                       else if (inherits(cond, "condition")) {
[10:59:32.804]                         if (!is.null(pattern)) {
[10:59:32.804]                           computeRestarts <- base::computeRestarts
[10:59:32.804]                           grepl <- base::grepl
[10:59:32.804]                           restarts <- computeRestarts(cond)
[10:59:32.804]                           for (restart in restarts) {
[10:59:32.804]                             name <- restart$name
[10:59:32.804]                             if (is.null(name)) 
[10:59:32.804]                               next
[10:59:32.804]                             if (!grepl(pattern, name)) 
[10:59:32.804]                               next
[10:59:32.804]                             invokeRestart(restart)
[10:59:32.804]                             muffled <- TRUE
[10:59:32.804]                             break
[10:59:32.804]                           }
[10:59:32.804]                         }
[10:59:32.804]                       }
[10:59:32.804]                       invisible(muffled)
[10:59:32.804]                     }
[10:59:32.804]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.804]                   }
[10:59:32.804]                 }
[10:59:32.804]             }
[10:59:32.804]         }))
[10:59:32.804]     }, error = function(ex) {
[10:59:32.804]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.804]                 ...future.rng), started = ...future.startTime, 
[10:59:32.804]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.804]             version = "1.8"), class = "FutureResult")
[10:59:32.804]     }, finally = {
[10:59:32.804]         if (!identical(...future.workdir, getwd())) 
[10:59:32.804]             setwd(...future.workdir)
[10:59:32.804]         {
[10:59:32.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.804]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.804]             }
[10:59:32.804]             base::options(...future.oldOptions)
[10:59:32.804]             if (.Platform$OS.type == "windows") {
[10:59:32.804]                 old_names <- names(...future.oldEnvVars)
[10:59:32.804]                 envs <- base::Sys.getenv()
[10:59:32.804]                 names <- names(envs)
[10:59:32.804]                 common <- intersect(names, old_names)
[10:59:32.804]                 added <- setdiff(names, old_names)
[10:59:32.804]                 removed <- setdiff(old_names, names)
[10:59:32.804]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.804]                   envs[common]]
[10:59:32.804]                 NAMES <- toupper(changed)
[10:59:32.804]                 args <- list()
[10:59:32.804]                 for (kk in seq_along(NAMES)) {
[10:59:32.804]                   name <- changed[[kk]]
[10:59:32.804]                   NAME <- NAMES[[kk]]
[10:59:32.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.804]                     next
[10:59:32.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.804]                 }
[10:59:32.804]                 NAMES <- toupper(added)
[10:59:32.804]                 for (kk in seq_along(NAMES)) {
[10:59:32.804]                   name <- added[[kk]]
[10:59:32.804]                   NAME <- NAMES[[kk]]
[10:59:32.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.804]                     next
[10:59:32.804]                   args[[name]] <- ""
[10:59:32.804]                 }
[10:59:32.804]                 NAMES <- toupper(removed)
[10:59:32.804]                 for (kk in seq_along(NAMES)) {
[10:59:32.804]                   name <- removed[[kk]]
[10:59:32.804]                   NAME <- NAMES[[kk]]
[10:59:32.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.804]                     next
[10:59:32.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.804]                 }
[10:59:32.804]                 if (length(args) > 0) 
[10:59:32.804]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.804]             }
[10:59:32.804]             else {
[10:59:32.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.804]             }
[10:59:32.804]             {
[10:59:32.804]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.804]                   0L) {
[10:59:32.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.804]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.804]                   base::options(opts)
[10:59:32.804]                 }
[10:59:32.804]                 {
[10:59:32.804]                   {
[10:59:32.804]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.804]                     NULL
[10:59:32.804]                   }
[10:59:32.804]                   options(future.plan = NULL)
[10:59:32.804]                   if (is.na(NA_character_)) 
[10:59:32.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.804]                     .init = FALSE)
[10:59:32.804]                 }
[10:59:32.804]             }
[10:59:32.804]         }
[10:59:32.804]     })
[10:59:32.804]     if (TRUE) {
[10:59:32.804]         base::sink(type = "output", split = FALSE)
[10:59:32.804]         if (TRUE) {
[10:59:32.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.804]         }
[10:59:32.804]         else {
[10:59:32.804]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.804]         }
[10:59:32.804]         base::close(...future.stdout)
[10:59:32.804]         ...future.stdout <- NULL
[10:59:32.804]     }
[10:59:32.804]     ...future.result$conditions <- ...future.conditions
[10:59:32.804]     ...future.result$finished <- base::Sys.time()
[10:59:32.804]     ...future.result
[10:59:32.804] }
[10:59:32.806] assign_globals() ...
[10:59:32.807] List of 5
[10:59:32.807]  $ ...future.FUN            :function (C, k)  
[10:59:32.807]  $ MoreArgs                 : NULL
[10:59:32.807]  $ ...future.elements_ii    :List of 2
[10:59:32.807]   ..$ :List of 2
[10:59:32.807]   .. ..$ : chr "D"
[10:59:32.807]   .. ..$ : chr "B"
[10:59:32.807]   ..$ :List of 2
[10:59:32.807]   .. ..$ : int 2
[10:59:32.807]   .. ..$ : int 4
[10:59:32.807]  $ ...future.seeds_ii       : NULL
[10:59:32.807]  $ ...future.globals.maxSize: NULL
[10:59:32.807]  - attr(*, "where")=List of 5
[10:59:32.807]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.807]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.807]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.807]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.807]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.807]  - attr(*, "resolved")= logi FALSE
[10:59:32.807]  - attr(*, "total_size")= num 876
[10:59:32.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.807]  - attr(*, "already-done")= logi TRUE
[10:59:32.813] - reassign environment for ‘...future.FUN’
[10:59:32.813] - copied ‘...future.FUN’ to environment
[10:59:32.813] - copied ‘MoreArgs’ to environment
[10:59:32.814] - copied ‘...future.elements_ii’ to environment
[10:59:32.814] - copied ‘...future.seeds_ii’ to environment
[10:59:32.814] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.814] assign_globals() ... done
[10:59:32.814] requestCore(): workers = 2
[10:59:32.814] Poll #1 (0): usedCores() = 2, workers = 2
[10:59:32.825] result() for MulticoreFuture ...
[10:59:32.825] result() for MulticoreFuture ...
[10:59:32.826] result() for MulticoreFuture ... done
[10:59:32.826] result() for MulticoreFuture ... done
[10:59:32.826] result() for MulticoreFuture ...
[10:59:32.826] result() for MulticoreFuture ... done
[10:59:32.828] MulticoreFuture started
[10:59:32.829] - Launch lazy future ... done
[10:59:32.829] run() for ‘MulticoreFuture’ ... done
[10:59:32.829] Created future:
[10:59:32.829] plan(): Setting new future strategy stack:
[10:59:32.830] List of future strategies:
[10:59:32.830] 1. sequential:
[10:59:32.830]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.830]    - tweaked: FALSE
[10:59:32.830]    - call: NULL
[10:59:32.831] plan(): nbrOfWorkers() = 1
[10:59:32.839] plan(): Setting new future strategy stack:
[10:59:32.839] List of future strategies:
[10:59:32.839] 1. multicore:
[10:59:32.839]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.839]    - tweaked: FALSE
[10:59:32.839]    - call: plan(strategy)
[10:59:32.843] plan(): nbrOfWorkers() = 2
[10:59:32.830] MulticoreFuture:
[10:59:32.830] Label: ‘future_mapply-3’
[10:59:32.830] Expression:
[10:59:32.830] {
[10:59:32.830]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.830]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.830]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.830]         on.exit(options(oopts), add = TRUE)
[10:59:32.830]     }
[10:59:32.830]     {
[10:59:32.830]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.830]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.830]         do.call(mapply, args = args)
[10:59:32.830]     }
[10:59:32.830] }
[10:59:32.830] Lazy evaluation: FALSE
[10:59:32.830] Asynchronous evaluation: TRUE
[10:59:32.830] Local evaluation: TRUE
[10:59:32.830] Environment: R_GlobalEnv
[10:59:32.830] Capture standard output: TRUE
[10:59:32.830] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.830] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.830] Packages: <none>
[10:59:32.830] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.830] Resolved: TRUE
[10:59:32.830] Value: <not collected>
[10:59:32.830] Conditions captured: <none>
[10:59:32.830] Early signaling: FALSE
[10:59:32.830] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.830] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.845] Chunk #3 of 3 ... DONE
[10:59:32.845] Launching 3 futures (chunks) ... DONE
[10:59:32.845] Resolving 3 futures (chunks) ...
[10:59:32.845] resolve() on list ...
[10:59:32.846]  recursive: 0
[10:59:32.846]  length: 3
[10:59:32.846] 
[10:59:32.846] Future #1
[10:59:32.846] result() for MulticoreFuture ...
[10:59:32.847] result() for MulticoreFuture ... done
[10:59:32.847] result() for MulticoreFuture ...
[10:59:32.847] result() for MulticoreFuture ... done
[10:59:32.847] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.847] - nx: 3
[10:59:32.848] - relay: TRUE
[10:59:32.848] - stdout: TRUE
[10:59:32.848] - signal: TRUE
[10:59:32.848] - resignal: FALSE
[10:59:32.848] - force: TRUE
[10:59:32.849] - relayed: [n=3] FALSE, FALSE, FALSE
[10:59:32.849] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:59:32.849]  - until=1
[10:59:32.849]  - relaying element #1
[10:59:32.849] result() for MulticoreFuture ...
[10:59:32.850] result() for MulticoreFuture ... done
[10:59:32.850] result() for MulticoreFuture ...
[10:59:32.850] result() for MulticoreFuture ... done
[10:59:32.850] result() for MulticoreFuture ...
[10:59:32.851] result() for MulticoreFuture ... done
[10:59:32.851] result() for MulticoreFuture ...
[10:59:32.851] result() for MulticoreFuture ... done
[10:59:32.851] - relayed: [n=3] TRUE, FALSE, FALSE
[10:59:32.851] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:59:32.851] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.852]  length: 2 (resolved future 1)
[10:59:32.852] Future #2
[10:59:32.852] result() for MulticoreFuture ...
[10:59:32.853] result() for MulticoreFuture ...
[10:59:32.854] result() for MulticoreFuture ... done
[10:59:32.854] result() for MulticoreFuture ... done
[10:59:32.854] result() for MulticoreFuture ...
[10:59:32.854] result() for MulticoreFuture ... done
[10:59:32.854] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.855] - nx: 3
[10:59:32.855] - relay: TRUE
[10:59:32.855] - stdout: TRUE
[10:59:32.855] - signal: TRUE
[10:59:32.855] - resignal: FALSE
[10:59:32.855] - force: TRUE
[10:59:32.855] - relayed: [n=3] TRUE, FALSE, FALSE
[10:59:32.856] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:59:32.856]  - until=2
[10:59:32.856]  - relaying element #2
[10:59:32.856] result() for MulticoreFuture ...
[10:59:32.856] result() for MulticoreFuture ... done
[10:59:32.856] result() for MulticoreFuture ...
[10:59:32.856] result() for MulticoreFuture ... done
[10:59:32.856] result() for MulticoreFuture ...
[10:59:32.857] result() for MulticoreFuture ... done
[10:59:32.857] result() for MulticoreFuture ...
[10:59:32.857] result() for MulticoreFuture ... done
[10:59:32.857] - relayed: [n=3] TRUE, TRUE, FALSE
[10:59:32.857] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:59:32.857] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.857]  length: 1 (resolved future 2)
[10:59:32.858] Future #3
[10:59:32.858] result() for MulticoreFuture ...
[10:59:32.859] result() for MulticoreFuture ...
[10:59:32.859] result() for MulticoreFuture ... done
[10:59:32.859] result() for MulticoreFuture ... done
[10:59:32.859] result() for MulticoreFuture ...
[10:59:32.859] result() for MulticoreFuture ... done
[10:59:32.859] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:59:32.860] - nx: 3
[10:59:32.860] - relay: TRUE
[10:59:32.860] - stdout: TRUE
[10:59:32.860] - signal: TRUE
[10:59:32.860] - resignal: FALSE
[10:59:32.860] - force: TRUE
[10:59:32.860] - relayed: [n=3] TRUE, TRUE, FALSE
[10:59:32.860] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:59:32.861]  - until=3
[10:59:32.861]  - relaying element #3
[10:59:32.861] result() for MulticoreFuture ...
[10:59:32.861] result() for MulticoreFuture ... done
[10:59:32.861] result() for MulticoreFuture ...
[10:59:32.861] result() for MulticoreFuture ... done
[10:59:32.862] result() for MulticoreFuture ...
[10:59:32.862] result() for MulticoreFuture ... done
[10:59:32.862] result() for MulticoreFuture ...
[10:59:32.862] result() for MulticoreFuture ... done
[10:59:32.862] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:32.862] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:59:32.862] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:59:32.863]  length: 0 (resolved future 3)
[10:59:32.863] Relaying remaining futures
[10:59:32.863] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.863] - nx: 3
[10:59:32.863] - relay: TRUE
[10:59:32.863] - stdout: TRUE
[10:59:32.863] - signal: TRUE
[10:59:32.863] - resignal: FALSE
[10:59:32.863] - force: TRUE
[10:59:32.863] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:32.864] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:59:32.864] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:32.864] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:59:32.864] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.864] resolve() on list ... DONE
[10:59:32.864] result() for MulticoreFuture ...
[10:59:32.864] result() for MulticoreFuture ... done
[10:59:32.864] result() for MulticoreFuture ...
[10:59:32.864] result() for MulticoreFuture ... done
[10:59:32.865] result() for MulticoreFuture ...
[10:59:32.865] result() for MulticoreFuture ... done
[10:59:32.865] result() for MulticoreFuture ...
[10:59:32.865] result() for MulticoreFuture ... done
[10:59:32.865] result() for MulticoreFuture ...
[10:59:32.865] result() for MulticoreFuture ... done
[10:59:32.865] result() for MulticoreFuture ...
[10:59:32.865] result() for MulticoreFuture ... done
[10:59:32.865]  - Number of value chunks collected: 3
[10:59:32.865] Resolving 3 futures (chunks) ... DONE
[10:59:32.865] Reducing values from 3 chunks ...
[10:59:32.866]  - Number of values collected after concatenation: 5
[10:59:32.866]  - Number of values expected: 5
[10:59:32.866] Reverse index remapping (attribute 'ordering'): [n = 5] 1, 5, 2, 4, 3
[10:59:32.866] Reducing values from 3 chunks ... DONE
[10:59:32.866] future_mapply() ... DONE
[10:59:32.866] future_mapply() ...
[10:59:32.868] Number of chunks: 2
[10:59:32.868] getGlobalsAndPackagesXApply() ...
[10:59:32.869]  - future.globals: TRUE
[10:59:32.869] getGlobalsAndPackages() ...
[10:59:32.869] Searching for globals...
[10:59:32.870] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:32.870] Searching for globals ... DONE
[10:59:32.870] Resolving globals: FALSE
[10:59:32.871] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:32.871] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:32.871] - globals: [1] ‘FUN’
[10:59:32.871] 
[10:59:32.872] getGlobalsAndPackages() ... DONE
[10:59:32.872]  - globals found/used: [n=1] ‘FUN’
[10:59:32.872]  - needed namespaces: [n=0] 
[10:59:32.872] Finding globals ... DONE
[10:59:32.872] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.874] List of 2
[10:59:32.874]  $ ...future.FUN:function (C, k)  
[10:59:32.874]  $ MoreArgs     : list()
[10:59:32.874]  - attr(*, "where")=List of 2
[10:59:32.874]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.874]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.874]  - attr(*, "resolved")= logi FALSE
[10:59:32.874]  - attr(*, "total_size")= num NA
[10:59:32.877] Packages to be attached in all futures: [n=0] 
[10:59:32.877] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.877] Number of futures (= number of chunks): 2
[10:59:32.877] Launching 2 futures (chunks) ...
[10:59:32.877] Chunk #1 of 2 ...
[10:59:32.877]  - Finding globals in '...' for chunk #1 ...
[10:59:32.878] getGlobalsAndPackages() ...
[10:59:32.878] Searching for globals...
[10:59:32.878] 
[10:59:32.878] Searching for globals ... DONE
[10:59:32.878] - globals: [0] <none>
[10:59:32.878] getGlobalsAndPackages() ... DONE
[10:59:32.878]    + additional globals found: [n=0] 
[10:59:32.878]    + additional namespaces needed: [n=0] 
[10:59:32.879]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.879]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.879]  - seeds: <none>
[10:59:32.879]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.879] getGlobalsAndPackages() ...
[10:59:32.879] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.879] Resolving globals: FALSE
[10:59:32.880] The total size of the 5 globals is 880 bytes (880 bytes)
[10:59:32.880] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:32.880] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.880] 
[10:59:32.880] getGlobalsAndPackages() ... DONE
[10:59:32.881] run() for ‘Future’ ...
[10:59:32.881] - state: ‘created’
[10:59:32.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.883]   - Field: ‘label’
[10:59:32.883]   - Field: ‘local’
[10:59:32.883]   - Field: ‘owner’
[10:59:32.883]   - Field: ‘envir’
[10:59:32.883]   - Field: ‘workers’
[10:59:32.883]   - Field: ‘packages’
[10:59:32.883]   - Field: ‘gc’
[10:59:32.883]   - Field: ‘job’
[10:59:32.883]   - Field: ‘conditions’
[10:59:32.883]   - Field: ‘expr’
[10:59:32.884]   - Field: ‘uuid’
[10:59:32.884]   - Field: ‘seed’
[10:59:32.884]   - Field: ‘version’
[10:59:32.884]   - Field: ‘result’
[10:59:32.884]   - Field: ‘asynchronous’
[10:59:32.884]   - Field: ‘calls’
[10:59:32.884]   - Field: ‘globals’
[10:59:32.884]   - Field: ‘stdout’
[10:59:32.884]   - Field: ‘earlySignal’
[10:59:32.884]   - Field: ‘lazy’
[10:59:32.884]   - Field: ‘state’
[10:59:32.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.885] - Launch lazy future ...
[10:59:32.885] Packages needed by the future expression (n = 0): <none>
[10:59:32.885] Packages needed by future strategies (n = 0): <none>
[10:59:32.885] {
[10:59:32.885]     {
[10:59:32.885]         {
[10:59:32.885]             ...future.startTime <- base::Sys.time()
[10:59:32.885]             {
[10:59:32.885]                 {
[10:59:32.885]                   {
[10:59:32.885]                     {
[10:59:32.885]                       base::local({
[10:59:32.885]                         has_future <- base::requireNamespace("future", 
[10:59:32.885]                           quietly = TRUE)
[10:59:32.885]                         if (has_future) {
[10:59:32.885]                           ns <- base::getNamespace("future")
[10:59:32.885]                           version <- ns[[".package"]][["version"]]
[10:59:32.885]                           if (is.null(version)) 
[10:59:32.885]                             version <- utils::packageVersion("future")
[10:59:32.885]                         }
[10:59:32.885]                         else {
[10:59:32.885]                           version <- NULL
[10:59:32.885]                         }
[10:59:32.885]                         if (!has_future || version < "1.8.0") {
[10:59:32.885]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.885]                             "", base::R.version$version.string), 
[10:59:32.885]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.885]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.885]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.885]                               "release", "version")], collapse = " "), 
[10:59:32.885]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.885]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.885]                             info)
[10:59:32.885]                           info <- base::paste(info, collapse = "; ")
[10:59:32.885]                           if (!has_future) {
[10:59:32.885]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.885]                               info)
[10:59:32.885]                           }
[10:59:32.885]                           else {
[10:59:32.885]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.885]                               info, version)
[10:59:32.885]                           }
[10:59:32.885]                           base::stop(msg)
[10:59:32.885]                         }
[10:59:32.885]                       })
[10:59:32.885]                     }
[10:59:32.885]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.885]                     base::options(mc.cores = 1L)
[10:59:32.885]                   }
[10:59:32.885]                   ...future.strategy.old <- future::plan("list")
[10:59:32.885]                   options(future.plan = NULL)
[10:59:32.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.885]                 }
[10:59:32.885]                 ...future.workdir <- getwd()
[10:59:32.885]             }
[10:59:32.885]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.885]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.885]         }
[10:59:32.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.885]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.885]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.885]             base::names(...future.oldOptions))
[10:59:32.885]     }
[10:59:32.885]     if (FALSE) {
[10:59:32.885]     }
[10:59:32.885]     else {
[10:59:32.885]         if (TRUE) {
[10:59:32.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.885]                 open = "w")
[10:59:32.885]         }
[10:59:32.885]         else {
[10:59:32.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.885]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.885]         }
[10:59:32.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.885]             base::sink(type = "output", split = FALSE)
[10:59:32.885]             base::close(...future.stdout)
[10:59:32.885]         }, add = TRUE)
[10:59:32.885]     }
[10:59:32.885]     ...future.frame <- base::sys.nframe()
[10:59:32.885]     ...future.conditions <- base::list()
[10:59:32.885]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.885]     if (FALSE) {
[10:59:32.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.885]     }
[10:59:32.885]     ...future.result <- base::tryCatch({
[10:59:32.885]         base::withCallingHandlers({
[10:59:32.885]             ...future.value <- base::withVisible(base::local({
[10:59:32.885]                 withCallingHandlers({
[10:59:32.885]                   {
[10:59:32.885]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.885]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.885]                       ...future.globals.maxSize)) {
[10:59:32.885]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.885]                       on.exit(options(oopts), add = TRUE)
[10:59:32.885]                     }
[10:59:32.885]                     {
[10:59:32.885]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.885]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.885]                         USE.NAMES = FALSE)
[10:59:32.885]                       do.call(mapply, args = args)
[10:59:32.885]                     }
[10:59:32.885]                   }
[10:59:32.885]                 }, immediateCondition = function(cond) {
[10:59:32.885]                   save_rds <- function (object, pathname, ...) 
[10:59:32.885]                   {
[10:59:32.885]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.885]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.885]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.885]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.885]                         fi_tmp[["mtime"]])
[10:59:32.885]                     }
[10:59:32.885]                     tryCatch({
[10:59:32.885]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.885]                     }, error = function(ex) {
[10:59:32.885]                       msg <- conditionMessage(ex)
[10:59:32.885]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.885]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.885]                         fi_tmp[["mtime"]], msg)
[10:59:32.885]                       ex$message <- msg
[10:59:32.885]                       stop(ex)
[10:59:32.885]                     })
[10:59:32.885]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.885]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.885]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.885]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.885]                       fi <- file.info(pathname)
[10:59:32.885]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.885]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.885]                         fi[["size"]], fi[["mtime"]])
[10:59:32.885]                       stop(msg)
[10:59:32.885]                     }
[10:59:32.885]                     invisible(pathname)
[10:59:32.885]                   }
[10:59:32.885]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.885]                     rootPath = tempdir()) 
[10:59:32.885]                   {
[10:59:32.885]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.885]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.885]                       tmpdir = path, fileext = ".rds")
[10:59:32.885]                     save_rds(obj, file)
[10:59:32.885]                   }
[10:59:32.885]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.885]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.885]                   {
[10:59:32.885]                     inherits <- base::inherits
[10:59:32.885]                     invokeRestart <- base::invokeRestart
[10:59:32.885]                     is.null <- base::is.null
[10:59:32.885]                     muffled <- FALSE
[10:59:32.885]                     if (inherits(cond, "message")) {
[10:59:32.885]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.885]                       if (muffled) 
[10:59:32.885]                         invokeRestart("muffleMessage")
[10:59:32.885]                     }
[10:59:32.885]                     else if (inherits(cond, "warning")) {
[10:59:32.885]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.885]                       if (muffled) 
[10:59:32.885]                         invokeRestart("muffleWarning")
[10:59:32.885]                     }
[10:59:32.885]                     else if (inherits(cond, "condition")) {
[10:59:32.885]                       if (!is.null(pattern)) {
[10:59:32.885]                         computeRestarts <- base::computeRestarts
[10:59:32.885]                         grepl <- base::grepl
[10:59:32.885]                         restarts <- computeRestarts(cond)
[10:59:32.885]                         for (restart in restarts) {
[10:59:32.885]                           name <- restart$name
[10:59:32.885]                           if (is.null(name)) 
[10:59:32.885]                             next
[10:59:32.885]                           if (!grepl(pattern, name)) 
[10:59:32.885]                             next
[10:59:32.885]                           invokeRestart(restart)
[10:59:32.885]                           muffled <- TRUE
[10:59:32.885]                           break
[10:59:32.885]                         }
[10:59:32.885]                       }
[10:59:32.885]                     }
[10:59:32.885]                     invisible(muffled)
[10:59:32.885]                   }
[10:59:32.885]                   muffleCondition(cond)
[10:59:32.885]                 })
[10:59:32.885]             }))
[10:59:32.885]             future::FutureResult(value = ...future.value$value, 
[10:59:32.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.885]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.885]                     ...future.globalenv.names))
[10:59:32.885]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.885]         }, condition = base::local({
[10:59:32.885]             c <- base::c
[10:59:32.885]             inherits <- base::inherits
[10:59:32.885]             invokeRestart <- base::invokeRestart
[10:59:32.885]             length <- base::length
[10:59:32.885]             list <- base::list
[10:59:32.885]             seq.int <- base::seq.int
[10:59:32.885]             signalCondition <- base::signalCondition
[10:59:32.885]             sys.calls <- base::sys.calls
[10:59:32.885]             `[[` <- base::`[[`
[10:59:32.885]             `+` <- base::`+`
[10:59:32.885]             `<<-` <- base::`<<-`
[10:59:32.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.885]                   3L)]
[10:59:32.885]             }
[10:59:32.885]             function(cond) {
[10:59:32.885]                 is_error <- inherits(cond, "error")
[10:59:32.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.885]                   NULL)
[10:59:32.885]                 if (is_error) {
[10:59:32.885]                   sessionInformation <- function() {
[10:59:32.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.885]                       search = base::search(), system = base::Sys.info())
[10:59:32.885]                   }
[10:59:32.885]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.885]                     cond$call), session = sessionInformation(), 
[10:59:32.885]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.885]                   signalCondition(cond)
[10:59:32.885]                 }
[10:59:32.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.885]                 "immediateCondition"))) {
[10:59:32.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.885]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.885]                   if (TRUE && !signal) {
[10:59:32.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.885]                     {
[10:59:32.885]                       inherits <- base::inherits
[10:59:32.885]                       invokeRestart <- base::invokeRestart
[10:59:32.885]                       is.null <- base::is.null
[10:59:32.885]                       muffled <- FALSE
[10:59:32.885]                       if (inherits(cond, "message")) {
[10:59:32.885]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.885]                         if (muffled) 
[10:59:32.885]                           invokeRestart("muffleMessage")
[10:59:32.885]                       }
[10:59:32.885]                       else if (inherits(cond, "warning")) {
[10:59:32.885]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.885]                         if (muffled) 
[10:59:32.885]                           invokeRestart("muffleWarning")
[10:59:32.885]                       }
[10:59:32.885]                       else if (inherits(cond, "condition")) {
[10:59:32.885]                         if (!is.null(pattern)) {
[10:59:32.885]                           computeRestarts <- base::computeRestarts
[10:59:32.885]                           grepl <- base::grepl
[10:59:32.885]                           restarts <- computeRestarts(cond)
[10:59:32.885]                           for (restart in restarts) {
[10:59:32.885]                             name <- restart$name
[10:59:32.885]                             if (is.null(name)) 
[10:59:32.885]                               next
[10:59:32.885]                             if (!grepl(pattern, name)) 
[10:59:32.885]                               next
[10:59:32.885]                             invokeRestart(restart)
[10:59:32.885]                             muffled <- TRUE
[10:59:32.885]                             break
[10:59:32.885]                           }
[10:59:32.885]                         }
[10:59:32.885]                       }
[10:59:32.885]                       invisible(muffled)
[10:59:32.885]                     }
[10:59:32.885]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.885]                   }
[10:59:32.885]                 }
[10:59:32.885]                 else {
[10:59:32.885]                   if (TRUE) {
[10:59:32.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.885]                     {
[10:59:32.885]                       inherits <- base::inherits
[10:59:32.885]                       invokeRestart <- base::invokeRestart
[10:59:32.885]                       is.null <- base::is.null
[10:59:32.885]                       muffled <- FALSE
[10:59:32.885]                       if (inherits(cond, "message")) {
[10:59:32.885]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.885]                         if (muffled) 
[10:59:32.885]                           invokeRestart("muffleMessage")
[10:59:32.885]                       }
[10:59:32.885]                       else if (inherits(cond, "warning")) {
[10:59:32.885]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.885]                         if (muffled) 
[10:59:32.885]                           invokeRestart("muffleWarning")
[10:59:32.885]                       }
[10:59:32.885]                       else if (inherits(cond, "condition")) {
[10:59:32.885]                         if (!is.null(pattern)) {
[10:59:32.885]                           computeRestarts <- base::computeRestarts
[10:59:32.885]                           grepl <- base::grepl
[10:59:32.885]                           restarts <- computeRestarts(cond)
[10:59:32.885]                           for (restart in restarts) {
[10:59:32.885]                             name <- restart$name
[10:59:32.885]                             if (is.null(name)) 
[10:59:32.885]                               next
[10:59:32.885]                             if (!grepl(pattern, name)) 
[10:59:32.885]                               next
[10:59:32.885]                             invokeRestart(restart)
[10:59:32.885]                             muffled <- TRUE
[10:59:32.885]                             break
[10:59:32.885]                           }
[10:59:32.885]                         }
[10:59:32.885]                       }
[10:59:32.885]                       invisible(muffled)
[10:59:32.885]                     }
[10:59:32.885]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.885]                   }
[10:59:32.885]                 }
[10:59:32.885]             }
[10:59:32.885]         }))
[10:59:32.885]     }, error = function(ex) {
[10:59:32.885]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.885]                 ...future.rng), started = ...future.startTime, 
[10:59:32.885]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.885]             version = "1.8"), class = "FutureResult")
[10:59:32.885]     }, finally = {
[10:59:32.885]         if (!identical(...future.workdir, getwd())) 
[10:59:32.885]             setwd(...future.workdir)
[10:59:32.885]         {
[10:59:32.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.885]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.885]             }
[10:59:32.885]             base::options(...future.oldOptions)
[10:59:32.885]             if (.Platform$OS.type == "windows") {
[10:59:32.885]                 old_names <- names(...future.oldEnvVars)
[10:59:32.885]                 envs <- base::Sys.getenv()
[10:59:32.885]                 names <- names(envs)
[10:59:32.885]                 common <- intersect(names, old_names)
[10:59:32.885]                 added <- setdiff(names, old_names)
[10:59:32.885]                 removed <- setdiff(old_names, names)
[10:59:32.885]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.885]                   envs[common]]
[10:59:32.885]                 NAMES <- toupper(changed)
[10:59:32.885]                 args <- list()
[10:59:32.885]                 for (kk in seq_along(NAMES)) {
[10:59:32.885]                   name <- changed[[kk]]
[10:59:32.885]                   NAME <- NAMES[[kk]]
[10:59:32.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.885]                     next
[10:59:32.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.885]                 }
[10:59:32.885]                 NAMES <- toupper(added)
[10:59:32.885]                 for (kk in seq_along(NAMES)) {
[10:59:32.885]                   name <- added[[kk]]
[10:59:32.885]                   NAME <- NAMES[[kk]]
[10:59:32.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.885]                     next
[10:59:32.885]                   args[[name]] <- ""
[10:59:32.885]                 }
[10:59:32.885]                 NAMES <- toupper(removed)
[10:59:32.885]                 for (kk in seq_along(NAMES)) {
[10:59:32.885]                   name <- removed[[kk]]
[10:59:32.885]                   NAME <- NAMES[[kk]]
[10:59:32.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.885]                     next
[10:59:32.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.885]                 }
[10:59:32.885]                 if (length(args) > 0) 
[10:59:32.885]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.885]             }
[10:59:32.885]             else {
[10:59:32.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.885]             }
[10:59:32.885]             {
[10:59:32.885]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.885]                   0L) {
[10:59:32.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.885]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.885]                   base::options(opts)
[10:59:32.885]                 }
[10:59:32.885]                 {
[10:59:32.885]                   {
[10:59:32.885]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.885]                     NULL
[10:59:32.885]                   }
[10:59:32.885]                   options(future.plan = NULL)
[10:59:32.885]                   if (is.na(NA_character_)) 
[10:59:32.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.885]                     .init = FALSE)
[10:59:32.885]                 }
[10:59:32.885]             }
[10:59:32.885]         }
[10:59:32.885]     })
[10:59:32.885]     if (TRUE) {
[10:59:32.885]         base::sink(type = "output", split = FALSE)
[10:59:32.885]         if (TRUE) {
[10:59:32.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.885]         }
[10:59:32.885]         else {
[10:59:32.885]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.885]         }
[10:59:32.885]         base::close(...future.stdout)
[10:59:32.885]         ...future.stdout <- NULL
[10:59:32.885]     }
[10:59:32.885]     ...future.result$conditions <- ...future.conditions
[10:59:32.885]     ...future.result$finished <- base::Sys.time()
[10:59:32.885]     ...future.result
[10:59:32.885] }
[10:59:32.888] assign_globals() ...
[10:59:32.888] List of 5
[10:59:32.888]  $ ...future.FUN            :function (C, k)  
[10:59:32.888]  $ MoreArgs                 : list()
[10:59:32.888]  $ ...future.elements_ii    :List of 2
[10:59:32.888]   ..$ :List of 2
[10:59:32.888]   .. ..$ : chr "A"
[10:59:32.888]   .. ..$ : chr "B"
[10:59:32.888]   ..$ :List of 2
[10:59:32.888]   .. ..$ : int 5
[10:59:32.888]   .. ..$ : int 4
[10:59:32.888]  $ ...future.seeds_ii       : NULL
[10:59:32.888]  $ ...future.globals.maxSize: NULL
[10:59:32.888]  - attr(*, "where")=List of 5
[10:59:32.888]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.888]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.888]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.888]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.888]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.888]  - attr(*, "resolved")= logi FALSE
[10:59:32.888]  - attr(*, "total_size")= num 880
[10:59:32.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.888]  - attr(*, "already-done")= logi TRUE
[10:59:32.893] - reassign environment for ‘...future.FUN’
[10:59:32.893] - copied ‘...future.FUN’ to environment
[10:59:32.893] - copied ‘MoreArgs’ to environment
[10:59:32.893] - copied ‘...future.elements_ii’ to environment
[10:59:32.893] - copied ‘...future.seeds_ii’ to environment
[10:59:32.894] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.894] assign_globals() ... done
[10:59:32.894] requestCore(): workers = 2
[10:59:32.897] MulticoreFuture started
[10:59:32.898] - Launch lazy future ... done
[10:59:32.899] plan(): Setting new future strategy stack:
[10:59:32.898] run() for ‘MulticoreFuture’ ... done
[10:59:32.899] Created future:
[10:59:32.899] List of future strategies:
[10:59:32.899] 1. sequential:
[10:59:32.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.899]    - tweaked: FALSE
[10:59:32.899]    - call: NULL
[10:59:32.901] plan(): nbrOfWorkers() = 1
[10:59:32.904] plan(): Setting new future strategy stack:
[10:59:32.904] List of future strategies:
[10:59:32.904] 1. multicore:
[10:59:32.904]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.904]    - tweaked: FALSE
[10:59:32.904]    - call: plan(strategy)
[10:59:32.908] plan(): nbrOfWorkers() = 2
[10:59:32.900] MulticoreFuture:
[10:59:32.900] Label: ‘future_.mapply-1’
[10:59:32.900] Expression:
[10:59:32.900] {
[10:59:32.900]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.900]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.900]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.900]         on.exit(options(oopts), add = TRUE)
[10:59:32.900]     }
[10:59:32.900]     {
[10:59:32.900]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.900]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.900]         do.call(mapply, args = args)
[10:59:32.900]     }
[10:59:32.900] }
[10:59:32.900] Lazy evaluation: FALSE
[10:59:32.900] Asynchronous evaluation: TRUE
[10:59:32.900] Local evaluation: TRUE
[10:59:32.900] Environment: R_GlobalEnv
[10:59:32.900] Capture standard output: TRUE
[10:59:32.900] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.900] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.900] Packages: <none>
[10:59:32.900] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.900] Resolved: TRUE
[10:59:32.900] Value: <not collected>
[10:59:32.900] Conditions captured: <none>
[10:59:32.900] Early signaling: FALSE
[10:59:32.900] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.900] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.909] Chunk #1 of 2 ... DONE
[10:59:32.910] Chunk #2 of 2 ...
[10:59:32.910]  - Finding globals in '...' for chunk #2 ...
[10:59:32.910] getGlobalsAndPackages() ...
[10:59:32.910] Searching for globals...
[10:59:32.911] 
[10:59:32.911] Searching for globals ... DONE
[10:59:32.911] - globals: [0] <none>
[10:59:32.912] getGlobalsAndPackages() ... DONE
[10:59:32.912]    + additional globals found: [n=0] 
[10:59:32.912]    + additional namespaces needed: [n=0] 
[10:59:32.912]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:32.912]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.912]  - seeds: <none>
[10:59:32.913]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.913] getGlobalsAndPackages() ...
[10:59:32.913] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.913] Resolving globals: FALSE
[10:59:32.914] The total size of the 5 globals is 909 bytes (909 bytes)
[10:59:32.915] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:32.915] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.916] 
[10:59:32.916] getGlobalsAndPackages() ... DONE
[10:59:32.916] run() for ‘Future’ ...
[10:59:32.917] - state: ‘created’
[10:59:32.917] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.920] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.920]   - Field: ‘label’
[10:59:32.920]   - Field: ‘local’
[10:59:32.920]   - Field: ‘owner’
[10:59:32.920]   - Field: ‘envir’
[10:59:32.920]   - Field: ‘workers’
[10:59:32.921]   - Field: ‘packages’
[10:59:32.921]   - Field: ‘gc’
[10:59:32.921]   - Field: ‘job’
[10:59:32.921]   - Field: ‘conditions’
[10:59:32.921]   - Field: ‘expr’
[10:59:32.921]   - Field: ‘uuid’
[10:59:32.921]   - Field: ‘seed’
[10:59:32.922]   - Field: ‘version’
[10:59:32.922]   - Field: ‘result’
[10:59:32.922]   - Field: ‘asynchronous’
[10:59:32.922]   - Field: ‘calls’
[10:59:32.922]   - Field: ‘globals’
[10:59:32.922]   - Field: ‘stdout’
[10:59:32.922]   - Field: ‘earlySignal’
[10:59:32.922]   - Field: ‘lazy’
[10:59:32.923]   - Field: ‘state’
[10:59:32.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.923] - Launch lazy future ...
[10:59:32.923] Packages needed by the future expression (n = 0): <none>
[10:59:32.923] Packages needed by future strategies (n = 0): <none>
[10:59:32.924] {
[10:59:32.924]     {
[10:59:32.924]         {
[10:59:32.924]             ...future.startTime <- base::Sys.time()
[10:59:32.924]             {
[10:59:32.924]                 {
[10:59:32.924]                   {
[10:59:32.924]                     {
[10:59:32.924]                       base::local({
[10:59:32.924]                         has_future <- base::requireNamespace("future", 
[10:59:32.924]                           quietly = TRUE)
[10:59:32.924]                         if (has_future) {
[10:59:32.924]                           ns <- base::getNamespace("future")
[10:59:32.924]                           version <- ns[[".package"]][["version"]]
[10:59:32.924]                           if (is.null(version)) 
[10:59:32.924]                             version <- utils::packageVersion("future")
[10:59:32.924]                         }
[10:59:32.924]                         else {
[10:59:32.924]                           version <- NULL
[10:59:32.924]                         }
[10:59:32.924]                         if (!has_future || version < "1.8.0") {
[10:59:32.924]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.924]                             "", base::R.version$version.string), 
[10:59:32.924]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.924]                               "release", "version")], collapse = " "), 
[10:59:32.924]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.924]                             info)
[10:59:32.924]                           info <- base::paste(info, collapse = "; ")
[10:59:32.924]                           if (!has_future) {
[10:59:32.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.924]                               info)
[10:59:32.924]                           }
[10:59:32.924]                           else {
[10:59:32.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.924]                               info, version)
[10:59:32.924]                           }
[10:59:32.924]                           base::stop(msg)
[10:59:32.924]                         }
[10:59:32.924]                       })
[10:59:32.924]                     }
[10:59:32.924]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.924]                     base::options(mc.cores = 1L)
[10:59:32.924]                   }
[10:59:32.924]                   ...future.strategy.old <- future::plan("list")
[10:59:32.924]                   options(future.plan = NULL)
[10:59:32.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.924]                 }
[10:59:32.924]                 ...future.workdir <- getwd()
[10:59:32.924]             }
[10:59:32.924]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.924]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.924]         }
[10:59:32.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.924]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.924]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.924]             base::names(...future.oldOptions))
[10:59:32.924]     }
[10:59:32.924]     if (FALSE) {
[10:59:32.924]     }
[10:59:32.924]     else {
[10:59:32.924]         if (TRUE) {
[10:59:32.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.924]                 open = "w")
[10:59:32.924]         }
[10:59:32.924]         else {
[10:59:32.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.924]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.924]         }
[10:59:32.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.924]             base::sink(type = "output", split = FALSE)
[10:59:32.924]             base::close(...future.stdout)
[10:59:32.924]         }, add = TRUE)
[10:59:32.924]     }
[10:59:32.924]     ...future.frame <- base::sys.nframe()
[10:59:32.924]     ...future.conditions <- base::list()
[10:59:32.924]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.924]     if (FALSE) {
[10:59:32.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.924]     }
[10:59:32.924]     ...future.result <- base::tryCatch({
[10:59:32.924]         base::withCallingHandlers({
[10:59:32.924]             ...future.value <- base::withVisible(base::local({
[10:59:32.924]                 withCallingHandlers({
[10:59:32.924]                   {
[10:59:32.924]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.924]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.924]                       ...future.globals.maxSize)) {
[10:59:32.924]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.924]                       on.exit(options(oopts), add = TRUE)
[10:59:32.924]                     }
[10:59:32.924]                     {
[10:59:32.924]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.924]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.924]                         USE.NAMES = FALSE)
[10:59:32.924]                       do.call(mapply, args = args)
[10:59:32.924]                     }
[10:59:32.924]                   }
[10:59:32.924]                 }, immediateCondition = function(cond) {
[10:59:32.924]                   save_rds <- function (object, pathname, ...) 
[10:59:32.924]                   {
[10:59:32.924]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.924]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.924]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.924]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.924]                         fi_tmp[["mtime"]])
[10:59:32.924]                     }
[10:59:32.924]                     tryCatch({
[10:59:32.924]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.924]                     }, error = function(ex) {
[10:59:32.924]                       msg <- conditionMessage(ex)
[10:59:32.924]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.924]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.924]                         fi_tmp[["mtime"]], msg)
[10:59:32.924]                       ex$message <- msg
[10:59:32.924]                       stop(ex)
[10:59:32.924]                     })
[10:59:32.924]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.924]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.924]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.924]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.924]                       fi <- file.info(pathname)
[10:59:32.924]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.924]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.924]                         fi[["size"]], fi[["mtime"]])
[10:59:32.924]                       stop(msg)
[10:59:32.924]                     }
[10:59:32.924]                     invisible(pathname)
[10:59:32.924]                   }
[10:59:32.924]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.924]                     rootPath = tempdir()) 
[10:59:32.924]                   {
[10:59:32.924]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.924]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.924]                       tmpdir = path, fileext = ".rds")
[10:59:32.924]                     save_rds(obj, file)
[10:59:32.924]                   }
[10:59:32.924]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.924]                   {
[10:59:32.924]                     inherits <- base::inherits
[10:59:32.924]                     invokeRestart <- base::invokeRestart
[10:59:32.924]                     is.null <- base::is.null
[10:59:32.924]                     muffled <- FALSE
[10:59:32.924]                     if (inherits(cond, "message")) {
[10:59:32.924]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.924]                       if (muffled) 
[10:59:32.924]                         invokeRestart("muffleMessage")
[10:59:32.924]                     }
[10:59:32.924]                     else if (inherits(cond, "warning")) {
[10:59:32.924]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.924]                       if (muffled) 
[10:59:32.924]                         invokeRestart("muffleWarning")
[10:59:32.924]                     }
[10:59:32.924]                     else if (inherits(cond, "condition")) {
[10:59:32.924]                       if (!is.null(pattern)) {
[10:59:32.924]                         computeRestarts <- base::computeRestarts
[10:59:32.924]                         grepl <- base::grepl
[10:59:32.924]                         restarts <- computeRestarts(cond)
[10:59:32.924]                         for (restart in restarts) {
[10:59:32.924]                           name <- restart$name
[10:59:32.924]                           if (is.null(name)) 
[10:59:32.924]                             next
[10:59:32.924]                           if (!grepl(pattern, name)) 
[10:59:32.924]                             next
[10:59:32.924]                           invokeRestart(restart)
[10:59:32.924]                           muffled <- TRUE
[10:59:32.924]                           break
[10:59:32.924]                         }
[10:59:32.924]                       }
[10:59:32.924]                     }
[10:59:32.924]                     invisible(muffled)
[10:59:32.924]                   }
[10:59:32.924]                   muffleCondition(cond)
[10:59:32.924]                 })
[10:59:32.924]             }))
[10:59:32.924]             future::FutureResult(value = ...future.value$value, 
[10:59:32.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.924]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.924]                     ...future.globalenv.names))
[10:59:32.924]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.924]         }, condition = base::local({
[10:59:32.924]             c <- base::c
[10:59:32.924]             inherits <- base::inherits
[10:59:32.924]             invokeRestart <- base::invokeRestart
[10:59:32.924]             length <- base::length
[10:59:32.924]             list <- base::list
[10:59:32.924]             seq.int <- base::seq.int
[10:59:32.924]             signalCondition <- base::signalCondition
[10:59:32.924]             sys.calls <- base::sys.calls
[10:59:32.924]             `[[` <- base::`[[`
[10:59:32.924]             `+` <- base::`+`
[10:59:32.924]             `<<-` <- base::`<<-`
[10:59:32.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.924]                   3L)]
[10:59:32.924]             }
[10:59:32.924]             function(cond) {
[10:59:32.924]                 is_error <- inherits(cond, "error")
[10:59:32.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.924]                   NULL)
[10:59:32.924]                 if (is_error) {
[10:59:32.924]                   sessionInformation <- function() {
[10:59:32.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.924]                       search = base::search(), system = base::Sys.info())
[10:59:32.924]                   }
[10:59:32.924]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.924]                     cond$call), session = sessionInformation(), 
[10:59:32.924]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.924]                   signalCondition(cond)
[10:59:32.924]                 }
[10:59:32.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.924]                 "immediateCondition"))) {
[10:59:32.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.924]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.924]                   if (TRUE && !signal) {
[10:59:32.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.924]                     {
[10:59:32.924]                       inherits <- base::inherits
[10:59:32.924]                       invokeRestart <- base::invokeRestart
[10:59:32.924]                       is.null <- base::is.null
[10:59:32.924]                       muffled <- FALSE
[10:59:32.924]                       if (inherits(cond, "message")) {
[10:59:32.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.924]                         if (muffled) 
[10:59:32.924]                           invokeRestart("muffleMessage")
[10:59:32.924]                       }
[10:59:32.924]                       else if (inherits(cond, "warning")) {
[10:59:32.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.924]                         if (muffled) 
[10:59:32.924]                           invokeRestart("muffleWarning")
[10:59:32.924]                       }
[10:59:32.924]                       else if (inherits(cond, "condition")) {
[10:59:32.924]                         if (!is.null(pattern)) {
[10:59:32.924]                           computeRestarts <- base::computeRestarts
[10:59:32.924]                           grepl <- base::grepl
[10:59:32.924]                           restarts <- computeRestarts(cond)
[10:59:32.924]                           for (restart in restarts) {
[10:59:32.924]                             name <- restart$name
[10:59:32.924]                             if (is.null(name)) 
[10:59:32.924]                               next
[10:59:32.924]                             if (!grepl(pattern, name)) 
[10:59:32.924]                               next
[10:59:32.924]                             invokeRestart(restart)
[10:59:32.924]                             muffled <- TRUE
[10:59:32.924]                             break
[10:59:32.924]                           }
[10:59:32.924]                         }
[10:59:32.924]                       }
[10:59:32.924]                       invisible(muffled)
[10:59:32.924]                     }
[10:59:32.924]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.924]                   }
[10:59:32.924]                 }
[10:59:32.924]                 else {
[10:59:32.924]                   if (TRUE) {
[10:59:32.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.924]                     {
[10:59:32.924]                       inherits <- base::inherits
[10:59:32.924]                       invokeRestart <- base::invokeRestart
[10:59:32.924]                       is.null <- base::is.null
[10:59:32.924]                       muffled <- FALSE
[10:59:32.924]                       if (inherits(cond, "message")) {
[10:59:32.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.924]                         if (muffled) 
[10:59:32.924]                           invokeRestart("muffleMessage")
[10:59:32.924]                       }
[10:59:32.924]                       else if (inherits(cond, "warning")) {
[10:59:32.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.924]                         if (muffled) 
[10:59:32.924]                           invokeRestart("muffleWarning")
[10:59:32.924]                       }
[10:59:32.924]                       else if (inherits(cond, "condition")) {
[10:59:32.924]                         if (!is.null(pattern)) {
[10:59:32.924]                           computeRestarts <- base::computeRestarts
[10:59:32.924]                           grepl <- base::grepl
[10:59:32.924]                           restarts <- computeRestarts(cond)
[10:59:32.924]                           for (restart in restarts) {
[10:59:32.924]                             name <- restart$name
[10:59:32.924]                             if (is.null(name)) 
[10:59:32.924]                               next
[10:59:32.924]                             if (!grepl(pattern, name)) 
[10:59:32.924]                               next
[10:59:32.924]                             invokeRestart(restart)
[10:59:32.924]                             muffled <- TRUE
[10:59:32.924]                             break
[10:59:32.924]                           }
[10:59:32.924]                         }
[10:59:32.924]                       }
[10:59:32.924]                       invisible(muffled)
[10:59:32.924]                     }
[10:59:32.924]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.924]                   }
[10:59:32.924]                 }
[10:59:32.924]             }
[10:59:32.924]         }))
[10:59:32.924]     }, error = function(ex) {
[10:59:32.924]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.924]                 ...future.rng), started = ...future.startTime, 
[10:59:32.924]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.924]             version = "1.8"), class = "FutureResult")
[10:59:32.924]     }, finally = {
[10:59:32.924]         if (!identical(...future.workdir, getwd())) 
[10:59:32.924]             setwd(...future.workdir)
[10:59:32.924]         {
[10:59:32.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.924]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.924]             }
[10:59:32.924]             base::options(...future.oldOptions)
[10:59:32.924]             if (.Platform$OS.type == "windows") {
[10:59:32.924]                 old_names <- names(...future.oldEnvVars)
[10:59:32.924]                 envs <- base::Sys.getenv()
[10:59:32.924]                 names <- names(envs)
[10:59:32.924]                 common <- intersect(names, old_names)
[10:59:32.924]                 added <- setdiff(names, old_names)
[10:59:32.924]                 removed <- setdiff(old_names, names)
[10:59:32.924]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.924]                   envs[common]]
[10:59:32.924]                 NAMES <- toupper(changed)
[10:59:32.924]                 args <- list()
[10:59:32.924]                 for (kk in seq_along(NAMES)) {
[10:59:32.924]                   name <- changed[[kk]]
[10:59:32.924]                   NAME <- NAMES[[kk]]
[10:59:32.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.924]                     next
[10:59:32.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.924]                 }
[10:59:32.924]                 NAMES <- toupper(added)
[10:59:32.924]                 for (kk in seq_along(NAMES)) {
[10:59:32.924]                   name <- added[[kk]]
[10:59:32.924]                   NAME <- NAMES[[kk]]
[10:59:32.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.924]                     next
[10:59:32.924]                   args[[name]] <- ""
[10:59:32.924]                 }
[10:59:32.924]                 NAMES <- toupper(removed)
[10:59:32.924]                 for (kk in seq_along(NAMES)) {
[10:59:32.924]                   name <- removed[[kk]]
[10:59:32.924]                   NAME <- NAMES[[kk]]
[10:59:32.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.924]                     next
[10:59:32.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.924]                 }
[10:59:32.924]                 if (length(args) > 0) 
[10:59:32.924]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.924]             }
[10:59:32.924]             else {
[10:59:32.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.924]             }
[10:59:32.924]             {
[10:59:32.924]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.924]                   0L) {
[10:59:32.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.924]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.924]                   base::options(opts)
[10:59:32.924]                 }
[10:59:32.924]                 {
[10:59:32.924]                   {
[10:59:32.924]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.924]                     NULL
[10:59:32.924]                   }
[10:59:32.924]                   options(future.plan = NULL)
[10:59:32.924]                   if (is.na(NA_character_)) 
[10:59:32.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.924]                     .init = FALSE)
[10:59:32.924]                 }
[10:59:32.924]             }
[10:59:32.924]         }
[10:59:32.924]     })
[10:59:32.924]     if (TRUE) {
[10:59:32.924]         base::sink(type = "output", split = FALSE)
[10:59:32.924]         if (TRUE) {
[10:59:32.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.924]         }
[10:59:32.924]         else {
[10:59:32.924]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.924]         }
[10:59:32.924]         base::close(...future.stdout)
[10:59:32.924]         ...future.stdout <- NULL
[10:59:32.924]     }
[10:59:32.924]     ...future.result$conditions <- ...future.conditions
[10:59:32.924]     ...future.result$finished <- base::Sys.time()
[10:59:32.924]     ...future.result
[10:59:32.924] }
[10:59:32.927] assign_globals() ...
[10:59:32.927] List of 5
[10:59:32.927]  $ ...future.FUN            :function (C, k)  
[10:59:32.927]  $ MoreArgs                 : list()
[10:59:32.927]  $ ...future.elements_ii    :List of 2
[10:59:32.927]   ..$ :List of 3
[10:59:32.927]   .. ..$ : chr "C"
[10:59:32.927]   .. ..$ : chr "D"
[10:59:32.927]   .. ..$ : chr "E"
[10:59:32.927]   ..$ :List of 3
[10:59:32.927]   .. ..$ : int 3
[10:59:32.927]   .. ..$ : int 2
[10:59:32.927]   .. ..$ : int 1
[10:59:32.927]  $ ...future.seeds_ii       : NULL
[10:59:32.927]  $ ...future.globals.maxSize: NULL
[10:59:32.927]  - attr(*, "where")=List of 5
[10:59:32.927]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.927]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.927]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.927]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.927]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.927]  - attr(*, "resolved")= logi FALSE
[10:59:32.927]  - attr(*, "total_size")= num 909
[10:59:32.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.927]  - attr(*, "already-done")= logi TRUE
[10:59:32.935] - reassign environment for ‘...future.FUN’
[10:59:32.935] - copied ‘...future.FUN’ to environment
[10:59:32.935] - copied ‘MoreArgs’ to environment
[10:59:32.935] - copied ‘...future.elements_ii’ to environment
[10:59:32.935] - copied ‘...future.seeds_ii’ to environment
[10:59:32.935] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.935] assign_globals() ... done
[10:59:32.935] requestCore(): workers = 2
[10:59:32.938] MulticoreFuture started
[10:59:32.938] - Launch lazy future ... done
[10:59:32.938] run() for ‘MulticoreFuture’ ... done
[10:59:32.938] Created future:
[10:59:32.939] plan(): Setting new future strategy stack:
[10:59:32.939] List of future strategies:
[10:59:32.939] 1. sequential:
[10:59:32.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.939]    - tweaked: FALSE
[10:59:32.939]    - call: NULL
[10:59:32.940] plan(): nbrOfWorkers() = 1
[10:59:32.946] plan(): Setting new future strategy stack:
[10:59:32.946] List of future strategies:
[10:59:32.946] 1. multicore:
[10:59:32.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:32.946]    - tweaked: FALSE
[10:59:32.946]    - call: plan(strategy)
[10:59:32.951] plan(): nbrOfWorkers() = 2
[10:59:32.939] MulticoreFuture:
[10:59:32.939] Label: ‘future_.mapply-2’
[10:59:32.939] Expression:
[10:59:32.939] {
[10:59:32.939]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.939]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.939]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.939]         on.exit(options(oopts), add = TRUE)
[10:59:32.939]     }
[10:59:32.939]     {
[10:59:32.939]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.939]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.939]         do.call(mapply, args = args)
[10:59:32.939]     }
[10:59:32.939] }
[10:59:32.939] Lazy evaluation: FALSE
[10:59:32.939] Asynchronous evaluation: TRUE
[10:59:32.939] Local evaluation: TRUE
[10:59:32.939] Environment: R_GlobalEnv
[10:59:32.939] Capture standard output: TRUE
[10:59:32.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.939] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.939] Packages: <none>
[10:59:32.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.939] Resolved: TRUE
[10:59:32.939] Value: <not collected>
[10:59:32.939] Conditions captured: <none>
[10:59:32.939] Early signaling: FALSE
[10:59:32.939] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.939] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.952] Chunk #2 of 2 ... DONE
[10:59:32.952] Launching 2 futures (chunks) ... DONE
[10:59:32.953] Resolving 2 futures (chunks) ...
[10:59:32.953] resolve() on list ...
[10:59:32.953]  recursive: 0
[10:59:32.953]  length: 2
[10:59:32.953] 
[10:59:32.954] Future #1
[10:59:32.954] result() for MulticoreFuture ...
[10:59:32.955] result() for MulticoreFuture ...
[10:59:32.955] result() for MulticoreFuture ... done
[10:59:32.955] result() for MulticoreFuture ... done
[10:59:32.956] result() for MulticoreFuture ...
[10:59:32.956] result() for MulticoreFuture ... done
[10:59:32.956] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:32.956] - nx: 2
[10:59:32.957] - relay: TRUE
[10:59:32.957] - stdout: TRUE
[10:59:32.957] - signal: TRUE
[10:59:32.957] - resignal: FALSE
[10:59:32.957] - force: TRUE
[10:59:32.957] - relayed: [n=2] FALSE, FALSE
[10:59:32.958] - queued futures: [n=2] FALSE, FALSE
[10:59:32.958]  - until=1
[10:59:32.958]  - relaying element #1
[10:59:32.958] result() for MulticoreFuture ...
[10:59:32.959] result() for MulticoreFuture ... done
[10:59:32.959] result() for MulticoreFuture ...
[10:59:32.959] result() for MulticoreFuture ... done
[10:59:32.959] result() for MulticoreFuture ...
[10:59:32.959] result() for MulticoreFuture ... done
[10:59:32.960] result() for MulticoreFuture ...
[10:59:32.960] result() for MulticoreFuture ... done
[10:59:32.960] - relayed: [n=2] TRUE, FALSE
[10:59:32.960] - queued futures: [n=2] TRUE, FALSE
[10:59:32.960] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:32.961]  length: 1 (resolved future 1)
[10:59:32.961] Future #2
[10:59:32.961] result() for MulticoreFuture ...
[10:59:32.962] result() for MulticoreFuture ...
[10:59:32.962] result() for MulticoreFuture ... done
[10:59:32.962] result() for MulticoreFuture ... done
[10:59:32.963] result() for MulticoreFuture ...
[10:59:32.963] result() for MulticoreFuture ... done
[10:59:32.963] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:32.963] - nx: 2
[10:59:32.963] - relay: TRUE
[10:59:32.963] - stdout: TRUE
[10:59:32.963] - signal: TRUE
[10:59:32.964] - resignal: FALSE
[10:59:32.964] - force: TRUE
[10:59:32.964] - relayed: [n=2] TRUE, FALSE
[10:59:32.964] - queued futures: [n=2] TRUE, FALSE
[10:59:32.964]  - until=2
[10:59:32.964]  - relaying element #2
[10:59:32.964] result() for MulticoreFuture ...
[10:59:32.964] result() for MulticoreFuture ... done
[10:59:32.964] result() for MulticoreFuture ...
[10:59:32.965] result() for MulticoreFuture ... done
[10:59:32.965] result() for MulticoreFuture ...
[10:59:32.965] result() for MulticoreFuture ... done
[10:59:32.965] result() for MulticoreFuture ...
[10:59:32.965] result() for MulticoreFuture ... done
[10:59:32.965] - relayed: [n=2] TRUE, TRUE
[10:59:32.965] - queued futures: [n=2] TRUE, TRUE
[10:59:32.965] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:32.965]  length: 0 (resolved future 2)
[10:59:32.966] Relaying remaining futures
[10:59:32.966] signalConditionsASAP(NULL, pos=0) ...
[10:59:32.966] - nx: 2
[10:59:32.966] - relay: TRUE
[10:59:32.966] - stdout: TRUE
[10:59:32.966] - signal: TRUE
[10:59:32.966] - resignal: FALSE
[10:59:32.966] - force: TRUE
[10:59:32.966] - relayed: [n=2] TRUE, TRUE
[10:59:32.966] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:32.967] - relayed: [n=2] TRUE, TRUE
[10:59:32.967] - queued futures: [n=2] TRUE, TRUE
[10:59:32.967] signalConditionsASAP(NULL, pos=0) ... done
[10:59:32.967] resolve() on list ... DONE
[10:59:32.967] result() for MulticoreFuture ...
[10:59:32.967] result() for MulticoreFuture ... done
[10:59:32.967] result() for MulticoreFuture ...
[10:59:32.967] result() for MulticoreFuture ... done
[10:59:32.967] result() for MulticoreFuture ...
[10:59:32.967] result() for MulticoreFuture ... done
[10:59:32.968] result() for MulticoreFuture ...
[10:59:32.968] result() for MulticoreFuture ... done
[10:59:32.968]  - Number of value chunks collected: 2
[10:59:32.968] Resolving 2 futures (chunks) ... DONE
[10:59:32.968] Reducing values from 2 chunks ...
[10:59:32.968]  - Number of values collected after concatenation: 5
[10:59:32.968]  - Number of values expected: 5
[10:59:32.968] Reducing values from 2 chunks ... DONE
[10:59:32.968] future_mapply() ... DONE
[10:59:32.969] future_mapply() ...
[10:59:32.971] Number of chunks: 2
[10:59:32.971] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:59:32.971] getGlobalsAndPackagesXApply() ...
[10:59:32.971]  - future.globals: TRUE
[10:59:32.971] getGlobalsAndPackages() ...
[10:59:32.971] Searching for globals...
[10:59:32.973] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:32.973] Searching for globals ... DONE
[10:59:32.973] Resolving globals: FALSE
[10:59:32.973] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:32.974] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:32.974] - globals: [1] ‘FUN’
[10:59:32.974] 
[10:59:32.974] getGlobalsAndPackages() ... DONE
[10:59:32.974]  - globals found/used: [n=1] ‘FUN’
[10:59:32.974]  - needed namespaces: [n=0] 
[10:59:32.974] Finding globals ... DONE
[10:59:32.974] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:32.974] List of 2
[10:59:32.974]  $ ...future.FUN:function (C, k)  
[10:59:32.974]  $ MoreArgs     : NULL
[10:59:32.974]  - attr(*, "where")=List of 2
[10:59:32.974]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:32.974]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:32.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.974]  - attr(*, "resolved")= logi FALSE
[10:59:32.974]  - attr(*, "total_size")= num NA
[10:59:32.977] Packages to be attached in all futures: [n=0] 
[10:59:32.977] getGlobalsAndPackagesXApply() ... DONE
[10:59:32.979] Number of futures (= number of chunks): 2
[10:59:32.979] Launching 2 futures (chunks) ...
[10:59:32.979] Chunk #1 of 2 ...
[10:59:32.980]  - Finding globals in '...' for chunk #1 ...
[10:59:32.980] getGlobalsAndPackages() ...
[10:59:32.980] Searching for globals...
[10:59:32.980] 
[10:59:32.980] Searching for globals ... DONE
[10:59:32.980] - globals: [0] <none>
[10:59:32.980] getGlobalsAndPackages() ... DONE
[10:59:32.980]    + additional globals found: [n=0] 
[10:59:32.981]    + additional namespaces needed: [n=0] 
[10:59:32.981]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:32.981]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:32.981]  - seeds: <none>
[10:59:32.981]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.981] getGlobalsAndPackages() ...
[10:59:32.981] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.981] Resolving globals: FALSE
[10:59:32.982] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:32.982] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:32.982] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:32.982] 
[10:59:32.982] getGlobalsAndPackages() ... DONE
[10:59:32.983] run() for ‘Future’ ...
[10:59:32.983] - state: ‘created’
[10:59:32.983] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:32.985] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:32.985] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:32.985]   - Field: ‘label’
[10:59:32.985]   - Field: ‘local’
[10:59:32.985]   - Field: ‘owner’
[10:59:32.985]   - Field: ‘envir’
[10:59:32.985]   - Field: ‘workers’
[10:59:32.985]   - Field: ‘packages’
[10:59:32.986]   - Field: ‘gc’
[10:59:32.986]   - Field: ‘job’
[10:59:32.986]   - Field: ‘conditions’
[10:59:32.986]   - Field: ‘expr’
[10:59:32.986]   - Field: ‘uuid’
[10:59:32.986]   - Field: ‘seed’
[10:59:32.986]   - Field: ‘version’
[10:59:32.986]   - Field: ‘result’
[10:59:32.986]   - Field: ‘asynchronous’
[10:59:32.986]   - Field: ‘calls’
[10:59:32.986]   - Field: ‘globals’
[10:59:32.987]   - Field: ‘stdout’
[10:59:32.987]   - Field: ‘earlySignal’
[10:59:32.987]   - Field: ‘lazy’
[10:59:32.987]   - Field: ‘state’
[10:59:32.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:32.987] - Launch lazy future ...
[10:59:32.987] Packages needed by the future expression (n = 0): <none>
[10:59:32.987] Packages needed by future strategies (n = 0): <none>
[10:59:32.988] {
[10:59:32.988]     {
[10:59:32.988]         {
[10:59:32.988]             ...future.startTime <- base::Sys.time()
[10:59:32.988]             {
[10:59:32.988]                 {
[10:59:32.988]                   {
[10:59:32.988]                     {
[10:59:32.988]                       base::local({
[10:59:32.988]                         has_future <- base::requireNamespace("future", 
[10:59:32.988]                           quietly = TRUE)
[10:59:32.988]                         if (has_future) {
[10:59:32.988]                           ns <- base::getNamespace("future")
[10:59:32.988]                           version <- ns[[".package"]][["version"]]
[10:59:32.988]                           if (is.null(version)) 
[10:59:32.988]                             version <- utils::packageVersion("future")
[10:59:32.988]                         }
[10:59:32.988]                         else {
[10:59:32.988]                           version <- NULL
[10:59:32.988]                         }
[10:59:32.988]                         if (!has_future || version < "1.8.0") {
[10:59:32.988]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:32.988]                             "", base::R.version$version.string), 
[10:59:32.988]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:32.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:32.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:32.988]                               "release", "version")], collapse = " "), 
[10:59:32.988]                             hostname = base::Sys.info()[["nodename"]])
[10:59:32.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:32.988]                             info)
[10:59:32.988]                           info <- base::paste(info, collapse = "; ")
[10:59:32.988]                           if (!has_future) {
[10:59:32.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:32.988]                               info)
[10:59:32.988]                           }
[10:59:32.988]                           else {
[10:59:32.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:32.988]                               info, version)
[10:59:32.988]                           }
[10:59:32.988]                           base::stop(msg)
[10:59:32.988]                         }
[10:59:32.988]                       })
[10:59:32.988]                     }
[10:59:32.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:32.988]                     base::options(mc.cores = 1L)
[10:59:32.988]                   }
[10:59:32.988]                   ...future.strategy.old <- future::plan("list")
[10:59:32.988]                   options(future.plan = NULL)
[10:59:32.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:32.988]                 }
[10:59:32.988]                 ...future.workdir <- getwd()
[10:59:32.988]             }
[10:59:32.988]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:32.988]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:32.988]         }
[10:59:32.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:32.988]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:32.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:32.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:32.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:32.988]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:32.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:32.988]             base::names(...future.oldOptions))
[10:59:32.988]     }
[10:59:32.988]     if (FALSE) {
[10:59:32.988]     }
[10:59:32.988]     else {
[10:59:32.988]         if (TRUE) {
[10:59:32.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:32.988]                 open = "w")
[10:59:32.988]         }
[10:59:32.988]         else {
[10:59:32.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:32.988]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:32.988]         }
[10:59:32.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:32.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:32.988]             base::sink(type = "output", split = FALSE)
[10:59:32.988]             base::close(...future.stdout)
[10:59:32.988]         }, add = TRUE)
[10:59:32.988]     }
[10:59:32.988]     ...future.frame <- base::sys.nframe()
[10:59:32.988]     ...future.conditions <- base::list()
[10:59:32.988]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:32.988]     if (FALSE) {
[10:59:32.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:32.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:32.988]     }
[10:59:32.988]     ...future.result <- base::tryCatch({
[10:59:32.988]         base::withCallingHandlers({
[10:59:32.988]             ...future.value <- base::withVisible(base::local({
[10:59:32.988]                 withCallingHandlers({
[10:59:32.988]                   {
[10:59:32.988]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.988]                     if (!identical(...future.globals.maxSize.org, 
[10:59:32.988]                       ...future.globals.maxSize)) {
[10:59:32.988]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.988]                       on.exit(options(oopts), add = TRUE)
[10:59:32.988]                     }
[10:59:32.988]                     {
[10:59:32.988]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.988]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:32.988]                         USE.NAMES = FALSE)
[10:59:32.988]                       do.call(mapply, args = args)
[10:59:32.988]                     }
[10:59:32.988]                   }
[10:59:32.988]                 }, immediateCondition = function(cond) {
[10:59:32.988]                   save_rds <- function (object, pathname, ...) 
[10:59:32.988]                   {
[10:59:32.988]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:32.988]                     if (file_test("-f", pathname_tmp)) {
[10:59:32.988]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.988]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:32.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.988]                         fi_tmp[["mtime"]])
[10:59:32.988]                     }
[10:59:32.988]                     tryCatch({
[10:59:32.988]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:32.988]                     }, error = function(ex) {
[10:59:32.988]                       msg <- conditionMessage(ex)
[10:59:32.988]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.988]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:32.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.988]                         fi_tmp[["mtime"]], msg)
[10:59:32.988]                       ex$message <- msg
[10:59:32.988]                       stop(ex)
[10:59:32.988]                     })
[10:59:32.988]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:32.988]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:32.988]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:32.988]                       fi_tmp <- file.info(pathname_tmp)
[10:59:32.988]                       fi <- file.info(pathname)
[10:59:32.988]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:32.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:32.988]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:32.988]                         fi[["size"]], fi[["mtime"]])
[10:59:32.988]                       stop(msg)
[10:59:32.988]                     }
[10:59:32.988]                     invisible(pathname)
[10:59:32.988]                   }
[10:59:32.988]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:32.988]                     rootPath = tempdir()) 
[10:59:32.988]                   {
[10:59:32.988]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:32.988]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:32.988]                       tmpdir = path, fileext = ".rds")
[10:59:32.988]                     save_rds(obj, file)
[10:59:32.988]                   }
[10:59:32.988]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:32.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.988]                   {
[10:59:32.988]                     inherits <- base::inherits
[10:59:32.988]                     invokeRestart <- base::invokeRestart
[10:59:32.988]                     is.null <- base::is.null
[10:59:32.988]                     muffled <- FALSE
[10:59:32.988]                     if (inherits(cond, "message")) {
[10:59:32.988]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:32.988]                       if (muffled) 
[10:59:32.988]                         invokeRestart("muffleMessage")
[10:59:32.988]                     }
[10:59:32.988]                     else if (inherits(cond, "warning")) {
[10:59:32.988]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:32.988]                       if (muffled) 
[10:59:32.988]                         invokeRestart("muffleWarning")
[10:59:32.988]                     }
[10:59:32.988]                     else if (inherits(cond, "condition")) {
[10:59:32.988]                       if (!is.null(pattern)) {
[10:59:32.988]                         computeRestarts <- base::computeRestarts
[10:59:32.988]                         grepl <- base::grepl
[10:59:32.988]                         restarts <- computeRestarts(cond)
[10:59:32.988]                         for (restart in restarts) {
[10:59:32.988]                           name <- restart$name
[10:59:32.988]                           if (is.null(name)) 
[10:59:32.988]                             next
[10:59:32.988]                           if (!grepl(pattern, name)) 
[10:59:32.988]                             next
[10:59:32.988]                           invokeRestart(restart)
[10:59:32.988]                           muffled <- TRUE
[10:59:32.988]                           break
[10:59:32.988]                         }
[10:59:32.988]                       }
[10:59:32.988]                     }
[10:59:32.988]                     invisible(muffled)
[10:59:32.988]                   }
[10:59:32.988]                   muffleCondition(cond)
[10:59:32.988]                 })
[10:59:32.988]             }))
[10:59:32.988]             future::FutureResult(value = ...future.value$value, 
[10:59:32.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.988]                   ...future.rng), globalenv = if (FALSE) 
[10:59:32.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:32.988]                     ...future.globalenv.names))
[10:59:32.988]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:32.988]         }, condition = base::local({
[10:59:32.988]             c <- base::c
[10:59:32.988]             inherits <- base::inherits
[10:59:32.988]             invokeRestart <- base::invokeRestart
[10:59:32.988]             length <- base::length
[10:59:32.988]             list <- base::list
[10:59:32.988]             seq.int <- base::seq.int
[10:59:32.988]             signalCondition <- base::signalCondition
[10:59:32.988]             sys.calls <- base::sys.calls
[10:59:32.988]             `[[` <- base::`[[`
[10:59:32.988]             `+` <- base::`+`
[10:59:32.988]             `<<-` <- base::`<<-`
[10:59:32.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:32.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:32.988]                   3L)]
[10:59:32.988]             }
[10:59:32.988]             function(cond) {
[10:59:32.988]                 is_error <- inherits(cond, "error")
[10:59:32.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:32.988]                   NULL)
[10:59:32.988]                 if (is_error) {
[10:59:32.988]                   sessionInformation <- function() {
[10:59:32.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:32.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:32.988]                       search = base::search(), system = base::Sys.info())
[10:59:32.988]                   }
[10:59:32.988]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:32.988]                     cond$call), session = sessionInformation(), 
[10:59:32.988]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:32.988]                   signalCondition(cond)
[10:59:32.988]                 }
[10:59:32.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:32.988]                 "immediateCondition"))) {
[10:59:32.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:32.988]                   ...future.conditions[[length(...future.conditions) + 
[10:59:32.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:32.988]                   if (TRUE && !signal) {
[10:59:32.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.988]                     {
[10:59:32.988]                       inherits <- base::inherits
[10:59:32.988]                       invokeRestart <- base::invokeRestart
[10:59:32.988]                       is.null <- base::is.null
[10:59:32.988]                       muffled <- FALSE
[10:59:32.988]                       if (inherits(cond, "message")) {
[10:59:32.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.988]                         if (muffled) 
[10:59:32.988]                           invokeRestart("muffleMessage")
[10:59:32.988]                       }
[10:59:32.988]                       else if (inherits(cond, "warning")) {
[10:59:32.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.988]                         if (muffled) 
[10:59:32.988]                           invokeRestart("muffleWarning")
[10:59:32.988]                       }
[10:59:32.988]                       else if (inherits(cond, "condition")) {
[10:59:32.988]                         if (!is.null(pattern)) {
[10:59:32.988]                           computeRestarts <- base::computeRestarts
[10:59:32.988]                           grepl <- base::grepl
[10:59:32.988]                           restarts <- computeRestarts(cond)
[10:59:32.988]                           for (restart in restarts) {
[10:59:32.988]                             name <- restart$name
[10:59:32.988]                             if (is.null(name)) 
[10:59:32.988]                               next
[10:59:32.988]                             if (!grepl(pattern, name)) 
[10:59:32.988]                               next
[10:59:32.988]                             invokeRestart(restart)
[10:59:32.988]                             muffled <- TRUE
[10:59:32.988]                             break
[10:59:32.988]                           }
[10:59:32.988]                         }
[10:59:32.988]                       }
[10:59:32.988]                       invisible(muffled)
[10:59:32.988]                     }
[10:59:32.988]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.988]                   }
[10:59:32.988]                 }
[10:59:32.988]                 else {
[10:59:32.988]                   if (TRUE) {
[10:59:32.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:32.988]                     {
[10:59:32.988]                       inherits <- base::inherits
[10:59:32.988]                       invokeRestart <- base::invokeRestart
[10:59:32.988]                       is.null <- base::is.null
[10:59:32.988]                       muffled <- FALSE
[10:59:32.988]                       if (inherits(cond, "message")) {
[10:59:32.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:32.988]                         if (muffled) 
[10:59:32.988]                           invokeRestart("muffleMessage")
[10:59:32.988]                       }
[10:59:32.988]                       else if (inherits(cond, "warning")) {
[10:59:32.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:32.988]                         if (muffled) 
[10:59:32.988]                           invokeRestart("muffleWarning")
[10:59:32.988]                       }
[10:59:32.988]                       else if (inherits(cond, "condition")) {
[10:59:32.988]                         if (!is.null(pattern)) {
[10:59:32.988]                           computeRestarts <- base::computeRestarts
[10:59:32.988]                           grepl <- base::grepl
[10:59:32.988]                           restarts <- computeRestarts(cond)
[10:59:32.988]                           for (restart in restarts) {
[10:59:32.988]                             name <- restart$name
[10:59:32.988]                             if (is.null(name)) 
[10:59:32.988]                               next
[10:59:32.988]                             if (!grepl(pattern, name)) 
[10:59:32.988]                               next
[10:59:32.988]                             invokeRestart(restart)
[10:59:32.988]                             muffled <- TRUE
[10:59:32.988]                             break
[10:59:32.988]                           }
[10:59:32.988]                         }
[10:59:32.988]                       }
[10:59:32.988]                       invisible(muffled)
[10:59:32.988]                     }
[10:59:32.988]                     muffleCondition(cond, pattern = "^muffle")
[10:59:32.988]                   }
[10:59:32.988]                 }
[10:59:32.988]             }
[10:59:32.988]         }))
[10:59:32.988]     }, error = function(ex) {
[10:59:32.988]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:32.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:32.988]                 ...future.rng), started = ...future.startTime, 
[10:59:32.988]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:32.988]             version = "1.8"), class = "FutureResult")
[10:59:32.988]     }, finally = {
[10:59:32.988]         if (!identical(...future.workdir, getwd())) 
[10:59:32.988]             setwd(...future.workdir)
[10:59:32.988]         {
[10:59:32.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:32.988]                 ...future.oldOptions$nwarnings <- NULL
[10:59:32.988]             }
[10:59:32.988]             base::options(...future.oldOptions)
[10:59:32.988]             if (.Platform$OS.type == "windows") {
[10:59:32.988]                 old_names <- names(...future.oldEnvVars)
[10:59:32.988]                 envs <- base::Sys.getenv()
[10:59:32.988]                 names <- names(envs)
[10:59:32.988]                 common <- intersect(names, old_names)
[10:59:32.988]                 added <- setdiff(names, old_names)
[10:59:32.988]                 removed <- setdiff(old_names, names)
[10:59:32.988]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:32.988]                   envs[common]]
[10:59:32.988]                 NAMES <- toupper(changed)
[10:59:32.988]                 args <- list()
[10:59:32.988]                 for (kk in seq_along(NAMES)) {
[10:59:32.988]                   name <- changed[[kk]]
[10:59:32.988]                   NAME <- NAMES[[kk]]
[10:59:32.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.988]                     next
[10:59:32.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.988]                 }
[10:59:32.988]                 NAMES <- toupper(added)
[10:59:32.988]                 for (kk in seq_along(NAMES)) {
[10:59:32.988]                   name <- added[[kk]]
[10:59:32.988]                   NAME <- NAMES[[kk]]
[10:59:32.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.988]                     next
[10:59:32.988]                   args[[name]] <- ""
[10:59:32.988]                 }
[10:59:32.988]                 NAMES <- toupper(removed)
[10:59:32.988]                 for (kk in seq_along(NAMES)) {
[10:59:32.988]                   name <- removed[[kk]]
[10:59:32.988]                   NAME <- NAMES[[kk]]
[10:59:32.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:32.988]                     next
[10:59:32.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:32.988]                 }
[10:59:32.988]                 if (length(args) > 0) 
[10:59:32.988]                   base::do.call(base::Sys.setenv, args = args)
[10:59:32.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:32.988]             }
[10:59:32.988]             else {
[10:59:32.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:32.988]             }
[10:59:32.988]             {
[10:59:32.988]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:32.988]                   0L) {
[10:59:32.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:32.988]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:32.988]                   base::options(opts)
[10:59:32.988]                 }
[10:59:32.988]                 {
[10:59:32.988]                   {
[10:59:32.988]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:32.988]                     NULL
[10:59:32.988]                   }
[10:59:32.988]                   options(future.plan = NULL)
[10:59:32.988]                   if (is.na(NA_character_)) 
[10:59:32.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:32.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:32.988]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:32.988]                     .init = FALSE)
[10:59:32.988]                 }
[10:59:32.988]             }
[10:59:32.988]         }
[10:59:32.988]     })
[10:59:32.988]     if (TRUE) {
[10:59:32.988]         base::sink(type = "output", split = FALSE)
[10:59:32.988]         if (TRUE) {
[10:59:32.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:32.988]         }
[10:59:32.988]         else {
[10:59:32.988]             ...future.result["stdout"] <- base::list(NULL)
[10:59:32.988]         }
[10:59:32.988]         base::close(...future.stdout)
[10:59:32.988]         ...future.stdout <- NULL
[10:59:32.988]     }
[10:59:32.988]     ...future.result$conditions <- ...future.conditions
[10:59:32.988]     ...future.result$finished <- base::Sys.time()
[10:59:32.988]     ...future.result
[10:59:32.988] }
[10:59:32.990] assign_globals() ...
[10:59:32.990] List of 5
[10:59:32.990]  $ ...future.FUN            :function (C, k)  
[10:59:32.990]  $ MoreArgs                 : NULL
[10:59:32.990]  $ ...future.elements_ii    :List of 2
[10:59:32.990]   ..$ :List of 2
[10:59:32.990]   .. ..$ : chr "E"
[10:59:32.990]   .. ..$ : chr "D"
[10:59:32.990]   ..$ :List of 2
[10:59:32.990]   .. ..$ : int 1
[10:59:32.990]   .. ..$ : int 2
[10:59:32.990]  $ ...future.seeds_ii       : NULL
[10:59:32.990]  $ ...future.globals.maxSize: NULL
[10:59:32.990]  - attr(*, "where")=List of 5
[10:59:32.990]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:32.990]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:32.990]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:32.990]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:32.990]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:32.990]  - attr(*, "resolved")= logi FALSE
[10:59:32.990]  - attr(*, "total_size")= num 876
[10:59:32.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:32.990]  - attr(*, "already-done")= logi TRUE
[10:59:32.995] - reassign environment for ‘...future.FUN’
[10:59:32.996] - copied ‘...future.FUN’ to environment
[10:59:32.996] - copied ‘MoreArgs’ to environment
[10:59:32.996] - copied ‘...future.elements_ii’ to environment
[10:59:32.996] - copied ‘...future.seeds_ii’ to environment
[10:59:32.996] - copied ‘...future.globals.maxSize’ to environment
[10:59:32.996] assign_globals() ... done
[10:59:32.996] requestCore(): workers = 2
[10:59:32.998] MulticoreFuture started
[10:59:32.998] - Launch lazy future ... done
[10:59:32.999] run() for ‘MulticoreFuture’ ... done
[10:59:32.999] Created future:
[10:59:32.999] plan(): Setting new future strategy stack:
[10:59:32.999] List of future strategies:
[10:59:32.999] 1. sequential:
[10:59:32.999]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:32.999]    - tweaked: FALSE
[10:59:32.999]    - call: NULL
[10:59:33.000] plan(): nbrOfWorkers() = 1
[10:59:33.002] plan(): Setting new future strategy stack:
[10:59:33.002] List of future strategies:
[10:59:33.002] 1. multicore:
[10:59:33.002]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.002]    - tweaked: FALSE
[10:59:33.002]    - call: plan(strategy)
[10:59:33.009] plan(): nbrOfWorkers() = 2
[10:59:32.999] MulticoreFuture:
[10:59:32.999] Label: ‘future_mapply-1’
[10:59:32.999] Expression:
[10:59:32.999] {
[10:59:32.999]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:32.999]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:32.999]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:32.999]         on.exit(options(oopts), add = TRUE)
[10:59:32.999]     }
[10:59:32.999]     {
[10:59:32.999]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:32.999]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:32.999]         do.call(mapply, args = args)
[10:59:32.999]     }
[10:59:32.999] }
[10:59:32.999] Lazy evaluation: FALSE
[10:59:32.999] Asynchronous evaluation: TRUE
[10:59:32.999] Local evaluation: TRUE
[10:59:32.999] Environment: R_GlobalEnv
[10:59:32.999] Capture standard output: TRUE
[10:59:32.999] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:32.999] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:32.999] Packages: <none>
[10:59:32.999] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:32.999] Resolved: TRUE
[10:59:32.999] Value: <not collected>
[10:59:32.999] Conditions captured: <none>
[10:59:32.999] Early signaling: FALSE
[10:59:32.999] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:32.999] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.011] Chunk #1 of 2 ... DONE
[10:59:33.011] Chunk #2 of 2 ...
[10:59:33.011]  - Finding globals in '...' for chunk #2 ...
[10:59:33.011] getGlobalsAndPackages() ...
[10:59:33.011] Searching for globals...
[10:59:33.012] 
[10:59:33.012] Searching for globals ... DONE
[10:59:33.012] - globals: [0] <none>
[10:59:33.012] getGlobalsAndPackages() ... DONE
[10:59:33.012]    + additional globals found: [n=0] 
[10:59:33.012]    + additional namespaces needed: [n=0] 
[10:59:33.015]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.015]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.015]  - seeds: <none>
[10:59:33.015]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.016] getGlobalsAndPackages() ...
[10:59:33.016] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.017] Resolving globals: FALSE
[10:59:33.018] The total size of the 5 globals is 905 bytes (905 bytes)
[10:59:33.019] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.019] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.019] 
[10:59:33.020] getGlobalsAndPackages() ... DONE
[10:59:33.020] run() for ‘Future’ ...
[10:59:33.021] - state: ‘created’
[10:59:33.021] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.024] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.024]   - Field: ‘label’
[10:59:33.025]   - Field: ‘local’
[10:59:33.025]   - Field: ‘owner’
[10:59:33.025]   - Field: ‘envir’
[10:59:33.025]   - Field: ‘workers’
[10:59:33.025]   - Field: ‘packages’
[10:59:33.026]   - Field: ‘gc’
[10:59:33.026]   - Field: ‘job’
[10:59:33.026]   - Field: ‘conditions’
[10:59:33.026]   - Field: ‘expr’
[10:59:33.026]   - Field: ‘uuid’
[10:59:33.027]   - Field: ‘seed’
[10:59:33.027]   - Field: ‘version’
[10:59:33.027]   - Field: ‘result’
[10:59:33.027]   - Field: ‘asynchronous’
[10:59:33.027]   - Field: ‘calls’
[10:59:33.027]   - Field: ‘globals’
[10:59:33.028]   - Field: ‘stdout’
[10:59:33.028]   - Field: ‘earlySignal’
[10:59:33.028]   - Field: ‘lazy’
[10:59:33.028]   - Field: ‘state’
[10:59:33.028] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.028] - Launch lazy future ...
[10:59:33.029] Packages needed by the future expression (n = 0): <none>
[10:59:33.029] Packages needed by future strategies (n = 0): <none>
[10:59:33.029] {
[10:59:33.029]     {
[10:59:33.029]         {
[10:59:33.029]             ...future.startTime <- base::Sys.time()
[10:59:33.029]             {
[10:59:33.029]                 {
[10:59:33.029]                   {
[10:59:33.029]                     {
[10:59:33.029]                       base::local({
[10:59:33.029]                         has_future <- base::requireNamespace("future", 
[10:59:33.029]                           quietly = TRUE)
[10:59:33.029]                         if (has_future) {
[10:59:33.029]                           ns <- base::getNamespace("future")
[10:59:33.029]                           version <- ns[[".package"]][["version"]]
[10:59:33.029]                           if (is.null(version)) 
[10:59:33.029]                             version <- utils::packageVersion("future")
[10:59:33.029]                         }
[10:59:33.029]                         else {
[10:59:33.029]                           version <- NULL
[10:59:33.029]                         }
[10:59:33.029]                         if (!has_future || version < "1.8.0") {
[10:59:33.029]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.029]                             "", base::R.version$version.string), 
[10:59:33.029]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.029]                               "release", "version")], collapse = " "), 
[10:59:33.029]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.029]                             info)
[10:59:33.029]                           info <- base::paste(info, collapse = "; ")
[10:59:33.029]                           if (!has_future) {
[10:59:33.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.029]                               info)
[10:59:33.029]                           }
[10:59:33.029]                           else {
[10:59:33.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.029]                               info, version)
[10:59:33.029]                           }
[10:59:33.029]                           base::stop(msg)
[10:59:33.029]                         }
[10:59:33.029]                       })
[10:59:33.029]                     }
[10:59:33.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.029]                     base::options(mc.cores = 1L)
[10:59:33.029]                   }
[10:59:33.029]                   ...future.strategy.old <- future::plan("list")
[10:59:33.029]                   options(future.plan = NULL)
[10:59:33.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.029]                 }
[10:59:33.029]                 ...future.workdir <- getwd()
[10:59:33.029]             }
[10:59:33.029]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.029]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.029]         }
[10:59:33.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.029]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.029]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.029]             base::names(...future.oldOptions))
[10:59:33.029]     }
[10:59:33.029]     if (FALSE) {
[10:59:33.029]     }
[10:59:33.029]     else {
[10:59:33.029]         if (TRUE) {
[10:59:33.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.029]                 open = "w")
[10:59:33.029]         }
[10:59:33.029]         else {
[10:59:33.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.029]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.029]         }
[10:59:33.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.029]             base::sink(type = "output", split = FALSE)
[10:59:33.029]             base::close(...future.stdout)
[10:59:33.029]         }, add = TRUE)
[10:59:33.029]     }
[10:59:33.029]     ...future.frame <- base::sys.nframe()
[10:59:33.029]     ...future.conditions <- base::list()
[10:59:33.029]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.029]     if (FALSE) {
[10:59:33.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.029]     }
[10:59:33.029]     ...future.result <- base::tryCatch({
[10:59:33.029]         base::withCallingHandlers({
[10:59:33.029]             ...future.value <- base::withVisible(base::local({
[10:59:33.029]                 withCallingHandlers({
[10:59:33.029]                   {
[10:59:33.029]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.029]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.029]                       ...future.globals.maxSize)) {
[10:59:33.029]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.029]                       on.exit(options(oopts), add = TRUE)
[10:59:33.029]                     }
[10:59:33.029]                     {
[10:59:33.029]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.029]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.029]                         USE.NAMES = FALSE)
[10:59:33.029]                       do.call(mapply, args = args)
[10:59:33.029]                     }
[10:59:33.029]                   }
[10:59:33.029]                 }, immediateCondition = function(cond) {
[10:59:33.029]                   save_rds <- function (object, pathname, ...) 
[10:59:33.029]                   {
[10:59:33.029]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.029]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.029]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.029]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.029]                         fi_tmp[["mtime"]])
[10:59:33.029]                     }
[10:59:33.029]                     tryCatch({
[10:59:33.029]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.029]                     }, error = function(ex) {
[10:59:33.029]                       msg <- conditionMessage(ex)
[10:59:33.029]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.029]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.029]                         fi_tmp[["mtime"]], msg)
[10:59:33.029]                       ex$message <- msg
[10:59:33.029]                       stop(ex)
[10:59:33.029]                     })
[10:59:33.029]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.029]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.029]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.029]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.029]                       fi <- file.info(pathname)
[10:59:33.029]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.029]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.029]                         fi[["size"]], fi[["mtime"]])
[10:59:33.029]                       stop(msg)
[10:59:33.029]                     }
[10:59:33.029]                     invisible(pathname)
[10:59:33.029]                   }
[10:59:33.029]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.029]                     rootPath = tempdir()) 
[10:59:33.029]                   {
[10:59:33.029]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.029]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.029]                       tmpdir = path, fileext = ".rds")
[10:59:33.029]                     save_rds(obj, file)
[10:59:33.029]                   }
[10:59:33.029]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.029]                   {
[10:59:33.029]                     inherits <- base::inherits
[10:59:33.029]                     invokeRestart <- base::invokeRestart
[10:59:33.029]                     is.null <- base::is.null
[10:59:33.029]                     muffled <- FALSE
[10:59:33.029]                     if (inherits(cond, "message")) {
[10:59:33.029]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.029]                       if (muffled) 
[10:59:33.029]                         invokeRestart("muffleMessage")
[10:59:33.029]                     }
[10:59:33.029]                     else if (inherits(cond, "warning")) {
[10:59:33.029]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.029]                       if (muffled) 
[10:59:33.029]                         invokeRestart("muffleWarning")
[10:59:33.029]                     }
[10:59:33.029]                     else if (inherits(cond, "condition")) {
[10:59:33.029]                       if (!is.null(pattern)) {
[10:59:33.029]                         computeRestarts <- base::computeRestarts
[10:59:33.029]                         grepl <- base::grepl
[10:59:33.029]                         restarts <- computeRestarts(cond)
[10:59:33.029]                         for (restart in restarts) {
[10:59:33.029]                           name <- restart$name
[10:59:33.029]                           if (is.null(name)) 
[10:59:33.029]                             next
[10:59:33.029]                           if (!grepl(pattern, name)) 
[10:59:33.029]                             next
[10:59:33.029]                           invokeRestart(restart)
[10:59:33.029]                           muffled <- TRUE
[10:59:33.029]                           break
[10:59:33.029]                         }
[10:59:33.029]                       }
[10:59:33.029]                     }
[10:59:33.029]                     invisible(muffled)
[10:59:33.029]                   }
[10:59:33.029]                   muffleCondition(cond)
[10:59:33.029]                 })
[10:59:33.029]             }))
[10:59:33.029]             future::FutureResult(value = ...future.value$value, 
[10:59:33.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.029]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.029]                     ...future.globalenv.names))
[10:59:33.029]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.029]         }, condition = base::local({
[10:59:33.029]             c <- base::c
[10:59:33.029]             inherits <- base::inherits
[10:59:33.029]             invokeRestart <- base::invokeRestart
[10:59:33.029]             length <- base::length
[10:59:33.029]             list <- base::list
[10:59:33.029]             seq.int <- base::seq.int
[10:59:33.029]             signalCondition <- base::signalCondition
[10:59:33.029]             sys.calls <- base::sys.calls
[10:59:33.029]             `[[` <- base::`[[`
[10:59:33.029]             `+` <- base::`+`
[10:59:33.029]             `<<-` <- base::`<<-`
[10:59:33.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.029]                   3L)]
[10:59:33.029]             }
[10:59:33.029]             function(cond) {
[10:59:33.029]                 is_error <- inherits(cond, "error")
[10:59:33.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.029]                   NULL)
[10:59:33.029]                 if (is_error) {
[10:59:33.029]                   sessionInformation <- function() {
[10:59:33.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.029]                       search = base::search(), system = base::Sys.info())
[10:59:33.029]                   }
[10:59:33.029]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.029]                     cond$call), session = sessionInformation(), 
[10:59:33.029]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.029]                   signalCondition(cond)
[10:59:33.029]                 }
[10:59:33.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.029]                 "immediateCondition"))) {
[10:59:33.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.029]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.029]                   if (TRUE && !signal) {
[10:59:33.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.029]                     {
[10:59:33.029]                       inherits <- base::inherits
[10:59:33.029]                       invokeRestart <- base::invokeRestart
[10:59:33.029]                       is.null <- base::is.null
[10:59:33.029]                       muffled <- FALSE
[10:59:33.029]                       if (inherits(cond, "message")) {
[10:59:33.029]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.029]                         if (muffled) 
[10:59:33.029]                           invokeRestart("muffleMessage")
[10:59:33.029]                       }
[10:59:33.029]                       else if (inherits(cond, "warning")) {
[10:59:33.029]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.029]                         if (muffled) 
[10:59:33.029]                           invokeRestart("muffleWarning")
[10:59:33.029]                       }
[10:59:33.029]                       else if (inherits(cond, "condition")) {
[10:59:33.029]                         if (!is.null(pattern)) {
[10:59:33.029]                           computeRestarts <- base::computeRestarts
[10:59:33.029]                           grepl <- base::grepl
[10:59:33.029]                           restarts <- computeRestarts(cond)
[10:59:33.029]                           for (restart in restarts) {
[10:59:33.029]                             name <- restart$name
[10:59:33.029]                             if (is.null(name)) 
[10:59:33.029]                               next
[10:59:33.029]                             if (!grepl(pattern, name)) 
[10:59:33.029]                               next
[10:59:33.029]                             invokeRestart(restart)
[10:59:33.029]                             muffled <- TRUE
[10:59:33.029]                             break
[10:59:33.029]                           }
[10:59:33.029]                         }
[10:59:33.029]                       }
[10:59:33.029]                       invisible(muffled)
[10:59:33.029]                     }
[10:59:33.029]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.029]                   }
[10:59:33.029]                 }
[10:59:33.029]                 else {
[10:59:33.029]                   if (TRUE) {
[10:59:33.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.029]                     {
[10:59:33.029]                       inherits <- base::inherits
[10:59:33.029]                       invokeRestart <- base::invokeRestart
[10:59:33.029]                       is.null <- base::is.null
[10:59:33.029]                       muffled <- FALSE
[10:59:33.029]                       if (inherits(cond, "message")) {
[10:59:33.029]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.029]                         if (muffled) 
[10:59:33.029]                           invokeRestart("muffleMessage")
[10:59:33.029]                       }
[10:59:33.029]                       else if (inherits(cond, "warning")) {
[10:59:33.029]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.029]                         if (muffled) 
[10:59:33.029]                           invokeRestart("muffleWarning")
[10:59:33.029]                       }
[10:59:33.029]                       else if (inherits(cond, "condition")) {
[10:59:33.029]                         if (!is.null(pattern)) {
[10:59:33.029]                           computeRestarts <- base::computeRestarts
[10:59:33.029]                           grepl <- base::grepl
[10:59:33.029]                           restarts <- computeRestarts(cond)
[10:59:33.029]                           for (restart in restarts) {
[10:59:33.029]                             name <- restart$name
[10:59:33.029]                             if (is.null(name)) 
[10:59:33.029]                               next
[10:59:33.029]                             if (!grepl(pattern, name)) 
[10:59:33.029]                               next
[10:59:33.029]                             invokeRestart(restart)
[10:59:33.029]                             muffled <- TRUE
[10:59:33.029]                             break
[10:59:33.029]                           }
[10:59:33.029]                         }
[10:59:33.029]                       }
[10:59:33.029]                       invisible(muffled)
[10:59:33.029]                     }
[10:59:33.029]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.029]                   }
[10:59:33.029]                 }
[10:59:33.029]             }
[10:59:33.029]         }))
[10:59:33.029]     }, error = function(ex) {
[10:59:33.029]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.029]                 ...future.rng), started = ...future.startTime, 
[10:59:33.029]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.029]             version = "1.8"), class = "FutureResult")
[10:59:33.029]     }, finally = {
[10:59:33.029]         if (!identical(...future.workdir, getwd())) 
[10:59:33.029]             setwd(...future.workdir)
[10:59:33.029]         {
[10:59:33.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.029]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.029]             }
[10:59:33.029]             base::options(...future.oldOptions)
[10:59:33.029]             if (.Platform$OS.type == "windows") {
[10:59:33.029]                 old_names <- names(...future.oldEnvVars)
[10:59:33.029]                 envs <- base::Sys.getenv()
[10:59:33.029]                 names <- names(envs)
[10:59:33.029]                 common <- intersect(names, old_names)
[10:59:33.029]                 added <- setdiff(names, old_names)
[10:59:33.029]                 removed <- setdiff(old_names, names)
[10:59:33.029]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.029]                   envs[common]]
[10:59:33.029]                 NAMES <- toupper(changed)
[10:59:33.029]                 args <- list()
[10:59:33.029]                 for (kk in seq_along(NAMES)) {
[10:59:33.029]                   name <- changed[[kk]]
[10:59:33.029]                   NAME <- NAMES[[kk]]
[10:59:33.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.029]                     next
[10:59:33.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.029]                 }
[10:59:33.029]                 NAMES <- toupper(added)
[10:59:33.029]                 for (kk in seq_along(NAMES)) {
[10:59:33.029]                   name <- added[[kk]]
[10:59:33.029]                   NAME <- NAMES[[kk]]
[10:59:33.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.029]                     next
[10:59:33.029]                   args[[name]] <- ""
[10:59:33.029]                 }
[10:59:33.029]                 NAMES <- toupper(removed)
[10:59:33.029]                 for (kk in seq_along(NAMES)) {
[10:59:33.029]                   name <- removed[[kk]]
[10:59:33.029]                   NAME <- NAMES[[kk]]
[10:59:33.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.029]                     next
[10:59:33.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.029]                 }
[10:59:33.029]                 if (length(args) > 0) 
[10:59:33.029]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.029]             }
[10:59:33.029]             else {
[10:59:33.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.029]             }
[10:59:33.029]             {
[10:59:33.029]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.029]                   0L) {
[10:59:33.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.029]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.029]                   base::options(opts)
[10:59:33.029]                 }
[10:59:33.029]                 {
[10:59:33.029]                   {
[10:59:33.029]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.029]                     NULL
[10:59:33.029]                   }
[10:59:33.029]                   options(future.plan = NULL)
[10:59:33.029]                   if (is.na(NA_character_)) 
[10:59:33.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.029]                     .init = FALSE)
[10:59:33.029]                 }
[10:59:33.029]             }
[10:59:33.029]         }
[10:59:33.029]     })
[10:59:33.029]     if (TRUE) {
[10:59:33.029]         base::sink(type = "output", split = FALSE)
[10:59:33.029]         if (TRUE) {
[10:59:33.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.029]         }
[10:59:33.029]         else {
[10:59:33.029]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.029]         }
[10:59:33.029]         base::close(...future.stdout)
[10:59:33.029]         ...future.stdout <- NULL
[10:59:33.029]     }
[10:59:33.029]     ...future.result$conditions <- ...future.conditions
[10:59:33.029]     ...future.result$finished <- base::Sys.time()
[10:59:33.029]     ...future.result
[10:59:33.029] }
[10:59:33.032] assign_globals() ...
[10:59:33.032] List of 5
[10:59:33.032]  $ ...future.FUN            :function (C, k)  
[10:59:33.032]  $ MoreArgs                 : NULL
[10:59:33.032]  $ ...future.elements_ii    :List of 2
[10:59:33.032]   ..$ :List of 3
[10:59:33.032]   .. ..$ : chr "C"
[10:59:33.032]   .. ..$ : chr "B"
[10:59:33.032]   .. ..$ : chr "A"
[10:59:33.032]   ..$ :List of 3
[10:59:33.032]   .. ..$ : int 3
[10:59:33.032]   .. ..$ : int 4
[10:59:33.032]   .. ..$ : int 5
[10:59:33.032]  $ ...future.seeds_ii       : NULL
[10:59:33.032]  $ ...future.globals.maxSize: NULL
[10:59:33.032]  - attr(*, "where")=List of 5
[10:59:33.032]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.032]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.032]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.032]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.032]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.032]  - attr(*, "resolved")= logi FALSE
[10:59:33.032]  - attr(*, "total_size")= num 905
[10:59:33.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.032]  - attr(*, "already-done")= logi TRUE
[10:59:33.039] - reassign environment for ‘...future.FUN’
[10:59:33.040] - copied ‘...future.FUN’ to environment
[10:59:33.040] - copied ‘MoreArgs’ to environment
[10:59:33.040] - copied ‘...future.elements_ii’ to environment
[10:59:33.040] - copied ‘...future.seeds_ii’ to environment
[10:59:33.040] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.040] assign_globals() ... done
[10:59:33.040] requestCore(): workers = 2
[10:59:33.043] MulticoreFuture started
[10:59:33.043] - Launch lazy future ... done
[10:59:33.043] run() for ‘MulticoreFuture’ ... done
[10:59:33.043] plan(): Setting new future strategy stack:
[10:59:33.044] Created future:
[10:59:33.044] List of future strategies:
[10:59:33.044] 1. sequential:
[10:59:33.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.044]    - tweaked: FALSE
[10:59:33.044]    - call: NULL
[10:59:33.045] plan(): nbrOfWorkers() = 1
[10:59:33.047] plan(): Setting new future strategy stack:
[10:59:33.047] List of future strategies:
[10:59:33.047] 1. multicore:
[10:59:33.047]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.047]    - tweaked: FALSE
[10:59:33.047]    - call: plan(strategy)
[10:59:33.050] plan(): nbrOfWorkers() = 2
[10:59:33.044] MulticoreFuture:
[10:59:33.044] Label: ‘future_mapply-2’
[10:59:33.044] Expression:
[10:59:33.044] {
[10:59:33.044]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.044]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.044]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.044]         on.exit(options(oopts), add = TRUE)
[10:59:33.044]     }
[10:59:33.044]     {
[10:59:33.044]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.044]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.044]         do.call(mapply, args = args)
[10:59:33.044]     }
[10:59:33.044] }
[10:59:33.044] Lazy evaluation: FALSE
[10:59:33.044] Asynchronous evaluation: TRUE
[10:59:33.044] Local evaluation: TRUE
[10:59:33.044] Environment: R_GlobalEnv
[10:59:33.044] Capture standard output: TRUE
[10:59:33.044] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.044] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.044] Packages: <none>
[10:59:33.044] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.044] Resolved: TRUE
[10:59:33.044] Value: <not collected>
[10:59:33.044] Conditions captured: <none>
[10:59:33.044] Early signaling: FALSE
[10:59:33.044] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.044] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.051] Chunk #2 of 2 ... DONE
[10:59:33.051] Launching 2 futures (chunks) ... DONE
[10:59:33.051] Resolving 2 futures (chunks) ...
[10:59:33.051] resolve() on list ...
[10:59:33.052]  recursive: 0
[10:59:33.052]  length: 2
[10:59:33.052] 
[10:59:33.052] Future #1
[10:59:33.052] result() for MulticoreFuture ...
[10:59:33.053] result() for MulticoreFuture ...
[10:59:33.053] result() for MulticoreFuture ... done
[10:59:33.053] result() for MulticoreFuture ... done
[10:59:33.053] result() for MulticoreFuture ...
[10:59:33.054] result() for MulticoreFuture ... done
[10:59:33.054] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.054] - nx: 2
[10:59:33.054] - relay: TRUE
[10:59:33.054] - stdout: TRUE
[10:59:33.054] - signal: TRUE
[10:59:33.058] - resignal: FALSE
[10:59:33.058] - force: TRUE
[10:59:33.058] - relayed: [n=2] FALSE, FALSE
[10:59:33.059] - queued futures: [n=2] FALSE, FALSE
[10:59:33.059]  - until=1
[10:59:33.059]  - relaying element #1
[10:59:33.060] result() for MulticoreFuture ...
[10:59:33.060] result() for MulticoreFuture ... done
[10:59:33.060] result() for MulticoreFuture ...
[10:59:33.061] result() for MulticoreFuture ... done
[10:59:33.061] result() for MulticoreFuture ...
[10:59:33.061] result() for MulticoreFuture ... done
[10:59:33.061] result() for MulticoreFuture ...
[10:59:33.062] result() for MulticoreFuture ... done
[10:59:33.062] - relayed: [n=2] TRUE, FALSE
[10:59:33.062] - queued futures: [n=2] TRUE, FALSE
[10:59:33.062] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.063]  length: 1 (resolved future 1)
[10:59:33.063] Future #2
[10:59:33.063] result() for MulticoreFuture ...
[10:59:33.064] result() for MulticoreFuture ...
[10:59:33.064] result() for MulticoreFuture ... done
[10:59:33.065] result() for MulticoreFuture ... done
[10:59:33.065] result() for MulticoreFuture ...
[10:59:33.065] result() for MulticoreFuture ... done
[10:59:33.065] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.066] - nx: 2
[10:59:33.066] - relay: TRUE
[10:59:33.066] - stdout: TRUE
[10:59:33.066] - signal: TRUE
[10:59:33.066] - resignal: FALSE
[10:59:33.066] - force: TRUE
[10:59:33.066] - relayed: [n=2] TRUE, FALSE
[10:59:33.067] - queued futures: [n=2] TRUE, FALSE
[10:59:33.067]  - until=2
[10:59:33.067]  - relaying element #2
[10:59:33.067] result() for MulticoreFuture ...
[10:59:33.067] result() for MulticoreFuture ... done
[10:59:33.067] result() for MulticoreFuture ...
[10:59:33.068] result() for MulticoreFuture ... done
[10:59:33.068] result() for MulticoreFuture ...
[10:59:33.068] result() for MulticoreFuture ... done
[10:59:33.068] result() for MulticoreFuture ...
[10:59:33.068] result() for MulticoreFuture ... done
[10:59:33.068] - relayed: [n=2] TRUE, TRUE
[10:59:33.068] - queued futures: [n=2] TRUE, TRUE
[10:59:33.069] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.069]  length: 0 (resolved future 2)
[10:59:33.069] Relaying remaining futures
[10:59:33.069] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.069] - nx: 2
[10:59:33.069] - relay: TRUE
[10:59:33.069] - stdout: TRUE
[10:59:33.069] - signal: TRUE
[10:59:33.069] - resignal: FALSE
[10:59:33.070] - force: TRUE
[10:59:33.070] - relayed: [n=2] TRUE, TRUE
[10:59:33.070] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.070] - relayed: [n=2] TRUE, TRUE
[10:59:33.070] - queued futures: [n=2] TRUE, TRUE
[10:59:33.070] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.070] resolve() on list ... DONE
[10:59:33.070] result() for MulticoreFuture ...
[10:59:33.070] result() for MulticoreFuture ... done
[10:59:33.071] result() for MulticoreFuture ...
[10:59:33.071] result() for MulticoreFuture ... done
[10:59:33.071] result() for MulticoreFuture ...
[10:59:33.071] result() for MulticoreFuture ... done
[10:59:33.071] result() for MulticoreFuture ...
[10:59:33.071] result() for MulticoreFuture ... done
[10:59:33.071]  - Number of value chunks collected: 2
[10:59:33.071] Resolving 2 futures (chunks) ... DONE
[10:59:33.071] Reducing values from 2 chunks ...
[10:59:33.072]  - Number of values collected after concatenation: 5
[10:59:33.072]  - Number of values expected: 5
[10:59:33.072] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:59:33.072] Reducing values from 2 chunks ... DONE
[10:59:33.072] future_mapply() ... DONE
[10:59:33.072] future_mapply() ...
[10:59:33.074] Number of chunks: 2
[10:59:33.075] getGlobalsAndPackagesXApply() ...
[10:59:33.075]  - future.globals: TRUE
[10:59:33.075] getGlobalsAndPackages() ...
[10:59:33.075] Searching for globals...
[10:59:33.076] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:33.076] Searching for globals ... DONE
[10:59:33.077] Resolving globals: FALSE
[10:59:33.077] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:33.077] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:33.077] - globals: [1] ‘FUN’
[10:59:33.078] 
[10:59:33.078] getGlobalsAndPackages() ... DONE
[10:59:33.078]  - globals found/used: [n=1] ‘FUN’
[10:59:33.078]  - needed namespaces: [n=0] 
[10:59:33.078] Finding globals ... DONE
[10:59:33.078] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.078] List of 2
[10:59:33.078]  $ ...future.FUN:function (C, k)  
[10:59:33.078]  $ MoreArgs     : list()
[10:59:33.078]  - attr(*, "where")=List of 2
[10:59:33.078]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.078]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.078]  - attr(*, "resolved")= logi FALSE
[10:59:33.078]  - attr(*, "total_size")= num NA
[10:59:33.081] Packages to be attached in all futures: [n=0] 
[10:59:33.081] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.081] Number of futures (= number of chunks): 2
[10:59:33.081] Launching 2 futures (chunks) ...
[10:59:33.082] Chunk #1 of 2 ...
[10:59:33.082]  - Finding globals in '...' for chunk #1 ...
[10:59:33.082] getGlobalsAndPackages() ...
[10:59:33.082] Searching for globals...
[10:59:33.082] 
[10:59:33.082] Searching for globals ... DONE
[10:59:33.082] - globals: [0] <none>
[10:59:33.082] getGlobalsAndPackages() ... DONE
[10:59:33.083]    + additional globals found: [n=0] 
[10:59:33.083]    + additional namespaces needed: [n=0] 
[10:59:33.083]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.083]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.083]  - seeds: <none>
[10:59:33.083]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.083] getGlobalsAndPackages() ...
[10:59:33.085] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.085] Resolving globals: FALSE
[10:59:33.086] The total size of the 5 globals is 880 bytes (880 bytes)
[10:59:33.086] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:33.086] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.087] 
[10:59:33.087] getGlobalsAndPackages() ... DONE
[10:59:33.087] run() for ‘Future’ ...
[10:59:33.087] - state: ‘created’
[10:59:33.087] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.089]   - Field: ‘label’
[10:59:33.089]   - Field: ‘local’
[10:59:33.090]   - Field: ‘owner’
[10:59:33.090]   - Field: ‘envir’
[10:59:33.090]   - Field: ‘workers’
[10:59:33.090]   - Field: ‘packages’
[10:59:33.090]   - Field: ‘gc’
[10:59:33.090]   - Field: ‘job’
[10:59:33.090]   - Field: ‘conditions’
[10:59:33.090]   - Field: ‘expr’
[10:59:33.090]   - Field: ‘uuid’
[10:59:33.090]   - Field: ‘seed’
[10:59:33.091]   - Field: ‘version’
[10:59:33.091]   - Field: ‘result’
[10:59:33.091]   - Field: ‘asynchronous’
[10:59:33.091]   - Field: ‘calls’
[10:59:33.091]   - Field: ‘globals’
[10:59:33.091]   - Field: ‘stdout’
[10:59:33.091]   - Field: ‘earlySignal’
[10:59:33.091]   - Field: ‘lazy’
[10:59:33.091]   - Field: ‘state’
[10:59:33.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.092] - Launch lazy future ...
[10:59:33.092] Packages needed by the future expression (n = 0): <none>
[10:59:33.092] Packages needed by future strategies (n = 0): <none>
[10:59:33.092] {
[10:59:33.092]     {
[10:59:33.092]         {
[10:59:33.092]             ...future.startTime <- base::Sys.time()
[10:59:33.092]             {
[10:59:33.092]                 {
[10:59:33.092]                   {
[10:59:33.092]                     {
[10:59:33.092]                       base::local({
[10:59:33.092]                         has_future <- base::requireNamespace("future", 
[10:59:33.092]                           quietly = TRUE)
[10:59:33.092]                         if (has_future) {
[10:59:33.092]                           ns <- base::getNamespace("future")
[10:59:33.092]                           version <- ns[[".package"]][["version"]]
[10:59:33.092]                           if (is.null(version)) 
[10:59:33.092]                             version <- utils::packageVersion("future")
[10:59:33.092]                         }
[10:59:33.092]                         else {
[10:59:33.092]                           version <- NULL
[10:59:33.092]                         }
[10:59:33.092]                         if (!has_future || version < "1.8.0") {
[10:59:33.092]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.092]                             "", base::R.version$version.string), 
[10:59:33.092]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.092]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.092]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.092]                               "release", "version")], collapse = " "), 
[10:59:33.092]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.092]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.092]                             info)
[10:59:33.092]                           info <- base::paste(info, collapse = "; ")
[10:59:33.092]                           if (!has_future) {
[10:59:33.092]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.092]                               info)
[10:59:33.092]                           }
[10:59:33.092]                           else {
[10:59:33.092]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.092]                               info, version)
[10:59:33.092]                           }
[10:59:33.092]                           base::stop(msg)
[10:59:33.092]                         }
[10:59:33.092]                       })
[10:59:33.092]                     }
[10:59:33.092]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.092]                     base::options(mc.cores = 1L)
[10:59:33.092]                   }
[10:59:33.092]                   ...future.strategy.old <- future::plan("list")
[10:59:33.092]                   options(future.plan = NULL)
[10:59:33.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.092]                 }
[10:59:33.092]                 ...future.workdir <- getwd()
[10:59:33.092]             }
[10:59:33.092]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.092]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.092]         }
[10:59:33.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.092]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.092]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.092]             base::names(...future.oldOptions))
[10:59:33.092]     }
[10:59:33.092]     if (FALSE) {
[10:59:33.092]     }
[10:59:33.092]     else {
[10:59:33.092]         if (TRUE) {
[10:59:33.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.092]                 open = "w")
[10:59:33.092]         }
[10:59:33.092]         else {
[10:59:33.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.092]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.092]         }
[10:59:33.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.092]             base::sink(type = "output", split = FALSE)
[10:59:33.092]             base::close(...future.stdout)
[10:59:33.092]         }, add = TRUE)
[10:59:33.092]     }
[10:59:33.092]     ...future.frame <- base::sys.nframe()
[10:59:33.092]     ...future.conditions <- base::list()
[10:59:33.092]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.092]     if (FALSE) {
[10:59:33.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.092]     }
[10:59:33.092]     ...future.result <- base::tryCatch({
[10:59:33.092]         base::withCallingHandlers({
[10:59:33.092]             ...future.value <- base::withVisible(base::local({
[10:59:33.092]                 withCallingHandlers({
[10:59:33.092]                   {
[10:59:33.092]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.092]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.092]                       ...future.globals.maxSize)) {
[10:59:33.092]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.092]                       on.exit(options(oopts), add = TRUE)
[10:59:33.092]                     }
[10:59:33.092]                     {
[10:59:33.092]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.092]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.092]                         USE.NAMES = FALSE)
[10:59:33.092]                       do.call(mapply, args = args)
[10:59:33.092]                     }
[10:59:33.092]                   }
[10:59:33.092]                 }, immediateCondition = function(cond) {
[10:59:33.092]                   save_rds <- function (object, pathname, ...) 
[10:59:33.092]                   {
[10:59:33.092]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.092]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.092]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.092]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.092]                         fi_tmp[["mtime"]])
[10:59:33.092]                     }
[10:59:33.092]                     tryCatch({
[10:59:33.092]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.092]                     }, error = function(ex) {
[10:59:33.092]                       msg <- conditionMessage(ex)
[10:59:33.092]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.092]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.092]                         fi_tmp[["mtime"]], msg)
[10:59:33.092]                       ex$message <- msg
[10:59:33.092]                       stop(ex)
[10:59:33.092]                     })
[10:59:33.092]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.092]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.092]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.092]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.092]                       fi <- file.info(pathname)
[10:59:33.092]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.092]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.092]                         fi[["size"]], fi[["mtime"]])
[10:59:33.092]                       stop(msg)
[10:59:33.092]                     }
[10:59:33.092]                     invisible(pathname)
[10:59:33.092]                   }
[10:59:33.092]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.092]                     rootPath = tempdir()) 
[10:59:33.092]                   {
[10:59:33.092]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.092]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.092]                       tmpdir = path, fileext = ".rds")
[10:59:33.092]                     save_rds(obj, file)
[10:59:33.092]                   }
[10:59:33.092]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.092]                   {
[10:59:33.092]                     inherits <- base::inherits
[10:59:33.092]                     invokeRestart <- base::invokeRestart
[10:59:33.092]                     is.null <- base::is.null
[10:59:33.092]                     muffled <- FALSE
[10:59:33.092]                     if (inherits(cond, "message")) {
[10:59:33.092]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.092]                       if (muffled) 
[10:59:33.092]                         invokeRestart("muffleMessage")
[10:59:33.092]                     }
[10:59:33.092]                     else if (inherits(cond, "warning")) {
[10:59:33.092]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.092]                       if (muffled) 
[10:59:33.092]                         invokeRestart("muffleWarning")
[10:59:33.092]                     }
[10:59:33.092]                     else if (inherits(cond, "condition")) {
[10:59:33.092]                       if (!is.null(pattern)) {
[10:59:33.092]                         computeRestarts <- base::computeRestarts
[10:59:33.092]                         grepl <- base::grepl
[10:59:33.092]                         restarts <- computeRestarts(cond)
[10:59:33.092]                         for (restart in restarts) {
[10:59:33.092]                           name <- restart$name
[10:59:33.092]                           if (is.null(name)) 
[10:59:33.092]                             next
[10:59:33.092]                           if (!grepl(pattern, name)) 
[10:59:33.092]                             next
[10:59:33.092]                           invokeRestart(restart)
[10:59:33.092]                           muffled <- TRUE
[10:59:33.092]                           break
[10:59:33.092]                         }
[10:59:33.092]                       }
[10:59:33.092]                     }
[10:59:33.092]                     invisible(muffled)
[10:59:33.092]                   }
[10:59:33.092]                   muffleCondition(cond)
[10:59:33.092]                 })
[10:59:33.092]             }))
[10:59:33.092]             future::FutureResult(value = ...future.value$value, 
[10:59:33.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.092]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.092]                     ...future.globalenv.names))
[10:59:33.092]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.092]         }, condition = base::local({
[10:59:33.092]             c <- base::c
[10:59:33.092]             inherits <- base::inherits
[10:59:33.092]             invokeRestart <- base::invokeRestart
[10:59:33.092]             length <- base::length
[10:59:33.092]             list <- base::list
[10:59:33.092]             seq.int <- base::seq.int
[10:59:33.092]             signalCondition <- base::signalCondition
[10:59:33.092]             sys.calls <- base::sys.calls
[10:59:33.092]             `[[` <- base::`[[`
[10:59:33.092]             `+` <- base::`+`
[10:59:33.092]             `<<-` <- base::`<<-`
[10:59:33.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.092]                   3L)]
[10:59:33.092]             }
[10:59:33.092]             function(cond) {
[10:59:33.092]                 is_error <- inherits(cond, "error")
[10:59:33.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.092]                   NULL)
[10:59:33.092]                 if (is_error) {
[10:59:33.092]                   sessionInformation <- function() {
[10:59:33.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.092]                       search = base::search(), system = base::Sys.info())
[10:59:33.092]                   }
[10:59:33.092]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.092]                     cond$call), session = sessionInformation(), 
[10:59:33.092]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.092]                   signalCondition(cond)
[10:59:33.092]                 }
[10:59:33.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.092]                 "immediateCondition"))) {
[10:59:33.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.092]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.092]                   if (TRUE && !signal) {
[10:59:33.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.092]                     {
[10:59:33.092]                       inherits <- base::inherits
[10:59:33.092]                       invokeRestart <- base::invokeRestart
[10:59:33.092]                       is.null <- base::is.null
[10:59:33.092]                       muffled <- FALSE
[10:59:33.092]                       if (inherits(cond, "message")) {
[10:59:33.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.092]                         if (muffled) 
[10:59:33.092]                           invokeRestart("muffleMessage")
[10:59:33.092]                       }
[10:59:33.092]                       else if (inherits(cond, "warning")) {
[10:59:33.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.092]                         if (muffled) 
[10:59:33.092]                           invokeRestart("muffleWarning")
[10:59:33.092]                       }
[10:59:33.092]                       else if (inherits(cond, "condition")) {
[10:59:33.092]                         if (!is.null(pattern)) {
[10:59:33.092]                           computeRestarts <- base::computeRestarts
[10:59:33.092]                           grepl <- base::grepl
[10:59:33.092]                           restarts <- computeRestarts(cond)
[10:59:33.092]                           for (restart in restarts) {
[10:59:33.092]                             name <- restart$name
[10:59:33.092]                             if (is.null(name)) 
[10:59:33.092]                               next
[10:59:33.092]                             if (!grepl(pattern, name)) 
[10:59:33.092]                               next
[10:59:33.092]                             invokeRestart(restart)
[10:59:33.092]                             muffled <- TRUE
[10:59:33.092]                             break
[10:59:33.092]                           }
[10:59:33.092]                         }
[10:59:33.092]                       }
[10:59:33.092]                       invisible(muffled)
[10:59:33.092]                     }
[10:59:33.092]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.092]                   }
[10:59:33.092]                 }
[10:59:33.092]                 else {
[10:59:33.092]                   if (TRUE) {
[10:59:33.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.092]                     {
[10:59:33.092]                       inherits <- base::inherits
[10:59:33.092]                       invokeRestart <- base::invokeRestart
[10:59:33.092]                       is.null <- base::is.null
[10:59:33.092]                       muffled <- FALSE
[10:59:33.092]                       if (inherits(cond, "message")) {
[10:59:33.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.092]                         if (muffled) 
[10:59:33.092]                           invokeRestart("muffleMessage")
[10:59:33.092]                       }
[10:59:33.092]                       else if (inherits(cond, "warning")) {
[10:59:33.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.092]                         if (muffled) 
[10:59:33.092]                           invokeRestart("muffleWarning")
[10:59:33.092]                       }
[10:59:33.092]                       else if (inherits(cond, "condition")) {
[10:59:33.092]                         if (!is.null(pattern)) {
[10:59:33.092]                           computeRestarts <- base::computeRestarts
[10:59:33.092]                           grepl <- base::grepl
[10:59:33.092]                           restarts <- computeRestarts(cond)
[10:59:33.092]                           for (restart in restarts) {
[10:59:33.092]                             name <- restart$name
[10:59:33.092]                             if (is.null(name)) 
[10:59:33.092]                               next
[10:59:33.092]                             if (!grepl(pattern, name)) 
[10:59:33.092]                               next
[10:59:33.092]                             invokeRestart(restart)
[10:59:33.092]                             muffled <- TRUE
[10:59:33.092]                             break
[10:59:33.092]                           }
[10:59:33.092]                         }
[10:59:33.092]                       }
[10:59:33.092]                       invisible(muffled)
[10:59:33.092]                     }
[10:59:33.092]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.092]                   }
[10:59:33.092]                 }
[10:59:33.092]             }
[10:59:33.092]         }))
[10:59:33.092]     }, error = function(ex) {
[10:59:33.092]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.092]                 ...future.rng), started = ...future.startTime, 
[10:59:33.092]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.092]             version = "1.8"), class = "FutureResult")
[10:59:33.092]     }, finally = {
[10:59:33.092]         if (!identical(...future.workdir, getwd())) 
[10:59:33.092]             setwd(...future.workdir)
[10:59:33.092]         {
[10:59:33.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.092]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.092]             }
[10:59:33.092]             base::options(...future.oldOptions)
[10:59:33.092]             if (.Platform$OS.type == "windows") {
[10:59:33.092]                 old_names <- names(...future.oldEnvVars)
[10:59:33.092]                 envs <- base::Sys.getenv()
[10:59:33.092]                 names <- names(envs)
[10:59:33.092]                 common <- intersect(names, old_names)
[10:59:33.092]                 added <- setdiff(names, old_names)
[10:59:33.092]                 removed <- setdiff(old_names, names)
[10:59:33.092]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.092]                   envs[common]]
[10:59:33.092]                 NAMES <- toupper(changed)
[10:59:33.092]                 args <- list()
[10:59:33.092]                 for (kk in seq_along(NAMES)) {
[10:59:33.092]                   name <- changed[[kk]]
[10:59:33.092]                   NAME <- NAMES[[kk]]
[10:59:33.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.092]                     next
[10:59:33.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.092]                 }
[10:59:33.092]                 NAMES <- toupper(added)
[10:59:33.092]                 for (kk in seq_along(NAMES)) {
[10:59:33.092]                   name <- added[[kk]]
[10:59:33.092]                   NAME <- NAMES[[kk]]
[10:59:33.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.092]                     next
[10:59:33.092]                   args[[name]] <- ""
[10:59:33.092]                 }
[10:59:33.092]                 NAMES <- toupper(removed)
[10:59:33.092]                 for (kk in seq_along(NAMES)) {
[10:59:33.092]                   name <- removed[[kk]]
[10:59:33.092]                   NAME <- NAMES[[kk]]
[10:59:33.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.092]                     next
[10:59:33.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.092]                 }
[10:59:33.092]                 if (length(args) > 0) 
[10:59:33.092]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.092]             }
[10:59:33.092]             else {
[10:59:33.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.092]             }
[10:59:33.092]             {
[10:59:33.092]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.092]                   0L) {
[10:59:33.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.092]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.092]                   base::options(opts)
[10:59:33.092]                 }
[10:59:33.092]                 {
[10:59:33.092]                   {
[10:59:33.092]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.092]                     NULL
[10:59:33.092]                   }
[10:59:33.092]                   options(future.plan = NULL)
[10:59:33.092]                   if (is.na(NA_character_)) 
[10:59:33.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.092]                     .init = FALSE)
[10:59:33.092]                 }
[10:59:33.092]             }
[10:59:33.092]         }
[10:59:33.092]     })
[10:59:33.092]     if (TRUE) {
[10:59:33.092]         base::sink(type = "output", split = FALSE)
[10:59:33.092]         if (TRUE) {
[10:59:33.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.092]         }
[10:59:33.092]         else {
[10:59:33.092]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.092]         }
[10:59:33.092]         base::close(...future.stdout)
[10:59:33.092]         ...future.stdout <- NULL
[10:59:33.092]     }
[10:59:33.092]     ...future.result$conditions <- ...future.conditions
[10:59:33.092]     ...future.result$finished <- base::Sys.time()
[10:59:33.092]     ...future.result
[10:59:33.092] }
[10:59:33.095] assign_globals() ...
[10:59:33.095] List of 5
[10:59:33.095]  $ ...future.FUN            :function (C, k)  
[10:59:33.095]  $ MoreArgs                 : list()
[10:59:33.095]  $ ...future.elements_ii    :List of 2
[10:59:33.095]   ..$ :List of 2
[10:59:33.095]   .. ..$ : chr "A"
[10:59:33.095]   .. ..$ : chr "B"
[10:59:33.095]   ..$ :List of 2
[10:59:33.095]   .. ..$ : int 5
[10:59:33.095]   .. ..$ : int 4
[10:59:33.095]  $ ...future.seeds_ii       : NULL
[10:59:33.095]  $ ...future.globals.maxSize: NULL
[10:59:33.095]  - attr(*, "where")=List of 5
[10:59:33.095]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.095]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.095]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.095]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.095]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.095]  - attr(*, "resolved")= logi FALSE
[10:59:33.095]  - attr(*, "total_size")= num 880
[10:59:33.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.095]  - attr(*, "already-done")= logi TRUE
[10:59:33.100] - reassign environment for ‘...future.FUN’
[10:59:33.100] - copied ‘...future.FUN’ to environment
[10:59:33.100] - copied ‘MoreArgs’ to environment
[10:59:33.101] - copied ‘...future.elements_ii’ to environment
[10:59:33.101] - copied ‘...future.seeds_ii’ to environment
[10:59:33.101] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.101] assign_globals() ... done
[10:59:33.101] requestCore(): workers = 2
[10:59:33.103] MulticoreFuture started
[10:59:33.103] - Launch lazy future ... done
[10:59:33.104] run() for ‘MulticoreFuture’ ... done
[10:59:33.104] Created future:
[10:59:33.104] plan(): Setting new future strategy stack:
[10:59:33.104] List of future strategies:
[10:59:33.104] 1. sequential:
[10:59:33.104]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.104]    - tweaked: FALSE
[10:59:33.104]    - call: NULL
[10:59:33.105] plan(): nbrOfWorkers() = 1
[10:59:33.107] plan(): Setting new future strategy stack:
[10:59:33.108] List of future strategies:
[10:59:33.108] 1. multicore:
[10:59:33.108]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.108]    - tweaked: FALSE
[10:59:33.108]    - call: plan(strategy)
[10:59:33.111] plan(): nbrOfWorkers() = 2
[10:59:33.104] MulticoreFuture:
[10:59:33.104] Label: ‘future_.mapply-1’
[10:59:33.104] Expression:
[10:59:33.104] {
[10:59:33.104]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.104]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.104]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.104]         on.exit(options(oopts), add = TRUE)
[10:59:33.104]     }
[10:59:33.104]     {
[10:59:33.104]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.104]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.104]         do.call(mapply, args = args)
[10:59:33.104]     }
[10:59:33.104] }
[10:59:33.104] Lazy evaluation: FALSE
[10:59:33.104] Asynchronous evaluation: TRUE
[10:59:33.104] Local evaluation: TRUE
[10:59:33.104] Environment: R_GlobalEnv
[10:59:33.104] Capture standard output: TRUE
[10:59:33.104] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.104] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.104] Packages: <none>
[10:59:33.104] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.104] Resolved: TRUE
[10:59:33.104] Value: <not collected>
[10:59:33.104] Conditions captured: <none>
[10:59:33.104] Early signaling: FALSE
[10:59:33.104] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.104] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.112] Chunk #1 of 2 ... DONE
[10:59:33.112] Chunk #2 of 2 ...
[10:59:33.112]  - Finding globals in '...' for chunk #2 ...
[10:59:33.113] getGlobalsAndPackages() ...
[10:59:33.113] Searching for globals...
[10:59:33.113] 
[10:59:33.113] Searching for globals ... DONE
[10:59:33.113] - globals: [0] <none>
[10:59:33.114] getGlobalsAndPackages() ... DONE
[10:59:33.114]    + additional globals found: [n=0] 
[10:59:33.114]    + additional namespaces needed: [n=0] 
[10:59:33.114]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.114]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.114]  - seeds: <none>
[10:59:33.114]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.115] getGlobalsAndPackages() ...
[10:59:33.115] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.115] Resolving globals: FALSE
[10:59:33.116] The total size of the 5 globals is 909 bytes (909 bytes)
[10:59:33.116] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:33.116] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.117] 
[10:59:33.117] getGlobalsAndPackages() ... DONE
[10:59:33.121] run() for ‘Future’ ...
[10:59:33.121] - state: ‘created’
[10:59:33.122] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.125] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.126] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.126]   - Field: ‘label’
[10:59:33.126]   - Field: ‘local’
[10:59:33.126]   - Field: ‘owner’
[10:59:33.126]   - Field: ‘envir’
[10:59:33.127]   - Field: ‘workers’
[10:59:33.127]   - Field: ‘packages’
[10:59:33.127]   - Field: ‘gc’
[10:59:33.127]   - Field: ‘job’
[10:59:33.128]   - Field: ‘conditions’
[10:59:33.128]   - Field: ‘expr’
[10:59:33.128]   - Field: ‘uuid’
[10:59:33.128]   - Field: ‘seed’
[10:59:33.128]   - Field: ‘version’
[10:59:33.129]   - Field: ‘result’
[10:59:33.129]   - Field: ‘asynchronous’
[10:59:33.129]   - Field: ‘calls’
[10:59:33.129]   - Field: ‘globals’
[10:59:33.129]   - Field: ‘stdout’
[10:59:33.129]   - Field: ‘earlySignal’
[10:59:33.130]   - Field: ‘lazy’
[10:59:33.130]   - Field: ‘state’
[10:59:33.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.130] - Launch lazy future ...
[10:59:33.131] Packages needed by the future expression (n = 0): <none>
[10:59:33.131] Packages needed by future strategies (n = 0): <none>
[10:59:33.132] {
[10:59:33.132]     {
[10:59:33.132]         {
[10:59:33.132]             ...future.startTime <- base::Sys.time()
[10:59:33.132]             {
[10:59:33.132]                 {
[10:59:33.132]                   {
[10:59:33.132]                     {
[10:59:33.132]                       base::local({
[10:59:33.132]                         has_future <- base::requireNamespace("future", 
[10:59:33.132]                           quietly = TRUE)
[10:59:33.132]                         if (has_future) {
[10:59:33.132]                           ns <- base::getNamespace("future")
[10:59:33.132]                           version <- ns[[".package"]][["version"]]
[10:59:33.132]                           if (is.null(version)) 
[10:59:33.132]                             version <- utils::packageVersion("future")
[10:59:33.132]                         }
[10:59:33.132]                         else {
[10:59:33.132]                           version <- NULL
[10:59:33.132]                         }
[10:59:33.132]                         if (!has_future || version < "1.8.0") {
[10:59:33.132]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.132]                             "", base::R.version$version.string), 
[10:59:33.132]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.132]                               "release", "version")], collapse = " "), 
[10:59:33.132]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.132]                             info)
[10:59:33.132]                           info <- base::paste(info, collapse = "; ")
[10:59:33.132]                           if (!has_future) {
[10:59:33.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.132]                               info)
[10:59:33.132]                           }
[10:59:33.132]                           else {
[10:59:33.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.132]                               info, version)
[10:59:33.132]                           }
[10:59:33.132]                           base::stop(msg)
[10:59:33.132]                         }
[10:59:33.132]                       })
[10:59:33.132]                     }
[10:59:33.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.132]                     base::options(mc.cores = 1L)
[10:59:33.132]                   }
[10:59:33.132]                   ...future.strategy.old <- future::plan("list")
[10:59:33.132]                   options(future.plan = NULL)
[10:59:33.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.132]                 }
[10:59:33.132]                 ...future.workdir <- getwd()
[10:59:33.132]             }
[10:59:33.132]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.132]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.132]         }
[10:59:33.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.132]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.132]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.132]             base::names(...future.oldOptions))
[10:59:33.132]     }
[10:59:33.132]     if (FALSE) {
[10:59:33.132]     }
[10:59:33.132]     else {
[10:59:33.132]         if (TRUE) {
[10:59:33.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.132]                 open = "w")
[10:59:33.132]         }
[10:59:33.132]         else {
[10:59:33.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.132]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.132]         }
[10:59:33.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.132]             base::sink(type = "output", split = FALSE)
[10:59:33.132]             base::close(...future.stdout)
[10:59:33.132]         }, add = TRUE)
[10:59:33.132]     }
[10:59:33.132]     ...future.frame <- base::sys.nframe()
[10:59:33.132]     ...future.conditions <- base::list()
[10:59:33.132]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.132]     if (FALSE) {
[10:59:33.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.132]     }
[10:59:33.132]     ...future.result <- base::tryCatch({
[10:59:33.132]         base::withCallingHandlers({
[10:59:33.132]             ...future.value <- base::withVisible(base::local({
[10:59:33.132]                 withCallingHandlers({
[10:59:33.132]                   {
[10:59:33.132]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.132]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.132]                       ...future.globals.maxSize)) {
[10:59:33.132]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.132]                       on.exit(options(oopts), add = TRUE)
[10:59:33.132]                     }
[10:59:33.132]                     {
[10:59:33.132]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.132]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.132]                         USE.NAMES = FALSE)
[10:59:33.132]                       do.call(mapply, args = args)
[10:59:33.132]                     }
[10:59:33.132]                   }
[10:59:33.132]                 }, immediateCondition = function(cond) {
[10:59:33.132]                   save_rds <- function (object, pathname, ...) 
[10:59:33.132]                   {
[10:59:33.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.132]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.132]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.132]                         fi_tmp[["mtime"]])
[10:59:33.132]                     }
[10:59:33.132]                     tryCatch({
[10:59:33.132]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.132]                     }, error = function(ex) {
[10:59:33.132]                       msg <- conditionMessage(ex)
[10:59:33.132]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.132]                         fi_tmp[["mtime"]], msg)
[10:59:33.132]                       ex$message <- msg
[10:59:33.132]                       stop(ex)
[10:59:33.132]                     })
[10:59:33.132]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.132]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.132]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.132]                       fi <- file.info(pathname)
[10:59:33.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.132]                         fi[["size"]], fi[["mtime"]])
[10:59:33.132]                       stop(msg)
[10:59:33.132]                     }
[10:59:33.132]                     invisible(pathname)
[10:59:33.132]                   }
[10:59:33.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.132]                     rootPath = tempdir()) 
[10:59:33.132]                   {
[10:59:33.132]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.132]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.132]                       tmpdir = path, fileext = ".rds")
[10:59:33.132]                     save_rds(obj, file)
[10:59:33.132]                   }
[10:59:33.132]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.132]                   {
[10:59:33.132]                     inherits <- base::inherits
[10:59:33.132]                     invokeRestart <- base::invokeRestart
[10:59:33.132]                     is.null <- base::is.null
[10:59:33.132]                     muffled <- FALSE
[10:59:33.132]                     if (inherits(cond, "message")) {
[10:59:33.132]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.132]                       if (muffled) 
[10:59:33.132]                         invokeRestart("muffleMessage")
[10:59:33.132]                     }
[10:59:33.132]                     else if (inherits(cond, "warning")) {
[10:59:33.132]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.132]                       if (muffled) 
[10:59:33.132]                         invokeRestart("muffleWarning")
[10:59:33.132]                     }
[10:59:33.132]                     else if (inherits(cond, "condition")) {
[10:59:33.132]                       if (!is.null(pattern)) {
[10:59:33.132]                         computeRestarts <- base::computeRestarts
[10:59:33.132]                         grepl <- base::grepl
[10:59:33.132]                         restarts <- computeRestarts(cond)
[10:59:33.132]                         for (restart in restarts) {
[10:59:33.132]                           name <- restart$name
[10:59:33.132]                           if (is.null(name)) 
[10:59:33.132]                             next
[10:59:33.132]                           if (!grepl(pattern, name)) 
[10:59:33.132]                             next
[10:59:33.132]                           invokeRestart(restart)
[10:59:33.132]                           muffled <- TRUE
[10:59:33.132]                           break
[10:59:33.132]                         }
[10:59:33.132]                       }
[10:59:33.132]                     }
[10:59:33.132]                     invisible(muffled)
[10:59:33.132]                   }
[10:59:33.132]                   muffleCondition(cond)
[10:59:33.132]                 })
[10:59:33.132]             }))
[10:59:33.132]             future::FutureResult(value = ...future.value$value, 
[10:59:33.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.132]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.132]                     ...future.globalenv.names))
[10:59:33.132]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.132]         }, condition = base::local({
[10:59:33.132]             c <- base::c
[10:59:33.132]             inherits <- base::inherits
[10:59:33.132]             invokeRestart <- base::invokeRestart
[10:59:33.132]             length <- base::length
[10:59:33.132]             list <- base::list
[10:59:33.132]             seq.int <- base::seq.int
[10:59:33.132]             signalCondition <- base::signalCondition
[10:59:33.132]             sys.calls <- base::sys.calls
[10:59:33.132]             `[[` <- base::`[[`
[10:59:33.132]             `+` <- base::`+`
[10:59:33.132]             `<<-` <- base::`<<-`
[10:59:33.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.132]                   3L)]
[10:59:33.132]             }
[10:59:33.132]             function(cond) {
[10:59:33.132]                 is_error <- inherits(cond, "error")
[10:59:33.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.132]                   NULL)
[10:59:33.132]                 if (is_error) {
[10:59:33.132]                   sessionInformation <- function() {
[10:59:33.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.132]                       search = base::search(), system = base::Sys.info())
[10:59:33.132]                   }
[10:59:33.132]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.132]                     cond$call), session = sessionInformation(), 
[10:59:33.132]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.132]                   signalCondition(cond)
[10:59:33.132]                 }
[10:59:33.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.132]                 "immediateCondition"))) {
[10:59:33.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.132]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.132]                   if (TRUE && !signal) {
[10:59:33.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.132]                     {
[10:59:33.132]                       inherits <- base::inherits
[10:59:33.132]                       invokeRestart <- base::invokeRestart
[10:59:33.132]                       is.null <- base::is.null
[10:59:33.132]                       muffled <- FALSE
[10:59:33.132]                       if (inherits(cond, "message")) {
[10:59:33.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.132]                         if (muffled) 
[10:59:33.132]                           invokeRestart("muffleMessage")
[10:59:33.132]                       }
[10:59:33.132]                       else if (inherits(cond, "warning")) {
[10:59:33.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.132]                         if (muffled) 
[10:59:33.132]                           invokeRestart("muffleWarning")
[10:59:33.132]                       }
[10:59:33.132]                       else if (inherits(cond, "condition")) {
[10:59:33.132]                         if (!is.null(pattern)) {
[10:59:33.132]                           computeRestarts <- base::computeRestarts
[10:59:33.132]                           grepl <- base::grepl
[10:59:33.132]                           restarts <- computeRestarts(cond)
[10:59:33.132]                           for (restart in restarts) {
[10:59:33.132]                             name <- restart$name
[10:59:33.132]                             if (is.null(name)) 
[10:59:33.132]                               next
[10:59:33.132]                             if (!grepl(pattern, name)) 
[10:59:33.132]                               next
[10:59:33.132]                             invokeRestart(restart)
[10:59:33.132]                             muffled <- TRUE
[10:59:33.132]                             break
[10:59:33.132]                           }
[10:59:33.132]                         }
[10:59:33.132]                       }
[10:59:33.132]                       invisible(muffled)
[10:59:33.132]                     }
[10:59:33.132]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.132]                   }
[10:59:33.132]                 }
[10:59:33.132]                 else {
[10:59:33.132]                   if (TRUE) {
[10:59:33.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.132]                     {
[10:59:33.132]                       inherits <- base::inherits
[10:59:33.132]                       invokeRestart <- base::invokeRestart
[10:59:33.132]                       is.null <- base::is.null
[10:59:33.132]                       muffled <- FALSE
[10:59:33.132]                       if (inherits(cond, "message")) {
[10:59:33.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.132]                         if (muffled) 
[10:59:33.132]                           invokeRestart("muffleMessage")
[10:59:33.132]                       }
[10:59:33.132]                       else if (inherits(cond, "warning")) {
[10:59:33.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.132]                         if (muffled) 
[10:59:33.132]                           invokeRestart("muffleWarning")
[10:59:33.132]                       }
[10:59:33.132]                       else if (inherits(cond, "condition")) {
[10:59:33.132]                         if (!is.null(pattern)) {
[10:59:33.132]                           computeRestarts <- base::computeRestarts
[10:59:33.132]                           grepl <- base::grepl
[10:59:33.132]                           restarts <- computeRestarts(cond)
[10:59:33.132]                           for (restart in restarts) {
[10:59:33.132]                             name <- restart$name
[10:59:33.132]                             if (is.null(name)) 
[10:59:33.132]                               next
[10:59:33.132]                             if (!grepl(pattern, name)) 
[10:59:33.132]                               next
[10:59:33.132]                             invokeRestart(restart)
[10:59:33.132]                             muffled <- TRUE
[10:59:33.132]                             break
[10:59:33.132]                           }
[10:59:33.132]                         }
[10:59:33.132]                       }
[10:59:33.132]                       invisible(muffled)
[10:59:33.132]                     }
[10:59:33.132]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.132]                   }
[10:59:33.132]                 }
[10:59:33.132]             }
[10:59:33.132]         }))
[10:59:33.132]     }, error = function(ex) {
[10:59:33.132]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.132]                 ...future.rng), started = ...future.startTime, 
[10:59:33.132]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.132]             version = "1.8"), class = "FutureResult")
[10:59:33.132]     }, finally = {
[10:59:33.132]         if (!identical(...future.workdir, getwd())) 
[10:59:33.132]             setwd(...future.workdir)
[10:59:33.132]         {
[10:59:33.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.132]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.132]             }
[10:59:33.132]             base::options(...future.oldOptions)
[10:59:33.132]             if (.Platform$OS.type == "windows") {
[10:59:33.132]                 old_names <- names(...future.oldEnvVars)
[10:59:33.132]                 envs <- base::Sys.getenv()
[10:59:33.132]                 names <- names(envs)
[10:59:33.132]                 common <- intersect(names, old_names)
[10:59:33.132]                 added <- setdiff(names, old_names)
[10:59:33.132]                 removed <- setdiff(old_names, names)
[10:59:33.132]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.132]                   envs[common]]
[10:59:33.132]                 NAMES <- toupper(changed)
[10:59:33.132]                 args <- list()
[10:59:33.132]                 for (kk in seq_along(NAMES)) {
[10:59:33.132]                   name <- changed[[kk]]
[10:59:33.132]                   NAME <- NAMES[[kk]]
[10:59:33.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.132]                     next
[10:59:33.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.132]                 }
[10:59:33.132]                 NAMES <- toupper(added)
[10:59:33.132]                 for (kk in seq_along(NAMES)) {
[10:59:33.132]                   name <- added[[kk]]
[10:59:33.132]                   NAME <- NAMES[[kk]]
[10:59:33.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.132]                     next
[10:59:33.132]                   args[[name]] <- ""
[10:59:33.132]                 }
[10:59:33.132]                 NAMES <- toupper(removed)
[10:59:33.132]                 for (kk in seq_along(NAMES)) {
[10:59:33.132]                   name <- removed[[kk]]
[10:59:33.132]                   NAME <- NAMES[[kk]]
[10:59:33.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.132]                     next
[10:59:33.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.132]                 }
[10:59:33.132]                 if (length(args) > 0) 
[10:59:33.132]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.132]             }
[10:59:33.132]             else {
[10:59:33.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.132]             }
[10:59:33.132]             {
[10:59:33.132]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.132]                   0L) {
[10:59:33.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.132]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.132]                   base::options(opts)
[10:59:33.132]                 }
[10:59:33.132]                 {
[10:59:33.132]                   {
[10:59:33.132]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.132]                     NULL
[10:59:33.132]                   }
[10:59:33.132]                   options(future.plan = NULL)
[10:59:33.132]                   if (is.na(NA_character_)) 
[10:59:33.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.132]                     .init = FALSE)
[10:59:33.132]                 }
[10:59:33.132]             }
[10:59:33.132]         }
[10:59:33.132]     })
[10:59:33.132]     if (TRUE) {
[10:59:33.132]         base::sink(type = "output", split = FALSE)
[10:59:33.132]         if (TRUE) {
[10:59:33.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.132]         }
[10:59:33.132]         else {
[10:59:33.132]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.132]         }
[10:59:33.132]         base::close(...future.stdout)
[10:59:33.132]         ...future.stdout <- NULL
[10:59:33.132]     }
[10:59:33.132]     ...future.result$conditions <- ...future.conditions
[10:59:33.132]     ...future.result$finished <- base::Sys.time()
[10:59:33.132]     ...future.result
[10:59:33.132] }
[10:59:33.135] assign_globals() ...
[10:59:33.135] List of 5
[10:59:33.135]  $ ...future.FUN            :function (C, k)  
[10:59:33.135]  $ MoreArgs                 : list()
[10:59:33.135]  $ ...future.elements_ii    :List of 2
[10:59:33.135]   ..$ :List of 3
[10:59:33.135]   .. ..$ : chr "C"
[10:59:33.135]   .. ..$ : chr "D"
[10:59:33.135]   .. ..$ : chr "E"
[10:59:33.135]   ..$ :List of 3
[10:59:33.135]   .. ..$ : int 3
[10:59:33.135]   .. ..$ : int 2
[10:59:33.135]   .. ..$ : int 1
[10:59:33.135]  $ ...future.seeds_ii       : NULL
[10:59:33.135]  $ ...future.globals.maxSize: NULL
[10:59:33.135]  - attr(*, "where")=List of 5
[10:59:33.135]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.135]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.135]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.135]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.135]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.135]  - attr(*, "resolved")= logi FALSE
[10:59:33.135]  - attr(*, "total_size")= num 909
[10:59:33.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.135]  - attr(*, "already-done")= logi TRUE
[10:59:33.142] - reassign environment for ‘...future.FUN’
[10:59:33.143] - copied ‘...future.FUN’ to environment
[10:59:33.143] - copied ‘MoreArgs’ to environment
[10:59:33.143] - copied ‘...future.elements_ii’ to environment
[10:59:33.143] - copied ‘...future.seeds_ii’ to environment
[10:59:33.143] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.143] assign_globals() ... done
[10:59:33.143] requestCore(): workers = 2
[10:59:33.145] MulticoreFuture started
[10:59:33.146] - Launch lazy future ... done
[10:59:33.146] run() for ‘MulticoreFuture’ ... done
[10:59:33.146] Created future:
[10:59:33.146] plan(): Setting new future strategy stack:
[10:59:33.147] List of future strategies:
[10:59:33.147] 1. sequential:
[10:59:33.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.147]    - tweaked: FALSE
[10:59:33.147]    - call: NULL
[10:59:33.148] plan(): nbrOfWorkers() = 1
[10:59:33.150] plan(): Setting new future strategy stack:
[10:59:33.150] List of future strategies:
[10:59:33.150] 1. multicore:
[10:59:33.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.150]    - tweaked: FALSE
[10:59:33.150]    - call: plan(strategy)
[10:59:33.153] plan(): nbrOfWorkers() = 2
[10:59:33.147] MulticoreFuture:
[10:59:33.147] Label: ‘future_.mapply-2’
[10:59:33.147] Expression:
[10:59:33.147] {
[10:59:33.147]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.147]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.147]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.147]         on.exit(options(oopts), add = TRUE)
[10:59:33.147]     }
[10:59:33.147]     {
[10:59:33.147]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.147]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.147]         do.call(mapply, args = args)
[10:59:33.147]     }
[10:59:33.147] }
[10:59:33.147] Lazy evaluation: FALSE
[10:59:33.147] Asynchronous evaluation: TRUE
[10:59:33.147] Local evaluation: TRUE
[10:59:33.147] Environment: R_GlobalEnv
[10:59:33.147] Capture standard output: TRUE
[10:59:33.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.147] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.147] Packages: <none>
[10:59:33.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.147] Resolved: TRUE
[10:59:33.147] Value: <not collected>
[10:59:33.147] Conditions captured: <none>
[10:59:33.147] Early signaling: FALSE
[10:59:33.147] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.147] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.154] Chunk #2 of 2 ... DONE
[10:59:33.155] Launching 2 futures (chunks) ... DONE
[10:59:33.155] Resolving 2 futures (chunks) ...
[10:59:33.155] resolve() on list ...
[10:59:33.155]  recursive: 0
[10:59:33.155]  length: 2
[10:59:33.155] 
[10:59:33.156] Future #1
[10:59:33.156] result() for MulticoreFuture ...
[10:59:33.157] result() for MulticoreFuture ...
[10:59:33.157] result() for MulticoreFuture ... done
[10:59:33.157] result() for MulticoreFuture ... done
[10:59:33.157] result() for MulticoreFuture ...
[10:59:33.157] result() for MulticoreFuture ... done
[10:59:33.157] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.157] - nx: 2
[10:59:33.158] - relay: TRUE
[10:59:33.158] - stdout: TRUE
[10:59:33.158] - signal: TRUE
[10:59:33.158] - resignal: FALSE
[10:59:33.158] - force: TRUE
[10:59:33.158] - relayed: [n=2] FALSE, FALSE
[10:59:33.158] - queued futures: [n=2] FALSE, FALSE
[10:59:33.159]  - until=1
[10:59:33.159]  - relaying element #1
[10:59:33.159] result() for MulticoreFuture ...
[10:59:33.159] result() for MulticoreFuture ... done
[10:59:33.159] result() for MulticoreFuture ...
[10:59:33.159] result() for MulticoreFuture ... done
[10:59:33.159] result() for MulticoreFuture ...
[10:59:33.160] result() for MulticoreFuture ... done
[10:59:33.160] result() for MulticoreFuture ...
[10:59:33.163] result() for MulticoreFuture ... done
[10:59:33.164] - relayed: [n=2] TRUE, FALSE
[10:59:33.164] - queued futures: [n=2] TRUE, FALSE
[10:59:33.164] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.165]  length: 1 (resolved future 1)
[10:59:33.165] Future #2
[10:59:33.165] result() for MulticoreFuture ...
[10:59:33.166] result() for MulticoreFuture ...
[10:59:33.167] result() for MulticoreFuture ... done
[10:59:33.167] result() for MulticoreFuture ... done
[10:59:33.167] result() for MulticoreFuture ...
[10:59:33.167] result() for MulticoreFuture ... done
[10:59:33.167] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.168] - nx: 2
[10:59:33.168] - relay: TRUE
[10:59:33.168] - stdout: TRUE
[10:59:33.168] - signal: TRUE
[10:59:33.168] - resignal: FALSE
[10:59:33.168] - force: TRUE
[10:59:33.169] - relayed: [n=2] TRUE, FALSE
[10:59:33.169] - queued futures: [n=2] TRUE, FALSE
[10:59:33.169]  - until=2
[10:59:33.169]  - relaying element #2
[10:59:33.169] result() for MulticoreFuture ...
[10:59:33.169] result() for MulticoreFuture ... done
[10:59:33.169] result() for MulticoreFuture ...
[10:59:33.169] result() for MulticoreFuture ... done
[10:59:33.170] result() for MulticoreFuture ...
[10:59:33.170] result() for MulticoreFuture ... done
[10:59:33.170] result() for MulticoreFuture ...
[10:59:33.170] result() for MulticoreFuture ... done
[10:59:33.170] - relayed: [n=2] TRUE, TRUE
[10:59:33.170] - queued futures: [n=2] TRUE, TRUE
[10:59:33.170] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.171]  length: 0 (resolved future 2)
[10:59:33.171] Relaying remaining futures
[10:59:33.171] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.171] - nx: 2
[10:59:33.171] - relay: TRUE
[10:59:33.171] - stdout: TRUE
[10:59:33.171] - signal: TRUE
[10:59:33.171] - resignal: FALSE
[10:59:33.172] - force: TRUE
[10:59:33.172] - relayed: [n=2] TRUE, TRUE
[10:59:33.172] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.172] - relayed: [n=2] TRUE, TRUE
[10:59:33.172] - queued futures: [n=2] TRUE, TRUE
[10:59:33.172] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.172] resolve() on list ... DONE
[10:59:33.172] result() for MulticoreFuture ...
[10:59:33.173] result() for MulticoreFuture ... done
[10:59:33.173] result() for MulticoreFuture ...
[10:59:33.173] result() for MulticoreFuture ... done
[10:59:33.173] result() for MulticoreFuture ...
[10:59:33.173] result() for MulticoreFuture ... done
[10:59:33.173] result() for MulticoreFuture ...
[10:59:33.173] result() for MulticoreFuture ... done
[10:59:33.173]  - Number of value chunks collected: 2
[10:59:33.173] Resolving 2 futures (chunks) ... DONE
[10:59:33.174] Reducing values from 2 chunks ...
[10:59:33.174]  - Number of values collected after concatenation: 5
[10:59:33.174]  - Number of values expected: 5
[10:59:33.174] Reducing values from 2 chunks ... DONE
[10:59:33.174] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:59:33.174] future_mapply() ...
[10:59:33.176] Number of chunks: 1
[10:59:33.176] getGlobalsAndPackagesXApply() ...
[10:59:33.176]  - future.globals: TRUE
[10:59:33.176] getGlobalsAndPackages() ...
[10:59:33.177] Searching for globals...
[10:59:33.178] - globals found: [1] ‘FUN’
[10:59:33.178] Searching for globals ... DONE
[10:59:33.178] Resolving globals: FALSE
[10:59:33.178] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:33.179] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:33.179] - globals: [1] ‘FUN’
[10:59:33.179] 
[10:59:33.179] getGlobalsAndPackages() ... DONE
[10:59:33.179]  - globals found/used: [n=1] ‘FUN’
[10:59:33.179]  - needed namespaces: [n=0] 
[10:59:33.179] Finding globals ... DONE
[10:59:33.179] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.179] List of 2
[10:59:33.179]  $ ...future.FUN:function (x)  
[10:59:33.179]  $ MoreArgs     : NULL
[10:59:33.179]  - attr(*, "where")=List of 2
[10:59:33.179]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.179]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.179]  - attr(*, "resolved")= logi FALSE
[10:59:33.179]  - attr(*, "total_size")= num NA
[10:59:33.182] Packages to be attached in all futures: [n=0] 
[10:59:33.182] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.182] Number of futures (= number of chunks): 1
[10:59:33.182] Launching 1 futures (chunks) ...
[10:59:33.183] Chunk #1 of 1 ...
[10:59:33.183]  - Finding globals in '...' for chunk #1 ...
[10:59:33.183] getGlobalsAndPackages() ...
[10:59:33.183] Searching for globals...
[10:59:33.183] 
[10:59:33.183] Searching for globals ... DONE
[10:59:33.183] - globals: [0] <none>
[10:59:33.183] getGlobalsAndPackages() ... DONE
[10:59:33.183]    + additional globals found: [n=0] 
[10:59:33.184]    + additional namespaces needed: [n=0] 
[10:59:33.184]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.184]  - seeds: <none>
[10:59:33.184]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.184] getGlobalsAndPackages() ...
[10:59:33.184] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.184] Resolving globals: FALSE
[10:59:33.185] The total size of the 5 globals is 366 bytes (366 bytes)
[10:59:33.185] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.185] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.185] 
[10:59:33.185] getGlobalsAndPackages() ... DONE
[10:59:33.186] run() for ‘Future’ ...
[10:59:33.186] - state: ‘created’
[10:59:33.186] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.189] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.189]   - Field: ‘label’
[10:59:33.189]   - Field: ‘local’
[10:59:33.190]   - Field: ‘owner’
[10:59:33.190]   - Field: ‘envir’
[10:59:33.190]   - Field: ‘workers’
[10:59:33.190]   - Field: ‘packages’
[10:59:33.190]   - Field: ‘gc’
[10:59:33.190]   - Field: ‘job’
[10:59:33.190]   - Field: ‘conditions’
[10:59:33.190]   - Field: ‘expr’
[10:59:33.190]   - Field: ‘uuid’
[10:59:33.190]   - Field: ‘seed’
[10:59:33.190]   - Field: ‘version’
[10:59:33.190]   - Field: ‘result’
[10:59:33.191]   - Field: ‘asynchronous’
[10:59:33.191]   - Field: ‘calls’
[10:59:33.191]   - Field: ‘globals’
[10:59:33.191]   - Field: ‘stdout’
[10:59:33.191]   - Field: ‘earlySignal’
[10:59:33.191]   - Field: ‘lazy’
[10:59:33.191]   - Field: ‘state’
[10:59:33.191] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.191] - Launch lazy future ...
[10:59:33.192] Packages needed by the future expression (n = 0): <none>
[10:59:33.192] Packages needed by future strategies (n = 0): <none>
[10:59:33.192] {
[10:59:33.192]     {
[10:59:33.192]         {
[10:59:33.192]             ...future.startTime <- base::Sys.time()
[10:59:33.192]             {
[10:59:33.192]                 {
[10:59:33.192]                   {
[10:59:33.192]                     {
[10:59:33.192]                       base::local({
[10:59:33.192]                         has_future <- base::requireNamespace("future", 
[10:59:33.192]                           quietly = TRUE)
[10:59:33.192]                         if (has_future) {
[10:59:33.192]                           ns <- base::getNamespace("future")
[10:59:33.192]                           version <- ns[[".package"]][["version"]]
[10:59:33.192]                           if (is.null(version)) 
[10:59:33.192]                             version <- utils::packageVersion("future")
[10:59:33.192]                         }
[10:59:33.192]                         else {
[10:59:33.192]                           version <- NULL
[10:59:33.192]                         }
[10:59:33.192]                         if (!has_future || version < "1.8.0") {
[10:59:33.192]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.192]                             "", base::R.version$version.string), 
[10:59:33.192]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.192]                               "release", "version")], collapse = " "), 
[10:59:33.192]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.192]                             info)
[10:59:33.192]                           info <- base::paste(info, collapse = "; ")
[10:59:33.192]                           if (!has_future) {
[10:59:33.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.192]                               info)
[10:59:33.192]                           }
[10:59:33.192]                           else {
[10:59:33.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.192]                               info, version)
[10:59:33.192]                           }
[10:59:33.192]                           base::stop(msg)
[10:59:33.192]                         }
[10:59:33.192]                       })
[10:59:33.192]                     }
[10:59:33.192]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.192]                     base::options(mc.cores = 1L)
[10:59:33.192]                   }
[10:59:33.192]                   ...future.strategy.old <- future::plan("list")
[10:59:33.192]                   options(future.plan = NULL)
[10:59:33.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.192]                 }
[10:59:33.192]                 ...future.workdir <- getwd()
[10:59:33.192]             }
[10:59:33.192]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.192]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.192]         }
[10:59:33.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:33.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.192]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.192]             base::names(...future.oldOptions))
[10:59:33.192]     }
[10:59:33.192]     if (FALSE) {
[10:59:33.192]     }
[10:59:33.192]     else {
[10:59:33.192]         if (TRUE) {
[10:59:33.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.192]                 open = "w")
[10:59:33.192]         }
[10:59:33.192]         else {
[10:59:33.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.192]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.192]         }
[10:59:33.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.192]             base::sink(type = "output", split = FALSE)
[10:59:33.192]             base::close(...future.stdout)
[10:59:33.192]         }, add = TRUE)
[10:59:33.192]     }
[10:59:33.192]     ...future.frame <- base::sys.nframe()
[10:59:33.192]     ...future.conditions <- base::list()
[10:59:33.192]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.192]     if (FALSE) {
[10:59:33.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.192]     }
[10:59:33.192]     ...future.result <- base::tryCatch({
[10:59:33.192]         base::withCallingHandlers({
[10:59:33.192]             ...future.value <- base::withVisible(base::local({
[10:59:33.192]                 withCallingHandlers({
[10:59:33.192]                   {
[10:59:33.192]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.192]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.192]                       ...future.globals.maxSize)) {
[10:59:33.192]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.192]                       on.exit(options(oopts), add = TRUE)
[10:59:33.192]                     }
[10:59:33.192]                     {
[10:59:33.192]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.192]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.192]                         USE.NAMES = FALSE)
[10:59:33.192]                       do.call(mapply, args = args)
[10:59:33.192]                     }
[10:59:33.192]                   }
[10:59:33.192]                 }, immediateCondition = function(cond) {
[10:59:33.192]                   save_rds <- function (object, pathname, ...) 
[10:59:33.192]                   {
[10:59:33.192]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.192]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.192]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.192]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.192]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.192]                         fi_tmp[["mtime"]])
[10:59:33.192]                     }
[10:59:33.192]                     tryCatch({
[10:59:33.192]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.192]                     }, error = function(ex) {
[10:59:33.192]                       msg <- conditionMessage(ex)
[10:59:33.192]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.192]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.192]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.192]                         fi_tmp[["mtime"]], msg)
[10:59:33.192]                       ex$message <- msg
[10:59:33.192]                       stop(ex)
[10:59:33.192]                     })
[10:59:33.192]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.192]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.192]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.192]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.192]                       fi <- file.info(pathname)
[10:59:33.192]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.192]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.192]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.192]                         fi[["size"]], fi[["mtime"]])
[10:59:33.192]                       stop(msg)
[10:59:33.192]                     }
[10:59:33.192]                     invisible(pathname)
[10:59:33.192]                   }
[10:59:33.192]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.192]                     rootPath = tempdir()) 
[10:59:33.192]                   {
[10:59:33.192]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.192]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.192]                       tmpdir = path, fileext = ".rds")
[10:59:33.192]                     save_rds(obj, file)
[10:59:33.192]                   }
[10:59:33.192]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.192]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.192]                   {
[10:59:33.192]                     inherits <- base::inherits
[10:59:33.192]                     invokeRestart <- base::invokeRestart
[10:59:33.192]                     is.null <- base::is.null
[10:59:33.192]                     muffled <- FALSE
[10:59:33.192]                     if (inherits(cond, "message")) {
[10:59:33.192]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.192]                       if (muffled) 
[10:59:33.192]                         invokeRestart("muffleMessage")
[10:59:33.192]                     }
[10:59:33.192]                     else if (inherits(cond, "warning")) {
[10:59:33.192]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.192]                       if (muffled) 
[10:59:33.192]                         invokeRestart("muffleWarning")
[10:59:33.192]                     }
[10:59:33.192]                     else if (inherits(cond, "condition")) {
[10:59:33.192]                       if (!is.null(pattern)) {
[10:59:33.192]                         computeRestarts <- base::computeRestarts
[10:59:33.192]                         grepl <- base::grepl
[10:59:33.192]                         restarts <- computeRestarts(cond)
[10:59:33.192]                         for (restart in restarts) {
[10:59:33.192]                           name <- restart$name
[10:59:33.192]                           if (is.null(name)) 
[10:59:33.192]                             next
[10:59:33.192]                           if (!grepl(pattern, name)) 
[10:59:33.192]                             next
[10:59:33.192]                           invokeRestart(restart)
[10:59:33.192]                           muffled <- TRUE
[10:59:33.192]                           break
[10:59:33.192]                         }
[10:59:33.192]                       }
[10:59:33.192]                     }
[10:59:33.192]                     invisible(muffled)
[10:59:33.192]                   }
[10:59:33.192]                   muffleCondition(cond)
[10:59:33.192]                 })
[10:59:33.192]             }))
[10:59:33.192]             future::FutureResult(value = ...future.value$value, 
[10:59:33.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.192]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.192]                     ...future.globalenv.names))
[10:59:33.192]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.192]         }, condition = base::local({
[10:59:33.192]             c <- base::c
[10:59:33.192]             inherits <- base::inherits
[10:59:33.192]             invokeRestart <- base::invokeRestart
[10:59:33.192]             length <- base::length
[10:59:33.192]             list <- base::list
[10:59:33.192]             seq.int <- base::seq.int
[10:59:33.192]             signalCondition <- base::signalCondition
[10:59:33.192]             sys.calls <- base::sys.calls
[10:59:33.192]             `[[` <- base::`[[`
[10:59:33.192]             `+` <- base::`+`
[10:59:33.192]             `<<-` <- base::`<<-`
[10:59:33.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.192]                   3L)]
[10:59:33.192]             }
[10:59:33.192]             function(cond) {
[10:59:33.192]                 is_error <- inherits(cond, "error")
[10:59:33.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.192]                   NULL)
[10:59:33.192]                 if (is_error) {
[10:59:33.192]                   sessionInformation <- function() {
[10:59:33.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.192]                       search = base::search(), system = base::Sys.info())
[10:59:33.192]                   }
[10:59:33.192]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.192]                     cond$call), session = sessionInformation(), 
[10:59:33.192]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.192]                   signalCondition(cond)
[10:59:33.192]                 }
[10:59:33.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.192]                 "immediateCondition"))) {
[10:59:33.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.192]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.192]                   if (TRUE && !signal) {
[10:59:33.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.192]                     {
[10:59:33.192]                       inherits <- base::inherits
[10:59:33.192]                       invokeRestart <- base::invokeRestart
[10:59:33.192]                       is.null <- base::is.null
[10:59:33.192]                       muffled <- FALSE
[10:59:33.192]                       if (inherits(cond, "message")) {
[10:59:33.192]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.192]                         if (muffled) 
[10:59:33.192]                           invokeRestart("muffleMessage")
[10:59:33.192]                       }
[10:59:33.192]                       else if (inherits(cond, "warning")) {
[10:59:33.192]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.192]                         if (muffled) 
[10:59:33.192]                           invokeRestart("muffleWarning")
[10:59:33.192]                       }
[10:59:33.192]                       else if (inherits(cond, "condition")) {
[10:59:33.192]                         if (!is.null(pattern)) {
[10:59:33.192]                           computeRestarts <- base::computeRestarts
[10:59:33.192]                           grepl <- base::grepl
[10:59:33.192]                           restarts <- computeRestarts(cond)
[10:59:33.192]                           for (restart in restarts) {
[10:59:33.192]                             name <- restart$name
[10:59:33.192]                             if (is.null(name)) 
[10:59:33.192]                               next
[10:59:33.192]                             if (!grepl(pattern, name)) 
[10:59:33.192]                               next
[10:59:33.192]                             invokeRestart(restart)
[10:59:33.192]                             muffled <- TRUE
[10:59:33.192]                             break
[10:59:33.192]                           }
[10:59:33.192]                         }
[10:59:33.192]                       }
[10:59:33.192]                       invisible(muffled)
[10:59:33.192]                     }
[10:59:33.192]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.192]                   }
[10:59:33.192]                 }
[10:59:33.192]                 else {
[10:59:33.192]                   if (TRUE) {
[10:59:33.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.192]                     {
[10:59:33.192]                       inherits <- base::inherits
[10:59:33.192]                       invokeRestart <- base::invokeRestart
[10:59:33.192]                       is.null <- base::is.null
[10:59:33.192]                       muffled <- FALSE
[10:59:33.192]                       if (inherits(cond, "message")) {
[10:59:33.192]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.192]                         if (muffled) 
[10:59:33.192]                           invokeRestart("muffleMessage")
[10:59:33.192]                       }
[10:59:33.192]                       else if (inherits(cond, "warning")) {
[10:59:33.192]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.192]                         if (muffled) 
[10:59:33.192]                           invokeRestart("muffleWarning")
[10:59:33.192]                       }
[10:59:33.192]                       else if (inherits(cond, "condition")) {
[10:59:33.192]                         if (!is.null(pattern)) {
[10:59:33.192]                           computeRestarts <- base::computeRestarts
[10:59:33.192]                           grepl <- base::grepl
[10:59:33.192]                           restarts <- computeRestarts(cond)
[10:59:33.192]                           for (restart in restarts) {
[10:59:33.192]                             name <- restart$name
[10:59:33.192]                             if (is.null(name)) 
[10:59:33.192]                               next
[10:59:33.192]                             if (!grepl(pattern, name)) 
[10:59:33.192]                               next
[10:59:33.192]                             invokeRestart(restart)
[10:59:33.192]                             muffled <- TRUE
[10:59:33.192]                             break
[10:59:33.192]                           }
[10:59:33.192]                         }
[10:59:33.192]                       }
[10:59:33.192]                       invisible(muffled)
[10:59:33.192]                     }
[10:59:33.192]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.192]                   }
[10:59:33.192]                 }
[10:59:33.192]             }
[10:59:33.192]         }))
[10:59:33.192]     }, error = function(ex) {
[10:59:33.192]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.192]                 ...future.rng), started = ...future.startTime, 
[10:59:33.192]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.192]             version = "1.8"), class = "FutureResult")
[10:59:33.192]     }, finally = {
[10:59:33.192]         if (!identical(...future.workdir, getwd())) 
[10:59:33.192]             setwd(...future.workdir)
[10:59:33.192]         {
[10:59:33.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.192]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.192]             }
[10:59:33.192]             base::options(...future.oldOptions)
[10:59:33.192]             if (.Platform$OS.type == "windows") {
[10:59:33.192]                 old_names <- names(...future.oldEnvVars)
[10:59:33.192]                 envs <- base::Sys.getenv()
[10:59:33.192]                 names <- names(envs)
[10:59:33.192]                 common <- intersect(names, old_names)
[10:59:33.192]                 added <- setdiff(names, old_names)
[10:59:33.192]                 removed <- setdiff(old_names, names)
[10:59:33.192]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.192]                   envs[common]]
[10:59:33.192]                 NAMES <- toupper(changed)
[10:59:33.192]                 args <- list()
[10:59:33.192]                 for (kk in seq_along(NAMES)) {
[10:59:33.192]                   name <- changed[[kk]]
[10:59:33.192]                   NAME <- NAMES[[kk]]
[10:59:33.192]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.192]                     next
[10:59:33.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.192]                 }
[10:59:33.192]                 NAMES <- toupper(added)
[10:59:33.192]                 for (kk in seq_along(NAMES)) {
[10:59:33.192]                   name <- added[[kk]]
[10:59:33.192]                   NAME <- NAMES[[kk]]
[10:59:33.192]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.192]                     next
[10:59:33.192]                   args[[name]] <- ""
[10:59:33.192]                 }
[10:59:33.192]                 NAMES <- toupper(removed)
[10:59:33.192]                 for (kk in seq_along(NAMES)) {
[10:59:33.192]                   name <- removed[[kk]]
[10:59:33.192]                   NAME <- NAMES[[kk]]
[10:59:33.192]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.192]                     next
[10:59:33.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.192]                 }
[10:59:33.192]                 if (length(args) > 0) 
[10:59:33.192]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.192]             }
[10:59:33.192]             else {
[10:59:33.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.192]             }
[10:59:33.192]             {
[10:59:33.192]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.192]                   0L) {
[10:59:33.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.192]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.192]                   base::options(opts)
[10:59:33.192]                 }
[10:59:33.192]                 {
[10:59:33.192]                   {
[10:59:33.192]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.192]                     NULL
[10:59:33.192]                   }
[10:59:33.192]                   options(future.plan = NULL)
[10:59:33.192]                   if (is.na(NA_character_)) 
[10:59:33.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.192]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.192]                     .init = FALSE)
[10:59:33.192]                 }
[10:59:33.192]             }
[10:59:33.192]         }
[10:59:33.192]     })
[10:59:33.192]     if (TRUE) {
[10:59:33.192]         base::sink(type = "output", split = FALSE)
[10:59:33.192]         if (TRUE) {
[10:59:33.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.192]         }
[10:59:33.192]         else {
[10:59:33.192]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.192]         }
[10:59:33.192]         base::close(...future.stdout)
[10:59:33.192]         ...future.stdout <- NULL
[10:59:33.192]     }
[10:59:33.192]     ...future.result$conditions <- ...future.conditions
[10:59:33.192]     ...future.result$finished <- base::Sys.time()
[10:59:33.192]     ...future.result
[10:59:33.192] }
[10:59:33.195] assign_globals() ...
[10:59:33.195] List of 5
[10:59:33.195]  $ ...future.FUN            :function (x)  
[10:59:33.195]  $ MoreArgs                 : NULL
[10:59:33.195]  $ ...future.elements_ii    :List of 1
[10:59:33.195]   ..$ :List of 1
[10:59:33.195]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:59:33.195]  $ ...future.seeds_ii       : NULL
[10:59:33.195]  $ ...future.globals.maxSize: NULL
[10:59:33.195]  - attr(*, "where")=List of 5
[10:59:33.195]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.195]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.195]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.195]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.195]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.195]  - attr(*, "resolved")= logi FALSE
[10:59:33.195]  - attr(*, "total_size")= num 366
[10:59:33.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.195]  - attr(*, "already-done")= logi TRUE
[10:59:33.199] - copied ‘...future.FUN’ to environment
[10:59:33.199] - copied ‘MoreArgs’ to environment
[10:59:33.199] - copied ‘...future.elements_ii’ to environment
[10:59:33.199] - copied ‘...future.seeds_ii’ to environment
[10:59:33.199] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.199] assign_globals() ... done
[10:59:33.200] requestCore(): workers = 2
[10:59:33.201] MulticoreFuture started
[10:59:33.202] - Launch lazy future ... done
[10:59:33.202] run() for ‘MulticoreFuture’ ... done
[10:59:33.202] Created future:
[10:59:33.202] plan(): Setting new future strategy stack:
[10:59:33.203] List of future strategies:
[10:59:33.203] 1. sequential:
[10:59:33.203]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.203]    - tweaked: FALSE
[10:59:33.203]    - call: NULL
[10:59:33.203] plan(): nbrOfWorkers() = 1
[10:59:33.206] plan(): Setting new future strategy stack:
[10:59:33.206] List of future strategies:
[10:59:33.206] 1. multicore:
[10:59:33.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.206]    - tweaked: FALSE
[10:59:33.206]    - call: plan(strategy)
[10:59:33.209] plan(): nbrOfWorkers() = 2
[10:59:33.202] MulticoreFuture:
[10:59:33.202] Label: ‘future_mapply-1’
[10:59:33.202] Expression:
[10:59:33.202] {
[10:59:33.202]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.202]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.202]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.202]         on.exit(options(oopts), add = TRUE)
[10:59:33.202]     }
[10:59:33.202]     {
[10:59:33.202]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.202]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.202]         do.call(mapply, args = args)
[10:59:33.202]     }
[10:59:33.202] }
[10:59:33.202] Lazy evaluation: FALSE
[10:59:33.202] Asynchronous evaluation: TRUE
[10:59:33.202] Local evaluation: TRUE
[10:59:33.202] Environment: R_GlobalEnv
[10:59:33.202] Capture standard output: TRUE
[10:59:33.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.202] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.202] Packages: <none>
[10:59:33.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.202] Resolved: TRUE
[10:59:33.202] Value: <not collected>
[10:59:33.202] Conditions captured: <none>
[10:59:33.202] Early signaling: FALSE
[10:59:33.202] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.202] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.210] Chunk #1 of 1 ... DONE
[10:59:33.210] Launching 1 futures (chunks) ... DONE
[10:59:33.210] Resolving 1 futures (chunks) ...
[10:59:33.211] resolve() on list ...
[10:59:33.211]  recursive: 0
[10:59:33.211]  length: 1
[10:59:33.211] 
[10:59:33.211] Future #1
[10:59:33.211] result() for MulticoreFuture ...
[10:59:33.212] result() for MulticoreFuture ...
[10:59:33.212] result() for MulticoreFuture ... done
[10:59:33.213] result() for MulticoreFuture ... done
[10:59:33.213] result() for MulticoreFuture ...
[10:59:33.213] result() for MulticoreFuture ... done
[10:59:33.213] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.213] - nx: 1
[10:59:33.213] - relay: TRUE
[10:59:33.214] - stdout: TRUE
[10:59:33.214] - signal: TRUE
[10:59:33.214] - resignal: FALSE
[10:59:33.214] - force: TRUE
[10:59:33.214] - relayed: [n=1] FALSE
[10:59:33.214] - queued futures: [n=1] FALSE
[10:59:33.214]  - until=1
[10:59:33.214]  - relaying element #1
[10:59:33.214] result() for MulticoreFuture ...
[10:59:33.215] result() for MulticoreFuture ... done
[10:59:33.215] result() for MulticoreFuture ...
[10:59:33.215] result() for MulticoreFuture ... done
[10:59:33.215] result() for MulticoreFuture ...
[10:59:33.215] result() for MulticoreFuture ... done
[10:59:33.215] result() for MulticoreFuture ...
[10:59:33.215] result() for MulticoreFuture ... done
[10:59:33.215] - relayed: [n=1] TRUE
[10:59:33.216] - queued futures: [n=1] TRUE
[10:59:33.216] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.216]  length: 0 (resolved future 1)
[10:59:33.216] Relaying remaining futures
[10:59:33.216] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.216] - nx: 1
[10:59:33.216] - relay: TRUE
[10:59:33.216] - stdout: TRUE
[10:59:33.216] - signal: TRUE
[10:59:33.217] - resignal: FALSE
[10:59:33.217] - force: TRUE
[10:59:33.217] - relayed: [n=1] TRUE
[10:59:33.217] - queued futures: [n=1] TRUE
 - flush all
[10:59:33.217] - relayed: [n=1] TRUE
[10:59:33.217] - queued futures: [n=1] TRUE
[10:59:33.217] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.217] resolve() on list ... DONE
[10:59:33.217] result() for MulticoreFuture ...
[10:59:33.218] result() for MulticoreFuture ... done
[10:59:33.218] result() for MulticoreFuture ...
[10:59:33.223] result() for MulticoreFuture ... done
[10:59:33.223]  - Number of value chunks collected: 1
[10:59:33.223] Resolving 1 futures (chunks) ... DONE
[10:59:33.223] Reducing values from 1 chunks ...
[10:59:33.223]  - Number of values collected after concatenation: 1
[10:59:33.223]  - Number of values expected: 1
[10:59:33.224] Reducing values from 1 chunks ... DONE
[10:59:33.224] future_mapply() ... DONE
[10:59:33.224] future_mapply() ...
[10:59:33.226] Number of chunks: 1
[10:59:33.226] getGlobalsAndPackagesXApply() ...
[10:59:33.226]  - future.globals: TRUE
[10:59:33.226] getGlobalsAndPackages() ...
[10:59:33.226] Searching for globals...
[10:59:33.228] - globals found: [1] ‘FUN’
[10:59:33.228] Searching for globals ... DONE
[10:59:33.228] Resolving globals: FALSE
[10:59:33.228] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:33.229] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:33.229] - globals: [1] ‘FUN’
[10:59:33.229] 
[10:59:33.229] getGlobalsAndPackages() ... DONE
[10:59:33.229]  - globals found/used: [n=1] ‘FUN’
[10:59:33.229]  - needed namespaces: [n=0] 
[10:59:33.229] Finding globals ... DONE
[10:59:33.230] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.230] List of 2
[10:59:33.230]  $ ...future.FUN:function (x)  
[10:59:33.230]  $ MoreArgs     : list()
[10:59:33.230]  - attr(*, "where")=List of 2
[10:59:33.230]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.230]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.230]  - attr(*, "resolved")= logi FALSE
[10:59:33.230]  - attr(*, "total_size")= num NA
[10:59:33.233] Packages to be attached in all futures: [n=0] 
[10:59:33.233] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.233] Number of futures (= number of chunks): 1
[10:59:33.233] Launching 1 futures (chunks) ...
[10:59:33.234] Chunk #1 of 1 ...
[10:59:33.234]  - Finding globals in '...' for chunk #1 ...
[10:59:33.234] getGlobalsAndPackages() ...
[10:59:33.234] Searching for globals...
[10:59:33.234] 
[10:59:33.234] Searching for globals ... DONE
[10:59:33.235] - globals: [0] <none>
[10:59:33.235] getGlobalsAndPackages() ... DONE
[10:59:33.235]    + additional globals found: [n=0] 
[10:59:33.235]    + additional namespaces needed: [n=0] 
[10:59:33.235]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.235]  - seeds: <none>
[10:59:33.235]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.235] getGlobalsAndPackages() ...
[10:59:33.235] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.236] Resolving globals: FALSE
[10:59:33.236] The total size of the 5 globals is 370 bytes (370 bytes)
[10:59:33.236] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:33.237] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.237] 
[10:59:33.237] getGlobalsAndPackages() ... DONE
[10:59:33.237] run() for ‘Future’ ...
[10:59:33.237] - state: ‘created’
[10:59:33.237] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.239] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.239]   - Field: ‘label’
[10:59:33.239]   - Field: ‘local’
[10:59:33.239]   - Field: ‘owner’
[10:59:33.239]   - Field: ‘envir’
[10:59:33.240]   - Field: ‘workers’
[10:59:33.240]   - Field: ‘packages’
[10:59:33.240]   - Field: ‘gc’
[10:59:33.240]   - Field: ‘job’
[10:59:33.240]   - Field: ‘conditions’
[10:59:33.240]   - Field: ‘expr’
[10:59:33.240]   - Field: ‘uuid’
[10:59:33.240]   - Field: ‘seed’
[10:59:33.240]   - Field: ‘version’
[10:59:33.240]   - Field: ‘result’
[10:59:33.240]   - Field: ‘asynchronous’
[10:59:33.240]   - Field: ‘calls’
[10:59:33.241]   - Field: ‘globals’
[10:59:33.241]   - Field: ‘stdout’
[10:59:33.241]   - Field: ‘earlySignal’
[10:59:33.241]   - Field: ‘lazy’
[10:59:33.241]   - Field: ‘state’
[10:59:33.241] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.241] - Launch lazy future ...
[10:59:33.241] Packages needed by the future expression (n = 0): <none>
[10:59:33.241] Packages needed by future strategies (n = 0): <none>
[10:59:33.242] {
[10:59:33.242]     {
[10:59:33.242]         {
[10:59:33.242]             ...future.startTime <- base::Sys.time()
[10:59:33.242]             {
[10:59:33.242]                 {
[10:59:33.242]                   {
[10:59:33.242]                     {
[10:59:33.242]                       base::local({
[10:59:33.242]                         has_future <- base::requireNamespace("future", 
[10:59:33.242]                           quietly = TRUE)
[10:59:33.242]                         if (has_future) {
[10:59:33.242]                           ns <- base::getNamespace("future")
[10:59:33.242]                           version <- ns[[".package"]][["version"]]
[10:59:33.242]                           if (is.null(version)) 
[10:59:33.242]                             version <- utils::packageVersion("future")
[10:59:33.242]                         }
[10:59:33.242]                         else {
[10:59:33.242]                           version <- NULL
[10:59:33.242]                         }
[10:59:33.242]                         if (!has_future || version < "1.8.0") {
[10:59:33.242]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.242]                             "", base::R.version$version.string), 
[10:59:33.242]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.242]                               "release", "version")], collapse = " "), 
[10:59:33.242]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.242]                             info)
[10:59:33.242]                           info <- base::paste(info, collapse = "; ")
[10:59:33.242]                           if (!has_future) {
[10:59:33.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.242]                               info)
[10:59:33.242]                           }
[10:59:33.242]                           else {
[10:59:33.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.242]                               info, version)
[10:59:33.242]                           }
[10:59:33.242]                           base::stop(msg)
[10:59:33.242]                         }
[10:59:33.242]                       })
[10:59:33.242]                     }
[10:59:33.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.242]                     base::options(mc.cores = 1L)
[10:59:33.242]                   }
[10:59:33.242]                   ...future.strategy.old <- future::plan("list")
[10:59:33.242]                   options(future.plan = NULL)
[10:59:33.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.242]                 }
[10:59:33.242]                 ...future.workdir <- getwd()
[10:59:33.242]             }
[10:59:33.242]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.242]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.242]         }
[10:59:33.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:33.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.242]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.242]             base::names(...future.oldOptions))
[10:59:33.242]     }
[10:59:33.242]     if (FALSE) {
[10:59:33.242]     }
[10:59:33.242]     else {
[10:59:33.242]         if (TRUE) {
[10:59:33.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.242]                 open = "w")
[10:59:33.242]         }
[10:59:33.242]         else {
[10:59:33.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.242]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.242]         }
[10:59:33.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.242]             base::sink(type = "output", split = FALSE)
[10:59:33.242]             base::close(...future.stdout)
[10:59:33.242]         }, add = TRUE)
[10:59:33.242]     }
[10:59:33.242]     ...future.frame <- base::sys.nframe()
[10:59:33.242]     ...future.conditions <- base::list()
[10:59:33.242]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.242]     if (FALSE) {
[10:59:33.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.242]     }
[10:59:33.242]     ...future.result <- base::tryCatch({
[10:59:33.242]         base::withCallingHandlers({
[10:59:33.242]             ...future.value <- base::withVisible(base::local({
[10:59:33.242]                 withCallingHandlers({
[10:59:33.242]                   {
[10:59:33.242]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.242]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.242]                       ...future.globals.maxSize)) {
[10:59:33.242]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.242]                       on.exit(options(oopts), add = TRUE)
[10:59:33.242]                     }
[10:59:33.242]                     {
[10:59:33.242]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.242]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.242]                         USE.NAMES = FALSE)
[10:59:33.242]                       do.call(mapply, args = args)
[10:59:33.242]                     }
[10:59:33.242]                   }
[10:59:33.242]                 }, immediateCondition = function(cond) {
[10:59:33.242]                   save_rds <- function (object, pathname, ...) 
[10:59:33.242]                   {
[10:59:33.242]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.242]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.242]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.242]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.242]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.242]                         fi_tmp[["mtime"]])
[10:59:33.242]                     }
[10:59:33.242]                     tryCatch({
[10:59:33.242]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.242]                     }, error = function(ex) {
[10:59:33.242]                       msg <- conditionMessage(ex)
[10:59:33.242]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.242]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.242]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.242]                         fi_tmp[["mtime"]], msg)
[10:59:33.242]                       ex$message <- msg
[10:59:33.242]                       stop(ex)
[10:59:33.242]                     })
[10:59:33.242]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.242]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.242]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.242]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.242]                       fi <- file.info(pathname)
[10:59:33.242]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.242]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.242]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.242]                         fi[["size"]], fi[["mtime"]])
[10:59:33.242]                       stop(msg)
[10:59:33.242]                     }
[10:59:33.242]                     invisible(pathname)
[10:59:33.242]                   }
[10:59:33.242]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.242]                     rootPath = tempdir()) 
[10:59:33.242]                   {
[10:59:33.242]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.242]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.242]                       tmpdir = path, fileext = ".rds")
[10:59:33.242]                     save_rds(obj, file)
[10:59:33.242]                   }
[10:59:33.242]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.242]                   {
[10:59:33.242]                     inherits <- base::inherits
[10:59:33.242]                     invokeRestart <- base::invokeRestart
[10:59:33.242]                     is.null <- base::is.null
[10:59:33.242]                     muffled <- FALSE
[10:59:33.242]                     if (inherits(cond, "message")) {
[10:59:33.242]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.242]                       if (muffled) 
[10:59:33.242]                         invokeRestart("muffleMessage")
[10:59:33.242]                     }
[10:59:33.242]                     else if (inherits(cond, "warning")) {
[10:59:33.242]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.242]                       if (muffled) 
[10:59:33.242]                         invokeRestart("muffleWarning")
[10:59:33.242]                     }
[10:59:33.242]                     else if (inherits(cond, "condition")) {
[10:59:33.242]                       if (!is.null(pattern)) {
[10:59:33.242]                         computeRestarts <- base::computeRestarts
[10:59:33.242]                         grepl <- base::grepl
[10:59:33.242]                         restarts <- computeRestarts(cond)
[10:59:33.242]                         for (restart in restarts) {
[10:59:33.242]                           name <- restart$name
[10:59:33.242]                           if (is.null(name)) 
[10:59:33.242]                             next
[10:59:33.242]                           if (!grepl(pattern, name)) 
[10:59:33.242]                             next
[10:59:33.242]                           invokeRestart(restart)
[10:59:33.242]                           muffled <- TRUE
[10:59:33.242]                           break
[10:59:33.242]                         }
[10:59:33.242]                       }
[10:59:33.242]                     }
[10:59:33.242]                     invisible(muffled)
[10:59:33.242]                   }
[10:59:33.242]                   muffleCondition(cond)
[10:59:33.242]                 })
[10:59:33.242]             }))
[10:59:33.242]             future::FutureResult(value = ...future.value$value, 
[10:59:33.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.242]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.242]                     ...future.globalenv.names))
[10:59:33.242]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.242]         }, condition = base::local({
[10:59:33.242]             c <- base::c
[10:59:33.242]             inherits <- base::inherits
[10:59:33.242]             invokeRestart <- base::invokeRestart
[10:59:33.242]             length <- base::length
[10:59:33.242]             list <- base::list
[10:59:33.242]             seq.int <- base::seq.int
[10:59:33.242]             signalCondition <- base::signalCondition
[10:59:33.242]             sys.calls <- base::sys.calls
[10:59:33.242]             `[[` <- base::`[[`
[10:59:33.242]             `+` <- base::`+`
[10:59:33.242]             `<<-` <- base::`<<-`
[10:59:33.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.242]                   3L)]
[10:59:33.242]             }
[10:59:33.242]             function(cond) {
[10:59:33.242]                 is_error <- inherits(cond, "error")
[10:59:33.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.242]                   NULL)
[10:59:33.242]                 if (is_error) {
[10:59:33.242]                   sessionInformation <- function() {
[10:59:33.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.242]                       search = base::search(), system = base::Sys.info())
[10:59:33.242]                   }
[10:59:33.242]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.242]                     cond$call), session = sessionInformation(), 
[10:59:33.242]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.242]                   signalCondition(cond)
[10:59:33.242]                 }
[10:59:33.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.242]                 "immediateCondition"))) {
[10:59:33.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.242]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.242]                   if (TRUE && !signal) {
[10:59:33.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.242]                     {
[10:59:33.242]                       inherits <- base::inherits
[10:59:33.242]                       invokeRestart <- base::invokeRestart
[10:59:33.242]                       is.null <- base::is.null
[10:59:33.242]                       muffled <- FALSE
[10:59:33.242]                       if (inherits(cond, "message")) {
[10:59:33.242]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.242]                         if (muffled) 
[10:59:33.242]                           invokeRestart("muffleMessage")
[10:59:33.242]                       }
[10:59:33.242]                       else if (inherits(cond, "warning")) {
[10:59:33.242]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.242]                         if (muffled) 
[10:59:33.242]                           invokeRestart("muffleWarning")
[10:59:33.242]                       }
[10:59:33.242]                       else if (inherits(cond, "condition")) {
[10:59:33.242]                         if (!is.null(pattern)) {
[10:59:33.242]                           computeRestarts <- base::computeRestarts
[10:59:33.242]                           grepl <- base::grepl
[10:59:33.242]                           restarts <- computeRestarts(cond)
[10:59:33.242]                           for (restart in restarts) {
[10:59:33.242]                             name <- restart$name
[10:59:33.242]                             if (is.null(name)) 
[10:59:33.242]                               next
[10:59:33.242]                             if (!grepl(pattern, name)) 
[10:59:33.242]                               next
[10:59:33.242]                             invokeRestart(restart)
[10:59:33.242]                             muffled <- TRUE
[10:59:33.242]                             break
[10:59:33.242]                           }
[10:59:33.242]                         }
[10:59:33.242]                       }
[10:59:33.242]                       invisible(muffled)
[10:59:33.242]                     }
[10:59:33.242]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.242]                   }
[10:59:33.242]                 }
[10:59:33.242]                 else {
[10:59:33.242]                   if (TRUE) {
[10:59:33.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.242]                     {
[10:59:33.242]                       inherits <- base::inherits
[10:59:33.242]                       invokeRestart <- base::invokeRestart
[10:59:33.242]                       is.null <- base::is.null
[10:59:33.242]                       muffled <- FALSE
[10:59:33.242]                       if (inherits(cond, "message")) {
[10:59:33.242]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.242]                         if (muffled) 
[10:59:33.242]                           invokeRestart("muffleMessage")
[10:59:33.242]                       }
[10:59:33.242]                       else if (inherits(cond, "warning")) {
[10:59:33.242]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.242]                         if (muffled) 
[10:59:33.242]                           invokeRestart("muffleWarning")
[10:59:33.242]                       }
[10:59:33.242]                       else if (inherits(cond, "condition")) {
[10:59:33.242]                         if (!is.null(pattern)) {
[10:59:33.242]                           computeRestarts <- base::computeRestarts
[10:59:33.242]                           grepl <- base::grepl
[10:59:33.242]                           restarts <- computeRestarts(cond)
[10:59:33.242]                           for (restart in restarts) {
[10:59:33.242]                             name <- restart$name
[10:59:33.242]                             if (is.null(name)) 
[10:59:33.242]                               next
[10:59:33.242]                             if (!grepl(pattern, name)) 
[10:59:33.242]                               next
[10:59:33.242]                             invokeRestart(restart)
[10:59:33.242]                             muffled <- TRUE
[10:59:33.242]                             break
[10:59:33.242]                           }
[10:59:33.242]                         }
[10:59:33.242]                       }
[10:59:33.242]                       invisible(muffled)
[10:59:33.242]                     }
[10:59:33.242]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.242]                   }
[10:59:33.242]                 }
[10:59:33.242]             }
[10:59:33.242]         }))
[10:59:33.242]     }, error = function(ex) {
[10:59:33.242]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.242]                 ...future.rng), started = ...future.startTime, 
[10:59:33.242]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.242]             version = "1.8"), class = "FutureResult")
[10:59:33.242]     }, finally = {
[10:59:33.242]         if (!identical(...future.workdir, getwd())) 
[10:59:33.242]             setwd(...future.workdir)
[10:59:33.242]         {
[10:59:33.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.242]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.242]             }
[10:59:33.242]             base::options(...future.oldOptions)
[10:59:33.242]             if (.Platform$OS.type == "windows") {
[10:59:33.242]                 old_names <- names(...future.oldEnvVars)
[10:59:33.242]                 envs <- base::Sys.getenv()
[10:59:33.242]                 names <- names(envs)
[10:59:33.242]                 common <- intersect(names, old_names)
[10:59:33.242]                 added <- setdiff(names, old_names)
[10:59:33.242]                 removed <- setdiff(old_names, names)
[10:59:33.242]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.242]                   envs[common]]
[10:59:33.242]                 NAMES <- toupper(changed)
[10:59:33.242]                 args <- list()
[10:59:33.242]                 for (kk in seq_along(NAMES)) {
[10:59:33.242]                   name <- changed[[kk]]
[10:59:33.242]                   NAME <- NAMES[[kk]]
[10:59:33.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.242]                     next
[10:59:33.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.242]                 }
[10:59:33.242]                 NAMES <- toupper(added)
[10:59:33.242]                 for (kk in seq_along(NAMES)) {
[10:59:33.242]                   name <- added[[kk]]
[10:59:33.242]                   NAME <- NAMES[[kk]]
[10:59:33.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.242]                     next
[10:59:33.242]                   args[[name]] <- ""
[10:59:33.242]                 }
[10:59:33.242]                 NAMES <- toupper(removed)
[10:59:33.242]                 for (kk in seq_along(NAMES)) {
[10:59:33.242]                   name <- removed[[kk]]
[10:59:33.242]                   NAME <- NAMES[[kk]]
[10:59:33.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.242]                     next
[10:59:33.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.242]                 }
[10:59:33.242]                 if (length(args) > 0) 
[10:59:33.242]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.242]             }
[10:59:33.242]             else {
[10:59:33.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.242]             }
[10:59:33.242]             {
[10:59:33.242]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.242]                   0L) {
[10:59:33.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.242]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.242]                   base::options(opts)
[10:59:33.242]                 }
[10:59:33.242]                 {
[10:59:33.242]                   {
[10:59:33.242]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.242]                     NULL
[10:59:33.242]                   }
[10:59:33.242]                   options(future.plan = NULL)
[10:59:33.242]                   if (is.na(NA_character_)) 
[10:59:33.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.242]                     .init = FALSE)
[10:59:33.242]                 }
[10:59:33.242]             }
[10:59:33.242]         }
[10:59:33.242]     })
[10:59:33.242]     if (TRUE) {
[10:59:33.242]         base::sink(type = "output", split = FALSE)
[10:59:33.242]         if (TRUE) {
[10:59:33.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.242]         }
[10:59:33.242]         else {
[10:59:33.242]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.242]         }
[10:59:33.242]         base::close(...future.stdout)
[10:59:33.242]         ...future.stdout <- NULL
[10:59:33.242]     }
[10:59:33.242]     ...future.result$conditions <- ...future.conditions
[10:59:33.242]     ...future.result$finished <- base::Sys.time()
[10:59:33.242]     ...future.result
[10:59:33.242] }
[10:59:33.244] assign_globals() ...
[10:59:33.244] List of 5
[10:59:33.244]  $ ...future.FUN            :function (x)  
[10:59:33.244]  $ MoreArgs                 : list()
[10:59:33.244]  $ ...future.elements_ii    :List of 1
[10:59:33.244]   ..$ :List of 1
[10:59:33.244]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:59:33.244]  $ ...future.seeds_ii       : NULL
[10:59:33.244]  $ ...future.globals.maxSize: NULL
[10:59:33.244]  - attr(*, "where")=List of 5
[10:59:33.244]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.244]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.244]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.244]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.244]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.244]  - attr(*, "resolved")= logi FALSE
[10:59:33.244]  - attr(*, "total_size")= num 370
[10:59:33.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.244]  - attr(*, "already-done")= logi TRUE
[10:59:33.250] - copied ‘...future.FUN’ to environment
[10:59:33.250] - copied ‘MoreArgs’ to environment
[10:59:33.250] - copied ‘...future.elements_ii’ to environment
[10:59:33.251] - copied ‘...future.seeds_ii’ to environment
[10:59:33.251] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.251] assign_globals() ... done
[10:59:33.251] requestCore(): workers = 2
[10:59:33.253] MulticoreFuture started
[10:59:33.254] - Launch lazy future ... done
[10:59:33.254] plan(): Setting new future strategy stack:
[10:59:33.254] run() for ‘MulticoreFuture’ ... done
[10:59:33.255] Created future:
[10:59:33.255] List of future strategies:
[10:59:33.255] 1. sequential:
[10:59:33.255]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.255]    - tweaked: FALSE
[10:59:33.255]    - call: NULL
[10:59:33.257] plan(): nbrOfWorkers() = 1
[10:59:33.259] plan(): Setting new future strategy stack:
[10:59:33.260] List of future strategies:
[10:59:33.260] 1. multicore:
[10:59:33.260]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.260]    - tweaked: FALSE
[10:59:33.260]    - call: plan(strategy)
[10:59:33.264] plan(): nbrOfWorkers() = 2
[10:59:33.255] MulticoreFuture:
[10:59:33.255] Label: ‘future_.mapply-1’
[10:59:33.255] Expression:
[10:59:33.255] {
[10:59:33.255]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.255]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.255]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.255]         on.exit(options(oopts), add = TRUE)
[10:59:33.255]     }
[10:59:33.255]     {
[10:59:33.255]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.255]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.255]         do.call(mapply, args = args)
[10:59:33.255]     }
[10:59:33.255] }
[10:59:33.255] Lazy evaluation: FALSE
[10:59:33.255] Asynchronous evaluation: TRUE
[10:59:33.255] Local evaluation: TRUE
[10:59:33.255] Environment: R_GlobalEnv
[10:59:33.255] Capture standard output: TRUE
[10:59:33.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.255] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.255] Packages: <none>
[10:59:33.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.255] Resolved: TRUE
[10:59:33.255] Value: <not collected>
[10:59:33.255] Conditions captured: <none>
[10:59:33.255] Early signaling: FALSE
[10:59:33.255] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.255] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.265] Chunk #1 of 1 ... DONE
[10:59:33.265] Launching 1 futures (chunks) ... DONE
[10:59:33.266] Resolving 1 futures (chunks) ...
[10:59:33.266] resolve() on list ...
[10:59:33.266]  recursive: 0
[10:59:33.266]  length: 1
[10:59:33.267] 
[10:59:33.267] Future #1
[10:59:33.267] result() for MulticoreFuture ...
[10:59:33.268] result() for MulticoreFuture ...
[10:59:33.268] result() for MulticoreFuture ... done
[10:59:33.268] result() for MulticoreFuture ... done
[10:59:33.269] result() for MulticoreFuture ...
[10:59:33.269] result() for MulticoreFuture ... done
[10:59:33.269] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.269] - nx: 1
[10:59:33.269] - relay: TRUE
[10:59:33.270] - stdout: TRUE
[10:59:33.270] - signal: TRUE
[10:59:33.270] - resignal: FALSE
[10:59:33.270] - force: TRUE
[10:59:33.270] - relayed: [n=1] FALSE
[10:59:33.270] - queued futures: [n=1] FALSE
[10:59:33.271]  - until=1
[10:59:33.271]  - relaying element #1
[10:59:33.271] result() for MulticoreFuture ...
[10:59:33.271] result() for MulticoreFuture ... done
[10:59:33.271] result() for MulticoreFuture ...
[10:59:33.271] result() for MulticoreFuture ... done
[10:59:33.271] result() for MulticoreFuture ...
[10:59:33.271] result() for MulticoreFuture ... done
[10:59:33.272] result() for MulticoreFuture ...
[10:59:33.272] result() for MulticoreFuture ... done
[10:59:33.272] - relayed: [n=1] TRUE
[10:59:33.272] - queued futures: [n=1] TRUE
[10:59:33.272] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.272]  length: 0 (resolved future 1)
[10:59:33.272] Relaying remaining futures
[10:59:33.272] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.272] - nx: 1
[10:59:33.273] - relay: TRUE
[10:59:33.273] - stdout: TRUE
[10:59:33.273] - signal: TRUE
[10:59:33.273] - resignal: FALSE
[10:59:33.273] - force: TRUE
[10:59:33.273] - relayed: [n=1] TRUE
[10:59:33.273] - queued futures: [n=1] TRUE
 - flush all
[10:59:33.273] - relayed: [n=1] TRUE
[10:59:33.273] - queued futures: [n=1] TRUE
[10:59:33.274] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.274] resolve() on list ... DONE
[10:59:33.274] result() for MulticoreFuture ...
[10:59:33.274] result() for MulticoreFuture ... done
[10:59:33.274] result() for MulticoreFuture ...
[10:59:33.274] result() for MulticoreFuture ... done
[10:59:33.274]  - Number of value chunks collected: 1
[10:59:33.274] Resolving 1 futures (chunks) ... DONE
[10:59:33.274] Reducing values from 1 chunks ...
[10:59:33.274]  - Number of values collected after concatenation: 1
[10:59:33.275]  - Number of values expected: 1
[10:59:33.275] Reducing values from 1 chunks ... DONE
[10:59:33.275] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:59:33.275] future_mapply() ...
[10:59:33.277] Number of chunks: 2
[10:59:33.277] getGlobalsAndPackagesXApply() ...
[10:59:33.277]  - future.globals: TRUE
[10:59:33.277] getGlobalsAndPackages() ...
[10:59:33.277] Searching for globals...
[10:59:33.279] - globals found: [1] ‘FUN’
[10:59:33.279] Searching for globals ... DONE
[10:59:33.279] Resolving globals: FALSE
[10:59:33.279] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:33.279] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:33.280] - globals: [1] ‘FUN’
[10:59:33.280] 
[10:59:33.280] getGlobalsAndPackages() ... DONE
[10:59:33.280]  - globals found/used: [n=1] ‘FUN’
[10:59:33.280]  - needed namespaces: [n=0] 
[10:59:33.280] Finding globals ... DONE
[10:59:33.280] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.280] List of 2
[10:59:33.280]  $ ...future.FUN:function (x, y)  
[10:59:33.280]  $ MoreArgs     :List of 1
[10:59:33.280]   ..$ y: int [1:2] 3 4
[10:59:33.280]  - attr(*, "where")=List of 2
[10:59:33.280]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.280]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.280]  - attr(*, "resolved")= logi FALSE
[10:59:33.280]  - attr(*, "total_size")= num NA
[10:59:33.284] Packages to be attached in all futures: [n=0] 
[10:59:33.284] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.284] Number of futures (= number of chunks): 2
[10:59:33.284] Launching 2 futures (chunks) ...
[10:59:33.284] Chunk #1 of 2 ...
[10:59:33.284]  - Finding globals in '...' for chunk #1 ...
[10:59:33.284] getGlobalsAndPackages() ...
[10:59:33.284] Searching for globals...
[10:59:33.287] 
[10:59:33.287] Searching for globals ... DONE
[10:59:33.287] - globals: [0] <none>
[10:59:33.287] getGlobalsAndPackages() ... DONE
[10:59:33.287]    + additional globals found: [n=0] 
[10:59:33.287]    + additional namespaces needed: [n=0] 
[10:59:33.287]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.288]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.288]  - seeds: <none>
[10:59:33.288]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.288] getGlobalsAndPackages() ...
[10:59:33.288] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.288] Resolving globals: FALSE
[10:59:33.289] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:33.289] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:33.289] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.289] 
[10:59:33.289] getGlobalsAndPackages() ... DONE
[10:59:33.290] run() for ‘Future’ ...
[10:59:33.290] - state: ‘created’
[10:59:33.290] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.292] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.292] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.292]   - Field: ‘label’
[10:59:33.292]   - Field: ‘local’
[10:59:33.292]   - Field: ‘owner’
[10:59:33.292]   - Field: ‘envir’
[10:59:33.293]   - Field: ‘workers’
[10:59:33.293]   - Field: ‘packages’
[10:59:33.293]   - Field: ‘gc’
[10:59:33.293]   - Field: ‘job’
[10:59:33.293]   - Field: ‘conditions’
[10:59:33.293]   - Field: ‘expr’
[10:59:33.293]   - Field: ‘uuid’
[10:59:33.293]   - Field: ‘seed’
[10:59:33.293]   - Field: ‘version’
[10:59:33.293]   - Field: ‘result’
[10:59:33.293]   - Field: ‘asynchronous’
[10:59:33.294]   - Field: ‘calls’
[10:59:33.294]   - Field: ‘globals’
[10:59:33.294]   - Field: ‘stdout’
[10:59:33.294]   - Field: ‘earlySignal’
[10:59:33.294]   - Field: ‘lazy’
[10:59:33.294]   - Field: ‘state’
[10:59:33.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.294] - Launch lazy future ...
[10:59:33.295] Packages needed by the future expression (n = 0): <none>
[10:59:33.295] Packages needed by future strategies (n = 0): <none>
[10:59:33.295] {
[10:59:33.295]     {
[10:59:33.295]         {
[10:59:33.295]             ...future.startTime <- base::Sys.time()
[10:59:33.295]             {
[10:59:33.295]                 {
[10:59:33.295]                   {
[10:59:33.295]                     {
[10:59:33.295]                       base::local({
[10:59:33.295]                         has_future <- base::requireNamespace("future", 
[10:59:33.295]                           quietly = TRUE)
[10:59:33.295]                         if (has_future) {
[10:59:33.295]                           ns <- base::getNamespace("future")
[10:59:33.295]                           version <- ns[[".package"]][["version"]]
[10:59:33.295]                           if (is.null(version)) 
[10:59:33.295]                             version <- utils::packageVersion("future")
[10:59:33.295]                         }
[10:59:33.295]                         else {
[10:59:33.295]                           version <- NULL
[10:59:33.295]                         }
[10:59:33.295]                         if (!has_future || version < "1.8.0") {
[10:59:33.295]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.295]                             "", base::R.version$version.string), 
[10:59:33.295]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.295]                               "release", "version")], collapse = " "), 
[10:59:33.295]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.295]                             info)
[10:59:33.295]                           info <- base::paste(info, collapse = "; ")
[10:59:33.295]                           if (!has_future) {
[10:59:33.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.295]                               info)
[10:59:33.295]                           }
[10:59:33.295]                           else {
[10:59:33.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.295]                               info, version)
[10:59:33.295]                           }
[10:59:33.295]                           base::stop(msg)
[10:59:33.295]                         }
[10:59:33.295]                       })
[10:59:33.295]                     }
[10:59:33.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.295]                     base::options(mc.cores = 1L)
[10:59:33.295]                   }
[10:59:33.295]                   ...future.strategy.old <- future::plan("list")
[10:59:33.295]                   options(future.plan = NULL)
[10:59:33.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.295]                 }
[10:59:33.295]                 ...future.workdir <- getwd()
[10:59:33.295]             }
[10:59:33.295]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.295]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.295]         }
[10:59:33.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.295]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.295]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.295]             base::names(...future.oldOptions))
[10:59:33.295]     }
[10:59:33.295]     if (FALSE) {
[10:59:33.295]     }
[10:59:33.295]     else {
[10:59:33.295]         if (TRUE) {
[10:59:33.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.295]                 open = "w")
[10:59:33.295]         }
[10:59:33.295]         else {
[10:59:33.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.295]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.295]         }
[10:59:33.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.295]             base::sink(type = "output", split = FALSE)
[10:59:33.295]             base::close(...future.stdout)
[10:59:33.295]         }, add = TRUE)
[10:59:33.295]     }
[10:59:33.295]     ...future.frame <- base::sys.nframe()
[10:59:33.295]     ...future.conditions <- base::list()
[10:59:33.295]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.295]     if (FALSE) {
[10:59:33.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.295]     }
[10:59:33.295]     ...future.result <- base::tryCatch({
[10:59:33.295]         base::withCallingHandlers({
[10:59:33.295]             ...future.value <- base::withVisible(base::local({
[10:59:33.295]                 withCallingHandlers({
[10:59:33.295]                   {
[10:59:33.295]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.295]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.295]                       ...future.globals.maxSize)) {
[10:59:33.295]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.295]                       on.exit(options(oopts), add = TRUE)
[10:59:33.295]                     }
[10:59:33.295]                     {
[10:59:33.295]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.295]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.295]                         USE.NAMES = FALSE)
[10:59:33.295]                       do.call(mapply, args = args)
[10:59:33.295]                     }
[10:59:33.295]                   }
[10:59:33.295]                 }, immediateCondition = function(cond) {
[10:59:33.295]                   save_rds <- function (object, pathname, ...) 
[10:59:33.295]                   {
[10:59:33.295]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.295]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.295]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.295]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.295]                         fi_tmp[["mtime"]])
[10:59:33.295]                     }
[10:59:33.295]                     tryCatch({
[10:59:33.295]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.295]                     }, error = function(ex) {
[10:59:33.295]                       msg <- conditionMessage(ex)
[10:59:33.295]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.295]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.295]                         fi_tmp[["mtime"]], msg)
[10:59:33.295]                       ex$message <- msg
[10:59:33.295]                       stop(ex)
[10:59:33.295]                     })
[10:59:33.295]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.295]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.295]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.295]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.295]                       fi <- file.info(pathname)
[10:59:33.295]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.295]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.295]                         fi[["size"]], fi[["mtime"]])
[10:59:33.295]                       stop(msg)
[10:59:33.295]                     }
[10:59:33.295]                     invisible(pathname)
[10:59:33.295]                   }
[10:59:33.295]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.295]                     rootPath = tempdir()) 
[10:59:33.295]                   {
[10:59:33.295]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.295]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.295]                       tmpdir = path, fileext = ".rds")
[10:59:33.295]                     save_rds(obj, file)
[10:59:33.295]                   }
[10:59:33.295]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.295]                   {
[10:59:33.295]                     inherits <- base::inherits
[10:59:33.295]                     invokeRestart <- base::invokeRestart
[10:59:33.295]                     is.null <- base::is.null
[10:59:33.295]                     muffled <- FALSE
[10:59:33.295]                     if (inherits(cond, "message")) {
[10:59:33.295]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.295]                       if (muffled) 
[10:59:33.295]                         invokeRestart("muffleMessage")
[10:59:33.295]                     }
[10:59:33.295]                     else if (inherits(cond, "warning")) {
[10:59:33.295]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.295]                       if (muffled) 
[10:59:33.295]                         invokeRestart("muffleWarning")
[10:59:33.295]                     }
[10:59:33.295]                     else if (inherits(cond, "condition")) {
[10:59:33.295]                       if (!is.null(pattern)) {
[10:59:33.295]                         computeRestarts <- base::computeRestarts
[10:59:33.295]                         grepl <- base::grepl
[10:59:33.295]                         restarts <- computeRestarts(cond)
[10:59:33.295]                         for (restart in restarts) {
[10:59:33.295]                           name <- restart$name
[10:59:33.295]                           if (is.null(name)) 
[10:59:33.295]                             next
[10:59:33.295]                           if (!grepl(pattern, name)) 
[10:59:33.295]                             next
[10:59:33.295]                           invokeRestart(restart)
[10:59:33.295]                           muffled <- TRUE
[10:59:33.295]                           break
[10:59:33.295]                         }
[10:59:33.295]                       }
[10:59:33.295]                     }
[10:59:33.295]                     invisible(muffled)
[10:59:33.295]                   }
[10:59:33.295]                   muffleCondition(cond)
[10:59:33.295]                 })
[10:59:33.295]             }))
[10:59:33.295]             future::FutureResult(value = ...future.value$value, 
[10:59:33.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.295]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.295]                     ...future.globalenv.names))
[10:59:33.295]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.295]         }, condition = base::local({
[10:59:33.295]             c <- base::c
[10:59:33.295]             inherits <- base::inherits
[10:59:33.295]             invokeRestart <- base::invokeRestart
[10:59:33.295]             length <- base::length
[10:59:33.295]             list <- base::list
[10:59:33.295]             seq.int <- base::seq.int
[10:59:33.295]             signalCondition <- base::signalCondition
[10:59:33.295]             sys.calls <- base::sys.calls
[10:59:33.295]             `[[` <- base::`[[`
[10:59:33.295]             `+` <- base::`+`
[10:59:33.295]             `<<-` <- base::`<<-`
[10:59:33.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.295]                   3L)]
[10:59:33.295]             }
[10:59:33.295]             function(cond) {
[10:59:33.295]                 is_error <- inherits(cond, "error")
[10:59:33.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.295]                   NULL)
[10:59:33.295]                 if (is_error) {
[10:59:33.295]                   sessionInformation <- function() {
[10:59:33.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.295]                       search = base::search(), system = base::Sys.info())
[10:59:33.295]                   }
[10:59:33.295]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.295]                     cond$call), session = sessionInformation(), 
[10:59:33.295]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.295]                   signalCondition(cond)
[10:59:33.295]                 }
[10:59:33.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.295]                 "immediateCondition"))) {
[10:59:33.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.295]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.295]                   if (TRUE && !signal) {
[10:59:33.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.295]                     {
[10:59:33.295]                       inherits <- base::inherits
[10:59:33.295]                       invokeRestart <- base::invokeRestart
[10:59:33.295]                       is.null <- base::is.null
[10:59:33.295]                       muffled <- FALSE
[10:59:33.295]                       if (inherits(cond, "message")) {
[10:59:33.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.295]                         if (muffled) 
[10:59:33.295]                           invokeRestart("muffleMessage")
[10:59:33.295]                       }
[10:59:33.295]                       else if (inherits(cond, "warning")) {
[10:59:33.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.295]                         if (muffled) 
[10:59:33.295]                           invokeRestart("muffleWarning")
[10:59:33.295]                       }
[10:59:33.295]                       else if (inherits(cond, "condition")) {
[10:59:33.295]                         if (!is.null(pattern)) {
[10:59:33.295]                           computeRestarts <- base::computeRestarts
[10:59:33.295]                           grepl <- base::grepl
[10:59:33.295]                           restarts <- computeRestarts(cond)
[10:59:33.295]                           for (restart in restarts) {
[10:59:33.295]                             name <- restart$name
[10:59:33.295]                             if (is.null(name)) 
[10:59:33.295]                               next
[10:59:33.295]                             if (!grepl(pattern, name)) 
[10:59:33.295]                               next
[10:59:33.295]                             invokeRestart(restart)
[10:59:33.295]                             muffled <- TRUE
[10:59:33.295]                             break
[10:59:33.295]                           }
[10:59:33.295]                         }
[10:59:33.295]                       }
[10:59:33.295]                       invisible(muffled)
[10:59:33.295]                     }
[10:59:33.295]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.295]                   }
[10:59:33.295]                 }
[10:59:33.295]                 else {
[10:59:33.295]                   if (TRUE) {
[10:59:33.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.295]                     {
[10:59:33.295]                       inherits <- base::inherits
[10:59:33.295]                       invokeRestart <- base::invokeRestart
[10:59:33.295]                       is.null <- base::is.null
[10:59:33.295]                       muffled <- FALSE
[10:59:33.295]                       if (inherits(cond, "message")) {
[10:59:33.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.295]                         if (muffled) 
[10:59:33.295]                           invokeRestart("muffleMessage")
[10:59:33.295]                       }
[10:59:33.295]                       else if (inherits(cond, "warning")) {
[10:59:33.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.295]                         if (muffled) 
[10:59:33.295]                           invokeRestart("muffleWarning")
[10:59:33.295]                       }
[10:59:33.295]                       else if (inherits(cond, "condition")) {
[10:59:33.295]                         if (!is.null(pattern)) {
[10:59:33.295]                           computeRestarts <- base::computeRestarts
[10:59:33.295]                           grepl <- base::grepl
[10:59:33.295]                           restarts <- computeRestarts(cond)
[10:59:33.295]                           for (restart in restarts) {
[10:59:33.295]                             name <- restart$name
[10:59:33.295]                             if (is.null(name)) 
[10:59:33.295]                               next
[10:59:33.295]                             if (!grepl(pattern, name)) 
[10:59:33.295]                               next
[10:59:33.295]                             invokeRestart(restart)
[10:59:33.295]                             muffled <- TRUE
[10:59:33.295]                             break
[10:59:33.295]                           }
[10:59:33.295]                         }
[10:59:33.295]                       }
[10:59:33.295]                       invisible(muffled)
[10:59:33.295]                     }
[10:59:33.295]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.295]                   }
[10:59:33.295]                 }
[10:59:33.295]             }
[10:59:33.295]         }))
[10:59:33.295]     }, error = function(ex) {
[10:59:33.295]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.295]                 ...future.rng), started = ...future.startTime, 
[10:59:33.295]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.295]             version = "1.8"), class = "FutureResult")
[10:59:33.295]     }, finally = {
[10:59:33.295]         if (!identical(...future.workdir, getwd())) 
[10:59:33.295]             setwd(...future.workdir)
[10:59:33.295]         {
[10:59:33.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.295]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.295]             }
[10:59:33.295]             base::options(...future.oldOptions)
[10:59:33.295]             if (.Platform$OS.type == "windows") {
[10:59:33.295]                 old_names <- names(...future.oldEnvVars)
[10:59:33.295]                 envs <- base::Sys.getenv()
[10:59:33.295]                 names <- names(envs)
[10:59:33.295]                 common <- intersect(names, old_names)
[10:59:33.295]                 added <- setdiff(names, old_names)
[10:59:33.295]                 removed <- setdiff(old_names, names)
[10:59:33.295]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.295]                   envs[common]]
[10:59:33.295]                 NAMES <- toupper(changed)
[10:59:33.295]                 args <- list()
[10:59:33.295]                 for (kk in seq_along(NAMES)) {
[10:59:33.295]                   name <- changed[[kk]]
[10:59:33.295]                   NAME <- NAMES[[kk]]
[10:59:33.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.295]                     next
[10:59:33.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.295]                 }
[10:59:33.295]                 NAMES <- toupper(added)
[10:59:33.295]                 for (kk in seq_along(NAMES)) {
[10:59:33.295]                   name <- added[[kk]]
[10:59:33.295]                   NAME <- NAMES[[kk]]
[10:59:33.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.295]                     next
[10:59:33.295]                   args[[name]] <- ""
[10:59:33.295]                 }
[10:59:33.295]                 NAMES <- toupper(removed)
[10:59:33.295]                 for (kk in seq_along(NAMES)) {
[10:59:33.295]                   name <- removed[[kk]]
[10:59:33.295]                   NAME <- NAMES[[kk]]
[10:59:33.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.295]                     next
[10:59:33.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.295]                 }
[10:59:33.295]                 if (length(args) > 0) 
[10:59:33.295]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.295]             }
[10:59:33.295]             else {
[10:59:33.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.295]             }
[10:59:33.295]             {
[10:59:33.295]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.295]                   0L) {
[10:59:33.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.295]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.295]                   base::options(opts)
[10:59:33.295]                 }
[10:59:33.295]                 {
[10:59:33.295]                   {
[10:59:33.295]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.295]                     NULL
[10:59:33.295]                   }
[10:59:33.295]                   options(future.plan = NULL)
[10:59:33.295]                   if (is.na(NA_character_)) 
[10:59:33.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.295]                     .init = FALSE)
[10:59:33.295]                 }
[10:59:33.295]             }
[10:59:33.295]         }
[10:59:33.295]     })
[10:59:33.295]     if (TRUE) {
[10:59:33.295]         base::sink(type = "output", split = FALSE)
[10:59:33.295]         if (TRUE) {
[10:59:33.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.295]         }
[10:59:33.295]         else {
[10:59:33.295]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.295]         }
[10:59:33.295]         base::close(...future.stdout)
[10:59:33.295]         ...future.stdout <- NULL
[10:59:33.295]     }
[10:59:33.295]     ...future.result$conditions <- ...future.conditions
[10:59:33.295]     ...future.result$finished <- base::Sys.time()
[10:59:33.295]     ...future.result
[10:59:33.295] }
[10:59:33.298] assign_globals() ...
[10:59:33.298] List of 5
[10:59:33.298]  $ ...future.FUN            :function (x, y)  
[10:59:33.298]  $ MoreArgs                 :List of 1
[10:59:33.298]   ..$ y: int [1:2] 3 4
[10:59:33.298]  $ ...future.elements_ii    :List of 1
[10:59:33.298]   ..$ x:List of 1
[10:59:33.298]   .. ..$ : int 1
[10:59:33.298]  $ ...future.seeds_ii       : NULL
[10:59:33.298]  $ ...future.globals.maxSize: NULL
[10:59:33.298]  - attr(*, "where")=List of 5
[10:59:33.298]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.298]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.298]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.298]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.298]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.298]  - attr(*, "resolved")= logi FALSE
[10:59:33.298]  - attr(*, "total_size")= num 656
[10:59:33.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.298]  - attr(*, "already-done")= logi TRUE
[10:59:33.303] - reassign environment for ‘...future.FUN’
[10:59:33.303] - copied ‘...future.FUN’ to environment
[10:59:33.303] - copied ‘MoreArgs’ to environment
[10:59:33.303] - copied ‘...future.elements_ii’ to environment
[10:59:33.303] - copied ‘...future.seeds_ii’ to environment
[10:59:33.303] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.303] assign_globals() ... done
[10:59:33.303] requestCore(): workers = 2
[10:59:33.305] MulticoreFuture started
[10:59:33.306] - Launch lazy future ... done
[10:59:33.306] run() for ‘MulticoreFuture’ ... done
[10:59:33.306] Created future:
[10:59:33.306] plan(): Setting new future strategy stack:
[10:59:33.307] List of future strategies:
[10:59:33.307] 1. sequential:
[10:59:33.307]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.307]    - tweaked: FALSE
[10:59:33.307]    - call: NULL
[10:59:33.308] plan(): nbrOfWorkers() = 1
[10:59:33.310] plan(): Setting new future strategy stack:
[10:59:33.310] List of future strategies:
[10:59:33.310] 1. multicore:
[10:59:33.310]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.310]    - tweaked: FALSE
[10:59:33.310]    - call: plan(strategy)
[10:59:33.313] plan(): nbrOfWorkers() = 2
[10:59:33.306] MulticoreFuture:
[10:59:33.306] Label: ‘future_mapply-1’
[10:59:33.306] Expression:
[10:59:33.306] {
[10:59:33.306]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.306]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.306]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.306]         on.exit(options(oopts), add = TRUE)
[10:59:33.306]     }
[10:59:33.306]     {
[10:59:33.306]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.306]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.306]         do.call(mapply, args = args)
[10:59:33.306]     }
[10:59:33.306] }
[10:59:33.306] Lazy evaluation: FALSE
[10:59:33.306] Asynchronous evaluation: TRUE
[10:59:33.306] Local evaluation: TRUE
[10:59:33.306] Environment: R_GlobalEnv
[10:59:33.306] Capture standard output: TRUE
[10:59:33.306] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.306] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.306] Packages: <none>
[10:59:33.306] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.306] Resolved: TRUE
[10:59:33.306] Value: <not collected>
[10:59:33.306] Conditions captured: <none>
[10:59:33.306] Early signaling: FALSE
[10:59:33.306] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.306] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.314] Chunk #1 of 2 ... DONE
[10:59:33.314] Chunk #2 of 2 ...
[10:59:33.315]  - Finding globals in '...' for chunk #2 ...
[10:59:33.315] getGlobalsAndPackages() ...
[10:59:33.315] Searching for globals...
[10:59:33.316] 
[10:59:33.316] Searching for globals ... DONE
[10:59:33.316] - globals: [0] <none>
[10:59:33.316] getGlobalsAndPackages() ... DONE
[10:59:33.316]    + additional globals found: [n=0] 
[10:59:33.316]    + additional namespaces needed: [n=0] 
[10:59:33.316]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.316]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.317]  - seeds: <none>
[10:59:33.317]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.317] getGlobalsAndPackages() ...
[10:59:33.317] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.317] Resolving globals: FALSE
[10:59:33.318] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:33.319] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:33.319] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.319] 
[10:59:33.319] getGlobalsAndPackages() ... DONE
[10:59:33.320] run() for ‘Future’ ...
[10:59:33.320] - state: ‘created’
[10:59:33.320] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.327] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.327] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.327]   - Field: ‘label’
[10:59:33.328]   - Field: ‘local’
[10:59:33.328]   - Field: ‘owner’
[10:59:33.328]   - Field: ‘envir’
[10:59:33.328]   - Field: ‘workers’
[10:59:33.329]   - Field: ‘packages’
[10:59:33.329]   - Field: ‘gc’
[10:59:33.329]   - Field: ‘job’
[10:59:33.329]   - Field: ‘conditions’
[10:59:33.330]   - Field: ‘expr’
[10:59:33.330]   - Field: ‘uuid’
[10:59:33.330]   - Field: ‘seed’
[10:59:33.330]   - Field: ‘version’
[10:59:33.330]   - Field: ‘result’
[10:59:33.331]   - Field: ‘asynchronous’
[10:59:33.331]   - Field: ‘calls’
[10:59:33.331]   - Field: ‘globals’
[10:59:33.331]   - Field: ‘stdout’
[10:59:33.331]   - Field: ‘earlySignal’
[10:59:33.331]   - Field: ‘lazy’
[10:59:33.332]   - Field: ‘state’
[10:59:33.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.332] - Launch lazy future ...
[10:59:33.333] Packages needed by the future expression (n = 0): <none>
[10:59:33.333] Packages needed by future strategies (n = 0): <none>
[10:59:33.334] {
[10:59:33.334]     {
[10:59:33.334]         {
[10:59:33.334]             ...future.startTime <- base::Sys.time()
[10:59:33.334]             {
[10:59:33.334]                 {
[10:59:33.334]                   {
[10:59:33.334]                     {
[10:59:33.334]                       base::local({
[10:59:33.334]                         has_future <- base::requireNamespace("future", 
[10:59:33.334]                           quietly = TRUE)
[10:59:33.334]                         if (has_future) {
[10:59:33.334]                           ns <- base::getNamespace("future")
[10:59:33.334]                           version <- ns[[".package"]][["version"]]
[10:59:33.334]                           if (is.null(version)) 
[10:59:33.334]                             version <- utils::packageVersion("future")
[10:59:33.334]                         }
[10:59:33.334]                         else {
[10:59:33.334]                           version <- NULL
[10:59:33.334]                         }
[10:59:33.334]                         if (!has_future || version < "1.8.0") {
[10:59:33.334]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.334]                             "", base::R.version$version.string), 
[10:59:33.334]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.334]                               "release", "version")], collapse = " "), 
[10:59:33.334]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.334]                             info)
[10:59:33.334]                           info <- base::paste(info, collapse = "; ")
[10:59:33.334]                           if (!has_future) {
[10:59:33.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.334]                               info)
[10:59:33.334]                           }
[10:59:33.334]                           else {
[10:59:33.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.334]                               info, version)
[10:59:33.334]                           }
[10:59:33.334]                           base::stop(msg)
[10:59:33.334]                         }
[10:59:33.334]                       })
[10:59:33.334]                     }
[10:59:33.334]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.334]                     base::options(mc.cores = 1L)
[10:59:33.334]                   }
[10:59:33.334]                   ...future.strategy.old <- future::plan("list")
[10:59:33.334]                   options(future.plan = NULL)
[10:59:33.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.334]                 }
[10:59:33.334]                 ...future.workdir <- getwd()
[10:59:33.334]             }
[10:59:33.334]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.334]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.334]         }
[10:59:33.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.334]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.334]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.334]             base::names(...future.oldOptions))
[10:59:33.334]     }
[10:59:33.334]     if (FALSE) {
[10:59:33.334]     }
[10:59:33.334]     else {
[10:59:33.334]         if (TRUE) {
[10:59:33.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.334]                 open = "w")
[10:59:33.334]         }
[10:59:33.334]         else {
[10:59:33.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.334]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.334]         }
[10:59:33.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.334]             base::sink(type = "output", split = FALSE)
[10:59:33.334]             base::close(...future.stdout)
[10:59:33.334]         }, add = TRUE)
[10:59:33.334]     }
[10:59:33.334]     ...future.frame <- base::sys.nframe()
[10:59:33.334]     ...future.conditions <- base::list()
[10:59:33.334]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.334]     if (FALSE) {
[10:59:33.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.334]     }
[10:59:33.334]     ...future.result <- base::tryCatch({
[10:59:33.334]         base::withCallingHandlers({
[10:59:33.334]             ...future.value <- base::withVisible(base::local({
[10:59:33.334]                 withCallingHandlers({
[10:59:33.334]                   {
[10:59:33.334]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.334]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.334]                       ...future.globals.maxSize)) {
[10:59:33.334]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.334]                       on.exit(options(oopts), add = TRUE)
[10:59:33.334]                     }
[10:59:33.334]                     {
[10:59:33.334]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.334]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.334]                         USE.NAMES = FALSE)
[10:59:33.334]                       do.call(mapply, args = args)
[10:59:33.334]                     }
[10:59:33.334]                   }
[10:59:33.334]                 }, immediateCondition = function(cond) {
[10:59:33.334]                   save_rds <- function (object, pathname, ...) 
[10:59:33.334]                   {
[10:59:33.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.334]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.334]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.334]                         fi_tmp[["mtime"]])
[10:59:33.334]                     }
[10:59:33.334]                     tryCatch({
[10:59:33.334]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.334]                     }, error = function(ex) {
[10:59:33.334]                       msg <- conditionMessage(ex)
[10:59:33.334]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.334]                         fi_tmp[["mtime"]], msg)
[10:59:33.334]                       ex$message <- msg
[10:59:33.334]                       stop(ex)
[10:59:33.334]                     })
[10:59:33.334]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.334]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.334]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.334]                       fi <- file.info(pathname)
[10:59:33.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.334]                         fi[["size"]], fi[["mtime"]])
[10:59:33.334]                       stop(msg)
[10:59:33.334]                     }
[10:59:33.334]                     invisible(pathname)
[10:59:33.334]                   }
[10:59:33.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.334]                     rootPath = tempdir()) 
[10:59:33.334]                   {
[10:59:33.334]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.334]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.334]                       tmpdir = path, fileext = ".rds")
[10:59:33.334]                     save_rds(obj, file)
[10:59:33.334]                   }
[10:59:33.334]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.334]                   {
[10:59:33.334]                     inherits <- base::inherits
[10:59:33.334]                     invokeRestart <- base::invokeRestart
[10:59:33.334]                     is.null <- base::is.null
[10:59:33.334]                     muffled <- FALSE
[10:59:33.334]                     if (inherits(cond, "message")) {
[10:59:33.334]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.334]                       if (muffled) 
[10:59:33.334]                         invokeRestart("muffleMessage")
[10:59:33.334]                     }
[10:59:33.334]                     else if (inherits(cond, "warning")) {
[10:59:33.334]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.334]                       if (muffled) 
[10:59:33.334]                         invokeRestart("muffleWarning")
[10:59:33.334]                     }
[10:59:33.334]                     else if (inherits(cond, "condition")) {
[10:59:33.334]                       if (!is.null(pattern)) {
[10:59:33.334]                         computeRestarts <- base::computeRestarts
[10:59:33.334]                         grepl <- base::grepl
[10:59:33.334]                         restarts <- computeRestarts(cond)
[10:59:33.334]                         for (restart in restarts) {
[10:59:33.334]                           name <- restart$name
[10:59:33.334]                           if (is.null(name)) 
[10:59:33.334]                             next
[10:59:33.334]                           if (!grepl(pattern, name)) 
[10:59:33.334]                             next
[10:59:33.334]                           invokeRestart(restart)
[10:59:33.334]                           muffled <- TRUE
[10:59:33.334]                           break
[10:59:33.334]                         }
[10:59:33.334]                       }
[10:59:33.334]                     }
[10:59:33.334]                     invisible(muffled)
[10:59:33.334]                   }
[10:59:33.334]                   muffleCondition(cond)
[10:59:33.334]                 })
[10:59:33.334]             }))
[10:59:33.334]             future::FutureResult(value = ...future.value$value, 
[10:59:33.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.334]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.334]                     ...future.globalenv.names))
[10:59:33.334]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.334]         }, condition = base::local({
[10:59:33.334]             c <- base::c
[10:59:33.334]             inherits <- base::inherits
[10:59:33.334]             invokeRestart <- base::invokeRestart
[10:59:33.334]             length <- base::length
[10:59:33.334]             list <- base::list
[10:59:33.334]             seq.int <- base::seq.int
[10:59:33.334]             signalCondition <- base::signalCondition
[10:59:33.334]             sys.calls <- base::sys.calls
[10:59:33.334]             `[[` <- base::`[[`
[10:59:33.334]             `+` <- base::`+`
[10:59:33.334]             `<<-` <- base::`<<-`
[10:59:33.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.334]                   3L)]
[10:59:33.334]             }
[10:59:33.334]             function(cond) {
[10:59:33.334]                 is_error <- inherits(cond, "error")
[10:59:33.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.334]                   NULL)
[10:59:33.334]                 if (is_error) {
[10:59:33.334]                   sessionInformation <- function() {
[10:59:33.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.334]                       search = base::search(), system = base::Sys.info())
[10:59:33.334]                   }
[10:59:33.334]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.334]                     cond$call), session = sessionInformation(), 
[10:59:33.334]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.334]                   signalCondition(cond)
[10:59:33.334]                 }
[10:59:33.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.334]                 "immediateCondition"))) {
[10:59:33.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.334]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.334]                   if (TRUE && !signal) {
[10:59:33.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.334]                     {
[10:59:33.334]                       inherits <- base::inherits
[10:59:33.334]                       invokeRestart <- base::invokeRestart
[10:59:33.334]                       is.null <- base::is.null
[10:59:33.334]                       muffled <- FALSE
[10:59:33.334]                       if (inherits(cond, "message")) {
[10:59:33.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.334]                         if (muffled) 
[10:59:33.334]                           invokeRestart("muffleMessage")
[10:59:33.334]                       }
[10:59:33.334]                       else if (inherits(cond, "warning")) {
[10:59:33.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.334]                         if (muffled) 
[10:59:33.334]                           invokeRestart("muffleWarning")
[10:59:33.334]                       }
[10:59:33.334]                       else if (inherits(cond, "condition")) {
[10:59:33.334]                         if (!is.null(pattern)) {
[10:59:33.334]                           computeRestarts <- base::computeRestarts
[10:59:33.334]                           grepl <- base::grepl
[10:59:33.334]                           restarts <- computeRestarts(cond)
[10:59:33.334]                           for (restart in restarts) {
[10:59:33.334]                             name <- restart$name
[10:59:33.334]                             if (is.null(name)) 
[10:59:33.334]                               next
[10:59:33.334]                             if (!grepl(pattern, name)) 
[10:59:33.334]                               next
[10:59:33.334]                             invokeRestart(restart)
[10:59:33.334]                             muffled <- TRUE
[10:59:33.334]                             break
[10:59:33.334]                           }
[10:59:33.334]                         }
[10:59:33.334]                       }
[10:59:33.334]                       invisible(muffled)
[10:59:33.334]                     }
[10:59:33.334]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.334]                   }
[10:59:33.334]                 }
[10:59:33.334]                 else {
[10:59:33.334]                   if (TRUE) {
[10:59:33.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.334]                     {
[10:59:33.334]                       inherits <- base::inherits
[10:59:33.334]                       invokeRestart <- base::invokeRestart
[10:59:33.334]                       is.null <- base::is.null
[10:59:33.334]                       muffled <- FALSE
[10:59:33.334]                       if (inherits(cond, "message")) {
[10:59:33.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.334]                         if (muffled) 
[10:59:33.334]                           invokeRestart("muffleMessage")
[10:59:33.334]                       }
[10:59:33.334]                       else if (inherits(cond, "warning")) {
[10:59:33.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.334]                         if (muffled) 
[10:59:33.334]                           invokeRestart("muffleWarning")
[10:59:33.334]                       }
[10:59:33.334]                       else if (inherits(cond, "condition")) {
[10:59:33.334]                         if (!is.null(pattern)) {
[10:59:33.334]                           computeRestarts <- base::computeRestarts
[10:59:33.334]                           grepl <- base::grepl
[10:59:33.334]                           restarts <- computeRestarts(cond)
[10:59:33.334]                           for (restart in restarts) {
[10:59:33.334]                             name <- restart$name
[10:59:33.334]                             if (is.null(name)) 
[10:59:33.334]                               next
[10:59:33.334]                             if (!grepl(pattern, name)) 
[10:59:33.334]                               next
[10:59:33.334]                             invokeRestart(restart)
[10:59:33.334]                             muffled <- TRUE
[10:59:33.334]                             break
[10:59:33.334]                           }
[10:59:33.334]                         }
[10:59:33.334]                       }
[10:59:33.334]                       invisible(muffled)
[10:59:33.334]                     }
[10:59:33.334]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.334]                   }
[10:59:33.334]                 }
[10:59:33.334]             }
[10:59:33.334]         }))
[10:59:33.334]     }, error = function(ex) {
[10:59:33.334]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.334]                 ...future.rng), started = ...future.startTime, 
[10:59:33.334]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.334]             version = "1.8"), class = "FutureResult")
[10:59:33.334]     }, finally = {
[10:59:33.334]         if (!identical(...future.workdir, getwd())) 
[10:59:33.334]             setwd(...future.workdir)
[10:59:33.334]         {
[10:59:33.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.334]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.334]             }
[10:59:33.334]             base::options(...future.oldOptions)
[10:59:33.334]             if (.Platform$OS.type == "windows") {
[10:59:33.334]                 old_names <- names(...future.oldEnvVars)
[10:59:33.334]                 envs <- base::Sys.getenv()
[10:59:33.334]                 names <- names(envs)
[10:59:33.334]                 common <- intersect(names, old_names)
[10:59:33.334]                 added <- setdiff(names, old_names)
[10:59:33.334]                 removed <- setdiff(old_names, names)
[10:59:33.334]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.334]                   envs[common]]
[10:59:33.334]                 NAMES <- toupper(changed)
[10:59:33.334]                 args <- list()
[10:59:33.334]                 for (kk in seq_along(NAMES)) {
[10:59:33.334]                   name <- changed[[kk]]
[10:59:33.334]                   NAME <- NAMES[[kk]]
[10:59:33.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.334]                     next
[10:59:33.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.334]                 }
[10:59:33.334]                 NAMES <- toupper(added)
[10:59:33.334]                 for (kk in seq_along(NAMES)) {
[10:59:33.334]                   name <- added[[kk]]
[10:59:33.334]                   NAME <- NAMES[[kk]]
[10:59:33.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.334]                     next
[10:59:33.334]                   args[[name]] <- ""
[10:59:33.334]                 }
[10:59:33.334]                 NAMES <- toupper(removed)
[10:59:33.334]                 for (kk in seq_along(NAMES)) {
[10:59:33.334]                   name <- removed[[kk]]
[10:59:33.334]                   NAME <- NAMES[[kk]]
[10:59:33.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.334]                     next
[10:59:33.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.334]                 }
[10:59:33.334]                 if (length(args) > 0) 
[10:59:33.334]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.334]             }
[10:59:33.334]             else {
[10:59:33.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.334]             }
[10:59:33.334]             {
[10:59:33.334]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.334]                   0L) {
[10:59:33.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.334]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.334]                   base::options(opts)
[10:59:33.334]                 }
[10:59:33.334]                 {
[10:59:33.334]                   {
[10:59:33.334]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.334]                     NULL
[10:59:33.334]                   }
[10:59:33.334]                   options(future.plan = NULL)
[10:59:33.334]                   if (is.na(NA_character_)) 
[10:59:33.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.334]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.334]                     .init = FALSE)
[10:59:33.334]                 }
[10:59:33.334]             }
[10:59:33.334]         }
[10:59:33.334]     })
[10:59:33.334]     if (TRUE) {
[10:59:33.334]         base::sink(type = "output", split = FALSE)
[10:59:33.334]         if (TRUE) {
[10:59:33.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.334]         }
[10:59:33.334]         else {
[10:59:33.334]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.334]         }
[10:59:33.334]         base::close(...future.stdout)
[10:59:33.334]         ...future.stdout <- NULL
[10:59:33.334]     }
[10:59:33.334]     ...future.result$conditions <- ...future.conditions
[10:59:33.334]     ...future.result$finished <- base::Sys.time()
[10:59:33.334]     ...future.result
[10:59:33.334] }
[10:59:33.337] assign_globals() ...
[10:59:33.337] List of 5
[10:59:33.337]  $ ...future.FUN            :function (x, y)  
[10:59:33.337]  $ MoreArgs                 :List of 1
[10:59:33.337]   ..$ y: int [1:2] 3 4
[10:59:33.337]  $ ...future.elements_ii    :List of 1
[10:59:33.337]   ..$ x:List of 1
[10:59:33.337]   .. ..$ : int 2
[10:59:33.337]  $ ...future.seeds_ii       : NULL
[10:59:33.337]  $ ...future.globals.maxSize: NULL
[10:59:33.337]  - attr(*, "where")=List of 5
[10:59:33.337]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.337]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.337]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.337]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.337]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.337]  - attr(*, "resolved")= logi FALSE
[10:59:33.337]  - attr(*, "total_size")= num 656
[10:59:33.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.337]  - attr(*, "already-done")= logi TRUE
[10:59:33.344] - reassign environment for ‘...future.FUN’
[10:59:33.344] - copied ‘...future.FUN’ to environment
[10:59:33.344] - copied ‘MoreArgs’ to environment
[10:59:33.344] - copied ‘...future.elements_ii’ to environment
[10:59:33.345] - copied ‘...future.seeds_ii’ to environment
[10:59:33.345] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.345] assign_globals() ... done
[10:59:33.345] requestCore(): workers = 2
[10:59:33.347] MulticoreFuture started
[10:59:33.347] - Launch lazy future ... done
[10:59:33.348] run() for ‘MulticoreFuture’ ... done
[10:59:33.348] Created future:
[10:59:33.348] plan(): Setting new future strategy stack:
[10:59:33.348] List of future strategies:
[10:59:33.348] 1. sequential:
[10:59:33.348]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.348]    - tweaked: FALSE
[10:59:33.348]    - call: NULL
[10:59:33.349] plan(): nbrOfWorkers() = 1
[10:59:33.351] plan(): Setting new future strategy stack:
[10:59:33.352] List of future strategies:
[10:59:33.352] 1. multicore:
[10:59:33.352]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.352]    - tweaked: FALSE
[10:59:33.352]    - call: plan(strategy)
[10:59:33.355] plan(): nbrOfWorkers() = 2
[10:59:33.348] MulticoreFuture:
[10:59:33.348] Label: ‘future_mapply-2’
[10:59:33.348] Expression:
[10:59:33.348] {
[10:59:33.348]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.348]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.348]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.348]         on.exit(options(oopts), add = TRUE)
[10:59:33.348]     }
[10:59:33.348]     {
[10:59:33.348]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.348]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.348]         do.call(mapply, args = args)
[10:59:33.348]     }
[10:59:33.348] }
[10:59:33.348] Lazy evaluation: FALSE
[10:59:33.348] Asynchronous evaluation: TRUE
[10:59:33.348] Local evaluation: TRUE
[10:59:33.348] Environment: R_GlobalEnv
[10:59:33.348] Capture standard output: TRUE
[10:59:33.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.348] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.348] Packages: <none>
[10:59:33.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.348] Resolved: TRUE
[10:59:33.348] Value: <not collected>
[10:59:33.348] Conditions captured: <none>
[10:59:33.348] Early signaling: FALSE
[10:59:33.348] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.348] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.356] Chunk #2 of 2 ... DONE
[10:59:33.356] Launching 2 futures (chunks) ... DONE
[10:59:33.356] Resolving 2 futures (chunks) ...
[10:59:33.356] resolve() on list ...
[10:59:33.356]  recursive: 0
[10:59:33.356]  length: 2
[10:59:33.357] 
[10:59:33.357] Future #1
[10:59:33.357] result() for MulticoreFuture ...
[10:59:33.358] result() for MulticoreFuture ...
[10:59:33.358] result() for MulticoreFuture ... done
[10:59:33.358] result() for MulticoreFuture ... done
[10:59:33.358] result() for MulticoreFuture ...
[10:59:33.358] result() for MulticoreFuture ... done
[10:59:33.359] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.359] - nx: 2
[10:59:33.359] - relay: TRUE
[10:59:33.359] - stdout: TRUE
[10:59:33.359] - signal: TRUE
[10:59:33.359] - resignal: FALSE
[10:59:33.359] - force: TRUE
[10:59:33.360] - relayed: [n=2] FALSE, FALSE
[10:59:33.360] - queued futures: [n=2] FALSE, FALSE
[10:59:33.360]  - until=1
[10:59:33.360]  - relaying element #1
[10:59:33.360] result() for MulticoreFuture ...
[10:59:33.360] result() for MulticoreFuture ... done
[10:59:33.361] result() for MulticoreFuture ...
[10:59:33.361] result() for MulticoreFuture ... done
[10:59:33.361] result() for MulticoreFuture ...
[10:59:33.361] result() for MulticoreFuture ... done
[10:59:33.361] result() for MulticoreFuture ...
[10:59:33.361] result() for MulticoreFuture ... done
[10:59:33.361] - relayed: [n=2] TRUE, FALSE
[10:59:33.362] - queued futures: [n=2] TRUE, FALSE
[10:59:33.362] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.362]  length: 1 (resolved future 1)
[10:59:33.362] Future #2
[10:59:33.362] result() for MulticoreFuture ...
[10:59:33.363] result() for MulticoreFuture ...
[10:59:33.363] result() for MulticoreFuture ... done
[10:59:33.363] result() for MulticoreFuture ... done
[10:59:33.364] result() for MulticoreFuture ...
[10:59:33.364] result() for MulticoreFuture ... done
[10:59:33.364] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.364] - nx: 2
[10:59:33.364] - relay: TRUE
[10:59:33.364] - stdout: TRUE
[10:59:33.364] - signal: TRUE
[10:59:33.365] - resignal: FALSE
[10:59:33.365] - force: TRUE
[10:59:33.365] - relayed: [n=2] TRUE, FALSE
[10:59:33.365] - queued futures: [n=2] TRUE, FALSE
[10:59:33.365]  - until=2
[10:59:33.365]  - relaying element #2
[10:59:33.365] result() for MulticoreFuture ...
[10:59:33.365] result() for MulticoreFuture ... done
[10:59:33.365] result() for MulticoreFuture ...
[10:59:33.366] result() for MulticoreFuture ... done
[10:59:33.368] result() for MulticoreFuture ...
[10:59:33.368] result() for MulticoreFuture ... done
[10:59:33.369] result() for MulticoreFuture ...
[10:59:33.369] result() for MulticoreFuture ... done
[10:59:33.369] - relayed: [n=2] TRUE, TRUE
[10:59:33.369] - queued futures: [n=2] TRUE, TRUE
[10:59:33.369] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.369]  length: 0 (resolved future 2)
[10:59:33.369] Relaying remaining futures
[10:59:33.370] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.370] - nx: 2
[10:59:33.370] - relay: TRUE
[10:59:33.370] - stdout: TRUE
[10:59:33.370] - signal: TRUE
[10:59:33.370] - resignal: FALSE
[10:59:33.370] - force: TRUE
[10:59:33.371] - relayed: [n=2] TRUE, TRUE
[10:59:33.371] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.371] - relayed: [n=2] TRUE, TRUE
[10:59:33.371] - queued futures: [n=2] TRUE, TRUE
[10:59:33.371] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.371] resolve() on list ... DONE
[10:59:33.371] result() for MulticoreFuture ...
[10:59:33.372] result() for MulticoreFuture ... done
[10:59:33.372] result() for MulticoreFuture ...
[10:59:33.372] result() for MulticoreFuture ... done
[10:59:33.372] result() for MulticoreFuture ...
[10:59:33.372] result() for MulticoreFuture ... done
[10:59:33.372] result() for MulticoreFuture ...
[10:59:33.372] result() for MulticoreFuture ... done
[10:59:33.372]  - Number of value chunks collected: 2
[10:59:33.373] Resolving 2 futures (chunks) ... DONE
[10:59:33.373] Reducing values from 2 chunks ...
[10:59:33.373]  - Number of values collected after concatenation: 2
[10:59:33.373]  - Number of values expected: 2
[10:59:33.373] Reducing values from 2 chunks ... DONE
[10:59:33.373] future_mapply() ... DONE
[10:59:33.373] future_mapply() ...
[10:59:33.374] Generating random seeds ...
[10:59:33.374] Generating random seed streams for 2 elements ...
[10:59:33.374] Generating random seed streams for 2 elements ... DONE
[10:59:33.374] Generating random seeds ... DONE
[10:59:33.374] Will set RNG state on exit: 10407, -1268229531, 1261190591, -1456079852, 724716582, 1228132657, -1577885622
[10:59:33.376] Number of chunks: 2
[10:59:33.376] getGlobalsAndPackagesXApply() ...
[10:59:33.377]  - future.globals: TRUE
[10:59:33.377] getGlobalsAndPackages() ...
[10:59:33.377] Searching for globals...
[10:59:33.378] - globals found: [1] ‘FUN’
[10:59:33.378] Searching for globals ... DONE
[10:59:33.378] Resolving globals: FALSE
[10:59:33.379] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:33.379] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:33.379] - globals: [1] ‘FUN’
[10:59:33.379] 
[10:59:33.380] getGlobalsAndPackages() ... DONE
[10:59:33.380]  - globals found/used: [n=1] ‘FUN’
[10:59:33.380]  - needed namespaces: [n=0] 
[10:59:33.380] Finding globals ... DONE
[10:59:33.380] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.380] List of 2
[10:59:33.380]  $ ...future.FUN:function (x, y)  
[10:59:33.380]  $ MoreArgs     :List of 1
[10:59:33.380]   ..$ y: int [1:2] 3 4
[10:59:33.380]  - attr(*, "where")=List of 2
[10:59:33.380]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.380]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.380]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.380]  - attr(*, "resolved")= logi FALSE
[10:59:33.380]  - attr(*, "total_size")= num NA
[10:59:33.383] Packages to be attached in all futures: [n=0] 
[10:59:33.383] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.384] Number of futures (= number of chunks): 2
[10:59:33.384] Launching 2 futures (chunks) ...
[10:59:33.384] Chunk #1 of 2 ...
[10:59:33.384]  - Finding globals in '...' for chunk #1 ...
[10:59:33.384] getGlobalsAndPackages() ...
[10:59:33.384] Searching for globals...
[10:59:33.384] 
[10:59:33.384] Searching for globals ... DONE
[10:59:33.385] - globals: [0] <none>
[10:59:33.385] getGlobalsAndPackages() ... DONE
[10:59:33.385]    + additional globals found: [n=0] 
[10:59:33.385]    + additional namespaces needed: [n=0] 
[10:59:33.385]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.385]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.385]  - seeds: [1] <seeds>
[10:59:33.385]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.385] getGlobalsAndPackages() ...
[10:59:33.385] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.385] Resolving globals: FALSE
[10:59:33.386] The total size of the 5 globals is 696 bytes (696 bytes)
[10:59:33.386] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:33.386] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.387] 
[10:59:33.387] getGlobalsAndPackages() ... DONE
[10:59:33.387] run() for ‘Future’ ...
[10:59:33.387] - state: ‘created’
[10:59:33.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.389] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.389]   - Field: ‘label’
[10:59:33.389]   - Field: ‘local’
[10:59:33.389]   - Field: ‘owner’
[10:59:33.389]   - Field: ‘envir’
[10:59:33.389]   - Field: ‘workers’
[10:59:33.389]   - Field: ‘packages’
[10:59:33.389]   - Field: ‘gc’
[10:59:33.390]   - Field: ‘job’
[10:59:33.390]   - Field: ‘conditions’
[10:59:33.390]   - Field: ‘expr’
[10:59:33.390]   - Field: ‘uuid’
[10:59:33.390]   - Field: ‘seed’
[10:59:33.390]   - Field: ‘version’
[10:59:33.390]   - Field: ‘result’
[10:59:33.390]   - Field: ‘asynchronous’
[10:59:33.390]   - Field: ‘calls’
[10:59:33.390]   - Field: ‘globals’
[10:59:33.390]   - Field: ‘stdout’
[10:59:33.390]   - Field: ‘earlySignal’
[10:59:33.392]   - Field: ‘lazy’
[10:59:33.392]   - Field: ‘state’
[10:59:33.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.393] - Launch lazy future ...
[10:59:33.393] Packages needed by the future expression (n = 0): <none>
[10:59:33.393] Packages needed by future strategies (n = 0): <none>
[10:59:33.393] {
[10:59:33.393]     {
[10:59:33.393]         {
[10:59:33.393]             ...future.startTime <- base::Sys.time()
[10:59:33.393]             {
[10:59:33.393]                 {
[10:59:33.393]                   {
[10:59:33.393]                     {
[10:59:33.393]                       base::local({
[10:59:33.393]                         has_future <- base::requireNamespace("future", 
[10:59:33.393]                           quietly = TRUE)
[10:59:33.393]                         if (has_future) {
[10:59:33.393]                           ns <- base::getNamespace("future")
[10:59:33.393]                           version <- ns[[".package"]][["version"]]
[10:59:33.393]                           if (is.null(version)) 
[10:59:33.393]                             version <- utils::packageVersion("future")
[10:59:33.393]                         }
[10:59:33.393]                         else {
[10:59:33.393]                           version <- NULL
[10:59:33.393]                         }
[10:59:33.393]                         if (!has_future || version < "1.8.0") {
[10:59:33.393]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.393]                             "", base::R.version$version.string), 
[10:59:33.393]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.393]                               "release", "version")], collapse = " "), 
[10:59:33.393]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.393]                             info)
[10:59:33.393]                           info <- base::paste(info, collapse = "; ")
[10:59:33.393]                           if (!has_future) {
[10:59:33.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.393]                               info)
[10:59:33.393]                           }
[10:59:33.393]                           else {
[10:59:33.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.393]                               info, version)
[10:59:33.393]                           }
[10:59:33.393]                           base::stop(msg)
[10:59:33.393]                         }
[10:59:33.393]                       })
[10:59:33.393]                     }
[10:59:33.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.393]                     base::options(mc.cores = 1L)
[10:59:33.393]                   }
[10:59:33.393]                   ...future.strategy.old <- future::plan("list")
[10:59:33.393]                   options(future.plan = NULL)
[10:59:33.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.393]                 }
[10:59:33.393]                 ...future.workdir <- getwd()
[10:59:33.393]             }
[10:59:33.393]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.393]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.393]         }
[10:59:33.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.393]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.393]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.393]             base::names(...future.oldOptions))
[10:59:33.393]     }
[10:59:33.393]     if (FALSE) {
[10:59:33.393]     }
[10:59:33.393]     else {
[10:59:33.393]         if (TRUE) {
[10:59:33.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.393]                 open = "w")
[10:59:33.393]         }
[10:59:33.393]         else {
[10:59:33.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.393]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.393]         }
[10:59:33.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.393]             base::sink(type = "output", split = FALSE)
[10:59:33.393]             base::close(...future.stdout)
[10:59:33.393]         }, add = TRUE)
[10:59:33.393]     }
[10:59:33.393]     ...future.frame <- base::sys.nframe()
[10:59:33.393]     ...future.conditions <- base::list()
[10:59:33.393]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.393]     if (FALSE) {
[10:59:33.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.393]     }
[10:59:33.393]     ...future.result <- base::tryCatch({
[10:59:33.393]         base::withCallingHandlers({
[10:59:33.393]             ...future.value <- base::withVisible(base::local({
[10:59:33.393]                 withCallingHandlers({
[10:59:33.393]                   {
[10:59:33.393]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.393]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.393]                       ...future.globals.maxSize)) {
[10:59:33.393]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.393]                       on.exit(options(oopts), add = TRUE)
[10:59:33.393]                     }
[10:59:33.393]                     {
[10:59:33.393]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.393]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:33.393]                           envir = globalenv(), inherits = FALSE)
[10:59:33.393]                         ...future.FUN(...)
[10:59:33.393]                       }
[10:59:33.393]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.393]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.393]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.393]                         USE.NAMES = FALSE)
[10:59:33.393]                       do.call(mapply, args = args)
[10:59:33.393]                     }
[10:59:33.393]                   }
[10:59:33.393]                 }, immediateCondition = function(cond) {
[10:59:33.393]                   save_rds <- function (object, pathname, ...) 
[10:59:33.393]                   {
[10:59:33.393]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.393]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.393]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.393]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.393]                         fi_tmp[["mtime"]])
[10:59:33.393]                     }
[10:59:33.393]                     tryCatch({
[10:59:33.393]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.393]                     }, error = function(ex) {
[10:59:33.393]                       msg <- conditionMessage(ex)
[10:59:33.393]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.393]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.393]                         fi_tmp[["mtime"]], msg)
[10:59:33.393]                       ex$message <- msg
[10:59:33.393]                       stop(ex)
[10:59:33.393]                     })
[10:59:33.393]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.393]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.393]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.393]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.393]                       fi <- file.info(pathname)
[10:59:33.393]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.393]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.393]                         fi[["size"]], fi[["mtime"]])
[10:59:33.393]                       stop(msg)
[10:59:33.393]                     }
[10:59:33.393]                     invisible(pathname)
[10:59:33.393]                   }
[10:59:33.393]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.393]                     rootPath = tempdir()) 
[10:59:33.393]                   {
[10:59:33.393]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.393]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.393]                       tmpdir = path, fileext = ".rds")
[10:59:33.393]                     save_rds(obj, file)
[10:59:33.393]                   }
[10:59:33.393]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.393]                   {
[10:59:33.393]                     inherits <- base::inherits
[10:59:33.393]                     invokeRestart <- base::invokeRestart
[10:59:33.393]                     is.null <- base::is.null
[10:59:33.393]                     muffled <- FALSE
[10:59:33.393]                     if (inherits(cond, "message")) {
[10:59:33.393]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.393]                       if (muffled) 
[10:59:33.393]                         invokeRestart("muffleMessage")
[10:59:33.393]                     }
[10:59:33.393]                     else if (inherits(cond, "warning")) {
[10:59:33.393]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.393]                       if (muffled) 
[10:59:33.393]                         invokeRestart("muffleWarning")
[10:59:33.393]                     }
[10:59:33.393]                     else if (inherits(cond, "condition")) {
[10:59:33.393]                       if (!is.null(pattern)) {
[10:59:33.393]                         computeRestarts <- base::computeRestarts
[10:59:33.393]                         grepl <- base::grepl
[10:59:33.393]                         restarts <- computeRestarts(cond)
[10:59:33.393]                         for (restart in restarts) {
[10:59:33.393]                           name <- restart$name
[10:59:33.393]                           if (is.null(name)) 
[10:59:33.393]                             next
[10:59:33.393]                           if (!grepl(pattern, name)) 
[10:59:33.393]                             next
[10:59:33.393]                           invokeRestart(restart)
[10:59:33.393]                           muffled <- TRUE
[10:59:33.393]                           break
[10:59:33.393]                         }
[10:59:33.393]                       }
[10:59:33.393]                     }
[10:59:33.393]                     invisible(muffled)
[10:59:33.393]                   }
[10:59:33.393]                   muffleCondition(cond)
[10:59:33.393]                 })
[10:59:33.393]             }))
[10:59:33.393]             future::FutureResult(value = ...future.value$value, 
[10:59:33.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.393]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.393]                     ...future.globalenv.names))
[10:59:33.393]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.393]         }, condition = base::local({
[10:59:33.393]             c <- base::c
[10:59:33.393]             inherits <- base::inherits
[10:59:33.393]             invokeRestart <- base::invokeRestart
[10:59:33.393]             length <- base::length
[10:59:33.393]             list <- base::list
[10:59:33.393]             seq.int <- base::seq.int
[10:59:33.393]             signalCondition <- base::signalCondition
[10:59:33.393]             sys.calls <- base::sys.calls
[10:59:33.393]             `[[` <- base::`[[`
[10:59:33.393]             `+` <- base::`+`
[10:59:33.393]             `<<-` <- base::`<<-`
[10:59:33.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.393]                   3L)]
[10:59:33.393]             }
[10:59:33.393]             function(cond) {
[10:59:33.393]                 is_error <- inherits(cond, "error")
[10:59:33.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.393]                   NULL)
[10:59:33.393]                 if (is_error) {
[10:59:33.393]                   sessionInformation <- function() {
[10:59:33.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.393]                       search = base::search(), system = base::Sys.info())
[10:59:33.393]                   }
[10:59:33.393]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.393]                     cond$call), session = sessionInformation(), 
[10:59:33.393]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.393]                   signalCondition(cond)
[10:59:33.393]                 }
[10:59:33.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.393]                 "immediateCondition"))) {
[10:59:33.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.393]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.393]                   if (TRUE && !signal) {
[10:59:33.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.393]                     {
[10:59:33.393]                       inherits <- base::inherits
[10:59:33.393]                       invokeRestart <- base::invokeRestart
[10:59:33.393]                       is.null <- base::is.null
[10:59:33.393]                       muffled <- FALSE
[10:59:33.393]                       if (inherits(cond, "message")) {
[10:59:33.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.393]                         if (muffled) 
[10:59:33.393]                           invokeRestart("muffleMessage")
[10:59:33.393]                       }
[10:59:33.393]                       else if (inherits(cond, "warning")) {
[10:59:33.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.393]                         if (muffled) 
[10:59:33.393]                           invokeRestart("muffleWarning")
[10:59:33.393]                       }
[10:59:33.393]                       else if (inherits(cond, "condition")) {
[10:59:33.393]                         if (!is.null(pattern)) {
[10:59:33.393]                           computeRestarts <- base::computeRestarts
[10:59:33.393]                           grepl <- base::grepl
[10:59:33.393]                           restarts <- computeRestarts(cond)
[10:59:33.393]                           for (restart in restarts) {
[10:59:33.393]                             name <- restart$name
[10:59:33.393]                             if (is.null(name)) 
[10:59:33.393]                               next
[10:59:33.393]                             if (!grepl(pattern, name)) 
[10:59:33.393]                               next
[10:59:33.393]                             invokeRestart(restart)
[10:59:33.393]                             muffled <- TRUE
[10:59:33.393]                             break
[10:59:33.393]                           }
[10:59:33.393]                         }
[10:59:33.393]                       }
[10:59:33.393]                       invisible(muffled)
[10:59:33.393]                     }
[10:59:33.393]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.393]                   }
[10:59:33.393]                 }
[10:59:33.393]                 else {
[10:59:33.393]                   if (TRUE) {
[10:59:33.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.393]                     {
[10:59:33.393]                       inherits <- base::inherits
[10:59:33.393]                       invokeRestart <- base::invokeRestart
[10:59:33.393]                       is.null <- base::is.null
[10:59:33.393]                       muffled <- FALSE
[10:59:33.393]                       if (inherits(cond, "message")) {
[10:59:33.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.393]                         if (muffled) 
[10:59:33.393]                           invokeRestart("muffleMessage")
[10:59:33.393]                       }
[10:59:33.393]                       else if (inherits(cond, "warning")) {
[10:59:33.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.393]                         if (muffled) 
[10:59:33.393]                           invokeRestart("muffleWarning")
[10:59:33.393]                       }
[10:59:33.393]                       else if (inherits(cond, "condition")) {
[10:59:33.393]                         if (!is.null(pattern)) {
[10:59:33.393]                           computeRestarts <- base::computeRestarts
[10:59:33.393]                           grepl <- base::grepl
[10:59:33.393]                           restarts <- computeRestarts(cond)
[10:59:33.393]                           for (restart in restarts) {
[10:59:33.393]                             name <- restart$name
[10:59:33.393]                             if (is.null(name)) 
[10:59:33.393]                               next
[10:59:33.393]                             if (!grepl(pattern, name)) 
[10:59:33.393]                               next
[10:59:33.393]                             invokeRestart(restart)
[10:59:33.393]                             muffled <- TRUE
[10:59:33.393]                             break
[10:59:33.393]                           }
[10:59:33.393]                         }
[10:59:33.393]                       }
[10:59:33.393]                       invisible(muffled)
[10:59:33.393]                     }
[10:59:33.393]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.393]                   }
[10:59:33.393]                 }
[10:59:33.393]             }
[10:59:33.393]         }))
[10:59:33.393]     }, error = function(ex) {
[10:59:33.393]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.393]                 ...future.rng), started = ...future.startTime, 
[10:59:33.393]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.393]             version = "1.8"), class = "FutureResult")
[10:59:33.393]     }, finally = {
[10:59:33.393]         if (!identical(...future.workdir, getwd())) 
[10:59:33.393]             setwd(...future.workdir)
[10:59:33.393]         {
[10:59:33.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.393]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.393]             }
[10:59:33.393]             base::options(...future.oldOptions)
[10:59:33.393]             if (.Platform$OS.type == "windows") {
[10:59:33.393]                 old_names <- names(...future.oldEnvVars)
[10:59:33.393]                 envs <- base::Sys.getenv()
[10:59:33.393]                 names <- names(envs)
[10:59:33.393]                 common <- intersect(names, old_names)
[10:59:33.393]                 added <- setdiff(names, old_names)
[10:59:33.393]                 removed <- setdiff(old_names, names)
[10:59:33.393]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.393]                   envs[common]]
[10:59:33.393]                 NAMES <- toupper(changed)
[10:59:33.393]                 args <- list()
[10:59:33.393]                 for (kk in seq_along(NAMES)) {
[10:59:33.393]                   name <- changed[[kk]]
[10:59:33.393]                   NAME <- NAMES[[kk]]
[10:59:33.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.393]                     next
[10:59:33.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.393]                 }
[10:59:33.393]                 NAMES <- toupper(added)
[10:59:33.393]                 for (kk in seq_along(NAMES)) {
[10:59:33.393]                   name <- added[[kk]]
[10:59:33.393]                   NAME <- NAMES[[kk]]
[10:59:33.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.393]                     next
[10:59:33.393]                   args[[name]] <- ""
[10:59:33.393]                 }
[10:59:33.393]                 NAMES <- toupper(removed)
[10:59:33.393]                 for (kk in seq_along(NAMES)) {
[10:59:33.393]                   name <- removed[[kk]]
[10:59:33.393]                   NAME <- NAMES[[kk]]
[10:59:33.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.393]                     next
[10:59:33.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.393]                 }
[10:59:33.393]                 if (length(args) > 0) 
[10:59:33.393]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.393]             }
[10:59:33.393]             else {
[10:59:33.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.393]             }
[10:59:33.393]             {
[10:59:33.393]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.393]                   0L) {
[10:59:33.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.393]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.393]                   base::options(opts)
[10:59:33.393]                 }
[10:59:33.393]                 {
[10:59:33.393]                   {
[10:59:33.393]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.393]                     NULL
[10:59:33.393]                   }
[10:59:33.393]                   options(future.plan = NULL)
[10:59:33.393]                   if (is.na(NA_character_)) 
[10:59:33.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.393]                     .init = FALSE)
[10:59:33.393]                 }
[10:59:33.393]             }
[10:59:33.393]         }
[10:59:33.393]     })
[10:59:33.393]     if (TRUE) {
[10:59:33.393]         base::sink(type = "output", split = FALSE)
[10:59:33.393]         if (TRUE) {
[10:59:33.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.393]         }
[10:59:33.393]         else {
[10:59:33.393]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.393]         }
[10:59:33.393]         base::close(...future.stdout)
[10:59:33.393]         ...future.stdout <- NULL
[10:59:33.393]     }
[10:59:33.393]     ...future.result$conditions <- ...future.conditions
[10:59:33.393]     ...future.result$finished <- base::Sys.time()
[10:59:33.393]     ...future.result
[10:59:33.393] }
[10:59:33.396] assign_globals() ...
[10:59:33.396] List of 5
[10:59:33.396]  $ ...future.FUN            :function (x, y)  
[10:59:33.396]  $ MoreArgs                 :List of 1
[10:59:33.396]   ..$ y: int [1:2] 3 4
[10:59:33.396]  $ ...future.elements_ii    :List of 1
[10:59:33.396]   ..$ x:List of 1
[10:59:33.396]   .. ..$ : int 1
[10:59:33.396]  $ ...future.seeds_ii       :List of 1
[10:59:33.396]   ..$ : int [1:7] 10407 472059130 283746633 1430829290 978256166 1823923871 -2073391798
[10:59:33.396]  $ ...future.globals.maxSize: NULL
[10:59:33.396]  - attr(*, "where")=List of 5
[10:59:33.396]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.396]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.396]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.396]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.396]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.396]  - attr(*, "resolved")= logi FALSE
[10:59:33.396]  - attr(*, "total_size")= num 696
[10:59:33.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.396]  - attr(*, "already-done")= logi TRUE
[10:59:33.401] - reassign environment for ‘...future.FUN’
[10:59:33.401] - copied ‘...future.FUN’ to environment
[10:59:33.402] - copied ‘MoreArgs’ to environment
[10:59:33.402] - copied ‘...future.elements_ii’ to environment
[10:59:33.402] - copied ‘...future.seeds_ii’ to environment
[10:59:33.402] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.402] assign_globals() ... done
[10:59:33.402] requestCore(): workers = 2
[10:59:33.404] MulticoreFuture started
[10:59:33.405] - Launch lazy future ... done
[10:59:33.405] run() for ‘MulticoreFuture’ ... done
[10:59:33.405] plan(): Setting new future strategy stack:
[10:59:33.405] Created future:
[10:59:33.405] List of future strategies:
[10:59:33.405] 1. sequential:
[10:59:33.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.405]    - tweaked: FALSE
[10:59:33.405]    - call: NULL
[10:59:33.406] plan(): nbrOfWorkers() = 1
[10:59:33.409] plan(): Setting new future strategy stack:
[10:59:33.409] List of future strategies:
[10:59:33.409] 1. multicore:
[10:59:33.409]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.409]    - tweaked: FALSE
[10:59:33.409]    - call: plan(strategy)
[10:59:33.412] plan(): nbrOfWorkers() = 2
[10:59:33.406] MulticoreFuture:
[10:59:33.406] Label: ‘future_mapply-1’
[10:59:33.406] Expression:
[10:59:33.406] {
[10:59:33.406]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.406]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.406]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.406]         on.exit(options(oopts), add = TRUE)
[10:59:33.406]     }
[10:59:33.406]     {
[10:59:33.406]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.406]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:33.406]                 inherits = FALSE)
[10:59:33.406]             ...future.FUN(...)
[10:59:33.406]         }
[10:59:33.406]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.406]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.406]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.406]         do.call(mapply, args = args)
[10:59:33.406]     }
[10:59:33.406] }
[10:59:33.406] Lazy evaluation: FALSE
[10:59:33.406] Asynchronous evaluation: TRUE
[10:59:33.406] Local evaluation: TRUE
[10:59:33.406] Environment: R_GlobalEnv
[10:59:33.406] Capture standard output: TRUE
[10:59:33.406] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.406] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.406] Packages: <none>
[10:59:33.406] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:33.406] Resolved: TRUE
[10:59:33.406] Value: <not collected>
[10:59:33.406] Conditions captured: <none>
[10:59:33.406] Early signaling: FALSE
[10:59:33.406] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.406] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.413] Chunk #1 of 2 ... DONE
[10:59:33.414] Chunk #2 of 2 ...
[10:59:33.414]  - Finding globals in '...' for chunk #2 ...
[10:59:33.414] getGlobalsAndPackages() ...
[10:59:33.414] Searching for globals...
[10:59:33.415] 
[10:59:33.415] Searching for globals ... DONE
[10:59:33.415] - globals: [0] <none>
[10:59:33.415] getGlobalsAndPackages() ... DONE
[10:59:33.415]    + additional globals found: [n=0] 
[10:59:33.415]    + additional namespaces needed: [n=0] 
[10:59:33.415]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.415]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.416]  - seeds: [1] <seeds>
[10:59:33.416]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.416] getGlobalsAndPackages() ...
[10:59:33.416] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.416] Resolving globals: FALSE
[10:59:33.417] The total size of the 5 globals is 696 bytes (696 bytes)
[10:59:33.418] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:33.418] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.418] 
[10:59:33.418] getGlobalsAndPackages() ... DONE
[10:59:33.419] run() for ‘Future’ ...
[10:59:33.419] - state: ‘created’
[10:59:33.419] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.422]   - Field: ‘label’
[10:59:33.422]   - Field: ‘local’
[10:59:33.422]   - Field: ‘owner’
[10:59:33.422]   - Field: ‘envir’
[10:59:33.422]   - Field: ‘workers’
[10:59:33.423]   - Field: ‘packages’
[10:59:33.423]   - Field: ‘gc’
[10:59:33.423]   - Field: ‘job’
[10:59:33.423]   - Field: ‘conditions’
[10:59:33.423]   - Field: ‘expr’
[10:59:33.423]   - Field: ‘uuid’
[10:59:33.423]   - Field: ‘seed’
[10:59:33.424]   - Field: ‘version’
[10:59:33.424]   - Field: ‘result’
[10:59:33.424]   - Field: ‘asynchronous’
[10:59:33.424]   - Field: ‘calls’
[10:59:33.424]   - Field: ‘globals’
[10:59:33.424]   - Field: ‘stdout’
[10:59:33.425]   - Field: ‘earlySignal’
[10:59:33.425]   - Field: ‘lazy’
[10:59:33.425]   - Field: ‘state’
[10:59:33.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.425] - Launch lazy future ...
[10:59:33.426] Packages needed by the future expression (n = 0): <none>
[10:59:33.426] Packages needed by future strategies (n = 0): <none>
[10:59:33.426] {
[10:59:33.426]     {
[10:59:33.426]         {
[10:59:33.426]             ...future.startTime <- base::Sys.time()
[10:59:33.426]             {
[10:59:33.426]                 {
[10:59:33.426]                   {
[10:59:33.426]                     {
[10:59:33.426]                       base::local({
[10:59:33.426]                         has_future <- base::requireNamespace("future", 
[10:59:33.426]                           quietly = TRUE)
[10:59:33.426]                         if (has_future) {
[10:59:33.426]                           ns <- base::getNamespace("future")
[10:59:33.426]                           version <- ns[[".package"]][["version"]]
[10:59:33.426]                           if (is.null(version)) 
[10:59:33.426]                             version <- utils::packageVersion("future")
[10:59:33.426]                         }
[10:59:33.426]                         else {
[10:59:33.426]                           version <- NULL
[10:59:33.426]                         }
[10:59:33.426]                         if (!has_future || version < "1.8.0") {
[10:59:33.426]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.426]                             "", base::R.version$version.string), 
[10:59:33.426]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.426]                               "release", "version")], collapse = " "), 
[10:59:33.426]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.426]                             info)
[10:59:33.426]                           info <- base::paste(info, collapse = "; ")
[10:59:33.426]                           if (!has_future) {
[10:59:33.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.426]                               info)
[10:59:33.426]                           }
[10:59:33.426]                           else {
[10:59:33.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.426]                               info, version)
[10:59:33.426]                           }
[10:59:33.426]                           base::stop(msg)
[10:59:33.426]                         }
[10:59:33.426]                       })
[10:59:33.426]                     }
[10:59:33.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.426]                     base::options(mc.cores = 1L)
[10:59:33.426]                   }
[10:59:33.426]                   ...future.strategy.old <- future::plan("list")
[10:59:33.426]                   options(future.plan = NULL)
[10:59:33.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.426]                 }
[10:59:33.426]                 ...future.workdir <- getwd()
[10:59:33.426]             }
[10:59:33.426]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.426]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.426]         }
[10:59:33.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.426]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.426]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.426]             base::names(...future.oldOptions))
[10:59:33.426]     }
[10:59:33.426]     if (FALSE) {
[10:59:33.426]     }
[10:59:33.426]     else {
[10:59:33.426]         if (TRUE) {
[10:59:33.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.426]                 open = "w")
[10:59:33.426]         }
[10:59:33.426]         else {
[10:59:33.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.426]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.426]         }
[10:59:33.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.426]             base::sink(type = "output", split = FALSE)
[10:59:33.426]             base::close(...future.stdout)
[10:59:33.426]         }, add = TRUE)
[10:59:33.426]     }
[10:59:33.426]     ...future.frame <- base::sys.nframe()
[10:59:33.426]     ...future.conditions <- base::list()
[10:59:33.426]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.426]     if (FALSE) {
[10:59:33.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.426]     }
[10:59:33.426]     ...future.result <- base::tryCatch({
[10:59:33.426]         base::withCallingHandlers({
[10:59:33.426]             ...future.value <- base::withVisible(base::local({
[10:59:33.426]                 withCallingHandlers({
[10:59:33.426]                   {
[10:59:33.426]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.426]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.426]                       ...future.globals.maxSize)) {
[10:59:33.426]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.426]                       on.exit(options(oopts), add = TRUE)
[10:59:33.426]                     }
[10:59:33.426]                     {
[10:59:33.426]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.426]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:33.426]                           envir = globalenv(), inherits = FALSE)
[10:59:33.426]                         ...future.FUN(...)
[10:59:33.426]                       }
[10:59:33.426]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.426]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.426]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.426]                         USE.NAMES = FALSE)
[10:59:33.426]                       do.call(mapply, args = args)
[10:59:33.426]                     }
[10:59:33.426]                   }
[10:59:33.426]                 }, immediateCondition = function(cond) {
[10:59:33.426]                   save_rds <- function (object, pathname, ...) 
[10:59:33.426]                   {
[10:59:33.426]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.426]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.426]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.426]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.426]                         fi_tmp[["mtime"]])
[10:59:33.426]                     }
[10:59:33.426]                     tryCatch({
[10:59:33.426]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.426]                     }, error = function(ex) {
[10:59:33.426]                       msg <- conditionMessage(ex)
[10:59:33.426]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.426]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.426]                         fi_tmp[["mtime"]], msg)
[10:59:33.426]                       ex$message <- msg
[10:59:33.426]                       stop(ex)
[10:59:33.426]                     })
[10:59:33.426]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.426]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.426]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.426]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.426]                       fi <- file.info(pathname)
[10:59:33.426]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.426]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.426]                         fi[["size"]], fi[["mtime"]])
[10:59:33.426]                       stop(msg)
[10:59:33.426]                     }
[10:59:33.426]                     invisible(pathname)
[10:59:33.426]                   }
[10:59:33.426]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.426]                     rootPath = tempdir()) 
[10:59:33.426]                   {
[10:59:33.426]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.426]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.426]                       tmpdir = path, fileext = ".rds")
[10:59:33.426]                     save_rds(obj, file)
[10:59:33.426]                   }
[10:59:33.426]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.426]                   {
[10:59:33.426]                     inherits <- base::inherits
[10:59:33.426]                     invokeRestart <- base::invokeRestart
[10:59:33.426]                     is.null <- base::is.null
[10:59:33.426]                     muffled <- FALSE
[10:59:33.426]                     if (inherits(cond, "message")) {
[10:59:33.426]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.426]                       if (muffled) 
[10:59:33.426]                         invokeRestart("muffleMessage")
[10:59:33.426]                     }
[10:59:33.426]                     else if (inherits(cond, "warning")) {
[10:59:33.426]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.426]                       if (muffled) 
[10:59:33.426]                         invokeRestart("muffleWarning")
[10:59:33.426]                     }
[10:59:33.426]                     else if (inherits(cond, "condition")) {
[10:59:33.426]                       if (!is.null(pattern)) {
[10:59:33.426]                         computeRestarts <- base::computeRestarts
[10:59:33.426]                         grepl <- base::grepl
[10:59:33.426]                         restarts <- computeRestarts(cond)
[10:59:33.426]                         for (restart in restarts) {
[10:59:33.426]                           name <- restart$name
[10:59:33.426]                           if (is.null(name)) 
[10:59:33.426]                             next
[10:59:33.426]                           if (!grepl(pattern, name)) 
[10:59:33.426]                             next
[10:59:33.426]                           invokeRestart(restart)
[10:59:33.426]                           muffled <- TRUE
[10:59:33.426]                           break
[10:59:33.426]                         }
[10:59:33.426]                       }
[10:59:33.426]                     }
[10:59:33.426]                     invisible(muffled)
[10:59:33.426]                   }
[10:59:33.426]                   muffleCondition(cond)
[10:59:33.426]                 })
[10:59:33.426]             }))
[10:59:33.426]             future::FutureResult(value = ...future.value$value, 
[10:59:33.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.426]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.426]                     ...future.globalenv.names))
[10:59:33.426]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.426]         }, condition = base::local({
[10:59:33.426]             c <- base::c
[10:59:33.426]             inherits <- base::inherits
[10:59:33.426]             invokeRestart <- base::invokeRestart
[10:59:33.426]             length <- base::length
[10:59:33.426]             list <- base::list
[10:59:33.426]             seq.int <- base::seq.int
[10:59:33.426]             signalCondition <- base::signalCondition
[10:59:33.426]             sys.calls <- base::sys.calls
[10:59:33.426]             `[[` <- base::`[[`
[10:59:33.426]             `+` <- base::`+`
[10:59:33.426]             `<<-` <- base::`<<-`
[10:59:33.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.426]                   3L)]
[10:59:33.426]             }
[10:59:33.426]             function(cond) {
[10:59:33.426]                 is_error <- inherits(cond, "error")
[10:59:33.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.426]                   NULL)
[10:59:33.426]                 if (is_error) {
[10:59:33.426]                   sessionInformation <- function() {
[10:59:33.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.426]                       search = base::search(), system = base::Sys.info())
[10:59:33.426]                   }
[10:59:33.426]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.426]                     cond$call), session = sessionInformation(), 
[10:59:33.426]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.426]                   signalCondition(cond)
[10:59:33.426]                 }
[10:59:33.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.426]                 "immediateCondition"))) {
[10:59:33.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.426]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.426]                   if (TRUE && !signal) {
[10:59:33.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.426]                     {
[10:59:33.426]                       inherits <- base::inherits
[10:59:33.426]                       invokeRestart <- base::invokeRestart
[10:59:33.426]                       is.null <- base::is.null
[10:59:33.426]                       muffled <- FALSE
[10:59:33.426]                       if (inherits(cond, "message")) {
[10:59:33.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.426]                         if (muffled) 
[10:59:33.426]                           invokeRestart("muffleMessage")
[10:59:33.426]                       }
[10:59:33.426]                       else if (inherits(cond, "warning")) {
[10:59:33.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.426]                         if (muffled) 
[10:59:33.426]                           invokeRestart("muffleWarning")
[10:59:33.426]                       }
[10:59:33.426]                       else if (inherits(cond, "condition")) {
[10:59:33.426]                         if (!is.null(pattern)) {
[10:59:33.426]                           computeRestarts <- base::computeRestarts
[10:59:33.426]                           grepl <- base::grepl
[10:59:33.426]                           restarts <- computeRestarts(cond)
[10:59:33.426]                           for (restart in restarts) {
[10:59:33.426]                             name <- restart$name
[10:59:33.426]                             if (is.null(name)) 
[10:59:33.426]                               next
[10:59:33.426]                             if (!grepl(pattern, name)) 
[10:59:33.426]                               next
[10:59:33.426]                             invokeRestart(restart)
[10:59:33.426]                             muffled <- TRUE
[10:59:33.426]                             break
[10:59:33.426]                           }
[10:59:33.426]                         }
[10:59:33.426]                       }
[10:59:33.426]                       invisible(muffled)
[10:59:33.426]                     }
[10:59:33.426]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.426]                   }
[10:59:33.426]                 }
[10:59:33.426]                 else {
[10:59:33.426]                   if (TRUE) {
[10:59:33.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.426]                     {
[10:59:33.426]                       inherits <- base::inherits
[10:59:33.426]                       invokeRestart <- base::invokeRestart
[10:59:33.426]                       is.null <- base::is.null
[10:59:33.426]                       muffled <- FALSE
[10:59:33.426]                       if (inherits(cond, "message")) {
[10:59:33.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.426]                         if (muffled) 
[10:59:33.426]                           invokeRestart("muffleMessage")
[10:59:33.426]                       }
[10:59:33.426]                       else if (inherits(cond, "warning")) {
[10:59:33.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.426]                         if (muffled) 
[10:59:33.426]                           invokeRestart("muffleWarning")
[10:59:33.426]                       }
[10:59:33.426]                       else if (inherits(cond, "condition")) {
[10:59:33.426]                         if (!is.null(pattern)) {
[10:59:33.426]                           computeRestarts <- base::computeRestarts
[10:59:33.426]                           grepl <- base::grepl
[10:59:33.426]                           restarts <- computeRestarts(cond)
[10:59:33.426]                           for (restart in restarts) {
[10:59:33.426]                             name <- restart$name
[10:59:33.426]                             if (is.null(name)) 
[10:59:33.426]                               next
[10:59:33.426]                             if (!grepl(pattern, name)) 
[10:59:33.426]                               next
[10:59:33.426]                             invokeRestart(restart)
[10:59:33.426]                             muffled <- TRUE
[10:59:33.426]                             break
[10:59:33.426]                           }
[10:59:33.426]                         }
[10:59:33.426]                       }
[10:59:33.426]                       invisible(muffled)
[10:59:33.426]                     }
[10:59:33.426]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.426]                   }
[10:59:33.426]                 }
[10:59:33.426]             }
[10:59:33.426]         }))
[10:59:33.426]     }, error = function(ex) {
[10:59:33.426]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.426]                 ...future.rng), started = ...future.startTime, 
[10:59:33.426]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.426]             version = "1.8"), class = "FutureResult")
[10:59:33.426]     }, finally = {
[10:59:33.426]         if (!identical(...future.workdir, getwd())) 
[10:59:33.426]             setwd(...future.workdir)
[10:59:33.426]         {
[10:59:33.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.426]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.426]             }
[10:59:33.426]             base::options(...future.oldOptions)
[10:59:33.426]             if (.Platform$OS.type == "windows") {
[10:59:33.426]                 old_names <- names(...future.oldEnvVars)
[10:59:33.426]                 envs <- base::Sys.getenv()
[10:59:33.426]                 names <- names(envs)
[10:59:33.426]                 common <- intersect(names, old_names)
[10:59:33.426]                 added <- setdiff(names, old_names)
[10:59:33.426]                 removed <- setdiff(old_names, names)
[10:59:33.426]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.426]                   envs[common]]
[10:59:33.426]                 NAMES <- toupper(changed)
[10:59:33.426]                 args <- list()
[10:59:33.426]                 for (kk in seq_along(NAMES)) {
[10:59:33.426]                   name <- changed[[kk]]
[10:59:33.426]                   NAME <- NAMES[[kk]]
[10:59:33.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.426]                     next
[10:59:33.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.426]                 }
[10:59:33.426]                 NAMES <- toupper(added)
[10:59:33.426]                 for (kk in seq_along(NAMES)) {
[10:59:33.426]                   name <- added[[kk]]
[10:59:33.426]                   NAME <- NAMES[[kk]]
[10:59:33.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.426]                     next
[10:59:33.426]                   args[[name]] <- ""
[10:59:33.426]                 }
[10:59:33.426]                 NAMES <- toupper(removed)
[10:59:33.426]                 for (kk in seq_along(NAMES)) {
[10:59:33.426]                   name <- removed[[kk]]
[10:59:33.426]                   NAME <- NAMES[[kk]]
[10:59:33.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.426]                     next
[10:59:33.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.426]                 }
[10:59:33.426]                 if (length(args) > 0) 
[10:59:33.426]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.426]             }
[10:59:33.426]             else {
[10:59:33.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.426]             }
[10:59:33.426]             {
[10:59:33.426]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.426]                   0L) {
[10:59:33.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.426]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.426]                   base::options(opts)
[10:59:33.426]                 }
[10:59:33.426]                 {
[10:59:33.426]                   {
[10:59:33.426]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.426]                     NULL
[10:59:33.426]                   }
[10:59:33.426]                   options(future.plan = NULL)
[10:59:33.426]                   if (is.na(NA_character_)) 
[10:59:33.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.426]                     .init = FALSE)
[10:59:33.426]                 }
[10:59:33.426]             }
[10:59:33.426]         }
[10:59:33.426]     })
[10:59:33.426]     if (TRUE) {
[10:59:33.426]         base::sink(type = "output", split = FALSE)
[10:59:33.426]         if (TRUE) {
[10:59:33.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.426]         }
[10:59:33.426]         else {
[10:59:33.426]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.426]         }
[10:59:33.426]         base::close(...future.stdout)
[10:59:33.426]         ...future.stdout <- NULL
[10:59:33.426]     }
[10:59:33.426]     ...future.result$conditions <- ...future.conditions
[10:59:33.426]     ...future.result$finished <- base::Sys.time()
[10:59:33.426]     ...future.result
[10:59:33.426] }
[10:59:33.430] assign_globals() ...
[10:59:33.430] List of 5
[10:59:33.430]  $ ...future.FUN            :function (x, y)  
[10:59:33.430]  $ MoreArgs                 :List of 1
[10:59:33.430]   ..$ y: int [1:2] 3 4
[10:59:33.430]  $ ...future.elements_ii    :List of 1
[10:59:33.430]   ..$ x:List of 1
[10:59:33.430]   .. ..$ : int 2
[10:59:33.430]  $ ...future.seeds_ii       :List of 1
[10:59:33.430]   ..$ : int [1:7] 10407 -1956586032 1485078657 1286884639 -577262962 1926908412 -1259531304
[10:59:33.430]  $ ...future.globals.maxSize: NULL
[10:59:33.430]  - attr(*, "where")=List of 5
[10:59:33.430]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.430]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.430]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.430]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.430]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.430]  - attr(*, "resolved")= logi FALSE
[10:59:33.430]  - attr(*, "total_size")= num 696
[10:59:33.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.430]  - attr(*, "already-done")= logi TRUE
[10:59:33.443] - reassign environment for ‘...future.FUN’
[10:59:33.443] - copied ‘...future.FUN’ to environment
[10:59:33.443] - copied ‘MoreArgs’ to environment
[10:59:33.443] - copied ‘...future.elements_ii’ to environment
[10:59:33.443] - copied ‘...future.seeds_ii’ to environment
[10:59:33.443] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.444] assign_globals() ... done
[10:59:33.444] requestCore(): workers = 2
[10:59:33.446] MulticoreFuture started
[10:59:33.447] - Launch lazy future ... done
[10:59:33.447] plan(): Setting new future strategy stack:
[10:59:33.447] run() for ‘MulticoreFuture’ ... done
[10:59:33.448] Created future:
[10:59:33.448] List of future strategies:
[10:59:33.448] 1. sequential:
[10:59:33.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.448]    - tweaked: FALSE
[10:59:33.448]    - call: NULL
[10:59:33.449] plan(): nbrOfWorkers() = 1
[10:59:33.451] plan(): Setting new future strategy stack:
[10:59:33.452] List of future strategies:
[10:59:33.452] 1. multicore:
[10:59:33.452]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.452]    - tweaked: FALSE
[10:59:33.452]    - call: plan(strategy)
[10:59:33.455] plan(): nbrOfWorkers() = 2
[10:59:33.448] MulticoreFuture:
[10:59:33.448] Label: ‘future_mapply-2’
[10:59:33.448] Expression:
[10:59:33.448] {
[10:59:33.448]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.448]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.448]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.448]         on.exit(options(oopts), add = TRUE)
[10:59:33.448]     }
[10:59:33.448]     {
[10:59:33.448]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.448]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:33.448]                 inherits = FALSE)
[10:59:33.448]             ...future.FUN(...)
[10:59:33.448]         }
[10:59:33.448]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.448]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.448]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.448]         do.call(mapply, args = args)
[10:59:33.448]     }
[10:59:33.448] }
[10:59:33.448] Lazy evaluation: FALSE
[10:59:33.448] Asynchronous evaluation: TRUE
[10:59:33.448] Local evaluation: TRUE
[10:59:33.448] Environment: R_GlobalEnv
[10:59:33.448] Capture standard output: TRUE
[10:59:33.448] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.448] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.448] Packages: <none>
[10:59:33.448] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:33.448] Resolved: TRUE
[10:59:33.448] Value: <not collected>
[10:59:33.448] Conditions captured: <none>
[10:59:33.448] Early signaling: FALSE
[10:59:33.448] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.448] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.457] Chunk #2 of 2 ... DONE
[10:59:33.457] Launching 2 futures (chunks) ... DONE
[10:59:33.457] Resolving 2 futures (chunks) ...
[10:59:33.457] resolve() on list ...
[10:59:33.457]  recursive: 0
[10:59:33.458]  length: 2
[10:59:33.458] 
[10:59:33.458] Future #1
[10:59:33.458] result() for MulticoreFuture ...
[10:59:33.459] result() for MulticoreFuture ...
[10:59:33.459] result() for MulticoreFuture ... done
[10:59:33.460] result() for MulticoreFuture ... done
[10:59:33.460] result() for MulticoreFuture ...
[10:59:33.460] result() for MulticoreFuture ... done
[10:59:33.460] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.460] - nx: 2
[10:59:33.460] - relay: TRUE
[10:59:33.461] - stdout: TRUE
[10:59:33.461] - signal: TRUE
[10:59:33.461] - resignal: FALSE
[10:59:33.461] - force: TRUE
[10:59:33.461] - relayed: [n=2] FALSE, FALSE
[10:59:33.461] - queued futures: [n=2] FALSE, FALSE
[10:59:33.461]  - until=1
[10:59:33.462]  - relaying element #1
[10:59:33.462] result() for MulticoreFuture ...
[10:59:33.462] result() for MulticoreFuture ... done
[10:59:33.462] result() for MulticoreFuture ...
[10:59:33.462] result() for MulticoreFuture ... done
[10:59:33.462] result() for MulticoreFuture ...
[10:59:33.462] result() for MulticoreFuture ... done
[10:59:33.463] result() for MulticoreFuture ...
[10:59:33.463] result() for MulticoreFuture ... done
[10:59:33.463] - relayed: [n=2] TRUE, FALSE
[10:59:33.463] - queued futures: [n=2] TRUE, FALSE
[10:59:33.463] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.463]  length: 1 (resolved future 1)
[10:59:33.464] Future #2
[10:59:33.464] result() for MulticoreFuture ...
[10:59:33.464] result() for MulticoreFuture ...
[10:59:33.465] result() for MulticoreFuture ... done
[10:59:33.465] result() for MulticoreFuture ... done
[10:59:33.465] result() for MulticoreFuture ...
[10:59:33.465] result() for MulticoreFuture ... done
[10:59:33.465] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.465] - nx: 2
[10:59:33.465] - relay: TRUE
[10:59:33.465] - stdout: TRUE
[10:59:33.466] - signal: TRUE
[10:59:33.466] - resignal: FALSE
[10:59:33.466] - force: TRUE
[10:59:33.466] - relayed: [n=2] TRUE, FALSE
[10:59:33.466] - queued futures: [n=2] TRUE, FALSE
[10:59:33.466]  - until=2
[10:59:33.466]  - relaying element #2
[10:59:33.466] result() for MulticoreFuture ...
[10:59:33.467] result() for MulticoreFuture ... done
[10:59:33.467] result() for MulticoreFuture ...
[10:59:33.467] result() for MulticoreFuture ... done
[10:59:33.467] result() for MulticoreFuture ...
[10:59:33.467] result() for MulticoreFuture ... done
[10:59:33.467] result() for MulticoreFuture ...
[10:59:33.467] result() for MulticoreFuture ... done
[10:59:33.467] - relayed: [n=2] TRUE, TRUE
[10:59:33.467] - queued futures: [n=2] TRUE, TRUE
[10:59:33.468] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.468]  length: 0 (resolved future 2)
[10:59:33.468] Relaying remaining futures
[10:59:33.468] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.468] - nx: 2
[10:59:33.468] - relay: TRUE
[10:59:33.468] - stdout: TRUE
[10:59:33.468] - signal: TRUE
[10:59:33.468] - resignal: FALSE
[10:59:33.468] - force: TRUE
[10:59:33.469] - relayed: [n=2] TRUE, TRUE
[10:59:33.469] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.469] - relayed: [n=2] TRUE, TRUE
[10:59:33.469] - queued futures: [n=2] TRUE, TRUE
[10:59:33.469] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.469] resolve() on list ... DONE
[10:59:33.469] result() for MulticoreFuture ...
[10:59:33.469] result() for MulticoreFuture ... done
[10:59:33.469] result() for MulticoreFuture ...
[10:59:33.470] result() for MulticoreFuture ... done
[10:59:33.470] result() for MulticoreFuture ...
[10:59:33.470] result() for MulticoreFuture ... done
[10:59:33.470] result() for MulticoreFuture ...
[10:59:33.470] result() for MulticoreFuture ... done
[10:59:33.470]  - Number of value chunks collected: 2
[10:59:33.470] Resolving 2 futures (chunks) ... DONE
[10:59:33.470] Reducing values from 2 chunks ...
[10:59:33.470]  - Number of values collected after concatenation: 2
[10:59:33.471]  - Number of values expected: 2
[10:59:33.471] Reducing values from 2 chunks ... DONE
[10:59:33.471] future_mapply() ... DONE
[10:59:33.471] future_mapply() ...
[10:59:33.475] Number of chunks: 2
[10:59:33.475] getGlobalsAndPackagesXApply() ...
[10:59:33.476]  - future.globals: TRUE
[10:59:33.476] getGlobalsAndPackages() ...
[10:59:33.476] Searching for globals...
[10:59:33.477] - globals found: [1] ‘FUN’
[10:59:33.477] Searching for globals ... DONE
[10:59:33.478] Resolving globals: FALSE
[10:59:33.478] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:33.478] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:33.479] - globals: [1] ‘FUN’
[10:59:33.479] 
[10:59:33.479] getGlobalsAndPackages() ... DONE
[10:59:33.479]  - globals found/used: [n=1] ‘FUN’
[10:59:33.479]  - needed namespaces: [n=0] 
[10:59:33.479] Finding globals ... DONE
[10:59:33.479] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.479] List of 2
[10:59:33.479]  $ ...future.FUN:function (x, y)  
[10:59:33.479]  $ MoreArgs     :List of 1
[10:59:33.479]   ..$ y: int [1:2] 3 4
[10:59:33.479]  - attr(*, "where")=List of 2
[10:59:33.479]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.479]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.479]  - attr(*, "resolved")= logi FALSE
[10:59:33.479]  - attr(*, "total_size")= num NA
[10:59:33.483] Packages to be attached in all futures: [n=0] 
[10:59:33.483] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.483] Number of futures (= number of chunks): 2
[10:59:33.483] Launching 2 futures (chunks) ...
[10:59:33.484] Chunk #1 of 2 ...
[10:59:33.484]  - Finding globals in '...' for chunk #1 ...
[10:59:33.484] getGlobalsAndPackages() ...
[10:59:33.484] Searching for globals...
[10:59:33.484] 
[10:59:33.484] Searching for globals ... DONE
[10:59:33.484] - globals: [0] <none>
[10:59:33.484] getGlobalsAndPackages() ... DONE
[10:59:33.484]    + additional globals found: [n=0] 
[10:59:33.485]    + additional namespaces needed: [n=0] 
[10:59:33.485]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.485]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.485]  - seeds: <none>
[10:59:33.485]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.485] getGlobalsAndPackages() ...
[10:59:33.485] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.485] Resolving globals: FALSE
[10:59:33.486] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:33.486] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:33.486] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.486] 
[10:59:33.486] getGlobalsAndPackages() ... DONE
[10:59:33.487] run() for ‘Future’ ...
[10:59:33.487] - state: ‘created’
[10:59:33.487] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.489] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.489]   - Field: ‘label’
[10:59:33.489]   - Field: ‘local’
[10:59:33.489]   - Field: ‘owner’
[10:59:33.489]   - Field: ‘envir’
[10:59:33.489]   - Field: ‘workers’
[10:59:33.489]   - Field: ‘packages’
[10:59:33.489]   - Field: ‘gc’
[10:59:33.489]   - Field: ‘job’
[10:59:33.489]   - Field: ‘conditions’
[10:59:33.490]   - Field: ‘expr’
[10:59:33.490]   - Field: ‘uuid’
[10:59:33.490]   - Field: ‘seed’
[10:59:33.490]   - Field: ‘version’
[10:59:33.490]   - Field: ‘result’
[10:59:33.490]   - Field: ‘asynchronous’
[10:59:33.490]   - Field: ‘calls’
[10:59:33.490]   - Field: ‘globals’
[10:59:33.490]   - Field: ‘stdout’
[10:59:33.490]   - Field: ‘earlySignal’
[10:59:33.490]   - Field: ‘lazy’
[10:59:33.490]   - Field: ‘state’
[10:59:33.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.491] - Launch lazy future ...
[10:59:33.491] Packages needed by the future expression (n = 0): <none>
[10:59:33.491] Packages needed by future strategies (n = 0): <none>
[10:59:33.491] {
[10:59:33.491]     {
[10:59:33.491]         {
[10:59:33.491]             ...future.startTime <- base::Sys.time()
[10:59:33.491]             {
[10:59:33.491]                 {
[10:59:33.491]                   {
[10:59:33.491]                     {
[10:59:33.491]                       base::local({
[10:59:33.491]                         has_future <- base::requireNamespace("future", 
[10:59:33.491]                           quietly = TRUE)
[10:59:33.491]                         if (has_future) {
[10:59:33.491]                           ns <- base::getNamespace("future")
[10:59:33.491]                           version <- ns[[".package"]][["version"]]
[10:59:33.491]                           if (is.null(version)) 
[10:59:33.491]                             version <- utils::packageVersion("future")
[10:59:33.491]                         }
[10:59:33.491]                         else {
[10:59:33.491]                           version <- NULL
[10:59:33.491]                         }
[10:59:33.491]                         if (!has_future || version < "1.8.0") {
[10:59:33.491]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.491]                             "", base::R.version$version.string), 
[10:59:33.491]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.491]                               "release", "version")], collapse = " "), 
[10:59:33.491]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.491]                             info)
[10:59:33.491]                           info <- base::paste(info, collapse = "; ")
[10:59:33.491]                           if (!has_future) {
[10:59:33.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.491]                               info)
[10:59:33.491]                           }
[10:59:33.491]                           else {
[10:59:33.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.491]                               info, version)
[10:59:33.491]                           }
[10:59:33.491]                           base::stop(msg)
[10:59:33.491]                         }
[10:59:33.491]                       })
[10:59:33.491]                     }
[10:59:33.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.491]                     base::options(mc.cores = 1L)
[10:59:33.491]                   }
[10:59:33.491]                   ...future.strategy.old <- future::plan("list")
[10:59:33.491]                   options(future.plan = NULL)
[10:59:33.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.491]                 }
[10:59:33.491]                 ...future.workdir <- getwd()
[10:59:33.491]             }
[10:59:33.491]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.491]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.491]         }
[10:59:33.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.491]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.491]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.491]             base::names(...future.oldOptions))
[10:59:33.491]     }
[10:59:33.491]     if (FALSE) {
[10:59:33.491]     }
[10:59:33.491]     else {
[10:59:33.491]         if (TRUE) {
[10:59:33.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.491]                 open = "w")
[10:59:33.491]         }
[10:59:33.491]         else {
[10:59:33.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.491]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.491]         }
[10:59:33.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.491]             base::sink(type = "output", split = FALSE)
[10:59:33.491]             base::close(...future.stdout)
[10:59:33.491]         }, add = TRUE)
[10:59:33.491]     }
[10:59:33.491]     ...future.frame <- base::sys.nframe()
[10:59:33.491]     ...future.conditions <- base::list()
[10:59:33.491]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.491]     if (FALSE) {
[10:59:33.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.491]     }
[10:59:33.491]     ...future.result <- base::tryCatch({
[10:59:33.491]         base::withCallingHandlers({
[10:59:33.491]             ...future.value <- base::withVisible(base::local({
[10:59:33.491]                 withCallingHandlers({
[10:59:33.491]                   {
[10:59:33.491]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.491]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.491]                       ...future.globals.maxSize)) {
[10:59:33.491]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.491]                       on.exit(options(oopts), add = TRUE)
[10:59:33.491]                     }
[10:59:33.491]                     {
[10:59:33.491]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.491]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.491]                         USE.NAMES = FALSE)
[10:59:33.491]                       do.call(mapply, args = args)
[10:59:33.491]                     }
[10:59:33.491]                   }
[10:59:33.491]                 }, immediateCondition = function(cond) {
[10:59:33.491]                   save_rds <- function (object, pathname, ...) 
[10:59:33.491]                   {
[10:59:33.491]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.491]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.491]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.491]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.491]                         fi_tmp[["mtime"]])
[10:59:33.491]                     }
[10:59:33.491]                     tryCatch({
[10:59:33.491]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.491]                     }, error = function(ex) {
[10:59:33.491]                       msg <- conditionMessage(ex)
[10:59:33.491]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.491]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.491]                         fi_tmp[["mtime"]], msg)
[10:59:33.491]                       ex$message <- msg
[10:59:33.491]                       stop(ex)
[10:59:33.491]                     })
[10:59:33.491]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.491]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.491]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.491]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.491]                       fi <- file.info(pathname)
[10:59:33.491]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.491]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.491]                         fi[["size"]], fi[["mtime"]])
[10:59:33.491]                       stop(msg)
[10:59:33.491]                     }
[10:59:33.491]                     invisible(pathname)
[10:59:33.491]                   }
[10:59:33.491]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.491]                     rootPath = tempdir()) 
[10:59:33.491]                   {
[10:59:33.491]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.491]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.491]                       tmpdir = path, fileext = ".rds")
[10:59:33.491]                     save_rds(obj, file)
[10:59:33.491]                   }
[10:59:33.491]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.491]                   {
[10:59:33.491]                     inherits <- base::inherits
[10:59:33.491]                     invokeRestart <- base::invokeRestart
[10:59:33.491]                     is.null <- base::is.null
[10:59:33.491]                     muffled <- FALSE
[10:59:33.491]                     if (inherits(cond, "message")) {
[10:59:33.491]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.491]                       if (muffled) 
[10:59:33.491]                         invokeRestart("muffleMessage")
[10:59:33.491]                     }
[10:59:33.491]                     else if (inherits(cond, "warning")) {
[10:59:33.491]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.491]                       if (muffled) 
[10:59:33.491]                         invokeRestart("muffleWarning")
[10:59:33.491]                     }
[10:59:33.491]                     else if (inherits(cond, "condition")) {
[10:59:33.491]                       if (!is.null(pattern)) {
[10:59:33.491]                         computeRestarts <- base::computeRestarts
[10:59:33.491]                         grepl <- base::grepl
[10:59:33.491]                         restarts <- computeRestarts(cond)
[10:59:33.491]                         for (restart in restarts) {
[10:59:33.491]                           name <- restart$name
[10:59:33.491]                           if (is.null(name)) 
[10:59:33.491]                             next
[10:59:33.491]                           if (!grepl(pattern, name)) 
[10:59:33.491]                             next
[10:59:33.491]                           invokeRestart(restart)
[10:59:33.491]                           muffled <- TRUE
[10:59:33.491]                           break
[10:59:33.491]                         }
[10:59:33.491]                       }
[10:59:33.491]                     }
[10:59:33.491]                     invisible(muffled)
[10:59:33.491]                   }
[10:59:33.491]                   muffleCondition(cond)
[10:59:33.491]                 })
[10:59:33.491]             }))
[10:59:33.491]             future::FutureResult(value = ...future.value$value, 
[10:59:33.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.491]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.491]                     ...future.globalenv.names))
[10:59:33.491]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.491]         }, condition = base::local({
[10:59:33.491]             c <- base::c
[10:59:33.491]             inherits <- base::inherits
[10:59:33.491]             invokeRestart <- base::invokeRestart
[10:59:33.491]             length <- base::length
[10:59:33.491]             list <- base::list
[10:59:33.491]             seq.int <- base::seq.int
[10:59:33.491]             signalCondition <- base::signalCondition
[10:59:33.491]             sys.calls <- base::sys.calls
[10:59:33.491]             `[[` <- base::`[[`
[10:59:33.491]             `+` <- base::`+`
[10:59:33.491]             `<<-` <- base::`<<-`
[10:59:33.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.491]                   3L)]
[10:59:33.491]             }
[10:59:33.491]             function(cond) {
[10:59:33.491]                 is_error <- inherits(cond, "error")
[10:59:33.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.491]                   NULL)
[10:59:33.491]                 if (is_error) {
[10:59:33.491]                   sessionInformation <- function() {
[10:59:33.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.491]                       search = base::search(), system = base::Sys.info())
[10:59:33.491]                   }
[10:59:33.491]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.491]                     cond$call), session = sessionInformation(), 
[10:59:33.491]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.491]                   signalCondition(cond)
[10:59:33.491]                 }
[10:59:33.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.491]                 "immediateCondition"))) {
[10:59:33.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.491]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.491]                   if (TRUE && !signal) {
[10:59:33.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.491]                     {
[10:59:33.491]                       inherits <- base::inherits
[10:59:33.491]                       invokeRestart <- base::invokeRestart
[10:59:33.491]                       is.null <- base::is.null
[10:59:33.491]                       muffled <- FALSE
[10:59:33.491]                       if (inherits(cond, "message")) {
[10:59:33.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.491]                         if (muffled) 
[10:59:33.491]                           invokeRestart("muffleMessage")
[10:59:33.491]                       }
[10:59:33.491]                       else if (inherits(cond, "warning")) {
[10:59:33.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.491]                         if (muffled) 
[10:59:33.491]                           invokeRestart("muffleWarning")
[10:59:33.491]                       }
[10:59:33.491]                       else if (inherits(cond, "condition")) {
[10:59:33.491]                         if (!is.null(pattern)) {
[10:59:33.491]                           computeRestarts <- base::computeRestarts
[10:59:33.491]                           grepl <- base::grepl
[10:59:33.491]                           restarts <- computeRestarts(cond)
[10:59:33.491]                           for (restart in restarts) {
[10:59:33.491]                             name <- restart$name
[10:59:33.491]                             if (is.null(name)) 
[10:59:33.491]                               next
[10:59:33.491]                             if (!grepl(pattern, name)) 
[10:59:33.491]                               next
[10:59:33.491]                             invokeRestart(restart)
[10:59:33.491]                             muffled <- TRUE
[10:59:33.491]                             break
[10:59:33.491]                           }
[10:59:33.491]                         }
[10:59:33.491]                       }
[10:59:33.491]                       invisible(muffled)
[10:59:33.491]                     }
[10:59:33.491]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.491]                   }
[10:59:33.491]                 }
[10:59:33.491]                 else {
[10:59:33.491]                   if (TRUE) {
[10:59:33.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.491]                     {
[10:59:33.491]                       inherits <- base::inherits
[10:59:33.491]                       invokeRestart <- base::invokeRestart
[10:59:33.491]                       is.null <- base::is.null
[10:59:33.491]                       muffled <- FALSE
[10:59:33.491]                       if (inherits(cond, "message")) {
[10:59:33.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.491]                         if (muffled) 
[10:59:33.491]                           invokeRestart("muffleMessage")
[10:59:33.491]                       }
[10:59:33.491]                       else if (inherits(cond, "warning")) {
[10:59:33.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.491]                         if (muffled) 
[10:59:33.491]                           invokeRestart("muffleWarning")
[10:59:33.491]                       }
[10:59:33.491]                       else if (inherits(cond, "condition")) {
[10:59:33.491]                         if (!is.null(pattern)) {
[10:59:33.491]                           computeRestarts <- base::computeRestarts
[10:59:33.491]                           grepl <- base::grepl
[10:59:33.491]                           restarts <- computeRestarts(cond)
[10:59:33.491]                           for (restart in restarts) {
[10:59:33.491]                             name <- restart$name
[10:59:33.491]                             if (is.null(name)) 
[10:59:33.491]                               next
[10:59:33.491]                             if (!grepl(pattern, name)) 
[10:59:33.491]                               next
[10:59:33.491]                             invokeRestart(restart)
[10:59:33.491]                             muffled <- TRUE
[10:59:33.491]                             break
[10:59:33.491]                           }
[10:59:33.491]                         }
[10:59:33.491]                       }
[10:59:33.491]                       invisible(muffled)
[10:59:33.491]                     }
[10:59:33.491]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.491]                   }
[10:59:33.491]                 }
[10:59:33.491]             }
[10:59:33.491]         }))
[10:59:33.491]     }, error = function(ex) {
[10:59:33.491]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.491]                 ...future.rng), started = ...future.startTime, 
[10:59:33.491]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.491]             version = "1.8"), class = "FutureResult")
[10:59:33.491]     }, finally = {
[10:59:33.491]         if (!identical(...future.workdir, getwd())) 
[10:59:33.491]             setwd(...future.workdir)
[10:59:33.491]         {
[10:59:33.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.491]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.491]             }
[10:59:33.491]             base::options(...future.oldOptions)
[10:59:33.491]             if (.Platform$OS.type == "windows") {
[10:59:33.491]                 old_names <- names(...future.oldEnvVars)
[10:59:33.491]                 envs <- base::Sys.getenv()
[10:59:33.491]                 names <- names(envs)
[10:59:33.491]                 common <- intersect(names, old_names)
[10:59:33.491]                 added <- setdiff(names, old_names)
[10:59:33.491]                 removed <- setdiff(old_names, names)
[10:59:33.491]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.491]                   envs[common]]
[10:59:33.491]                 NAMES <- toupper(changed)
[10:59:33.491]                 args <- list()
[10:59:33.491]                 for (kk in seq_along(NAMES)) {
[10:59:33.491]                   name <- changed[[kk]]
[10:59:33.491]                   NAME <- NAMES[[kk]]
[10:59:33.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.491]                     next
[10:59:33.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.491]                 }
[10:59:33.491]                 NAMES <- toupper(added)
[10:59:33.491]                 for (kk in seq_along(NAMES)) {
[10:59:33.491]                   name <- added[[kk]]
[10:59:33.491]                   NAME <- NAMES[[kk]]
[10:59:33.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.491]                     next
[10:59:33.491]                   args[[name]] <- ""
[10:59:33.491]                 }
[10:59:33.491]                 NAMES <- toupper(removed)
[10:59:33.491]                 for (kk in seq_along(NAMES)) {
[10:59:33.491]                   name <- removed[[kk]]
[10:59:33.491]                   NAME <- NAMES[[kk]]
[10:59:33.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.491]                     next
[10:59:33.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.491]                 }
[10:59:33.491]                 if (length(args) > 0) 
[10:59:33.491]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.491]             }
[10:59:33.491]             else {
[10:59:33.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.491]             }
[10:59:33.491]             {
[10:59:33.491]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.491]                   0L) {
[10:59:33.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.491]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.491]                   base::options(opts)
[10:59:33.491]                 }
[10:59:33.491]                 {
[10:59:33.491]                   {
[10:59:33.491]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.491]                     NULL
[10:59:33.491]                   }
[10:59:33.491]                   options(future.plan = NULL)
[10:59:33.491]                   if (is.na(NA_character_)) 
[10:59:33.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.491]                     .init = FALSE)
[10:59:33.491]                 }
[10:59:33.491]             }
[10:59:33.491]         }
[10:59:33.491]     })
[10:59:33.491]     if (TRUE) {
[10:59:33.491]         base::sink(type = "output", split = FALSE)
[10:59:33.491]         if (TRUE) {
[10:59:33.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.491]         }
[10:59:33.491]         else {
[10:59:33.491]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.491]         }
[10:59:33.491]         base::close(...future.stdout)
[10:59:33.491]         ...future.stdout <- NULL
[10:59:33.491]     }
[10:59:33.491]     ...future.result$conditions <- ...future.conditions
[10:59:33.491]     ...future.result$finished <- base::Sys.time()
[10:59:33.491]     ...future.result
[10:59:33.491] }
[10:59:33.494] assign_globals() ...
[10:59:33.494] List of 5
[10:59:33.494]  $ ...future.FUN            :function (x, y)  
[10:59:33.494]  $ MoreArgs                 :List of 1
[10:59:33.494]   ..$ y: int [1:2] 3 4
[10:59:33.494]  $ ...future.elements_ii    :List of 1
[10:59:33.494]   ..$ x:List of 1
[10:59:33.494]   .. ..$ : int 1
[10:59:33.494]  $ ...future.seeds_ii       : NULL
[10:59:33.494]  $ ...future.globals.maxSize: NULL
[10:59:33.494]  - attr(*, "where")=List of 5
[10:59:33.494]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.494]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.494]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.494]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.494]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.494]  - attr(*, "resolved")= logi FALSE
[10:59:33.494]  - attr(*, "total_size")= num 656
[10:59:33.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.494]  - attr(*, "already-done")= logi TRUE
[10:59:33.501] - reassign environment for ‘...future.FUN’
[10:59:33.501] - copied ‘...future.FUN’ to environment
[10:59:33.501] - copied ‘MoreArgs’ to environment
[10:59:33.501] - copied ‘...future.elements_ii’ to environment
[10:59:33.501] - copied ‘...future.seeds_ii’ to environment
[10:59:33.501] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.501] assign_globals() ... done
[10:59:33.501] requestCore(): workers = 2
[10:59:33.504] MulticoreFuture started
[10:59:33.504] - Launch lazy future ... done
[10:59:33.505] plan(): Setting new future strategy stack:
[10:59:33.505] run() for ‘MulticoreFuture’ ... done
[10:59:33.505] Created future:
[10:59:33.505] List of future strategies:
[10:59:33.505] 1. sequential:
[10:59:33.505]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.505]    - tweaked: FALSE
[10:59:33.505]    - call: NULL
[10:59:33.507] plan(): nbrOfWorkers() = 1
[10:59:33.510] plan(): Setting new future strategy stack:
[10:59:33.511] List of future strategies:
[10:59:33.511] 1. multicore:
[10:59:33.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.511]    - tweaked: FALSE
[10:59:33.511]    - call: plan(strategy)
[10:59:33.517] plan(): nbrOfWorkers() = 2
[10:59:33.506] MulticoreFuture:
[10:59:33.506] Label: ‘future_.mapply-1’
[10:59:33.506] Expression:
[10:59:33.506] {
[10:59:33.506]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.506]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.506]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.506]         on.exit(options(oopts), add = TRUE)
[10:59:33.506]     }
[10:59:33.506]     {
[10:59:33.506]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.506]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.506]         do.call(mapply, args = args)
[10:59:33.506]     }
[10:59:33.506] }
[10:59:33.506] Lazy evaluation: FALSE
[10:59:33.506] Asynchronous evaluation: TRUE
[10:59:33.506] Local evaluation: TRUE
[10:59:33.506] Environment: R_GlobalEnv
[10:59:33.506] Capture standard output: TRUE
[10:59:33.506] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.506] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.506] Packages: <none>
[10:59:33.506] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.506] Resolved: TRUE
[10:59:33.506] Value: <not collected>
[10:59:33.506] Conditions captured: <none>
[10:59:33.506] Early signaling: FALSE
[10:59:33.506] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.506] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.518] Chunk #1 of 2 ... DONE
[10:59:33.518] Chunk #2 of 2 ...
[10:59:33.519]  - Finding globals in '...' for chunk #2 ...
[10:59:33.519] getGlobalsAndPackages() ...
[10:59:33.519] Searching for globals...
[10:59:33.520] 
[10:59:33.520] Searching for globals ... DONE
[10:59:33.520] - globals: [0] <none>
[10:59:33.520] getGlobalsAndPackages() ... DONE
[10:59:33.520]    + additional globals found: [n=0] 
[10:59:33.520]    + additional namespaces needed: [n=0] 
[10:59:33.521]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.521]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.521]  - seeds: <none>
[10:59:33.521]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.521] getGlobalsAndPackages() ...
[10:59:33.522] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.522] Resolving globals: FALSE
[10:59:33.523] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:33.523] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:33.524] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.524] 
[10:59:33.524] getGlobalsAndPackages() ... DONE
[10:59:33.524] run() for ‘Future’ ...
[10:59:33.525] - state: ‘created’
[10:59:33.525] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.527] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.528]   - Field: ‘label’
[10:59:33.528]   - Field: ‘local’
[10:59:33.528]   - Field: ‘owner’
[10:59:33.528]   - Field: ‘envir’
[10:59:33.528]   - Field: ‘workers’
[10:59:33.528]   - Field: ‘packages’
[10:59:33.528]   - Field: ‘gc’
[10:59:33.528]   - Field: ‘job’
[10:59:33.529]   - Field: ‘conditions’
[10:59:33.529]   - Field: ‘expr’
[10:59:33.529]   - Field: ‘uuid’
[10:59:33.529]   - Field: ‘seed’
[10:59:33.529]   - Field: ‘version’
[10:59:33.529]   - Field: ‘result’
[10:59:33.529]   - Field: ‘asynchronous’
[10:59:33.529]   - Field: ‘calls’
[10:59:33.530]   - Field: ‘globals’
[10:59:33.530]   - Field: ‘stdout’
[10:59:33.530]   - Field: ‘earlySignal’
[10:59:33.530]   - Field: ‘lazy’
[10:59:33.530]   - Field: ‘state’
[10:59:33.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.530] - Launch lazy future ...
[10:59:33.531] Packages needed by the future expression (n = 0): <none>
[10:59:33.531] Packages needed by future strategies (n = 0): <none>
[10:59:33.531] {
[10:59:33.531]     {
[10:59:33.531]         {
[10:59:33.531]             ...future.startTime <- base::Sys.time()
[10:59:33.531]             {
[10:59:33.531]                 {
[10:59:33.531]                   {
[10:59:33.531]                     {
[10:59:33.531]                       base::local({
[10:59:33.531]                         has_future <- base::requireNamespace("future", 
[10:59:33.531]                           quietly = TRUE)
[10:59:33.531]                         if (has_future) {
[10:59:33.531]                           ns <- base::getNamespace("future")
[10:59:33.531]                           version <- ns[[".package"]][["version"]]
[10:59:33.531]                           if (is.null(version)) 
[10:59:33.531]                             version <- utils::packageVersion("future")
[10:59:33.531]                         }
[10:59:33.531]                         else {
[10:59:33.531]                           version <- NULL
[10:59:33.531]                         }
[10:59:33.531]                         if (!has_future || version < "1.8.0") {
[10:59:33.531]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.531]                             "", base::R.version$version.string), 
[10:59:33.531]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.531]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.531]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.531]                               "release", "version")], collapse = " "), 
[10:59:33.531]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.531]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.531]                             info)
[10:59:33.531]                           info <- base::paste(info, collapse = "; ")
[10:59:33.531]                           if (!has_future) {
[10:59:33.531]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.531]                               info)
[10:59:33.531]                           }
[10:59:33.531]                           else {
[10:59:33.531]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.531]                               info, version)
[10:59:33.531]                           }
[10:59:33.531]                           base::stop(msg)
[10:59:33.531]                         }
[10:59:33.531]                       })
[10:59:33.531]                     }
[10:59:33.531]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.531]                     base::options(mc.cores = 1L)
[10:59:33.531]                   }
[10:59:33.531]                   ...future.strategy.old <- future::plan("list")
[10:59:33.531]                   options(future.plan = NULL)
[10:59:33.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.531]                 }
[10:59:33.531]                 ...future.workdir <- getwd()
[10:59:33.531]             }
[10:59:33.531]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.531]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.531]         }
[10:59:33.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.531]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.531]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.531]             base::names(...future.oldOptions))
[10:59:33.531]     }
[10:59:33.531]     if (FALSE) {
[10:59:33.531]     }
[10:59:33.531]     else {
[10:59:33.531]         if (TRUE) {
[10:59:33.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.531]                 open = "w")
[10:59:33.531]         }
[10:59:33.531]         else {
[10:59:33.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.531]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.531]         }
[10:59:33.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.531]             base::sink(type = "output", split = FALSE)
[10:59:33.531]             base::close(...future.stdout)
[10:59:33.531]         }, add = TRUE)
[10:59:33.531]     }
[10:59:33.531]     ...future.frame <- base::sys.nframe()
[10:59:33.531]     ...future.conditions <- base::list()
[10:59:33.531]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.531]     if (FALSE) {
[10:59:33.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.531]     }
[10:59:33.531]     ...future.result <- base::tryCatch({
[10:59:33.531]         base::withCallingHandlers({
[10:59:33.531]             ...future.value <- base::withVisible(base::local({
[10:59:33.531]                 withCallingHandlers({
[10:59:33.531]                   {
[10:59:33.531]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.531]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.531]                       ...future.globals.maxSize)) {
[10:59:33.531]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.531]                       on.exit(options(oopts), add = TRUE)
[10:59:33.531]                     }
[10:59:33.531]                     {
[10:59:33.531]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.531]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.531]                         USE.NAMES = FALSE)
[10:59:33.531]                       do.call(mapply, args = args)
[10:59:33.531]                     }
[10:59:33.531]                   }
[10:59:33.531]                 }, immediateCondition = function(cond) {
[10:59:33.531]                   save_rds <- function (object, pathname, ...) 
[10:59:33.531]                   {
[10:59:33.531]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.531]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.531]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.531]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.531]                         fi_tmp[["mtime"]])
[10:59:33.531]                     }
[10:59:33.531]                     tryCatch({
[10:59:33.531]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.531]                     }, error = function(ex) {
[10:59:33.531]                       msg <- conditionMessage(ex)
[10:59:33.531]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.531]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.531]                         fi_tmp[["mtime"]], msg)
[10:59:33.531]                       ex$message <- msg
[10:59:33.531]                       stop(ex)
[10:59:33.531]                     })
[10:59:33.531]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.531]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.531]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.531]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.531]                       fi <- file.info(pathname)
[10:59:33.531]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.531]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.531]                         fi[["size"]], fi[["mtime"]])
[10:59:33.531]                       stop(msg)
[10:59:33.531]                     }
[10:59:33.531]                     invisible(pathname)
[10:59:33.531]                   }
[10:59:33.531]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.531]                     rootPath = tempdir()) 
[10:59:33.531]                   {
[10:59:33.531]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.531]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.531]                       tmpdir = path, fileext = ".rds")
[10:59:33.531]                     save_rds(obj, file)
[10:59:33.531]                   }
[10:59:33.531]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.531]                   {
[10:59:33.531]                     inherits <- base::inherits
[10:59:33.531]                     invokeRestart <- base::invokeRestart
[10:59:33.531]                     is.null <- base::is.null
[10:59:33.531]                     muffled <- FALSE
[10:59:33.531]                     if (inherits(cond, "message")) {
[10:59:33.531]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.531]                       if (muffled) 
[10:59:33.531]                         invokeRestart("muffleMessage")
[10:59:33.531]                     }
[10:59:33.531]                     else if (inherits(cond, "warning")) {
[10:59:33.531]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.531]                       if (muffled) 
[10:59:33.531]                         invokeRestart("muffleWarning")
[10:59:33.531]                     }
[10:59:33.531]                     else if (inherits(cond, "condition")) {
[10:59:33.531]                       if (!is.null(pattern)) {
[10:59:33.531]                         computeRestarts <- base::computeRestarts
[10:59:33.531]                         grepl <- base::grepl
[10:59:33.531]                         restarts <- computeRestarts(cond)
[10:59:33.531]                         for (restart in restarts) {
[10:59:33.531]                           name <- restart$name
[10:59:33.531]                           if (is.null(name)) 
[10:59:33.531]                             next
[10:59:33.531]                           if (!grepl(pattern, name)) 
[10:59:33.531]                             next
[10:59:33.531]                           invokeRestart(restart)
[10:59:33.531]                           muffled <- TRUE
[10:59:33.531]                           break
[10:59:33.531]                         }
[10:59:33.531]                       }
[10:59:33.531]                     }
[10:59:33.531]                     invisible(muffled)
[10:59:33.531]                   }
[10:59:33.531]                   muffleCondition(cond)
[10:59:33.531]                 })
[10:59:33.531]             }))
[10:59:33.531]             future::FutureResult(value = ...future.value$value, 
[10:59:33.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.531]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.531]                     ...future.globalenv.names))
[10:59:33.531]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.531]         }, condition = base::local({
[10:59:33.531]             c <- base::c
[10:59:33.531]             inherits <- base::inherits
[10:59:33.531]             invokeRestart <- base::invokeRestart
[10:59:33.531]             length <- base::length
[10:59:33.531]             list <- base::list
[10:59:33.531]             seq.int <- base::seq.int
[10:59:33.531]             signalCondition <- base::signalCondition
[10:59:33.531]             sys.calls <- base::sys.calls
[10:59:33.531]             `[[` <- base::`[[`
[10:59:33.531]             `+` <- base::`+`
[10:59:33.531]             `<<-` <- base::`<<-`
[10:59:33.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.531]                   3L)]
[10:59:33.531]             }
[10:59:33.531]             function(cond) {
[10:59:33.531]                 is_error <- inherits(cond, "error")
[10:59:33.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.531]                   NULL)
[10:59:33.531]                 if (is_error) {
[10:59:33.531]                   sessionInformation <- function() {
[10:59:33.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.531]                       search = base::search(), system = base::Sys.info())
[10:59:33.531]                   }
[10:59:33.531]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.531]                     cond$call), session = sessionInformation(), 
[10:59:33.531]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.531]                   signalCondition(cond)
[10:59:33.531]                 }
[10:59:33.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.531]                 "immediateCondition"))) {
[10:59:33.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.531]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.531]                   if (TRUE && !signal) {
[10:59:33.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.531]                     {
[10:59:33.531]                       inherits <- base::inherits
[10:59:33.531]                       invokeRestart <- base::invokeRestart
[10:59:33.531]                       is.null <- base::is.null
[10:59:33.531]                       muffled <- FALSE
[10:59:33.531]                       if (inherits(cond, "message")) {
[10:59:33.531]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.531]                         if (muffled) 
[10:59:33.531]                           invokeRestart("muffleMessage")
[10:59:33.531]                       }
[10:59:33.531]                       else if (inherits(cond, "warning")) {
[10:59:33.531]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.531]                         if (muffled) 
[10:59:33.531]                           invokeRestart("muffleWarning")
[10:59:33.531]                       }
[10:59:33.531]                       else if (inherits(cond, "condition")) {
[10:59:33.531]                         if (!is.null(pattern)) {
[10:59:33.531]                           computeRestarts <- base::computeRestarts
[10:59:33.531]                           grepl <- base::grepl
[10:59:33.531]                           restarts <- computeRestarts(cond)
[10:59:33.531]                           for (restart in restarts) {
[10:59:33.531]                             name <- restart$name
[10:59:33.531]                             if (is.null(name)) 
[10:59:33.531]                               next
[10:59:33.531]                             if (!grepl(pattern, name)) 
[10:59:33.531]                               next
[10:59:33.531]                             invokeRestart(restart)
[10:59:33.531]                             muffled <- TRUE
[10:59:33.531]                             break
[10:59:33.531]                           }
[10:59:33.531]                         }
[10:59:33.531]                       }
[10:59:33.531]                       invisible(muffled)
[10:59:33.531]                     }
[10:59:33.531]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.531]                   }
[10:59:33.531]                 }
[10:59:33.531]                 else {
[10:59:33.531]                   if (TRUE) {
[10:59:33.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.531]                     {
[10:59:33.531]                       inherits <- base::inherits
[10:59:33.531]                       invokeRestart <- base::invokeRestart
[10:59:33.531]                       is.null <- base::is.null
[10:59:33.531]                       muffled <- FALSE
[10:59:33.531]                       if (inherits(cond, "message")) {
[10:59:33.531]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.531]                         if (muffled) 
[10:59:33.531]                           invokeRestart("muffleMessage")
[10:59:33.531]                       }
[10:59:33.531]                       else if (inherits(cond, "warning")) {
[10:59:33.531]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.531]                         if (muffled) 
[10:59:33.531]                           invokeRestart("muffleWarning")
[10:59:33.531]                       }
[10:59:33.531]                       else if (inherits(cond, "condition")) {
[10:59:33.531]                         if (!is.null(pattern)) {
[10:59:33.531]                           computeRestarts <- base::computeRestarts
[10:59:33.531]                           grepl <- base::grepl
[10:59:33.531]                           restarts <- computeRestarts(cond)
[10:59:33.531]                           for (restart in restarts) {
[10:59:33.531]                             name <- restart$name
[10:59:33.531]                             if (is.null(name)) 
[10:59:33.531]                               next
[10:59:33.531]                             if (!grepl(pattern, name)) 
[10:59:33.531]                               next
[10:59:33.531]                             invokeRestart(restart)
[10:59:33.531]                             muffled <- TRUE
[10:59:33.531]                             break
[10:59:33.531]                           }
[10:59:33.531]                         }
[10:59:33.531]                       }
[10:59:33.531]                       invisible(muffled)
[10:59:33.531]                     }
[10:59:33.531]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.531]                   }
[10:59:33.531]                 }
[10:59:33.531]             }
[10:59:33.531]         }))
[10:59:33.531]     }, error = function(ex) {
[10:59:33.531]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.531]                 ...future.rng), started = ...future.startTime, 
[10:59:33.531]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.531]             version = "1.8"), class = "FutureResult")
[10:59:33.531]     }, finally = {
[10:59:33.531]         if (!identical(...future.workdir, getwd())) 
[10:59:33.531]             setwd(...future.workdir)
[10:59:33.531]         {
[10:59:33.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.531]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.531]             }
[10:59:33.531]             base::options(...future.oldOptions)
[10:59:33.531]             if (.Platform$OS.type == "windows") {
[10:59:33.531]                 old_names <- names(...future.oldEnvVars)
[10:59:33.531]                 envs <- base::Sys.getenv()
[10:59:33.531]                 names <- names(envs)
[10:59:33.531]                 common <- intersect(names, old_names)
[10:59:33.531]                 added <- setdiff(names, old_names)
[10:59:33.531]                 removed <- setdiff(old_names, names)
[10:59:33.531]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.531]                   envs[common]]
[10:59:33.531]                 NAMES <- toupper(changed)
[10:59:33.531]                 args <- list()
[10:59:33.531]                 for (kk in seq_along(NAMES)) {
[10:59:33.531]                   name <- changed[[kk]]
[10:59:33.531]                   NAME <- NAMES[[kk]]
[10:59:33.531]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.531]                     next
[10:59:33.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.531]                 }
[10:59:33.531]                 NAMES <- toupper(added)
[10:59:33.531]                 for (kk in seq_along(NAMES)) {
[10:59:33.531]                   name <- added[[kk]]
[10:59:33.531]                   NAME <- NAMES[[kk]]
[10:59:33.531]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.531]                     next
[10:59:33.531]                   args[[name]] <- ""
[10:59:33.531]                 }
[10:59:33.531]                 NAMES <- toupper(removed)
[10:59:33.531]                 for (kk in seq_along(NAMES)) {
[10:59:33.531]                   name <- removed[[kk]]
[10:59:33.531]                   NAME <- NAMES[[kk]]
[10:59:33.531]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.531]                     next
[10:59:33.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.531]                 }
[10:59:33.531]                 if (length(args) > 0) 
[10:59:33.531]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.531]             }
[10:59:33.531]             else {
[10:59:33.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.531]             }
[10:59:33.531]             {
[10:59:33.531]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.531]                   0L) {
[10:59:33.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.531]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.531]                   base::options(opts)
[10:59:33.531]                 }
[10:59:33.531]                 {
[10:59:33.531]                   {
[10:59:33.531]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.531]                     NULL
[10:59:33.531]                   }
[10:59:33.531]                   options(future.plan = NULL)
[10:59:33.531]                   if (is.na(NA_character_)) 
[10:59:33.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.531]                     .init = FALSE)
[10:59:33.531]                 }
[10:59:33.531]             }
[10:59:33.531]         }
[10:59:33.531]     })
[10:59:33.531]     if (TRUE) {
[10:59:33.531]         base::sink(type = "output", split = FALSE)
[10:59:33.531]         if (TRUE) {
[10:59:33.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.531]         }
[10:59:33.531]         else {
[10:59:33.531]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.531]         }
[10:59:33.531]         base::close(...future.stdout)
[10:59:33.531]         ...future.stdout <- NULL
[10:59:33.531]     }
[10:59:33.531]     ...future.result$conditions <- ...future.conditions
[10:59:33.531]     ...future.result$finished <- base::Sys.time()
[10:59:33.531]     ...future.result
[10:59:33.531] }
[10:59:33.535] assign_globals() ...
[10:59:33.535] List of 5
[10:59:33.535]  $ ...future.FUN            :function (x, y)  
[10:59:33.535]  $ MoreArgs                 :List of 1
[10:59:33.535]   ..$ y: int [1:2] 3 4
[10:59:33.535]  $ ...future.elements_ii    :List of 1
[10:59:33.535]   ..$ x:List of 1
[10:59:33.535]   .. ..$ : int 2
[10:59:33.535]  $ ...future.seeds_ii       : NULL
[10:59:33.535]  $ ...future.globals.maxSize: NULL
[10:59:33.535]  - attr(*, "where")=List of 5
[10:59:33.535]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.535]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.535]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.535]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.535]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.535]  - attr(*, "resolved")= logi FALSE
[10:59:33.535]  - attr(*, "total_size")= num 656
[10:59:33.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.535]  - attr(*, "already-done")= logi TRUE
[10:59:33.544] - reassign environment for ‘...future.FUN’
[10:59:33.544] - copied ‘...future.FUN’ to environment
[10:59:33.544] - copied ‘MoreArgs’ to environment
[10:59:33.544] - copied ‘...future.elements_ii’ to environment
[10:59:33.544] - copied ‘...future.seeds_ii’ to environment
[10:59:33.545] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.545] assign_globals() ... done
[10:59:33.545] requestCore(): workers = 2
[10:59:33.547] MulticoreFuture started
[10:59:33.548] - Launch lazy future ... done
[10:59:33.549] run() for ‘MulticoreFuture’ ... done
[10:59:33.549] plan(): Setting new future strategy stack:
[10:59:33.549] Created future:
[10:59:33.549] List of future strategies:
[10:59:33.549] 1. sequential:
[10:59:33.549]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.549]    - tweaked: FALSE
[10:59:33.549]    - call: NULL
[10:59:33.551] plan(): nbrOfWorkers() = 1
[10:59:33.555] plan(): Setting new future strategy stack:
[10:59:33.556] List of future strategies:
[10:59:33.556] 1. multicore:
[10:59:33.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.556]    - tweaked: FALSE
[10:59:33.556]    - call: plan(strategy)
[10:59:33.562] plan(): nbrOfWorkers() = 2
[10:59:33.550] MulticoreFuture:
[10:59:33.550] Label: ‘future_.mapply-2’
[10:59:33.550] Expression:
[10:59:33.550] {
[10:59:33.550]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.550]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.550]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.550]         on.exit(options(oopts), add = TRUE)
[10:59:33.550]     }
[10:59:33.550]     {
[10:59:33.550]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.550]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.550]         do.call(mapply, args = args)
[10:59:33.550]     }
[10:59:33.550] }
[10:59:33.550] Lazy evaluation: FALSE
[10:59:33.550] Asynchronous evaluation: TRUE
[10:59:33.550] Local evaluation: TRUE
[10:59:33.550] Environment: R_GlobalEnv
[10:59:33.550] Capture standard output: TRUE
[10:59:33.550] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.550] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.550] Packages: <none>
[10:59:33.550] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.550] Resolved: FALSE
[10:59:33.550] Value: <not collected>
[10:59:33.550] Conditions captured: <none>
[10:59:33.550] Early signaling: FALSE
[10:59:33.550] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.550] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.563] Chunk #2 of 2 ... DONE
[10:59:33.563] Launching 2 futures (chunks) ... DONE
[10:59:33.564] Resolving 2 futures (chunks) ...
[10:59:33.564] resolve() on list ...
[10:59:33.564]  recursive: 0
[10:59:33.564]  length: 2
[10:59:33.564] 
[10:59:33.565] Future #1
[10:59:33.565] result() for MulticoreFuture ...
[10:59:33.566] result() for MulticoreFuture ...
[10:59:33.566] result() for MulticoreFuture ... done
[10:59:33.567] result() for MulticoreFuture ... done
[10:59:33.567] result() for MulticoreFuture ...
[10:59:33.567] result() for MulticoreFuture ... done
[10:59:33.567] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.567] - nx: 2
[10:59:33.568] - relay: TRUE
[10:59:33.568] - stdout: TRUE
[10:59:33.568] - signal: TRUE
[10:59:33.568] - resignal: FALSE
[10:59:33.568] - force: TRUE
[10:59:33.569] - relayed: [n=2] FALSE, FALSE
[10:59:33.569] - queued futures: [n=2] FALSE, FALSE
[10:59:33.569]  - until=1
[10:59:33.569]  - relaying element #1
[10:59:33.569] result() for MulticoreFuture ...
[10:59:33.570] result() for MulticoreFuture ... done
[10:59:33.570] result() for MulticoreFuture ...
[10:59:33.570] result() for MulticoreFuture ... done
[10:59:33.571] result() for MulticoreFuture ...
[10:59:33.571] result() for MulticoreFuture ... done
[10:59:33.571] result() for MulticoreFuture ...
[10:59:33.571] result() for MulticoreFuture ... done
[10:59:33.571] - relayed: [n=2] TRUE, FALSE
[10:59:33.572] - queued futures: [n=2] TRUE, FALSE
[10:59:33.572] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.572]  length: 1 (resolved future 1)
[10:59:33.572] Future #2
[10:59:33.572] result() for MulticoreFuture ...
[10:59:33.573] result() for MulticoreFuture ...
[10:59:33.573] result() for MulticoreFuture ... done
[10:59:33.573] result() for MulticoreFuture ... done
[10:59:33.573] result() for MulticoreFuture ...
[10:59:33.574] result() for MulticoreFuture ... done
[10:59:33.574] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.574] - nx: 2
[10:59:33.574] - relay: TRUE
[10:59:33.574] - stdout: TRUE
[10:59:33.574] - signal: TRUE
[10:59:33.574] - resignal: FALSE
[10:59:33.575] - force: TRUE
[10:59:33.575] - relayed: [n=2] TRUE, FALSE
[10:59:33.575] - queued futures: [n=2] TRUE, FALSE
[10:59:33.575]  - until=2
[10:59:33.575]  - relaying element #2
[10:59:33.575] result() for MulticoreFuture ...
[10:59:33.575] result() for MulticoreFuture ... done
[10:59:33.575] result() for MulticoreFuture ...
[10:59:33.576] result() for MulticoreFuture ... done
[10:59:33.576] result() for MulticoreFuture ...
[10:59:33.576] result() for MulticoreFuture ... done
[10:59:33.576] result() for MulticoreFuture ...
[10:59:33.576] result() for MulticoreFuture ... done
[10:59:33.576] - relayed: [n=2] TRUE, TRUE
[10:59:33.576] - queued futures: [n=2] TRUE, TRUE
[10:59:33.576] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.576]  length: 0 (resolved future 2)
[10:59:33.577] Relaying remaining futures
[10:59:33.577] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.577] - nx: 2
[10:59:33.577] - relay: TRUE
[10:59:33.577] - stdout: TRUE
[10:59:33.577] - signal: TRUE
[10:59:33.577] - resignal: FALSE
[10:59:33.577] - force: TRUE
[10:59:33.577] - relayed: [n=2] TRUE, TRUE
[10:59:33.577] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.578] - relayed: [n=2] TRUE, TRUE
[10:59:33.578] - queued futures: [n=2] TRUE, TRUE
[10:59:33.578] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.578] resolve() on list ... DONE
[10:59:33.578] result() for MulticoreFuture ...
[10:59:33.578] result() for MulticoreFuture ... done
[10:59:33.578] result() for MulticoreFuture ...
[10:59:33.578] result() for MulticoreFuture ... done
[10:59:33.578] result() for MulticoreFuture ...
[10:59:33.579] result() for MulticoreFuture ... done
[10:59:33.579] result() for MulticoreFuture ...
[10:59:33.579] result() for MulticoreFuture ... done
[10:59:33.579]  - Number of value chunks collected: 2
[10:59:33.579] Resolving 2 futures (chunks) ... DONE
[10:59:33.579] Reducing values from 2 chunks ...
[10:59:33.579]  - Number of values collected after concatenation: 2
[10:59:33.579]  - Number of values expected: 2
[10:59:33.579] Reducing values from 2 chunks ... DONE
[10:59:33.579] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:59:33.580] future_mapply() ...
[10:59:33.582] Number of chunks: 2
[10:59:33.582] getGlobalsAndPackagesXApply() ...
[10:59:33.582]  - future.globals: TRUE
[10:59:33.582] getGlobalsAndPackages() ...
[10:59:33.582] Searching for globals...
[10:59:33.583] - globals found: [1] ‘FUN’
[10:59:33.583] Searching for globals ... DONE
[10:59:33.583] Resolving globals: FALSE
[10:59:33.584] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:33.584] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:33.584] - globals: [1] ‘FUN’
[10:59:33.584] 
[10:59:33.584] getGlobalsAndPackages() ... DONE
[10:59:33.584]  - globals found/used: [n=1] ‘FUN’
[10:59:33.585]  - needed namespaces: [n=0] 
[10:59:33.585] Finding globals ... DONE
[10:59:33.585] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.585] List of 2
[10:59:33.585]  $ ...future.FUN:function (x, ...)  
[10:59:33.585]  $ MoreArgs     : NULL
[10:59:33.585]  - attr(*, "where")=List of 2
[10:59:33.585]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.585]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.585]  - attr(*, "resolved")= logi FALSE
[10:59:33.585]  - attr(*, "total_size")= num NA
[10:59:33.591] Packages to be attached in all futures: [n=0] 
[10:59:33.591] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.591] Number of futures (= number of chunks): 2
[10:59:33.591] Launching 2 futures (chunks) ...
[10:59:33.591] Chunk #1 of 2 ...
[10:59:33.591]  - Finding globals in '...' for chunk #1 ...
[10:59:33.591] getGlobalsAndPackages() ...
[10:59:33.592] Searching for globals...
[10:59:33.592] 
[10:59:33.592] Searching for globals ... DONE
[10:59:33.592] - globals: [0] <none>
[10:59:33.592] getGlobalsAndPackages() ... DONE
[10:59:33.592]    + additional globals found: [n=0] 
[10:59:33.593]    + additional namespaces needed: [n=0] 
[10:59:33.593]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.593]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.593]  - seeds: <none>
[10:59:33.593]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.593] getGlobalsAndPackages() ...
[10:59:33.593] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.593] Resolving globals: FALSE
[10:59:33.594] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:33.594] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.594] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.595] 
[10:59:33.595] getGlobalsAndPackages() ... DONE
[10:59:33.595] run() for ‘Future’ ...
[10:59:33.595] - state: ‘created’
[10:59:33.595] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.597] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.597]   - Field: ‘label’
[10:59:33.598]   - Field: ‘local’
[10:59:33.598]   - Field: ‘owner’
[10:59:33.598]   - Field: ‘envir’
[10:59:33.598]   - Field: ‘workers’
[10:59:33.598]   - Field: ‘packages’
[10:59:33.598]   - Field: ‘gc’
[10:59:33.598]   - Field: ‘job’
[10:59:33.598]   - Field: ‘conditions’
[10:59:33.598]   - Field: ‘expr’
[10:59:33.598]   - Field: ‘uuid’
[10:59:33.598]   - Field: ‘seed’
[10:59:33.599]   - Field: ‘version’
[10:59:33.599]   - Field: ‘result’
[10:59:33.599]   - Field: ‘asynchronous’
[10:59:33.599]   - Field: ‘calls’
[10:59:33.599]   - Field: ‘globals’
[10:59:33.599]   - Field: ‘stdout’
[10:59:33.599]   - Field: ‘earlySignal’
[10:59:33.599]   - Field: ‘lazy’
[10:59:33.599]   - Field: ‘state’
[10:59:33.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.599] - Launch lazy future ...
[10:59:33.600] Packages needed by the future expression (n = 0): <none>
[10:59:33.600] Packages needed by future strategies (n = 0): <none>
[10:59:33.600] {
[10:59:33.600]     {
[10:59:33.600]         {
[10:59:33.600]             ...future.startTime <- base::Sys.time()
[10:59:33.600]             {
[10:59:33.600]                 {
[10:59:33.600]                   {
[10:59:33.600]                     {
[10:59:33.600]                       base::local({
[10:59:33.600]                         has_future <- base::requireNamespace("future", 
[10:59:33.600]                           quietly = TRUE)
[10:59:33.600]                         if (has_future) {
[10:59:33.600]                           ns <- base::getNamespace("future")
[10:59:33.600]                           version <- ns[[".package"]][["version"]]
[10:59:33.600]                           if (is.null(version)) 
[10:59:33.600]                             version <- utils::packageVersion("future")
[10:59:33.600]                         }
[10:59:33.600]                         else {
[10:59:33.600]                           version <- NULL
[10:59:33.600]                         }
[10:59:33.600]                         if (!has_future || version < "1.8.0") {
[10:59:33.600]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.600]                             "", base::R.version$version.string), 
[10:59:33.600]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.600]                               "release", "version")], collapse = " "), 
[10:59:33.600]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.600]                             info)
[10:59:33.600]                           info <- base::paste(info, collapse = "; ")
[10:59:33.600]                           if (!has_future) {
[10:59:33.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.600]                               info)
[10:59:33.600]                           }
[10:59:33.600]                           else {
[10:59:33.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.600]                               info, version)
[10:59:33.600]                           }
[10:59:33.600]                           base::stop(msg)
[10:59:33.600]                         }
[10:59:33.600]                       })
[10:59:33.600]                     }
[10:59:33.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.600]                     base::options(mc.cores = 1L)
[10:59:33.600]                   }
[10:59:33.600]                   ...future.strategy.old <- future::plan("list")
[10:59:33.600]                   options(future.plan = NULL)
[10:59:33.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.600]                 }
[10:59:33.600]                 ...future.workdir <- getwd()
[10:59:33.600]             }
[10:59:33.600]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.600]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.600]         }
[10:59:33.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.600]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.600]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.600]             base::names(...future.oldOptions))
[10:59:33.600]     }
[10:59:33.600]     if (FALSE) {
[10:59:33.600]     }
[10:59:33.600]     else {
[10:59:33.600]         if (TRUE) {
[10:59:33.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.600]                 open = "w")
[10:59:33.600]         }
[10:59:33.600]         else {
[10:59:33.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.600]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.600]         }
[10:59:33.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.600]             base::sink(type = "output", split = FALSE)
[10:59:33.600]             base::close(...future.stdout)
[10:59:33.600]         }, add = TRUE)
[10:59:33.600]     }
[10:59:33.600]     ...future.frame <- base::sys.nframe()
[10:59:33.600]     ...future.conditions <- base::list()
[10:59:33.600]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.600]     if (FALSE) {
[10:59:33.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.600]     }
[10:59:33.600]     ...future.result <- base::tryCatch({
[10:59:33.600]         base::withCallingHandlers({
[10:59:33.600]             ...future.value <- base::withVisible(base::local({
[10:59:33.600]                 withCallingHandlers({
[10:59:33.600]                   {
[10:59:33.600]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.600]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.600]                       ...future.globals.maxSize)) {
[10:59:33.600]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.600]                       on.exit(options(oopts), add = TRUE)
[10:59:33.600]                     }
[10:59:33.600]                     {
[10:59:33.600]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.600]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.600]                         USE.NAMES = FALSE)
[10:59:33.600]                       do.call(mapply, args = args)
[10:59:33.600]                     }
[10:59:33.600]                   }
[10:59:33.600]                 }, immediateCondition = function(cond) {
[10:59:33.600]                   save_rds <- function (object, pathname, ...) 
[10:59:33.600]                   {
[10:59:33.600]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.600]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.600]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.600]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.600]                         fi_tmp[["mtime"]])
[10:59:33.600]                     }
[10:59:33.600]                     tryCatch({
[10:59:33.600]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.600]                     }, error = function(ex) {
[10:59:33.600]                       msg <- conditionMessage(ex)
[10:59:33.600]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.600]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.600]                         fi_tmp[["mtime"]], msg)
[10:59:33.600]                       ex$message <- msg
[10:59:33.600]                       stop(ex)
[10:59:33.600]                     })
[10:59:33.600]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.600]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.600]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.600]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.600]                       fi <- file.info(pathname)
[10:59:33.600]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.600]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.600]                         fi[["size"]], fi[["mtime"]])
[10:59:33.600]                       stop(msg)
[10:59:33.600]                     }
[10:59:33.600]                     invisible(pathname)
[10:59:33.600]                   }
[10:59:33.600]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.600]                     rootPath = tempdir()) 
[10:59:33.600]                   {
[10:59:33.600]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.600]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.600]                       tmpdir = path, fileext = ".rds")
[10:59:33.600]                     save_rds(obj, file)
[10:59:33.600]                   }
[10:59:33.600]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.600]                   {
[10:59:33.600]                     inherits <- base::inherits
[10:59:33.600]                     invokeRestart <- base::invokeRestart
[10:59:33.600]                     is.null <- base::is.null
[10:59:33.600]                     muffled <- FALSE
[10:59:33.600]                     if (inherits(cond, "message")) {
[10:59:33.600]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.600]                       if (muffled) 
[10:59:33.600]                         invokeRestart("muffleMessage")
[10:59:33.600]                     }
[10:59:33.600]                     else if (inherits(cond, "warning")) {
[10:59:33.600]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.600]                       if (muffled) 
[10:59:33.600]                         invokeRestart("muffleWarning")
[10:59:33.600]                     }
[10:59:33.600]                     else if (inherits(cond, "condition")) {
[10:59:33.600]                       if (!is.null(pattern)) {
[10:59:33.600]                         computeRestarts <- base::computeRestarts
[10:59:33.600]                         grepl <- base::grepl
[10:59:33.600]                         restarts <- computeRestarts(cond)
[10:59:33.600]                         for (restart in restarts) {
[10:59:33.600]                           name <- restart$name
[10:59:33.600]                           if (is.null(name)) 
[10:59:33.600]                             next
[10:59:33.600]                           if (!grepl(pattern, name)) 
[10:59:33.600]                             next
[10:59:33.600]                           invokeRestart(restart)
[10:59:33.600]                           muffled <- TRUE
[10:59:33.600]                           break
[10:59:33.600]                         }
[10:59:33.600]                       }
[10:59:33.600]                     }
[10:59:33.600]                     invisible(muffled)
[10:59:33.600]                   }
[10:59:33.600]                   muffleCondition(cond)
[10:59:33.600]                 })
[10:59:33.600]             }))
[10:59:33.600]             future::FutureResult(value = ...future.value$value, 
[10:59:33.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.600]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.600]                     ...future.globalenv.names))
[10:59:33.600]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.600]         }, condition = base::local({
[10:59:33.600]             c <- base::c
[10:59:33.600]             inherits <- base::inherits
[10:59:33.600]             invokeRestart <- base::invokeRestart
[10:59:33.600]             length <- base::length
[10:59:33.600]             list <- base::list
[10:59:33.600]             seq.int <- base::seq.int
[10:59:33.600]             signalCondition <- base::signalCondition
[10:59:33.600]             sys.calls <- base::sys.calls
[10:59:33.600]             `[[` <- base::`[[`
[10:59:33.600]             `+` <- base::`+`
[10:59:33.600]             `<<-` <- base::`<<-`
[10:59:33.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.600]                   3L)]
[10:59:33.600]             }
[10:59:33.600]             function(cond) {
[10:59:33.600]                 is_error <- inherits(cond, "error")
[10:59:33.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.600]                   NULL)
[10:59:33.600]                 if (is_error) {
[10:59:33.600]                   sessionInformation <- function() {
[10:59:33.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.600]                       search = base::search(), system = base::Sys.info())
[10:59:33.600]                   }
[10:59:33.600]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.600]                     cond$call), session = sessionInformation(), 
[10:59:33.600]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.600]                   signalCondition(cond)
[10:59:33.600]                 }
[10:59:33.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.600]                 "immediateCondition"))) {
[10:59:33.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.600]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.600]                   if (TRUE && !signal) {
[10:59:33.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.600]                     {
[10:59:33.600]                       inherits <- base::inherits
[10:59:33.600]                       invokeRestart <- base::invokeRestart
[10:59:33.600]                       is.null <- base::is.null
[10:59:33.600]                       muffled <- FALSE
[10:59:33.600]                       if (inherits(cond, "message")) {
[10:59:33.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.600]                         if (muffled) 
[10:59:33.600]                           invokeRestart("muffleMessage")
[10:59:33.600]                       }
[10:59:33.600]                       else if (inherits(cond, "warning")) {
[10:59:33.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.600]                         if (muffled) 
[10:59:33.600]                           invokeRestart("muffleWarning")
[10:59:33.600]                       }
[10:59:33.600]                       else if (inherits(cond, "condition")) {
[10:59:33.600]                         if (!is.null(pattern)) {
[10:59:33.600]                           computeRestarts <- base::computeRestarts
[10:59:33.600]                           grepl <- base::grepl
[10:59:33.600]                           restarts <- computeRestarts(cond)
[10:59:33.600]                           for (restart in restarts) {
[10:59:33.600]                             name <- restart$name
[10:59:33.600]                             if (is.null(name)) 
[10:59:33.600]                               next
[10:59:33.600]                             if (!grepl(pattern, name)) 
[10:59:33.600]                               next
[10:59:33.600]                             invokeRestart(restart)
[10:59:33.600]                             muffled <- TRUE
[10:59:33.600]                             break
[10:59:33.600]                           }
[10:59:33.600]                         }
[10:59:33.600]                       }
[10:59:33.600]                       invisible(muffled)
[10:59:33.600]                     }
[10:59:33.600]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.600]                   }
[10:59:33.600]                 }
[10:59:33.600]                 else {
[10:59:33.600]                   if (TRUE) {
[10:59:33.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.600]                     {
[10:59:33.600]                       inherits <- base::inherits
[10:59:33.600]                       invokeRestart <- base::invokeRestart
[10:59:33.600]                       is.null <- base::is.null
[10:59:33.600]                       muffled <- FALSE
[10:59:33.600]                       if (inherits(cond, "message")) {
[10:59:33.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.600]                         if (muffled) 
[10:59:33.600]                           invokeRestart("muffleMessage")
[10:59:33.600]                       }
[10:59:33.600]                       else if (inherits(cond, "warning")) {
[10:59:33.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.600]                         if (muffled) 
[10:59:33.600]                           invokeRestart("muffleWarning")
[10:59:33.600]                       }
[10:59:33.600]                       else if (inherits(cond, "condition")) {
[10:59:33.600]                         if (!is.null(pattern)) {
[10:59:33.600]                           computeRestarts <- base::computeRestarts
[10:59:33.600]                           grepl <- base::grepl
[10:59:33.600]                           restarts <- computeRestarts(cond)
[10:59:33.600]                           for (restart in restarts) {
[10:59:33.600]                             name <- restart$name
[10:59:33.600]                             if (is.null(name)) 
[10:59:33.600]                               next
[10:59:33.600]                             if (!grepl(pattern, name)) 
[10:59:33.600]                               next
[10:59:33.600]                             invokeRestart(restart)
[10:59:33.600]                             muffled <- TRUE
[10:59:33.600]                             break
[10:59:33.600]                           }
[10:59:33.600]                         }
[10:59:33.600]                       }
[10:59:33.600]                       invisible(muffled)
[10:59:33.600]                     }
[10:59:33.600]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.600]                   }
[10:59:33.600]                 }
[10:59:33.600]             }
[10:59:33.600]         }))
[10:59:33.600]     }, error = function(ex) {
[10:59:33.600]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.600]                 ...future.rng), started = ...future.startTime, 
[10:59:33.600]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.600]             version = "1.8"), class = "FutureResult")
[10:59:33.600]     }, finally = {
[10:59:33.600]         if (!identical(...future.workdir, getwd())) 
[10:59:33.600]             setwd(...future.workdir)
[10:59:33.600]         {
[10:59:33.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.600]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.600]             }
[10:59:33.600]             base::options(...future.oldOptions)
[10:59:33.600]             if (.Platform$OS.type == "windows") {
[10:59:33.600]                 old_names <- names(...future.oldEnvVars)
[10:59:33.600]                 envs <- base::Sys.getenv()
[10:59:33.600]                 names <- names(envs)
[10:59:33.600]                 common <- intersect(names, old_names)
[10:59:33.600]                 added <- setdiff(names, old_names)
[10:59:33.600]                 removed <- setdiff(old_names, names)
[10:59:33.600]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.600]                   envs[common]]
[10:59:33.600]                 NAMES <- toupper(changed)
[10:59:33.600]                 args <- list()
[10:59:33.600]                 for (kk in seq_along(NAMES)) {
[10:59:33.600]                   name <- changed[[kk]]
[10:59:33.600]                   NAME <- NAMES[[kk]]
[10:59:33.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.600]                     next
[10:59:33.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.600]                 }
[10:59:33.600]                 NAMES <- toupper(added)
[10:59:33.600]                 for (kk in seq_along(NAMES)) {
[10:59:33.600]                   name <- added[[kk]]
[10:59:33.600]                   NAME <- NAMES[[kk]]
[10:59:33.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.600]                     next
[10:59:33.600]                   args[[name]] <- ""
[10:59:33.600]                 }
[10:59:33.600]                 NAMES <- toupper(removed)
[10:59:33.600]                 for (kk in seq_along(NAMES)) {
[10:59:33.600]                   name <- removed[[kk]]
[10:59:33.600]                   NAME <- NAMES[[kk]]
[10:59:33.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.600]                     next
[10:59:33.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.600]                 }
[10:59:33.600]                 if (length(args) > 0) 
[10:59:33.600]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.600]             }
[10:59:33.600]             else {
[10:59:33.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.600]             }
[10:59:33.600]             {
[10:59:33.600]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.600]                   0L) {
[10:59:33.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.600]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.600]                   base::options(opts)
[10:59:33.600]                 }
[10:59:33.600]                 {
[10:59:33.600]                   {
[10:59:33.600]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.600]                     NULL
[10:59:33.600]                   }
[10:59:33.600]                   options(future.plan = NULL)
[10:59:33.600]                   if (is.na(NA_character_)) 
[10:59:33.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.600]                     .init = FALSE)
[10:59:33.600]                 }
[10:59:33.600]             }
[10:59:33.600]         }
[10:59:33.600]     })
[10:59:33.600]     if (TRUE) {
[10:59:33.600]         base::sink(type = "output", split = FALSE)
[10:59:33.600]         if (TRUE) {
[10:59:33.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.600]         }
[10:59:33.600]         else {
[10:59:33.600]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.600]         }
[10:59:33.600]         base::close(...future.stdout)
[10:59:33.600]         ...future.stdout <- NULL
[10:59:33.600]     }
[10:59:33.600]     ...future.result$conditions <- ...future.conditions
[10:59:33.600]     ...future.result$finished <- base::Sys.time()
[10:59:33.600]     ...future.result
[10:59:33.600] }
[10:59:33.603] assign_globals() ...
[10:59:33.603] List of 5
[10:59:33.603]  $ ...future.FUN            :function (x, ...)  
[10:59:33.603]  $ MoreArgs                 : NULL
[10:59:33.603]  $ ...future.elements_ii    :List of 2
[10:59:33.603]   ..$ :List of 2
[10:59:33.603]   .. ..$ : int 1
[10:59:33.603]   .. ..$ : int 2
[10:59:33.603]   ..$ :List of 2
[10:59:33.603]   .. ..$ : int 2
[10:59:33.603]   .. ..$ : int 1
[10:59:33.603]  $ ...future.seeds_ii       : NULL
[10:59:33.603]  $ ...future.globals.maxSize: NULL
[10:59:33.603]  - attr(*, "where")=List of 5
[10:59:33.603]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.603]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.603]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.603]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.603]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.603]  - attr(*, "resolved")= logi FALSE
[10:59:33.603]  - attr(*, "total_size")= num 210
[10:59:33.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.603]  - attr(*, "already-done")= logi TRUE
[10:59:33.609] - copied ‘...future.FUN’ to environment
[10:59:33.609] - copied ‘MoreArgs’ to environment
[10:59:33.609] - copied ‘...future.elements_ii’ to environment
[10:59:33.609] - copied ‘...future.seeds_ii’ to environment
[10:59:33.609] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.609] assign_globals() ... done
[10:59:33.609] requestCore(): workers = 2
[10:59:33.614] MulticoreFuture started
[10:59:33.614] - Launch lazy future ... done
[10:59:33.615] plan(): Setting new future strategy stack:
[10:59:33.615] run() for ‘MulticoreFuture’ ... done
[10:59:33.615] Created future:
[10:59:33.615] List of future strategies:
[10:59:33.615] 1. sequential:
[10:59:33.615]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.615]    - tweaked: FALSE
[10:59:33.615]    - call: NULL
[10:59:33.617] plan(): nbrOfWorkers() = 1
[10:59:33.620] plan(): Setting new future strategy stack:
[10:59:33.620] List of future strategies:
[10:59:33.620] 1. multicore:
[10:59:33.620]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.620]    - tweaked: FALSE
[10:59:33.620]    - call: plan(strategy)
[10:59:33.625] plan(): nbrOfWorkers() = 2
[10:59:33.616] MulticoreFuture:
[10:59:33.616] Label: ‘future_mapply-1’
[10:59:33.616] Expression:
[10:59:33.616] {
[10:59:33.616]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.616]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.616]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.616]         on.exit(options(oopts), add = TRUE)
[10:59:33.616]     }
[10:59:33.616]     {
[10:59:33.616]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.616]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.616]         do.call(mapply, args = args)
[10:59:33.616]     }
[10:59:33.616] }
[10:59:33.616] Lazy evaluation: FALSE
[10:59:33.616] Asynchronous evaluation: TRUE
[10:59:33.616] Local evaluation: TRUE
[10:59:33.616] Environment: R_GlobalEnv
[10:59:33.616] Capture standard output: TRUE
[10:59:33.616] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.616] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.616] Packages: <none>
[10:59:33.616] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.616] Resolved: TRUE
[10:59:33.616] Value: <not collected>
[10:59:33.616] Conditions captured: <none>
[10:59:33.616] Early signaling: FALSE
[10:59:33.616] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.616] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.626] Chunk #1 of 2 ... DONE
[10:59:33.626] Chunk #2 of 2 ...
[10:59:33.627]  - Finding globals in '...' for chunk #2 ...
[10:59:33.627] getGlobalsAndPackages() ...
[10:59:33.627] Searching for globals...
[10:59:33.628] 
[10:59:33.628] Searching for globals ... DONE
[10:59:33.628] - globals: [0] <none>
[10:59:33.628] getGlobalsAndPackages() ... DONE
[10:59:33.629]    + additional globals found: [n=0] 
[10:59:33.629]    + additional namespaces needed: [n=0] 
[10:59:33.629]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.629]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.629]  - seeds: <none>
[10:59:33.629]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.630] getGlobalsAndPackages() ...
[10:59:33.630] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.630] Resolving globals: FALSE
[10:59:33.631] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:33.632] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.632] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.632] 
[10:59:33.633] getGlobalsAndPackages() ... DONE
[10:59:33.633] run() for ‘Future’ ...
[10:59:33.633] - state: ‘created’
[10:59:33.634] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.637] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.637]   - Field: ‘label’
[10:59:33.637]   - Field: ‘local’
[10:59:33.637]   - Field: ‘owner’
[10:59:33.637]   - Field: ‘envir’
[10:59:33.638]   - Field: ‘workers’
[10:59:33.638]   - Field: ‘packages’
[10:59:33.638]   - Field: ‘gc’
[10:59:33.638]   - Field: ‘job’
[10:59:33.638]   - Field: ‘conditions’
[10:59:33.638]   - Field: ‘expr’
[10:59:33.638]   - Field: ‘uuid’
[10:59:33.639]   - Field: ‘seed’
[10:59:33.639]   - Field: ‘version’
[10:59:33.639]   - Field: ‘result’
[10:59:33.639]   - Field: ‘asynchronous’
[10:59:33.639]   - Field: ‘calls’
[10:59:33.639]   - Field: ‘globals’
[10:59:33.639]   - Field: ‘stdout’
[10:59:33.639]   - Field: ‘earlySignal’
[10:59:33.640]   - Field: ‘lazy’
[10:59:33.640]   - Field: ‘state’
[10:59:33.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.640] - Launch lazy future ...
[10:59:33.640] Packages needed by the future expression (n = 0): <none>
[10:59:33.640] Packages needed by future strategies (n = 0): <none>
[10:59:33.641] {
[10:59:33.641]     {
[10:59:33.641]         {
[10:59:33.641]             ...future.startTime <- base::Sys.time()
[10:59:33.641]             {
[10:59:33.641]                 {
[10:59:33.641]                   {
[10:59:33.641]                     {
[10:59:33.641]                       base::local({
[10:59:33.641]                         has_future <- base::requireNamespace("future", 
[10:59:33.641]                           quietly = TRUE)
[10:59:33.641]                         if (has_future) {
[10:59:33.641]                           ns <- base::getNamespace("future")
[10:59:33.641]                           version <- ns[[".package"]][["version"]]
[10:59:33.641]                           if (is.null(version)) 
[10:59:33.641]                             version <- utils::packageVersion("future")
[10:59:33.641]                         }
[10:59:33.641]                         else {
[10:59:33.641]                           version <- NULL
[10:59:33.641]                         }
[10:59:33.641]                         if (!has_future || version < "1.8.0") {
[10:59:33.641]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.641]                             "", base::R.version$version.string), 
[10:59:33.641]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.641]                               "release", "version")], collapse = " "), 
[10:59:33.641]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.641]                             info)
[10:59:33.641]                           info <- base::paste(info, collapse = "; ")
[10:59:33.641]                           if (!has_future) {
[10:59:33.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.641]                               info)
[10:59:33.641]                           }
[10:59:33.641]                           else {
[10:59:33.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.641]                               info, version)
[10:59:33.641]                           }
[10:59:33.641]                           base::stop(msg)
[10:59:33.641]                         }
[10:59:33.641]                       })
[10:59:33.641]                     }
[10:59:33.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.641]                     base::options(mc.cores = 1L)
[10:59:33.641]                   }
[10:59:33.641]                   ...future.strategy.old <- future::plan("list")
[10:59:33.641]                   options(future.plan = NULL)
[10:59:33.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.641]                 }
[10:59:33.641]                 ...future.workdir <- getwd()
[10:59:33.641]             }
[10:59:33.641]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.641]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.641]         }
[10:59:33.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.641]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.641]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.641]             base::names(...future.oldOptions))
[10:59:33.641]     }
[10:59:33.641]     if (FALSE) {
[10:59:33.641]     }
[10:59:33.641]     else {
[10:59:33.641]         if (TRUE) {
[10:59:33.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.641]                 open = "w")
[10:59:33.641]         }
[10:59:33.641]         else {
[10:59:33.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.641]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.641]         }
[10:59:33.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.641]             base::sink(type = "output", split = FALSE)
[10:59:33.641]             base::close(...future.stdout)
[10:59:33.641]         }, add = TRUE)
[10:59:33.641]     }
[10:59:33.641]     ...future.frame <- base::sys.nframe()
[10:59:33.641]     ...future.conditions <- base::list()
[10:59:33.641]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.641]     if (FALSE) {
[10:59:33.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.641]     }
[10:59:33.641]     ...future.result <- base::tryCatch({
[10:59:33.641]         base::withCallingHandlers({
[10:59:33.641]             ...future.value <- base::withVisible(base::local({
[10:59:33.641]                 withCallingHandlers({
[10:59:33.641]                   {
[10:59:33.641]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.641]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.641]                       ...future.globals.maxSize)) {
[10:59:33.641]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.641]                       on.exit(options(oopts), add = TRUE)
[10:59:33.641]                     }
[10:59:33.641]                     {
[10:59:33.641]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.641]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.641]                         USE.NAMES = FALSE)
[10:59:33.641]                       do.call(mapply, args = args)
[10:59:33.641]                     }
[10:59:33.641]                   }
[10:59:33.641]                 }, immediateCondition = function(cond) {
[10:59:33.641]                   save_rds <- function (object, pathname, ...) 
[10:59:33.641]                   {
[10:59:33.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.641]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.641]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.641]                         fi_tmp[["mtime"]])
[10:59:33.641]                     }
[10:59:33.641]                     tryCatch({
[10:59:33.641]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.641]                     }, error = function(ex) {
[10:59:33.641]                       msg <- conditionMessage(ex)
[10:59:33.641]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.641]                         fi_tmp[["mtime"]], msg)
[10:59:33.641]                       ex$message <- msg
[10:59:33.641]                       stop(ex)
[10:59:33.641]                     })
[10:59:33.641]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.641]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.641]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.641]                       fi <- file.info(pathname)
[10:59:33.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.641]                         fi[["size"]], fi[["mtime"]])
[10:59:33.641]                       stop(msg)
[10:59:33.641]                     }
[10:59:33.641]                     invisible(pathname)
[10:59:33.641]                   }
[10:59:33.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.641]                     rootPath = tempdir()) 
[10:59:33.641]                   {
[10:59:33.641]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.641]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.641]                       tmpdir = path, fileext = ".rds")
[10:59:33.641]                     save_rds(obj, file)
[10:59:33.641]                   }
[10:59:33.641]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.641]                   {
[10:59:33.641]                     inherits <- base::inherits
[10:59:33.641]                     invokeRestart <- base::invokeRestart
[10:59:33.641]                     is.null <- base::is.null
[10:59:33.641]                     muffled <- FALSE
[10:59:33.641]                     if (inherits(cond, "message")) {
[10:59:33.641]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.641]                       if (muffled) 
[10:59:33.641]                         invokeRestart("muffleMessage")
[10:59:33.641]                     }
[10:59:33.641]                     else if (inherits(cond, "warning")) {
[10:59:33.641]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.641]                       if (muffled) 
[10:59:33.641]                         invokeRestart("muffleWarning")
[10:59:33.641]                     }
[10:59:33.641]                     else if (inherits(cond, "condition")) {
[10:59:33.641]                       if (!is.null(pattern)) {
[10:59:33.641]                         computeRestarts <- base::computeRestarts
[10:59:33.641]                         grepl <- base::grepl
[10:59:33.641]                         restarts <- computeRestarts(cond)
[10:59:33.641]                         for (restart in restarts) {
[10:59:33.641]                           name <- restart$name
[10:59:33.641]                           if (is.null(name)) 
[10:59:33.641]                             next
[10:59:33.641]                           if (!grepl(pattern, name)) 
[10:59:33.641]                             next
[10:59:33.641]                           invokeRestart(restart)
[10:59:33.641]                           muffled <- TRUE
[10:59:33.641]                           break
[10:59:33.641]                         }
[10:59:33.641]                       }
[10:59:33.641]                     }
[10:59:33.641]                     invisible(muffled)
[10:59:33.641]                   }
[10:59:33.641]                   muffleCondition(cond)
[10:59:33.641]                 })
[10:59:33.641]             }))
[10:59:33.641]             future::FutureResult(value = ...future.value$value, 
[10:59:33.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.641]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.641]                     ...future.globalenv.names))
[10:59:33.641]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.641]         }, condition = base::local({
[10:59:33.641]             c <- base::c
[10:59:33.641]             inherits <- base::inherits
[10:59:33.641]             invokeRestart <- base::invokeRestart
[10:59:33.641]             length <- base::length
[10:59:33.641]             list <- base::list
[10:59:33.641]             seq.int <- base::seq.int
[10:59:33.641]             signalCondition <- base::signalCondition
[10:59:33.641]             sys.calls <- base::sys.calls
[10:59:33.641]             `[[` <- base::`[[`
[10:59:33.641]             `+` <- base::`+`
[10:59:33.641]             `<<-` <- base::`<<-`
[10:59:33.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.641]                   3L)]
[10:59:33.641]             }
[10:59:33.641]             function(cond) {
[10:59:33.641]                 is_error <- inherits(cond, "error")
[10:59:33.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.641]                   NULL)
[10:59:33.641]                 if (is_error) {
[10:59:33.641]                   sessionInformation <- function() {
[10:59:33.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.641]                       search = base::search(), system = base::Sys.info())
[10:59:33.641]                   }
[10:59:33.641]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.641]                     cond$call), session = sessionInformation(), 
[10:59:33.641]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.641]                   signalCondition(cond)
[10:59:33.641]                 }
[10:59:33.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.641]                 "immediateCondition"))) {
[10:59:33.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.641]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.641]                   if (TRUE && !signal) {
[10:59:33.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.641]                     {
[10:59:33.641]                       inherits <- base::inherits
[10:59:33.641]                       invokeRestart <- base::invokeRestart
[10:59:33.641]                       is.null <- base::is.null
[10:59:33.641]                       muffled <- FALSE
[10:59:33.641]                       if (inherits(cond, "message")) {
[10:59:33.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.641]                         if (muffled) 
[10:59:33.641]                           invokeRestart("muffleMessage")
[10:59:33.641]                       }
[10:59:33.641]                       else if (inherits(cond, "warning")) {
[10:59:33.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.641]                         if (muffled) 
[10:59:33.641]                           invokeRestart("muffleWarning")
[10:59:33.641]                       }
[10:59:33.641]                       else if (inherits(cond, "condition")) {
[10:59:33.641]                         if (!is.null(pattern)) {
[10:59:33.641]                           computeRestarts <- base::computeRestarts
[10:59:33.641]                           grepl <- base::grepl
[10:59:33.641]                           restarts <- computeRestarts(cond)
[10:59:33.641]                           for (restart in restarts) {
[10:59:33.641]                             name <- restart$name
[10:59:33.641]                             if (is.null(name)) 
[10:59:33.641]                               next
[10:59:33.641]                             if (!grepl(pattern, name)) 
[10:59:33.641]                               next
[10:59:33.641]                             invokeRestart(restart)
[10:59:33.641]                             muffled <- TRUE
[10:59:33.641]                             break
[10:59:33.641]                           }
[10:59:33.641]                         }
[10:59:33.641]                       }
[10:59:33.641]                       invisible(muffled)
[10:59:33.641]                     }
[10:59:33.641]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.641]                   }
[10:59:33.641]                 }
[10:59:33.641]                 else {
[10:59:33.641]                   if (TRUE) {
[10:59:33.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.641]                     {
[10:59:33.641]                       inherits <- base::inherits
[10:59:33.641]                       invokeRestart <- base::invokeRestart
[10:59:33.641]                       is.null <- base::is.null
[10:59:33.641]                       muffled <- FALSE
[10:59:33.641]                       if (inherits(cond, "message")) {
[10:59:33.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.641]                         if (muffled) 
[10:59:33.641]                           invokeRestart("muffleMessage")
[10:59:33.641]                       }
[10:59:33.641]                       else if (inherits(cond, "warning")) {
[10:59:33.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.641]                         if (muffled) 
[10:59:33.641]                           invokeRestart("muffleWarning")
[10:59:33.641]                       }
[10:59:33.641]                       else if (inherits(cond, "condition")) {
[10:59:33.641]                         if (!is.null(pattern)) {
[10:59:33.641]                           computeRestarts <- base::computeRestarts
[10:59:33.641]                           grepl <- base::grepl
[10:59:33.641]                           restarts <- computeRestarts(cond)
[10:59:33.641]                           for (restart in restarts) {
[10:59:33.641]                             name <- restart$name
[10:59:33.641]                             if (is.null(name)) 
[10:59:33.641]                               next
[10:59:33.641]                             if (!grepl(pattern, name)) 
[10:59:33.641]                               next
[10:59:33.641]                             invokeRestart(restart)
[10:59:33.641]                             muffled <- TRUE
[10:59:33.641]                             break
[10:59:33.641]                           }
[10:59:33.641]                         }
[10:59:33.641]                       }
[10:59:33.641]                       invisible(muffled)
[10:59:33.641]                     }
[10:59:33.641]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.641]                   }
[10:59:33.641]                 }
[10:59:33.641]             }
[10:59:33.641]         }))
[10:59:33.641]     }, error = function(ex) {
[10:59:33.641]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.641]                 ...future.rng), started = ...future.startTime, 
[10:59:33.641]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.641]             version = "1.8"), class = "FutureResult")
[10:59:33.641]     }, finally = {
[10:59:33.641]         if (!identical(...future.workdir, getwd())) 
[10:59:33.641]             setwd(...future.workdir)
[10:59:33.641]         {
[10:59:33.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.641]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.641]             }
[10:59:33.641]             base::options(...future.oldOptions)
[10:59:33.641]             if (.Platform$OS.type == "windows") {
[10:59:33.641]                 old_names <- names(...future.oldEnvVars)
[10:59:33.641]                 envs <- base::Sys.getenv()
[10:59:33.641]                 names <- names(envs)
[10:59:33.641]                 common <- intersect(names, old_names)
[10:59:33.641]                 added <- setdiff(names, old_names)
[10:59:33.641]                 removed <- setdiff(old_names, names)
[10:59:33.641]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.641]                   envs[common]]
[10:59:33.641]                 NAMES <- toupper(changed)
[10:59:33.641]                 args <- list()
[10:59:33.641]                 for (kk in seq_along(NAMES)) {
[10:59:33.641]                   name <- changed[[kk]]
[10:59:33.641]                   NAME <- NAMES[[kk]]
[10:59:33.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.641]                     next
[10:59:33.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.641]                 }
[10:59:33.641]                 NAMES <- toupper(added)
[10:59:33.641]                 for (kk in seq_along(NAMES)) {
[10:59:33.641]                   name <- added[[kk]]
[10:59:33.641]                   NAME <- NAMES[[kk]]
[10:59:33.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.641]                     next
[10:59:33.641]                   args[[name]] <- ""
[10:59:33.641]                 }
[10:59:33.641]                 NAMES <- toupper(removed)
[10:59:33.641]                 for (kk in seq_along(NAMES)) {
[10:59:33.641]                   name <- removed[[kk]]
[10:59:33.641]                   NAME <- NAMES[[kk]]
[10:59:33.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.641]                     next
[10:59:33.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.641]                 }
[10:59:33.641]                 if (length(args) > 0) 
[10:59:33.641]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.641]             }
[10:59:33.641]             else {
[10:59:33.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.641]             }
[10:59:33.641]             {
[10:59:33.641]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.641]                   0L) {
[10:59:33.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.641]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.641]                   base::options(opts)
[10:59:33.641]                 }
[10:59:33.641]                 {
[10:59:33.641]                   {
[10:59:33.641]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.641]                     NULL
[10:59:33.641]                   }
[10:59:33.641]                   options(future.plan = NULL)
[10:59:33.641]                   if (is.na(NA_character_)) 
[10:59:33.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.641]                     .init = FALSE)
[10:59:33.641]                 }
[10:59:33.641]             }
[10:59:33.641]         }
[10:59:33.641]     })
[10:59:33.641]     if (TRUE) {
[10:59:33.641]         base::sink(type = "output", split = FALSE)
[10:59:33.641]         if (TRUE) {
[10:59:33.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.641]         }
[10:59:33.641]         else {
[10:59:33.641]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.641]         }
[10:59:33.641]         base::close(...future.stdout)
[10:59:33.641]         ...future.stdout <- NULL
[10:59:33.641]     }
[10:59:33.641]     ...future.result$conditions <- ...future.conditions
[10:59:33.641]     ...future.result$finished <- base::Sys.time()
[10:59:33.641]     ...future.result
[10:59:33.641] }
[10:59:33.645] assign_globals() ...
[10:59:33.645] List of 5
[10:59:33.645]  $ ...future.FUN            :function (x, ...)  
[10:59:33.645]  $ MoreArgs                 : NULL
[10:59:33.645]  $ ...future.elements_ii    :List of 2
[10:59:33.645]   ..$ :List of 2
[10:59:33.645]   .. ..$ : int 3
[10:59:33.645]   .. ..$ : int 4
[10:59:33.645]   ..$ :List of 2
[10:59:33.645]   .. ..$ : int 2
[10:59:33.645]   .. ..$ : int 1
[10:59:33.645]  $ ...future.seeds_ii       : NULL
[10:59:33.645]  $ ...future.globals.maxSize: NULL
[10:59:33.645]  - attr(*, "where")=List of 5
[10:59:33.645]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.645]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.645]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.645]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.645]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.645]  - attr(*, "resolved")= logi FALSE
[10:59:33.645]  - attr(*, "total_size")= num 210
[10:59:33.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.645]  - attr(*, "already-done")= logi TRUE
[10:59:33.651] - copied ‘...future.FUN’ to environment
[10:59:33.651] - copied ‘MoreArgs’ to environment
[10:59:33.652] - copied ‘...future.elements_ii’ to environment
[10:59:33.652] - copied ‘...future.seeds_ii’ to environment
[10:59:33.652] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.652] assign_globals() ... done
[10:59:33.652] requestCore(): workers = 2
[10:59:33.654] MulticoreFuture started
[10:59:33.655] - Launch lazy future ... done
[10:59:33.655] run() for ‘MulticoreFuture’ ... done
[10:59:33.655] Created future:
[10:59:33.655] plan(): Setting new future strategy stack:
[10:59:33.655] List of future strategies:
[10:59:33.655] 1. sequential:
[10:59:33.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.655]    - tweaked: FALSE
[10:59:33.655]    - call: NULL
[10:59:33.711] plan(): nbrOfWorkers() = 1
[10:59:33.712] plan(): Setting new future strategy stack:
[10:59:33.712] List of future strategies:
[10:59:33.712] 1. multicore:
[10:59:33.712]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.712]    - tweaked: FALSE
[10:59:33.712]    - call: plan(strategy)
[10:59:33.714] plan(): nbrOfWorkers() = 2
[10:59:33.655] MulticoreFuture:
[10:59:33.655] Label: ‘future_mapply-2’
[10:59:33.655] Expression:
[10:59:33.655] {
[10:59:33.655]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.655]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.655]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.655]         on.exit(options(oopts), add = TRUE)
[10:59:33.655]     }
[10:59:33.655]     {
[10:59:33.655]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.655]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.655]         do.call(mapply, args = args)
[10:59:33.655]     }
[10:59:33.655] }
[10:59:33.655] Lazy evaluation: FALSE
[10:59:33.655] Asynchronous evaluation: TRUE
[10:59:33.655] Local evaluation: TRUE
[10:59:33.655] Environment: R_GlobalEnv
[10:59:33.655] Capture standard output: TRUE
[10:59:33.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.655] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.655] Packages: <none>
[10:59:33.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.655] Resolved: TRUE
[10:59:33.655] Value: <not collected>
[10:59:33.655] Conditions captured: <none>
[10:59:33.655] Early signaling: FALSE
[10:59:33.655] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.655] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.714] Chunk #2 of 2 ... DONE
[10:59:33.715] Launching 2 futures (chunks) ... DONE
[10:59:33.715] Resolving 2 futures (chunks) ...
[10:59:33.715] resolve() on list ...
[10:59:33.715]  recursive: 0
[10:59:33.715]  length: 2
[10:59:33.715] 
[10:59:33.715] Future #1
[10:59:33.715] result() for MulticoreFuture ...
[10:59:33.716] result() for MulticoreFuture ...
[10:59:33.716] result() for MulticoreFuture ... done
[10:59:33.716] result() for MulticoreFuture ... done
[10:59:33.716] result() for MulticoreFuture ...
[10:59:33.716] result() for MulticoreFuture ... done
[10:59:33.716] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.716] - nx: 2
[10:59:33.717] - relay: TRUE
[10:59:33.717] - stdout: TRUE
[10:59:33.717] - signal: TRUE
[10:59:33.717] - resignal: FALSE
[10:59:33.717] - force: TRUE
[10:59:33.717] - relayed: [n=2] FALSE, FALSE
[10:59:33.717] - queued futures: [n=2] FALSE, FALSE
[10:59:33.717]  - until=1
[10:59:33.717]  - relaying element #1
[10:59:33.717] result() for MulticoreFuture ...
[10:59:33.717] result() for MulticoreFuture ... done
[10:59:33.717] result() for MulticoreFuture ...
[10:59:33.718] result() for MulticoreFuture ... done
[10:59:33.718] result() for MulticoreFuture ...
[10:59:33.718] result() for MulticoreFuture ... done
[10:59:33.718] result() for MulticoreFuture ...
[10:59:33.718] result() for MulticoreFuture ... done
[10:59:33.718] - relayed: [n=2] TRUE, FALSE
[10:59:33.718] - queued futures: [n=2] TRUE, FALSE
[10:59:33.718] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.718]  length: 1 (resolved future 1)
[10:59:33.718] Future #2
[10:59:33.719] result() for MulticoreFuture ...
[10:59:33.719] result() for MulticoreFuture ...
[10:59:33.719] result() for MulticoreFuture ... done
[10:59:33.719] result() for MulticoreFuture ... done
[10:59:33.719] result() for MulticoreFuture ...
[10:59:33.719] result() for MulticoreFuture ... done
[10:59:33.719] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.720] - nx: 2
[10:59:33.720] - relay: TRUE
[10:59:33.720] - stdout: TRUE
[10:59:33.720] - signal: TRUE
[10:59:33.720] - resignal: FALSE
[10:59:33.720] - force: TRUE
[10:59:33.720] - relayed: [n=2] TRUE, FALSE
[10:59:33.720] - queued futures: [n=2] TRUE, FALSE
[10:59:33.720]  - until=2
[10:59:33.720]  - relaying element #2
[10:59:33.720] result() for MulticoreFuture ...
[10:59:33.720] result() for MulticoreFuture ... done
[10:59:33.720] result() for MulticoreFuture ...
[10:59:33.721] result() for MulticoreFuture ... done
[10:59:33.721] result() for MulticoreFuture ...
[10:59:33.721] result() for MulticoreFuture ... done
[10:59:33.721] result() for MulticoreFuture ...
[10:59:33.721] result() for MulticoreFuture ... done
[10:59:33.721] - relayed: [n=2] TRUE, TRUE
[10:59:33.721] - queued futures: [n=2] TRUE, TRUE
[10:59:33.721] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.721]  length: 0 (resolved future 2)
[10:59:33.721] Relaying remaining futures
[10:59:33.721] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.722] - nx: 2
[10:59:33.722] - relay: TRUE
[10:59:33.722] - stdout: TRUE
[10:59:33.722] - signal: TRUE
[10:59:33.722] - resignal: FALSE
[10:59:33.722] - force: TRUE
[10:59:33.722] - relayed: [n=2] TRUE, TRUE
[10:59:33.722] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.722] - relayed: [n=2] TRUE, TRUE
[10:59:33.722] - queued futures: [n=2] TRUE, TRUE
[10:59:33.722] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.722] resolve() on list ... DONE
[10:59:33.722] result() for MulticoreFuture ...
[10:59:33.723] result() for MulticoreFuture ... done
[10:59:33.723] result() for MulticoreFuture ...
[10:59:33.723] result() for MulticoreFuture ... done
[10:59:33.723] result() for MulticoreFuture ...
[10:59:33.723] result() for MulticoreFuture ... done
[10:59:33.723] result() for MulticoreFuture ...
[10:59:33.723] result() for MulticoreFuture ... done
[10:59:33.723]  - Number of value chunks collected: 2
[10:59:33.723] Resolving 2 futures (chunks) ... DONE
[10:59:33.723] Reducing values from 2 chunks ...
[10:59:33.723]  - Number of values collected after concatenation: 4
[10:59:33.723]  - Number of values expected: 4
[10:59:33.724] Reducing values from 2 chunks ... DONE
[10:59:33.724] future_mapply() ... DONE
- Parallel RNG ...
[10:59:33.724] future_mapply() ...
[10:59:33.724] Generating random seeds ...
[10:59:33.724] Generating random seed streams for 4 elements ...
[10:59:33.724] Generating random seed streams for 4 elements ... DONE
[10:59:33.724] Generating random seeds ... DONE
[10:59:33.724] Will set RNG state on exit: 10407, -1456079852, -2009151602, 277396721, -1577885622, 1565923760, -189897170
[10:59:33.726] Number of chunks: 2
[10:59:33.726] getGlobalsAndPackagesXApply() ...
[10:59:33.726]  - future.globals: TRUE
[10:59:33.726] getGlobalsAndPackages() ...
[10:59:33.726] Searching for globals...
[10:59:33.728] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:59:33.728] Searching for globals ... DONE
[10:59:33.728] Resolving globals: FALSE
[10:59:33.728] The total size of the 1 globals is 501 bytes (501 bytes)
[10:59:33.729] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:59:33.729] - globals: [1] ‘FUN’
[10:59:33.729] - packages: [1] ‘stats’
[10:59:33.729] getGlobalsAndPackages() ... DONE
[10:59:33.729]  - globals found/used: [n=1] ‘FUN’
[10:59:33.729]  - needed namespaces: [n=1] ‘stats’
[10:59:33.729] Finding globals ... DONE
[10:59:33.729] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.730] List of 2
[10:59:33.730]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:59:33.730]  $ MoreArgs     :List of 1
[10:59:33.730]   ..$ min: num 1
[10:59:33.730]  - attr(*, "where")=List of 2
[10:59:33.730]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.730]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.730]  - attr(*, "resolved")= logi FALSE
[10:59:33.730]  - attr(*, "total_size")= num NA
[10:59:33.732] Packages to be attached in all futures: [n=1] ‘stats’
[10:59:33.732] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.733] Number of futures (= number of chunks): 2
[10:59:33.733] Launching 2 futures (chunks) ...
[10:59:33.733] Chunk #1 of 2 ...
[10:59:33.733]  - Finding globals in '...' for chunk #1 ...
[10:59:33.733] getGlobalsAndPackages() ...
[10:59:33.733] Searching for globals...
[10:59:33.733] 
[10:59:33.733] Searching for globals ... DONE
[10:59:33.734] - globals: [0] <none>
[10:59:33.734] getGlobalsAndPackages() ... DONE
[10:59:33.734]    + additional globals found: [n=0] 
[10:59:33.734]    + additional namespaces needed: [n=0] 
[10:59:33.734]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.734]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.734]  - seeds: [2] <seeds>
[10:59:33.734]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.734] getGlobalsAndPackages() ...
[10:59:33.734] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.734] Resolving globals: FALSE
[10:59:33.735] The total size of the 5 globals is 870 bytes (870 bytes)
[10:59:33.735] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:59:33.736] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.736] - packages: [1] ‘stats’
[10:59:33.736] getGlobalsAndPackages() ... DONE
[10:59:33.736] run() for ‘Future’ ...
[10:59:33.736] - state: ‘created’
[10:59:33.736] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.738] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.738]   - Field: ‘label’
[10:59:33.738]   - Field: ‘local’
[10:59:33.738]   - Field: ‘owner’
[10:59:33.738]   - Field: ‘envir’
[10:59:33.739]   - Field: ‘workers’
[10:59:33.739]   - Field: ‘packages’
[10:59:33.739]   - Field: ‘gc’
[10:59:33.739]   - Field: ‘job’
[10:59:33.739]   - Field: ‘conditions’
[10:59:33.739]   - Field: ‘expr’
[10:59:33.739]   - Field: ‘uuid’
[10:59:33.739]   - Field: ‘seed’
[10:59:33.739]   - Field: ‘version’
[10:59:33.739]   - Field: ‘result’
[10:59:33.739]   - Field: ‘asynchronous’
[10:59:33.739]   - Field: ‘calls’
[10:59:33.740]   - Field: ‘globals’
[10:59:33.740]   - Field: ‘stdout’
[10:59:33.740]   - Field: ‘earlySignal’
[10:59:33.740]   - Field: ‘lazy’
[10:59:33.740]   - Field: ‘state’
[10:59:33.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.740] - Launch lazy future ...
[10:59:33.740] Packages needed by the future expression (n = 1): ‘stats’
[10:59:33.740] Packages needed by future strategies (n = 0): <none>
[10:59:33.741] {
[10:59:33.741]     {
[10:59:33.741]         {
[10:59:33.741]             ...future.startTime <- base::Sys.time()
[10:59:33.741]             {
[10:59:33.741]                 {
[10:59:33.741]                   {
[10:59:33.741]                     {
[10:59:33.741]                       {
[10:59:33.741]                         base::local({
[10:59:33.741]                           has_future <- base::requireNamespace("future", 
[10:59:33.741]                             quietly = TRUE)
[10:59:33.741]                           if (has_future) {
[10:59:33.741]                             ns <- base::getNamespace("future")
[10:59:33.741]                             version <- ns[[".package"]][["version"]]
[10:59:33.741]                             if (is.null(version)) 
[10:59:33.741]                               version <- utils::packageVersion("future")
[10:59:33.741]                           }
[10:59:33.741]                           else {
[10:59:33.741]                             version <- NULL
[10:59:33.741]                           }
[10:59:33.741]                           if (!has_future || version < "1.8.0") {
[10:59:33.741]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.741]                               "", base::R.version$version.string), 
[10:59:33.741]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:33.741]                                 base::R.version$platform, 8 * 
[10:59:33.741]                                   base::.Machine$sizeof.pointer), 
[10:59:33.741]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.741]                                 "release", "version")], collapse = " "), 
[10:59:33.741]                               hostname = base::Sys.info()[["nodename"]])
[10:59:33.741]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.741]                               info)
[10:59:33.741]                             info <- base::paste(info, collapse = "; ")
[10:59:33.741]                             if (!has_future) {
[10:59:33.741]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.741]                                 info)
[10:59:33.741]                             }
[10:59:33.741]                             else {
[10:59:33.741]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.741]                                 info, version)
[10:59:33.741]                             }
[10:59:33.741]                             base::stop(msg)
[10:59:33.741]                           }
[10:59:33.741]                         })
[10:59:33.741]                       }
[10:59:33.741]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.741]                       base::options(mc.cores = 1L)
[10:59:33.741]                     }
[10:59:33.741]                     base::local({
[10:59:33.741]                       for (pkg in "stats") {
[10:59:33.741]                         base::loadNamespace(pkg)
[10:59:33.741]                         base::library(pkg, character.only = TRUE)
[10:59:33.741]                       }
[10:59:33.741]                     })
[10:59:33.741]                   }
[10:59:33.741]                   ...future.strategy.old <- future::plan("list")
[10:59:33.741]                   options(future.plan = NULL)
[10:59:33.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.741]                 }
[10:59:33.741]                 ...future.workdir <- getwd()
[10:59:33.741]             }
[10:59:33.741]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.741]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.741]         }
[10:59:33.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.741]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.741]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.741]             base::names(...future.oldOptions))
[10:59:33.741]     }
[10:59:33.741]     if (FALSE) {
[10:59:33.741]     }
[10:59:33.741]     else {
[10:59:33.741]         if (TRUE) {
[10:59:33.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.741]                 open = "w")
[10:59:33.741]         }
[10:59:33.741]         else {
[10:59:33.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.741]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.741]         }
[10:59:33.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.741]             base::sink(type = "output", split = FALSE)
[10:59:33.741]             base::close(...future.stdout)
[10:59:33.741]         }, add = TRUE)
[10:59:33.741]     }
[10:59:33.741]     ...future.frame <- base::sys.nframe()
[10:59:33.741]     ...future.conditions <- base::list()
[10:59:33.741]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.741]     if (FALSE) {
[10:59:33.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.741]     }
[10:59:33.741]     ...future.result <- base::tryCatch({
[10:59:33.741]         base::withCallingHandlers({
[10:59:33.741]             ...future.value <- base::withVisible(base::local({
[10:59:33.741]                 withCallingHandlers({
[10:59:33.741]                   {
[10:59:33.741]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.741]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.741]                       ...future.globals.maxSize)) {
[10:59:33.741]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.741]                       on.exit(options(oopts), add = TRUE)
[10:59:33.741]                     }
[10:59:33.741]                     {
[10:59:33.741]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.741]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:33.741]                           envir = globalenv(), inherits = FALSE)
[10:59:33.741]                         ...future.FUN(...)
[10:59:33.741]                       }
[10:59:33.741]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.741]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.741]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.741]                         USE.NAMES = FALSE)
[10:59:33.741]                       do.call(mapply, args = args)
[10:59:33.741]                     }
[10:59:33.741]                   }
[10:59:33.741]                 }, immediateCondition = function(cond) {
[10:59:33.741]                   save_rds <- function (object, pathname, ...) 
[10:59:33.741]                   {
[10:59:33.741]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.741]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.741]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.741]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.741]                         fi_tmp[["mtime"]])
[10:59:33.741]                     }
[10:59:33.741]                     tryCatch({
[10:59:33.741]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.741]                     }, error = function(ex) {
[10:59:33.741]                       msg <- conditionMessage(ex)
[10:59:33.741]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.741]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.741]                         fi_tmp[["mtime"]], msg)
[10:59:33.741]                       ex$message <- msg
[10:59:33.741]                       stop(ex)
[10:59:33.741]                     })
[10:59:33.741]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.741]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.741]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.741]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.741]                       fi <- file.info(pathname)
[10:59:33.741]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.741]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.741]                         fi[["size"]], fi[["mtime"]])
[10:59:33.741]                       stop(msg)
[10:59:33.741]                     }
[10:59:33.741]                     invisible(pathname)
[10:59:33.741]                   }
[10:59:33.741]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.741]                     rootPath = tempdir()) 
[10:59:33.741]                   {
[10:59:33.741]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.741]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.741]                       tmpdir = path, fileext = ".rds")
[10:59:33.741]                     save_rds(obj, file)
[10:59:33.741]                   }
[10:59:33.741]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.741]                   {
[10:59:33.741]                     inherits <- base::inherits
[10:59:33.741]                     invokeRestart <- base::invokeRestart
[10:59:33.741]                     is.null <- base::is.null
[10:59:33.741]                     muffled <- FALSE
[10:59:33.741]                     if (inherits(cond, "message")) {
[10:59:33.741]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.741]                       if (muffled) 
[10:59:33.741]                         invokeRestart("muffleMessage")
[10:59:33.741]                     }
[10:59:33.741]                     else if (inherits(cond, "warning")) {
[10:59:33.741]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.741]                       if (muffled) 
[10:59:33.741]                         invokeRestart("muffleWarning")
[10:59:33.741]                     }
[10:59:33.741]                     else if (inherits(cond, "condition")) {
[10:59:33.741]                       if (!is.null(pattern)) {
[10:59:33.741]                         computeRestarts <- base::computeRestarts
[10:59:33.741]                         grepl <- base::grepl
[10:59:33.741]                         restarts <- computeRestarts(cond)
[10:59:33.741]                         for (restart in restarts) {
[10:59:33.741]                           name <- restart$name
[10:59:33.741]                           if (is.null(name)) 
[10:59:33.741]                             next
[10:59:33.741]                           if (!grepl(pattern, name)) 
[10:59:33.741]                             next
[10:59:33.741]                           invokeRestart(restart)
[10:59:33.741]                           muffled <- TRUE
[10:59:33.741]                           break
[10:59:33.741]                         }
[10:59:33.741]                       }
[10:59:33.741]                     }
[10:59:33.741]                     invisible(muffled)
[10:59:33.741]                   }
[10:59:33.741]                   muffleCondition(cond)
[10:59:33.741]                 })
[10:59:33.741]             }))
[10:59:33.741]             future::FutureResult(value = ...future.value$value, 
[10:59:33.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.741]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.741]                     ...future.globalenv.names))
[10:59:33.741]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.741]         }, condition = base::local({
[10:59:33.741]             c <- base::c
[10:59:33.741]             inherits <- base::inherits
[10:59:33.741]             invokeRestart <- base::invokeRestart
[10:59:33.741]             length <- base::length
[10:59:33.741]             list <- base::list
[10:59:33.741]             seq.int <- base::seq.int
[10:59:33.741]             signalCondition <- base::signalCondition
[10:59:33.741]             sys.calls <- base::sys.calls
[10:59:33.741]             `[[` <- base::`[[`
[10:59:33.741]             `+` <- base::`+`
[10:59:33.741]             `<<-` <- base::`<<-`
[10:59:33.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.741]                   3L)]
[10:59:33.741]             }
[10:59:33.741]             function(cond) {
[10:59:33.741]                 is_error <- inherits(cond, "error")
[10:59:33.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.741]                   NULL)
[10:59:33.741]                 if (is_error) {
[10:59:33.741]                   sessionInformation <- function() {
[10:59:33.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.741]                       search = base::search(), system = base::Sys.info())
[10:59:33.741]                   }
[10:59:33.741]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.741]                     cond$call), session = sessionInformation(), 
[10:59:33.741]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.741]                   signalCondition(cond)
[10:59:33.741]                 }
[10:59:33.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.741]                 "immediateCondition"))) {
[10:59:33.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.741]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.741]                   if (TRUE && !signal) {
[10:59:33.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.741]                     {
[10:59:33.741]                       inherits <- base::inherits
[10:59:33.741]                       invokeRestart <- base::invokeRestart
[10:59:33.741]                       is.null <- base::is.null
[10:59:33.741]                       muffled <- FALSE
[10:59:33.741]                       if (inherits(cond, "message")) {
[10:59:33.741]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.741]                         if (muffled) 
[10:59:33.741]                           invokeRestart("muffleMessage")
[10:59:33.741]                       }
[10:59:33.741]                       else if (inherits(cond, "warning")) {
[10:59:33.741]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.741]                         if (muffled) 
[10:59:33.741]                           invokeRestart("muffleWarning")
[10:59:33.741]                       }
[10:59:33.741]                       else if (inherits(cond, "condition")) {
[10:59:33.741]                         if (!is.null(pattern)) {
[10:59:33.741]                           computeRestarts <- base::computeRestarts
[10:59:33.741]                           grepl <- base::grepl
[10:59:33.741]                           restarts <- computeRestarts(cond)
[10:59:33.741]                           for (restart in restarts) {
[10:59:33.741]                             name <- restart$name
[10:59:33.741]                             if (is.null(name)) 
[10:59:33.741]                               next
[10:59:33.741]                             if (!grepl(pattern, name)) 
[10:59:33.741]                               next
[10:59:33.741]                             invokeRestart(restart)
[10:59:33.741]                             muffled <- TRUE
[10:59:33.741]                             break
[10:59:33.741]                           }
[10:59:33.741]                         }
[10:59:33.741]                       }
[10:59:33.741]                       invisible(muffled)
[10:59:33.741]                     }
[10:59:33.741]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.741]                   }
[10:59:33.741]                 }
[10:59:33.741]                 else {
[10:59:33.741]                   if (TRUE) {
[10:59:33.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.741]                     {
[10:59:33.741]                       inherits <- base::inherits
[10:59:33.741]                       invokeRestart <- base::invokeRestart
[10:59:33.741]                       is.null <- base::is.null
[10:59:33.741]                       muffled <- FALSE
[10:59:33.741]                       if (inherits(cond, "message")) {
[10:59:33.741]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.741]                         if (muffled) 
[10:59:33.741]                           invokeRestart("muffleMessage")
[10:59:33.741]                       }
[10:59:33.741]                       else if (inherits(cond, "warning")) {
[10:59:33.741]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.741]                         if (muffled) 
[10:59:33.741]                           invokeRestart("muffleWarning")
[10:59:33.741]                       }
[10:59:33.741]                       else if (inherits(cond, "condition")) {
[10:59:33.741]                         if (!is.null(pattern)) {
[10:59:33.741]                           computeRestarts <- base::computeRestarts
[10:59:33.741]                           grepl <- base::grepl
[10:59:33.741]                           restarts <- computeRestarts(cond)
[10:59:33.741]                           for (restart in restarts) {
[10:59:33.741]                             name <- restart$name
[10:59:33.741]                             if (is.null(name)) 
[10:59:33.741]                               next
[10:59:33.741]                             if (!grepl(pattern, name)) 
[10:59:33.741]                               next
[10:59:33.741]                             invokeRestart(restart)
[10:59:33.741]                             muffled <- TRUE
[10:59:33.741]                             break
[10:59:33.741]                           }
[10:59:33.741]                         }
[10:59:33.741]                       }
[10:59:33.741]                       invisible(muffled)
[10:59:33.741]                     }
[10:59:33.741]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.741]                   }
[10:59:33.741]                 }
[10:59:33.741]             }
[10:59:33.741]         }))
[10:59:33.741]     }, error = function(ex) {
[10:59:33.741]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.741]                 ...future.rng), started = ...future.startTime, 
[10:59:33.741]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.741]             version = "1.8"), class = "FutureResult")
[10:59:33.741]     }, finally = {
[10:59:33.741]         if (!identical(...future.workdir, getwd())) 
[10:59:33.741]             setwd(...future.workdir)
[10:59:33.741]         {
[10:59:33.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.741]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.741]             }
[10:59:33.741]             base::options(...future.oldOptions)
[10:59:33.741]             if (.Platform$OS.type == "windows") {
[10:59:33.741]                 old_names <- names(...future.oldEnvVars)
[10:59:33.741]                 envs <- base::Sys.getenv()
[10:59:33.741]                 names <- names(envs)
[10:59:33.741]                 common <- intersect(names, old_names)
[10:59:33.741]                 added <- setdiff(names, old_names)
[10:59:33.741]                 removed <- setdiff(old_names, names)
[10:59:33.741]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.741]                   envs[common]]
[10:59:33.741]                 NAMES <- toupper(changed)
[10:59:33.741]                 args <- list()
[10:59:33.741]                 for (kk in seq_along(NAMES)) {
[10:59:33.741]                   name <- changed[[kk]]
[10:59:33.741]                   NAME <- NAMES[[kk]]
[10:59:33.741]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.741]                     next
[10:59:33.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.741]                 }
[10:59:33.741]                 NAMES <- toupper(added)
[10:59:33.741]                 for (kk in seq_along(NAMES)) {
[10:59:33.741]                   name <- added[[kk]]
[10:59:33.741]                   NAME <- NAMES[[kk]]
[10:59:33.741]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.741]                     next
[10:59:33.741]                   args[[name]] <- ""
[10:59:33.741]                 }
[10:59:33.741]                 NAMES <- toupper(removed)
[10:59:33.741]                 for (kk in seq_along(NAMES)) {
[10:59:33.741]                   name <- removed[[kk]]
[10:59:33.741]                   NAME <- NAMES[[kk]]
[10:59:33.741]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.741]                     next
[10:59:33.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.741]                 }
[10:59:33.741]                 if (length(args) > 0) 
[10:59:33.741]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.741]             }
[10:59:33.741]             else {
[10:59:33.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.741]             }
[10:59:33.741]             {
[10:59:33.741]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.741]                   0L) {
[10:59:33.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.741]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.741]                   base::options(opts)
[10:59:33.741]                 }
[10:59:33.741]                 {
[10:59:33.741]                   {
[10:59:33.741]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.741]                     NULL
[10:59:33.741]                   }
[10:59:33.741]                   options(future.plan = NULL)
[10:59:33.741]                   if (is.na(NA_character_)) 
[10:59:33.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.741]                     .init = FALSE)
[10:59:33.741]                 }
[10:59:33.741]             }
[10:59:33.741]         }
[10:59:33.741]     })
[10:59:33.741]     if (TRUE) {
[10:59:33.741]         base::sink(type = "output", split = FALSE)
[10:59:33.741]         if (TRUE) {
[10:59:33.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.741]         }
[10:59:33.741]         else {
[10:59:33.741]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.741]         }
[10:59:33.741]         base::close(...future.stdout)
[10:59:33.741]         ...future.stdout <- NULL
[10:59:33.741]     }
[10:59:33.741]     ...future.result$conditions <- ...future.conditions
[10:59:33.741]     ...future.result$finished <- base::Sys.time()
[10:59:33.741]     ...future.result
[10:59:33.741] }
[10:59:33.743] assign_globals() ...
[10:59:33.743] List of 5
[10:59:33.743]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:59:33.743]  $ MoreArgs                 :List of 1
[10:59:33.743]   ..$ min: num 1
[10:59:33.743]  $ ...future.elements_ii    :List of 2
[10:59:33.743]   ..$ n  :List of 2
[10:59:33.743]   .. ..$ : int 1
[10:59:33.743]   .. ..$ : int 2
[10:59:33.743]   ..$ max:List of 2
[10:59:33.743]   .. ..$ : int 2
[10:59:33.743]   .. ..$ : int 3
[10:59:33.743]  $ ...future.seeds_ii       :List of 2
[10:59:33.743]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:59:33.743]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:59:33.743]  $ ...future.globals.maxSize: NULL
[10:59:33.743]  - attr(*, "where")=List of 5
[10:59:33.743]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.743]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.743]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.743]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.743]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.743]  - attr(*, "resolved")= logi FALSE
[10:59:33.743]  - attr(*, "total_size")= num 870
[10:59:33.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.743]  - attr(*, "already-done")= logi TRUE
[10:59:33.750] - copied ‘...future.FUN’ to environment
[10:59:33.750] - copied ‘MoreArgs’ to environment
[10:59:33.750] - copied ‘...future.elements_ii’ to environment
[10:59:33.751] - copied ‘...future.seeds_ii’ to environment
[10:59:33.751] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.751] assign_globals() ... done
[10:59:33.751] requestCore(): workers = 2
[10:59:33.753] MulticoreFuture started
[10:59:33.753] - Launch lazy future ... done
[10:59:33.753] run() for ‘MulticoreFuture’ ... done
[10:59:33.754] Created future:
[10:59:33.754] plan(): Setting new future strategy stack:
[10:59:33.755] List of future strategies:
[10:59:33.755] 1. sequential:
[10:59:33.755]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.755]    - tweaked: FALSE
[10:59:33.755]    - call: NULL
[10:59:33.755] plan(): nbrOfWorkers() = 1
[10:59:33.758] plan(): Setting new future strategy stack:
[10:59:33.758] List of future strategies:
[10:59:33.758] 1. multicore:
[10:59:33.758]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.758]    - tweaked: FALSE
[10:59:33.758]    - call: plan(strategy)
[10:59:33.761] plan(): nbrOfWorkers() = 2
[10:59:33.754] MulticoreFuture:
[10:59:33.754] Label: ‘future_mapply-1’
[10:59:33.754] Expression:
[10:59:33.754] {
[10:59:33.754]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.754]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.754]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.754]         on.exit(options(oopts), add = TRUE)
[10:59:33.754]     }
[10:59:33.754]     {
[10:59:33.754]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.754]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:33.754]                 inherits = FALSE)
[10:59:33.754]             ...future.FUN(...)
[10:59:33.754]         }
[10:59:33.754]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.754]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.754]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.754]         do.call(mapply, args = args)
[10:59:33.754]     }
[10:59:33.754] }
[10:59:33.754] Lazy evaluation: FALSE
[10:59:33.754] Asynchronous evaluation: TRUE
[10:59:33.754] Local evaluation: TRUE
[10:59:33.754] Environment: R_GlobalEnv
[10:59:33.754] Capture standard output: TRUE
[10:59:33.754] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.754] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.754] Packages: 1 packages (‘stats’)
[10:59:33.754] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:33.754] Resolved: TRUE
[10:59:33.754] Value: <not collected>
[10:59:33.754] Conditions captured: <none>
[10:59:33.754] Early signaling: FALSE
[10:59:33.754] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.754] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.762] Chunk #1 of 2 ... DONE
[10:59:33.762] Chunk #2 of 2 ...
[10:59:33.762]  - Finding globals in '...' for chunk #2 ...
[10:59:33.762] getGlobalsAndPackages() ...
[10:59:33.762] Searching for globals...
[10:59:33.763] 
[10:59:33.763] Searching for globals ... DONE
[10:59:33.763] - globals: [0] <none>
[10:59:33.763] getGlobalsAndPackages() ... DONE
[10:59:33.763]    + additional globals found: [n=0] 
[10:59:33.763]    + additional namespaces needed: [n=0] 
[10:59:33.763]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.763]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.764]  - seeds: [2] <seeds>
[10:59:33.764]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.764] getGlobalsAndPackages() ...
[10:59:33.764] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.764] Resolving globals: FALSE
[10:59:33.765] The total size of the 5 globals is 870 bytes (870 bytes)
[10:59:33.766] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:59:33.766] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.766] - packages: [1] ‘stats’
[10:59:33.766] getGlobalsAndPackages() ... DONE
[10:59:33.766] run() for ‘Future’ ...
[10:59:33.767] - state: ‘created’
[10:59:33.767] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.769] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.769]   - Field: ‘label’
[10:59:33.769]   - Field: ‘local’
[10:59:33.770]   - Field: ‘owner’
[10:59:33.770]   - Field: ‘envir’
[10:59:33.770]   - Field: ‘workers’
[10:59:33.770]   - Field: ‘packages’
[10:59:33.770]   - Field: ‘gc’
[10:59:33.770]   - Field: ‘job’
[10:59:33.770]   - Field: ‘conditions’
[10:59:33.770]   - Field: ‘expr’
[10:59:33.771]   - Field: ‘uuid’
[10:59:33.771]   - Field: ‘seed’
[10:59:33.771]   - Field: ‘version’
[10:59:33.771]   - Field: ‘result’
[10:59:33.771]   - Field: ‘asynchronous’
[10:59:33.771]   - Field: ‘calls’
[10:59:33.771]   - Field: ‘globals’
[10:59:33.771]   - Field: ‘stdout’
[10:59:33.771]   - Field: ‘earlySignal’
[10:59:33.772]   - Field: ‘lazy’
[10:59:33.772]   - Field: ‘state’
[10:59:33.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.772] - Launch lazy future ...
[10:59:33.772] Packages needed by the future expression (n = 1): ‘stats’
[10:59:33.772] Packages needed by future strategies (n = 0): <none>
[10:59:33.773] {
[10:59:33.773]     {
[10:59:33.773]         {
[10:59:33.773]             ...future.startTime <- base::Sys.time()
[10:59:33.773]             {
[10:59:33.773]                 {
[10:59:33.773]                   {
[10:59:33.773]                     {
[10:59:33.773]                       {
[10:59:33.773]                         base::local({
[10:59:33.773]                           has_future <- base::requireNamespace("future", 
[10:59:33.773]                             quietly = TRUE)
[10:59:33.773]                           if (has_future) {
[10:59:33.773]                             ns <- base::getNamespace("future")
[10:59:33.773]                             version <- ns[[".package"]][["version"]]
[10:59:33.773]                             if (is.null(version)) 
[10:59:33.773]                               version <- utils::packageVersion("future")
[10:59:33.773]                           }
[10:59:33.773]                           else {
[10:59:33.773]                             version <- NULL
[10:59:33.773]                           }
[10:59:33.773]                           if (!has_future || version < "1.8.0") {
[10:59:33.773]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.773]                               "", base::R.version$version.string), 
[10:59:33.773]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:33.773]                                 base::R.version$platform, 8 * 
[10:59:33.773]                                   base::.Machine$sizeof.pointer), 
[10:59:33.773]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.773]                                 "release", "version")], collapse = " "), 
[10:59:33.773]                               hostname = base::Sys.info()[["nodename"]])
[10:59:33.773]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.773]                               info)
[10:59:33.773]                             info <- base::paste(info, collapse = "; ")
[10:59:33.773]                             if (!has_future) {
[10:59:33.773]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.773]                                 info)
[10:59:33.773]                             }
[10:59:33.773]                             else {
[10:59:33.773]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.773]                                 info, version)
[10:59:33.773]                             }
[10:59:33.773]                             base::stop(msg)
[10:59:33.773]                           }
[10:59:33.773]                         })
[10:59:33.773]                       }
[10:59:33.773]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.773]                       base::options(mc.cores = 1L)
[10:59:33.773]                     }
[10:59:33.773]                     base::local({
[10:59:33.773]                       for (pkg in "stats") {
[10:59:33.773]                         base::loadNamespace(pkg)
[10:59:33.773]                         base::library(pkg, character.only = TRUE)
[10:59:33.773]                       }
[10:59:33.773]                     })
[10:59:33.773]                   }
[10:59:33.773]                   ...future.strategy.old <- future::plan("list")
[10:59:33.773]                   options(future.plan = NULL)
[10:59:33.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.773]                 }
[10:59:33.773]                 ...future.workdir <- getwd()
[10:59:33.773]             }
[10:59:33.773]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.773]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.773]         }
[10:59:33.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.773]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.773]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.773]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.773]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.773]             base::names(...future.oldOptions))
[10:59:33.773]     }
[10:59:33.773]     if (FALSE) {
[10:59:33.773]     }
[10:59:33.773]     else {
[10:59:33.773]         if (TRUE) {
[10:59:33.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.773]                 open = "w")
[10:59:33.773]         }
[10:59:33.773]         else {
[10:59:33.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.773]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.773]         }
[10:59:33.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.773]             base::sink(type = "output", split = FALSE)
[10:59:33.773]             base::close(...future.stdout)
[10:59:33.773]         }, add = TRUE)
[10:59:33.773]     }
[10:59:33.773]     ...future.frame <- base::sys.nframe()
[10:59:33.773]     ...future.conditions <- base::list()
[10:59:33.773]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.773]     if (FALSE) {
[10:59:33.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.773]     }
[10:59:33.773]     ...future.result <- base::tryCatch({
[10:59:33.773]         base::withCallingHandlers({
[10:59:33.773]             ...future.value <- base::withVisible(base::local({
[10:59:33.773]                 withCallingHandlers({
[10:59:33.773]                   {
[10:59:33.773]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.773]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.773]                       ...future.globals.maxSize)) {
[10:59:33.773]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.773]                       on.exit(options(oopts), add = TRUE)
[10:59:33.773]                     }
[10:59:33.773]                     {
[10:59:33.773]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.773]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:33.773]                           envir = globalenv(), inherits = FALSE)
[10:59:33.773]                         ...future.FUN(...)
[10:59:33.773]                       }
[10:59:33.773]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.773]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.773]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.773]                         USE.NAMES = FALSE)
[10:59:33.773]                       do.call(mapply, args = args)
[10:59:33.773]                     }
[10:59:33.773]                   }
[10:59:33.773]                 }, immediateCondition = function(cond) {
[10:59:33.773]                   save_rds <- function (object, pathname, ...) 
[10:59:33.773]                   {
[10:59:33.773]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.773]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.773]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.773]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.773]                         fi_tmp[["mtime"]])
[10:59:33.773]                     }
[10:59:33.773]                     tryCatch({
[10:59:33.773]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.773]                     }, error = function(ex) {
[10:59:33.773]                       msg <- conditionMessage(ex)
[10:59:33.773]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.773]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.773]                         fi_tmp[["mtime"]], msg)
[10:59:33.773]                       ex$message <- msg
[10:59:33.773]                       stop(ex)
[10:59:33.773]                     })
[10:59:33.773]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.773]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.773]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.773]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.773]                       fi <- file.info(pathname)
[10:59:33.773]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.773]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.773]                         fi[["size"]], fi[["mtime"]])
[10:59:33.773]                       stop(msg)
[10:59:33.773]                     }
[10:59:33.773]                     invisible(pathname)
[10:59:33.773]                   }
[10:59:33.773]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.773]                     rootPath = tempdir()) 
[10:59:33.773]                   {
[10:59:33.773]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.773]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.773]                       tmpdir = path, fileext = ".rds")
[10:59:33.773]                     save_rds(obj, file)
[10:59:33.773]                   }
[10:59:33.773]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.773]                   {
[10:59:33.773]                     inherits <- base::inherits
[10:59:33.773]                     invokeRestart <- base::invokeRestart
[10:59:33.773]                     is.null <- base::is.null
[10:59:33.773]                     muffled <- FALSE
[10:59:33.773]                     if (inherits(cond, "message")) {
[10:59:33.773]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.773]                       if (muffled) 
[10:59:33.773]                         invokeRestart("muffleMessage")
[10:59:33.773]                     }
[10:59:33.773]                     else if (inherits(cond, "warning")) {
[10:59:33.773]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.773]                       if (muffled) 
[10:59:33.773]                         invokeRestart("muffleWarning")
[10:59:33.773]                     }
[10:59:33.773]                     else if (inherits(cond, "condition")) {
[10:59:33.773]                       if (!is.null(pattern)) {
[10:59:33.773]                         computeRestarts <- base::computeRestarts
[10:59:33.773]                         grepl <- base::grepl
[10:59:33.773]                         restarts <- computeRestarts(cond)
[10:59:33.773]                         for (restart in restarts) {
[10:59:33.773]                           name <- restart$name
[10:59:33.773]                           if (is.null(name)) 
[10:59:33.773]                             next
[10:59:33.773]                           if (!grepl(pattern, name)) 
[10:59:33.773]                             next
[10:59:33.773]                           invokeRestart(restart)
[10:59:33.773]                           muffled <- TRUE
[10:59:33.773]                           break
[10:59:33.773]                         }
[10:59:33.773]                       }
[10:59:33.773]                     }
[10:59:33.773]                     invisible(muffled)
[10:59:33.773]                   }
[10:59:33.773]                   muffleCondition(cond)
[10:59:33.773]                 })
[10:59:33.773]             }))
[10:59:33.773]             future::FutureResult(value = ...future.value$value, 
[10:59:33.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.773]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.773]                     ...future.globalenv.names))
[10:59:33.773]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.773]         }, condition = base::local({
[10:59:33.773]             c <- base::c
[10:59:33.773]             inherits <- base::inherits
[10:59:33.773]             invokeRestart <- base::invokeRestart
[10:59:33.773]             length <- base::length
[10:59:33.773]             list <- base::list
[10:59:33.773]             seq.int <- base::seq.int
[10:59:33.773]             signalCondition <- base::signalCondition
[10:59:33.773]             sys.calls <- base::sys.calls
[10:59:33.773]             `[[` <- base::`[[`
[10:59:33.773]             `+` <- base::`+`
[10:59:33.773]             `<<-` <- base::`<<-`
[10:59:33.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.773]                   3L)]
[10:59:33.773]             }
[10:59:33.773]             function(cond) {
[10:59:33.773]                 is_error <- inherits(cond, "error")
[10:59:33.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.773]                   NULL)
[10:59:33.773]                 if (is_error) {
[10:59:33.773]                   sessionInformation <- function() {
[10:59:33.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.773]                       search = base::search(), system = base::Sys.info())
[10:59:33.773]                   }
[10:59:33.773]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.773]                     cond$call), session = sessionInformation(), 
[10:59:33.773]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.773]                   signalCondition(cond)
[10:59:33.773]                 }
[10:59:33.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.773]                 "immediateCondition"))) {
[10:59:33.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.773]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.773]                   if (TRUE && !signal) {
[10:59:33.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.773]                     {
[10:59:33.773]                       inherits <- base::inherits
[10:59:33.773]                       invokeRestart <- base::invokeRestart
[10:59:33.773]                       is.null <- base::is.null
[10:59:33.773]                       muffled <- FALSE
[10:59:33.773]                       if (inherits(cond, "message")) {
[10:59:33.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.773]                         if (muffled) 
[10:59:33.773]                           invokeRestart("muffleMessage")
[10:59:33.773]                       }
[10:59:33.773]                       else if (inherits(cond, "warning")) {
[10:59:33.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.773]                         if (muffled) 
[10:59:33.773]                           invokeRestart("muffleWarning")
[10:59:33.773]                       }
[10:59:33.773]                       else if (inherits(cond, "condition")) {
[10:59:33.773]                         if (!is.null(pattern)) {
[10:59:33.773]                           computeRestarts <- base::computeRestarts
[10:59:33.773]                           grepl <- base::grepl
[10:59:33.773]                           restarts <- computeRestarts(cond)
[10:59:33.773]                           for (restart in restarts) {
[10:59:33.773]                             name <- restart$name
[10:59:33.773]                             if (is.null(name)) 
[10:59:33.773]                               next
[10:59:33.773]                             if (!grepl(pattern, name)) 
[10:59:33.773]                               next
[10:59:33.773]                             invokeRestart(restart)
[10:59:33.773]                             muffled <- TRUE
[10:59:33.773]                             break
[10:59:33.773]                           }
[10:59:33.773]                         }
[10:59:33.773]                       }
[10:59:33.773]                       invisible(muffled)
[10:59:33.773]                     }
[10:59:33.773]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.773]                   }
[10:59:33.773]                 }
[10:59:33.773]                 else {
[10:59:33.773]                   if (TRUE) {
[10:59:33.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.773]                     {
[10:59:33.773]                       inherits <- base::inherits
[10:59:33.773]                       invokeRestart <- base::invokeRestart
[10:59:33.773]                       is.null <- base::is.null
[10:59:33.773]                       muffled <- FALSE
[10:59:33.773]                       if (inherits(cond, "message")) {
[10:59:33.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.773]                         if (muffled) 
[10:59:33.773]                           invokeRestart("muffleMessage")
[10:59:33.773]                       }
[10:59:33.773]                       else if (inherits(cond, "warning")) {
[10:59:33.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.773]                         if (muffled) 
[10:59:33.773]                           invokeRestart("muffleWarning")
[10:59:33.773]                       }
[10:59:33.773]                       else if (inherits(cond, "condition")) {
[10:59:33.773]                         if (!is.null(pattern)) {
[10:59:33.773]                           computeRestarts <- base::computeRestarts
[10:59:33.773]                           grepl <- base::grepl
[10:59:33.773]                           restarts <- computeRestarts(cond)
[10:59:33.773]                           for (restart in restarts) {
[10:59:33.773]                             name <- restart$name
[10:59:33.773]                             if (is.null(name)) 
[10:59:33.773]                               next
[10:59:33.773]                             if (!grepl(pattern, name)) 
[10:59:33.773]                               next
[10:59:33.773]                             invokeRestart(restart)
[10:59:33.773]                             muffled <- TRUE
[10:59:33.773]                             break
[10:59:33.773]                           }
[10:59:33.773]                         }
[10:59:33.773]                       }
[10:59:33.773]                       invisible(muffled)
[10:59:33.773]                     }
[10:59:33.773]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.773]                   }
[10:59:33.773]                 }
[10:59:33.773]             }
[10:59:33.773]         }))
[10:59:33.773]     }, error = function(ex) {
[10:59:33.773]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.773]                 ...future.rng), started = ...future.startTime, 
[10:59:33.773]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.773]             version = "1.8"), class = "FutureResult")
[10:59:33.773]     }, finally = {
[10:59:33.773]         if (!identical(...future.workdir, getwd())) 
[10:59:33.773]             setwd(...future.workdir)
[10:59:33.773]         {
[10:59:33.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.773]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.773]             }
[10:59:33.773]             base::options(...future.oldOptions)
[10:59:33.773]             if (.Platform$OS.type == "windows") {
[10:59:33.773]                 old_names <- names(...future.oldEnvVars)
[10:59:33.773]                 envs <- base::Sys.getenv()
[10:59:33.773]                 names <- names(envs)
[10:59:33.773]                 common <- intersect(names, old_names)
[10:59:33.773]                 added <- setdiff(names, old_names)
[10:59:33.773]                 removed <- setdiff(old_names, names)
[10:59:33.773]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.773]                   envs[common]]
[10:59:33.773]                 NAMES <- toupper(changed)
[10:59:33.773]                 args <- list()
[10:59:33.773]                 for (kk in seq_along(NAMES)) {
[10:59:33.773]                   name <- changed[[kk]]
[10:59:33.773]                   NAME <- NAMES[[kk]]
[10:59:33.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.773]                     next
[10:59:33.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.773]                 }
[10:59:33.773]                 NAMES <- toupper(added)
[10:59:33.773]                 for (kk in seq_along(NAMES)) {
[10:59:33.773]                   name <- added[[kk]]
[10:59:33.773]                   NAME <- NAMES[[kk]]
[10:59:33.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.773]                     next
[10:59:33.773]                   args[[name]] <- ""
[10:59:33.773]                 }
[10:59:33.773]                 NAMES <- toupper(removed)
[10:59:33.773]                 for (kk in seq_along(NAMES)) {
[10:59:33.773]                   name <- removed[[kk]]
[10:59:33.773]                   NAME <- NAMES[[kk]]
[10:59:33.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.773]                     next
[10:59:33.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.773]                 }
[10:59:33.773]                 if (length(args) > 0) 
[10:59:33.773]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.773]             }
[10:59:33.773]             else {
[10:59:33.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.773]             }
[10:59:33.773]             {
[10:59:33.773]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.773]                   0L) {
[10:59:33.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.773]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.773]                   base::options(opts)
[10:59:33.773]                 }
[10:59:33.773]                 {
[10:59:33.773]                   {
[10:59:33.773]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.773]                     NULL
[10:59:33.773]                   }
[10:59:33.773]                   options(future.plan = NULL)
[10:59:33.773]                   if (is.na(NA_character_)) 
[10:59:33.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.773]                     .init = FALSE)
[10:59:33.773]                 }
[10:59:33.773]             }
[10:59:33.773]         }
[10:59:33.773]     })
[10:59:33.773]     if (TRUE) {
[10:59:33.773]         base::sink(type = "output", split = FALSE)
[10:59:33.773]         if (TRUE) {
[10:59:33.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.773]         }
[10:59:33.773]         else {
[10:59:33.773]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.773]         }
[10:59:33.773]         base::close(...future.stdout)
[10:59:33.773]         ...future.stdout <- NULL
[10:59:33.773]     }
[10:59:33.773]     ...future.result$conditions <- ...future.conditions
[10:59:33.773]     ...future.result$finished <- base::Sys.time()
[10:59:33.773]     ...future.result
[10:59:33.773] }
[10:59:33.777] assign_globals() ...
[10:59:33.777] List of 5
[10:59:33.777]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:59:33.777]  $ MoreArgs                 :List of 1
[10:59:33.777]   ..$ min: num 1
[10:59:33.777]  $ ...future.elements_ii    :List of 2
[10:59:33.777]   ..$ n  :List of 2
[10:59:33.777]   .. ..$ : int 3
[10:59:33.777]   .. ..$ : int 4
[10:59:33.777]   ..$ max:List of 2
[10:59:33.777]   .. ..$ : int 4
[10:59:33.777]   .. ..$ : int 5
[10:59:33.777]  $ ...future.seeds_ii       :List of 2
[10:59:33.777]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:59:33.777]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:59:33.777]  $ ...future.globals.maxSize: NULL
[10:59:33.777]  - attr(*, "where")=List of 5
[10:59:33.777]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.777]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.777]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.777]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.777]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.777]  - attr(*, "resolved")= logi FALSE
[10:59:33.777]  - attr(*, "total_size")= num 870
[10:59:33.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.777]  - attr(*, "already-done")= logi TRUE
[10:59:33.785] - copied ‘...future.FUN’ to environment
[10:59:33.786] - copied ‘MoreArgs’ to environment
[10:59:33.786] - copied ‘...future.elements_ii’ to environment
[10:59:33.786] - copied ‘...future.seeds_ii’ to environment
[10:59:33.786] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.786] assign_globals() ... done
[10:59:33.786] requestCore(): workers = 2
[10:59:33.788] MulticoreFuture started
[10:59:33.789] - Launch lazy future ... done
[10:59:33.789] run() for ‘MulticoreFuture’ ... done
[10:59:33.789] Created future:
[10:59:33.790] plan(): Setting new future strategy stack:
[10:59:33.790] List of future strategies:
[10:59:33.790] 1. sequential:
[10:59:33.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.790]    - tweaked: FALSE
[10:59:33.790]    - call: NULL
[10:59:33.791] plan(): nbrOfWorkers() = 1
[10:59:33.793] plan(): Setting new future strategy stack:
[10:59:33.793] List of future strategies:
[10:59:33.793] 1. multicore:
[10:59:33.793]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.793]    - tweaked: FALSE
[10:59:33.793]    - call: plan(strategy)
[10:59:33.796] plan(): nbrOfWorkers() = 2
[10:59:33.789] MulticoreFuture:
[10:59:33.789] Label: ‘future_mapply-2’
[10:59:33.789] Expression:
[10:59:33.789] {
[10:59:33.789]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.789]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.789]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.789]         on.exit(options(oopts), add = TRUE)
[10:59:33.789]     }
[10:59:33.789]     {
[10:59:33.789]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:33.789]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:33.789]                 inherits = FALSE)
[10:59:33.789]             ...future.FUN(...)
[10:59:33.789]         }
[10:59:33.789]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:33.789]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:33.789]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.789]         do.call(mapply, args = args)
[10:59:33.789]     }
[10:59:33.789] }
[10:59:33.789] Lazy evaluation: FALSE
[10:59:33.789] Asynchronous evaluation: TRUE
[10:59:33.789] Local evaluation: TRUE
[10:59:33.789] Environment: R_GlobalEnv
[10:59:33.789] Capture standard output: TRUE
[10:59:33.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.789] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.789] Packages: 1 packages (‘stats’)
[10:59:33.789] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:33.789] Resolved: TRUE
[10:59:33.789] Value: <not collected>
[10:59:33.789] Conditions captured: <none>
[10:59:33.789] Early signaling: FALSE
[10:59:33.789] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.789] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.797] Chunk #2 of 2 ... DONE
[10:59:33.797] Launching 2 futures (chunks) ... DONE
[10:59:33.797] Resolving 2 futures (chunks) ...
[10:59:33.797] resolve() on list ...
[10:59:33.797]  recursive: 0
[10:59:33.798]  length: 2
[10:59:33.798] 
[10:59:33.798] Future #1
[10:59:33.798] result() for MulticoreFuture ...
[10:59:33.799] result() for MulticoreFuture ...
[10:59:33.799] result() for MulticoreFuture ... done
[10:59:33.799] result() for MulticoreFuture ... done
[10:59:33.799] result() for MulticoreFuture ...
[10:59:33.800] result() for MulticoreFuture ... done
[10:59:33.800] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.800] - nx: 2
[10:59:33.800] - relay: TRUE
[10:59:33.800] - stdout: TRUE
[10:59:33.800] - signal: TRUE
[10:59:33.800] - resignal: FALSE
[10:59:33.800] - force: TRUE
[10:59:33.801] - relayed: [n=2] FALSE, FALSE
[10:59:33.801] - queued futures: [n=2] FALSE, FALSE
[10:59:33.801]  - until=1
[10:59:33.801]  - relaying element #1
[10:59:33.801] result() for MulticoreFuture ...
[10:59:33.801] result() for MulticoreFuture ... done
[10:59:33.801] result() for MulticoreFuture ...
[10:59:33.801] result() for MulticoreFuture ... done
[10:59:33.802] result() for MulticoreFuture ...
[10:59:33.802] result() for MulticoreFuture ... done
[10:59:33.802] result() for MulticoreFuture ...
[10:59:33.802] result() for MulticoreFuture ... done
[10:59:33.802] - relayed: [n=2] TRUE, FALSE
[10:59:33.802] - queued futures: [n=2] TRUE, FALSE
[10:59:33.802] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.802]  length: 1 (resolved future 1)
[10:59:33.803] Future #2
[10:59:33.803] result() for MulticoreFuture ...
[10:59:33.803] result() for MulticoreFuture ...
[10:59:33.804] result() for MulticoreFuture ... done
[10:59:33.804] result() for MulticoreFuture ... done
[10:59:33.804] result() for MulticoreFuture ...
[10:59:33.804] result() for MulticoreFuture ... done
[10:59:33.804] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.804] - nx: 2
[10:59:33.804] - relay: TRUE
[10:59:33.804] - stdout: TRUE
[10:59:33.804] - signal: TRUE
[10:59:33.805] - resignal: FALSE
[10:59:33.805] - force: TRUE
[10:59:33.805] - relayed: [n=2] TRUE, FALSE
[10:59:33.805] - queued futures: [n=2] TRUE, FALSE
[10:59:33.805]  - until=2
[10:59:33.805]  - relaying element #2
[10:59:33.805] result() for MulticoreFuture ...
[10:59:33.805] result() for MulticoreFuture ... done
[10:59:33.805] result() for MulticoreFuture ...
[10:59:33.806] result() for MulticoreFuture ... done
[10:59:33.806] result() for MulticoreFuture ...
[10:59:33.806] result() for MulticoreFuture ... done
[10:59:33.806] result() for MulticoreFuture ...
[10:59:33.806] result() for MulticoreFuture ... done
[10:59:33.806] - relayed: [n=2] TRUE, TRUE
[10:59:33.806] - queued futures: [n=2] TRUE, TRUE
[10:59:33.806] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.806]  length: 0 (resolved future 2)
[10:59:33.807] Relaying remaining futures
[10:59:33.807] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.807] - nx: 2
[10:59:33.807] - relay: TRUE
[10:59:33.807] - stdout: TRUE
[10:59:33.807] - signal: TRUE
[10:59:33.807] - resignal: FALSE
[10:59:33.807] - force: TRUE
[10:59:33.807] - relayed: [n=2] TRUE, TRUE
[10:59:33.807] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.808] - relayed: [n=2] TRUE, TRUE
[10:59:33.808] - queued futures: [n=2] TRUE, TRUE
[10:59:33.808] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.808] resolve() on list ... DONE
[10:59:33.808] result() for MulticoreFuture ...
[10:59:33.808] result() for MulticoreFuture ... done
[10:59:33.808] result() for MulticoreFuture ...
[10:59:33.808] result() for MulticoreFuture ... done
[10:59:33.809] result() for MulticoreFuture ...
[10:59:33.809] result() for MulticoreFuture ... done
[10:59:33.809] result() for MulticoreFuture ...
[10:59:33.809] result() for MulticoreFuture ... done
[10:59:33.809]  - Number of value chunks collected: 2
[10:59:33.809] Resolving 2 futures (chunks) ... DONE
[10:59:33.809] Reducing values from 2 chunks ...
[10:59:33.809]  - Number of values collected after concatenation: 4
[10:59:33.809]  - Number of values expected: 4
[10:59:33.810] Reducing values from 2 chunks ... DONE
[10:59:33.810] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:59:33.810] future_mapply() ...
[10:59:33.813] Number of chunks: 2
[10:59:33.813] getGlobalsAndPackagesXApply() ...
[10:59:33.813]  - future.globals: TRUE
[10:59:33.813] getGlobalsAndPackages() ...
[10:59:33.813] Searching for globals...
[10:59:33.815] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:59:33.815] Searching for globals ... DONE
[10:59:33.815] Resolving globals: FALSE
[10:59:33.816] The total size of the 1 globals is 337 bytes (337 bytes)
[10:59:33.816] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[10:59:33.816] - globals: [1] ‘FUN’
[10:59:33.816] - packages: [1] ‘stats’
[10:59:33.816] getGlobalsAndPackages() ... DONE
[10:59:33.816]  - globals found/used: [n=1] ‘FUN’
[10:59:33.817]  - needed namespaces: [n=1] ‘stats’
[10:59:33.817] Finding globals ... DONE
[10:59:33.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.817] List of 2
[10:59:33.817]  $ ...future.FUN:function (x, w, ...)  
[10:59:33.817]  $ MoreArgs     : NULL
[10:59:33.817]  - attr(*, "where")=List of 2
[10:59:33.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.817]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.817]  - attr(*, "resolved")= logi FALSE
[10:59:33.817]  - attr(*, "total_size")= num NA
[10:59:33.820] Packages to be attached in all futures: [n=1] ‘stats’
[10:59:33.820] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.821] Number of futures (= number of chunks): 2
[10:59:33.821] Launching 2 futures (chunks) ...
[10:59:33.821] Chunk #1 of 2 ...
[10:59:33.821]  - Finding globals in '...' for chunk #1 ...
[10:59:33.821] getGlobalsAndPackages() ...
[10:59:33.821] Searching for globals...
[10:59:33.822] 
[10:59:33.822] Searching for globals ... DONE
[10:59:33.822] - globals: [0] <none>
[10:59:33.822] getGlobalsAndPackages() ... DONE
[10:59:33.822]    + additional globals found: [n=0] 
[10:59:33.822]    + additional namespaces needed: [n=0] 
[10:59:33.822]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.822]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.823]  - seeds: <none>
[10:59:33.823]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.823] getGlobalsAndPackages() ...
[10:59:33.823] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.823] Resolving globals: FALSE
[10:59:33.823] The total size of the 5 globals is 817 bytes (817 bytes)
[10:59:33.826] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 817 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (399 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.826] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.827] - packages: [1] ‘stats’
[10:59:33.827] getGlobalsAndPackages() ... DONE
[10:59:33.827] run() for ‘Future’ ...
[10:59:33.827] - state: ‘created’
[10:59:33.827] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.829] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.829]   - Field: ‘label’
[10:59:33.829]   - Field: ‘local’
[10:59:33.830]   - Field: ‘owner’
[10:59:33.830]   - Field: ‘envir’
[10:59:33.830]   - Field: ‘workers’
[10:59:33.830]   - Field: ‘packages’
[10:59:33.830]   - Field: ‘gc’
[10:59:33.830]   - Field: ‘job’
[10:59:33.830]   - Field: ‘conditions’
[10:59:33.830]   - Field: ‘expr’
[10:59:33.830]   - Field: ‘uuid’
[10:59:33.830]   - Field: ‘seed’
[10:59:33.831]   - Field: ‘version’
[10:59:33.831]   - Field: ‘result’
[10:59:33.831]   - Field: ‘asynchronous’
[10:59:33.831]   - Field: ‘calls’
[10:59:33.831]   - Field: ‘globals’
[10:59:33.831]   - Field: ‘stdout’
[10:59:33.831]   - Field: ‘earlySignal’
[10:59:33.831]   - Field: ‘lazy’
[10:59:33.831]   - Field: ‘state’
[10:59:33.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.832] - Launch lazy future ...
[10:59:33.832] Packages needed by the future expression (n = 1): ‘stats’
[10:59:33.832] Packages needed by future strategies (n = 0): <none>
[10:59:33.833] {
[10:59:33.833]     {
[10:59:33.833]         {
[10:59:33.833]             ...future.startTime <- base::Sys.time()
[10:59:33.833]             {
[10:59:33.833]                 {
[10:59:33.833]                   {
[10:59:33.833]                     {
[10:59:33.833]                       {
[10:59:33.833]                         base::local({
[10:59:33.833]                           has_future <- base::requireNamespace("future", 
[10:59:33.833]                             quietly = TRUE)
[10:59:33.833]                           if (has_future) {
[10:59:33.833]                             ns <- base::getNamespace("future")
[10:59:33.833]                             version <- ns[[".package"]][["version"]]
[10:59:33.833]                             if (is.null(version)) 
[10:59:33.833]                               version <- utils::packageVersion("future")
[10:59:33.833]                           }
[10:59:33.833]                           else {
[10:59:33.833]                             version <- NULL
[10:59:33.833]                           }
[10:59:33.833]                           if (!has_future || version < "1.8.0") {
[10:59:33.833]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.833]                               "", base::R.version$version.string), 
[10:59:33.833]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:33.833]                                 base::R.version$platform, 8 * 
[10:59:33.833]                                   base::.Machine$sizeof.pointer), 
[10:59:33.833]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.833]                                 "release", "version")], collapse = " "), 
[10:59:33.833]                               hostname = base::Sys.info()[["nodename"]])
[10:59:33.833]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.833]                               info)
[10:59:33.833]                             info <- base::paste(info, collapse = "; ")
[10:59:33.833]                             if (!has_future) {
[10:59:33.833]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.833]                                 info)
[10:59:33.833]                             }
[10:59:33.833]                             else {
[10:59:33.833]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.833]                                 info, version)
[10:59:33.833]                             }
[10:59:33.833]                             base::stop(msg)
[10:59:33.833]                           }
[10:59:33.833]                         })
[10:59:33.833]                       }
[10:59:33.833]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.833]                       base::options(mc.cores = 1L)
[10:59:33.833]                     }
[10:59:33.833]                     base::local({
[10:59:33.833]                       for (pkg in "stats") {
[10:59:33.833]                         base::loadNamespace(pkg)
[10:59:33.833]                         base::library(pkg, character.only = TRUE)
[10:59:33.833]                       }
[10:59:33.833]                     })
[10:59:33.833]                   }
[10:59:33.833]                   ...future.strategy.old <- future::plan("list")
[10:59:33.833]                   options(future.plan = NULL)
[10:59:33.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.833]                 }
[10:59:33.833]                 ...future.workdir <- getwd()
[10:59:33.833]             }
[10:59:33.833]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.833]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.833]         }
[10:59:33.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.833]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.833]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.833]             base::names(...future.oldOptions))
[10:59:33.833]     }
[10:59:33.833]     if (FALSE) {
[10:59:33.833]     }
[10:59:33.833]     else {
[10:59:33.833]         if (TRUE) {
[10:59:33.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.833]                 open = "w")
[10:59:33.833]         }
[10:59:33.833]         else {
[10:59:33.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.833]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.833]         }
[10:59:33.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.833]             base::sink(type = "output", split = FALSE)
[10:59:33.833]             base::close(...future.stdout)
[10:59:33.833]         }, add = TRUE)
[10:59:33.833]     }
[10:59:33.833]     ...future.frame <- base::sys.nframe()
[10:59:33.833]     ...future.conditions <- base::list()
[10:59:33.833]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.833]     if (FALSE) {
[10:59:33.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.833]     }
[10:59:33.833]     ...future.result <- base::tryCatch({
[10:59:33.833]         base::withCallingHandlers({
[10:59:33.833]             ...future.value <- base::withVisible(base::local({
[10:59:33.833]                 withCallingHandlers({
[10:59:33.833]                   {
[10:59:33.833]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.833]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.833]                       ...future.globals.maxSize)) {
[10:59:33.833]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.833]                       on.exit(options(oopts), add = TRUE)
[10:59:33.833]                     }
[10:59:33.833]                     {
[10:59:33.833]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.833]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.833]                         USE.NAMES = FALSE)
[10:59:33.833]                       do.call(mapply, args = args)
[10:59:33.833]                     }
[10:59:33.833]                   }
[10:59:33.833]                 }, immediateCondition = function(cond) {
[10:59:33.833]                   save_rds <- function (object, pathname, ...) 
[10:59:33.833]                   {
[10:59:33.833]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.833]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.833]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.833]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.833]                         fi_tmp[["mtime"]])
[10:59:33.833]                     }
[10:59:33.833]                     tryCatch({
[10:59:33.833]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.833]                     }, error = function(ex) {
[10:59:33.833]                       msg <- conditionMessage(ex)
[10:59:33.833]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.833]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.833]                         fi_tmp[["mtime"]], msg)
[10:59:33.833]                       ex$message <- msg
[10:59:33.833]                       stop(ex)
[10:59:33.833]                     })
[10:59:33.833]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.833]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.833]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.833]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.833]                       fi <- file.info(pathname)
[10:59:33.833]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.833]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.833]                         fi[["size"]], fi[["mtime"]])
[10:59:33.833]                       stop(msg)
[10:59:33.833]                     }
[10:59:33.833]                     invisible(pathname)
[10:59:33.833]                   }
[10:59:33.833]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.833]                     rootPath = tempdir()) 
[10:59:33.833]                   {
[10:59:33.833]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.833]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.833]                       tmpdir = path, fileext = ".rds")
[10:59:33.833]                     save_rds(obj, file)
[10:59:33.833]                   }
[10:59:33.833]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.833]                   {
[10:59:33.833]                     inherits <- base::inherits
[10:59:33.833]                     invokeRestart <- base::invokeRestart
[10:59:33.833]                     is.null <- base::is.null
[10:59:33.833]                     muffled <- FALSE
[10:59:33.833]                     if (inherits(cond, "message")) {
[10:59:33.833]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.833]                       if (muffled) 
[10:59:33.833]                         invokeRestart("muffleMessage")
[10:59:33.833]                     }
[10:59:33.833]                     else if (inherits(cond, "warning")) {
[10:59:33.833]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.833]                       if (muffled) 
[10:59:33.833]                         invokeRestart("muffleWarning")
[10:59:33.833]                     }
[10:59:33.833]                     else if (inherits(cond, "condition")) {
[10:59:33.833]                       if (!is.null(pattern)) {
[10:59:33.833]                         computeRestarts <- base::computeRestarts
[10:59:33.833]                         grepl <- base::grepl
[10:59:33.833]                         restarts <- computeRestarts(cond)
[10:59:33.833]                         for (restart in restarts) {
[10:59:33.833]                           name <- restart$name
[10:59:33.833]                           if (is.null(name)) 
[10:59:33.833]                             next
[10:59:33.833]                           if (!grepl(pattern, name)) 
[10:59:33.833]                             next
[10:59:33.833]                           invokeRestart(restart)
[10:59:33.833]                           muffled <- TRUE
[10:59:33.833]                           break
[10:59:33.833]                         }
[10:59:33.833]                       }
[10:59:33.833]                     }
[10:59:33.833]                     invisible(muffled)
[10:59:33.833]                   }
[10:59:33.833]                   muffleCondition(cond)
[10:59:33.833]                 })
[10:59:33.833]             }))
[10:59:33.833]             future::FutureResult(value = ...future.value$value, 
[10:59:33.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.833]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.833]                     ...future.globalenv.names))
[10:59:33.833]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.833]         }, condition = base::local({
[10:59:33.833]             c <- base::c
[10:59:33.833]             inherits <- base::inherits
[10:59:33.833]             invokeRestart <- base::invokeRestart
[10:59:33.833]             length <- base::length
[10:59:33.833]             list <- base::list
[10:59:33.833]             seq.int <- base::seq.int
[10:59:33.833]             signalCondition <- base::signalCondition
[10:59:33.833]             sys.calls <- base::sys.calls
[10:59:33.833]             `[[` <- base::`[[`
[10:59:33.833]             `+` <- base::`+`
[10:59:33.833]             `<<-` <- base::`<<-`
[10:59:33.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.833]                   3L)]
[10:59:33.833]             }
[10:59:33.833]             function(cond) {
[10:59:33.833]                 is_error <- inherits(cond, "error")
[10:59:33.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.833]                   NULL)
[10:59:33.833]                 if (is_error) {
[10:59:33.833]                   sessionInformation <- function() {
[10:59:33.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.833]                       search = base::search(), system = base::Sys.info())
[10:59:33.833]                   }
[10:59:33.833]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.833]                     cond$call), session = sessionInformation(), 
[10:59:33.833]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.833]                   signalCondition(cond)
[10:59:33.833]                 }
[10:59:33.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.833]                 "immediateCondition"))) {
[10:59:33.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.833]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.833]                   if (TRUE && !signal) {
[10:59:33.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.833]                     {
[10:59:33.833]                       inherits <- base::inherits
[10:59:33.833]                       invokeRestart <- base::invokeRestart
[10:59:33.833]                       is.null <- base::is.null
[10:59:33.833]                       muffled <- FALSE
[10:59:33.833]                       if (inherits(cond, "message")) {
[10:59:33.833]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.833]                         if (muffled) 
[10:59:33.833]                           invokeRestart("muffleMessage")
[10:59:33.833]                       }
[10:59:33.833]                       else if (inherits(cond, "warning")) {
[10:59:33.833]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.833]                         if (muffled) 
[10:59:33.833]                           invokeRestart("muffleWarning")
[10:59:33.833]                       }
[10:59:33.833]                       else if (inherits(cond, "condition")) {
[10:59:33.833]                         if (!is.null(pattern)) {
[10:59:33.833]                           computeRestarts <- base::computeRestarts
[10:59:33.833]                           grepl <- base::grepl
[10:59:33.833]                           restarts <- computeRestarts(cond)
[10:59:33.833]                           for (restart in restarts) {
[10:59:33.833]                             name <- restart$name
[10:59:33.833]                             if (is.null(name)) 
[10:59:33.833]                               next
[10:59:33.833]                             if (!grepl(pattern, name)) 
[10:59:33.833]                               next
[10:59:33.833]                             invokeRestart(restart)
[10:59:33.833]                             muffled <- TRUE
[10:59:33.833]                             break
[10:59:33.833]                           }
[10:59:33.833]                         }
[10:59:33.833]                       }
[10:59:33.833]                       invisible(muffled)
[10:59:33.833]                     }
[10:59:33.833]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.833]                   }
[10:59:33.833]                 }
[10:59:33.833]                 else {
[10:59:33.833]                   if (TRUE) {
[10:59:33.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.833]                     {
[10:59:33.833]                       inherits <- base::inherits
[10:59:33.833]                       invokeRestart <- base::invokeRestart
[10:59:33.833]                       is.null <- base::is.null
[10:59:33.833]                       muffled <- FALSE
[10:59:33.833]                       if (inherits(cond, "message")) {
[10:59:33.833]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.833]                         if (muffled) 
[10:59:33.833]                           invokeRestart("muffleMessage")
[10:59:33.833]                       }
[10:59:33.833]                       else if (inherits(cond, "warning")) {
[10:59:33.833]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.833]                         if (muffled) 
[10:59:33.833]                           invokeRestart("muffleWarning")
[10:59:33.833]                       }
[10:59:33.833]                       else if (inherits(cond, "condition")) {
[10:59:33.833]                         if (!is.null(pattern)) {
[10:59:33.833]                           computeRestarts <- base::computeRestarts
[10:59:33.833]                           grepl <- base::grepl
[10:59:33.833]                           restarts <- computeRestarts(cond)
[10:59:33.833]                           for (restart in restarts) {
[10:59:33.833]                             name <- restart$name
[10:59:33.833]                             if (is.null(name)) 
[10:59:33.833]                               next
[10:59:33.833]                             if (!grepl(pattern, name)) 
[10:59:33.833]                               next
[10:59:33.833]                             invokeRestart(restart)
[10:59:33.833]                             muffled <- TRUE
[10:59:33.833]                             break
[10:59:33.833]                           }
[10:59:33.833]                         }
[10:59:33.833]                       }
[10:59:33.833]                       invisible(muffled)
[10:59:33.833]                     }
[10:59:33.833]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.833]                   }
[10:59:33.833]                 }
[10:59:33.833]             }
[10:59:33.833]         }))
[10:59:33.833]     }, error = function(ex) {
[10:59:33.833]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.833]                 ...future.rng), started = ...future.startTime, 
[10:59:33.833]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.833]             version = "1.8"), class = "FutureResult")
[10:59:33.833]     }, finally = {
[10:59:33.833]         if (!identical(...future.workdir, getwd())) 
[10:59:33.833]             setwd(...future.workdir)
[10:59:33.833]         {
[10:59:33.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.833]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.833]             }
[10:59:33.833]             base::options(...future.oldOptions)
[10:59:33.833]             if (.Platform$OS.type == "windows") {
[10:59:33.833]                 old_names <- names(...future.oldEnvVars)
[10:59:33.833]                 envs <- base::Sys.getenv()
[10:59:33.833]                 names <- names(envs)
[10:59:33.833]                 common <- intersect(names, old_names)
[10:59:33.833]                 added <- setdiff(names, old_names)
[10:59:33.833]                 removed <- setdiff(old_names, names)
[10:59:33.833]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.833]                   envs[common]]
[10:59:33.833]                 NAMES <- toupper(changed)
[10:59:33.833]                 args <- list()
[10:59:33.833]                 for (kk in seq_along(NAMES)) {
[10:59:33.833]                   name <- changed[[kk]]
[10:59:33.833]                   NAME <- NAMES[[kk]]
[10:59:33.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.833]                     next
[10:59:33.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.833]                 }
[10:59:33.833]                 NAMES <- toupper(added)
[10:59:33.833]                 for (kk in seq_along(NAMES)) {
[10:59:33.833]                   name <- added[[kk]]
[10:59:33.833]                   NAME <- NAMES[[kk]]
[10:59:33.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.833]                     next
[10:59:33.833]                   args[[name]] <- ""
[10:59:33.833]                 }
[10:59:33.833]                 NAMES <- toupper(removed)
[10:59:33.833]                 for (kk in seq_along(NAMES)) {
[10:59:33.833]                   name <- removed[[kk]]
[10:59:33.833]                   NAME <- NAMES[[kk]]
[10:59:33.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.833]                     next
[10:59:33.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.833]                 }
[10:59:33.833]                 if (length(args) > 0) 
[10:59:33.833]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.833]             }
[10:59:33.833]             else {
[10:59:33.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.833]             }
[10:59:33.833]             {
[10:59:33.833]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.833]                   0L) {
[10:59:33.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.833]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.833]                   base::options(opts)
[10:59:33.833]                 }
[10:59:33.833]                 {
[10:59:33.833]                   {
[10:59:33.833]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.833]                     NULL
[10:59:33.833]                   }
[10:59:33.833]                   options(future.plan = NULL)
[10:59:33.833]                   if (is.na(NA_character_)) 
[10:59:33.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.833]                     .init = FALSE)
[10:59:33.833]                 }
[10:59:33.833]             }
[10:59:33.833]         }
[10:59:33.833]     })
[10:59:33.833]     if (TRUE) {
[10:59:33.833]         base::sink(type = "output", split = FALSE)
[10:59:33.833]         if (TRUE) {
[10:59:33.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.833]         }
[10:59:33.833]         else {
[10:59:33.833]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.833]         }
[10:59:33.833]         base::close(...future.stdout)
[10:59:33.833]         ...future.stdout <- NULL
[10:59:33.833]     }
[10:59:33.833]     ...future.result$conditions <- ...future.conditions
[10:59:33.833]     ...future.result$finished <- base::Sys.time()
[10:59:33.833]     ...future.result
[10:59:33.833] }
[10:59:33.835] assign_globals() ...
[10:59:33.835] List of 5
[10:59:33.835]  $ ...future.FUN            :function (x, w, ...)  
[10:59:33.835]  $ MoreArgs                 : NULL
[10:59:33.835]  $ ...future.elements_ii    :List of 2
[10:59:33.835]   ..$ :List of 2
[10:59:33.835]   .. ..$ : num [1:10] 0.9897 0.0501 0.3253 0.0367 0.7659 ...
[10:59:33.835]   .. ..$ : num [1:10] 0.453 0.1703 0.0505 0.7054 0.4953 ...
[10:59:33.835]   ..$ :List of 2
[10:59:33.835]   .. ..$ : num [1:10] 10 2 5 7 7 4 4 9 7 7
[10:59:33.835]   .. ..$ : num [1:10] 4 4 7 6 10 3 6 6 7 7
[10:59:33.835]  $ ...future.seeds_ii       : NULL
[10:59:33.835]  $ ...future.globals.maxSize: NULL
[10:59:33.835]  - attr(*, "where")=List of 5
[10:59:33.835]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.835]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.835]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.835]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.835]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.835]  - attr(*, "resolved")= logi FALSE
[10:59:33.835]  - attr(*, "total_size")= num 817
[10:59:33.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.835]  - attr(*, "already-done")= logi TRUE
[10:59:33.841] - copied ‘...future.FUN’ to environment
[10:59:33.841] - copied ‘MoreArgs’ to environment
[10:59:33.841] - copied ‘...future.elements_ii’ to environment
[10:59:33.842] - copied ‘...future.seeds_ii’ to environment
[10:59:33.842] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.842] assign_globals() ... done
[10:59:33.842] requestCore(): workers = 2
[10:59:33.844] MulticoreFuture started
[10:59:33.844] - Launch lazy future ... done
[10:59:33.844] run() for ‘MulticoreFuture’ ... done
[10:59:33.845] Created future:
[10:59:33.845] plan(): Setting new future strategy stack:
[10:59:33.845] List of future strategies:
[10:59:33.845] 1. sequential:
[10:59:33.845]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.845]    - tweaked: FALSE
[10:59:33.845]    - call: NULL
[10:59:33.846] plan(): nbrOfWorkers() = 1
[10:59:33.848] plan(): Setting new future strategy stack:
[10:59:33.849] List of future strategies:
[10:59:33.849] 1. multicore:
[10:59:33.849]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.849]    - tweaked: FALSE
[10:59:33.849]    - call: plan(strategy)
[10:59:33.852] plan(): nbrOfWorkers() = 2
[10:59:33.845] MulticoreFuture:
[10:59:33.845] Label: ‘future_Map-1’
[10:59:33.845] Expression:
[10:59:33.845] {
[10:59:33.845]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.845]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.845]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.845]         on.exit(options(oopts), add = TRUE)
[10:59:33.845]     }
[10:59:33.845]     {
[10:59:33.845]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.845]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.845]         do.call(mapply, args = args)
[10:59:33.845]     }
[10:59:33.845] }
[10:59:33.845] Lazy evaluation: FALSE
[10:59:33.845] Asynchronous evaluation: TRUE
[10:59:33.845] Local evaluation: TRUE
[10:59:33.845] Environment: R_GlobalEnv
[10:59:33.845] Capture standard output: TRUE
[10:59:33.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.845] Globals: 5 objects totaling 817 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 399 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.845] Packages: 1 packages (‘stats’)
[10:59:33.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.845] Resolved: TRUE
[10:59:33.845] Value: <not collected>
[10:59:33.845] Conditions captured: <none>
[10:59:33.845] Early signaling: FALSE
[10:59:33.845] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.845] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.853] Chunk #1 of 2 ... DONE
[10:59:33.853] Chunk #2 of 2 ...
[10:59:33.853]  - Finding globals in '...' for chunk #2 ...
[10:59:33.853] getGlobalsAndPackages() ...
[10:59:33.853] Searching for globals...
[10:59:33.854] 
[10:59:33.854] Searching for globals ... DONE
[10:59:33.854] - globals: [0] <none>
[10:59:33.854] getGlobalsAndPackages() ... DONE
[10:59:33.854]    + additional globals found: [n=0] 
[10:59:33.854]    + additional namespaces needed: [n=0] 
[10:59:33.854]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.854]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.855]  - seeds: <none>
[10:59:33.855]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.855] getGlobalsAndPackages() ...
[10:59:33.855] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.855] Resolving globals: FALSE
[10:59:33.856] The total size of the 5 globals is 993 bytes (993 bytes)
[10:59:33.857] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 993 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (575 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.857] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.857] - packages: [1] ‘stats’
[10:59:33.857] getGlobalsAndPackages() ... DONE
[10:59:33.858] run() for ‘Future’ ...
[10:59:33.858] - state: ‘created’
[10:59:33.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.860] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.861]   - Field: ‘label’
[10:59:33.861]   - Field: ‘local’
[10:59:33.861]   - Field: ‘owner’
[10:59:33.861]   - Field: ‘envir’
[10:59:33.861]   - Field: ‘workers’
[10:59:33.861]   - Field: ‘packages’
[10:59:33.861]   - Field: ‘gc’
[10:59:33.861]   - Field: ‘job’
[10:59:33.862]   - Field: ‘conditions’
[10:59:33.862]   - Field: ‘expr’
[10:59:33.862]   - Field: ‘uuid’
[10:59:33.862]   - Field: ‘seed’
[10:59:33.862]   - Field: ‘version’
[10:59:33.862]   - Field: ‘result’
[10:59:33.862]   - Field: ‘asynchronous’
[10:59:33.863]   - Field: ‘calls’
[10:59:33.863]   - Field: ‘globals’
[10:59:33.863]   - Field: ‘stdout’
[10:59:33.863]   - Field: ‘earlySignal’
[10:59:33.863]   - Field: ‘lazy’
[10:59:33.863]   - Field: ‘state’
[10:59:33.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.864] - Launch lazy future ...
[10:59:33.864] Packages needed by the future expression (n = 1): ‘stats’
[10:59:33.864] Packages needed by future strategies (n = 0): <none>
[10:59:33.865] {
[10:59:33.865]     {
[10:59:33.865]         {
[10:59:33.865]             ...future.startTime <- base::Sys.time()
[10:59:33.865]             {
[10:59:33.865]                 {
[10:59:33.865]                   {
[10:59:33.865]                     {
[10:59:33.865]                       {
[10:59:33.865]                         base::local({
[10:59:33.865]                           has_future <- base::requireNamespace("future", 
[10:59:33.865]                             quietly = TRUE)
[10:59:33.865]                           if (has_future) {
[10:59:33.865]                             ns <- base::getNamespace("future")
[10:59:33.865]                             version <- ns[[".package"]][["version"]]
[10:59:33.865]                             if (is.null(version)) 
[10:59:33.865]                               version <- utils::packageVersion("future")
[10:59:33.865]                           }
[10:59:33.865]                           else {
[10:59:33.865]                             version <- NULL
[10:59:33.865]                           }
[10:59:33.865]                           if (!has_future || version < "1.8.0") {
[10:59:33.865]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.865]                               "", base::R.version$version.string), 
[10:59:33.865]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:33.865]                                 base::R.version$platform, 8 * 
[10:59:33.865]                                   base::.Machine$sizeof.pointer), 
[10:59:33.865]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.865]                                 "release", "version")], collapse = " "), 
[10:59:33.865]                               hostname = base::Sys.info()[["nodename"]])
[10:59:33.865]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.865]                               info)
[10:59:33.865]                             info <- base::paste(info, collapse = "; ")
[10:59:33.865]                             if (!has_future) {
[10:59:33.865]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.865]                                 info)
[10:59:33.865]                             }
[10:59:33.865]                             else {
[10:59:33.865]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.865]                                 info, version)
[10:59:33.865]                             }
[10:59:33.865]                             base::stop(msg)
[10:59:33.865]                           }
[10:59:33.865]                         })
[10:59:33.865]                       }
[10:59:33.865]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.865]                       base::options(mc.cores = 1L)
[10:59:33.865]                     }
[10:59:33.865]                     base::local({
[10:59:33.865]                       for (pkg in "stats") {
[10:59:33.865]                         base::loadNamespace(pkg)
[10:59:33.865]                         base::library(pkg, character.only = TRUE)
[10:59:33.865]                       }
[10:59:33.865]                     })
[10:59:33.865]                   }
[10:59:33.865]                   ...future.strategy.old <- future::plan("list")
[10:59:33.865]                   options(future.plan = NULL)
[10:59:33.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.865]                 }
[10:59:33.865]                 ...future.workdir <- getwd()
[10:59:33.865]             }
[10:59:33.865]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.865]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.865]         }
[10:59:33.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.865]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.865]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.865]             base::names(...future.oldOptions))
[10:59:33.865]     }
[10:59:33.865]     if (FALSE) {
[10:59:33.865]     }
[10:59:33.865]     else {
[10:59:33.865]         if (TRUE) {
[10:59:33.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.865]                 open = "w")
[10:59:33.865]         }
[10:59:33.865]         else {
[10:59:33.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.865]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.865]         }
[10:59:33.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.865]             base::sink(type = "output", split = FALSE)
[10:59:33.865]             base::close(...future.stdout)
[10:59:33.865]         }, add = TRUE)
[10:59:33.865]     }
[10:59:33.865]     ...future.frame <- base::sys.nframe()
[10:59:33.865]     ...future.conditions <- base::list()
[10:59:33.865]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.865]     if (FALSE) {
[10:59:33.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.865]     }
[10:59:33.865]     ...future.result <- base::tryCatch({
[10:59:33.865]         base::withCallingHandlers({
[10:59:33.865]             ...future.value <- base::withVisible(base::local({
[10:59:33.865]                 withCallingHandlers({
[10:59:33.865]                   {
[10:59:33.865]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.865]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.865]                       ...future.globals.maxSize)) {
[10:59:33.865]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.865]                       on.exit(options(oopts), add = TRUE)
[10:59:33.865]                     }
[10:59:33.865]                     {
[10:59:33.865]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.865]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.865]                         USE.NAMES = FALSE)
[10:59:33.865]                       do.call(mapply, args = args)
[10:59:33.865]                     }
[10:59:33.865]                   }
[10:59:33.865]                 }, immediateCondition = function(cond) {
[10:59:33.865]                   save_rds <- function (object, pathname, ...) 
[10:59:33.865]                   {
[10:59:33.865]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.865]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.865]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.865]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.865]                         fi_tmp[["mtime"]])
[10:59:33.865]                     }
[10:59:33.865]                     tryCatch({
[10:59:33.865]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.865]                     }, error = function(ex) {
[10:59:33.865]                       msg <- conditionMessage(ex)
[10:59:33.865]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.865]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.865]                         fi_tmp[["mtime"]], msg)
[10:59:33.865]                       ex$message <- msg
[10:59:33.865]                       stop(ex)
[10:59:33.865]                     })
[10:59:33.865]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.865]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.865]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.865]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.865]                       fi <- file.info(pathname)
[10:59:33.865]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.865]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.865]                         fi[["size"]], fi[["mtime"]])
[10:59:33.865]                       stop(msg)
[10:59:33.865]                     }
[10:59:33.865]                     invisible(pathname)
[10:59:33.865]                   }
[10:59:33.865]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.865]                     rootPath = tempdir()) 
[10:59:33.865]                   {
[10:59:33.865]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.865]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.865]                       tmpdir = path, fileext = ".rds")
[10:59:33.865]                     save_rds(obj, file)
[10:59:33.865]                   }
[10:59:33.865]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.865]                   {
[10:59:33.865]                     inherits <- base::inherits
[10:59:33.865]                     invokeRestart <- base::invokeRestart
[10:59:33.865]                     is.null <- base::is.null
[10:59:33.865]                     muffled <- FALSE
[10:59:33.865]                     if (inherits(cond, "message")) {
[10:59:33.865]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.865]                       if (muffled) 
[10:59:33.865]                         invokeRestart("muffleMessage")
[10:59:33.865]                     }
[10:59:33.865]                     else if (inherits(cond, "warning")) {
[10:59:33.865]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.865]                       if (muffled) 
[10:59:33.865]                         invokeRestart("muffleWarning")
[10:59:33.865]                     }
[10:59:33.865]                     else if (inherits(cond, "condition")) {
[10:59:33.865]                       if (!is.null(pattern)) {
[10:59:33.865]                         computeRestarts <- base::computeRestarts
[10:59:33.865]                         grepl <- base::grepl
[10:59:33.865]                         restarts <- computeRestarts(cond)
[10:59:33.865]                         for (restart in restarts) {
[10:59:33.865]                           name <- restart$name
[10:59:33.865]                           if (is.null(name)) 
[10:59:33.865]                             next
[10:59:33.865]                           if (!grepl(pattern, name)) 
[10:59:33.865]                             next
[10:59:33.865]                           invokeRestart(restart)
[10:59:33.865]                           muffled <- TRUE
[10:59:33.865]                           break
[10:59:33.865]                         }
[10:59:33.865]                       }
[10:59:33.865]                     }
[10:59:33.865]                     invisible(muffled)
[10:59:33.865]                   }
[10:59:33.865]                   muffleCondition(cond)
[10:59:33.865]                 })
[10:59:33.865]             }))
[10:59:33.865]             future::FutureResult(value = ...future.value$value, 
[10:59:33.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.865]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.865]                     ...future.globalenv.names))
[10:59:33.865]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.865]         }, condition = base::local({
[10:59:33.865]             c <- base::c
[10:59:33.865]             inherits <- base::inherits
[10:59:33.865]             invokeRestart <- base::invokeRestart
[10:59:33.865]             length <- base::length
[10:59:33.865]             list <- base::list
[10:59:33.865]             seq.int <- base::seq.int
[10:59:33.865]             signalCondition <- base::signalCondition
[10:59:33.865]             sys.calls <- base::sys.calls
[10:59:33.865]             `[[` <- base::`[[`
[10:59:33.865]             `+` <- base::`+`
[10:59:33.865]             `<<-` <- base::`<<-`
[10:59:33.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.865]                   3L)]
[10:59:33.865]             }
[10:59:33.865]             function(cond) {
[10:59:33.865]                 is_error <- inherits(cond, "error")
[10:59:33.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.865]                   NULL)
[10:59:33.865]                 if (is_error) {
[10:59:33.865]                   sessionInformation <- function() {
[10:59:33.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.865]                       search = base::search(), system = base::Sys.info())
[10:59:33.865]                   }
[10:59:33.865]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.865]                     cond$call), session = sessionInformation(), 
[10:59:33.865]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.865]                   signalCondition(cond)
[10:59:33.865]                 }
[10:59:33.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.865]                 "immediateCondition"))) {
[10:59:33.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.865]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.865]                   if (TRUE && !signal) {
[10:59:33.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.865]                     {
[10:59:33.865]                       inherits <- base::inherits
[10:59:33.865]                       invokeRestart <- base::invokeRestart
[10:59:33.865]                       is.null <- base::is.null
[10:59:33.865]                       muffled <- FALSE
[10:59:33.865]                       if (inherits(cond, "message")) {
[10:59:33.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.865]                         if (muffled) 
[10:59:33.865]                           invokeRestart("muffleMessage")
[10:59:33.865]                       }
[10:59:33.865]                       else if (inherits(cond, "warning")) {
[10:59:33.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.865]                         if (muffled) 
[10:59:33.865]                           invokeRestart("muffleWarning")
[10:59:33.865]                       }
[10:59:33.865]                       else if (inherits(cond, "condition")) {
[10:59:33.865]                         if (!is.null(pattern)) {
[10:59:33.865]                           computeRestarts <- base::computeRestarts
[10:59:33.865]                           grepl <- base::grepl
[10:59:33.865]                           restarts <- computeRestarts(cond)
[10:59:33.865]                           for (restart in restarts) {
[10:59:33.865]                             name <- restart$name
[10:59:33.865]                             if (is.null(name)) 
[10:59:33.865]                               next
[10:59:33.865]                             if (!grepl(pattern, name)) 
[10:59:33.865]                               next
[10:59:33.865]                             invokeRestart(restart)
[10:59:33.865]                             muffled <- TRUE
[10:59:33.865]                             break
[10:59:33.865]                           }
[10:59:33.865]                         }
[10:59:33.865]                       }
[10:59:33.865]                       invisible(muffled)
[10:59:33.865]                     }
[10:59:33.865]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.865]                   }
[10:59:33.865]                 }
[10:59:33.865]                 else {
[10:59:33.865]                   if (TRUE) {
[10:59:33.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.865]                     {
[10:59:33.865]                       inherits <- base::inherits
[10:59:33.865]                       invokeRestart <- base::invokeRestart
[10:59:33.865]                       is.null <- base::is.null
[10:59:33.865]                       muffled <- FALSE
[10:59:33.865]                       if (inherits(cond, "message")) {
[10:59:33.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.865]                         if (muffled) 
[10:59:33.865]                           invokeRestart("muffleMessage")
[10:59:33.865]                       }
[10:59:33.865]                       else if (inherits(cond, "warning")) {
[10:59:33.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.865]                         if (muffled) 
[10:59:33.865]                           invokeRestart("muffleWarning")
[10:59:33.865]                       }
[10:59:33.865]                       else if (inherits(cond, "condition")) {
[10:59:33.865]                         if (!is.null(pattern)) {
[10:59:33.865]                           computeRestarts <- base::computeRestarts
[10:59:33.865]                           grepl <- base::grepl
[10:59:33.865]                           restarts <- computeRestarts(cond)
[10:59:33.865]                           for (restart in restarts) {
[10:59:33.865]                             name <- restart$name
[10:59:33.865]                             if (is.null(name)) 
[10:59:33.865]                               next
[10:59:33.865]                             if (!grepl(pattern, name)) 
[10:59:33.865]                               next
[10:59:33.865]                             invokeRestart(restart)
[10:59:33.865]                             muffled <- TRUE
[10:59:33.865]                             break
[10:59:33.865]                           }
[10:59:33.865]                         }
[10:59:33.865]                       }
[10:59:33.865]                       invisible(muffled)
[10:59:33.865]                     }
[10:59:33.865]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.865]                   }
[10:59:33.865]                 }
[10:59:33.865]             }
[10:59:33.865]         }))
[10:59:33.865]     }, error = function(ex) {
[10:59:33.865]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.865]                 ...future.rng), started = ...future.startTime, 
[10:59:33.865]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.865]             version = "1.8"), class = "FutureResult")
[10:59:33.865]     }, finally = {
[10:59:33.865]         if (!identical(...future.workdir, getwd())) 
[10:59:33.865]             setwd(...future.workdir)
[10:59:33.865]         {
[10:59:33.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.865]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.865]             }
[10:59:33.865]             base::options(...future.oldOptions)
[10:59:33.865]             if (.Platform$OS.type == "windows") {
[10:59:33.865]                 old_names <- names(...future.oldEnvVars)
[10:59:33.865]                 envs <- base::Sys.getenv()
[10:59:33.865]                 names <- names(envs)
[10:59:33.865]                 common <- intersect(names, old_names)
[10:59:33.865]                 added <- setdiff(names, old_names)
[10:59:33.865]                 removed <- setdiff(old_names, names)
[10:59:33.865]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.865]                   envs[common]]
[10:59:33.865]                 NAMES <- toupper(changed)
[10:59:33.865]                 args <- list()
[10:59:33.865]                 for (kk in seq_along(NAMES)) {
[10:59:33.865]                   name <- changed[[kk]]
[10:59:33.865]                   NAME <- NAMES[[kk]]
[10:59:33.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.865]                     next
[10:59:33.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.865]                 }
[10:59:33.865]                 NAMES <- toupper(added)
[10:59:33.865]                 for (kk in seq_along(NAMES)) {
[10:59:33.865]                   name <- added[[kk]]
[10:59:33.865]                   NAME <- NAMES[[kk]]
[10:59:33.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.865]                     next
[10:59:33.865]                   args[[name]] <- ""
[10:59:33.865]                 }
[10:59:33.865]                 NAMES <- toupper(removed)
[10:59:33.865]                 for (kk in seq_along(NAMES)) {
[10:59:33.865]                   name <- removed[[kk]]
[10:59:33.865]                   NAME <- NAMES[[kk]]
[10:59:33.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.865]                     next
[10:59:33.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.865]                 }
[10:59:33.865]                 if (length(args) > 0) 
[10:59:33.865]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.865]             }
[10:59:33.865]             else {
[10:59:33.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.865]             }
[10:59:33.865]             {
[10:59:33.865]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.865]                   0L) {
[10:59:33.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.865]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.865]                   base::options(opts)
[10:59:33.865]                 }
[10:59:33.865]                 {
[10:59:33.865]                   {
[10:59:33.865]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.865]                     NULL
[10:59:33.865]                   }
[10:59:33.865]                   options(future.plan = NULL)
[10:59:33.865]                   if (is.na(NA_character_)) 
[10:59:33.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.865]                     .init = FALSE)
[10:59:33.865]                 }
[10:59:33.865]             }
[10:59:33.865]         }
[10:59:33.865]     })
[10:59:33.865]     if (TRUE) {
[10:59:33.865]         base::sink(type = "output", split = FALSE)
[10:59:33.865]         if (TRUE) {
[10:59:33.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.865]         }
[10:59:33.865]         else {
[10:59:33.865]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.865]         }
[10:59:33.865]         base::close(...future.stdout)
[10:59:33.865]         ...future.stdout <- NULL
[10:59:33.865]     }
[10:59:33.865]     ...future.result$conditions <- ...future.conditions
[10:59:33.865]     ...future.result$finished <- base::Sys.time()
[10:59:33.865]     ...future.result
[10:59:33.865] }
[10:59:33.869] assign_globals() ...
[10:59:33.869] List of 5
[10:59:33.869]  $ ...future.FUN            :function (x, w, ...)  
[10:59:33.869]  $ MoreArgs                 : NULL
[10:59:33.869]  $ ...future.elements_ii    :List of 2
[10:59:33.869]   ..$ :List of 3
[10:59:33.869]   .. ..$ : num [1:10] 0.121 0.519 0.15 0.506 0.984 ...
[10:59:33.869]   .. ..$ : num [1:10] 0.16837 0.88836 0.61104 0.00777 0.89418 ...
[10:59:33.869]   .. ..$ : num [1:10] 0.8654 0.8218 0.5044 0.8926 0.0161 ...
[10:59:33.869]   ..$ :List of 3
[10:59:33.869]   .. ..$ : num [1:10] 5 8 9 6 1 4 9 7 8 4
[10:59:33.869]   .. ..$ : num [1:10] 1 3 4 6 5 6 3 4 2 5
[10:59:33.869]   .. ..$ : num [1:10] 6 7 2 6 3 8 3 4 9 3
[10:59:33.869]  $ ...future.seeds_ii       : NULL
[10:59:33.869]  $ ...future.globals.maxSize: NULL
[10:59:33.869]  - attr(*, "where")=List of 5
[10:59:33.869]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.869]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.869]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.869]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.869]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.869]  - attr(*, "resolved")= logi FALSE
[10:59:33.869]  - attr(*, "total_size")= num 993
[10:59:33.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.869]  - attr(*, "already-done")= logi TRUE
[10:59:33.878] - copied ‘...future.FUN’ to environment
[10:59:33.879] - copied ‘MoreArgs’ to environment
[10:59:33.879] - copied ‘...future.elements_ii’ to environment
[10:59:33.879] - copied ‘...future.seeds_ii’ to environment
[10:59:33.879] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.879] assign_globals() ... done
[10:59:33.879] requestCore(): workers = 2
[10:59:33.882] MulticoreFuture started
[10:59:33.882] - Launch lazy future ... done
[10:59:33.882] run() for ‘MulticoreFuture’ ... done
[10:59:33.883] Created future:
[10:59:33.883] plan(): Setting new future strategy stack:
[10:59:33.883] List of future strategies:
[10:59:33.883] 1. sequential:
[10:59:33.883]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.883]    - tweaked: FALSE
[10:59:33.883]    - call: NULL
[10:59:33.884] plan(): nbrOfWorkers() = 1
[10:59:33.886] plan(): Setting new future strategy stack:
[10:59:33.887] List of future strategies:
[10:59:33.887] 1. multicore:
[10:59:33.887]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.887]    - tweaked: FALSE
[10:59:33.887]    - call: plan(strategy)
[10:59:33.889] plan(): nbrOfWorkers() = 2
[10:59:33.883] MulticoreFuture:
[10:59:33.883] Label: ‘future_Map-2’
[10:59:33.883] Expression:
[10:59:33.883] {
[10:59:33.883]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.883]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.883]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.883]         on.exit(options(oopts), add = TRUE)
[10:59:33.883]     }
[10:59:33.883]     {
[10:59:33.883]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.883]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.883]         do.call(mapply, args = args)
[10:59:33.883]     }
[10:59:33.883] }
[10:59:33.883] Lazy evaluation: FALSE
[10:59:33.883] Asynchronous evaluation: TRUE
[10:59:33.883] Local evaluation: TRUE
[10:59:33.883] Environment: R_GlobalEnv
[10:59:33.883] Capture standard output: TRUE
[10:59:33.883] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.883] Globals: 5 objects totaling 993 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 575 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.883] Packages: 1 packages (‘stats’)
[10:59:33.883] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.883] Resolved: TRUE
[10:59:33.883] Value: <not collected>
[10:59:33.883] Conditions captured: <none>
[10:59:33.883] Early signaling: FALSE
[10:59:33.883] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.883] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.890] Chunk #2 of 2 ... DONE
[10:59:33.891] Launching 2 futures (chunks) ... DONE
[10:59:33.891] Resolving 2 futures (chunks) ...
[10:59:33.891] resolve() on list ...
[10:59:33.891]  recursive: 0
[10:59:33.891]  length: 2
[10:59:33.891] 
[10:59:33.892] Future #1
[10:59:33.892] result() for MulticoreFuture ...
[10:59:33.893] result() for MulticoreFuture ...
[10:59:33.893] result() for MulticoreFuture ... done
[10:59:33.893] result() for MulticoreFuture ... done
[10:59:33.893] result() for MulticoreFuture ...
[10:59:33.893] result() for MulticoreFuture ... done
[10:59:33.893] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.894] - nx: 2
[10:59:33.894] - relay: TRUE
[10:59:33.894] - stdout: TRUE
[10:59:33.894] - signal: TRUE
[10:59:33.894] - resignal: FALSE
[10:59:33.894] - force: TRUE
[10:59:33.894] - relayed: [n=2] FALSE, FALSE
[10:59:33.894] - queued futures: [n=2] FALSE, FALSE
[10:59:33.894]  - until=1
[10:59:33.895]  - relaying element #1
[10:59:33.895] result() for MulticoreFuture ...
[10:59:33.895] result() for MulticoreFuture ... done
[10:59:33.895] result() for MulticoreFuture ...
[10:59:33.895] result() for MulticoreFuture ... done
[10:59:33.895] result() for MulticoreFuture ...
[10:59:33.895] result() for MulticoreFuture ... done
[10:59:33.896] result() for MulticoreFuture ...
[10:59:33.896] result() for MulticoreFuture ... done
[10:59:33.896] - relayed: [n=2] TRUE, FALSE
[10:59:33.896] - queued futures: [n=2] TRUE, FALSE
[10:59:33.896] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.896]  length: 1 (resolved future 1)
[10:59:33.897] Future #2
[10:59:33.897] result() for MulticoreFuture ...
[10:59:33.897] result() for MulticoreFuture ...
[10:59:33.897] result() for MulticoreFuture ... done
[10:59:33.898] result() for MulticoreFuture ... done
[10:59:33.898] result() for MulticoreFuture ...
[10:59:33.898] result() for MulticoreFuture ... done
[10:59:33.898] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.898] - nx: 2
[10:59:33.898] - relay: TRUE
[10:59:33.898] - stdout: TRUE
[10:59:33.898] - signal: TRUE
[10:59:33.899] - resignal: FALSE
[10:59:33.899] - force: TRUE
[10:59:33.899] - relayed: [n=2] TRUE, FALSE
[10:59:33.899] - queued futures: [n=2] TRUE, FALSE
[10:59:33.899]  - until=2
[10:59:33.899]  - relaying element #2
[10:59:33.899] result() for MulticoreFuture ...
[10:59:33.899] result() for MulticoreFuture ... done
[10:59:33.899] result() for MulticoreFuture ...
[10:59:33.900] result() for MulticoreFuture ... done
[10:59:33.900] result() for MulticoreFuture ...
[10:59:33.900] result() for MulticoreFuture ... done
[10:59:33.900] result() for MulticoreFuture ...
[10:59:33.900] result() for MulticoreFuture ... done
[10:59:33.900] - relayed: [n=2] TRUE, TRUE
[10:59:33.900] - queued futures: [n=2] TRUE, TRUE
[10:59:33.900] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.901]  length: 0 (resolved future 2)
[10:59:33.901] Relaying remaining futures
[10:59:33.901] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.901] - nx: 2
[10:59:33.901] - relay: TRUE
[10:59:33.901] - stdout: TRUE
[10:59:33.901] - signal: TRUE
[10:59:33.901] - resignal: FALSE
[10:59:33.901] - force: TRUE
[10:59:33.901] - relayed: [n=2] TRUE, TRUE
[10:59:33.901] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.902] - relayed: [n=2] TRUE, TRUE
[10:59:33.902] - queued futures: [n=2] TRUE, TRUE
[10:59:33.902] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.902] resolve() on list ... DONE
[10:59:33.902] result() for MulticoreFuture ...
[10:59:33.902] result() for MulticoreFuture ... done
[10:59:33.902] result() for MulticoreFuture ...
[10:59:33.902] result() for MulticoreFuture ... done
[10:59:33.902] result() for MulticoreFuture ...
[10:59:33.903] result() for MulticoreFuture ... done
[10:59:33.903] result() for MulticoreFuture ...
[10:59:33.903] result() for MulticoreFuture ... done
[10:59:33.903]  - Number of value chunks collected: 2
[10:59:33.903] Resolving 2 futures (chunks) ... DONE
[10:59:33.903] Reducing values from 2 chunks ...
[10:59:33.903]  - Number of values collected after concatenation: 5
[10:59:33.903]  - Number of values expected: 5
[10:59:33.903] Reducing values from 2 chunks ... DONE
[10:59:33.904] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:59:33.906] future_mapply() ...
[10:59:33.908] Number of chunks: 2
[10:59:33.908] getGlobalsAndPackagesXApply() ...
[10:59:33.908]  - future.globals: TRUE
[10:59:33.908] getGlobalsAndPackages() ...
[10:59:33.908] Searching for globals...
[10:59:33.909] - globals found: [1] ‘FUN’
[10:59:33.909] Searching for globals ... DONE
[10:59:33.909] Resolving globals: FALSE
[10:59:33.909] The total size of the 1 globals is 32 bytes (32 bytes)
[10:59:33.910] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[10:59:33.910] - globals: [1] ‘FUN’
[10:59:33.910] 
[10:59:33.910] getGlobalsAndPackages() ... DONE
[10:59:33.910]  - globals found/used: [n=1] ‘FUN’
[10:59:33.910]  - needed namespaces: [n=0] 
[10:59:33.911] Finding globals ... DONE
[10:59:33.911] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:33.911] List of 2
[10:59:33.911]  $ ...future.FUN:function (e1, e2)  
[10:59:33.911]  $ MoreArgs     : NULL
[10:59:33.911]  - attr(*, "where")=List of 2
[10:59:33.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:33.911]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:33.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.911]  - attr(*, "resolved")= logi FALSE
[10:59:33.911]  - attr(*, "total_size")= num NA
[10:59:33.914] Packages to be attached in all futures: [n=0] 
[10:59:33.914] getGlobalsAndPackagesXApply() ... DONE
[10:59:33.914] Number of futures (= number of chunks): 2
[10:59:33.914] Launching 2 futures (chunks) ...
[10:59:33.914] Chunk #1 of 2 ...
[10:59:33.915]  - Finding globals in '...' for chunk #1 ...
[10:59:33.915] getGlobalsAndPackages() ...
[10:59:33.915] Searching for globals...
[10:59:33.915] 
[10:59:33.915] Searching for globals ... DONE
[10:59:33.915] - globals: [0] <none>
[10:59:33.915] getGlobalsAndPackages() ... DONE
[10:59:33.916]    + additional globals found: [n=0] 
[10:59:33.916]    + additional namespaces needed: [n=0] 
[10:59:33.916]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:33.916]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.916]  - seeds: <none>
[10:59:33.916]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.916] getGlobalsAndPackages() ...
[10:59:33.916] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.916] Resolving globals: FALSE
[10:59:33.917] The total size of the 5 globals is 188 bytes (188 bytes)
[10:59:33.917] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 188 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (75 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.917] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.918] 
[10:59:33.918] getGlobalsAndPackages() ... DONE
[10:59:33.918] run() for ‘Future’ ...
[10:59:33.918] - state: ‘created’
[10:59:33.918] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.920] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.920]   - Field: ‘label’
[10:59:33.921]   - Field: ‘local’
[10:59:33.921]   - Field: ‘owner’
[10:59:33.921]   - Field: ‘envir’
[10:59:33.921]   - Field: ‘workers’
[10:59:33.921]   - Field: ‘packages’
[10:59:33.921]   - Field: ‘gc’
[10:59:33.921]   - Field: ‘job’
[10:59:33.921]   - Field: ‘conditions’
[10:59:33.921]   - Field: ‘expr’
[10:59:33.921]   - Field: ‘uuid’
[10:59:33.922]   - Field: ‘seed’
[10:59:33.922]   - Field: ‘version’
[10:59:33.922]   - Field: ‘result’
[10:59:33.922]   - Field: ‘asynchronous’
[10:59:33.922]   - Field: ‘calls’
[10:59:33.922]   - Field: ‘globals’
[10:59:33.922]   - Field: ‘stdout’
[10:59:33.922]   - Field: ‘earlySignal’
[10:59:33.922]   - Field: ‘lazy’
[10:59:33.922]   - Field: ‘state’
[10:59:33.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.923] - Launch lazy future ...
[10:59:33.923] Packages needed by the future expression (n = 0): <none>
[10:59:33.923] Packages needed by future strategies (n = 0): <none>
[10:59:33.924] {
[10:59:33.924]     {
[10:59:33.924]         {
[10:59:33.924]             ...future.startTime <- base::Sys.time()
[10:59:33.924]             {
[10:59:33.924]                 {
[10:59:33.924]                   {
[10:59:33.924]                     {
[10:59:33.924]                       base::local({
[10:59:33.924]                         has_future <- base::requireNamespace("future", 
[10:59:33.924]                           quietly = TRUE)
[10:59:33.924]                         if (has_future) {
[10:59:33.924]                           ns <- base::getNamespace("future")
[10:59:33.924]                           version <- ns[[".package"]][["version"]]
[10:59:33.924]                           if (is.null(version)) 
[10:59:33.924]                             version <- utils::packageVersion("future")
[10:59:33.924]                         }
[10:59:33.924]                         else {
[10:59:33.924]                           version <- NULL
[10:59:33.924]                         }
[10:59:33.924]                         if (!has_future || version < "1.8.0") {
[10:59:33.924]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.924]                             "", base::R.version$version.string), 
[10:59:33.924]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.924]                               "release", "version")], collapse = " "), 
[10:59:33.924]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.924]                             info)
[10:59:33.924]                           info <- base::paste(info, collapse = "; ")
[10:59:33.924]                           if (!has_future) {
[10:59:33.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.924]                               info)
[10:59:33.924]                           }
[10:59:33.924]                           else {
[10:59:33.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.924]                               info, version)
[10:59:33.924]                           }
[10:59:33.924]                           base::stop(msg)
[10:59:33.924]                         }
[10:59:33.924]                       })
[10:59:33.924]                     }
[10:59:33.924]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.924]                     base::options(mc.cores = 1L)
[10:59:33.924]                   }
[10:59:33.924]                   ...future.strategy.old <- future::plan("list")
[10:59:33.924]                   options(future.plan = NULL)
[10:59:33.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.924]                 }
[10:59:33.924]                 ...future.workdir <- getwd()
[10:59:33.924]             }
[10:59:33.924]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.924]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.924]         }
[10:59:33.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.924]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.924]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.924]             base::names(...future.oldOptions))
[10:59:33.924]     }
[10:59:33.924]     if (FALSE) {
[10:59:33.924]     }
[10:59:33.924]     else {
[10:59:33.924]         if (TRUE) {
[10:59:33.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.924]                 open = "w")
[10:59:33.924]         }
[10:59:33.924]         else {
[10:59:33.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.924]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.924]         }
[10:59:33.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.924]             base::sink(type = "output", split = FALSE)
[10:59:33.924]             base::close(...future.stdout)
[10:59:33.924]         }, add = TRUE)
[10:59:33.924]     }
[10:59:33.924]     ...future.frame <- base::sys.nframe()
[10:59:33.924]     ...future.conditions <- base::list()
[10:59:33.924]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.924]     if (FALSE) {
[10:59:33.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.924]     }
[10:59:33.924]     ...future.result <- base::tryCatch({
[10:59:33.924]         base::withCallingHandlers({
[10:59:33.924]             ...future.value <- base::withVisible(base::local({
[10:59:33.924]                 withCallingHandlers({
[10:59:33.924]                   {
[10:59:33.924]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.924]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.924]                       ...future.globals.maxSize)) {
[10:59:33.924]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.924]                       on.exit(options(oopts), add = TRUE)
[10:59:33.924]                     }
[10:59:33.924]                     {
[10:59:33.924]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.924]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.924]                         USE.NAMES = FALSE)
[10:59:33.924]                       do.call(mapply, args = args)
[10:59:33.924]                     }
[10:59:33.924]                   }
[10:59:33.924]                 }, immediateCondition = function(cond) {
[10:59:33.924]                   save_rds <- function (object, pathname, ...) 
[10:59:33.924]                   {
[10:59:33.924]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.924]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.924]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.924]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.924]                         fi_tmp[["mtime"]])
[10:59:33.924]                     }
[10:59:33.924]                     tryCatch({
[10:59:33.924]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.924]                     }, error = function(ex) {
[10:59:33.924]                       msg <- conditionMessage(ex)
[10:59:33.924]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.924]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.924]                         fi_tmp[["mtime"]], msg)
[10:59:33.924]                       ex$message <- msg
[10:59:33.924]                       stop(ex)
[10:59:33.924]                     })
[10:59:33.924]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.924]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.924]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.924]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.924]                       fi <- file.info(pathname)
[10:59:33.924]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.924]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.924]                         fi[["size"]], fi[["mtime"]])
[10:59:33.924]                       stop(msg)
[10:59:33.924]                     }
[10:59:33.924]                     invisible(pathname)
[10:59:33.924]                   }
[10:59:33.924]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.924]                     rootPath = tempdir()) 
[10:59:33.924]                   {
[10:59:33.924]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.924]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.924]                       tmpdir = path, fileext = ".rds")
[10:59:33.924]                     save_rds(obj, file)
[10:59:33.924]                   }
[10:59:33.924]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.924]                   {
[10:59:33.924]                     inherits <- base::inherits
[10:59:33.924]                     invokeRestart <- base::invokeRestart
[10:59:33.924]                     is.null <- base::is.null
[10:59:33.924]                     muffled <- FALSE
[10:59:33.924]                     if (inherits(cond, "message")) {
[10:59:33.924]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.924]                       if (muffled) 
[10:59:33.924]                         invokeRestart("muffleMessage")
[10:59:33.924]                     }
[10:59:33.924]                     else if (inherits(cond, "warning")) {
[10:59:33.924]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.924]                       if (muffled) 
[10:59:33.924]                         invokeRestart("muffleWarning")
[10:59:33.924]                     }
[10:59:33.924]                     else if (inherits(cond, "condition")) {
[10:59:33.924]                       if (!is.null(pattern)) {
[10:59:33.924]                         computeRestarts <- base::computeRestarts
[10:59:33.924]                         grepl <- base::grepl
[10:59:33.924]                         restarts <- computeRestarts(cond)
[10:59:33.924]                         for (restart in restarts) {
[10:59:33.924]                           name <- restart$name
[10:59:33.924]                           if (is.null(name)) 
[10:59:33.924]                             next
[10:59:33.924]                           if (!grepl(pattern, name)) 
[10:59:33.924]                             next
[10:59:33.924]                           invokeRestart(restart)
[10:59:33.924]                           muffled <- TRUE
[10:59:33.924]                           break
[10:59:33.924]                         }
[10:59:33.924]                       }
[10:59:33.924]                     }
[10:59:33.924]                     invisible(muffled)
[10:59:33.924]                   }
[10:59:33.924]                   muffleCondition(cond)
[10:59:33.924]                 })
[10:59:33.924]             }))
[10:59:33.924]             future::FutureResult(value = ...future.value$value, 
[10:59:33.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.924]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.924]                     ...future.globalenv.names))
[10:59:33.924]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.924]         }, condition = base::local({
[10:59:33.924]             c <- base::c
[10:59:33.924]             inherits <- base::inherits
[10:59:33.924]             invokeRestart <- base::invokeRestart
[10:59:33.924]             length <- base::length
[10:59:33.924]             list <- base::list
[10:59:33.924]             seq.int <- base::seq.int
[10:59:33.924]             signalCondition <- base::signalCondition
[10:59:33.924]             sys.calls <- base::sys.calls
[10:59:33.924]             `[[` <- base::`[[`
[10:59:33.924]             `+` <- base::`+`
[10:59:33.924]             `<<-` <- base::`<<-`
[10:59:33.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.924]                   3L)]
[10:59:33.924]             }
[10:59:33.924]             function(cond) {
[10:59:33.924]                 is_error <- inherits(cond, "error")
[10:59:33.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.924]                   NULL)
[10:59:33.924]                 if (is_error) {
[10:59:33.924]                   sessionInformation <- function() {
[10:59:33.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.924]                       search = base::search(), system = base::Sys.info())
[10:59:33.924]                   }
[10:59:33.924]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.924]                     cond$call), session = sessionInformation(), 
[10:59:33.924]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.924]                   signalCondition(cond)
[10:59:33.924]                 }
[10:59:33.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.924]                 "immediateCondition"))) {
[10:59:33.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.924]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.924]                   if (TRUE && !signal) {
[10:59:33.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.924]                     {
[10:59:33.924]                       inherits <- base::inherits
[10:59:33.924]                       invokeRestart <- base::invokeRestart
[10:59:33.924]                       is.null <- base::is.null
[10:59:33.924]                       muffled <- FALSE
[10:59:33.924]                       if (inherits(cond, "message")) {
[10:59:33.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.924]                         if (muffled) 
[10:59:33.924]                           invokeRestart("muffleMessage")
[10:59:33.924]                       }
[10:59:33.924]                       else if (inherits(cond, "warning")) {
[10:59:33.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.924]                         if (muffled) 
[10:59:33.924]                           invokeRestart("muffleWarning")
[10:59:33.924]                       }
[10:59:33.924]                       else if (inherits(cond, "condition")) {
[10:59:33.924]                         if (!is.null(pattern)) {
[10:59:33.924]                           computeRestarts <- base::computeRestarts
[10:59:33.924]                           grepl <- base::grepl
[10:59:33.924]                           restarts <- computeRestarts(cond)
[10:59:33.924]                           for (restart in restarts) {
[10:59:33.924]                             name <- restart$name
[10:59:33.924]                             if (is.null(name)) 
[10:59:33.924]                               next
[10:59:33.924]                             if (!grepl(pattern, name)) 
[10:59:33.924]                               next
[10:59:33.924]                             invokeRestart(restart)
[10:59:33.924]                             muffled <- TRUE
[10:59:33.924]                             break
[10:59:33.924]                           }
[10:59:33.924]                         }
[10:59:33.924]                       }
[10:59:33.924]                       invisible(muffled)
[10:59:33.924]                     }
[10:59:33.924]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.924]                   }
[10:59:33.924]                 }
[10:59:33.924]                 else {
[10:59:33.924]                   if (TRUE) {
[10:59:33.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.924]                     {
[10:59:33.924]                       inherits <- base::inherits
[10:59:33.924]                       invokeRestart <- base::invokeRestart
[10:59:33.924]                       is.null <- base::is.null
[10:59:33.924]                       muffled <- FALSE
[10:59:33.924]                       if (inherits(cond, "message")) {
[10:59:33.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.924]                         if (muffled) 
[10:59:33.924]                           invokeRestart("muffleMessage")
[10:59:33.924]                       }
[10:59:33.924]                       else if (inherits(cond, "warning")) {
[10:59:33.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.924]                         if (muffled) 
[10:59:33.924]                           invokeRestart("muffleWarning")
[10:59:33.924]                       }
[10:59:33.924]                       else if (inherits(cond, "condition")) {
[10:59:33.924]                         if (!is.null(pattern)) {
[10:59:33.924]                           computeRestarts <- base::computeRestarts
[10:59:33.924]                           grepl <- base::grepl
[10:59:33.924]                           restarts <- computeRestarts(cond)
[10:59:33.924]                           for (restart in restarts) {
[10:59:33.924]                             name <- restart$name
[10:59:33.924]                             if (is.null(name)) 
[10:59:33.924]                               next
[10:59:33.924]                             if (!grepl(pattern, name)) 
[10:59:33.924]                               next
[10:59:33.924]                             invokeRestart(restart)
[10:59:33.924]                             muffled <- TRUE
[10:59:33.924]                             break
[10:59:33.924]                           }
[10:59:33.924]                         }
[10:59:33.924]                       }
[10:59:33.924]                       invisible(muffled)
[10:59:33.924]                     }
[10:59:33.924]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.924]                   }
[10:59:33.924]                 }
[10:59:33.924]             }
[10:59:33.924]         }))
[10:59:33.924]     }, error = function(ex) {
[10:59:33.924]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.924]                 ...future.rng), started = ...future.startTime, 
[10:59:33.924]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.924]             version = "1.8"), class = "FutureResult")
[10:59:33.924]     }, finally = {
[10:59:33.924]         if (!identical(...future.workdir, getwd())) 
[10:59:33.924]             setwd(...future.workdir)
[10:59:33.924]         {
[10:59:33.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.924]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.924]             }
[10:59:33.924]             base::options(...future.oldOptions)
[10:59:33.924]             if (.Platform$OS.type == "windows") {
[10:59:33.924]                 old_names <- names(...future.oldEnvVars)
[10:59:33.924]                 envs <- base::Sys.getenv()
[10:59:33.924]                 names <- names(envs)
[10:59:33.924]                 common <- intersect(names, old_names)
[10:59:33.924]                 added <- setdiff(names, old_names)
[10:59:33.924]                 removed <- setdiff(old_names, names)
[10:59:33.924]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.924]                   envs[common]]
[10:59:33.924]                 NAMES <- toupper(changed)
[10:59:33.924]                 args <- list()
[10:59:33.924]                 for (kk in seq_along(NAMES)) {
[10:59:33.924]                   name <- changed[[kk]]
[10:59:33.924]                   NAME <- NAMES[[kk]]
[10:59:33.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.924]                     next
[10:59:33.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.924]                 }
[10:59:33.924]                 NAMES <- toupper(added)
[10:59:33.924]                 for (kk in seq_along(NAMES)) {
[10:59:33.924]                   name <- added[[kk]]
[10:59:33.924]                   NAME <- NAMES[[kk]]
[10:59:33.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.924]                     next
[10:59:33.924]                   args[[name]] <- ""
[10:59:33.924]                 }
[10:59:33.924]                 NAMES <- toupper(removed)
[10:59:33.924]                 for (kk in seq_along(NAMES)) {
[10:59:33.924]                   name <- removed[[kk]]
[10:59:33.924]                   NAME <- NAMES[[kk]]
[10:59:33.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.924]                     next
[10:59:33.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.924]                 }
[10:59:33.924]                 if (length(args) > 0) 
[10:59:33.924]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.924]             }
[10:59:33.924]             else {
[10:59:33.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.924]             }
[10:59:33.924]             {
[10:59:33.924]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.924]                   0L) {
[10:59:33.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.924]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.924]                   base::options(opts)
[10:59:33.924]                 }
[10:59:33.924]                 {
[10:59:33.924]                   {
[10:59:33.924]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.924]                     NULL
[10:59:33.924]                   }
[10:59:33.924]                   options(future.plan = NULL)
[10:59:33.924]                   if (is.na(NA_character_)) 
[10:59:33.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.924]                     .init = FALSE)
[10:59:33.924]                 }
[10:59:33.924]             }
[10:59:33.924]         }
[10:59:33.924]     })
[10:59:33.924]     if (TRUE) {
[10:59:33.924]         base::sink(type = "output", split = FALSE)
[10:59:33.924]         if (TRUE) {
[10:59:33.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.924]         }
[10:59:33.924]         else {
[10:59:33.924]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.924]         }
[10:59:33.924]         base::close(...future.stdout)
[10:59:33.924]         ...future.stdout <- NULL
[10:59:33.924]     }
[10:59:33.924]     ...future.result$conditions <- ...future.conditions
[10:59:33.924]     ...future.result$finished <- base::Sys.time()
[10:59:33.924]     ...future.result
[10:59:33.924] }
[10:59:33.926] assign_globals() ...
[10:59:33.926] List of 5
[10:59:33.926]  $ ...future.FUN            :function (e1, e2)  
[10:59:33.926]  $ MoreArgs                 : NULL
[10:59:33.926]  $ ...future.elements_ii    :List of 2
[10:59:33.926]   ..$ :List of 1
[10:59:33.926]   .. ..$ : num 1
[10:59:33.926]   ..$ :List of 1
[10:59:33.926]   .. ..$ : int 1
[10:59:33.926]  $ ...future.seeds_ii       : NULL
[10:59:33.926]  $ ...future.globals.maxSize: NULL
[10:59:33.926]  - attr(*, "where")=List of 5
[10:59:33.926]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.926]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.926]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.926]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.926]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.926]  - attr(*, "resolved")= logi FALSE
[10:59:33.926]  - attr(*, "total_size")= num 188
[10:59:33.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.926]  - attr(*, "already-done")= logi TRUE
[10:59:33.932] - copied ‘...future.FUN’ to environment
[10:59:33.932] - copied ‘MoreArgs’ to environment
[10:59:33.932] - copied ‘...future.elements_ii’ to environment
[10:59:33.932] - copied ‘...future.seeds_ii’ to environment
[10:59:33.933] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.933] assign_globals() ... done
[10:59:33.933] requestCore(): workers = 2
[10:59:33.935] MulticoreFuture started
[10:59:33.935] - Launch lazy future ... done
[10:59:33.935] run() for ‘MulticoreFuture’ ... done
[10:59:33.935] Created future:
[10:59:33.936] plan(): Setting new future strategy stack:
[10:59:33.936] List of future strategies:
[10:59:33.936] 1. sequential:
[10:59:33.936]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.936]    - tweaked: FALSE
[10:59:33.936]    - call: NULL
[10:59:33.937] plan(): nbrOfWorkers() = 1
[10:59:33.939] plan(): Setting new future strategy stack:
[10:59:33.939] List of future strategies:
[10:59:33.939] 1. multicore:
[10:59:33.939]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.939]    - tweaked: FALSE
[10:59:33.939]    - call: plan(strategy)
[10:59:33.942] plan(): nbrOfWorkers() = 2
[10:59:33.936] MulticoreFuture:
[10:59:33.936] Label: ‘future_Map-1’
[10:59:33.936] Expression:
[10:59:33.936] {
[10:59:33.936]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.936]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.936]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.936]         on.exit(options(oopts), add = TRUE)
[10:59:33.936]     }
[10:59:33.936]     {
[10:59:33.936]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.936]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.936]         do.call(mapply, args = args)
[10:59:33.936]     }
[10:59:33.936] }
[10:59:33.936] Lazy evaluation: FALSE
[10:59:33.936] Asynchronous evaluation: TRUE
[10:59:33.936] Local evaluation: TRUE
[10:59:33.936] Environment: R_GlobalEnv
[10:59:33.936] Capture standard output: TRUE
[10:59:33.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.936] Globals: 5 objects totaling 188 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 75 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.936] Packages: <none>
[10:59:33.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.936] Resolved: TRUE
[10:59:33.936] Value: <not collected>
[10:59:33.936] Conditions captured: <none>
[10:59:33.936] Early signaling: FALSE
[10:59:33.936] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.936] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.943] Chunk #1 of 2 ... DONE
[10:59:33.943] Chunk #2 of 2 ...
[10:59:33.943]  - Finding globals in '...' for chunk #2 ...
[10:59:33.943] getGlobalsAndPackages() ...
[10:59:33.943] Searching for globals...
[10:59:33.944] 
[10:59:33.944] Searching for globals ... DONE
[10:59:33.944] - globals: [0] <none>
[10:59:33.944] getGlobalsAndPackages() ... DONE
[10:59:33.944]    + additional globals found: [n=0] 
[10:59:33.944]    + additional namespaces needed: [n=0] 
[10:59:33.944]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:33.944]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:33.945]  - seeds: <none>
[10:59:33.945]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.945] getGlobalsAndPackages() ...
[10:59:33.945] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.945] Resolving globals: FALSE
[10:59:33.946] The total size of the 5 globals is 216 bytes (216 bytes)
[10:59:33.946] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 216 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (103 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:33.947] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:33.947] 
[10:59:33.947] getGlobalsAndPackages() ... DONE
[10:59:33.947] run() for ‘Future’ ...
[10:59:33.948] - state: ‘created’
[10:59:33.948] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:33.950] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:33.950]   - Field: ‘label’
[10:59:33.950]   - Field: ‘local’
[10:59:33.951]   - Field: ‘owner’
[10:59:33.951]   - Field: ‘envir’
[10:59:33.951]   - Field: ‘workers’
[10:59:33.951]   - Field: ‘packages’
[10:59:33.951]   - Field: ‘gc’
[10:59:33.951]   - Field: ‘job’
[10:59:33.951]   - Field: ‘conditions’
[10:59:33.951]   - Field: ‘expr’
[10:59:33.951]   - Field: ‘uuid’
[10:59:33.952]   - Field: ‘seed’
[10:59:33.952]   - Field: ‘version’
[10:59:33.952]   - Field: ‘result’
[10:59:33.952]   - Field: ‘asynchronous’
[10:59:33.952]   - Field: ‘calls’
[10:59:33.952]   - Field: ‘globals’
[10:59:33.952]   - Field: ‘stdout’
[10:59:33.952]   - Field: ‘earlySignal’
[10:59:33.953]   - Field: ‘lazy’
[10:59:33.953]   - Field: ‘state’
[10:59:33.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:33.953] - Launch lazy future ...
[10:59:33.953] Packages needed by the future expression (n = 0): <none>
[10:59:33.953] Packages needed by future strategies (n = 0): <none>
[10:59:33.954] {
[10:59:33.954]     {
[10:59:33.954]         {
[10:59:33.954]             ...future.startTime <- base::Sys.time()
[10:59:33.954]             {
[10:59:33.954]                 {
[10:59:33.954]                   {
[10:59:33.954]                     {
[10:59:33.954]                       base::local({
[10:59:33.954]                         has_future <- base::requireNamespace("future", 
[10:59:33.954]                           quietly = TRUE)
[10:59:33.954]                         if (has_future) {
[10:59:33.954]                           ns <- base::getNamespace("future")
[10:59:33.954]                           version <- ns[[".package"]][["version"]]
[10:59:33.954]                           if (is.null(version)) 
[10:59:33.954]                             version <- utils::packageVersion("future")
[10:59:33.954]                         }
[10:59:33.954]                         else {
[10:59:33.954]                           version <- NULL
[10:59:33.954]                         }
[10:59:33.954]                         if (!has_future || version < "1.8.0") {
[10:59:33.954]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:33.954]                             "", base::R.version$version.string), 
[10:59:33.954]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:33.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:33.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:33.954]                               "release", "version")], collapse = " "), 
[10:59:33.954]                             hostname = base::Sys.info()[["nodename"]])
[10:59:33.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:33.954]                             info)
[10:59:33.954]                           info <- base::paste(info, collapse = "; ")
[10:59:33.954]                           if (!has_future) {
[10:59:33.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:33.954]                               info)
[10:59:33.954]                           }
[10:59:33.954]                           else {
[10:59:33.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:33.954]                               info, version)
[10:59:33.954]                           }
[10:59:33.954]                           base::stop(msg)
[10:59:33.954]                         }
[10:59:33.954]                       })
[10:59:33.954]                     }
[10:59:33.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:33.954]                     base::options(mc.cores = 1L)
[10:59:33.954]                   }
[10:59:33.954]                   ...future.strategy.old <- future::plan("list")
[10:59:33.954]                   options(future.plan = NULL)
[10:59:33.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:33.954]                 }
[10:59:33.954]                 ...future.workdir <- getwd()
[10:59:33.954]             }
[10:59:33.954]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:33.954]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:33.954]         }
[10:59:33.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:33.954]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:33.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:33.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:33.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:33.954]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:33.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:33.954]             base::names(...future.oldOptions))
[10:59:33.954]     }
[10:59:33.954]     if (FALSE) {
[10:59:33.954]     }
[10:59:33.954]     else {
[10:59:33.954]         if (TRUE) {
[10:59:33.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:33.954]                 open = "w")
[10:59:33.954]         }
[10:59:33.954]         else {
[10:59:33.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:33.954]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:33.954]         }
[10:59:33.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:33.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:33.954]             base::sink(type = "output", split = FALSE)
[10:59:33.954]             base::close(...future.stdout)
[10:59:33.954]         }, add = TRUE)
[10:59:33.954]     }
[10:59:33.954]     ...future.frame <- base::sys.nframe()
[10:59:33.954]     ...future.conditions <- base::list()
[10:59:33.954]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:33.954]     if (FALSE) {
[10:59:33.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:33.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:33.954]     }
[10:59:33.954]     ...future.result <- base::tryCatch({
[10:59:33.954]         base::withCallingHandlers({
[10:59:33.954]             ...future.value <- base::withVisible(base::local({
[10:59:33.954]                 withCallingHandlers({
[10:59:33.954]                   {
[10:59:33.954]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.954]                     if (!identical(...future.globals.maxSize.org, 
[10:59:33.954]                       ...future.globals.maxSize)) {
[10:59:33.954]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.954]                       on.exit(options(oopts), add = TRUE)
[10:59:33.954]                     }
[10:59:33.954]                     {
[10:59:33.954]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.954]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:33.954]                         USE.NAMES = FALSE)
[10:59:33.954]                       do.call(mapply, args = args)
[10:59:33.954]                     }
[10:59:33.954]                   }
[10:59:33.954]                 }, immediateCondition = function(cond) {
[10:59:33.954]                   save_rds <- function (object, pathname, ...) 
[10:59:33.954]                   {
[10:59:33.954]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:33.954]                     if (file_test("-f", pathname_tmp)) {
[10:59:33.954]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.954]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:33.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.954]                         fi_tmp[["mtime"]])
[10:59:33.954]                     }
[10:59:33.954]                     tryCatch({
[10:59:33.954]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:33.954]                     }, error = function(ex) {
[10:59:33.954]                       msg <- conditionMessage(ex)
[10:59:33.954]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.954]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:33.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.954]                         fi_tmp[["mtime"]], msg)
[10:59:33.954]                       ex$message <- msg
[10:59:33.954]                       stop(ex)
[10:59:33.954]                     })
[10:59:33.954]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:33.954]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:33.954]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:33.954]                       fi_tmp <- file.info(pathname_tmp)
[10:59:33.954]                       fi <- file.info(pathname)
[10:59:33.954]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:33.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:33.954]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:33.954]                         fi[["size"]], fi[["mtime"]])
[10:59:33.954]                       stop(msg)
[10:59:33.954]                     }
[10:59:33.954]                     invisible(pathname)
[10:59:33.954]                   }
[10:59:33.954]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:33.954]                     rootPath = tempdir()) 
[10:59:33.954]                   {
[10:59:33.954]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:33.954]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:33.954]                       tmpdir = path, fileext = ".rds")
[10:59:33.954]                     save_rds(obj, file)
[10:59:33.954]                   }
[10:59:33.954]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:33.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.954]                   {
[10:59:33.954]                     inherits <- base::inherits
[10:59:33.954]                     invokeRestart <- base::invokeRestart
[10:59:33.954]                     is.null <- base::is.null
[10:59:33.954]                     muffled <- FALSE
[10:59:33.954]                     if (inherits(cond, "message")) {
[10:59:33.954]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:33.954]                       if (muffled) 
[10:59:33.954]                         invokeRestart("muffleMessage")
[10:59:33.954]                     }
[10:59:33.954]                     else if (inherits(cond, "warning")) {
[10:59:33.954]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:33.954]                       if (muffled) 
[10:59:33.954]                         invokeRestart("muffleWarning")
[10:59:33.954]                     }
[10:59:33.954]                     else if (inherits(cond, "condition")) {
[10:59:33.954]                       if (!is.null(pattern)) {
[10:59:33.954]                         computeRestarts <- base::computeRestarts
[10:59:33.954]                         grepl <- base::grepl
[10:59:33.954]                         restarts <- computeRestarts(cond)
[10:59:33.954]                         for (restart in restarts) {
[10:59:33.954]                           name <- restart$name
[10:59:33.954]                           if (is.null(name)) 
[10:59:33.954]                             next
[10:59:33.954]                           if (!grepl(pattern, name)) 
[10:59:33.954]                             next
[10:59:33.954]                           invokeRestart(restart)
[10:59:33.954]                           muffled <- TRUE
[10:59:33.954]                           break
[10:59:33.954]                         }
[10:59:33.954]                       }
[10:59:33.954]                     }
[10:59:33.954]                     invisible(muffled)
[10:59:33.954]                   }
[10:59:33.954]                   muffleCondition(cond)
[10:59:33.954]                 })
[10:59:33.954]             }))
[10:59:33.954]             future::FutureResult(value = ...future.value$value, 
[10:59:33.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.954]                   ...future.rng), globalenv = if (FALSE) 
[10:59:33.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:33.954]                     ...future.globalenv.names))
[10:59:33.954]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:33.954]         }, condition = base::local({
[10:59:33.954]             c <- base::c
[10:59:33.954]             inherits <- base::inherits
[10:59:33.954]             invokeRestart <- base::invokeRestart
[10:59:33.954]             length <- base::length
[10:59:33.954]             list <- base::list
[10:59:33.954]             seq.int <- base::seq.int
[10:59:33.954]             signalCondition <- base::signalCondition
[10:59:33.954]             sys.calls <- base::sys.calls
[10:59:33.954]             `[[` <- base::`[[`
[10:59:33.954]             `+` <- base::`+`
[10:59:33.954]             `<<-` <- base::`<<-`
[10:59:33.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:33.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:33.954]                   3L)]
[10:59:33.954]             }
[10:59:33.954]             function(cond) {
[10:59:33.954]                 is_error <- inherits(cond, "error")
[10:59:33.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:33.954]                   NULL)
[10:59:33.954]                 if (is_error) {
[10:59:33.954]                   sessionInformation <- function() {
[10:59:33.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:33.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:33.954]                       search = base::search(), system = base::Sys.info())
[10:59:33.954]                   }
[10:59:33.954]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:33.954]                     cond$call), session = sessionInformation(), 
[10:59:33.954]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:33.954]                   signalCondition(cond)
[10:59:33.954]                 }
[10:59:33.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:33.954]                 "immediateCondition"))) {
[10:59:33.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:33.954]                   ...future.conditions[[length(...future.conditions) + 
[10:59:33.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:33.954]                   if (TRUE && !signal) {
[10:59:33.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.954]                     {
[10:59:33.954]                       inherits <- base::inherits
[10:59:33.954]                       invokeRestart <- base::invokeRestart
[10:59:33.954]                       is.null <- base::is.null
[10:59:33.954]                       muffled <- FALSE
[10:59:33.954]                       if (inherits(cond, "message")) {
[10:59:33.954]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.954]                         if (muffled) 
[10:59:33.954]                           invokeRestart("muffleMessage")
[10:59:33.954]                       }
[10:59:33.954]                       else if (inherits(cond, "warning")) {
[10:59:33.954]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.954]                         if (muffled) 
[10:59:33.954]                           invokeRestart("muffleWarning")
[10:59:33.954]                       }
[10:59:33.954]                       else if (inherits(cond, "condition")) {
[10:59:33.954]                         if (!is.null(pattern)) {
[10:59:33.954]                           computeRestarts <- base::computeRestarts
[10:59:33.954]                           grepl <- base::grepl
[10:59:33.954]                           restarts <- computeRestarts(cond)
[10:59:33.954]                           for (restart in restarts) {
[10:59:33.954]                             name <- restart$name
[10:59:33.954]                             if (is.null(name)) 
[10:59:33.954]                               next
[10:59:33.954]                             if (!grepl(pattern, name)) 
[10:59:33.954]                               next
[10:59:33.954]                             invokeRestart(restart)
[10:59:33.954]                             muffled <- TRUE
[10:59:33.954]                             break
[10:59:33.954]                           }
[10:59:33.954]                         }
[10:59:33.954]                       }
[10:59:33.954]                       invisible(muffled)
[10:59:33.954]                     }
[10:59:33.954]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.954]                   }
[10:59:33.954]                 }
[10:59:33.954]                 else {
[10:59:33.954]                   if (TRUE) {
[10:59:33.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:33.954]                     {
[10:59:33.954]                       inherits <- base::inherits
[10:59:33.954]                       invokeRestart <- base::invokeRestart
[10:59:33.954]                       is.null <- base::is.null
[10:59:33.954]                       muffled <- FALSE
[10:59:33.954]                       if (inherits(cond, "message")) {
[10:59:33.954]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:33.954]                         if (muffled) 
[10:59:33.954]                           invokeRestart("muffleMessage")
[10:59:33.954]                       }
[10:59:33.954]                       else if (inherits(cond, "warning")) {
[10:59:33.954]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:33.954]                         if (muffled) 
[10:59:33.954]                           invokeRestart("muffleWarning")
[10:59:33.954]                       }
[10:59:33.954]                       else if (inherits(cond, "condition")) {
[10:59:33.954]                         if (!is.null(pattern)) {
[10:59:33.954]                           computeRestarts <- base::computeRestarts
[10:59:33.954]                           grepl <- base::grepl
[10:59:33.954]                           restarts <- computeRestarts(cond)
[10:59:33.954]                           for (restart in restarts) {
[10:59:33.954]                             name <- restart$name
[10:59:33.954]                             if (is.null(name)) 
[10:59:33.954]                               next
[10:59:33.954]                             if (!grepl(pattern, name)) 
[10:59:33.954]                               next
[10:59:33.954]                             invokeRestart(restart)
[10:59:33.954]                             muffled <- TRUE
[10:59:33.954]                             break
[10:59:33.954]                           }
[10:59:33.954]                         }
[10:59:33.954]                       }
[10:59:33.954]                       invisible(muffled)
[10:59:33.954]                     }
[10:59:33.954]                     muffleCondition(cond, pattern = "^muffle")
[10:59:33.954]                   }
[10:59:33.954]                 }
[10:59:33.954]             }
[10:59:33.954]         }))
[10:59:33.954]     }, error = function(ex) {
[10:59:33.954]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:33.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:33.954]                 ...future.rng), started = ...future.startTime, 
[10:59:33.954]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:33.954]             version = "1.8"), class = "FutureResult")
[10:59:33.954]     }, finally = {
[10:59:33.954]         if (!identical(...future.workdir, getwd())) 
[10:59:33.954]             setwd(...future.workdir)
[10:59:33.954]         {
[10:59:33.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:33.954]                 ...future.oldOptions$nwarnings <- NULL
[10:59:33.954]             }
[10:59:33.954]             base::options(...future.oldOptions)
[10:59:33.954]             if (.Platform$OS.type == "windows") {
[10:59:33.954]                 old_names <- names(...future.oldEnvVars)
[10:59:33.954]                 envs <- base::Sys.getenv()
[10:59:33.954]                 names <- names(envs)
[10:59:33.954]                 common <- intersect(names, old_names)
[10:59:33.954]                 added <- setdiff(names, old_names)
[10:59:33.954]                 removed <- setdiff(old_names, names)
[10:59:33.954]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:33.954]                   envs[common]]
[10:59:33.954]                 NAMES <- toupper(changed)
[10:59:33.954]                 args <- list()
[10:59:33.954]                 for (kk in seq_along(NAMES)) {
[10:59:33.954]                   name <- changed[[kk]]
[10:59:33.954]                   NAME <- NAMES[[kk]]
[10:59:33.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.954]                     next
[10:59:33.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.954]                 }
[10:59:33.954]                 NAMES <- toupper(added)
[10:59:33.954]                 for (kk in seq_along(NAMES)) {
[10:59:33.954]                   name <- added[[kk]]
[10:59:33.954]                   NAME <- NAMES[[kk]]
[10:59:33.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.954]                     next
[10:59:33.954]                   args[[name]] <- ""
[10:59:33.954]                 }
[10:59:33.954]                 NAMES <- toupper(removed)
[10:59:33.954]                 for (kk in seq_along(NAMES)) {
[10:59:33.954]                   name <- removed[[kk]]
[10:59:33.954]                   NAME <- NAMES[[kk]]
[10:59:33.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:33.954]                     next
[10:59:33.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:33.954]                 }
[10:59:33.954]                 if (length(args) > 0) 
[10:59:33.954]                   base::do.call(base::Sys.setenv, args = args)
[10:59:33.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:33.954]             }
[10:59:33.954]             else {
[10:59:33.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:33.954]             }
[10:59:33.954]             {
[10:59:33.954]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:33.954]                   0L) {
[10:59:33.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:33.954]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:33.954]                   base::options(opts)
[10:59:33.954]                 }
[10:59:33.954]                 {
[10:59:33.954]                   {
[10:59:33.954]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:33.954]                     NULL
[10:59:33.954]                   }
[10:59:33.954]                   options(future.plan = NULL)
[10:59:33.954]                   if (is.na(NA_character_)) 
[10:59:33.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:33.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:33.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:33.954]                     .init = FALSE)
[10:59:33.954]                 }
[10:59:33.954]             }
[10:59:33.954]         }
[10:59:33.954]     })
[10:59:33.954]     if (TRUE) {
[10:59:33.954]         base::sink(type = "output", split = FALSE)
[10:59:33.954]         if (TRUE) {
[10:59:33.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:33.954]         }
[10:59:33.954]         else {
[10:59:33.954]             ...future.result["stdout"] <- base::list(NULL)
[10:59:33.954]         }
[10:59:33.954]         base::close(...future.stdout)
[10:59:33.954]         ...future.stdout <- NULL
[10:59:33.954]     }
[10:59:33.954]     ...future.result$conditions <- ...future.conditions
[10:59:33.954]     ...future.result$finished <- base::Sys.time()
[10:59:33.954]     ...future.result
[10:59:33.954] }
[10:59:33.957] assign_globals() ...
[10:59:33.957] List of 5
[10:59:33.957]  $ ...future.FUN            :function (e1, e2)  
[10:59:33.957]  $ MoreArgs                 : NULL
[10:59:33.957]  $ ...future.elements_ii    :List of 2
[10:59:33.957]   ..$ :List of 2
[10:59:33.957]   .. ..$ : num 1
[10:59:33.957]   .. ..$ : num 1
[10:59:33.957]   ..$ :List of 2
[10:59:33.957]   .. ..$ : int 2
[10:59:33.957]   .. ..$ : int 3
[10:59:33.957]  $ ...future.seeds_ii       : NULL
[10:59:33.957]  $ ...future.globals.maxSize: NULL
[10:59:33.957]  - attr(*, "where")=List of 5
[10:59:33.957]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:33.957]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:33.957]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:33.957]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:33.957]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:33.957]  - attr(*, "resolved")= logi FALSE
[10:59:33.957]  - attr(*, "total_size")= num 216
[10:59:33.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:33.957]  - attr(*, "already-done")= logi TRUE
[10:59:33.970] - copied ‘...future.FUN’ to environment
[10:59:33.970] - copied ‘MoreArgs’ to environment
[10:59:33.970] - copied ‘...future.elements_ii’ to environment
[10:59:33.971] - copied ‘...future.seeds_ii’ to environment
[10:59:33.971] - copied ‘...future.globals.maxSize’ to environment
[10:59:33.971] assign_globals() ... done
[10:59:33.971] requestCore(): workers = 2
[10:59:33.973] MulticoreFuture started
[10:59:33.974] - Launch lazy future ... done
[10:59:33.974] run() for ‘MulticoreFuture’ ... done
[10:59:33.974] Created future:
[10:59:33.975] plan(): Setting new future strategy stack:
[10:59:33.975] List of future strategies:
[10:59:33.975] 1. sequential:
[10:59:33.975]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:33.975]    - tweaked: FALSE
[10:59:33.975]    - call: NULL
[10:59:33.976] plan(): nbrOfWorkers() = 1
[10:59:33.978] plan(): Setting new future strategy stack:
[10:59:33.978] List of future strategies:
[10:59:33.978] 1. multicore:
[10:59:33.978]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:33.978]    - tweaked: FALSE
[10:59:33.978]    - call: plan(strategy)
[10:59:33.981] plan(): nbrOfWorkers() = 2
[10:59:33.974] MulticoreFuture:
[10:59:33.974] Label: ‘future_Map-2’
[10:59:33.974] Expression:
[10:59:33.974] {
[10:59:33.974]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:33.974]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:33.974]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:33.974]         on.exit(options(oopts), add = TRUE)
[10:59:33.974]     }
[10:59:33.974]     {
[10:59:33.974]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:33.974]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:33.974]         do.call(mapply, args = args)
[10:59:33.974]     }
[10:59:33.974] }
[10:59:33.974] Lazy evaluation: FALSE
[10:59:33.974] Asynchronous evaluation: TRUE
[10:59:33.974] Local evaluation: TRUE
[10:59:33.974] Environment: R_GlobalEnv
[10:59:33.974] Capture standard output: TRUE
[10:59:33.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:33.974] Globals: 5 objects totaling 216 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:33.974] Packages: <none>
[10:59:33.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:33.974] Resolved: TRUE
[10:59:33.974] Value: <not collected>
[10:59:33.974] Conditions captured: <none>
[10:59:33.974] Early signaling: FALSE
[10:59:33.974] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:33.974] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:33.982] Chunk #2 of 2 ... DONE
[10:59:33.982] Launching 2 futures (chunks) ... DONE
[10:59:33.982] Resolving 2 futures (chunks) ...
[10:59:33.982] resolve() on list ...
[10:59:33.982]  recursive: 0
[10:59:33.983]  length: 2
[10:59:33.983] 
[10:59:33.983] Future #1
[10:59:33.983] result() for MulticoreFuture ...
[10:59:33.984] result() for MulticoreFuture ...
[10:59:33.984] result() for MulticoreFuture ... done
[10:59:33.984] result() for MulticoreFuture ... done
[10:59:33.984] result() for MulticoreFuture ...
[10:59:33.985] result() for MulticoreFuture ... done
[10:59:33.985] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:33.985] - nx: 2
[10:59:33.985] - relay: TRUE
[10:59:33.985] - stdout: TRUE
[10:59:33.985] - signal: TRUE
[10:59:33.985] - resignal: FALSE
[10:59:33.985] - force: TRUE
[10:59:33.986] - relayed: [n=2] FALSE, FALSE
[10:59:33.986] - queued futures: [n=2] FALSE, FALSE
[10:59:33.986]  - until=1
[10:59:33.986]  - relaying element #1
[10:59:33.986] result() for MulticoreFuture ...
[10:59:33.986] result() for MulticoreFuture ... done
[10:59:33.986] result() for MulticoreFuture ...
[10:59:33.986] result() for MulticoreFuture ... done
[10:59:33.987] result() for MulticoreFuture ...
[10:59:33.987] result() for MulticoreFuture ... done
[10:59:33.987] result() for MulticoreFuture ...
[10:59:33.987] result() for MulticoreFuture ... done
[10:59:33.987] - relayed: [n=2] TRUE, FALSE
[10:59:33.987] - queued futures: [n=2] TRUE, FALSE
[10:59:33.987] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:33.988]  length: 1 (resolved future 1)
[10:59:33.988] Future #2
[10:59:33.988] result() for MulticoreFuture ...
[10:59:33.989] result() for MulticoreFuture ...
[10:59:33.989] result() for MulticoreFuture ... done
[10:59:33.989] result() for MulticoreFuture ... done
[10:59:33.989] result() for MulticoreFuture ...
[10:59:33.989] result() for MulticoreFuture ... done
[10:59:33.989] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:33.990] - nx: 2
[10:59:33.990] - relay: TRUE
[10:59:33.990] - stdout: TRUE
[10:59:33.990] - signal: TRUE
[10:59:33.990] - resignal: FALSE
[10:59:33.990] - force: TRUE
[10:59:33.990] - relayed: [n=2] TRUE, FALSE
[10:59:33.990] - queued futures: [n=2] TRUE, FALSE
[10:59:33.990]  - until=2
[10:59:33.990]  - relaying element #2
[10:59:33.991] result() for MulticoreFuture ...
[10:59:33.991] result() for MulticoreFuture ... done
[10:59:33.991] result() for MulticoreFuture ...
[10:59:33.991] result() for MulticoreFuture ... done
[10:59:33.991] result() for MulticoreFuture ...
[10:59:33.991] result() for MulticoreFuture ... done
[10:59:33.991] result() for MulticoreFuture ...
[10:59:33.991] result() for MulticoreFuture ... done
[10:59:33.991] - relayed: [n=2] TRUE, TRUE
[10:59:33.992] - queued futures: [n=2] TRUE, TRUE
[10:59:33.992] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:33.992]  length: 0 (resolved future 2)
[10:59:33.992] Relaying remaining futures
[10:59:33.992] signalConditionsASAP(NULL, pos=0) ...
[10:59:33.992] - nx: 2
[10:59:33.992] - relay: TRUE
[10:59:33.992] - stdout: TRUE
[10:59:33.992] - signal: TRUE
[10:59:33.992] - resignal: FALSE
[10:59:33.993] - force: TRUE
[10:59:33.993] - relayed: [n=2] TRUE, TRUE
[10:59:33.993] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:33.993] - relayed: [n=2] TRUE, TRUE
[10:59:33.993] - queued futures: [n=2] TRUE, TRUE
[10:59:33.993] signalConditionsASAP(NULL, pos=0) ... done
[10:59:33.993] resolve() on list ... DONE
[10:59:33.993] result() for MulticoreFuture ...
[10:59:33.993] result() for MulticoreFuture ... done
[10:59:33.994] result() for MulticoreFuture ...
[10:59:33.994] result() for MulticoreFuture ... done
[10:59:33.994] result() for MulticoreFuture ...
[10:59:33.994] result() for MulticoreFuture ... done
[10:59:33.994] result() for MulticoreFuture ...
[10:59:33.994] result() for MulticoreFuture ... done
[10:59:33.994]  - Number of value chunks collected: 2
[10:59:33.994] Resolving 2 futures (chunks) ... DONE
[10:59:33.994] Reducing values from 2 chunks ...
[10:59:33.995]  - Number of values collected after concatenation: 3
[10:59:33.995]  - Number of values expected: 3
[10:59:33.995] Reducing values from 2 chunks ... DONE
[10:59:33.995] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:59:33.995] future_mapply() ...
[10:59:33.997] Number of chunks: 2
[10:59:33.998] getGlobalsAndPackagesXApply() ...
[10:59:33.998]  - future.globals: TRUE
[10:59:33.998] getGlobalsAndPackages() ...
[10:59:33.998] Searching for globals...
[10:59:33.999] - globals found: [1] ‘FUN’
[10:59:33.999] Searching for globals ... DONE
[10:59:34.000] Resolving globals: FALSE
[10:59:34.000] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:34.000] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:34.000] - globals: [1] ‘FUN’
[10:59:34.001] 
[10:59:34.001] getGlobalsAndPackages() ... DONE
[10:59:34.001]  - globals found/used: [n=1] ‘FUN’
[10:59:34.001]  - needed namespaces: [n=0] 
[10:59:34.001] Finding globals ... DONE
[10:59:34.001] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:34.001] List of 2
[10:59:34.001]  $ ...future.FUN:function (x)  
[10:59:34.001]  $ MoreArgs     : NULL
[10:59:34.001]  - attr(*, "where")=List of 2
[10:59:34.001]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:34.001]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:34.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:34.001]  - attr(*, "resolved")= logi FALSE
[10:59:34.001]  - attr(*, "total_size")= num NA
[10:59:34.004] Packages to be attached in all futures: [n=0] 
[10:59:34.005] getGlobalsAndPackagesXApply() ... DONE
[10:59:34.005] Number of futures (= number of chunks): 2
[10:59:34.005] Launching 2 futures (chunks) ...
[10:59:34.005] Chunk #1 of 2 ...
[10:59:34.005]  - Finding globals in '...' for chunk #1 ...
[10:59:34.005] getGlobalsAndPackages() ...
[10:59:34.005] Searching for globals...
[10:59:34.006] 
[10:59:34.006] Searching for globals ... DONE
[10:59:34.006] - globals: [0] <none>
[10:59:34.006] getGlobalsAndPackages() ... DONE
[10:59:34.006]    + additional globals found: [n=0] 
[10:59:34.006]    + additional namespaces needed: [n=0] 
[10:59:34.006]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:34.007]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:34.007]  - seeds: <none>
[10:59:34.007]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.007] getGlobalsAndPackages() ...
[10:59:34.007] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.007] Resolving globals: FALSE
[10:59:34.008] The total size of the 5 globals is 363 bytes (363 bytes)
[10:59:34.008] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:34.008] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.008] 
[10:59:34.008] getGlobalsAndPackages() ... DONE
[10:59:34.009] run() for ‘Future’ ...
[10:59:34.009] - state: ‘created’
[10:59:34.009] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:34.011] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.011] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:34.011]   - Field: ‘label’
[10:59:34.011]   - Field: ‘local’
[10:59:34.011]   - Field: ‘owner’
[10:59:34.011]   - Field: ‘envir’
[10:59:34.011]   - Field: ‘workers’
[10:59:34.012]   - Field: ‘packages’
[10:59:34.012]   - Field: ‘gc’
[10:59:34.012]   - Field: ‘job’
[10:59:34.012]   - Field: ‘conditions’
[10:59:34.012]   - Field: ‘expr’
[10:59:34.012]   - Field: ‘uuid’
[10:59:34.012]   - Field: ‘seed’
[10:59:34.012]   - Field: ‘version’
[10:59:34.012]   - Field: ‘result’
[10:59:34.012]   - Field: ‘asynchronous’
[10:59:34.013]   - Field: ‘calls’
[10:59:34.013]   - Field: ‘globals’
[10:59:34.013]   - Field: ‘stdout’
[10:59:34.013]   - Field: ‘earlySignal’
[10:59:34.013]   - Field: ‘lazy’
[10:59:34.013]   - Field: ‘state’
[10:59:34.013] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:34.013] - Launch lazy future ...
[10:59:34.014] Packages needed by the future expression (n = 0): <none>
[10:59:34.014] Packages needed by future strategies (n = 0): <none>
[10:59:34.014] {
[10:59:34.014]     {
[10:59:34.014]         {
[10:59:34.014]             ...future.startTime <- base::Sys.time()
[10:59:34.014]             {
[10:59:34.014]                 {
[10:59:34.014]                   {
[10:59:34.014]                     {
[10:59:34.014]                       base::local({
[10:59:34.014]                         has_future <- base::requireNamespace("future", 
[10:59:34.014]                           quietly = TRUE)
[10:59:34.014]                         if (has_future) {
[10:59:34.014]                           ns <- base::getNamespace("future")
[10:59:34.014]                           version <- ns[[".package"]][["version"]]
[10:59:34.014]                           if (is.null(version)) 
[10:59:34.014]                             version <- utils::packageVersion("future")
[10:59:34.014]                         }
[10:59:34.014]                         else {
[10:59:34.014]                           version <- NULL
[10:59:34.014]                         }
[10:59:34.014]                         if (!has_future || version < "1.8.0") {
[10:59:34.014]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:34.014]                             "", base::R.version$version.string), 
[10:59:34.014]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:34.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:34.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:34.014]                               "release", "version")], collapse = " "), 
[10:59:34.014]                             hostname = base::Sys.info()[["nodename"]])
[10:59:34.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:34.014]                             info)
[10:59:34.014]                           info <- base::paste(info, collapse = "; ")
[10:59:34.014]                           if (!has_future) {
[10:59:34.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:34.014]                               info)
[10:59:34.014]                           }
[10:59:34.014]                           else {
[10:59:34.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:34.014]                               info, version)
[10:59:34.014]                           }
[10:59:34.014]                           base::stop(msg)
[10:59:34.014]                         }
[10:59:34.014]                       })
[10:59:34.014]                     }
[10:59:34.014]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:34.014]                     base::options(mc.cores = 1L)
[10:59:34.014]                   }
[10:59:34.014]                   ...future.strategy.old <- future::plan("list")
[10:59:34.014]                   options(future.plan = NULL)
[10:59:34.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:34.014]                 }
[10:59:34.014]                 ...future.workdir <- getwd()
[10:59:34.014]             }
[10:59:34.014]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:34.014]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:34.014]         }
[10:59:34.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:34.014]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:34.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:34.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:34.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:34.014]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:34.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:34.014]             base::names(...future.oldOptions))
[10:59:34.014]     }
[10:59:34.014]     if (FALSE) {
[10:59:34.014]     }
[10:59:34.014]     else {
[10:59:34.014]         if (TRUE) {
[10:59:34.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:34.014]                 open = "w")
[10:59:34.014]         }
[10:59:34.014]         else {
[10:59:34.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:34.014]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:34.014]         }
[10:59:34.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:34.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:34.014]             base::sink(type = "output", split = FALSE)
[10:59:34.014]             base::close(...future.stdout)
[10:59:34.014]         }, add = TRUE)
[10:59:34.014]     }
[10:59:34.014]     ...future.frame <- base::sys.nframe()
[10:59:34.014]     ...future.conditions <- base::list()
[10:59:34.014]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:34.014]     if (FALSE) {
[10:59:34.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:34.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:34.014]     }
[10:59:34.014]     ...future.result <- base::tryCatch({
[10:59:34.014]         base::withCallingHandlers({
[10:59:34.014]             ...future.value <- base::withVisible(base::local({
[10:59:34.014]                 withCallingHandlers({
[10:59:34.014]                   {
[10:59:34.014]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.014]                     if (!identical(...future.globals.maxSize.org, 
[10:59:34.014]                       ...future.globals.maxSize)) {
[10:59:34.014]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.014]                       on.exit(options(oopts), add = TRUE)
[10:59:34.014]                     }
[10:59:34.014]                     {
[10:59:34.014]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.014]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:34.014]                         USE.NAMES = FALSE)
[10:59:34.014]                       do.call(mapply, args = args)
[10:59:34.014]                     }
[10:59:34.014]                   }
[10:59:34.014]                 }, immediateCondition = function(cond) {
[10:59:34.014]                   save_rds <- function (object, pathname, ...) 
[10:59:34.014]                   {
[10:59:34.014]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:34.014]                     if (file_test("-f", pathname_tmp)) {
[10:59:34.014]                       fi_tmp <- file.info(pathname_tmp)
[10:59:34.014]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:34.014]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:34.014]                         fi_tmp[["mtime"]])
[10:59:34.014]                     }
[10:59:34.014]                     tryCatch({
[10:59:34.014]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:34.014]                     }, error = function(ex) {
[10:59:34.014]                       msg <- conditionMessage(ex)
[10:59:34.014]                       fi_tmp <- file.info(pathname_tmp)
[10:59:34.014]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:34.014]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:34.014]                         fi_tmp[["mtime"]], msg)
[10:59:34.014]                       ex$message <- msg
[10:59:34.014]                       stop(ex)
[10:59:34.014]                     })
[10:59:34.014]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:34.014]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:34.014]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:34.014]                       fi_tmp <- file.info(pathname_tmp)
[10:59:34.014]                       fi <- file.info(pathname)
[10:59:34.014]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:34.014]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:34.014]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:34.014]                         fi[["size"]], fi[["mtime"]])
[10:59:34.014]                       stop(msg)
[10:59:34.014]                     }
[10:59:34.014]                     invisible(pathname)
[10:59:34.014]                   }
[10:59:34.014]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:34.014]                     rootPath = tempdir()) 
[10:59:34.014]                   {
[10:59:34.014]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:34.014]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:34.014]                       tmpdir = path, fileext = ".rds")
[10:59:34.014]                     save_rds(obj, file)
[10:59:34.014]                   }
[10:59:34.014]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:34.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.014]                   {
[10:59:34.014]                     inherits <- base::inherits
[10:59:34.014]                     invokeRestart <- base::invokeRestart
[10:59:34.014]                     is.null <- base::is.null
[10:59:34.014]                     muffled <- FALSE
[10:59:34.014]                     if (inherits(cond, "message")) {
[10:59:34.014]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:34.014]                       if (muffled) 
[10:59:34.014]                         invokeRestart("muffleMessage")
[10:59:34.014]                     }
[10:59:34.014]                     else if (inherits(cond, "warning")) {
[10:59:34.014]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:34.014]                       if (muffled) 
[10:59:34.014]                         invokeRestart("muffleWarning")
[10:59:34.014]                     }
[10:59:34.014]                     else if (inherits(cond, "condition")) {
[10:59:34.014]                       if (!is.null(pattern)) {
[10:59:34.014]                         computeRestarts <- base::computeRestarts
[10:59:34.014]                         grepl <- base::grepl
[10:59:34.014]                         restarts <- computeRestarts(cond)
[10:59:34.014]                         for (restart in restarts) {
[10:59:34.014]                           name <- restart$name
[10:59:34.014]                           if (is.null(name)) 
[10:59:34.014]                             next
[10:59:34.014]                           if (!grepl(pattern, name)) 
[10:59:34.014]                             next
[10:59:34.014]                           invokeRestart(restart)
[10:59:34.014]                           muffled <- TRUE
[10:59:34.014]                           break
[10:59:34.014]                         }
[10:59:34.014]                       }
[10:59:34.014]                     }
[10:59:34.014]                     invisible(muffled)
[10:59:34.014]                   }
[10:59:34.014]                   muffleCondition(cond)
[10:59:34.014]                 })
[10:59:34.014]             }))
[10:59:34.014]             future::FutureResult(value = ...future.value$value, 
[10:59:34.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.014]                   ...future.rng), globalenv = if (FALSE) 
[10:59:34.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:34.014]                     ...future.globalenv.names))
[10:59:34.014]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:34.014]         }, condition = base::local({
[10:59:34.014]             c <- base::c
[10:59:34.014]             inherits <- base::inherits
[10:59:34.014]             invokeRestart <- base::invokeRestart
[10:59:34.014]             length <- base::length
[10:59:34.014]             list <- base::list
[10:59:34.014]             seq.int <- base::seq.int
[10:59:34.014]             signalCondition <- base::signalCondition
[10:59:34.014]             sys.calls <- base::sys.calls
[10:59:34.014]             `[[` <- base::`[[`
[10:59:34.014]             `+` <- base::`+`
[10:59:34.014]             `<<-` <- base::`<<-`
[10:59:34.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:34.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:34.014]                   3L)]
[10:59:34.014]             }
[10:59:34.014]             function(cond) {
[10:59:34.014]                 is_error <- inherits(cond, "error")
[10:59:34.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:34.014]                   NULL)
[10:59:34.014]                 if (is_error) {
[10:59:34.014]                   sessionInformation <- function() {
[10:59:34.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:34.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:34.014]                       search = base::search(), system = base::Sys.info())
[10:59:34.014]                   }
[10:59:34.014]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:34.014]                     cond$call), session = sessionInformation(), 
[10:59:34.014]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:34.014]                   signalCondition(cond)
[10:59:34.014]                 }
[10:59:34.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:34.014]                 "immediateCondition"))) {
[10:59:34.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:34.014]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:34.014]                   if (TRUE && !signal) {
[10:59:34.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.014]                     {
[10:59:34.014]                       inherits <- base::inherits
[10:59:34.014]                       invokeRestart <- base::invokeRestart
[10:59:34.014]                       is.null <- base::is.null
[10:59:34.014]                       muffled <- FALSE
[10:59:34.014]                       if (inherits(cond, "message")) {
[10:59:34.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.014]                         if (muffled) 
[10:59:34.014]                           invokeRestart("muffleMessage")
[10:59:34.014]                       }
[10:59:34.014]                       else if (inherits(cond, "warning")) {
[10:59:34.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.014]                         if (muffled) 
[10:59:34.014]                           invokeRestart("muffleWarning")
[10:59:34.014]                       }
[10:59:34.014]                       else if (inherits(cond, "condition")) {
[10:59:34.014]                         if (!is.null(pattern)) {
[10:59:34.014]                           computeRestarts <- base::computeRestarts
[10:59:34.014]                           grepl <- base::grepl
[10:59:34.014]                           restarts <- computeRestarts(cond)
[10:59:34.014]                           for (restart in restarts) {
[10:59:34.014]                             name <- restart$name
[10:59:34.014]                             if (is.null(name)) 
[10:59:34.014]                               next
[10:59:34.014]                             if (!grepl(pattern, name)) 
[10:59:34.014]                               next
[10:59:34.014]                             invokeRestart(restart)
[10:59:34.014]                             muffled <- TRUE
[10:59:34.014]                             break
[10:59:34.014]                           }
[10:59:34.014]                         }
[10:59:34.014]                       }
[10:59:34.014]                       invisible(muffled)
[10:59:34.014]                     }
[10:59:34.014]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.014]                   }
[10:59:34.014]                 }
[10:59:34.014]                 else {
[10:59:34.014]                   if (TRUE) {
[10:59:34.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.014]                     {
[10:59:34.014]                       inherits <- base::inherits
[10:59:34.014]                       invokeRestart <- base::invokeRestart
[10:59:34.014]                       is.null <- base::is.null
[10:59:34.014]                       muffled <- FALSE
[10:59:34.014]                       if (inherits(cond, "message")) {
[10:59:34.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.014]                         if (muffled) 
[10:59:34.014]                           invokeRestart("muffleMessage")
[10:59:34.014]                       }
[10:59:34.014]                       else if (inherits(cond, "warning")) {
[10:59:34.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.014]                         if (muffled) 
[10:59:34.014]                           invokeRestart("muffleWarning")
[10:59:34.014]                       }
[10:59:34.014]                       else if (inherits(cond, "condition")) {
[10:59:34.014]                         if (!is.null(pattern)) {
[10:59:34.014]                           computeRestarts <- base::computeRestarts
[10:59:34.014]                           grepl <- base::grepl
[10:59:34.014]                           restarts <- computeRestarts(cond)
[10:59:34.014]                           for (restart in restarts) {
[10:59:34.014]                             name <- restart$name
[10:59:34.014]                             if (is.null(name)) 
[10:59:34.014]                               next
[10:59:34.014]                             if (!grepl(pattern, name)) 
[10:59:34.014]                               next
[10:59:34.014]                             invokeRestart(restart)
[10:59:34.014]                             muffled <- TRUE
[10:59:34.014]                             break
[10:59:34.014]                           }
[10:59:34.014]                         }
[10:59:34.014]                       }
[10:59:34.014]                       invisible(muffled)
[10:59:34.014]                     }
[10:59:34.014]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.014]                   }
[10:59:34.014]                 }
[10:59:34.014]             }
[10:59:34.014]         }))
[10:59:34.014]     }, error = function(ex) {
[10:59:34.014]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:34.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.014]                 ...future.rng), started = ...future.startTime, 
[10:59:34.014]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:34.014]             version = "1.8"), class = "FutureResult")
[10:59:34.014]     }, finally = {
[10:59:34.014]         if (!identical(...future.workdir, getwd())) 
[10:59:34.014]             setwd(...future.workdir)
[10:59:34.014]         {
[10:59:34.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:34.014]                 ...future.oldOptions$nwarnings <- NULL
[10:59:34.014]             }
[10:59:34.014]             base::options(...future.oldOptions)
[10:59:34.014]             if (.Platform$OS.type == "windows") {
[10:59:34.014]                 old_names <- names(...future.oldEnvVars)
[10:59:34.014]                 envs <- base::Sys.getenv()
[10:59:34.014]                 names <- names(envs)
[10:59:34.014]                 common <- intersect(names, old_names)
[10:59:34.014]                 added <- setdiff(names, old_names)
[10:59:34.014]                 removed <- setdiff(old_names, names)
[10:59:34.014]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:34.014]                   envs[common]]
[10:59:34.014]                 NAMES <- toupper(changed)
[10:59:34.014]                 args <- list()
[10:59:34.014]                 for (kk in seq_along(NAMES)) {
[10:59:34.014]                   name <- changed[[kk]]
[10:59:34.014]                   NAME <- NAMES[[kk]]
[10:59:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.014]                     next
[10:59:34.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.014]                 }
[10:59:34.014]                 NAMES <- toupper(added)
[10:59:34.014]                 for (kk in seq_along(NAMES)) {
[10:59:34.014]                   name <- added[[kk]]
[10:59:34.014]                   NAME <- NAMES[[kk]]
[10:59:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.014]                     next
[10:59:34.014]                   args[[name]] <- ""
[10:59:34.014]                 }
[10:59:34.014]                 NAMES <- toupper(removed)
[10:59:34.014]                 for (kk in seq_along(NAMES)) {
[10:59:34.014]                   name <- removed[[kk]]
[10:59:34.014]                   NAME <- NAMES[[kk]]
[10:59:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.014]                     next
[10:59:34.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.014]                 }
[10:59:34.014]                 if (length(args) > 0) 
[10:59:34.014]                   base::do.call(base::Sys.setenv, args = args)
[10:59:34.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:34.014]             }
[10:59:34.014]             else {
[10:59:34.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:34.014]             }
[10:59:34.014]             {
[10:59:34.014]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:34.014]                   0L) {
[10:59:34.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:34.014]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:34.014]                   base::options(opts)
[10:59:34.014]                 }
[10:59:34.014]                 {
[10:59:34.014]                   {
[10:59:34.014]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:34.014]                     NULL
[10:59:34.014]                   }
[10:59:34.014]                   options(future.plan = NULL)
[10:59:34.014]                   if (is.na(NA_character_)) 
[10:59:34.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:34.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:34.014]                     .init = FALSE)
[10:59:34.014]                 }
[10:59:34.014]             }
[10:59:34.014]         }
[10:59:34.014]     })
[10:59:34.014]     if (TRUE) {
[10:59:34.014]         base::sink(type = "output", split = FALSE)
[10:59:34.014]         if (TRUE) {
[10:59:34.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:34.014]         }
[10:59:34.014]         else {
[10:59:34.014]             ...future.result["stdout"] <- base::list(NULL)
[10:59:34.014]         }
[10:59:34.014]         base::close(...future.stdout)
[10:59:34.014]         ...future.stdout <- NULL
[10:59:34.014]     }
[10:59:34.014]     ...future.result$conditions <- ...future.conditions
[10:59:34.014]     ...future.result$finished <- base::Sys.time()
[10:59:34.014]     ...future.result
[10:59:34.014] }
[10:59:34.017] assign_globals() ...
[10:59:34.017] List of 5
[10:59:34.017]  $ ...future.FUN            :function (x)  
[10:59:34.017]  $ MoreArgs                 : NULL
[10:59:34.017]  $ ...future.elements_ii    :List of 1
[10:59:34.017]   ..$ :List of 1
[10:59:34.017]   .. ..$ a: num 0
[10:59:34.017]  $ ...future.seeds_ii       : NULL
[10:59:34.017]  $ ...future.globals.maxSize: NULL
[10:59:34.017]  - attr(*, "where")=List of 5
[10:59:34.017]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:34.017]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:34.017]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:34.017]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:34.017]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:34.017]  - attr(*, "resolved")= logi FALSE
[10:59:34.017]  - attr(*, "total_size")= num 363
[10:59:34.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:34.017]  - attr(*, "already-done")= logi TRUE
[10:59:34.022] - copied ‘...future.FUN’ to environment
[10:59:34.022] - copied ‘MoreArgs’ to environment
[10:59:34.022] - copied ‘...future.elements_ii’ to environment
[10:59:34.022] - copied ‘...future.seeds_ii’ to environment
[10:59:34.023] - copied ‘...future.globals.maxSize’ to environment
[10:59:34.023] assign_globals() ... done
[10:59:34.023] requestCore(): workers = 2
[10:59:34.025] MulticoreFuture started
[10:59:34.025] - Launch lazy future ... done
[10:59:34.025] run() for ‘MulticoreFuture’ ... done
[10:59:34.025] Created future:
[10:59:34.026] plan(): Setting new future strategy stack:
[10:59:34.026] List of future strategies:
[10:59:34.026] 1. sequential:
[10:59:34.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:34.026]    - tweaked: FALSE
[10:59:34.026]    - call: NULL
[10:59:34.027] plan(): nbrOfWorkers() = 1
[10:59:34.029] plan(): Setting new future strategy stack:
[10:59:34.029] List of future strategies:
[10:59:34.029] 1. multicore:
[10:59:34.029]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:34.029]    - tweaked: FALSE
[10:59:34.029]    - call: plan(strategy)
[10:59:34.032] plan(): nbrOfWorkers() = 2
[10:59:34.026] MulticoreFuture:
[10:59:34.026] Label: ‘future_mapply-1’
[10:59:34.026] Expression:
[10:59:34.026] {
[10:59:34.026]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.026]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:34.026]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.026]         on.exit(options(oopts), add = TRUE)
[10:59:34.026]     }
[10:59:34.026]     {
[10:59:34.026]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.026]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:34.026]         do.call(mapply, args = args)
[10:59:34.026]     }
[10:59:34.026] }
[10:59:34.026] Lazy evaluation: FALSE
[10:59:34.026] Asynchronous evaluation: TRUE
[10:59:34.026] Local evaluation: TRUE
[10:59:34.026] Environment: R_GlobalEnv
[10:59:34.026] Capture standard output: TRUE
[10:59:34.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:34.026] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:34.026] Packages: <none>
[10:59:34.026] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:34.026] Resolved: TRUE
[10:59:34.026] Value: <not collected>
[10:59:34.026] Conditions captured: <none>
[10:59:34.026] Early signaling: FALSE
[10:59:34.026] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:34.026] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.033] Chunk #1 of 2 ... DONE
[10:59:34.033] Chunk #2 of 2 ...
[10:59:34.033]  - Finding globals in '...' for chunk #2 ...
[10:59:34.033] getGlobalsAndPackages() ...
[10:59:34.033] Searching for globals...
[10:59:34.034] 
[10:59:34.034] Searching for globals ... DONE
[10:59:34.034] - globals: [0] <none>
[10:59:34.034] getGlobalsAndPackages() ... DONE
[10:59:34.034]    + additional globals found: [n=0] 
[10:59:34.034]    + additional namespaces needed: [n=0] 
[10:59:34.035]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:34.035]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:34.035]  - seeds: <none>
[10:59:34.035]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.035] getGlobalsAndPackages() ...
[10:59:34.035] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.035] Resolving globals: FALSE
[10:59:34.036] The total size of the 5 globals is 363 bytes (363 bytes)
[10:59:34.037] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:34.037] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.037] 
[10:59:34.037] getGlobalsAndPackages() ... DONE
[10:59:34.038] run() for ‘Future’ ...
[10:59:34.038] - state: ‘created’
[10:59:34.038] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:59:34.040] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:59:34.041]   - Field: ‘label’
[10:59:34.041]   - Field: ‘local’
[10:59:34.041]   - Field: ‘owner’
[10:59:34.041]   - Field: ‘envir’
[10:59:34.041]   - Field: ‘workers’
[10:59:34.041]   - Field: ‘packages’
[10:59:34.041]   - Field: ‘gc’
[10:59:34.041]   - Field: ‘job’
[10:59:34.042]   - Field: ‘conditions’
[10:59:34.042]   - Field: ‘expr’
[10:59:34.042]   - Field: ‘uuid’
[10:59:34.042]   - Field: ‘seed’
[10:59:34.042]   - Field: ‘version’
[10:59:34.042]   - Field: ‘result’
[10:59:34.042]   - Field: ‘asynchronous’
[10:59:34.043]   - Field: ‘calls’
[10:59:34.043]   - Field: ‘globals’
[10:59:34.043]   - Field: ‘stdout’
[10:59:34.043]   - Field: ‘earlySignal’
[10:59:34.043]   - Field: ‘lazy’
[10:59:34.043]   - Field: ‘state’
[10:59:34.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:59:34.044] - Launch lazy future ...
[10:59:34.044] Packages needed by the future expression (n = 0): <none>
[10:59:34.044] Packages needed by future strategies (n = 0): <none>
[10:59:34.045] {
[10:59:34.045]     {
[10:59:34.045]         {
[10:59:34.045]             ...future.startTime <- base::Sys.time()
[10:59:34.045]             {
[10:59:34.045]                 {
[10:59:34.045]                   {
[10:59:34.045]                     {
[10:59:34.045]                       base::local({
[10:59:34.045]                         has_future <- base::requireNamespace("future", 
[10:59:34.045]                           quietly = TRUE)
[10:59:34.045]                         if (has_future) {
[10:59:34.045]                           ns <- base::getNamespace("future")
[10:59:34.045]                           version <- ns[[".package"]][["version"]]
[10:59:34.045]                           if (is.null(version)) 
[10:59:34.045]                             version <- utils::packageVersion("future")
[10:59:34.045]                         }
[10:59:34.045]                         else {
[10:59:34.045]                           version <- NULL
[10:59:34.045]                         }
[10:59:34.045]                         if (!has_future || version < "1.8.0") {
[10:59:34.045]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:34.045]                             "", base::R.version$version.string), 
[10:59:34.045]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:34.045]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:34.045]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:34.045]                               "release", "version")], collapse = " "), 
[10:59:34.045]                             hostname = base::Sys.info()[["nodename"]])
[10:59:34.045]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:34.045]                             info)
[10:59:34.045]                           info <- base::paste(info, collapse = "; ")
[10:59:34.045]                           if (!has_future) {
[10:59:34.045]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:34.045]                               info)
[10:59:34.045]                           }
[10:59:34.045]                           else {
[10:59:34.045]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:34.045]                               info, version)
[10:59:34.045]                           }
[10:59:34.045]                           base::stop(msg)
[10:59:34.045]                         }
[10:59:34.045]                       })
[10:59:34.045]                     }
[10:59:34.045]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:34.045]                     base::options(mc.cores = 1L)
[10:59:34.045]                   }
[10:59:34.045]                   ...future.strategy.old <- future::plan("list")
[10:59:34.045]                   options(future.plan = NULL)
[10:59:34.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:34.045]                 }
[10:59:34.045]                 ...future.workdir <- getwd()
[10:59:34.045]             }
[10:59:34.045]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:34.045]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:34.045]         }
[10:59:34.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:34.045]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:34.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:34.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:34.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:34.045]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:34.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:34.045]             base::names(...future.oldOptions))
[10:59:34.045]     }
[10:59:34.045]     if (FALSE) {
[10:59:34.045]     }
[10:59:34.045]     else {
[10:59:34.045]         if (TRUE) {
[10:59:34.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:34.045]                 open = "w")
[10:59:34.045]         }
[10:59:34.045]         else {
[10:59:34.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:34.045]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:34.045]         }
[10:59:34.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:34.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:34.045]             base::sink(type = "output", split = FALSE)
[10:59:34.045]             base::close(...future.stdout)
[10:59:34.045]         }, add = TRUE)
[10:59:34.045]     }
[10:59:34.045]     ...future.frame <- base::sys.nframe()
[10:59:34.045]     ...future.conditions <- base::list()
[10:59:34.045]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:34.045]     if (FALSE) {
[10:59:34.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:34.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:34.045]     }
[10:59:34.045]     ...future.result <- base::tryCatch({
[10:59:34.045]         base::withCallingHandlers({
[10:59:34.045]             ...future.value <- base::withVisible(base::local({
[10:59:34.045]                 withCallingHandlers({
[10:59:34.045]                   {
[10:59:34.045]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.045]                     if (!identical(...future.globals.maxSize.org, 
[10:59:34.045]                       ...future.globals.maxSize)) {
[10:59:34.045]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.045]                       on.exit(options(oopts), add = TRUE)
[10:59:34.045]                     }
[10:59:34.045]                     {
[10:59:34.045]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.045]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:34.045]                         USE.NAMES = FALSE)
[10:59:34.045]                       do.call(mapply, args = args)
[10:59:34.045]                     }
[10:59:34.045]                   }
[10:59:34.045]                 }, immediateCondition = function(cond) {
[10:59:34.045]                   save_rds <- function (object, pathname, ...) 
[10:59:34.045]                   {
[10:59:34.045]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:59:34.045]                     if (file_test("-f", pathname_tmp)) {
[10:59:34.045]                       fi_tmp <- file.info(pathname_tmp)
[10:59:34.045]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:59:34.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:34.045]                         fi_tmp[["mtime"]])
[10:59:34.045]                     }
[10:59:34.045]                     tryCatch({
[10:59:34.045]                       saveRDS(object, file = pathname_tmp, ...)
[10:59:34.045]                     }, error = function(ex) {
[10:59:34.045]                       msg <- conditionMessage(ex)
[10:59:34.045]                       fi_tmp <- file.info(pathname_tmp)
[10:59:34.045]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:59:34.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:34.045]                         fi_tmp[["mtime"]], msg)
[10:59:34.045]                       ex$message <- msg
[10:59:34.045]                       stop(ex)
[10:59:34.045]                     })
[10:59:34.045]                     stopifnot(file_test("-f", pathname_tmp))
[10:59:34.045]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:59:34.045]                     if (!res || file_test("-f", pathname_tmp)) {
[10:59:34.045]                       fi_tmp <- file.info(pathname_tmp)
[10:59:34.045]                       fi <- file.info(pathname)
[10:59:34.045]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:59:34.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:59:34.045]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:59:34.045]                         fi[["size"]], fi[["mtime"]])
[10:59:34.045]                       stop(msg)
[10:59:34.045]                     }
[10:59:34.045]                     invisible(pathname)
[10:59:34.045]                   }
[10:59:34.045]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:59:34.045]                     rootPath = tempdir()) 
[10:59:34.045]                   {
[10:59:34.045]                     obj <- list(time = Sys.time(), condition = cond)
[10:59:34.045]                     file <- tempfile(pattern = class(cond)[1], 
[10:59:34.045]                       tmpdir = path, fileext = ".rds")
[10:59:34.045]                     save_rds(obj, file)
[10:59:34.045]                   }
[10:59:34.045]                   saveImmediateCondition(cond, path = "/tmp/RtmplREF4e/.future/immediateConditions")
[10:59:34.045]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.045]                   {
[10:59:34.045]                     inherits <- base::inherits
[10:59:34.045]                     invokeRestart <- base::invokeRestart
[10:59:34.045]                     is.null <- base::is.null
[10:59:34.045]                     muffled <- FALSE
[10:59:34.045]                     if (inherits(cond, "message")) {
[10:59:34.045]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:34.045]                       if (muffled) 
[10:59:34.045]                         invokeRestart("muffleMessage")
[10:59:34.045]                     }
[10:59:34.045]                     else if (inherits(cond, "warning")) {
[10:59:34.045]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:34.045]                       if (muffled) 
[10:59:34.045]                         invokeRestart("muffleWarning")
[10:59:34.045]                     }
[10:59:34.045]                     else if (inherits(cond, "condition")) {
[10:59:34.045]                       if (!is.null(pattern)) {
[10:59:34.045]                         computeRestarts <- base::computeRestarts
[10:59:34.045]                         grepl <- base::grepl
[10:59:34.045]                         restarts <- computeRestarts(cond)
[10:59:34.045]                         for (restart in restarts) {
[10:59:34.045]                           name <- restart$name
[10:59:34.045]                           if (is.null(name)) 
[10:59:34.045]                             next
[10:59:34.045]                           if (!grepl(pattern, name)) 
[10:59:34.045]                             next
[10:59:34.045]                           invokeRestart(restart)
[10:59:34.045]                           muffled <- TRUE
[10:59:34.045]                           break
[10:59:34.045]                         }
[10:59:34.045]                       }
[10:59:34.045]                     }
[10:59:34.045]                     invisible(muffled)
[10:59:34.045]                   }
[10:59:34.045]                   muffleCondition(cond)
[10:59:34.045]                 })
[10:59:34.045]             }))
[10:59:34.045]             future::FutureResult(value = ...future.value$value, 
[10:59:34.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.045]                   ...future.rng), globalenv = if (FALSE) 
[10:59:34.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:34.045]                     ...future.globalenv.names))
[10:59:34.045]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:34.045]         }, condition = base::local({
[10:59:34.045]             c <- base::c
[10:59:34.045]             inherits <- base::inherits
[10:59:34.045]             invokeRestart <- base::invokeRestart
[10:59:34.045]             length <- base::length
[10:59:34.045]             list <- base::list
[10:59:34.045]             seq.int <- base::seq.int
[10:59:34.045]             signalCondition <- base::signalCondition
[10:59:34.045]             sys.calls <- base::sys.calls
[10:59:34.045]             `[[` <- base::`[[`
[10:59:34.045]             `+` <- base::`+`
[10:59:34.045]             `<<-` <- base::`<<-`
[10:59:34.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:34.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:34.045]                   3L)]
[10:59:34.045]             }
[10:59:34.045]             function(cond) {
[10:59:34.045]                 is_error <- inherits(cond, "error")
[10:59:34.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:34.045]                   NULL)
[10:59:34.045]                 if (is_error) {
[10:59:34.045]                   sessionInformation <- function() {
[10:59:34.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:34.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:34.045]                       search = base::search(), system = base::Sys.info())
[10:59:34.045]                   }
[10:59:34.045]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:34.045]                     cond$call), session = sessionInformation(), 
[10:59:34.045]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:34.045]                   signalCondition(cond)
[10:59:34.045]                 }
[10:59:34.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:34.045]                 "immediateCondition"))) {
[10:59:34.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:34.045]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:34.045]                   if (TRUE && !signal) {
[10:59:34.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.045]                     {
[10:59:34.045]                       inherits <- base::inherits
[10:59:34.045]                       invokeRestart <- base::invokeRestart
[10:59:34.045]                       is.null <- base::is.null
[10:59:34.045]                       muffled <- FALSE
[10:59:34.045]                       if (inherits(cond, "message")) {
[10:59:34.045]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.045]                         if (muffled) 
[10:59:34.045]                           invokeRestart("muffleMessage")
[10:59:34.045]                       }
[10:59:34.045]                       else if (inherits(cond, "warning")) {
[10:59:34.045]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.045]                         if (muffled) 
[10:59:34.045]                           invokeRestart("muffleWarning")
[10:59:34.045]                       }
[10:59:34.045]                       else if (inherits(cond, "condition")) {
[10:59:34.045]                         if (!is.null(pattern)) {
[10:59:34.045]                           computeRestarts <- base::computeRestarts
[10:59:34.045]                           grepl <- base::grepl
[10:59:34.045]                           restarts <- computeRestarts(cond)
[10:59:34.045]                           for (restart in restarts) {
[10:59:34.045]                             name <- restart$name
[10:59:34.045]                             if (is.null(name)) 
[10:59:34.045]                               next
[10:59:34.045]                             if (!grepl(pattern, name)) 
[10:59:34.045]                               next
[10:59:34.045]                             invokeRestart(restart)
[10:59:34.045]                             muffled <- TRUE
[10:59:34.045]                             break
[10:59:34.045]                           }
[10:59:34.045]                         }
[10:59:34.045]                       }
[10:59:34.045]                       invisible(muffled)
[10:59:34.045]                     }
[10:59:34.045]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.045]                   }
[10:59:34.045]                 }
[10:59:34.045]                 else {
[10:59:34.045]                   if (TRUE) {
[10:59:34.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.045]                     {
[10:59:34.045]                       inherits <- base::inherits
[10:59:34.045]                       invokeRestart <- base::invokeRestart
[10:59:34.045]                       is.null <- base::is.null
[10:59:34.045]                       muffled <- FALSE
[10:59:34.045]                       if (inherits(cond, "message")) {
[10:59:34.045]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.045]                         if (muffled) 
[10:59:34.045]                           invokeRestart("muffleMessage")
[10:59:34.045]                       }
[10:59:34.045]                       else if (inherits(cond, "warning")) {
[10:59:34.045]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.045]                         if (muffled) 
[10:59:34.045]                           invokeRestart("muffleWarning")
[10:59:34.045]                       }
[10:59:34.045]                       else if (inherits(cond, "condition")) {
[10:59:34.045]                         if (!is.null(pattern)) {
[10:59:34.045]                           computeRestarts <- base::computeRestarts
[10:59:34.045]                           grepl <- base::grepl
[10:59:34.045]                           restarts <- computeRestarts(cond)
[10:59:34.045]                           for (restart in restarts) {
[10:59:34.045]                             name <- restart$name
[10:59:34.045]                             if (is.null(name)) 
[10:59:34.045]                               next
[10:59:34.045]                             if (!grepl(pattern, name)) 
[10:59:34.045]                               next
[10:59:34.045]                             invokeRestart(restart)
[10:59:34.045]                             muffled <- TRUE
[10:59:34.045]                             break
[10:59:34.045]                           }
[10:59:34.045]                         }
[10:59:34.045]                       }
[10:59:34.045]                       invisible(muffled)
[10:59:34.045]                     }
[10:59:34.045]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.045]                   }
[10:59:34.045]                 }
[10:59:34.045]             }
[10:59:34.045]         }))
[10:59:34.045]     }, error = function(ex) {
[10:59:34.045]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:34.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.045]                 ...future.rng), started = ...future.startTime, 
[10:59:34.045]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:34.045]             version = "1.8"), class = "FutureResult")
[10:59:34.045]     }, finally = {
[10:59:34.045]         if (!identical(...future.workdir, getwd())) 
[10:59:34.045]             setwd(...future.workdir)
[10:59:34.045]         {
[10:59:34.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:34.045]                 ...future.oldOptions$nwarnings <- NULL
[10:59:34.045]             }
[10:59:34.045]             base::options(...future.oldOptions)
[10:59:34.045]             if (.Platform$OS.type == "windows") {
[10:59:34.045]                 old_names <- names(...future.oldEnvVars)
[10:59:34.045]                 envs <- base::Sys.getenv()
[10:59:34.045]                 names <- names(envs)
[10:59:34.045]                 common <- intersect(names, old_names)
[10:59:34.045]                 added <- setdiff(names, old_names)
[10:59:34.045]                 removed <- setdiff(old_names, names)
[10:59:34.045]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:34.045]                   envs[common]]
[10:59:34.045]                 NAMES <- toupper(changed)
[10:59:34.045]                 args <- list()
[10:59:34.045]                 for (kk in seq_along(NAMES)) {
[10:59:34.045]                   name <- changed[[kk]]
[10:59:34.045]                   NAME <- NAMES[[kk]]
[10:59:34.045]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.045]                     next
[10:59:34.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.045]                 }
[10:59:34.045]                 NAMES <- toupper(added)
[10:59:34.045]                 for (kk in seq_along(NAMES)) {
[10:59:34.045]                   name <- added[[kk]]
[10:59:34.045]                   NAME <- NAMES[[kk]]
[10:59:34.045]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.045]                     next
[10:59:34.045]                   args[[name]] <- ""
[10:59:34.045]                 }
[10:59:34.045]                 NAMES <- toupper(removed)
[10:59:34.045]                 for (kk in seq_along(NAMES)) {
[10:59:34.045]                   name <- removed[[kk]]
[10:59:34.045]                   NAME <- NAMES[[kk]]
[10:59:34.045]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.045]                     next
[10:59:34.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.045]                 }
[10:59:34.045]                 if (length(args) > 0) 
[10:59:34.045]                   base::do.call(base::Sys.setenv, args = args)
[10:59:34.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:34.045]             }
[10:59:34.045]             else {
[10:59:34.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:34.045]             }
[10:59:34.045]             {
[10:59:34.045]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:34.045]                   0L) {
[10:59:34.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:34.045]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:34.045]                   base::options(opts)
[10:59:34.045]                 }
[10:59:34.045]                 {
[10:59:34.045]                   {
[10:59:34.045]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:34.045]                     NULL
[10:59:34.045]                   }
[10:59:34.045]                   options(future.plan = NULL)
[10:59:34.045]                   if (is.na(NA_character_)) 
[10:59:34.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:34.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:34.045]                     .init = FALSE)
[10:59:34.045]                 }
[10:59:34.045]             }
[10:59:34.045]         }
[10:59:34.045]     })
[10:59:34.045]     if (TRUE) {
[10:59:34.045]         base::sink(type = "output", split = FALSE)
[10:59:34.045]         if (TRUE) {
[10:59:34.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:34.045]         }
[10:59:34.045]         else {
[10:59:34.045]             ...future.result["stdout"] <- base::list(NULL)
[10:59:34.045]         }
[10:59:34.045]         base::close(...future.stdout)
[10:59:34.045]         ...future.stdout <- NULL
[10:59:34.045]     }
[10:59:34.045]     ...future.result$conditions <- ...future.conditions
[10:59:34.045]     ...future.result$finished <- base::Sys.time()
[10:59:34.045]     ...future.result
[10:59:34.045] }
[10:59:34.048] assign_globals() ...
[10:59:34.048] List of 5
[10:59:34.048]  $ ...future.FUN            :function (x)  
[10:59:34.048]  $ MoreArgs                 : NULL
[10:59:34.048]  $ ...future.elements_ii    :List of 1
[10:59:34.048]   ..$ :List of 1
[10:59:34.048]   .. ..$ b: num 0
[10:59:34.048]  $ ...future.seeds_ii       : NULL
[10:59:34.048]  $ ...future.globals.maxSize: NULL
[10:59:34.048]  - attr(*, "where")=List of 5
[10:59:34.048]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:59:34.048]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:59:34.048]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:59:34.048]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:59:34.048]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:59:34.048]  - attr(*, "resolved")= logi FALSE
[10:59:34.048]  - attr(*, "total_size")= num 363
[10:59:34.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:34.048]  - attr(*, "already-done")= logi TRUE
[10:59:34.054] - copied ‘...future.FUN’ to environment
[10:59:34.054] - copied ‘MoreArgs’ to environment
[10:59:34.055] - copied ‘...future.elements_ii’ to environment
[10:59:34.055] - copied ‘...future.seeds_ii’ to environment
[10:59:34.055] - copied ‘...future.globals.maxSize’ to environment
[10:59:34.055] assign_globals() ... done
[10:59:34.055] requestCore(): workers = 2
[10:59:34.057] MulticoreFuture started
[10:59:34.058] - Launch lazy future ... done
[10:59:34.058] run() for ‘MulticoreFuture’ ... done
[10:59:34.058] Created future:
[10:59:34.058] plan(): Setting new future strategy stack:
[10:59:34.058] List of future strategies:
[10:59:34.058] 1. sequential:
[10:59:34.058]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:34.058]    - tweaked: FALSE
[10:59:34.058]    - call: NULL
[10:59:34.059] plan(): nbrOfWorkers() = 1
[10:59:34.061] plan(): Setting new future strategy stack:
[10:59:34.062] List of future strategies:
[10:59:34.062] 1. multicore:
[10:59:34.062]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:59:34.062]    - tweaked: FALSE
[10:59:34.062]    - call: plan(strategy)
[10:59:34.064] plan(): nbrOfWorkers() = 2
[10:59:34.058] MulticoreFuture:
[10:59:34.058] Label: ‘future_mapply-2’
[10:59:34.058] Expression:
[10:59:34.058] {
[10:59:34.058]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.058]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:34.058]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.058]         on.exit(options(oopts), add = TRUE)
[10:59:34.058]     }
[10:59:34.058]     {
[10:59:34.058]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.058]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:34.058]         do.call(mapply, args = args)
[10:59:34.058]     }
[10:59:34.058] }
[10:59:34.058] Lazy evaluation: FALSE
[10:59:34.058] Asynchronous evaluation: TRUE
[10:59:34.058] Local evaluation: TRUE
[10:59:34.058] Environment: R_GlobalEnv
[10:59:34.058] Capture standard output: TRUE
[10:59:34.058] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:34.058] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:34.058] Packages: <none>
[10:59:34.058] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:34.058] Resolved: TRUE
[10:59:34.058] Value: <not collected>
[10:59:34.058] Conditions captured: <none>
[10:59:34.058] Early signaling: FALSE
[10:59:34.058] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:34.058] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.065] Chunk #2 of 2 ... DONE
[10:59:34.066] Launching 2 futures (chunks) ... DONE
[10:59:34.066] Resolving 2 futures (chunks) ...
[10:59:34.066] resolve() on list ...
[10:59:34.066]  recursive: 0
[10:59:34.066]  length: 2
[10:59:34.066] 
[10:59:34.066] Future #1
[10:59:34.067] result() for MulticoreFuture ...
[10:59:34.068] result() for MulticoreFuture ...
[10:59:34.068] result() for MulticoreFuture ... done
[10:59:34.068] result() for MulticoreFuture ... done
[10:59:34.068] result() for MulticoreFuture ...
[10:59:34.068] result() for MulticoreFuture ... done
[10:59:34.068] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:59:34.068] - nx: 2
[10:59:34.068] - relay: TRUE
[10:59:34.069] - stdout: TRUE
[10:59:34.069] - signal: TRUE
[10:59:34.069] - resignal: FALSE
[10:59:34.069] - force: TRUE
[10:59:34.069] - relayed: [n=2] FALSE, FALSE
[10:59:34.069] - queued futures: [n=2] FALSE, FALSE
[10:59:34.069]  - until=1
[10:59:34.069]  - relaying element #1
[10:59:34.069] result() for MulticoreFuture ...
[10:59:34.070] result() for MulticoreFuture ... done
[10:59:34.070] result() for MulticoreFuture ...
[10:59:34.070] result() for MulticoreFuture ... done
[10:59:34.070] result() for MulticoreFuture ...
[10:59:34.070] result() for MulticoreFuture ... done
[10:59:34.070] result() for MulticoreFuture ...
[10:59:34.070] result() for MulticoreFuture ... done
[10:59:34.070] - relayed: [n=2] TRUE, FALSE
[10:59:34.071] - queued futures: [n=2] TRUE, FALSE
[10:59:34.071] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:59:34.071]  length: 1 (resolved future 1)
[10:59:34.071] Future #2
[10:59:34.071] result() for MulticoreFuture ...
[10:59:34.072] result() for MulticoreFuture ...
[10:59:34.072] result() for MulticoreFuture ... done
[10:59:34.072] result() for MulticoreFuture ... done
[10:59:34.072] result() for MulticoreFuture ...
[10:59:34.072] result() for MulticoreFuture ... done
[10:59:34.073] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:59:34.073] - nx: 2
[10:59:34.073] - relay: TRUE
[10:59:34.073] - stdout: TRUE
[10:59:34.073] - signal: TRUE
[10:59:34.073] - resignal: FALSE
[10:59:34.073] - force: TRUE
[10:59:34.073] - relayed: [n=2] TRUE, FALSE
[10:59:34.073] - queued futures: [n=2] TRUE, FALSE
[10:59:34.074]  - until=2
[10:59:34.074]  - relaying element #2
[10:59:34.074] result() for MulticoreFuture ...
[10:59:34.074] result() for MulticoreFuture ... done
[10:59:34.074] result() for MulticoreFuture ...
[10:59:34.074] result() for MulticoreFuture ... done
[10:59:34.074] result() for MulticoreFuture ...
[10:59:34.074] result() for MulticoreFuture ... done
[10:59:34.074] result() for MulticoreFuture ...
[10:59:34.075] result() for MulticoreFuture ... done
[10:59:34.075] - relayed: [n=2] TRUE, TRUE
[10:59:34.075] - queued futures: [n=2] TRUE, TRUE
[10:59:34.075] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:59:34.075]  length: 0 (resolved future 2)
[10:59:34.075] Relaying remaining futures
[10:59:34.075] signalConditionsASAP(NULL, pos=0) ...
[10:59:34.075] - nx: 2
[10:59:34.075] - relay: TRUE
[10:59:34.075] - stdout: TRUE
[10:59:34.076] - signal: TRUE
[10:59:34.076] - resignal: FALSE
[10:59:34.076] - force: TRUE
[10:59:34.076] - relayed: [n=2] TRUE, TRUE
[10:59:34.076] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:34.076] - relayed: [n=2] TRUE, TRUE
[10:59:34.076] - queued futures: [n=2] TRUE, TRUE
[10:59:34.076] signalConditionsASAP(NULL, pos=0) ... done
[10:59:34.076] resolve() on list ... DONE
[10:59:34.077] result() for MulticoreFuture ...
[10:59:34.077] result() for MulticoreFuture ... done
[10:59:34.077] result() for MulticoreFuture ...
[10:59:34.077] result() for MulticoreFuture ... done
[10:59:34.077] result() for MulticoreFuture ...
[10:59:34.077] result() for MulticoreFuture ... done
[10:59:34.077] result() for MulticoreFuture ...
[10:59:34.077] result() for MulticoreFuture ... done
[10:59:34.077]  - Number of value chunks collected: 2
[10:59:34.077] Resolving 2 futures (chunks) ... DONE
[10:59:34.078] Reducing values from 2 chunks ...
[10:59:34.078]  - Number of values collected after concatenation: 2
[10:59:34.078]  - Number of values expected: 2
[10:59:34.078] Reducing values from 2 chunks ... DONE
[10:59:34.078] future_mapply() ... DONE
[10:59:34.078] plan(): Setting new future strategy stack:
[10:59:34.078] List of future strategies:
[10:59:34.078] 1. sequential:
[10:59:34.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:34.078]    - tweaked: FALSE
[10:59:34.078]    - call: plan(sequential)
[10:59:34.079] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:59:34.079] plan(): Setting new future strategy stack:
[10:59:34.080] List of future strategies:
[10:59:34.080] 1. multisession:
[10:59:34.080]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:59:34.080]    - tweaked: FALSE
[10:59:34.080]    - call: plan(strategy)
[10:59:34.080] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:59:34.080] multisession:
[10:59:34.080] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:59:34.080] - tweaked: FALSE
[10:59:34.080] - call: plan(strategy)
[10:59:34.084] getGlobalsAndPackages() ...
[10:59:34.084] Not searching for globals
[10:59:34.085] - globals: [0] <none>
[10:59:34.085] getGlobalsAndPackages() ... DONE
[10:59:34.571] Packages needed by the future expression (n = 0): <none>
[10:59:34.571] Packages needed by future strategies (n = 0): <none>
[10:59:34.572] {
[10:59:34.572]     {
[10:59:34.572]         {
[10:59:34.572]             ...future.startTime <- base::Sys.time()
[10:59:34.572]             {
[10:59:34.572]                 {
[10:59:34.572]                   {
[10:59:34.572]                     {
[10:59:34.572]                       base::local({
[10:59:34.572]                         has_future <- base::requireNamespace("future", 
[10:59:34.572]                           quietly = TRUE)
[10:59:34.572]                         if (has_future) {
[10:59:34.572]                           ns <- base::getNamespace("future")
[10:59:34.572]                           version <- ns[[".package"]][["version"]]
[10:59:34.572]                           if (is.null(version)) 
[10:59:34.572]                             version <- utils::packageVersion("future")
[10:59:34.572]                         }
[10:59:34.572]                         else {
[10:59:34.572]                           version <- NULL
[10:59:34.572]                         }
[10:59:34.572]                         if (!has_future || version < "1.8.0") {
[10:59:34.572]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:34.572]                             "", base::R.version$version.string), 
[10:59:34.572]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:34.572]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:34.572]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:34.572]                               "release", "version")], collapse = " "), 
[10:59:34.572]                             hostname = base::Sys.info()[["nodename"]])
[10:59:34.572]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:34.572]                             info)
[10:59:34.572]                           info <- base::paste(info, collapse = "; ")
[10:59:34.572]                           if (!has_future) {
[10:59:34.572]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:34.572]                               info)
[10:59:34.572]                           }
[10:59:34.572]                           else {
[10:59:34.572]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:34.572]                               info, version)
[10:59:34.572]                           }
[10:59:34.572]                           base::stop(msg)
[10:59:34.572]                         }
[10:59:34.572]                       })
[10:59:34.572]                     }
[10:59:34.572]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:34.572]                     base::options(mc.cores = 1L)
[10:59:34.572]                   }
[10:59:34.572]                   ...future.strategy.old <- future::plan("list")
[10:59:34.572]                   options(future.plan = NULL)
[10:59:34.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:34.572]                 }
[10:59:34.572]                 ...future.workdir <- getwd()
[10:59:34.572]             }
[10:59:34.572]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:34.572]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:34.572]         }
[10:59:34.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:34.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:34.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:34.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:34.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:34.572]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:34.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:34.572]             base::names(...future.oldOptions))
[10:59:34.572]     }
[10:59:34.572]     if (FALSE) {
[10:59:34.572]     }
[10:59:34.572]     else {
[10:59:34.572]         if (TRUE) {
[10:59:34.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:34.572]                 open = "w")
[10:59:34.572]         }
[10:59:34.572]         else {
[10:59:34.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:34.572]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:34.572]         }
[10:59:34.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:34.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:34.572]             base::sink(type = "output", split = FALSE)
[10:59:34.572]             base::close(...future.stdout)
[10:59:34.572]         }, add = TRUE)
[10:59:34.572]     }
[10:59:34.572]     ...future.frame <- base::sys.nframe()
[10:59:34.572]     ...future.conditions <- base::list()
[10:59:34.572]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:34.572]     if (FALSE) {
[10:59:34.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:34.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:34.572]     }
[10:59:34.572]     ...future.result <- base::tryCatch({
[10:59:34.572]         base::withCallingHandlers({
[10:59:34.572]             ...future.value <- base::withVisible(base::local({
[10:59:34.572]                 ...future.makeSendCondition <- base::local({
[10:59:34.572]                   sendCondition <- NULL
[10:59:34.572]                   function(frame = 1L) {
[10:59:34.572]                     if (is.function(sendCondition)) 
[10:59:34.572]                       return(sendCondition)
[10:59:34.572]                     ns <- getNamespace("parallel")
[10:59:34.572]                     if (exists("sendData", mode = "function", 
[10:59:34.572]                       envir = ns)) {
[10:59:34.572]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:34.572]                         envir = ns)
[10:59:34.572]                       envir <- sys.frame(frame)
[10:59:34.572]                       master <- NULL
[10:59:34.572]                       while (!identical(envir, .GlobalEnv) && 
[10:59:34.572]                         !identical(envir, emptyenv())) {
[10:59:34.572]                         if (exists("master", mode = "list", envir = envir, 
[10:59:34.572]                           inherits = FALSE)) {
[10:59:34.572]                           master <- get("master", mode = "list", 
[10:59:34.572]                             envir = envir, inherits = FALSE)
[10:59:34.572]                           if (inherits(master, c("SOCKnode", 
[10:59:34.572]                             "SOCK0node"))) {
[10:59:34.572]                             sendCondition <<- function(cond) {
[10:59:34.572]                               data <- list(type = "VALUE", value = cond, 
[10:59:34.572]                                 success = TRUE)
[10:59:34.572]                               parallel_sendData(master, data)
[10:59:34.572]                             }
[10:59:34.572]                             return(sendCondition)
[10:59:34.572]                           }
[10:59:34.572]                         }
[10:59:34.572]                         frame <- frame + 1L
[10:59:34.572]                         envir <- sys.frame(frame)
[10:59:34.572]                       }
[10:59:34.572]                     }
[10:59:34.572]                     sendCondition <<- function(cond) NULL
[10:59:34.572]                   }
[10:59:34.572]                 })
[10:59:34.572]                 withCallingHandlers({
[10:59:34.572]                   NA
[10:59:34.572]                 }, immediateCondition = function(cond) {
[10:59:34.572]                   sendCondition <- ...future.makeSendCondition()
[10:59:34.572]                   sendCondition(cond)
[10:59:34.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.572]                   {
[10:59:34.572]                     inherits <- base::inherits
[10:59:34.572]                     invokeRestart <- base::invokeRestart
[10:59:34.572]                     is.null <- base::is.null
[10:59:34.572]                     muffled <- FALSE
[10:59:34.572]                     if (inherits(cond, "message")) {
[10:59:34.572]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:34.572]                       if (muffled) 
[10:59:34.572]                         invokeRestart("muffleMessage")
[10:59:34.572]                     }
[10:59:34.572]                     else if (inherits(cond, "warning")) {
[10:59:34.572]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:34.572]                       if (muffled) 
[10:59:34.572]                         invokeRestart("muffleWarning")
[10:59:34.572]                     }
[10:59:34.572]                     else if (inherits(cond, "condition")) {
[10:59:34.572]                       if (!is.null(pattern)) {
[10:59:34.572]                         computeRestarts <- base::computeRestarts
[10:59:34.572]                         grepl <- base::grepl
[10:59:34.572]                         restarts <- computeRestarts(cond)
[10:59:34.572]                         for (restart in restarts) {
[10:59:34.572]                           name <- restart$name
[10:59:34.572]                           if (is.null(name)) 
[10:59:34.572]                             next
[10:59:34.572]                           if (!grepl(pattern, name)) 
[10:59:34.572]                             next
[10:59:34.572]                           invokeRestart(restart)
[10:59:34.572]                           muffled <- TRUE
[10:59:34.572]                           break
[10:59:34.572]                         }
[10:59:34.572]                       }
[10:59:34.572]                     }
[10:59:34.572]                     invisible(muffled)
[10:59:34.572]                   }
[10:59:34.572]                   muffleCondition(cond)
[10:59:34.572]                 })
[10:59:34.572]             }))
[10:59:34.572]             future::FutureResult(value = ...future.value$value, 
[10:59:34.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.572]                   ...future.rng), globalenv = if (FALSE) 
[10:59:34.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:34.572]                     ...future.globalenv.names))
[10:59:34.572]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:34.572]         }, condition = base::local({
[10:59:34.572]             c <- base::c
[10:59:34.572]             inherits <- base::inherits
[10:59:34.572]             invokeRestart <- base::invokeRestart
[10:59:34.572]             length <- base::length
[10:59:34.572]             list <- base::list
[10:59:34.572]             seq.int <- base::seq.int
[10:59:34.572]             signalCondition <- base::signalCondition
[10:59:34.572]             sys.calls <- base::sys.calls
[10:59:34.572]             `[[` <- base::`[[`
[10:59:34.572]             `+` <- base::`+`
[10:59:34.572]             `<<-` <- base::`<<-`
[10:59:34.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:34.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:34.572]                   3L)]
[10:59:34.572]             }
[10:59:34.572]             function(cond) {
[10:59:34.572]                 is_error <- inherits(cond, "error")
[10:59:34.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:34.572]                   NULL)
[10:59:34.572]                 if (is_error) {
[10:59:34.572]                   sessionInformation <- function() {
[10:59:34.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:34.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:34.572]                       search = base::search(), system = base::Sys.info())
[10:59:34.572]                   }
[10:59:34.572]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:34.572]                     cond$call), session = sessionInformation(), 
[10:59:34.572]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:34.572]                   signalCondition(cond)
[10:59:34.572]                 }
[10:59:34.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:34.572]                 "immediateCondition"))) {
[10:59:34.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:34.572]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:34.572]                   if (TRUE && !signal) {
[10:59:34.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.572]                     {
[10:59:34.572]                       inherits <- base::inherits
[10:59:34.572]                       invokeRestart <- base::invokeRestart
[10:59:34.572]                       is.null <- base::is.null
[10:59:34.572]                       muffled <- FALSE
[10:59:34.572]                       if (inherits(cond, "message")) {
[10:59:34.572]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.572]                         if (muffled) 
[10:59:34.572]                           invokeRestart("muffleMessage")
[10:59:34.572]                       }
[10:59:34.572]                       else if (inherits(cond, "warning")) {
[10:59:34.572]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.572]                         if (muffled) 
[10:59:34.572]                           invokeRestart("muffleWarning")
[10:59:34.572]                       }
[10:59:34.572]                       else if (inherits(cond, "condition")) {
[10:59:34.572]                         if (!is.null(pattern)) {
[10:59:34.572]                           computeRestarts <- base::computeRestarts
[10:59:34.572]                           grepl <- base::grepl
[10:59:34.572]                           restarts <- computeRestarts(cond)
[10:59:34.572]                           for (restart in restarts) {
[10:59:34.572]                             name <- restart$name
[10:59:34.572]                             if (is.null(name)) 
[10:59:34.572]                               next
[10:59:34.572]                             if (!grepl(pattern, name)) 
[10:59:34.572]                               next
[10:59:34.572]                             invokeRestart(restart)
[10:59:34.572]                             muffled <- TRUE
[10:59:34.572]                             break
[10:59:34.572]                           }
[10:59:34.572]                         }
[10:59:34.572]                       }
[10:59:34.572]                       invisible(muffled)
[10:59:34.572]                     }
[10:59:34.572]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.572]                   }
[10:59:34.572]                 }
[10:59:34.572]                 else {
[10:59:34.572]                   if (TRUE) {
[10:59:34.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.572]                     {
[10:59:34.572]                       inherits <- base::inherits
[10:59:34.572]                       invokeRestart <- base::invokeRestart
[10:59:34.572]                       is.null <- base::is.null
[10:59:34.572]                       muffled <- FALSE
[10:59:34.572]                       if (inherits(cond, "message")) {
[10:59:34.572]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.572]                         if (muffled) 
[10:59:34.572]                           invokeRestart("muffleMessage")
[10:59:34.572]                       }
[10:59:34.572]                       else if (inherits(cond, "warning")) {
[10:59:34.572]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.572]                         if (muffled) 
[10:59:34.572]                           invokeRestart("muffleWarning")
[10:59:34.572]                       }
[10:59:34.572]                       else if (inherits(cond, "condition")) {
[10:59:34.572]                         if (!is.null(pattern)) {
[10:59:34.572]                           computeRestarts <- base::computeRestarts
[10:59:34.572]                           grepl <- base::grepl
[10:59:34.572]                           restarts <- computeRestarts(cond)
[10:59:34.572]                           for (restart in restarts) {
[10:59:34.572]                             name <- restart$name
[10:59:34.572]                             if (is.null(name)) 
[10:59:34.572]                               next
[10:59:34.572]                             if (!grepl(pattern, name)) 
[10:59:34.572]                               next
[10:59:34.572]                             invokeRestart(restart)
[10:59:34.572]                             muffled <- TRUE
[10:59:34.572]                             break
[10:59:34.572]                           }
[10:59:34.572]                         }
[10:59:34.572]                       }
[10:59:34.572]                       invisible(muffled)
[10:59:34.572]                     }
[10:59:34.572]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.572]                   }
[10:59:34.572]                 }
[10:59:34.572]             }
[10:59:34.572]         }))
[10:59:34.572]     }, error = function(ex) {
[10:59:34.572]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:34.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.572]                 ...future.rng), started = ...future.startTime, 
[10:59:34.572]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:34.572]             version = "1.8"), class = "FutureResult")
[10:59:34.572]     }, finally = {
[10:59:34.572]         if (!identical(...future.workdir, getwd())) 
[10:59:34.572]             setwd(...future.workdir)
[10:59:34.572]         {
[10:59:34.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:34.572]                 ...future.oldOptions$nwarnings <- NULL
[10:59:34.572]             }
[10:59:34.572]             base::options(...future.oldOptions)
[10:59:34.572]             if (.Platform$OS.type == "windows") {
[10:59:34.572]                 old_names <- names(...future.oldEnvVars)
[10:59:34.572]                 envs <- base::Sys.getenv()
[10:59:34.572]                 names <- names(envs)
[10:59:34.572]                 common <- intersect(names, old_names)
[10:59:34.572]                 added <- setdiff(names, old_names)
[10:59:34.572]                 removed <- setdiff(old_names, names)
[10:59:34.572]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:34.572]                   envs[common]]
[10:59:34.572]                 NAMES <- toupper(changed)
[10:59:34.572]                 args <- list()
[10:59:34.572]                 for (kk in seq_along(NAMES)) {
[10:59:34.572]                   name <- changed[[kk]]
[10:59:34.572]                   NAME <- NAMES[[kk]]
[10:59:34.572]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.572]                     next
[10:59:34.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.572]                 }
[10:59:34.572]                 NAMES <- toupper(added)
[10:59:34.572]                 for (kk in seq_along(NAMES)) {
[10:59:34.572]                   name <- added[[kk]]
[10:59:34.572]                   NAME <- NAMES[[kk]]
[10:59:34.572]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.572]                     next
[10:59:34.572]                   args[[name]] <- ""
[10:59:34.572]                 }
[10:59:34.572]                 NAMES <- toupper(removed)
[10:59:34.572]                 for (kk in seq_along(NAMES)) {
[10:59:34.572]                   name <- removed[[kk]]
[10:59:34.572]                   NAME <- NAMES[[kk]]
[10:59:34.572]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.572]                     next
[10:59:34.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.572]                 }
[10:59:34.572]                 if (length(args) > 0) 
[10:59:34.572]                   base::do.call(base::Sys.setenv, args = args)
[10:59:34.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:34.572]             }
[10:59:34.572]             else {
[10:59:34.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:34.572]             }
[10:59:34.572]             {
[10:59:34.572]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:34.572]                   0L) {
[10:59:34.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:34.572]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:34.572]                   base::options(opts)
[10:59:34.572]                 }
[10:59:34.572]                 {
[10:59:34.572]                   {
[10:59:34.572]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:34.572]                     NULL
[10:59:34.572]                   }
[10:59:34.572]                   options(future.plan = NULL)
[10:59:34.572]                   if (is.na(NA_character_)) 
[10:59:34.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:34.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:34.572]                     .init = FALSE)
[10:59:34.572]                 }
[10:59:34.572]             }
[10:59:34.572]         }
[10:59:34.572]     })
[10:59:34.572]     if (TRUE) {
[10:59:34.572]         base::sink(type = "output", split = FALSE)
[10:59:34.572]         if (TRUE) {
[10:59:34.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:34.572]         }
[10:59:34.572]         else {
[10:59:34.572]             ...future.result["stdout"] <- base::list(NULL)
[10:59:34.572]         }
[10:59:34.572]         base::close(...future.stdout)
[10:59:34.572]         ...future.stdout <- NULL
[10:59:34.572]     }
[10:59:34.572]     ...future.result$conditions <- ...future.conditions
[10:59:34.572]     ...future.result$finished <- base::Sys.time()
[10:59:34.572]     ...future.result
[10:59:34.572] }
[10:59:34.623] MultisessionFuture started
[10:59:34.624] result() for ClusterFuture ...
[10:59:34.624] receiveMessageFromWorker() for ClusterFuture ...
[10:59:34.624] - Validating connection of MultisessionFuture
[10:59:34.654] - received message: FutureResult
[10:59:34.654] - Received FutureResult
[10:59:34.654] - Erased future from FutureRegistry
[10:59:34.654] result() for ClusterFuture ...
[10:59:34.654] - result already collected: FutureResult
[10:59:34.654] result() for ClusterFuture ... done
[10:59:34.654] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:34.654] result() for ClusterFuture ... done
[10:59:34.655] result() for ClusterFuture ...
[10:59:34.655] - result already collected: FutureResult
[10:59:34.655] result() for ClusterFuture ... done
[10:59:34.655] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:59:34.656] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[10:59:34.657] future_mapply() ...
[10:59:34.658] Number of chunks: 2
[10:59:34.658] getGlobalsAndPackagesXApply() ...
[10:59:34.658]  - future.globals: TRUE
[10:59:34.658] getGlobalsAndPackages() ...
[10:59:34.658] Searching for globals...
[10:59:34.659] - globals found: [1] ‘FUN’
[10:59:34.659] Searching for globals ... DONE
[10:59:34.659] Resolving globals: FALSE
[10:59:34.660] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:34.660] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:34.660] - globals: [1] ‘FUN’
[10:59:34.660] 
[10:59:34.660] getGlobalsAndPackages() ... DONE
[10:59:34.660]  - globals found/used: [n=1] ‘FUN’
[10:59:34.660]  - needed namespaces: [n=0] 
[10:59:34.660] Finding globals ... DONE
[10:59:34.661] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:34.661] List of 2
[10:59:34.661]  $ ...future.FUN:function (x, ...)  
[10:59:34.661]  $ MoreArgs     : NULL
[10:59:34.661]  - attr(*, "where")=List of 2
[10:59:34.661]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:34.661]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:34.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:34.661]  - attr(*, "resolved")= logi FALSE
[10:59:34.661]  - attr(*, "total_size")= num NA
[10:59:34.663] Packages to be attached in all futures: [n=0] 
[10:59:34.663] getGlobalsAndPackagesXApply() ... DONE
[10:59:34.663] Number of futures (= number of chunks): 2
[10:59:34.663] Launching 2 futures (chunks) ...
[10:59:34.663] Chunk #1 of 2 ...
[10:59:34.664]  - Finding globals in '...' for chunk #1 ...
[10:59:34.664] getGlobalsAndPackages() ...
[10:59:34.664] Searching for globals...
[10:59:34.664] 
[10:59:34.664] Searching for globals ... DONE
[10:59:34.664] - globals: [0] <none>
[10:59:34.664] getGlobalsAndPackages() ... DONE
[10:59:34.664]    + additional globals found: [n=0] 
[10:59:34.664]    + additional namespaces needed: [n=0] 
[10:59:34.665]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:34.665]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:34.665]  - seeds: <none>
[10:59:34.665]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.665] getGlobalsAndPackages() ...
[10:59:34.665] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.665] Resolving globals: FALSE
[10:59:34.665] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:34.666] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:34.666] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.666] 
[10:59:34.666] getGlobalsAndPackages() ... DONE
[10:59:34.666] run() for ‘Future’ ...
[10:59:34.666] - state: ‘created’
[10:59:34.667] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:34.680] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:34.680]   - Field: ‘node’
[10:59:34.680]   - Field: ‘label’
[10:59:34.680]   - Field: ‘local’
[10:59:34.680]   - Field: ‘owner’
[10:59:34.681]   - Field: ‘envir’
[10:59:34.681]   - Field: ‘workers’
[10:59:34.681]   - Field: ‘packages’
[10:59:34.681]   - Field: ‘gc’
[10:59:34.681]   - Field: ‘conditions’
[10:59:34.681]   - Field: ‘persistent’
[10:59:34.681]   - Field: ‘expr’
[10:59:34.681]   - Field: ‘uuid’
[10:59:34.681]   - Field: ‘seed’
[10:59:34.681]   - Field: ‘version’
[10:59:34.681]   - Field: ‘result’
[10:59:34.681]   - Field: ‘asynchronous’
[10:59:34.682]   - Field: ‘calls’
[10:59:34.682]   - Field: ‘globals’
[10:59:34.682]   - Field: ‘stdout’
[10:59:34.682]   - Field: ‘earlySignal’
[10:59:34.682]   - Field: ‘lazy’
[10:59:34.682]   - Field: ‘state’
[10:59:34.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:34.682] - Launch lazy future ...
[10:59:34.682] Packages needed by the future expression (n = 0): <none>
[10:59:34.682] Packages needed by future strategies (n = 0): <none>
[10:59:34.683] {
[10:59:34.683]     {
[10:59:34.683]         {
[10:59:34.683]             ...future.startTime <- base::Sys.time()
[10:59:34.683]             {
[10:59:34.683]                 {
[10:59:34.683]                   {
[10:59:34.683]                     {
[10:59:34.683]                       base::local({
[10:59:34.683]                         has_future <- base::requireNamespace("future", 
[10:59:34.683]                           quietly = TRUE)
[10:59:34.683]                         if (has_future) {
[10:59:34.683]                           ns <- base::getNamespace("future")
[10:59:34.683]                           version <- ns[[".package"]][["version"]]
[10:59:34.683]                           if (is.null(version)) 
[10:59:34.683]                             version <- utils::packageVersion("future")
[10:59:34.683]                         }
[10:59:34.683]                         else {
[10:59:34.683]                           version <- NULL
[10:59:34.683]                         }
[10:59:34.683]                         if (!has_future || version < "1.8.0") {
[10:59:34.683]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:34.683]                             "", base::R.version$version.string), 
[10:59:34.683]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:34.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:34.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:34.683]                               "release", "version")], collapse = " "), 
[10:59:34.683]                             hostname = base::Sys.info()[["nodename"]])
[10:59:34.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:34.683]                             info)
[10:59:34.683]                           info <- base::paste(info, collapse = "; ")
[10:59:34.683]                           if (!has_future) {
[10:59:34.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:34.683]                               info)
[10:59:34.683]                           }
[10:59:34.683]                           else {
[10:59:34.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:34.683]                               info, version)
[10:59:34.683]                           }
[10:59:34.683]                           base::stop(msg)
[10:59:34.683]                         }
[10:59:34.683]                       })
[10:59:34.683]                     }
[10:59:34.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:34.683]                     base::options(mc.cores = 1L)
[10:59:34.683]                   }
[10:59:34.683]                   ...future.strategy.old <- future::plan("list")
[10:59:34.683]                   options(future.plan = NULL)
[10:59:34.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:34.683]                 }
[10:59:34.683]                 ...future.workdir <- getwd()
[10:59:34.683]             }
[10:59:34.683]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:34.683]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:34.683]         }
[10:59:34.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:34.683]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:34.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:34.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:34.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:34.683]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:34.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:34.683]             base::names(...future.oldOptions))
[10:59:34.683]     }
[10:59:34.683]     if (FALSE) {
[10:59:34.683]     }
[10:59:34.683]     else {
[10:59:34.683]         if (TRUE) {
[10:59:34.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:34.683]                 open = "w")
[10:59:34.683]         }
[10:59:34.683]         else {
[10:59:34.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:34.683]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:34.683]         }
[10:59:34.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:34.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:34.683]             base::sink(type = "output", split = FALSE)
[10:59:34.683]             base::close(...future.stdout)
[10:59:34.683]         }, add = TRUE)
[10:59:34.683]     }
[10:59:34.683]     ...future.frame <- base::sys.nframe()
[10:59:34.683]     ...future.conditions <- base::list()
[10:59:34.683]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:34.683]     if (FALSE) {
[10:59:34.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:34.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:34.683]     }
[10:59:34.683]     ...future.result <- base::tryCatch({
[10:59:34.683]         base::withCallingHandlers({
[10:59:34.683]             ...future.value <- base::withVisible(base::local({
[10:59:34.683]                 ...future.makeSendCondition <- base::local({
[10:59:34.683]                   sendCondition <- NULL
[10:59:34.683]                   function(frame = 1L) {
[10:59:34.683]                     if (is.function(sendCondition)) 
[10:59:34.683]                       return(sendCondition)
[10:59:34.683]                     ns <- getNamespace("parallel")
[10:59:34.683]                     if (exists("sendData", mode = "function", 
[10:59:34.683]                       envir = ns)) {
[10:59:34.683]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:34.683]                         envir = ns)
[10:59:34.683]                       envir <- sys.frame(frame)
[10:59:34.683]                       master <- NULL
[10:59:34.683]                       while (!identical(envir, .GlobalEnv) && 
[10:59:34.683]                         !identical(envir, emptyenv())) {
[10:59:34.683]                         if (exists("master", mode = "list", envir = envir, 
[10:59:34.683]                           inherits = FALSE)) {
[10:59:34.683]                           master <- get("master", mode = "list", 
[10:59:34.683]                             envir = envir, inherits = FALSE)
[10:59:34.683]                           if (inherits(master, c("SOCKnode", 
[10:59:34.683]                             "SOCK0node"))) {
[10:59:34.683]                             sendCondition <<- function(cond) {
[10:59:34.683]                               data <- list(type = "VALUE", value = cond, 
[10:59:34.683]                                 success = TRUE)
[10:59:34.683]                               parallel_sendData(master, data)
[10:59:34.683]                             }
[10:59:34.683]                             return(sendCondition)
[10:59:34.683]                           }
[10:59:34.683]                         }
[10:59:34.683]                         frame <- frame + 1L
[10:59:34.683]                         envir <- sys.frame(frame)
[10:59:34.683]                       }
[10:59:34.683]                     }
[10:59:34.683]                     sendCondition <<- function(cond) NULL
[10:59:34.683]                   }
[10:59:34.683]                 })
[10:59:34.683]                 withCallingHandlers({
[10:59:34.683]                   {
[10:59:34.683]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.683]                     if (!identical(...future.globals.maxSize.org, 
[10:59:34.683]                       ...future.globals.maxSize)) {
[10:59:34.683]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.683]                       on.exit(options(oopts), add = TRUE)
[10:59:34.683]                     }
[10:59:34.683]                     {
[10:59:34.683]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.683]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:34.683]                         USE.NAMES = FALSE)
[10:59:34.683]                       do.call(mapply, args = args)
[10:59:34.683]                     }
[10:59:34.683]                   }
[10:59:34.683]                 }, immediateCondition = function(cond) {
[10:59:34.683]                   sendCondition <- ...future.makeSendCondition()
[10:59:34.683]                   sendCondition(cond)
[10:59:34.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.683]                   {
[10:59:34.683]                     inherits <- base::inherits
[10:59:34.683]                     invokeRestart <- base::invokeRestart
[10:59:34.683]                     is.null <- base::is.null
[10:59:34.683]                     muffled <- FALSE
[10:59:34.683]                     if (inherits(cond, "message")) {
[10:59:34.683]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:34.683]                       if (muffled) 
[10:59:34.683]                         invokeRestart("muffleMessage")
[10:59:34.683]                     }
[10:59:34.683]                     else if (inherits(cond, "warning")) {
[10:59:34.683]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:34.683]                       if (muffled) 
[10:59:34.683]                         invokeRestart("muffleWarning")
[10:59:34.683]                     }
[10:59:34.683]                     else if (inherits(cond, "condition")) {
[10:59:34.683]                       if (!is.null(pattern)) {
[10:59:34.683]                         computeRestarts <- base::computeRestarts
[10:59:34.683]                         grepl <- base::grepl
[10:59:34.683]                         restarts <- computeRestarts(cond)
[10:59:34.683]                         for (restart in restarts) {
[10:59:34.683]                           name <- restart$name
[10:59:34.683]                           if (is.null(name)) 
[10:59:34.683]                             next
[10:59:34.683]                           if (!grepl(pattern, name)) 
[10:59:34.683]                             next
[10:59:34.683]                           invokeRestart(restart)
[10:59:34.683]                           muffled <- TRUE
[10:59:34.683]                           break
[10:59:34.683]                         }
[10:59:34.683]                       }
[10:59:34.683]                     }
[10:59:34.683]                     invisible(muffled)
[10:59:34.683]                   }
[10:59:34.683]                   muffleCondition(cond)
[10:59:34.683]                 })
[10:59:34.683]             }))
[10:59:34.683]             future::FutureResult(value = ...future.value$value, 
[10:59:34.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.683]                   ...future.rng), globalenv = if (FALSE) 
[10:59:34.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:34.683]                     ...future.globalenv.names))
[10:59:34.683]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:34.683]         }, condition = base::local({
[10:59:34.683]             c <- base::c
[10:59:34.683]             inherits <- base::inherits
[10:59:34.683]             invokeRestart <- base::invokeRestart
[10:59:34.683]             length <- base::length
[10:59:34.683]             list <- base::list
[10:59:34.683]             seq.int <- base::seq.int
[10:59:34.683]             signalCondition <- base::signalCondition
[10:59:34.683]             sys.calls <- base::sys.calls
[10:59:34.683]             `[[` <- base::`[[`
[10:59:34.683]             `+` <- base::`+`
[10:59:34.683]             `<<-` <- base::`<<-`
[10:59:34.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:34.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:34.683]                   3L)]
[10:59:34.683]             }
[10:59:34.683]             function(cond) {
[10:59:34.683]                 is_error <- inherits(cond, "error")
[10:59:34.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:34.683]                   NULL)
[10:59:34.683]                 if (is_error) {
[10:59:34.683]                   sessionInformation <- function() {
[10:59:34.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:34.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:34.683]                       search = base::search(), system = base::Sys.info())
[10:59:34.683]                   }
[10:59:34.683]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:34.683]                     cond$call), session = sessionInformation(), 
[10:59:34.683]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:34.683]                   signalCondition(cond)
[10:59:34.683]                 }
[10:59:34.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:34.683]                 "immediateCondition"))) {
[10:59:34.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:34.683]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:34.683]                   if (TRUE && !signal) {
[10:59:34.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.683]                     {
[10:59:34.683]                       inherits <- base::inherits
[10:59:34.683]                       invokeRestart <- base::invokeRestart
[10:59:34.683]                       is.null <- base::is.null
[10:59:34.683]                       muffled <- FALSE
[10:59:34.683]                       if (inherits(cond, "message")) {
[10:59:34.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.683]                         if (muffled) 
[10:59:34.683]                           invokeRestart("muffleMessage")
[10:59:34.683]                       }
[10:59:34.683]                       else if (inherits(cond, "warning")) {
[10:59:34.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.683]                         if (muffled) 
[10:59:34.683]                           invokeRestart("muffleWarning")
[10:59:34.683]                       }
[10:59:34.683]                       else if (inherits(cond, "condition")) {
[10:59:34.683]                         if (!is.null(pattern)) {
[10:59:34.683]                           computeRestarts <- base::computeRestarts
[10:59:34.683]                           grepl <- base::grepl
[10:59:34.683]                           restarts <- computeRestarts(cond)
[10:59:34.683]                           for (restart in restarts) {
[10:59:34.683]                             name <- restart$name
[10:59:34.683]                             if (is.null(name)) 
[10:59:34.683]                               next
[10:59:34.683]                             if (!grepl(pattern, name)) 
[10:59:34.683]                               next
[10:59:34.683]                             invokeRestart(restart)
[10:59:34.683]                             muffled <- TRUE
[10:59:34.683]                             break
[10:59:34.683]                           }
[10:59:34.683]                         }
[10:59:34.683]                       }
[10:59:34.683]                       invisible(muffled)
[10:59:34.683]                     }
[10:59:34.683]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.683]                   }
[10:59:34.683]                 }
[10:59:34.683]                 else {
[10:59:34.683]                   if (TRUE) {
[10:59:34.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.683]                     {
[10:59:34.683]                       inherits <- base::inherits
[10:59:34.683]                       invokeRestart <- base::invokeRestart
[10:59:34.683]                       is.null <- base::is.null
[10:59:34.683]                       muffled <- FALSE
[10:59:34.683]                       if (inherits(cond, "message")) {
[10:59:34.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.683]                         if (muffled) 
[10:59:34.683]                           invokeRestart("muffleMessage")
[10:59:34.683]                       }
[10:59:34.683]                       else if (inherits(cond, "warning")) {
[10:59:34.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.683]                         if (muffled) 
[10:59:34.683]                           invokeRestart("muffleWarning")
[10:59:34.683]                       }
[10:59:34.683]                       else if (inherits(cond, "condition")) {
[10:59:34.683]                         if (!is.null(pattern)) {
[10:59:34.683]                           computeRestarts <- base::computeRestarts
[10:59:34.683]                           grepl <- base::grepl
[10:59:34.683]                           restarts <- computeRestarts(cond)
[10:59:34.683]                           for (restart in restarts) {
[10:59:34.683]                             name <- restart$name
[10:59:34.683]                             if (is.null(name)) 
[10:59:34.683]                               next
[10:59:34.683]                             if (!grepl(pattern, name)) 
[10:59:34.683]                               next
[10:59:34.683]                             invokeRestart(restart)
[10:59:34.683]                             muffled <- TRUE
[10:59:34.683]                             break
[10:59:34.683]                           }
[10:59:34.683]                         }
[10:59:34.683]                       }
[10:59:34.683]                       invisible(muffled)
[10:59:34.683]                     }
[10:59:34.683]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.683]                   }
[10:59:34.683]                 }
[10:59:34.683]             }
[10:59:34.683]         }))
[10:59:34.683]     }, error = function(ex) {
[10:59:34.683]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:34.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.683]                 ...future.rng), started = ...future.startTime, 
[10:59:34.683]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:34.683]             version = "1.8"), class = "FutureResult")
[10:59:34.683]     }, finally = {
[10:59:34.683]         if (!identical(...future.workdir, getwd())) 
[10:59:34.683]             setwd(...future.workdir)
[10:59:34.683]         {
[10:59:34.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:34.683]                 ...future.oldOptions$nwarnings <- NULL
[10:59:34.683]             }
[10:59:34.683]             base::options(...future.oldOptions)
[10:59:34.683]             if (.Platform$OS.type == "windows") {
[10:59:34.683]                 old_names <- names(...future.oldEnvVars)
[10:59:34.683]                 envs <- base::Sys.getenv()
[10:59:34.683]                 names <- names(envs)
[10:59:34.683]                 common <- intersect(names, old_names)
[10:59:34.683]                 added <- setdiff(names, old_names)
[10:59:34.683]                 removed <- setdiff(old_names, names)
[10:59:34.683]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:34.683]                   envs[common]]
[10:59:34.683]                 NAMES <- toupper(changed)
[10:59:34.683]                 args <- list()
[10:59:34.683]                 for (kk in seq_along(NAMES)) {
[10:59:34.683]                   name <- changed[[kk]]
[10:59:34.683]                   NAME <- NAMES[[kk]]
[10:59:34.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.683]                     next
[10:59:34.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.683]                 }
[10:59:34.683]                 NAMES <- toupper(added)
[10:59:34.683]                 for (kk in seq_along(NAMES)) {
[10:59:34.683]                   name <- added[[kk]]
[10:59:34.683]                   NAME <- NAMES[[kk]]
[10:59:34.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.683]                     next
[10:59:34.683]                   args[[name]] <- ""
[10:59:34.683]                 }
[10:59:34.683]                 NAMES <- toupper(removed)
[10:59:34.683]                 for (kk in seq_along(NAMES)) {
[10:59:34.683]                   name <- removed[[kk]]
[10:59:34.683]                   NAME <- NAMES[[kk]]
[10:59:34.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.683]                     next
[10:59:34.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.683]                 }
[10:59:34.683]                 if (length(args) > 0) 
[10:59:34.683]                   base::do.call(base::Sys.setenv, args = args)
[10:59:34.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:34.683]             }
[10:59:34.683]             else {
[10:59:34.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:34.683]             }
[10:59:34.683]             {
[10:59:34.683]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:34.683]                   0L) {
[10:59:34.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:34.683]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:34.683]                   base::options(opts)
[10:59:34.683]                 }
[10:59:34.683]                 {
[10:59:34.683]                   {
[10:59:34.683]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:34.683]                     NULL
[10:59:34.683]                   }
[10:59:34.683]                   options(future.plan = NULL)
[10:59:34.683]                   if (is.na(NA_character_)) 
[10:59:34.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:34.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:34.683]                     .init = FALSE)
[10:59:34.683]                 }
[10:59:34.683]             }
[10:59:34.683]         }
[10:59:34.683]     })
[10:59:34.683]     if (TRUE) {
[10:59:34.683]         base::sink(type = "output", split = FALSE)
[10:59:34.683]         if (TRUE) {
[10:59:34.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:34.683]         }
[10:59:34.683]         else {
[10:59:34.683]             ...future.result["stdout"] <- base::list(NULL)
[10:59:34.683]         }
[10:59:34.683]         base::close(...future.stdout)
[10:59:34.683]         ...future.stdout <- NULL
[10:59:34.683]     }
[10:59:34.683]     ...future.result$conditions <- ...future.conditions
[10:59:34.683]     ...future.result$finished <- base::Sys.time()
[10:59:34.683]     ...future.result
[10:59:34.683] }
[10:59:34.685] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[10:59:34.686] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:59:34.686] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:59:34.686] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:34.686] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:34.687] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[10:59:34.687] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[10:59:34.687] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:34.687] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:34.687] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:34.688] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:34.688] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[10:59:34.688] MultisessionFuture started
[10:59:34.688] - Launch lazy future ... done
[10:59:34.688] run() for ‘MultisessionFuture’ ... done
[10:59:34.688] Created future:
[10:59:34.689] MultisessionFuture:
[10:59:34.689] Label: ‘future_mapply-1’
[10:59:34.689] Expression:
[10:59:34.689] {
[10:59:34.689]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.689]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:34.689]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.689]         on.exit(options(oopts), add = TRUE)
[10:59:34.689]     }
[10:59:34.689]     {
[10:59:34.689]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.689]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:34.689]         do.call(mapply, args = args)
[10:59:34.689]     }
[10:59:34.689] }
[10:59:34.689] Lazy evaluation: FALSE
[10:59:34.689] Asynchronous evaluation: TRUE
[10:59:34.689] Local evaluation: TRUE
[10:59:34.689] Environment: R_GlobalEnv
[10:59:34.689] Capture standard output: TRUE
[10:59:34.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:34.689] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:34.689] Packages: <none>
[10:59:34.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:34.689] Resolved: FALSE
[10:59:34.689] Value: <not collected>
[10:59:34.689] Conditions captured: <none>
[10:59:34.689] Early signaling: FALSE
[10:59:34.689] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:34.689] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.700] Chunk #1 of 2 ... DONE
[10:59:34.700] Chunk #2 of 2 ...
[10:59:34.700]  - Finding globals in '...' for chunk #2 ...
[10:59:34.700] getGlobalsAndPackages() ...
[10:59:34.701] Searching for globals...
[10:59:34.701] 
[10:59:34.701] Searching for globals ... DONE
[10:59:34.701] - globals: [0] <none>
[10:59:34.701] getGlobalsAndPackages() ... DONE
[10:59:34.701]    + additional globals found: [n=0] 
[10:59:34.701]    + additional namespaces needed: [n=0] 
[10:59:34.701]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:34.701]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:34.701]  - seeds: <none>
[10:59:34.702]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.702] getGlobalsAndPackages() ...
[10:59:34.702] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.702] Resolving globals: FALSE
[10:59:34.702] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:34.703] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:34.703] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.703] 
[10:59:34.703] getGlobalsAndPackages() ... DONE
[10:59:34.703] run() for ‘Future’ ...
[10:59:34.703] - state: ‘created’
[10:59:34.703] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:34.717] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:34.717]   - Field: ‘node’
[10:59:34.717]   - Field: ‘label’
[10:59:34.717]   - Field: ‘local’
[10:59:34.717]   - Field: ‘owner’
[10:59:34.718]   - Field: ‘envir’
[10:59:34.718]   - Field: ‘workers’
[10:59:34.718]   - Field: ‘packages’
[10:59:34.718]   - Field: ‘gc’
[10:59:34.718]   - Field: ‘conditions’
[10:59:34.718]   - Field: ‘persistent’
[10:59:34.718]   - Field: ‘expr’
[10:59:34.718]   - Field: ‘uuid’
[10:59:34.718]   - Field: ‘seed’
[10:59:34.718]   - Field: ‘version’
[10:59:34.718]   - Field: ‘result’
[10:59:34.718]   - Field: ‘asynchronous’
[10:59:34.718]   - Field: ‘calls’
[10:59:34.719]   - Field: ‘globals’
[10:59:34.719]   - Field: ‘stdout’
[10:59:34.719]   - Field: ‘earlySignal’
[10:59:34.719]   - Field: ‘lazy’
[10:59:34.719]   - Field: ‘state’
[10:59:34.719] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:34.719] - Launch lazy future ...
[10:59:34.719] Packages needed by the future expression (n = 0): <none>
[10:59:34.719] Packages needed by future strategies (n = 0): <none>
[10:59:34.720] {
[10:59:34.720]     {
[10:59:34.720]         {
[10:59:34.720]             ...future.startTime <- base::Sys.time()
[10:59:34.720]             {
[10:59:34.720]                 {
[10:59:34.720]                   {
[10:59:34.720]                     {
[10:59:34.720]                       base::local({
[10:59:34.720]                         has_future <- base::requireNamespace("future", 
[10:59:34.720]                           quietly = TRUE)
[10:59:34.720]                         if (has_future) {
[10:59:34.720]                           ns <- base::getNamespace("future")
[10:59:34.720]                           version <- ns[[".package"]][["version"]]
[10:59:34.720]                           if (is.null(version)) 
[10:59:34.720]                             version <- utils::packageVersion("future")
[10:59:34.720]                         }
[10:59:34.720]                         else {
[10:59:34.720]                           version <- NULL
[10:59:34.720]                         }
[10:59:34.720]                         if (!has_future || version < "1.8.0") {
[10:59:34.720]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:34.720]                             "", base::R.version$version.string), 
[10:59:34.720]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:34.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:34.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:34.720]                               "release", "version")], collapse = " "), 
[10:59:34.720]                             hostname = base::Sys.info()[["nodename"]])
[10:59:34.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:34.720]                             info)
[10:59:34.720]                           info <- base::paste(info, collapse = "; ")
[10:59:34.720]                           if (!has_future) {
[10:59:34.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:34.720]                               info)
[10:59:34.720]                           }
[10:59:34.720]                           else {
[10:59:34.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:34.720]                               info, version)
[10:59:34.720]                           }
[10:59:34.720]                           base::stop(msg)
[10:59:34.720]                         }
[10:59:34.720]                       })
[10:59:34.720]                     }
[10:59:34.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:34.720]                     base::options(mc.cores = 1L)
[10:59:34.720]                   }
[10:59:34.720]                   ...future.strategy.old <- future::plan("list")
[10:59:34.720]                   options(future.plan = NULL)
[10:59:34.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:34.720]                 }
[10:59:34.720]                 ...future.workdir <- getwd()
[10:59:34.720]             }
[10:59:34.720]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:34.720]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:34.720]         }
[10:59:34.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:34.720]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:34.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:34.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:34.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:34.720]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:34.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:34.720]             base::names(...future.oldOptions))
[10:59:34.720]     }
[10:59:34.720]     if (FALSE) {
[10:59:34.720]     }
[10:59:34.720]     else {
[10:59:34.720]         if (TRUE) {
[10:59:34.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:34.720]                 open = "w")
[10:59:34.720]         }
[10:59:34.720]         else {
[10:59:34.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:34.720]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:34.720]         }
[10:59:34.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:34.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:34.720]             base::sink(type = "output", split = FALSE)
[10:59:34.720]             base::close(...future.stdout)
[10:59:34.720]         }, add = TRUE)
[10:59:34.720]     }
[10:59:34.720]     ...future.frame <- base::sys.nframe()
[10:59:34.720]     ...future.conditions <- base::list()
[10:59:34.720]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:34.720]     if (FALSE) {
[10:59:34.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:34.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:34.720]     }
[10:59:34.720]     ...future.result <- base::tryCatch({
[10:59:34.720]         base::withCallingHandlers({
[10:59:34.720]             ...future.value <- base::withVisible(base::local({
[10:59:34.720]                 ...future.makeSendCondition <- base::local({
[10:59:34.720]                   sendCondition <- NULL
[10:59:34.720]                   function(frame = 1L) {
[10:59:34.720]                     if (is.function(sendCondition)) 
[10:59:34.720]                       return(sendCondition)
[10:59:34.720]                     ns <- getNamespace("parallel")
[10:59:34.720]                     if (exists("sendData", mode = "function", 
[10:59:34.720]                       envir = ns)) {
[10:59:34.720]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:34.720]                         envir = ns)
[10:59:34.720]                       envir <- sys.frame(frame)
[10:59:34.720]                       master <- NULL
[10:59:34.720]                       while (!identical(envir, .GlobalEnv) && 
[10:59:34.720]                         !identical(envir, emptyenv())) {
[10:59:34.720]                         if (exists("master", mode = "list", envir = envir, 
[10:59:34.720]                           inherits = FALSE)) {
[10:59:34.720]                           master <- get("master", mode = "list", 
[10:59:34.720]                             envir = envir, inherits = FALSE)
[10:59:34.720]                           if (inherits(master, c("SOCKnode", 
[10:59:34.720]                             "SOCK0node"))) {
[10:59:34.720]                             sendCondition <<- function(cond) {
[10:59:34.720]                               data <- list(type = "VALUE", value = cond, 
[10:59:34.720]                                 success = TRUE)
[10:59:34.720]                               parallel_sendData(master, data)
[10:59:34.720]                             }
[10:59:34.720]                             return(sendCondition)
[10:59:34.720]                           }
[10:59:34.720]                         }
[10:59:34.720]                         frame <- frame + 1L
[10:59:34.720]                         envir <- sys.frame(frame)
[10:59:34.720]                       }
[10:59:34.720]                     }
[10:59:34.720]                     sendCondition <<- function(cond) NULL
[10:59:34.720]                   }
[10:59:34.720]                 })
[10:59:34.720]                 withCallingHandlers({
[10:59:34.720]                   {
[10:59:34.720]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.720]                     if (!identical(...future.globals.maxSize.org, 
[10:59:34.720]                       ...future.globals.maxSize)) {
[10:59:34.720]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.720]                       on.exit(options(oopts), add = TRUE)
[10:59:34.720]                     }
[10:59:34.720]                     {
[10:59:34.720]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.720]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:34.720]                         USE.NAMES = FALSE)
[10:59:34.720]                       do.call(mapply, args = args)
[10:59:34.720]                     }
[10:59:34.720]                   }
[10:59:34.720]                 }, immediateCondition = function(cond) {
[10:59:34.720]                   sendCondition <- ...future.makeSendCondition()
[10:59:34.720]                   sendCondition(cond)
[10:59:34.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.720]                   {
[10:59:34.720]                     inherits <- base::inherits
[10:59:34.720]                     invokeRestart <- base::invokeRestart
[10:59:34.720]                     is.null <- base::is.null
[10:59:34.720]                     muffled <- FALSE
[10:59:34.720]                     if (inherits(cond, "message")) {
[10:59:34.720]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:34.720]                       if (muffled) 
[10:59:34.720]                         invokeRestart("muffleMessage")
[10:59:34.720]                     }
[10:59:34.720]                     else if (inherits(cond, "warning")) {
[10:59:34.720]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:34.720]                       if (muffled) 
[10:59:34.720]                         invokeRestart("muffleWarning")
[10:59:34.720]                     }
[10:59:34.720]                     else if (inherits(cond, "condition")) {
[10:59:34.720]                       if (!is.null(pattern)) {
[10:59:34.720]                         computeRestarts <- base::computeRestarts
[10:59:34.720]                         grepl <- base::grepl
[10:59:34.720]                         restarts <- computeRestarts(cond)
[10:59:34.720]                         for (restart in restarts) {
[10:59:34.720]                           name <- restart$name
[10:59:34.720]                           if (is.null(name)) 
[10:59:34.720]                             next
[10:59:34.720]                           if (!grepl(pattern, name)) 
[10:59:34.720]                             next
[10:59:34.720]                           invokeRestart(restart)
[10:59:34.720]                           muffled <- TRUE
[10:59:34.720]                           break
[10:59:34.720]                         }
[10:59:34.720]                       }
[10:59:34.720]                     }
[10:59:34.720]                     invisible(muffled)
[10:59:34.720]                   }
[10:59:34.720]                   muffleCondition(cond)
[10:59:34.720]                 })
[10:59:34.720]             }))
[10:59:34.720]             future::FutureResult(value = ...future.value$value, 
[10:59:34.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.720]                   ...future.rng), globalenv = if (FALSE) 
[10:59:34.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:34.720]                     ...future.globalenv.names))
[10:59:34.720]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:34.720]         }, condition = base::local({
[10:59:34.720]             c <- base::c
[10:59:34.720]             inherits <- base::inherits
[10:59:34.720]             invokeRestart <- base::invokeRestart
[10:59:34.720]             length <- base::length
[10:59:34.720]             list <- base::list
[10:59:34.720]             seq.int <- base::seq.int
[10:59:34.720]             signalCondition <- base::signalCondition
[10:59:34.720]             sys.calls <- base::sys.calls
[10:59:34.720]             `[[` <- base::`[[`
[10:59:34.720]             `+` <- base::`+`
[10:59:34.720]             `<<-` <- base::`<<-`
[10:59:34.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:34.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:34.720]                   3L)]
[10:59:34.720]             }
[10:59:34.720]             function(cond) {
[10:59:34.720]                 is_error <- inherits(cond, "error")
[10:59:34.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:34.720]                   NULL)
[10:59:34.720]                 if (is_error) {
[10:59:34.720]                   sessionInformation <- function() {
[10:59:34.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:34.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:34.720]                       search = base::search(), system = base::Sys.info())
[10:59:34.720]                   }
[10:59:34.720]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:34.720]                     cond$call), session = sessionInformation(), 
[10:59:34.720]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:34.720]                   signalCondition(cond)
[10:59:34.720]                 }
[10:59:34.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:34.720]                 "immediateCondition"))) {
[10:59:34.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:34.720]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:34.720]                   if (TRUE && !signal) {
[10:59:34.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.720]                     {
[10:59:34.720]                       inherits <- base::inherits
[10:59:34.720]                       invokeRestart <- base::invokeRestart
[10:59:34.720]                       is.null <- base::is.null
[10:59:34.720]                       muffled <- FALSE
[10:59:34.720]                       if (inherits(cond, "message")) {
[10:59:34.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.720]                         if (muffled) 
[10:59:34.720]                           invokeRestart("muffleMessage")
[10:59:34.720]                       }
[10:59:34.720]                       else if (inherits(cond, "warning")) {
[10:59:34.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.720]                         if (muffled) 
[10:59:34.720]                           invokeRestart("muffleWarning")
[10:59:34.720]                       }
[10:59:34.720]                       else if (inherits(cond, "condition")) {
[10:59:34.720]                         if (!is.null(pattern)) {
[10:59:34.720]                           computeRestarts <- base::computeRestarts
[10:59:34.720]                           grepl <- base::grepl
[10:59:34.720]                           restarts <- computeRestarts(cond)
[10:59:34.720]                           for (restart in restarts) {
[10:59:34.720]                             name <- restart$name
[10:59:34.720]                             if (is.null(name)) 
[10:59:34.720]                               next
[10:59:34.720]                             if (!grepl(pattern, name)) 
[10:59:34.720]                               next
[10:59:34.720]                             invokeRestart(restart)
[10:59:34.720]                             muffled <- TRUE
[10:59:34.720]                             break
[10:59:34.720]                           }
[10:59:34.720]                         }
[10:59:34.720]                       }
[10:59:34.720]                       invisible(muffled)
[10:59:34.720]                     }
[10:59:34.720]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.720]                   }
[10:59:34.720]                 }
[10:59:34.720]                 else {
[10:59:34.720]                   if (TRUE) {
[10:59:34.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.720]                     {
[10:59:34.720]                       inherits <- base::inherits
[10:59:34.720]                       invokeRestart <- base::invokeRestart
[10:59:34.720]                       is.null <- base::is.null
[10:59:34.720]                       muffled <- FALSE
[10:59:34.720]                       if (inherits(cond, "message")) {
[10:59:34.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.720]                         if (muffled) 
[10:59:34.720]                           invokeRestart("muffleMessage")
[10:59:34.720]                       }
[10:59:34.720]                       else if (inherits(cond, "warning")) {
[10:59:34.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.720]                         if (muffled) 
[10:59:34.720]                           invokeRestart("muffleWarning")
[10:59:34.720]                       }
[10:59:34.720]                       else if (inherits(cond, "condition")) {
[10:59:34.720]                         if (!is.null(pattern)) {
[10:59:34.720]                           computeRestarts <- base::computeRestarts
[10:59:34.720]                           grepl <- base::grepl
[10:59:34.720]                           restarts <- computeRestarts(cond)
[10:59:34.720]                           for (restart in restarts) {
[10:59:34.720]                             name <- restart$name
[10:59:34.720]                             if (is.null(name)) 
[10:59:34.720]                               next
[10:59:34.720]                             if (!grepl(pattern, name)) 
[10:59:34.720]                               next
[10:59:34.720]                             invokeRestart(restart)
[10:59:34.720]                             muffled <- TRUE
[10:59:34.720]                             break
[10:59:34.720]                           }
[10:59:34.720]                         }
[10:59:34.720]                       }
[10:59:34.720]                       invisible(muffled)
[10:59:34.720]                     }
[10:59:34.720]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.720]                   }
[10:59:34.720]                 }
[10:59:34.720]             }
[10:59:34.720]         }))
[10:59:34.720]     }, error = function(ex) {
[10:59:34.720]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:34.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.720]                 ...future.rng), started = ...future.startTime, 
[10:59:34.720]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:34.720]             version = "1.8"), class = "FutureResult")
[10:59:34.720]     }, finally = {
[10:59:34.720]         if (!identical(...future.workdir, getwd())) 
[10:59:34.720]             setwd(...future.workdir)
[10:59:34.720]         {
[10:59:34.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:34.720]                 ...future.oldOptions$nwarnings <- NULL
[10:59:34.720]             }
[10:59:34.720]             base::options(...future.oldOptions)
[10:59:34.720]             if (.Platform$OS.type == "windows") {
[10:59:34.720]                 old_names <- names(...future.oldEnvVars)
[10:59:34.720]                 envs <- base::Sys.getenv()
[10:59:34.720]                 names <- names(envs)
[10:59:34.720]                 common <- intersect(names, old_names)
[10:59:34.720]                 added <- setdiff(names, old_names)
[10:59:34.720]                 removed <- setdiff(old_names, names)
[10:59:34.720]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:34.720]                   envs[common]]
[10:59:34.720]                 NAMES <- toupper(changed)
[10:59:34.720]                 args <- list()
[10:59:34.720]                 for (kk in seq_along(NAMES)) {
[10:59:34.720]                   name <- changed[[kk]]
[10:59:34.720]                   NAME <- NAMES[[kk]]
[10:59:34.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.720]                     next
[10:59:34.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.720]                 }
[10:59:34.720]                 NAMES <- toupper(added)
[10:59:34.720]                 for (kk in seq_along(NAMES)) {
[10:59:34.720]                   name <- added[[kk]]
[10:59:34.720]                   NAME <- NAMES[[kk]]
[10:59:34.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.720]                     next
[10:59:34.720]                   args[[name]] <- ""
[10:59:34.720]                 }
[10:59:34.720]                 NAMES <- toupper(removed)
[10:59:34.720]                 for (kk in seq_along(NAMES)) {
[10:59:34.720]                   name <- removed[[kk]]
[10:59:34.720]                   NAME <- NAMES[[kk]]
[10:59:34.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.720]                     next
[10:59:34.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.720]                 }
[10:59:34.720]                 if (length(args) > 0) 
[10:59:34.720]                   base::do.call(base::Sys.setenv, args = args)
[10:59:34.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:34.720]             }
[10:59:34.720]             else {
[10:59:34.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:34.720]             }
[10:59:34.720]             {
[10:59:34.720]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:34.720]                   0L) {
[10:59:34.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:34.720]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:34.720]                   base::options(opts)
[10:59:34.720]                 }
[10:59:34.720]                 {
[10:59:34.720]                   {
[10:59:34.720]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:34.720]                     NULL
[10:59:34.720]                   }
[10:59:34.720]                   options(future.plan = NULL)
[10:59:34.720]                   if (is.na(NA_character_)) 
[10:59:34.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:34.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:34.720]                     .init = FALSE)
[10:59:34.720]                 }
[10:59:34.720]             }
[10:59:34.720]         }
[10:59:34.720]     })
[10:59:34.720]     if (TRUE) {
[10:59:34.720]         base::sink(type = "output", split = FALSE)
[10:59:34.720]         if (TRUE) {
[10:59:34.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:34.720]         }
[10:59:34.720]         else {
[10:59:34.720]             ...future.result["stdout"] <- base::list(NULL)
[10:59:34.720]         }
[10:59:34.720]         base::close(...future.stdout)
[10:59:34.720]         ...future.stdout <- NULL
[10:59:34.720]     }
[10:59:34.720]     ...future.result$conditions <- ...future.conditions
[10:59:34.720]     ...future.result$finished <- base::Sys.time()
[10:59:34.720]     ...future.result
[10:59:34.720] }
[10:59:34.771] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[10:59:34.772] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:59:34.772] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:59:34.772] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:34.773] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:34.773] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[10:59:34.773] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[10:59:34.773] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:34.774] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:34.774] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:34.774] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:34.774] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[10:59:34.775] MultisessionFuture started
[10:59:34.775] - Launch lazy future ... done
[10:59:34.775] run() for ‘MultisessionFuture’ ... done
[10:59:34.775] Created future:
[10:59:34.775] MultisessionFuture:
[10:59:34.775] Label: ‘future_mapply-2’
[10:59:34.775] Expression:
[10:59:34.775] {
[10:59:34.775]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.775]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:34.775]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.775]         on.exit(options(oopts), add = TRUE)
[10:59:34.775]     }
[10:59:34.775]     {
[10:59:34.775]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.775]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:34.775]         do.call(mapply, args = args)
[10:59:34.775]     }
[10:59:34.775] }
[10:59:34.775] Lazy evaluation: FALSE
[10:59:34.775] Asynchronous evaluation: TRUE
[10:59:34.775] Local evaluation: TRUE
[10:59:34.775] Environment: R_GlobalEnv
[10:59:34.775] Capture standard output: TRUE
[10:59:34.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:34.775] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:34.775] Packages: <none>
[10:59:34.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:34.775] Resolved: FALSE
[10:59:34.775] Value: <not collected>
[10:59:34.775] Conditions captured: <none>
[10:59:34.775] Early signaling: FALSE
[10:59:34.775] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:34.775] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.787] Chunk #2 of 2 ... DONE
[10:59:34.787] Launching 2 futures (chunks) ... DONE
[10:59:34.787] Resolving 2 futures (chunks) ...
[10:59:34.787] resolve() on list ...
[10:59:34.787]  recursive: 0
[10:59:34.787]  length: 2
[10:59:34.787] 
[10:59:34.788] receiveMessageFromWorker() for ClusterFuture ...
[10:59:34.788] - Validating connection of MultisessionFuture
[10:59:34.788] - received message: FutureResult
[10:59:34.788] - Received FutureResult
[10:59:34.788] - Erased future from FutureRegistry
[10:59:34.788] result() for ClusterFuture ...
[10:59:34.789] - result already collected: FutureResult
[10:59:34.789] result() for ClusterFuture ... done
[10:59:34.789] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:34.789] Future #1
[10:59:34.789] result() for ClusterFuture ...
[10:59:34.789] - result already collected: FutureResult
[10:59:34.789] result() for ClusterFuture ... done
[10:59:34.789] result() for ClusterFuture ...
[10:59:34.789] - result already collected: FutureResult
[10:59:34.789] result() for ClusterFuture ... done
[10:59:34.789] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:34.789] - nx: 2
[10:59:34.789] - relay: TRUE
[10:59:34.790] - stdout: TRUE
[10:59:34.790] - signal: TRUE
[10:59:34.790] - resignal: FALSE
[10:59:34.790] - force: TRUE
[10:59:34.790] - relayed: [n=2] FALSE, FALSE
[10:59:34.790] - queued futures: [n=2] FALSE, FALSE
[10:59:34.790]  - until=1
[10:59:34.790]  - relaying element #1
[10:59:34.790] result() for ClusterFuture ...
[10:59:34.790] - result already collected: FutureResult
[10:59:34.790] result() for ClusterFuture ... done
[10:59:34.790] result() for ClusterFuture ...
[10:59:34.790] - result already collected: FutureResult
[10:59:34.791] result() for ClusterFuture ... done
[10:59:34.791] result() for ClusterFuture ...
[10:59:34.791] - result already collected: FutureResult
[10:59:34.791] result() for ClusterFuture ... done
[10:59:34.791] result() for ClusterFuture ...
[10:59:34.791] - result already collected: FutureResult
[10:59:34.791] result() for ClusterFuture ... done
[10:59:34.791] - relayed: [n=2] TRUE, FALSE
[10:59:34.791] - queued futures: [n=2] TRUE, FALSE
[10:59:34.791] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:34.791]  length: 1 (resolved future 1)
[10:59:34.854] receiveMessageFromWorker() for ClusterFuture ...
[10:59:34.854] - Validating connection of MultisessionFuture
[10:59:34.854] - received message: FutureResult
[10:59:34.854] - Received FutureResult
[10:59:34.854] - Erased future from FutureRegistry
[10:59:34.854] result() for ClusterFuture ...
[10:59:34.854] - result already collected: FutureResult
[10:59:34.855] result() for ClusterFuture ... done
[10:59:34.855] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:34.855] Future #2
[10:59:34.855] result() for ClusterFuture ...
[10:59:34.855] - result already collected: FutureResult
[10:59:34.855] result() for ClusterFuture ... done
[10:59:34.855] result() for ClusterFuture ...
[10:59:34.855] - result already collected: FutureResult
[10:59:34.855] result() for ClusterFuture ... done
[10:59:34.855] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:34.855] - nx: 2
[10:59:34.855] - relay: TRUE
[10:59:34.855] - stdout: TRUE
[10:59:34.856] - signal: TRUE
[10:59:34.856] - resignal: FALSE
[10:59:34.856] - force: TRUE
[10:59:34.856] - relayed: [n=2] TRUE, FALSE
[10:59:34.856] - queued futures: [n=2] TRUE, FALSE
[10:59:34.856]  - until=2
[10:59:34.856]  - relaying element #2
[10:59:34.856] result() for ClusterFuture ...
[10:59:34.856] - result already collected: FutureResult
[10:59:34.856] result() for ClusterFuture ... done
[10:59:34.856] result() for ClusterFuture ...
[10:59:34.856] - result already collected: FutureResult
[10:59:34.856] result() for ClusterFuture ... done
[10:59:34.857] result() for ClusterFuture ...
[10:59:34.857] - result already collected: FutureResult
[10:59:34.857] result() for ClusterFuture ... done
[10:59:34.857] result() for ClusterFuture ...
[10:59:34.857] - result already collected: FutureResult
[10:59:34.857] result() for ClusterFuture ... done
[10:59:34.857] - relayed: [n=2] TRUE, TRUE
[10:59:34.857] - queued futures: [n=2] TRUE, TRUE
[10:59:34.857] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:34.857]  length: 0 (resolved future 2)
[10:59:34.857] Relaying remaining futures
[10:59:34.857] signalConditionsASAP(NULL, pos=0) ...
[10:59:34.858] - nx: 2
[10:59:34.858] - relay: TRUE
[10:59:34.858] - stdout: TRUE
[10:59:34.858] - signal: TRUE
[10:59:34.858] - resignal: FALSE
[10:59:34.858] - force: TRUE
[10:59:34.858] - relayed: [n=2] TRUE, TRUE
[10:59:34.858] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:34.858] - relayed: [n=2] TRUE, TRUE
[10:59:34.858] - queued futures: [n=2] TRUE, TRUE
[10:59:34.858] signalConditionsASAP(NULL, pos=0) ... done
[10:59:34.859] resolve() on list ... DONE
[10:59:34.859] result() for ClusterFuture ...
[10:59:34.859] - result already collected: FutureResult
[10:59:34.859] result() for ClusterFuture ... done
[10:59:34.859] result() for ClusterFuture ...
[10:59:34.859] - result already collected: FutureResult
[10:59:34.859] result() for ClusterFuture ... done
[10:59:34.859] result() for ClusterFuture ...
[10:59:34.859] - result already collected: FutureResult
[10:59:34.859] result() for ClusterFuture ... done
[10:59:34.859] result() for ClusterFuture ...
[10:59:34.859] - result already collected: FutureResult
[10:59:34.859] result() for ClusterFuture ... done
[10:59:34.860]  - Number of value chunks collected: 2
[10:59:34.860] Resolving 2 futures (chunks) ... DONE
[10:59:34.860] Reducing values from 2 chunks ...
[10:59:34.860]  - Number of values collected after concatenation: 4
[10:59:34.860]  - Number of values expected: 4
[10:59:34.860] Reducing values from 2 chunks ... DONE
[10:59:34.860] future_mapply() ... DONE
[10:59:34.860] future_mapply() ...
[10:59:34.862] Number of chunks: 2
[10:59:34.862] getGlobalsAndPackagesXApply() ...
[10:59:34.862]  - future.globals: TRUE
[10:59:34.862] getGlobalsAndPackages() ...
[10:59:34.862] Searching for globals...
[10:59:34.863] - globals found: [1] ‘FUN’
[10:59:34.863] Searching for globals ... DONE
[10:59:34.863] Resolving globals: FALSE
[10:59:34.863] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:34.864] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:34.864] - globals: [1] ‘FUN’
[10:59:34.864] 
[10:59:34.864] getGlobalsAndPackages() ... DONE
[10:59:34.864]  - globals found/used: [n=1] ‘FUN’
[10:59:34.864]  - needed namespaces: [n=0] 
[10:59:34.864] Finding globals ... DONE
[10:59:34.864] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:34.864] List of 2
[10:59:34.864]  $ ...future.FUN:function (x, ...)  
[10:59:34.864]  $ MoreArgs     : NULL
[10:59:34.864]  - attr(*, "where")=List of 2
[10:59:34.864]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:34.864]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:34.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:34.864]  - attr(*, "resolved")= logi FALSE
[10:59:34.864]  - attr(*, "total_size")= num NA
[10:59:34.867] Packages to be attached in all futures: [n=0] 
[10:59:34.867] getGlobalsAndPackagesXApply() ... DONE
[10:59:34.867] Number of futures (= number of chunks): 2
[10:59:34.867] Launching 2 futures (chunks) ...
[10:59:34.867] Chunk #1 of 2 ...
[10:59:34.867]  - Finding globals in '...' for chunk #1 ...
[10:59:34.868] getGlobalsAndPackages() ...
[10:59:34.868] Searching for globals...
[10:59:34.868] 
[10:59:34.868] Searching for globals ... DONE
[10:59:34.868] - globals: [0] <none>
[10:59:34.868] getGlobalsAndPackages() ... DONE
[10:59:34.868]    + additional globals found: [n=0] 
[10:59:34.868]    + additional namespaces needed: [n=0] 
[10:59:34.868]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:34.868]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:34.869]  - seeds: <none>
[10:59:34.869]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.869] getGlobalsAndPackages() ...
[10:59:34.869] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.869] Resolving globals: FALSE
[10:59:34.869] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:34.870] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:34.870] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.870] 
[10:59:34.870] getGlobalsAndPackages() ... DONE
[10:59:34.870] run() for ‘Future’ ...
[10:59:34.870] - state: ‘created’
[10:59:34.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:34.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:34.885]   - Field: ‘node’
[10:59:34.885]   - Field: ‘label’
[10:59:34.885]   - Field: ‘local’
[10:59:34.886]   - Field: ‘owner’
[10:59:34.886]   - Field: ‘envir’
[10:59:34.886]   - Field: ‘workers’
[10:59:34.886]   - Field: ‘packages’
[10:59:34.886]   - Field: ‘gc’
[10:59:34.886]   - Field: ‘conditions’
[10:59:34.886]   - Field: ‘persistent’
[10:59:34.886]   - Field: ‘expr’
[10:59:34.886]   - Field: ‘uuid’
[10:59:34.886]   - Field: ‘seed’
[10:59:34.886]   - Field: ‘version’
[10:59:34.886]   - Field: ‘result’
[10:59:34.887]   - Field: ‘asynchronous’
[10:59:34.887]   - Field: ‘calls’
[10:59:34.887]   - Field: ‘globals’
[10:59:34.887]   - Field: ‘stdout’
[10:59:34.887]   - Field: ‘earlySignal’
[10:59:34.887]   - Field: ‘lazy’
[10:59:34.887]   - Field: ‘state’
[10:59:34.887] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:34.887] - Launch lazy future ...
[10:59:34.887] Packages needed by the future expression (n = 0): <none>
[10:59:34.888] Packages needed by future strategies (n = 0): <none>
[10:59:34.890] {
[10:59:34.890]     {
[10:59:34.890]         {
[10:59:34.890]             ...future.startTime <- base::Sys.time()
[10:59:34.890]             {
[10:59:34.890]                 {
[10:59:34.890]                   {
[10:59:34.890]                     {
[10:59:34.890]                       base::local({
[10:59:34.890]                         has_future <- base::requireNamespace("future", 
[10:59:34.890]                           quietly = TRUE)
[10:59:34.890]                         if (has_future) {
[10:59:34.890]                           ns <- base::getNamespace("future")
[10:59:34.890]                           version <- ns[[".package"]][["version"]]
[10:59:34.890]                           if (is.null(version)) 
[10:59:34.890]                             version <- utils::packageVersion("future")
[10:59:34.890]                         }
[10:59:34.890]                         else {
[10:59:34.890]                           version <- NULL
[10:59:34.890]                         }
[10:59:34.890]                         if (!has_future || version < "1.8.0") {
[10:59:34.890]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:34.890]                             "", base::R.version$version.string), 
[10:59:34.890]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:34.890]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:34.890]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:34.890]                               "release", "version")], collapse = " "), 
[10:59:34.890]                             hostname = base::Sys.info()[["nodename"]])
[10:59:34.890]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:34.890]                             info)
[10:59:34.890]                           info <- base::paste(info, collapse = "; ")
[10:59:34.890]                           if (!has_future) {
[10:59:34.890]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:34.890]                               info)
[10:59:34.890]                           }
[10:59:34.890]                           else {
[10:59:34.890]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:34.890]                               info, version)
[10:59:34.890]                           }
[10:59:34.890]                           base::stop(msg)
[10:59:34.890]                         }
[10:59:34.890]                       })
[10:59:34.890]                     }
[10:59:34.890]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:34.890]                     base::options(mc.cores = 1L)
[10:59:34.890]                   }
[10:59:34.890]                   ...future.strategy.old <- future::plan("list")
[10:59:34.890]                   options(future.plan = NULL)
[10:59:34.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:34.890]                 }
[10:59:34.890]                 ...future.workdir <- getwd()
[10:59:34.890]             }
[10:59:34.890]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:34.890]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:34.890]         }
[10:59:34.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:34.890]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:34.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:34.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:34.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:34.890]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:34.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:34.890]             base::names(...future.oldOptions))
[10:59:34.890]     }
[10:59:34.890]     if (FALSE) {
[10:59:34.890]     }
[10:59:34.890]     else {
[10:59:34.890]         if (TRUE) {
[10:59:34.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:34.890]                 open = "w")
[10:59:34.890]         }
[10:59:34.890]         else {
[10:59:34.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:34.890]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:34.890]         }
[10:59:34.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:34.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:34.890]             base::sink(type = "output", split = FALSE)
[10:59:34.890]             base::close(...future.stdout)
[10:59:34.890]         }, add = TRUE)
[10:59:34.890]     }
[10:59:34.890]     ...future.frame <- base::sys.nframe()
[10:59:34.890]     ...future.conditions <- base::list()
[10:59:34.890]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:34.890]     if (FALSE) {
[10:59:34.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:34.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:34.890]     }
[10:59:34.890]     ...future.result <- base::tryCatch({
[10:59:34.890]         base::withCallingHandlers({
[10:59:34.890]             ...future.value <- base::withVisible(base::local({
[10:59:34.890]                 ...future.makeSendCondition <- base::local({
[10:59:34.890]                   sendCondition <- NULL
[10:59:34.890]                   function(frame = 1L) {
[10:59:34.890]                     if (is.function(sendCondition)) 
[10:59:34.890]                       return(sendCondition)
[10:59:34.890]                     ns <- getNamespace("parallel")
[10:59:34.890]                     if (exists("sendData", mode = "function", 
[10:59:34.890]                       envir = ns)) {
[10:59:34.890]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:34.890]                         envir = ns)
[10:59:34.890]                       envir <- sys.frame(frame)
[10:59:34.890]                       master <- NULL
[10:59:34.890]                       while (!identical(envir, .GlobalEnv) && 
[10:59:34.890]                         !identical(envir, emptyenv())) {
[10:59:34.890]                         if (exists("master", mode = "list", envir = envir, 
[10:59:34.890]                           inherits = FALSE)) {
[10:59:34.890]                           master <- get("master", mode = "list", 
[10:59:34.890]                             envir = envir, inherits = FALSE)
[10:59:34.890]                           if (inherits(master, c("SOCKnode", 
[10:59:34.890]                             "SOCK0node"))) {
[10:59:34.890]                             sendCondition <<- function(cond) {
[10:59:34.890]                               data <- list(type = "VALUE", value = cond, 
[10:59:34.890]                                 success = TRUE)
[10:59:34.890]                               parallel_sendData(master, data)
[10:59:34.890]                             }
[10:59:34.890]                             return(sendCondition)
[10:59:34.890]                           }
[10:59:34.890]                         }
[10:59:34.890]                         frame <- frame + 1L
[10:59:34.890]                         envir <- sys.frame(frame)
[10:59:34.890]                       }
[10:59:34.890]                     }
[10:59:34.890]                     sendCondition <<- function(cond) NULL
[10:59:34.890]                   }
[10:59:34.890]                 })
[10:59:34.890]                 withCallingHandlers({
[10:59:34.890]                   {
[10:59:34.890]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.890]                     if (!identical(...future.globals.maxSize.org, 
[10:59:34.890]                       ...future.globals.maxSize)) {
[10:59:34.890]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.890]                       on.exit(options(oopts), add = TRUE)
[10:59:34.890]                     }
[10:59:34.890]                     {
[10:59:34.890]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.890]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:34.890]                         USE.NAMES = FALSE)
[10:59:34.890]                       do.call(mapply, args = args)
[10:59:34.890]                     }
[10:59:34.890]                   }
[10:59:34.890]                 }, immediateCondition = function(cond) {
[10:59:34.890]                   sendCondition <- ...future.makeSendCondition()
[10:59:34.890]                   sendCondition(cond)
[10:59:34.890]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.890]                   {
[10:59:34.890]                     inherits <- base::inherits
[10:59:34.890]                     invokeRestart <- base::invokeRestart
[10:59:34.890]                     is.null <- base::is.null
[10:59:34.890]                     muffled <- FALSE
[10:59:34.890]                     if (inherits(cond, "message")) {
[10:59:34.890]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:34.890]                       if (muffled) 
[10:59:34.890]                         invokeRestart("muffleMessage")
[10:59:34.890]                     }
[10:59:34.890]                     else if (inherits(cond, "warning")) {
[10:59:34.890]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:34.890]                       if (muffled) 
[10:59:34.890]                         invokeRestart("muffleWarning")
[10:59:34.890]                     }
[10:59:34.890]                     else if (inherits(cond, "condition")) {
[10:59:34.890]                       if (!is.null(pattern)) {
[10:59:34.890]                         computeRestarts <- base::computeRestarts
[10:59:34.890]                         grepl <- base::grepl
[10:59:34.890]                         restarts <- computeRestarts(cond)
[10:59:34.890]                         for (restart in restarts) {
[10:59:34.890]                           name <- restart$name
[10:59:34.890]                           if (is.null(name)) 
[10:59:34.890]                             next
[10:59:34.890]                           if (!grepl(pattern, name)) 
[10:59:34.890]                             next
[10:59:34.890]                           invokeRestart(restart)
[10:59:34.890]                           muffled <- TRUE
[10:59:34.890]                           break
[10:59:34.890]                         }
[10:59:34.890]                       }
[10:59:34.890]                     }
[10:59:34.890]                     invisible(muffled)
[10:59:34.890]                   }
[10:59:34.890]                   muffleCondition(cond)
[10:59:34.890]                 })
[10:59:34.890]             }))
[10:59:34.890]             future::FutureResult(value = ...future.value$value, 
[10:59:34.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.890]                   ...future.rng), globalenv = if (FALSE) 
[10:59:34.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:34.890]                     ...future.globalenv.names))
[10:59:34.890]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:34.890]         }, condition = base::local({
[10:59:34.890]             c <- base::c
[10:59:34.890]             inherits <- base::inherits
[10:59:34.890]             invokeRestart <- base::invokeRestart
[10:59:34.890]             length <- base::length
[10:59:34.890]             list <- base::list
[10:59:34.890]             seq.int <- base::seq.int
[10:59:34.890]             signalCondition <- base::signalCondition
[10:59:34.890]             sys.calls <- base::sys.calls
[10:59:34.890]             `[[` <- base::`[[`
[10:59:34.890]             `+` <- base::`+`
[10:59:34.890]             `<<-` <- base::`<<-`
[10:59:34.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:34.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:34.890]                   3L)]
[10:59:34.890]             }
[10:59:34.890]             function(cond) {
[10:59:34.890]                 is_error <- inherits(cond, "error")
[10:59:34.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:34.890]                   NULL)
[10:59:34.890]                 if (is_error) {
[10:59:34.890]                   sessionInformation <- function() {
[10:59:34.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:34.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:34.890]                       search = base::search(), system = base::Sys.info())
[10:59:34.890]                   }
[10:59:34.890]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:34.890]                     cond$call), session = sessionInformation(), 
[10:59:34.890]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:34.890]                   signalCondition(cond)
[10:59:34.890]                 }
[10:59:34.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:34.890]                 "immediateCondition"))) {
[10:59:34.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:34.890]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:34.890]                   if (TRUE && !signal) {
[10:59:34.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.890]                     {
[10:59:34.890]                       inherits <- base::inherits
[10:59:34.890]                       invokeRestart <- base::invokeRestart
[10:59:34.890]                       is.null <- base::is.null
[10:59:34.890]                       muffled <- FALSE
[10:59:34.890]                       if (inherits(cond, "message")) {
[10:59:34.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.890]                         if (muffled) 
[10:59:34.890]                           invokeRestart("muffleMessage")
[10:59:34.890]                       }
[10:59:34.890]                       else if (inherits(cond, "warning")) {
[10:59:34.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.890]                         if (muffled) 
[10:59:34.890]                           invokeRestart("muffleWarning")
[10:59:34.890]                       }
[10:59:34.890]                       else if (inherits(cond, "condition")) {
[10:59:34.890]                         if (!is.null(pattern)) {
[10:59:34.890]                           computeRestarts <- base::computeRestarts
[10:59:34.890]                           grepl <- base::grepl
[10:59:34.890]                           restarts <- computeRestarts(cond)
[10:59:34.890]                           for (restart in restarts) {
[10:59:34.890]                             name <- restart$name
[10:59:34.890]                             if (is.null(name)) 
[10:59:34.890]                               next
[10:59:34.890]                             if (!grepl(pattern, name)) 
[10:59:34.890]                               next
[10:59:34.890]                             invokeRestart(restart)
[10:59:34.890]                             muffled <- TRUE
[10:59:34.890]                             break
[10:59:34.890]                           }
[10:59:34.890]                         }
[10:59:34.890]                       }
[10:59:34.890]                       invisible(muffled)
[10:59:34.890]                     }
[10:59:34.890]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.890]                   }
[10:59:34.890]                 }
[10:59:34.890]                 else {
[10:59:34.890]                   if (TRUE) {
[10:59:34.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.890]                     {
[10:59:34.890]                       inherits <- base::inherits
[10:59:34.890]                       invokeRestart <- base::invokeRestart
[10:59:34.890]                       is.null <- base::is.null
[10:59:34.890]                       muffled <- FALSE
[10:59:34.890]                       if (inherits(cond, "message")) {
[10:59:34.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.890]                         if (muffled) 
[10:59:34.890]                           invokeRestart("muffleMessage")
[10:59:34.890]                       }
[10:59:34.890]                       else if (inherits(cond, "warning")) {
[10:59:34.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.890]                         if (muffled) 
[10:59:34.890]                           invokeRestart("muffleWarning")
[10:59:34.890]                       }
[10:59:34.890]                       else if (inherits(cond, "condition")) {
[10:59:34.890]                         if (!is.null(pattern)) {
[10:59:34.890]                           computeRestarts <- base::computeRestarts
[10:59:34.890]                           grepl <- base::grepl
[10:59:34.890]                           restarts <- computeRestarts(cond)
[10:59:34.890]                           for (restart in restarts) {
[10:59:34.890]                             name <- restart$name
[10:59:34.890]                             if (is.null(name)) 
[10:59:34.890]                               next
[10:59:34.890]                             if (!grepl(pattern, name)) 
[10:59:34.890]                               next
[10:59:34.890]                             invokeRestart(restart)
[10:59:34.890]                             muffled <- TRUE
[10:59:34.890]                             break
[10:59:34.890]                           }
[10:59:34.890]                         }
[10:59:34.890]                       }
[10:59:34.890]                       invisible(muffled)
[10:59:34.890]                     }
[10:59:34.890]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.890]                   }
[10:59:34.890]                 }
[10:59:34.890]             }
[10:59:34.890]         }))
[10:59:34.890]     }, error = function(ex) {
[10:59:34.890]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:34.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.890]                 ...future.rng), started = ...future.startTime, 
[10:59:34.890]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:34.890]             version = "1.8"), class = "FutureResult")
[10:59:34.890]     }, finally = {
[10:59:34.890]         if (!identical(...future.workdir, getwd())) 
[10:59:34.890]             setwd(...future.workdir)
[10:59:34.890]         {
[10:59:34.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:34.890]                 ...future.oldOptions$nwarnings <- NULL
[10:59:34.890]             }
[10:59:34.890]             base::options(...future.oldOptions)
[10:59:34.890]             if (.Platform$OS.type == "windows") {
[10:59:34.890]                 old_names <- names(...future.oldEnvVars)
[10:59:34.890]                 envs <- base::Sys.getenv()
[10:59:34.890]                 names <- names(envs)
[10:59:34.890]                 common <- intersect(names, old_names)
[10:59:34.890]                 added <- setdiff(names, old_names)
[10:59:34.890]                 removed <- setdiff(old_names, names)
[10:59:34.890]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:34.890]                   envs[common]]
[10:59:34.890]                 NAMES <- toupper(changed)
[10:59:34.890]                 args <- list()
[10:59:34.890]                 for (kk in seq_along(NAMES)) {
[10:59:34.890]                   name <- changed[[kk]]
[10:59:34.890]                   NAME <- NAMES[[kk]]
[10:59:34.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.890]                     next
[10:59:34.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.890]                 }
[10:59:34.890]                 NAMES <- toupper(added)
[10:59:34.890]                 for (kk in seq_along(NAMES)) {
[10:59:34.890]                   name <- added[[kk]]
[10:59:34.890]                   NAME <- NAMES[[kk]]
[10:59:34.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.890]                     next
[10:59:34.890]                   args[[name]] <- ""
[10:59:34.890]                 }
[10:59:34.890]                 NAMES <- toupper(removed)
[10:59:34.890]                 for (kk in seq_along(NAMES)) {
[10:59:34.890]                   name <- removed[[kk]]
[10:59:34.890]                   NAME <- NAMES[[kk]]
[10:59:34.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.890]                     next
[10:59:34.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.890]                 }
[10:59:34.890]                 if (length(args) > 0) 
[10:59:34.890]                   base::do.call(base::Sys.setenv, args = args)
[10:59:34.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:34.890]             }
[10:59:34.890]             else {
[10:59:34.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:34.890]             }
[10:59:34.890]             {
[10:59:34.890]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:34.890]                   0L) {
[10:59:34.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:34.890]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:34.890]                   base::options(opts)
[10:59:34.890]                 }
[10:59:34.890]                 {
[10:59:34.890]                   {
[10:59:34.890]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:34.890]                     NULL
[10:59:34.890]                   }
[10:59:34.890]                   options(future.plan = NULL)
[10:59:34.890]                   if (is.na(NA_character_)) 
[10:59:34.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:34.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:34.890]                     .init = FALSE)
[10:59:34.890]                 }
[10:59:34.890]             }
[10:59:34.890]         }
[10:59:34.890]     })
[10:59:34.890]     if (TRUE) {
[10:59:34.890]         base::sink(type = "output", split = FALSE)
[10:59:34.890]         if (TRUE) {
[10:59:34.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:34.890]         }
[10:59:34.890]         else {
[10:59:34.890]             ...future.result["stdout"] <- base::list(NULL)
[10:59:34.890]         }
[10:59:34.890]         base::close(...future.stdout)
[10:59:34.890]         ...future.stdout <- NULL
[10:59:34.890]     }
[10:59:34.890]     ...future.result$conditions <- ...future.conditions
[10:59:34.890]     ...future.result$finished <- base::Sys.time()
[10:59:34.890]     ...future.result
[10:59:34.890] }
[10:59:34.893] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[10:59:34.893] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:59:34.893] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:59:34.893] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:34.894] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:34.894] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[10:59:34.894] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[10:59:34.894] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:34.895] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:34.895] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:34.895] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:34.895] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[10:59:34.895] MultisessionFuture started
[10:59:34.896] - Launch lazy future ... done
[10:59:34.896] run() for ‘MultisessionFuture’ ... done
[10:59:34.896] Created future:
[10:59:34.896] MultisessionFuture:
[10:59:34.896] Label: ‘future_mapply-1’
[10:59:34.896] Expression:
[10:59:34.896] {
[10:59:34.896]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.896]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:34.896]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.896]         on.exit(options(oopts), add = TRUE)
[10:59:34.896]     }
[10:59:34.896]     {
[10:59:34.896]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.896]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:34.896]         do.call(mapply, args = args)
[10:59:34.896]     }
[10:59:34.896] }
[10:59:34.896] Lazy evaluation: FALSE
[10:59:34.896] Asynchronous evaluation: TRUE
[10:59:34.896] Local evaluation: TRUE
[10:59:34.896] Environment: R_GlobalEnv
[10:59:34.896] Capture standard output: TRUE
[10:59:34.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:34.896] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:34.896] Packages: <none>
[10:59:34.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:34.896] Resolved: FALSE
[10:59:34.896] Value: <not collected>
[10:59:34.896] Conditions captured: <none>
[10:59:34.896] Early signaling: FALSE
[10:59:34.896] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:34.896] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.907] Chunk #1 of 2 ... DONE
[10:59:34.907] Chunk #2 of 2 ...
[10:59:34.907]  - Finding globals in '...' for chunk #2 ...
[10:59:34.907] getGlobalsAndPackages() ...
[10:59:34.907] Searching for globals...
[10:59:34.908] 
[10:59:34.908] Searching for globals ... DONE
[10:59:34.908] - globals: [0] <none>
[10:59:34.908] getGlobalsAndPackages() ... DONE
[10:59:34.908]    + additional globals found: [n=0] 
[10:59:34.908]    + additional namespaces needed: [n=0] 
[10:59:34.908]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:34.908]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:34.908]  - seeds: <none>
[10:59:34.908]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.909] getGlobalsAndPackages() ...
[10:59:34.909] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.909] Resolving globals: FALSE
[10:59:34.909] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:34.910] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:34.910] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.910] 
[10:59:34.910] getGlobalsAndPackages() ... DONE
[10:59:34.910] run() for ‘Future’ ...
[10:59:34.910] - state: ‘created’
[10:59:34.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:34.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:34.924]   - Field: ‘node’
[10:59:34.924]   - Field: ‘label’
[10:59:34.924]   - Field: ‘local’
[10:59:34.924]   - Field: ‘owner’
[10:59:34.924]   - Field: ‘envir’
[10:59:34.924]   - Field: ‘workers’
[10:59:34.924]   - Field: ‘packages’
[10:59:34.924]   - Field: ‘gc’
[10:59:34.924]   - Field: ‘conditions’
[10:59:34.925]   - Field: ‘persistent’
[10:59:34.925]   - Field: ‘expr’
[10:59:34.925]   - Field: ‘uuid’
[10:59:34.925]   - Field: ‘seed’
[10:59:34.925]   - Field: ‘version’
[10:59:34.925]   - Field: ‘result’
[10:59:34.925]   - Field: ‘asynchronous’
[10:59:34.925]   - Field: ‘calls’
[10:59:34.925]   - Field: ‘globals’
[10:59:34.925]   - Field: ‘stdout’
[10:59:34.925]   - Field: ‘earlySignal’
[10:59:34.925]   - Field: ‘lazy’
[10:59:34.926]   - Field: ‘state’
[10:59:34.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:34.926] - Launch lazy future ...
[10:59:34.926] Packages needed by the future expression (n = 0): <none>
[10:59:34.926] Packages needed by future strategies (n = 0): <none>
[10:59:34.926] {
[10:59:34.926]     {
[10:59:34.926]         {
[10:59:34.926]             ...future.startTime <- base::Sys.time()
[10:59:34.926]             {
[10:59:34.926]                 {
[10:59:34.926]                   {
[10:59:34.926]                     {
[10:59:34.926]                       base::local({
[10:59:34.926]                         has_future <- base::requireNamespace("future", 
[10:59:34.926]                           quietly = TRUE)
[10:59:34.926]                         if (has_future) {
[10:59:34.926]                           ns <- base::getNamespace("future")
[10:59:34.926]                           version <- ns[[".package"]][["version"]]
[10:59:34.926]                           if (is.null(version)) 
[10:59:34.926]                             version <- utils::packageVersion("future")
[10:59:34.926]                         }
[10:59:34.926]                         else {
[10:59:34.926]                           version <- NULL
[10:59:34.926]                         }
[10:59:34.926]                         if (!has_future || version < "1.8.0") {
[10:59:34.926]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:34.926]                             "", base::R.version$version.string), 
[10:59:34.926]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:34.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:34.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:34.926]                               "release", "version")], collapse = " "), 
[10:59:34.926]                             hostname = base::Sys.info()[["nodename"]])
[10:59:34.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:34.926]                             info)
[10:59:34.926]                           info <- base::paste(info, collapse = "; ")
[10:59:34.926]                           if (!has_future) {
[10:59:34.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:34.926]                               info)
[10:59:34.926]                           }
[10:59:34.926]                           else {
[10:59:34.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:34.926]                               info, version)
[10:59:34.926]                           }
[10:59:34.926]                           base::stop(msg)
[10:59:34.926]                         }
[10:59:34.926]                       })
[10:59:34.926]                     }
[10:59:34.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:34.926]                     base::options(mc.cores = 1L)
[10:59:34.926]                   }
[10:59:34.926]                   ...future.strategy.old <- future::plan("list")
[10:59:34.926]                   options(future.plan = NULL)
[10:59:34.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:34.926]                 }
[10:59:34.926]                 ...future.workdir <- getwd()
[10:59:34.926]             }
[10:59:34.926]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:34.926]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:34.926]         }
[10:59:34.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:34.926]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:34.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:34.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:34.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:34.926]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:34.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:34.926]             base::names(...future.oldOptions))
[10:59:34.926]     }
[10:59:34.926]     if (FALSE) {
[10:59:34.926]     }
[10:59:34.926]     else {
[10:59:34.926]         if (TRUE) {
[10:59:34.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:34.926]                 open = "w")
[10:59:34.926]         }
[10:59:34.926]         else {
[10:59:34.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:34.926]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:34.926]         }
[10:59:34.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:34.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:34.926]             base::sink(type = "output", split = FALSE)
[10:59:34.926]             base::close(...future.stdout)
[10:59:34.926]         }, add = TRUE)
[10:59:34.926]     }
[10:59:34.926]     ...future.frame <- base::sys.nframe()
[10:59:34.926]     ...future.conditions <- base::list()
[10:59:34.926]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:34.926]     if (FALSE) {
[10:59:34.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:34.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:34.926]     }
[10:59:34.926]     ...future.result <- base::tryCatch({
[10:59:34.926]         base::withCallingHandlers({
[10:59:34.926]             ...future.value <- base::withVisible(base::local({
[10:59:34.926]                 ...future.makeSendCondition <- base::local({
[10:59:34.926]                   sendCondition <- NULL
[10:59:34.926]                   function(frame = 1L) {
[10:59:34.926]                     if (is.function(sendCondition)) 
[10:59:34.926]                       return(sendCondition)
[10:59:34.926]                     ns <- getNamespace("parallel")
[10:59:34.926]                     if (exists("sendData", mode = "function", 
[10:59:34.926]                       envir = ns)) {
[10:59:34.926]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:34.926]                         envir = ns)
[10:59:34.926]                       envir <- sys.frame(frame)
[10:59:34.926]                       master <- NULL
[10:59:34.926]                       while (!identical(envir, .GlobalEnv) && 
[10:59:34.926]                         !identical(envir, emptyenv())) {
[10:59:34.926]                         if (exists("master", mode = "list", envir = envir, 
[10:59:34.926]                           inherits = FALSE)) {
[10:59:34.926]                           master <- get("master", mode = "list", 
[10:59:34.926]                             envir = envir, inherits = FALSE)
[10:59:34.926]                           if (inherits(master, c("SOCKnode", 
[10:59:34.926]                             "SOCK0node"))) {
[10:59:34.926]                             sendCondition <<- function(cond) {
[10:59:34.926]                               data <- list(type = "VALUE", value = cond, 
[10:59:34.926]                                 success = TRUE)
[10:59:34.926]                               parallel_sendData(master, data)
[10:59:34.926]                             }
[10:59:34.926]                             return(sendCondition)
[10:59:34.926]                           }
[10:59:34.926]                         }
[10:59:34.926]                         frame <- frame + 1L
[10:59:34.926]                         envir <- sys.frame(frame)
[10:59:34.926]                       }
[10:59:34.926]                     }
[10:59:34.926]                     sendCondition <<- function(cond) NULL
[10:59:34.926]                   }
[10:59:34.926]                 })
[10:59:34.926]                 withCallingHandlers({
[10:59:34.926]                   {
[10:59:34.926]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.926]                     if (!identical(...future.globals.maxSize.org, 
[10:59:34.926]                       ...future.globals.maxSize)) {
[10:59:34.926]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.926]                       on.exit(options(oopts), add = TRUE)
[10:59:34.926]                     }
[10:59:34.926]                     {
[10:59:34.926]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.926]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:34.926]                         USE.NAMES = FALSE)
[10:59:34.926]                       do.call(mapply, args = args)
[10:59:34.926]                     }
[10:59:34.926]                   }
[10:59:34.926]                 }, immediateCondition = function(cond) {
[10:59:34.926]                   sendCondition <- ...future.makeSendCondition()
[10:59:34.926]                   sendCondition(cond)
[10:59:34.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.926]                   {
[10:59:34.926]                     inherits <- base::inherits
[10:59:34.926]                     invokeRestart <- base::invokeRestart
[10:59:34.926]                     is.null <- base::is.null
[10:59:34.926]                     muffled <- FALSE
[10:59:34.926]                     if (inherits(cond, "message")) {
[10:59:34.926]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:34.926]                       if (muffled) 
[10:59:34.926]                         invokeRestart("muffleMessage")
[10:59:34.926]                     }
[10:59:34.926]                     else if (inherits(cond, "warning")) {
[10:59:34.926]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:34.926]                       if (muffled) 
[10:59:34.926]                         invokeRestart("muffleWarning")
[10:59:34.926]                     }
[10:59:34.926]                     else if (inherits(cond, "condition")) {
[10:59:34.926]                       if (!is.null(pattern)) {
[10:59:34.926]                         computeRestarts <- base::computeRestarts
[10:59:34.926]                         grepl <- base::grepl
[10:59:34.926]                         restarts <- computeRestarts(cond)
[10:59:34.926]                         for (restart in restarts) {
[10:59:34.926]                           name <- restart$name
[10:59:34.926]                           if (is.null(name)) 
[10:59:34.926]                             next
[10:59:34.926]                           if (!grepl(pattern, name)) 
[10:59:34.926]                             next
[10:59:34.926]                           invokeRestart(restart)
[10:59:34.926]                           muffled <- TRUE
[10:59:34.926]                           break
[10:59:34.926]                         }
[10:59:34.926]                       }
[10:59:34.926]                     }
[10:59:34.926]                     invisible(muffled)
[10:59:34.926]                   }
[10:59:34.926]                   muffleCondition(cond)
[10:59:34.926]                 })
[10:59:34.926]             }))
[10:59:34.926]             future::FutureResult(value = ...future.value$value, 
[10:59:34.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.926]                   ...future.rng), globalenv = if (FALSE) 
[10:59:34.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:34.926]                     ...future.globalenv.names))
[10:59:34.926]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:34.926]         }, condition = base::local({
[10:59:34.926]             c <- base::c
[10:59:34.926]             inherits <- base::inherits
[10:59:34.926]             invokeRestart <- base::invokeRestart
[10:59:34.926]             length <- base::length
[10:59:34.926]             list <- base::list
[10:59:34.926]             seq.int <- base::seq.int
[10:59:34.926]             signalCondition <- base::signalCondition
[10:59:34.926]             sys.calls <- base::sys.calls
[10:59:34.926]             `[[` <- base::`[[`
[10:59:34.926]             `+` <- base::`+`
[10:59:34.926]             `<<-` <- base::`<<-`
[10:59:34.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:34.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:34.926]                   3L)]
[10:59:34.926]             }
[10:59:34.926]             function(cond) {
[10:59:34.926]                 is_error <- inherits(cond, "error")
[10:59:34.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:34.926]                   NULL)
[10:59:34.926]                 if (is_error) {
[10:59:34.926]                   sessionInformation <- function() {
[10:59:34.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:34.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:34.926]                       search = base::search(), system = base::Sys.info())
[10:59:34.926]                   }
[10:59:34.926]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:34.926]                     cond$call), session = sessionInformation(), 
[10:59:34.926]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:34.926]                   signalCondition(cond)
[10:59:34.926]                 }
[10:59:34.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:34.926]                 "immediateCondition"))) {
[10:59:34.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:34.926]                   ...future.conditions[[length(...future.conditions) + 
[10:59:34.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:34.926]                   if (TRUE && !signal) {
[10:59:34.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.926]                     {
[10:59:34.926]                       inherits <- base::inherits
[10:59:34.926]                       invokeRestart <- base::invokeRestart
[10:59:34.926]                       is.null <- base::is.null
[10:59:34.926]                       muffled <- FALSE
[10:59:34.926]                       if (inherits(cond, "message")) {
[10:59:34.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.926]                         if (muffled) 
[10:59:34.926]                           invokeRestart("muffleMessage")
[10:59:34.926]                       }
[10:59:34.926]                       else if (inherits(cond, "warning")) {
[10:59:34.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.926]                         if (muffled) 
[10:59:34.926]                           invokeRestart("muffleWarning")
[10:59:34.926]                       }
[10:59:34.926]                       else if (inherits(cond, "condition")) {
[10:59:34.926]                         if (!is.null(pattern)) {
[10:59:34.926]                           computeRestarts <- base::computeRestarts
[10:59:34.926]                           grepl <- base::grepl
[10:59:34.926]                           restarts <- computeRestarts(cond)
[10:59:34.926]                           for (restart in restarts) {
[10:59:34.926]                             name <- restart$name
[10:59:34.926]                             if (is.null(name)) 
[10:59:34.926]                               next
[10:59:34.926]                             if (!grepl(pattern, name)) 
[10:59:34.926]                               next
[10:59:34.926]                             invokeRestart(restart)
[10:59:34.926]                             muffled <- TRUE
[10:59:34.926]                             break
[10:59:34.926]                           }
[10:59:34.926]                         }
[10:59:34.926]                       }
[10:59:34.926]                       invisible(muffled)
[10:59:34.926]                     }
[10:59:34.926]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.926]                   }
[10:59:34.926]                 }
[10:59:34.926]                 else {
[10:59:34.926]                   if (TRUE) {
[10:59:34.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:34.926]                     {
[10:59:34.926]                       inherits <- base::inherits
[10:59:34.926]                       invokeRestart <- base::invokeRestart
[10:59:34.926]                       is.null <- base::is.null
[10:59:34.926]                       muffled <- FALSE
[10:59:34.926]                       if (inherits(cond, "message")) {
[10:59:34.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:34.926]                         if (muffled) 
[10:59:34.926]                           invokeRestart("muffleMessage")
[10:59:34.926]                       }
[10:59:34.926]                       else if (inherits(cond, "warning")) {
[10:59:34.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:34.926]                         if (muffled) 
[10:59:34.926]                           invokeRestart("muffleWarning")
[10:59:34.926]                       }
[10:59:34.926]                       else if (inherits(cond, "condition")) {
[10:59:34.926]                         if (!is.null(pattern)) {
[10:59:34.926]                           computeRestarts <- base::computeRestarts
[10:59:34.926]                           grepl <- base::grepl
[10:59:34.926]                           restarts <- computeRestarts(cond)
[10:59:34.926]                           for (restart in restarts) {
[10:59:34.926]                             name <- restart$name
[10:59:34.926]                             if (is.null(name)) 
[10:59:34.926]                               next
[10:59:34.926]                             if (!grepl(pattern, name)) 
[10:59:34.926]                               next
[10:59:34.926]                             invokeRestart(restart)
[10:59:34.926]                             muffled <- TRUE
[10:59:34.926]                             break
[10:59:34.926]                           }
[10:59:34.926]                         }
[10:59:34.926]                       }
[10:59:34.926]                       invisible(muffled)
[10:59:34.926]                     }
[10:59:34.926]                     muffleCondition(cond, pattern = "^muffle")
[10:59:34.926]                   }
[10:59:34.926]                 }
[10:59:34.926]             }
[10:59:34.926]         }))
[10:59:34.926]     }, error = function(ex) {
[10:59:34.926]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:34.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:34.926]                 ...future.rng), started = ...future.startTime, 
[10:59:34.926]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:34.926]             version = "1.8"), class = "FutureResult")
[10:59:34.926]     }, finally = {
[10:59:34.926]         if (!identical(...future.workdir, getwd())) 
[10:59:34.926]             setwd(...future.workdir)
[10:59:34.926]         {
[10:59:34.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:34.926]                 ...future.oldOptions$nwarnings <- NULL
[10:59:34.926]             }
[10:59:34.926]             base::options(...future.oldOptions)
[10:59:34.926]             if (.Platform$OS.type == "windows") {
[10:59:34.926]                 old_names <- names(...future.oldEnvVars)
[10:59:34.926]                 envs <- base::Sys.getenv()
[10:59:34.926]                 names <- names(envs)
[10:59:34.926]                 common <- intersect(names, old_names)
[10:59:34.926]                 added <- setdiff(names, old_names)
[10:59:34.926]                 removed <- setdiff(old_names, names)
[10:59:34.926]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:34.926]                   envs[common]]
[10:59:34.926]                 NAMES <- toupper(changed)
[10:59:34.926]                 args <- list()
[10:59:34.926]                 for (kk in seq_along(NAMES)) {
[10:59:34.926]                   name <- changed[[kk]]
[10:59:34.926]                   NAME <- NAMES[[kk]]
[10:59:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.926]                     next
[10:59:34.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.926]                 }
[10:59:34.926]                 NAMES <- toupper(added)
[10:59:34.926]                 for (kk in seq_along(NAMES)) {
[10:59:34.926]                   name <- added[[kk]]
[10:59:34.926]                   NAME <- NAMES[[kk]]
[10:59:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.926]                     next
[10:59:34.926]                   args[[name]] <- ""
[10:59:34.926]                 }
[10:59:34.926]                 NAMES <- toupper(removed)
[10:59:34.926]                 for (kk in seq_along(NAMES)) {
[10:59:34.926]                   name <- removed[[kk]]
[10:59:34.926]                   NAME <- NAMES[[kk]]
[10:59:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:34.926]                     next
[10:59:34.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:34.926]                 }
[10:59:34.926]                 if (length(args) > 0) 
[10:59:34.926]                   base::do.call(base::Sys.setenv, args = args)
[10:59:34.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:34.926]             }
[10:59:34.926]             else {
[10:59:34.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:34.926]             }
[10:59:34.926]             {
[10:59:34.926]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:34.926]                   0L) {
[10:59:34.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:34.926]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:34.926]                   base::options(opts)
[10:59:34.926]                 }
[10:59:34.926]                 {
[10:59:34.926]                   {
[10:59:34.926]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:34.926]                     NULL
[10:59:34.926]                   }
[10:59:34.926]                   options(future.plan = NULL)
[10:59:34.926]                   if (is.na(NA_character_)) 
[10:59:34.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:34.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:34.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:34.926]                     .init = FALSE)
[10:59:34.926]                 }
[10:59:34.926]             }
[10:59:34.926]         }
[10:59:34.926]     })
[10:59:34.926]     if (TRUE) {
[10:59:34.926]         base::sink(type = "output", split = FALSE)
[10:59:34.926]         if (TRUE) {
[10:59:34.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:34.926]         }
[10:59:34.926]         else {
[10:59:34.926]             ...future.result["stdout"] <- base::list(NULL)
[10:59:34.926]         }
[10:59:34.926]         base::close(...future.stdout)
[10:59:34.926]         ...future.stdout <- NULL
[10:59:34.926]     }
[10:59:34.926]     ...future.result$conditions <- ...future.conditions
[10:59:34.926]     ...future.result$finished <- base::Sys.time()
[10:59:34.926]     ...future.result
[10:59:34.926] }
[10:59:34.929] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[10:59:34.929] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:59:34.929] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:59:34.930] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:34.930] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:34.930] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[10:59:34.930] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[10:59:34.931] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:34.931] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:34.931] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:34.931] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:34.931] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[10:59:34.932] MultisessionFuture started
[10:59:34.932] - Launch lazy future ... done
[10:59:34.932] run() for ‘MultisessionFuture’ ... done
[10:59:34.932] Created future:
[10:59:34.932] MultisessionFuture:
[10:59:34.932] Label: ‘future_mapply-2’
[10:59:34.932] Expression:
[10:59:34.932] {
[10:59:34.932]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:34.932]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:34.932]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:34.932]         on.exit(options(oopts), add = TRUE)
[10:59:34.932]     }
[10:59:34.932]     {
[10:59:34.932]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:34.932]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:34.932]         do.call(mapply, args = args)
[10:59:34.932]     }
[10:59:34.932] }
[10:59:34.932] Lazy evaluation: FALSE
[10:59:34.932] Asynchronous evaluation: TRUE
[10:59:34.932] Local evaluation: TRUE
[10:59:34.932] Environment: R_GlobalEnv
[10:59:34.932] Capture standard output: TRUE
[10:59:34.932] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:34.932] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:34.932] Packages: <none>
[10:59:34.932] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:34.932] Resolved: FALSE
[10:59:34.932] Value: <not collected>
[10:59:34.932] Conditions captured: <none>
[10:59:34.932] Early signaling: FALSE
[10:59:34.932] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:34.932] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:34.944] Chunk #2 of 2 ... DONE
[10:59:34.944] Launching 2 futures (chunks) ... DONE
[10:59:34.944] Resolving 2 futures (chunks) ...
[10:59:34.944] resolve() on list ...
[10:59:34.944]  recursive: 0
[10:59:34.944]  length: 2
[10:59:34.944] 
[10:59:34.945] receiveMessageFromWorker() for ClusterFuture ...
[10:59:34.945] - Validating connection of MultisessionFuture
[10:59:34.945] - received message: FutureResult
[10:59:34.945] - Received FutureResult
[10:59:34.945] - Erased future from FutureRegistry
[10:59:34.945] result() for ClusterFuture ...
[10:59:34.945] - result already collected: FutureResult
[10:59:34.945] result() for ClusterFuture ... done
[10:59:34.945] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:34.945] Future #1
[10:59:34.946] result() for ClusterFuture ...
[10:59:34.946] - result already collected: FutureResult
[10:59:34.946] result() for ClusterFuture ... done
[10:59:34.946] result() for ClusterFuture ...
[10:59:34.946] - result already collected: FutureResult
[10:59:34.946] result() for ClusterFuture ... done
[10:59:34.946] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:34.946] - nx: 2
[10:59:34.946] - relay: TRUE
[10:59:34.946] - stdout: TRUE
[10:59:34.946] - signal: TRUE
[10:59:34.946] - resignal: FALSE
[10:59:34.946] - force: TRUE
[10:59:34.947] - relayed: [n=2] FALSE, FALSE
[10:59:34.947] - queued futures: [n=2] FALSE, FALSE
[10:59:34.947]  - until=1
[10:59:34.947]  - relaying element #1
[10:59:34.947] result() for ClusterFuture ...
[10:59:34.947] - result already collected: FutureResult
[10:59:34.947] result() for ClusterFuture ... done
[10:59:34.947] result() for ClusterFuture ...
[10:59:34.947] - result already collected: FutureResult
[10:59:34.947] result() for ClusterFuture ... done
[10:59:34.947] result() for ClusterFuture ...
[10:59:34.947] - result already collected: FutureResult
[10:59:34.948] result() for ClusterFuture ... done
[10:59:34.948] result() for ClusterFuture ...
[10:59:34.948] - result already collected: FutureResult
[10:59:34.948] result() for ClusterFuture ... done
[10:59:34.948] - relayed: [n=2] TRUE, FALSE
[10:59:34.948] - queued futures: [n=2] TRUE, FALSE
[10:59:34.948] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:34.948]  length: 1 (resolved future 1)
[10:59:34.977] receiveMessageFromWorker() for ClusterFuture ...
[10:59:34.977] - Validating connection of MultisessionFuture
[10:59:34.978] - received message: FutureResult
[10:59:34.978] - Received FutureResult
[10:59:34.978] - Erased future from FutureRegistry
[10:59:34.978] result() for ClusterFuture ...
[10:59:34.978] - result already collected: FutureResult
[10:59:34.978] result() for ClusterFuture ... done
[10:59:34.978] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:34.978] Future #2
[10:59:34.978] result() for ClusterFuture ...
[10:59:34.978] - result already collected: FutureResult
[10:59:34.978] result() for ClusterFuture ... done
[10:59:34.979] result() for ClusterFuture ...
[10:59:34.979] - result already collected: FutureResult
[10:59:34.979] result() for ClusterFuture ... done
[10:59:34.979] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:34.979] - nx: 2
[10:59:34.979] - relay: TRUE
[10:59:34.979] - stdout: TRUE
[10:59:34.979] - signal: TRUE
[10:59:34.979] - resignal: FALSE
[10:59:34.979] - force: TRUE
[10:59:34.979] - relayed: [n=2] TRUE, FALSE
[10:59:34.979] - queued futures: [n=2] TRUE, FALSE
[10:59:34.979]  - until=2
[10:59:34.980]  - relaying element #2
[10:59:34.980] result() for ClusterFuture ...
[10:59:34.980] - result already collected: FutureResult
[10:59:34.980] result() for ClusterFuture ... done
[10:59:34.980] result() for ClusterFuture ...
[10:59:34.980] - result already collected: FutureResult
[10:59:34.980] result() for ClusterFuture ... done
[10:59:34.980] result() for ClusterFuture ...
[10:59:34.980] - result already collected: FutureResult
[10:59:34.980] result() for ClusterFuture ... done
[10:59:34.980] result() for ClusterFuture ...
[10:59:34.980] - result already collected: FutureResult
[10:59:34.980] result() for ClusterFuture ... done
[10:59:34.981] - relayed: [n=2] TRUE, TRUE
[10:59:34.981] - queued futures: [n=2] TRUE, TRUE
[10:59:34.981] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:34.981]  length: 0 (resolved future 2)
[10:59:34.981] Relaying remaining futures
[10:59:34.981] signalConditionsASAP(NULL, pos=0) ...
[10:59:34.981] - nx: 2
[10:59:34.981] - relay: TRUE
[10:59:34.981] - stdout: TRUE
[10:59:34.981] - signal: TRUE
[10:59:34.981] - resignal: FALSE
[10:59:34.981] - force: TRUE
[10:59:34.981] - relayed: [n=2] TRUE, TRUE
[10:59:34.982] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:34.982] - relayed: [n=2] TRUE, TRUE
[10:59:34.982] - queued futures: [n=2] TRUE, TRUE
[10:59:34.982] signalConditionsASAP(NULL, pos=0) ... done
[10:59:34.982] resolve() on list ... DONE
[10:59:34.982] result() for ClusterFuture ...
[10:59:34.982] - result already collected: FutureResult
[10:59:34.982] result() for ClusterFuture ... done
[10:59:34.982] result() for ClusterFuture ...
[10:59:34.982] - result already collected: FutureResult
[10:59:34.982] result() for ClusterFuture ... done
[10:59:34.982] result() for ClusterFuture ...
[10:59:34.983] - result already collected: FutureResult
[10:59:34.983] result() for ClusterFuture ... done
[10:59:34.983] result() for ClusterFuture ...
[10:59:34.983] - result already collected: FutureResult
[10:59:34.983] result() for ClusterFuture ... done
[10:59:34.983]  - Number of value chunks collected: 2
[10:59:34.983] Resolving 2 futures (chunks) ... DONE
[10:59:34.983] Reducing values from 2 chunks ...
[10:59:34.983]  - Number of values collected after concatenation: 4
[10:59:34.983]  - Number of values expected: 4
[10:59:34.983] Reducing values from 2 chunks ... DONE
[10:59:34.983] future_mapply() ... DONE
[10:59:34.984] future_mapply() ...
[10:59:34.985] Number of chunks: 2
[10:59:34.985] getGlobalsAndPackagesXApply() ...
[10:59:34.985]  - future.globals: TRUE
[10:59:34.985] getGlobalsAndPackages() ...
[10:59:34.985] Searching for globals...
[10:59:34.986] - globals found: [1] ‘FUN’
[10:59:34.986] Searching for globals ... DONE
[10:59:34.986] Resolving globals: FALSE
[10:59:34.986] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:34.987] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:34.987] - globals: [1] ‘FUN’
[10:59:34.987] 
[10:59:34.987] getGlobalsAndPackages() ... DONE
[10:59:34.987]  - globals found/used: [n=1] ‘FUN’
[10:59:34.987]  - needed namespaces: [n=0] 
[10:59:34.987] Finding globals ... DONE
[10:59:34.987] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:34.988] List of 2
[10:59:34.988]  $ ...future.FUN:function (x, ...)  
[10:59:34.988]  $ MoreArgs     : NULL
[10:59:34.988]  - attr(*, "where")=List of 2
[10:59:34.988]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:34.988]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:34.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:34.988]  - attr(*, "resolved")= logi FALSE
[10:59:34.988]  - attr(*, "total_size")= num NA
[10:59:34.990] Packages to be attached in all futures: [n=0] 
[10:59:34.990] getGlobalsAndPackagesXApply() ... DONE
[10:59:34.990] Number of futures (= number of chunks): 2
[10:59:34.990] Launching 2 futures (chunks) ...
[10:59:34.990] Chunk #1 of 2 ...
[10:59:34.991]  - Finding globals in '...' for chunk #1 ...
[10:59:34.991] getGlobalsAndPackages() ...
[10:59:34.991] Searching for globals...
[10:59:34.991] 
[10:59:34.991] Searching for globals ... DONE
[10:59:34.991] - globals: [0] <none>
[10:59:34.991] getGlobalsAndPackages() ... DONE
[10:59:34.991]    + additional globals found: [n=0] 
[10:59:34.991]    + additional namespaces needed: [n=0] 
[10:59:34.992]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:34.992]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:34.992]  - seeds: <none>
[10:59:34.992]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.992] getGlobalsAndPackages() ...
[10:59:34.992] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.992] Resolving globals: FALSE
[10:59:34.992] The total size of the 5 globals is 265 bytes (265 bytes)
[10:59:34.993] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:34.993] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:34.993] 
[10:59:34.993] getGlobalsAndPackages() ... DONE
[10:59:34.993] run() for ‘Future’ ...
[10:59:34.993] - state: ‘created’
[10:59:34.994] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.007] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.007] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.007]   - Field: ‘node’
[10:59:35.007]   - Field: ‘label’
[10:59:35.007]   - Field: ‘local’
[10:59:35.007]   - Field: ‘owner’
[10:59:35.007]   - Field: ‘envir’
[10:59:35.008]   - Field: ‘workers’
[10:59:35.008]   - Field: ‘packages’
[10:59:35.008]   - Field: ‘gc’
[10:59:35.008]   - Field: ‘conditions’
[10:59:35.008]   - Field: ‘persistent’
[10:59:35.008]   - Field: ‘expr’
[10:59:35.008]   - Field: ‘uuid’
[10:59:35.008]   - Field: ‘seed’
[10:59:35.008]   - Field: ‘version’
[10:59:35.008]   - Field: ‘result’
[10:59:35.008]   - Field: ‘asynchronous’
[10:59:35.008]   - Field: ‘calls’
[10:59:35.008]   - Field: ‘globals’
[10:59:35.009]   - Field: ‘stdout’
[10:59:35.009]   - Field: ‘earlySignal’
[10:59:35.009]   - Field: ‘lazy’
[10:59:35.009]   - Field: ‘state’
[10:59:35.009] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.009] - Launch lazy future ...
[10:59:35.009] Packages needed by the future expression (n = 0): <none>
[10:59:35.009] Packages needed by future strategies (n = 0): <none>
[10:59:35.010] {
[10:59:35.010]     {
[10:59:35.010]         {
[10:59:35.010]             ...future.startTime <- base::Sys.time()
[10:59:35.010]             {
[10:59:35.010]                 {
[10:59:35.010]                   {
[10:59:35.010]                     {
[10:59:35.010]                       base::local({
[10:59:35.010]                         has_future <- base::requireNamespace("future", 
[10:59:35.010]                           quietly = TRUE)
[10:59:35.010]                         if (has_future) {
[10:59:35.010]                           ns <- base::getNamespace("future")
[10:59:35.010]                           version <- ns[[".package"]][["version"]]
[10:59:35.010]                           if (is.null(version)) 
[10:59:35.010]                             version <- utils::packageVersion("future")
[10:59:35.010]                         }
[10:59:35.010]                         else {
[10:59:35.010]                           version <- NULL
[10:59:35.010]                         }
[10:59:35.010]                         if (!has_future || version < "1.8.0") {
[10:59:35.010]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.010]                             "", base::R.version$version.string), 
[10:59:35.010]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.010]                               "release", "version")], collapse = " "), 
[10:59:35.010]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.010]                             info)
[10:59:35.010]                           info <- base::paste(info, collapse = "; ")
[10:59:35.010]                           if (!has_future) {
[10:59:35.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.010]                               info)
[10:59:35.010]                           }
[10:59:35.010]                           else {
[10:59:35.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.010]                               info, version)
[10:59:35.010]                           }
[10:59:35.010]                           base::stop(msg)
[10:59:35.010]                         }
[10:59:35.010]                       })
[10:59:35.010]                     }
[10:59:35.010]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.010]                     base::options(mc.cores = 1L)
[10:59:35.010]                   }
[10:59:35.010]                   ...future.strategy.old <- future::plan("list")
[10:59:35.010]                   options(future.plan = NULL)
[10:59:35.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.010]                 }
[10:59:35.010]                 ...future.workdir <- getwd()
[10:59:35.010]             }
[10:59:35.010]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.010]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.010]         }
[10:59:35.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.010]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.010]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.010]             base::names(...future.oldOptions))
[10:59:35.010]     }
[10:59:35.010]     if (FALSE) {
[10:59:35.010]     }
[10:59:35.010]     else {
[10:59:35.010]         if (TRUE) {
[10:59:35.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.010]                 open = "w")
[10:59:35.010]         }
[10:59:35.010]         else {
[10:59:35.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.010]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.010]         }
[10:59:35.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.010]             base::sink(type = "output", split = FALSE)
[10:59:35.010]             base::close(...future.stdout)
[10:59:35.010]         }, add = TRUE)
[10:59:35.010]     }
[10:59:35.010]     ...future.frame <- base::sys.nframe()
[10:59:35.010]     ...future.conditions <- base::list()
[10:59:35.010]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.010]     if (FALSE) {
[10:59:35.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.010]     }
[10:59:35.010]     ...future.result <- base::tryCatch({
[10:59:35.010]         base::withCallingHandlers({
[10:59:35.010]             ...future.value <- base::withVisible(base::local({
[10:59:35.010]                 ...future.makeSendCondition <- base::local({
[10:59:35.010]                   sendCondition <- NULL
[10:59:35.010]                   function(frame = 1L) {
[10:59:35.010]                     if (is.function(sendCondition)) 
[10:59:35.010]                       return(sendCondition)
[10:59:35.010]                     ns <- getNamespace("parallel")
[10:59:35.010]                     if (exists("sendData", mode = "function", 
[10:59:35.010]                       envir = ns)) {
[10:59:35.010]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.010]                         envir = ns)
[10:59:35.010]                       envir <- sys.frame(frame)
[10:59:35.010]                       master <- NULL
[10:59:35.010]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.010]                         !identical(envir, emptyenv())) {
[10:59:35.010]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.010]                           inherits = FALSE)) {
[10:59:35.010]                           master <- get("master", mode = "list", 
[10:59:35.010]                             envir = envir, inherits = FALSE)
[10:59:35.010]                           if (inherits(master, c("SOCKnode", 
[10:59:35.010]                             "SOCK0node"))) {
[10:59:35.010]                             sendCondition <<- function(cond) {
[10:59:35.010]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.010]                                 success = TRUE)
[10:59:35.010]                               parallel_sendData(master, data)
[10:59:35.010]                             }
[10:59:35.010]                             return(sendCondition)
[10:59:35.010]                           }
[10:59:35.010]                         }
[10:59:35.010]                         frame <- frame + 1L
[10:59:35.010]                         envir <- sys.frame(frame)
[10:59:35.010]                       }
[10:59:35.010]                     }
[10:59:35.010]                     sendCondition <<- function(cond) NULL
[10:59:35.010]                   }
[10:59:35.010]                 })
[10:59:35.010]                 withCallingHandlers({
[10:59:35.010]                   {
[10:59:35.010]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.010]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.010]                       ...future.globals.maxSize)) {
[10:59:35.010]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.010]                       on.exit(options(oopts), add = TRUE)
[10:59:35.010]                     }
[10:59:35.010]                     {
[10:59:35.010]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.010]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.010]                         USE.NAMES = FALSE)
[10:59:35.010]                       do.call(mapply, args = args)
[10:59:35.010]                     }
[10:59:35.010]                   }
[10:59:35.010]                 }, immediateCondition = function(cond) {
[10:59:35.010]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.010]                   sendCondition(cond)
[10:59:35.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.010]                   {
[10:59:35.010]                     inherits <- base::inherits
[10:59:35.010]                     invokeRestart <- base::invokeRestart
[10:59:35.010]                     is.null <- base::is.null
[10:59:35.010]                     muffled <- FALSE
[10:59:35.010]                     if (inherits(cond, "message")) {
[10:59:35.010]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.010]                       if (muffled) 
[10:59:35.010]                         invokeRestart("muffleMessage")
[10:59:35.010]                     }
[10:59:35.010]                     else if (inherits(cond, "warning")) {
[10:59:35.010]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.010]                       if (muffled) 
[10:59:35.010]                         invokeRestart("muffleWarning")
[10:59:35.010]                     }
[10:59:35.010]                     else if (inherits(cond, "condition")) {
[10:59:35.010]                       if (!is.null(pattern)) {
[10:59:35.010]                         computeRestarts <- base::computeRestarts
[10:59:35.010]                         grepl <- base::grepl
[10:59:35.010]                         restarts <- computeRestarts(cond)
[10:59:35.010]                         for (restart in restarts) {
[10:59:35.010]                           name <- restart$name
[10:59:35.010]                           if (is.null(name)) 
[10:59:35.010]                             next
[10:59:35.010]                           if (!grepl(pattern, name)) 
[10:59:35.010]                             next
[10:59:35.010]                           invokeRestart(restart)
[10:59:35.010]                           muffled <- TRUE
[10:59:35.010]                           break
[10:59:35.010]                         }
[10:59:35.010]                       }
[10:59:35.010]                     }
[10:59:35.010]                     invisible(muffled)
[10:59:35.010]                   }
[10:59:35.010]                   muffleCondition(cond)
[10:59:35.010]                 })
[10:59:35.010]             }))
[10:59:35.010]             future::FutureResult(value = ...future.value$value, 
[10:59:35.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.010]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.010]                     ...future.globalenv.names))
[10:59:35.010]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.010]         }, condition = base::local({
[10:59:35.010]             c <- base::c
[10:59:35.010]             inherits <- base::inherits
[10:59:35.010]             invokeRestart <- base::invokeRestart
[10:59:35.010]             length <- base::length
[10:59:35.010]             list <- base::list
[10:59:35.010]             seq.int <- base::seq.int
[10:59:35.010]             signalCondition <- base::signalCondition
[10:59:35.010]             sys.calls <- base::sys.calls
[10:59:35.010]             `[[` <- base::`[[`
[10:59:35.010]             `+` <- base::`+`
[10:59:35.010]             `<<-` <- base::`<<-`
[10:59:35.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.010]                   3L)]
[10:59:35.010]             }
[10:59:35.010]             function(cond) {
[10:59:35.010]                 is_error <- inherits(cond, "error")
[10:59:35.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.010]                   NULL)
[10:59:35.010]                 if (is_error) {
[10:59:35.010]                   sessionInformation <- function() {
[10:59:35.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.010]                       search = base::search(), system = base::Sys.info())
[10:59:35.010]                   }
[10:59:35.010]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.010]                     cond$call), session = sessionInformation(), 
[10:59:35.010]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.010]                   signalCondition(cond)
[10:59:35.010]                 }
[10:59:35.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.010]                 "immediateCondition"))) {
[10:59:35.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.010]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.010]                   if (TRUE && !signal) {
[10:59:35.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.010]                     {
[10:59:35.010]                       inherits <- base::inherits
[10:59:35.010]                       invokeRestart <- base::invokeRestart
[10:59:35.010]                       is.null <- base::is.null
[10:59:35.010]                       muffled <- FALSE
[10:59:35.010]                       if (inherits(cond, "message")) {
[10:59:35.010]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.010]                         if (muffled) 
[10:59:35.010]                           invokeRestart("muffleMessage")
[10:59:35.010]                       }
[10:59:35.010]                       else if (inherits(cond, "warning")) {
[10:59:35.010]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.010]                         if (muffled) 
[10:59:35.010]                           invokeRestart("muffleWarning")
[10:59:35.010]                       }
[10:59:35.010]                       else if (inherits(cond, "condition")) {
[10:59:35.010]                         if (!is.null(pattern)) {
[10:59:35.010]                           computeRestarts <- base::computeRestarts
[10:59:35.010]                           grepl <- base::grepl
[10:59:35.010]                           restarts <- computeRestarts(cond)
[10:59:35.010]                           for (restart in restarts) {
[10:59:35.010]                             name <- restart$name
[10:59:35.010]                             if (is.null(name)) 
[10:59:35.010]                               next
[10:59:35.010]                             if (!grepl(pattern, name)) 
[10:59:35.010]                               next
[10:59:35.010]                             invokeRestart(restart)
[10:59:35.010]                             muffled <- TRUE
[10:59:35.010]                             break
[10:59:35.010]                           }
[10:59:35.010]                         }
[10:59:35.010]                       }
[10:59:35.010]                       invisible(muffled)
[10:59:35.010]                     }
[10:59:35.010]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.010]                   }
[10:59:35.010]                 }
[10:59:35.010]                 else {
[10:59:35.010]                   if (TRUE) {
[10:59:35.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.010]                     {
[10:59:35.010]                       inherits <- base::inherits
[10:59:35.010]                       invokeRestart <- base::invokeRestart
[10:59:35.010]                       is.null <- base::is.null
[10:59:35.010]                       muffled <- FALSE
[10:59:35.010]                       if (inherits(cond, "message")) {
[10:59:35.010]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.010]                         if (muffled) 
[10:59:35.010]                           invokeRestart("muffleMessage")
[10:59:35.010]                       }
[10:59:35.010]                       else if (inherits(cond, "warning")) {
[10:59:35.010]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.010]                         if (muffled) 
[10:59:35.010]                           invokeRestart("muffleWarning")
[10:59:35.010]                       }
[10:59:35.010]                       else if (inherits(cond, "condition")) {
[10:59:35.010]                         if (!is.null(pattern)) {
[10:59:35.010]                           computeRestarts <- base::computeRestarts
[10:59:35.010]                           grepl <- base::grepl
[10:59:35.010]                           restarts <- computeRestarts(cond)
[10:59:35.010]                           for (restart in restarts) {
[10:59:35.010]                             name <- restart$name
[10:59:35.010]                             if (is.null(name)) 
[10:59:35.010]                               next
[10:59:35.010]                             if (!grepl(pattern, name)) 
[10:59:35.010]                               next
[10:59:35.010]                             invokeRestart(restart)
[10:59:35.010]                             muffled <- TRUE
[10:59:35.010]                             break
[10:59:35.010]                           }
[10:59:35.010]                         }
[10:59:35.010]                       }
[10:59:35.010]                       invisible(muffled)
[10:59:35.010]                     }
[10:59:35.010]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.010]                   }
[10:59:35.010]                 }
[10:59:35.010]             }
[10:59:35.010]         }))
[10:59:35.010]     }, error = function(ex) {
[10:59:35.010]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.010]                 ...future.rng), started = ...future.startTime, 
[10:59:35.010]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.010]             version = "1.8"), class = "FutureResult")
[10:59:35.010]     }, finally = {
[10:59:35.010]         if (!identical(...future.workdir, getwd())) 
[10:59:35.010]             setwd(...future.workdir)
[10:59:35.010]         {
[10:59:35.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.010]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.010]             }
[10:59:35.010]             base::options(...future.oldOptions)
[10:59:35.010]             if (.Platform$OS.type == "windows") {
[10:59:35.010]                 old_names <- names(...future.oldEnvVars)
[10:59:35.010]                 envs <- base::Sys.getenv()
[10:59:35.010]                 names <- names(envs)
[10:59:35.010]                 common <- intersect(names, old_names)
[10:59:35.010]                 added <- setdiff(names, old_names)
[10:59:35.010]                 removed <- setdiff(old_names, names)
[10:59:35.010]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.010]                   envs[common]]
[10:59:35.010]                 NAMES <- toupper(changed)
[10:59:35.010]                 args <- list()
[10:59:35.010]                 for (kk in seq_along(NAMES)) {
[10:59:35.010]                   name <- changed[[kk]]
[10:59:35.010]                   NAME <- NAMES[[kk]]
[10:59:35.010]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.010]                     next
[10:59:35.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.010]                 }
[10:59:35.010]                 NAMES <- toupper(added)
[10:59:35.010]                 for (kk in seq_along(NAMES)) {
[10:59:35.010]                   name <- added[[kk]]
[10:59:35.010]                   NAME <- NAMES[[kk]]
[10:59:35.010]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.010]                     next
[10:59:35.010]                   args[[name]] <- ""
[10:59:35.010]                 }
[10:59:35.010]                 NAMES <- toupper(removed)
[10:59:35.010]                 for (kk in seq_along(NAMES)) {
[10:59:35.010]                   name <- removed[[kk]]
[10:59:35.010]                   NAME <- NAMES[[kk]]
[10:59:35.010]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.010]                     next
[10:59:35.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.010]                 }
[10:59:35.010]                 if (length(args) > 0) 
[10:59:35.010]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.010]             }
[10:59:35.010]             else {
[10:59:35.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.010]             }
[10:59:35.010]             {
[10:59:35.010]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.010]                   0L) {
[10:59:35.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.010]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.010]                   base::options(opts)
[10:59:35.010]                 }
[10:59:35.010]                 {
[10:59:35.010]                   {
[10:59:35.010]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.010]                     NULL
[10:59:35.010]                   }
[10:59:35.010]                   options(future.plan = NULL)
[10:59:35.010]                   if (is.na(NA_character_)) 
[10:59:35.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.010]                     .init = FALSE)
[10:59:35.010]                 }
[10:59:35.010]             }
[10:59:35.010]         }
[10:59:35.010]     })
[10:59:35.010]     if (TRUE) {
[10:59:35.010]         base::sink(type = "output", split = FALSE)
[10:59:35.010]         if (TRUE) {
[10:59:35.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.010]         }
[10:59:35.010]         else {
[10:59:35.010]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.010]         }
[10:59:35.010]         base::close(...future.stdout)
[10:59:35.010]         ...future.stdout <- NULL
[10:59:35.010]     }
[10:59:35.010]     ...future.result$conditions <- ...future.conditions
[10:59:35.010]     ...future.result$finished <- base::Sys.time()
[10:59:35.010]     ...future.result
[10:59:35.010] }
[10:59:35.012] Exporting 5 global objects (715 bytes) to cluster node #1 ...
[10:59:35.013] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:59:35.013] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:59:35.013] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:35.013] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.013] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[10:59:35.014] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[10:59:35.014] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.014] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.014] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.015] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.015] Exporting 5 global objects (715 bytes) to cluster node #1 ... DONE
[10:59:35.015] MultisessionFuture started
[10:59:35.015] - Launch lazy future ... done
[10:59:35.015] run() for ‘MultisessionFuture’ ... done
[10:59:35.016] Created future:
[10:59:35.016] MultisessionFuture:
[10:59:35.016] Label: ‘future_mapply-1’
[10:59:35.016] Expression:
[10:59:35.016] {
[10:59:35.016]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.016]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.016]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.016]         on.exit(options(oopts), add = TRUE)
[10:59:35.016]     }
[10:59:35.016]     {
[10:59:35.016]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.016]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.016]         do.call(mapply, args = args)
[10:59:35.016]     }
[10:59:35.016] }
[10:59:35.016] Lazy evaluation: FALSE
[10:59:35.016] Asynchronous evaluation: TRUE
[10:59:35.016] Local evaluation: TRUE
[10:59:35.016] Environment: R_GlobalEnv
[10:59:35.016] Capture standard output: TRUE
[10:59:35.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.016] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.016] Packages: <none>
[10:59:35.016] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.016] Resolved: FALSE
[10:59:35.016] Value: <not collected>
[10:59:35.016] Conditions captured: <none>
[10:59:35.016] Early signaling: FALSE
[10:59:35.016] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.016] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.027] Chunk #1 of 2 ... DONE
[10:59:35.027] Chunk #2 of 2 ...
[10:59:35.027]  - Finding globals in '...' for chunk #2 ...
[10:59:35.027] getGlobalsAndPackages() ...
[10:59:35.027] Searching for globals...
[10:59:35.028] 
[10:59:35.028] Searching for globals ... DONE
[10:59:35.028] - globals: [0] <none>
[10:59:35.028] getGlobalsAndPackages() ... DONE
[10:59:35.028]    + additional globals found: [n=0] 
[10:59:35.028]    + additional namespaces needed: [n=0] 
[10:59:35.028]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:35.028]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.028]  - seeds: <none>
[10:59:35.028]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.029] getGlobalsAndPackages() ...
[10:59:35.029] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.029] Resolving globals: FALSE
[10:59:35.029] The total size of the 5 globals is 265 bytes (265 bytes)
[10:59:35.029] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.030] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.030] 
[10:59:35.030] getGlobalsAndPackages() ... DONE
[10:59:35.030] run() for ‘Future’ ...
[10:59:35.030] - state: ‘created’
[10:59:35.030] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.044] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.044]   - Field: ‘node’
[10:59:35.044]   - Field: ‘label’
[10:59:35.045]   - Field: ‘local’
[10:59:35.045]   - Field: ‘owner’
[10:59:35.045]   - Field: ‘envir’
[10:59:35.045]   - Field: ‘workers’
[10:59:35.045]   - Field: ‘packages’
[10:59:35.045]   - Field: ‘gc’
[10:59:35.045]   - Field: ‘conditions’
[10:59:35.045]   - Field: ‘persistent’
[10:59:35.045]   - Field: ‘expr’
[10:59:35.045]   - Field: ‘uuid’
[10:59:35.045]   - Field: ‘seed’
[10:59:35.045]   - Field: ‘version’
[10:59:35.046]   - Field: ‘result’
[10:59:35.046]   - Field: ‘asynchronous’
[10:59:35.046]   - Field: ‘calls’
[10:59:35.046]   - Field: ‘globals’
[10:59:35.046]   - Field: ‘stdout’
[10:59:35.046]   - Field: ‘earlySignal’
[10:59:35.046]   - Field: ‘lazy’
[10:59:35.046]   - Field: ‘state’
[10:59:35.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.046] - Launch lazy future ...
[10:59:35.047] Packages needed by the future expression (n = 0): <none>
[10:59:35.047] Packages needed by future strategies (n = 0): <none>
[10:59:35.047] {
[10:59:35.047]     {
[10:59:35.047]         {
[10:59:35.047]             ...future.startTime <- base::Sys.time()
[10:59:35.047]             {
[10:59:35.047]                 {
[10:59:35.047]                   {
[10:59:35.047]                     {
[10:59:35.047]                       base::local({
[10:59:35.047]                         has_future <- base::requireNamespace("future", 
[10:59:35.047]                           quietly = TRUE)
[10:59:35.047]                         if (has_future) {
[10:59:35.047]                           ns <- base::getNamespace("future")
[10:59:35.047]                           version <- ns[[".package"]][["version"]]
[10:59:35.047]                           if (is.null(version)) 
[10:59:35.047]                             version <- utils::packageVersion("future")
[10:59:35.047]                         }
[10:59:35.047]                         else {
[10:59:35.047]                           version <- NULL
[10:59:35.047]                         }
[10:59:35.047]                         if (!has_future || version < "1.8.0") {
[10:59:35.047]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.047]                             "", base::R.version$version.string), 
[10:59:35.047]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.047]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.047]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.047]                               "release", "version")], collapse = " "), 
[10:59:35.047]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.047]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.047]                             info)
[10:59:35.047]                           info <- base::paste(info, collapse = "; ")
[10:59:35.047]                           if (!has_future) {
[10:59:35.047]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.047]                               info)
[10:59:35.047]                           }
[10:59:35.047]                           else {
[10:59:35.047]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.047]                               info, version)
[10:59:35.047]                           }
[10:59:35.047]                           base::stop(msg)
[10:59:35.047]                         }
[10:59:35.047]                       })
[10:59:35.047]                     }
[10:59:35.047]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.047]                     base::options(mc.cores = 1L)
[10:59:35.047]                   }
[10:59:35.047]                   ...future.strategy.old <- future::plan("list")
[10:59:35.047]                   options(future.plan = NULL)
[10:59:35.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.047]                 }
[10:59:35.047]                 ...future.workdir <- getwd()
[10:59:35.047]             }
[10:59:35.047]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.047]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.047]         }
[10:59:35.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.047]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.047]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.047]             base::names(...future.oldOptions))
[10:59:35.047]     }
[10:59:35.047]     if (FALSE) {
[10:59:35.047]     }
[10:59:35.047]     else {
[10:59:35.047]         if (TRUE) {
[10:59:35.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.047]                 open = "w")
[10:59:35.047]         }
[10:59:35.047]         else {
[10:59:35.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.047]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.047]         }
[10:59:35.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.047]             base::sink(type = "output", split = FALSE)
[10:59:35.047]             base::close(...future.stdout)
[10:59:35.047]         }, add = TRUE)
[10:59:35.047]     }
[10:59:35.047]     ...future.frame <- base::sys.nframe()
[10:59:35.047]     ...future.conditions <- base::list()
[10:59:35.047]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.047]     if (FALSE) {
[10:59:35.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.047]     }
[10:59:35.047]     ...future.result <- base::tryCatch({
[10:59:35.047]         base::withCallingHandlers({
[10:59:35.047]             ...future.value <- base::withVisible(base::local({
[10:59:35.047]                 ...future.makeSendCondition <- base::local({
[10:59:35.047]                   sendCondition <- NULL
[10:59:35.047]                   function(frame = 1L) {
[10:59:35.047]                     if (is.function(sendCondition)) 
[10:59:35.047]                       return(sendCondition)
[10:59:35.047]                     ns <- getNamespace("parallel")
[10:59:35.047]                     if (exists("sendData", mode = "function", 
[10:59:35.047]                       envir = ns)) {
[10:59:35.047]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.047]                         envir = ns)
[10:59:35.047]                       envir <- sys.frame(frame)
[10:59:35.047]                       master <- NULL
[10:59:35.047]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.047]                         !identical(envir, emptyenv())) {
[10:59:35.047]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.047]                           inherits = FALSE)) {
[10:59:35.047]                           master <- get("master", mode = "list", 
[10:59:35.047]                             envir = envir, inherits = FALSE)
[10:59:35.047]                           if (inherits(master, c("SOCKnode", 
[10:59:35.047]                             "SOCK0node"))) {
[10:59:35.047]                             sendCondition <<- function(cond) {
[10:59:35.047]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.047]                                 success = TRUE)
[10:59:35.047]                               parallel_sendData(master, data)
[10:59:35.047]                             }
[10:59:35.047]                             return(sendCondition)
[10:59:35.047]                           }
[10:59:35.047]                         }
[10:59:35.047]                         frame <- frame + 1L
[10:59:35.047]                         envir <- sys.frame(frame)
[10:59:35.047]                       }
[10:59:35.047]                     }
[10:59:35.047]                     sendCondition <<- function(cond) NULL
[10:59:35.047]                   }
[10:59:35.047]                 })
[10:59:35.047]                 withCallingHandlers({
[10:59:35.047]                   {
[10:59:35.047]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.047]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.047]                       ...future.globals.maxSize)) {
[10:59:35.047]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.047]                       on.exit(options(oopts), add = TRUE)
[10:59:35.047]                     }
[10:59:35.047]                     {
[10:59:35.047]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.047]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.047]                         USE.NAMES = FALSE)
[10:59:35.047]                       do.call(mapply, args = args)
[10:59:35.047]                     }
[10:59:35.047]                   }
[10:59:35.047]                 }, immediateCondition = function(cond) {
[10:59:35.047]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.047]                   sendCondition(cond)
[10:59:35.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.047]                   {
[10:59:35.047]                     inherits <- base::inherits
[10:59:35.047]                     invokeRestart <- base::invokeRestart
[10:59:35.047]                     is.null <- base::is.null
[10:59:35.047]                     muffled <- FALSE
[10:59:35.047]                     if (inherits(cond, "message")) {
[10:59:35.047]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.047]                       if (muffled) 
[10:59:35.047]                         invokeRestart("muffleMessage")
[10:59:35.047]                     }
[10:59:35.047]                     else if (inherits(cond, "warning")) {
[10:59:35.047]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.047]                       if (muffled) 
[10:59:35.047]                         invokeRestart("muffleWarning")
[10:59:35.047]                     }
[10:59:35.047]                     else if (inherits(cond, "condition")) {
[10:59:35.047]                       if (!is.null(pattern)) {
[10:59:35.047]                         computeRestarts <- base::computeRestarts
[10:59:35.047]                         grepl <- base::grepl
[10:59:35.047]                         restarts <- computeRestarts(cond)
[10:59:35.047]                         for (restart in restarts) {
[10:59:35.047]                           name <- restart$name
[10:59:35.047]                           if (is.null(name)) 
[10:59:35.047]                             next
[10:59:35.047]                           if (!grepl(pattern, name)) 
[10:59:35.047]                             next
[10:59:35.047]                           invokeRestart(restart)
[10:59:35.047]                           muffled <- TRUE
[10:59:35.047]                           break
[10:59:35.047]                         }
[10:59:35.047]                       }
[10:59:35.047]                     }
[10:59:35.047]                     invisible(muffled)
[10:59:35.047]                   }
[10:59:35.047]                   muffleCondition(cond)
[10:59:35.047]                 })
[10:59:35.047]             }))
[10:59:35.047]             future::FutureResult(value = ...future.value$value, 
[10:59:35.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.047]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.047]                     ...future.globalenv.names))
[10:59:35.047]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.047]         }, condition = base::local({
[10:59:35.047]             c <- base::c
[10:59:35.047]             inherits <- base::inherits
[10:59:35.047]             invokeRestart <- base::invokeRestart
[10:59:35.047]             length <- base::length
[10:59:35.047]             list <- base::list
[10:59:35.047]             seq.int <- base::seq.int
[10:59:35.047]             signalCondition <- base::signalCondition
[10:59:35.047]             sys.calls <- base::sys.calls
[10:59:35.047]             `[[` <- base::`[[`
[10:59:35.047]             `+` <- base::`+`
[10:59:35.047]             `<<-` <- base::`<<-`
[10:59:35.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.047]                   3L)]
[10:59:35.047]             }
[10:59:35.047]             function(cond) {
[10:59:35.047]                 is_error <- inherits(cond, "error")
[10:59:35.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.047]                   NULL)
[10:59:35.047]                 if (is_error) {
[10:59:35.047]                   sessionInformation <- function() {
[10:59:35.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.047]                       search = base::search(), system = base::Sys.info())
[10:59:35.047]                   }
[10:59:35.047]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.047]                     cond$call), session = sessionInformation(), 
[10:59:35.047]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.047]                   signalCondition(cond)
[10:59:35.047]                 }
[10:59:35.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.047]                 "immediateCondition"))) {
[10:59:35.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.047]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.047]                   if (TRUE && !signal) {
[10:59:35.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.047]                     {
[10:59:35.047]                       inherits <- base::inherits
[10:59:35.047]                       invokeRestart <- base::invokeRestart
[10:59:35.047]                       is.null <- base::is.null
[10:59:35.047]                       muffled <- FALSE
[10:59:35.047]                       if (inherits(cond, "message")) {
[10:59:35.047]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.047]                         if (muffled) 
[10:59:35.047]                           invokeRestart("muffleMessage")
[10:59:35.047]                       }
[10:59:35.047]                       else if (inherits(cond, "warning")) {
[10:59:35.047]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.047]                         if (muffled) 
[10:59:35.047]                           invokeRestart("muffleWarning")
[10:59:35.047]                       }
[10:59:35.047]                       else if (inherits(cond, "condition")) {
[10:59:35.047]                         if (!is.null(pattern)) {
[10:59:35.047]                           computeRestarts <- base::computeRestarts
[10:59:35.047]                           grepl <- base::grepl
[10:59:35.047]                           restarts <- computeRestarts(cond)
[10:59:35.047]                           for (restart in restarts) {
[10:59:35.047]                             name <- restart$name
[10:59:35.047]                             if (is.null(name)) 
[10:59:35.047]                               next
[10:59:35.047]                             if (!grepl(pattern, name)) 
[10:59:35.047]                               next
[10:59:35.047]                             invokeRestart(restart)
[10:59:35.047]                             muffled <- TRUE
[10:59:35.047]                             break
[10:59:35.047]                           }
[10:59:35.047]                         }
[10:59:35.047]                       }
[10:59:35.047]                       invisible(muffled)
[10:59:35.047]                     }
[10:59:35.047]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.047]                   }
[10:59:35.047]                 }
[10:59:35.047]                 else {
[10:59:35.047]                   if (TRUE) {
[10:59:35.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.047]                     {
[10:59:35.047]                       inherits <- base::inherits
[10:59:35.047]                       invokeRestart <- base::invokeRestart
[10:59:35.047]                       is.null <- base::is.null
[10:59:35.047]                       muffled <- FALSE
[10:59:35.047]                       if (inherits(cond, "message")) {
[10:59:35.047]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.047]                         if (muffled) 
[10:59:35.047]                           invokeRestart("muffleMessage")
[10:59:35.047]                       }
[10:59:35.047]                       else if (inherits(cond, "warning")) {
[10:59:35.047]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.047]                         if (muffled) 
[10:59:35.047]                           invokeRestart("muffleWarning")
[10:59:35.047]                       }
[10:59:35.047]                       else if (inherits(cond, "condition")) {
[10:59:35.047]                         if (!is.null(pattern)) {
[10:59:35.047]                           computeRestarts <- base::computeRestarts
[10:59:35.047]                           grepl <- base::grepl
[10:59:35.047]                           restarts <- computeRestarts(cond)
[10:59:35.047]                           for (restart in restarts) {
[10:59:35.047]                             name <- restart$name
[10:59:35.047]                             if (is.null(name)) 
[10:59:35.047]                               next
[10:59:35.047]                             if (!grepl(pattern, name)) 
[10:59:35.047]                               next
[10:59:35.047]                             invokeRestart(restart)
[10:59:35.047]                             muffled <- TRUE
[10:59:35.047]                             break
[10:59:35.047]                           }
[10:59:35.047]                         }
[10:59:35.047]                       }
[10:59:35.047]                       invisible(muffled)
[10:59:35.047]                     }
[10:59:35.047]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.047]                   }
[10:59:35.047]                 }
[10:59:35.047]             }
[10:59:35.047]         }))
[10:59:35.047]     }, error = function(ex) {
[10:59:35.047]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.047]                 ...future.rng), started = ...future.startTime, 
[10:59:35.047]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.047]             version = "1.8"), class = "FutureResult")
[10:59:35.047]     }, finally = {
[10:59:35.047]         if (!identical(...future.workdir, getwd())) 
[10:59:35.047]             setwd(...future.workdir)
[10:59:35.047]         {
[10:59:35.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.047]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.047]             }
[10:59:35.047]             base::options(...future.oldOptions)
[10:59:35.047]             if (.Platform$OS.type == "windows") {
[10:59:35.047]                 old_names <- names(...future.oldEnvVars)
[10:59:35.047]                 envs <- base::Sys.getenv()
[10:59:35.047]                 names <- names(envs)
[10:59:35.047]                 common <- intersect(names, old_names)
[10:59:35.047]                 added <- setdiff(names, old_names)
[10:59:35.047]                 removed <- setdiff(old_names, names)
[10:59:35.047]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.047]                   envs[common]]
[10:59:35.047]                 NAMES <- toupper(changed)
[10:59:35.047]                 args <- list()
[10:59:35.047]                 for (kk in seq_along(NAMES)) {
[10:59:35.047]                   name <- changed[[kk]]
[10:59:35.047]                   NAME <- NAMES[[kk]]
[10:59:35.047]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.047]                     next
[10:59:35.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.047]                 }
[10:59:35.047]                 NAMES <- toupper(added)
[10:59:35.047]                 for (kk in seq_along(NAMES)) {
[10:59:35.047]                   name <- added[[kk]]
[10:59:35.047]                   NAME <- NAMES[[kk]]
[10:59:35.047]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.047]                     next
[10:59:35.047]                   args[[name]] <- ""
[10:59:35.047]                 }
[10:59:35.047]                 NAMES <- toupper(removed)
[10:59:35.047]                 for (kk in seq_along(NAMES)) {
[10:59:35.047]                   name <- removed[[kk]]
[10:59:35.047]                   NAME <- NAMES[[kk]]
[10:59:35.047]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.047]                     next
[10:59:35.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.047]                 }
[10:59:35.047]                 if (length(args) > 0) 
[10:59:35.047]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.047]             }
[10:59:35.047]             else {
[10:59:35.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.047]             }
[10:59:35.047]             {
[10:59:35.047]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.047]                   0L) {
[10:59:35.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.047]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.047]                   base::options(opts)
[10:59:35.047]                 }
[10:59:35.047]                 {
[10:59:35.047]                   {
[10:59:35.047]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.047]                     NULL
[10:59:35.047]                   }
[10:59:35.047]                   options(future.plan = NULL)
[10:59:35.047]                   if (is.na(NA_character_)) 
[10:59:35.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.047]                     .init = FALSE)
[10:59:35.047]                 }
[10:59:35.047]             }
[10:59:35.047]         }
[10:59:35.047]     })
[10:59:35.047]     if (TRUE) {
[10:59:35.047]         base::sink(type = "output", split = FALSE)
[10:59:35.047]         if (TRUE) {
[10:59:35.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.047]         }
[10:59:35.047]         else {
[10:59:35.047]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.047]         }
[10:59:35.047]         base::close(...future.stdout)
[10:59:35.047]         ...future.stdout <- NULL
[10:59:35.047]     }
[10:59:35.047]     ...future.result$conditions <- ...future.conditions
[10:59:35.047]     ...future.result$finished <- base::Sys.time()
[10:59:35.047]     ...future.result
[10:59:35.047] }
[10:59:35.050] Exporting 5 global objects (715 bytes) to cluster node #2 ...
[10:59:35.050] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:59:35.050] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:59:35.050] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:35.051] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.051] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #2 ...
[10:59:35.051] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #2 ... DONE
[10:59:35.051] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.052] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.052] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.052] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.052] Exporting 5 global objects (715 bytes) to cluster node #2 ... DONE
[10:59:35.053] MultisessionFuture started
[10:59:35.053] - Launch lazy future ... done
[10:59:35.053] run() for ‘MultisessionFuture’ ... done
[10:59:35.053] Created future:
[10:59:35.053] MultisessionFuture:
[10:59:35.053] Label: ‘future_mapply-2’
[10:59:35.053] Expression:
[10:59:35.053] {
[10:59:35.053]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.053]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.053]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.053]         on.exit(options(oopts), add = TRUE)
[10:59:35.053]     }
[10:59:35.053]     {
[10:59:35.053]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.053]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.053]         do.call(mapply, args = args)
[10:59:35.053]     }
[10:59:35.053] }
[10:59:35.053] Lazy evaluation: FALSE
[10:59:35.053] Asynchronous evaluation: TRUE
[10:59:35.053] Local evaluation: TRUE
[10:59:35.053] Environment: R_GlobalEnv
[10:59:35.053] Capture standard output: TRUE
[10:59:35.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.053] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.053] Packages: <none>
[10:59:35.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.053] Resolved: FALSE
[10:59:35.053] Value: <not collected>
[10:59:35.053] Conditions captured: <none>
[10:59:35.053] Early signaling: FALSE
[10:59:35.053] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.053] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.064] Chunk #2 of 2 ... DONE
[10:59:35.064] Launching 2 futures (chunks) ... DONE
[10:59:35.065] Resolving 2 futures (chunks) ...
[10:59:35.065] resolve() on list ...
[10:59:35.065]  recursive: 0
[10:59:35.065]  length: 2
[10:59:35.065] 
[10:59:35.065] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.066] - Validating connection of MultisessionFuture
[10:59:35.066] - received message: FutureResult
[10:59:35.066] - Received FutureResult
[10:59:35.066] - Erased future from FutureRegistry
[10:59:35.066] result() for ClusterFuture ...
[10:59:35.066] - result already collected: FutureResult
[10:59:35.066] result() for ClusterFuture ... done
[10:59:35.066] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.066] Future #1
[10:59:35.067] result() for ClusterFuture ...
[10:59:35.067] - result already collected: FutureResult
[10:59:35.067] result() for ClusterFuture ... done
[10:59:35.067] result() for ClusterFuture ...
[10:59:35.067] - result already collected: FutureResult
[10:59:35.067] result() for ClusterFuture ... done
[10:59:35.067] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:35.067] - nx: 2
[10:59:35.067] - relay: TRUE
[10:59:35.067] - stdout: TRUE
[10:59:35.067] - signal: TRUE
[10:59:35.067] - resignal: FALSE
[10:59:35.068] - force: TRUE
[10:59:35.068] - relayed: [n=2] FALSE, FALSE
[10:59:35.068] - queued futures: [n=2] FALSE, FALSE
[10:59:35.068]  - until=1
[10:59:35.068]  - relaying element #1
[10:59:35.068] result() for ClusterFuture ...
[10:59:35.068] - result already collected: FutureResult
[10:59:35.068] result() for ClusterFuture ... done
[10:59:35.068] result() for ClusterFuture ...
[10:59:35.068] - result already collected: FutureResult
[10:59:35.068] result() for ClusterFuture ... done
[10:59:35.068] result() for ClusterFuture ...
[10:59:35.069] - result already collected: FutureResult
[10:59:35.069] result() for ClusterFuture ... done
[10:59:35.069] result() for ClusterFuture ...
[10:59:35.069] - result already collected: FutureResult
[10:59:35.069] result() for ClusterFuture ... done
[10:59:35.069] - relayed: [n=2] TRUE, FALSE
[10:59:35.069] - queued futures: [n=2] TRUE, FALSE
[10:59:35.069] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:35.069]  length: 1 (resolved future 1)
[10:59:35.094] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.094] - Validating connection of MultisessionFuture
[10:59:35.094] - received message: FutureResult
[10:59:35.095] - Received FutureResult
[10:59:35.095] - Erased future from FutureRegistry
[10:59:35.095] result() for ClusterFuture ...
[10:59:35.095] - result already collected: FutureResult
[10:59:35.095] result() for ClusterFuture ... done
[10:59:35.095] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.095] Future #2
[10:59:35.095] result() for ClusterFuture ...
[10:59:35.095] - result already collected: FutureResult
[10:59:35.095] result() for ClusterFuture ... done
[10:59:35.095] result() for ClusterFuture ...
[10:59:35.095] - result already collected: FutureResult
[10:59:35.096] result() for ClusterFuture ... done
[10:59:35.096] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:35.096] - nx: 2
[10:59:35.096] - relay: TRUE
[10:59:35.096] - stdout: TRUE
[10:59:35.096] - signal: TRUE
[10:59:35.096] - resignal: FALSE
[10:59:35.096] - force: TRUE
[10:59:35.096] - relayed: [n=2] TRUE, FALSE
[10:59:35.096] - queued futures: [n=2] TRUE, FALSE
[10:59:35.096]  - until=2
[10:59:35.097]  - relaying element #2
[10:59:35.097] result() for ClusterFuture ...
[10:59:35.097] - result already collected: FutureResult
[10:59:35.097] result() for ClusterFuture ... done
[10:59:35.097] result() for ClusterFuture ...
[10:59:35.097] - result already collected: FutureResult
[10:59:35.097] result() for ClusterFuture ... done
[10:59:35.097] result() for ClusterFuture ...
[10:59:35.097] - result already collected: FutureResult
[10:59:35.097] result() for ClusterFuture ... done
[10:59:35.097] result() for ClusterFuture ...
[10:59:35.097] - result already collected: FutureResult
[10:59:35.098] result() for ClusterFuture ... done
[10:59:35.098] - relayed: [n=2] TRUE, TRUE
[10:59:35.098] - queued futures: [n=2] TRUE, TRUE
[10:59:35.099] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:35.100]  length: 0 (resolved future 2)
[10:59:35.100] Relaying remaining futures
[10:59:35.100] signalConditionsASAP(NULL, pos=0) ...
[10:59:35.100] - nx: 2
[10:59:35.100] - relay: TRUE
[10:59:35.100] - stdout: TRUE
[10:59:35.100] - signal: TRUE
[10:59:35.100] - resignal: FALSE
[10:59:35.100] - force: TRUE
[10:59:35.100] - relayed: [n=2] TRUE, TRUE
[10:59:35.100] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:35.101] - relayed: [n=2] TRUE, TRUE
[10:59:35.101] - queued futures: [n=2] TRUE, TRUE
[10:59:35.101] signalConditionsASAP(NULL, pos=0) ... done
[10:59:35.101] resolve() on list ... DONE
[10:59:35.101] result() for ClusterFuture ...
[10:59:35.101] - result already collected: FutureResult
[10:59:35.101] result() for ClusterFuture ... done
[10:59:35.101] result() for ClusterFuture ...
[10:59:35.101] - result already collected: FutureResult
[10:59:35.101] result() for ClusterFuture ... done
[10:59:35.101] result() for ClusterFuture ...
[10:59:35.101] - result already collected: FutureResult
[10:59:35.102] result() for ClusterFuture ... done
[10:59:35.102] result() for ClusterFuture ...
[10:59:35.102] - result already collected: FutureResult
[10:59:35.102] result() for ClusterFuture ... done
[10:59:35.102]  - Number of value chunks collected: 2
[10:59:35.102] Resolving 2 futures (chunks) ... DONE
[10:59:35.102] Reducing values from 2 chunks ...
[10:59:35.102]  - Number of values collected after concatenation: 4
[10:59:35.102]  - Number of values expected: 4
[10:59:35.102] Reducing values from 2 chunks ... DONE
[10:59:35.102] future_mapply() ... DONE
[10:59:35.103] future_mapply() ...
[10:59:35.104] Number of chunks: 2
[10:59:35.104] getGlobalsAndPackagesXApply() ...
[10:59:35.104]  - future.globals: TRUE
[10:59:35.104] getGlobalsAndPackages() ...
[10:59:35.104] Searching for globals...
[10:59:35.105] - globals found: [1] ‘FUN’
[10:59:35.105] Searching for globals ... DONE
[10:59:35.105] Resolving globals: FALSE
[10:59:35.105] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:35.106] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:35.106] - globals: [1] ‘FUN’
[10:59:35.106] 
[10:59:35.106] getGlobalsAndPackages() ... DONE
[10:59:35.106]  - globals found/used: [n=1] ‘FUN’
[10:59:35.106]  - needed namespaces: [n=0] 
[10:59:35.106] Finding globals ... DONE
[10:59:35.106] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:35.106] List of 2
[10:59:35.106]  $ ...future.FUN:function (x, ...)  
[10:59:35.106]  $ MoreArgs     :List of 1
[10:59:35.106]   ..$ x: num 42
[10:59:35.106]  - attr(*, "where")=List of 2
[10:59:35.106]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:35.106]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:35.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:35.106]  - attr(*, "resolved")= logi FALSE
[10:59:35.106]  - attr(*, "total_size")= num NA
[10:59:35.109] Packages to be attached in all futures: [n=0] 
[10:59:35.109] getGlobalsAndPackagesXApply() ... DONE
[10:59:35.109] Number of futures (= number of chunks): 2
[10:59:35.109] Launching 2 futures (chunks) ...
[10:59:35.110] Chunk #1 of 2 ...
[10:59:35.110]  - Finding globals in '...' for chunk #1 ...
[10:59:35.110] getGlobalsAndPackages() ...
[10:59:35.110] Searching for globals...
[10:59:35.110] 
[10:59:35.110] Searching for globals ... DONE
[10:59:35.110] - globals: [0] <none>
[10:59:35.110] getGlobalsAndPackages() ... DONE
[10:59:35.110]    + additional globals found: [n=0] 
[10:59:35.110]    + additional namespaces needed: [n=0] 
[10:59:35.111]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:35.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.111]  - seeds: <none>
[10:59:35.111]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.111] getGlobalsAndPackages() ...
[10:59:35.111] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.111] Resolving globals: FALSE
[10:59:35.111] The total size of the 5 globals is 286 bytes (286 bytes)
[10:59:35.112] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:59:35.112] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.112] 
[10:59:35.112] getGlobalsAndPackages() ... DONE
[10:59:35.112] run() for ‘Future’ ...
[10:59:35.112] - state: ‘created’
[10:59:35.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.126] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.126]   - Field: ‘node’
[10:59:35.126]   - Field: ‘label’
[10:59:35.126]   - Field: ‘local’
[10:59:35.126]   - Field: ‘owner’
[10:59:35.126]   - Field: ‘envir’
[10:59:35.126]   - Field: ‘workers’
[10:59:35.126]   - Field: ‘packages’
[10:59:35.127]   - Field: ‘gc’
[10:59:35.127]   - Field: ‘conditions’
[10:59:35.127]   - Field: ‘persistent’
[10:59:35.127]   - Field: ‘expr’
[10:59:35.127]   - Field: ‘uuid’
[10:59:35.127]   - Field: ‘seed’
[10:59:35.127]   - Field: ‘version’
[10:59:35.127]   - Field: ‘result’
[10:59:35.127]   - Field: ‘asynchronous’
[10:59:35.127]   - Field: ‘calls’
[10:59:35.127]   - Field: ‘globals’
[10:59:35.127]   - Field: ‘stdout’
[10:59:35.128]   - Field: ‘earlySignal’
[10:59:35.128]   - Field: ‘lazy’
[10:59:35.128]   - Field: ‘state’
[10:59:35.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.128] - Launch lazy future ...
[10:59:35.128] Packages needed by the future expression (n = 0): <none>
[10:59:35.128] Packages needed by future strategies (n = 0): <none>
[10:59:35.129] {
[10:59:35.129]     {
[10:59:35.129]         {
[10:59:35.129]             ...future.startTime <- base::Sys.time()
[10:59:35.129]             {
[10:59:35.129]                 {
[10:59:35.129]                   {
[10:59:35.129]                     {
[10:59:35.129]                       base::local({
[10:59:35.129]                         has_future <- base::requireNamespace("future", 
[10:59:35.129]                           quietly = TRUE)
[10:59:35.129]                         if (has_future) {
[10:59:35.129]                           ns <- base::getNamespace("future")
[10:59:35.129]                           version <- ns[[".package"]][["version"]]
[10:59:35.129]                           if (is.null(version)) 
[10:59:35.129]                             version <- utils::packageVersion("future")
[10:59:35.129]                         }
[10:59:35.129]                         else {
[10:59:35.129]                           version <- NULL
[10:59:35.129]                         }
[10:59:35.129]                         if (!has_future || version < "1.8.0") {
[10:59:35.129]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.129]                             "", base::R.version$version.string), 
[10:59:35.129]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.129]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.129]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.129]                               "release", "version")], collapse = " "), 
[10:59:35.129]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.129]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.129]                             info)
[10:59:35.129]                           info <- base::paste(info, collapse = "; ")
[10:59:35.129]                           if (!has_future) {
[10:59:35.129]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.129]                               info)
[10:59:35.129]                           }
[10:59:35.129]                           else {
[10:59:35.129]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.129]                               info, version)
[10:59:35.129]                           }
[10:59:35.129]                           base::stop(msg)
[10:59:35.129]                         }
[10:59:35.129]                       })
[10:59:35.129]                     }
[10:59:35.129]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.129]                     base::options(mc.cores = 1L)
[10:59:35.129]                   }
[10:59:35.129]                   ...future.strategy.old <- future::plan("list")
[10:59:35.129]                   options(future.plan = NULL)
[10:59:35.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.129]                 }
[10:59:35.129]                 ...future.workdir <- getwd()
[10:59:35.129]             }
[10:59:35.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.129]         }
[10:59:35.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.129]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.129]             base::names(...future.oldOptions))
[10:59:35.129]     }
[10:59:35.129]     if (FALSE) {
[10:59:35.129]     }
[10:59:35.129]     else {
[10:59:35.129]         if (TRUE) {
[10:59:35.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.129]                 open = "w")
[10:59:35.129]         }
[10:59:35.129]         else {
[10:59:35.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.129]         }
[10:59:35.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.129]             base::sink(type = "output", split = FALSE)
[10:59:35.129]             base::close(...future.stdout)
[10:59:35.129]         }, add = TRUE)
[10:59:35.129]     }
[10:59:35.129]     ...future.frame <- base::sys.nframe()
[10:59:35.129]     ...future.conditions <- base::list()
[10:59:35.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.129]     if (FALSE) {
[10:59:35.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.129]     }
[10:59:35.129]     ...future.result <- base::tryCatch({
[10:59:35.129]         base::withCallingHandlers({
[10:59:35.129]             ...future.value <- base::withVisible(base::local({
[10:59:35.129]                 ...future.makeSendCondition <- base::local({
[10:59:35.129]                   sendCondition <- NULL
[10:59:35.129]                   function(frame = 1L) {
[10:59:35.129]                     if (is.function(sendCondition)) 
[10:59:35.129]                       return(sendCondition)
[10:59:35.129]                     ns <- getNamespace("parallel")
[10:59:35.129]                     if (exists("sendData", mode = "function", 
[10:59:35.129]                       envir = ns)) {
[10:59:35.129]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.129]                         envir = ns)
[10:59:35.129]                       envir <- sys.frame(frame)
[10:59:35.129]                       master <- NULL
[10:59:35.129]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.129]                         !identical(envir, emptyenv())) {
[10:59:35.129]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.129]                           inherits = FALSE)) {
[10:59:35.129]                           master <- get("master", mode = "list", 
[10:59:35.129]                             envir = envir, inherits = FALSE)
[10:59:35.129]                           if (inherits(master, c("SOCKnode", 
[10:59:35.129]                             "SOCK0node"))) {
[10:59:35.129]                             sendCondition <<- function(cond) {
[10:59:35.129]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.129]                                 success = TRUE)
[10:59:35.129]                               parallel_sendData(master, data)
[10:59:35.129]                             }
[10:59:35.129]                             return(sendCondition)
[10:59:35.129]                           }
[10:59:35.129]                         }
[10:59:35.129]                         frame <- frame + 1L
[10:59:35.129]                         envir <- sys.frame(frame)
[10:59:35.129]                       }
[10:59:35.129]                     }
[10:59:35.129]                     sendCondition <<- function(cond) NULL
[10:59:35.129]                   }
[10:59:35.129]                 })
[10:59:35.129]                 withCallingHandlers({
[10:59:35.129]                   {
[10:59:35.129]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.129]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.129]                       ...future.globals.maxSize)) {
[10:59:35.129]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.129]                       on.exit(options(oopts), add = TRUE)
[10:59:35.129]                     }
[10:59:35.129]                     {
[10:59:35.129]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.129]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.129]                         USE.NAMES = FALSE)
[10:59:35.129]                       do.call(mapply, args = args)
[10:59:35.129]                     }
[10:59:35.129]                   }
[10:59:35.129]                 }, immediateCondition = function(cond) {
[10:59:35.129]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.129]                   sendCondition(cond)
[10:59:35.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.129]                   {
[10:59:35.129]                     inherits <- base::inherits
[10:59:35.129]                     invokeRestart <- base::invokeRestart
[10:59:35.129]                     is.null <- base::is.null
[10:59:35.129]                     muffled <- FALSE
[10:59:35.129]                     if (inherits(cond, "message")) {
[10:59:35.129]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.129]                       if (muffled) 
[10:59:35.129]                         invokeRestart("muffleMessage")
[10:59:35.129]                     }
[10:59:35.129]                     else if (inherits(cond, "warning")) {
[10:59:35.129]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.129]                       if (muffled) 
[10:59:35.129]                         invokeRestart("muffleWarning")
[10:59:35.129]                     }
[10:59:35.129]                     else if (inherits(cond, "condition")) {
[10:59:35.129]                       if (!is.null(pattern)) {
[10:59:35.129]                         computeRestarts <- base::computeRestarts
[10:59:35.129]                         grepl <- base::grepl
[10:59:35.129]                         restarts <- computeRestarts(cond)
[10:59:35.129]                         for (restart in restarts) {
[10:59:35.129]                           name <- restart$name
[10:59:35.129]                           if (is.null(name)) 
[10:59:35.129]                             next
[10:59:35.129]                           if (!grepl(pattern, name)) 
[10:59:35.129]                             next
[10:59:35.129]                           invokeRestart(restart)
[10:59:35.129]                           muffled <- TRUE
[10:59:35.129]                           break
[10:59:35.129]                         }
[10:59:35.129]                       }
[10:59:35.129]                     }
[10:59:35.129]                     invisible(muffled)
[10:59:35.129]                   }
[10:59:35.129]                   muffleCondition(cond)
[10:59:35.129]                 })
[10:59:35.129]             }))
[10:59:35.129]             future::FutureResult(value = ...future.value$value, 
[10:59:35.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.129]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.129]                     ...future.globalenv.names))
[10:59:35.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.129]         }, condition = base::local({
[10:59:35.129]             c <- base::c
[10:59:35.129]             inherits <- base::inherits
[10:59:35.129]             invokeRestart <- base::invokeRestart
[10:59:35.129]             length <- base::length
[10:59:35.129]             list <- base::list
[10:59:35.129]             seq.int <- base::seq.int
[10:59:35.129]             signalCondition <- base::signalCondition
[10:59:35.129]             sys.calls <- base::sys.calls
[10:59:35.129]             `[[` <- base::`[[`
[10:59:35.129]             `+` <- base::`+`
[10:59:35.129]             `<<-` <- base::`<<-`
[10:59:35.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.129]                   3L)]
[10:59:35.129]             }
[10:59:35.129]             function(cond) {
[10:59:35.129]                 is_error <- inherits(cond, "error")
[10:59:35.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.129]                   NULL)
[10:59:35.129]                 if (is_error) {
[10:59:35.129]                   sessionInformation <- function() {
[10:59:35.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.129]                       search = base::search(), system = base::Sys.info())
[10:59:35.129]                   }
[10:59:35.129]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.129]                     cond$call), session = sessionInformation(), 
[10:59:35.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.129]                   signalCondition(cond)
[10:59:35.129]                 }
[10:59:35.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.129]                 "immediateCondition"))) {
[10:59:35.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.129]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.129]                   if (TRUE && !signal) {
[10:59:35.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.129]                     {
[10:59:35.129]                       inherits <- base::inherits
[10:59:35.129]                       invokeRestart <- base::invokeRestart
[10:59:35.129]                       is.null <- base::is.null
[10:59:35.129]                       muffled <- FALSE
[10:59:35.129]                       if (inherits(cond, "message")) {
[10:59:35.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.129]                         if (muffled) 
[10:59:35.129]                           invokeRestart("muffleMessage")
[10:59:35.129]                       }
[10:59:35.129]                       else if (inherits(cond, "warning")) {
[10:59:35.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.129]                         if (muffled) 
[10:59:35.129]                           invokeRestart("muffleWarning")
[10:59:35.129]                       }
[10:59:35.129]                       else if (inherits(cond, "condition")) {
[10:59:35.129]                         if (!is.null(pattern)) {
[10:59:35.129]                           computeRestarts <- base::computeRestarts
[10:59:35.129]                           grepl <- base::grepl
[10:59:35.129]                           restarts <- computeRestarts(cond)
[10:59:35.129]                           for (restart in restarts) {
[10:59:35.129]                             name <- restart$name
[10:59:35.129]                             if (is.null(name)) 
[10:59:35.129]                               next
[10:59:35.129]                             if (!grepl(pattern, name)) 
[10:59:35.129]                               next
[10:59:35.129]                             invokeRestart(restart)
[10:59:35.129]                             muffled <- TRUE
[10:59:35.129]                             break
[10:59:35.129]                           }
[10:59:35.129]                         }
[10:59:35.129]                       }
[10:59:35.129]                       invisible(muffled)
[10:59:35.129]                     }
[10:59:35.129]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.129]                   }
[10:59:35.129]                 }
[10:59:35.129]                 else {
[10:59:35.129]                   if (TRUE) {
[10:59:35.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.129]                     {
[10:59:35.129]                       inherits <- base::inherits
[10:59:35.129]                       invokeRestart <- base::invokeRestart
[10:59:35.129]                       is.null <- base::is.null
[10:59:35.129]                       muffled <- FALSE
[10:59:35.129]                       if (inherits(cond, "message")) {
[10:59:35.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.129]                         if (muffled) 
[10:59:35.129]                           invokeRestart("muffleMessage")
[10:59:35.129]                       }
[10:59:35.129]                       else if (inherits(cond, "warning")) {
[10:59:35.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.129]                         if (muffled) 
[10:59:35.129]                           invokeRestart("muffleWarning")
[10:59:35.129]                       }
[10:59:35.129]                       else if (inherits(cond, "condition")) {
[10:59:35.129]                         if (!is.null(pattern)) {
[10:59:35.129]                           computeRestarts <- base::computeRestarts
[10:59:35.129]                           grepl <- base::grepl
[10:59:35.129]                           restarts <- computeRestarts(cond)
[10:59:35.129]                           for (restart in restarts) {
[10:59:35.129]                             name <- restart$name
[10:59:35.129]                             if (is.null(name)) 
[10:59:35.129]                               next
[10:59:35.129]                             if (!grepl(pattern, name)) 
[10:59:35.129]                               next
[10:59:35.129]                             invokeRestart(restart)
[10:59:35.129]                             muffled <- TRUE
[10:59:35.129]                             break
[10:59:35.129]                           }
[10:59:35.129]                         }
[10:59:35.129]                       }
[10:59:35.129]                       invisible(muffled)
[10:59:35.129]                     }
[10:59:35.129]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.129]                   }
[10:59:35.129]                 }
[10:59:35.129]             }
[10:59:35.129]         }))
[10:59:35.129]     }, error = function(ex) {
[10:59:35.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.129]                 ...future.rng), started = ...future.startTime, 
[10:59:35.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.129]             version = "1.8"), class = "FutureResult")
[10:59:35.129]     }, finally = {
[10:59:35.129]         if (!identical(...future.workdir, getwd())) 
[10:59:35.129]             setwd(...future.workdir)
[10:59:35.129]         {
[10:59:35.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.129]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.129]             }
[10:59:35.129]             base::options(...future.oldOptions)
[10:59:35.129]             if (.Platform$OS.type == "windows") {
[10:59:35.129]                 old_names <- names(...future.oldEnvVars)
[10:59:35.129]                 envs <- base::Sys.getenv()
[10:59:35.129]                 names <- names(envs)
[10:59:35.129]                 common <- intersect(names, old_names)
[10:59:35.129]                 added <- setdiff(names, old_names)
[10:59:35.129]                 removed <- setdiff(old_names, names)
[10:59:35.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.129]                   envs[common]]
[10:59:35.129]                 NAMES <- toupper(changed)
[10:59:35.129]                 args <- list()
[10:59:35.129]                 for (kk in seq_along(NAMES)) {
[10:59:35.129]                   name <- changed[[kk]]
[10:59:35.129]                   NAME <- NAMES[[kk]]
[10:59:35.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.129]                     next
[10:59:35.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.129]                 }
[10:59:35.129]                 NAMES <- toupper(added)
[10:59:35.129]                 for (kk in seq_along(NAMES)) {
[10:59:35.129]                   name <- added[[kk]]
[10:59:35.129]                   NAME <- NAMES[[kk]]
[10:59:35.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.129]                     next
[10:59:35.129]                   args[[name]] <- ""
[10:59:35.129]                 }
[10:59:35.129]                 NAMES <- toupper(removed)
[10:59:35.129]                 for (kk in seq_along(NAMES)) {
[10:59:35.129]                   name <- removed[[kk]]
[10:59:35.129]                   NAME <- NAMES[[kk]]
[10:59:35.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.129]                     next
[10:59:35.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.129]                 }
[10:59:35.129]                 if (length(args) > 0) 
[10:59:35.129]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.129]             }
[10:59:35.129]             else {
[10:59:35.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.129]             }
[10:59:35.129]             {
[10:59:35.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.129]                   0L) {
[10:59:35.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.129]                   base::options(opts)
[10:59:35.129]                 }
[10:59:35.129]                 {
[10:59:35.129]                   {
[10:59:35.129]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.129]                     NULL
[10:59:35.129]                   }
[10:59:35.129]                   options(future.plan = NULL)
[10:59:35.129]                   if (is.na(NA_character_)) 
[10:59:35.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.129]                     .init = FALSE)
[10:59:35.129]                 }
[10:59:35.129]             }
[10:59:35.129]         }
[10:59:35.129]     })
[10:59:35.129]     if (TRUE) {
[10:59:35.129]         base::sink(type = "output", split = FALSE)
[10:59:35.129]         if (TRUE) {
[10:59:35.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.129]         }
[10:59:35.129]         else {
[10:59:35.129]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.129]         }
[10:59:35.129]         base::close(...future.stdout)
[10:59:35.129]         ...future.stdout <- NULL
[10:59:35.129]     }
[10:59:35.129]     ...future.result$conditions <- ...future.conditions
[10:59:35.129]     ...future.result$finished <- base::Sys.time()
[10:59:35.129]     ...future.result
[10:59:35.129] }
[10:59:35.131] Exporting 5 global objects (723 bytes) to cluster node #1 ...
[10:59:35.131] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:59:35.132] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:59:35.132] Exporting ‘MoreArgs’ (89 bytes) to cluster node #1 ...
[10:59:35.132] Exporting ‘MoreArgs’ (89 bytes) to cluster node #1 ... DONE
[10:59:35.132] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #1 ...
[10:59:35.133] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #1 ... DONE
[10:59:35.133] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.133] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.133] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.134] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.134] Exporting 5 global objects (723 bytes) to cluster node #1 ... DONE
[10:59:35.134] MultisessionFuture started
[10:59:35.134] - Launch lazy future ... done
[10:59:35.134] run() for ‘MultisessionFuture’ ... done
[10:59:35.135] Created future:
[10:59:35.135] MultisessionFuture:
[10:59:35.135] Label: ‘future_mapply-1’
[10:59:35.135] Expression:
[10:59:35.135] {
[10:59:35.135]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.135]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.135]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.135]         on.exit(options(oopts), add = TRUE)
[10:59:35.135]     }
[10:59:35.135]     {
[10:59:35.135]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.135]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.135]         do.call(mapply, args = args)
[10:59:35.135]     }
[10:59:35.135] }
[10:59:35.135] Lazy evaluation: FALSE
[10:59:35.135] Asynchronous evaluation: TRUE
[10:59:35.135] Local evaluation: TRUE
[10:59:35.135] Environment: R_GlobalEnv
[10:59:35.135] Capture standard output: TRUE
[10:59:35.135] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.135] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.135] Packages: <none>
[10:59:35.135] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.135] Resolved: FALSE
[10:59:35.135] Value: <not collected>
[10:59:35.135] Conditions captured: <none>
[10:59:35.135] Early signaling: FALSE
[10:59:35.135] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.135] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.146] Chunk #1 of 2 ... DONE
[10:59:35.146] Chunk #2 of 2 ...
[10:59:35.146]  - Finding globals in '...' for chunk #2 ...
[10:59:35.146] getGlobalsAndPackages() ...
[10:59:35.146] Searching for globals...
[10:59:35.147] 
[10:59:35.147] Searching for globals ... DONE
[10:59:35.147] - globals: [0] <none>
[10:59:35.147] getGlobalsAndPackages() ... DONE
[10:59:35.147]    + additional globals found: [n=0] 
[10:59:35.147]    + additional namespaces needed: [n=0] 
[10:59:35.147]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:35.147]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.147]  - seeds: <none>
[10:59:35.147]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.148] getGlobalsAndPackages() ...
[10:59:35.148] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.148] Resolving globals: FALSE
[10:59:35.148] The total size of the 5 globals is 286 bytes (286 bytes)
[10:59:35.148] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:59:35.149] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.149] 
[10:59:35.149] getGlobalsAndPackages() ... DONE
[10:59:35.149] run() for ‘Future’ ...
[10:59:35.149] - state: ‘created’
[10:59:35.149] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.162] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.163]   - Field: ‘node’
[10:59:35.163]   - Field: ‘label’
[10:59:35.163]   - Field: ‘local’
[10:59:35.163]   - Field: ‘owner’
[10:59:35.163]   - Field: ‘envir’
[10:59:35.163]   - Field: ‘workers’
[10:59:35.163]   - Field: ‘packages’
[10:59:35.163]   - Field: ‘gc’
[10:59:35.163]   - Field: ‘conditions’
[10:59:35.163]   - Field: ‘persistent’
[10:59:35.163]   - Field: ‘expr’
[10:59:35.164]   - Field: ‘uuid’
[10:59:35.164]   - Field: ‘seed’
[10:59:35.164]   - Field: ‘version’
[10:59:35.164]   - Field: ‘result’
[10:59:35.164]   - Field: ‘asynchronous’
[10:59:35.164]   - Field: ‘calls’
[10:59:35.164]   - Field: ‘globals’
[10:59:35.164]   - Field: ‘stdout’
[10:59:35.164]   - Field: ‘earlySignal’
[10:59:35.164]   - Field: ‘lazy’
[10:59:35.164]   - Field: ‘state’
[10:59:35.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.164] - Launch lazy future ...
[10:59:35.165] Packages needed by the future expression (n = 0): <none>
[10:59:35.165] Packages needed by future strategies (n = 0): <none>
[10:59:35.165] {
[10:59:35.165]     {
[10:59:35.165]         {
[10:59:35.165]             ...future.startTime <- base::Sys.time()
[10:59:35.165]             {
[10:59:35.165]                 {
[10:59:35.165]                   {
[10:59:35.165]                     {
[10:59:35.165]                       base::local({
[10:59:35.165]                         has_future <- base::requireNamespace("future", 
[10:59:35.165]                           quietly = TRUE)
[10:59:35.165]                         if (has_future) {
[10:59:35.165]                           ns <- base::getNamespace("future")
[10:59:35.165]                           version <- ns[[".package"]][["version"]]
[10:59:35.165]                           if (is.null(version)) 
[10:59:35.165]                             version <- utils::packageVersion("future")
[10:59:35.165]                         }
[10:59:35.165]                         else {
[10:59:35.165]                           version <- NULL
[10:59:35.165]                         }
[10:59:35.165]                         if (!has_future || version < "1.8.0") {
[10:59:35.165]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.165]                             "", base::R.version$version.string), 
[10:59:35.165]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.165]                               "release", "version")], collapse = " "), 
[10:59:35.165]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.165]                             info)
[10:59:35.165]                           info <- base::paste(info, collapse = "; ")
[10:59:35.165]                           if (!has_future) {
[10:59:35.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.165]                               info)
[10:59:35.165]                           }
[10:59:35.165]                           else {
[10:59:35.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.165]                               info, version)
[10:59:35.165]                           }
[10:59:35.165]                           base::stop(msg)
[10:59:35.165]                         }
[10:59:35.165]                       })
[10:59:35.165]                     }
[10:59:35.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.165]                     base::options(mc.cores = 1L)
[10:59:35.165]                   }
[10:59:35.165]                   ...future.strategy.old <- future::plan("list")
[10:59:35.165]                   options(future.plan = NULL)
[10:59:35.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.165]                 }
[10:59:35.165]                 ...future.workdir <- getwd()
[10:59:35.165]             }
[10:59:35.165]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.165]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.165]         }
[10:59:35.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.165]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.165]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.165]             base::names(...future.oldOptions))
[10:59:35.165]     }
[10:59:35.165]     if (FALSE) {
[10:59:35.165]     }
[10:59:35.165]     else {
[10:59:35.165]         if (TRUE) {
[10:59:35.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.165]                 open = "w")
[10:59:35.165]         }
[10:59:35.165]         else {
[10:59:35.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.165]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.165]         }
[10:59:35.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.165]             base::sink(type = "output", split = FALSE)
[10:59:35.165]             base::close(...future.stdout)
[10:59:35.165]         }, add = TRUE)
[10:59:35.165]     }
[10:59:35.165]     ...future.frame <- base::sys.nframe()
[10:59:35.165]     ...future.conditions <- base::list()
[10:59:35.165]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.165]     if (FALSE) {
[10:59:35.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.165]     }
[10:59:35.165]     ...future.result <- base::tryCatch({
[10:59:35.165]         base::withCallingHandlers({
[10:59:35.165]             ...future.value <- base::withVisible(base::local({
[10:59:35.165]                 ...future.makeSendCondition <- base::local({
[10:59:35.165]                   sendCondition <- NULL
[10:59:35.165]                   function(frame = 1L) {
[10:59:35.165]                     if (is.function(sendCondition)) 
[10:59:35.165]                       return(sendCondition)
[10:59:35.165]                     ns <- getNamespace("parallel")
[10:59:35.165]                     if (exists("sendData", mode = "function", 
[10:59:35.165]                       envir = ns)) {
[10:59:35.165]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.165]                         envir = ns)
[10:59:35.165]                       envir <- sys.frame(frame)
[10:59:35.165]                       master <- NULL
[10:59:35.165]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.165]                         !identical(envir, emptyenv())) {
[10:59:35.165]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.165]                           inherits = FALSE)) {
[10:59:35.165]                           master <- get("master", mode = "list", 
[10:59:35.165]                             envir = envir, inherits = FALSE)
[10:59:35.165]                           if (inherits(master, c("SOCKnode", 
[10:59:35.165]                             "SOCK0node"))) {
[10:59:35.165]                             sendCondition <<- function(cond) {
[10:59:35.165]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.165]                                 success = TRUE)
[10:59:35.165]                               parallel_sendData(master, data)
[10:59:35.165]                             }
[10:59:35.165]                             return(sendCondition)
[10:59:35.165]                           }
[10:59:35.165]                         }
[10:59:35.165]                         frame <- frame + 1L
[10:59:35.165]                         envir <- sys.frame(frame)
[10:59:35.165]                       }
[10:59:35.165]                     }
[10:59:35.165]                     sendCondition <<- function(cond) NULL
[10:59:35.165]                   }
[10:59:35.165]                 })
[10:59:35.165]                 withCallingHandlers({
[10:59:35.165]                   {
[10:59:35.165]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.165]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.165]                       ...future.globals.maxSize)) {
[10:59:35.165]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.165]                       on.exit(options(oopts), add = TRUE)
[10:59:35.165]                     }
[10:59:35.165]                     {
[10:59:35.165]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.165]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.165]                         USE.NAMES = FALSE)
[10:59:35.165]                       do.call(mapply, args = args)
[10:59:35.165]                     }
[10:59:35.165]                   }
[10:59:35.165]                 }, immediateCondition = function(cond) {
[10:59:35.165]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.165]                   sendCondition(cond)
[10:59:35.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.165]                   {
[10:59:35.165]                     inherits <- base::inherits
[10:59:35.165]                     invokeRestart <- base::invokeRestart
[10:59:35.165]                     is.null <- base::is.null
[10:59:35.165]                     muffled <- FALSE
[10:59:35.165]                     if (inherits(cond, "message")) {
[10:59:35.165]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.165]                       if (muffled) 
[10:59:35.165]                         invokeRestart("muffleMessage")
[10:59:35.165]                     }
[10:59:35.165]                     else if (inherits(cond, "warning")) {
[10:59:35.165]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.165]                       if (muffled) 
[10:59:35.165]                         invokeRestart("muffleWarning")
[10:59:35.165]                     }
[10:59:35.165]                     else if (inherits(cond, "condition")) {
[10:59:35.165]                       if (!is.null(pattern)) {
[10:59:35.165]                         computeRestarts <- base::computeRestarts
[10:59:35.165]                         grepl <- base::grepl
[10:59:35.165]                         restarts <- computeRestarts(cond)
[10:59:35.165]                         for (restart in restarts) {
[10:59:35.165]                           name <- restart$name
[10:59:35.165]                           if (is.null(name)) 
[10:59:35.165]                             next
[10:59:35.165]                           if (!grepl(pattern, name)) 
[10:59:35.165]                             next
[10:59:35.165]                           invokeRestart(restart)
[10:59:35.165]                           muffled <- TRUE
[10:59:35.165]                           break
[10:59:35.165]                         }
[10:59:35.165]                       }
[10:59:35.165]                     }
[10:59:35.165]                     invisible(muffled)
[10:59:35.165]                   }
[10:59:35.165]                   muffleCondition(cond)
[10:59:35.165]                 })
[10:59:35.165]             }))
[10:59:35.165]             future::FutureResult(value = ...future.value$value, 
[10:59:35.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.165]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.165]                     ...future.globalenv.names))
[10:59:35.165]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.165]         }, condition = base::local({
[10:59:35.165]             c <- base::c
[10:59:35.165]             inherits <- base::inherits
[10:59:35.165]             invokeRestart <- base::invokeRestart
[10:59:35.165]             length <- base::length
[10:59:35.165]             list <- base::list
[10:59:35.165]             seq.int <- base::seq.int
[10:59:35.165]             signalCondition <- base::signalCondition
[10:59:35.165]             sys.calls <- base::sys.calls
[10:59:35.165]             `[[` <- base::`[[`
[10:59:35.165]             `+` <- base::`+`
[10:59:35.165]             `<<-` <- base::`<<-`
[10:59:35.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.165]                   3L)]
[10:59:35.165]             }
[10:59:35.165]             function(cond) {
[10:59:35.165]                 is_error <- inherits(cond, "error")
[10:59:35.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.165]                   NULL)
[10:59:35.165]                 if (is_error) {
[10:59:35.165]                   sessionInformation <- function() {
[10:59:35.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.165]                       search = base::search(), system = base::Sys.info())
[10:59:35.165]                   }
[10:59:35.165]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.165]                     cond$call), session = sessionInformation(), 
[10:59:35.165]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.165]                   signalCondition(cond)
[10:59:35.165]                 }
[10:59:35.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.165]                 "immediateCondition"))) {
[10:59:35.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.165]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.165]                   if (TRUE && !signal) {
[10:59:35.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.165]                     {
[10:59:35.165]                       inherits <- base::inherits
[10:59:35.165]                       invokeRestart <- base::invokeRestart
[10:59:35.165]                       is.null <- base::is.null
[10:59:35.165]                       muffled <- FALSE
[10:59:35.165]                       if (inherits(cond, "message")) {
[10:59:35.165]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.165]                         if (muffled) 
[10:59:35.165]                           invokeRestart("muffleMessage")
[10:59:35.165]                       }
[10:59:35.165]                       else if (inherits(cond, "warning")) {
[10:59:35.165]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.165]                         if (muffled) 
[10:59:35.165]                           invokeRestart("muffleWarning")
[10:59:35.165]                       }
[10:59:35.165]                       else if (inherits(cond, "condition")) {
[10:59:35.165]                         if (!is.null(pattern)) {
[10:59:35.165]                           computeRestarts <- base::computeRestarts
[10:59:35.165]                           grepl <- base::grepl
[10:59:35.165]                           restarts <- computeRestarts(cond)
[10:59:35.165]                           for (restart in restarts) {
[10:59:35.165]                             name <- restart$name
[10:59:35.165]                             if (is.null(name)) 
[10:59:35.165]                               next
[10:59:35.165]                             if (!grepl(pattern, name)) 
[10:59:35.165]                               next
[10:59:35.165]                             invokeRestart(restart)
[10:59:35.165]                             muffled <- TRUE
[10:59:35.165]                             break
[10:59:35.165]                           }
[10:59:35.165]                         }
[10:59:35.165]                       }
[10:59:35.165]                       invisible(muffled)
[10:59:35.165]                     }
[10:59:35.165]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.165]                   }
[10:59:35.165]                 }
[10:59:35.165]                 else {
[10:59:35.165]                   if (TRUE) {
[10:59:35.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.165]                     {
[10:59:35.165]                       inherits <- base::inherits
[10:59:35.165]                       invokeRestart <- base::invokeRestart
[10:59:35.165]                       is.null <- base::is.null
[10:59:35.165]                       muffled <- FALSE
[10:59:35.165]                       if (inherits(cond, "message")) {
[10:59:35.165]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.165]                         if (muffled) 
[10:59:35.165]                           invokeRestart("muffleMessage")
[10:59:35.165]                       }
[10:59:35.165]                       else if (inherits(cond, "warning")) {
[10:59:35.165]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.165]                         if (muffled) 
[10:59:35.165]                           invokeRestart("muffleWarning")
[10:59:35.165]                       }
[10:59:35.165]                       else if (inherits(cond, "condition")) {
[10:59:35.165]                         if (!is.null(pattern)) {
[10:59:35.165]                           computeRestarts <- base::computeRestarts
[10:59:35.165]                           grepl <- base::grepl
[10:59:35.165]                           restarts <- computeRestarts(cond)
[10:59:35.165]                           for (restart in restarts) {
[10:59:35.165]                             name <- restart$name
[10:59:35.165]                             if (is.null(name)) 
[10:59:35.165]                               next
[10:59:35.165]                             if (!grepl(pattern, name)) 
[10:59:35.165]                               next
[10:59:35.165]                             invokeRestart(restart)
[10:59:35.165]                             muffled <- TRUE
[10:59:35.165]                             break
[10:59:35.165]                           }
[10:59:35.165]                         }
[10:59:35.165]                       }
[10:59:35.165]                       invisible(muffled)
[10:59:35.165]                     }
[10:59:35.165]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.165]                   }
[10:59:35.165]                 }
[10:59:35.165]             }
[10:59:35.165]         }))
[10:59:35.165]     }, error = function(ex) {
[10:59:35.165]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.165]                 ...future.rng), started = ...future.startTime, 
[10:59:35.165]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.165]             version = "1.8"), class = "FutureResult")
[10:59:35.165]     }, finally = {
[10:59:35.165]         if (!identical(...future.workdir, getwd())) 
[10:59:35.165]             setwd(...future.workdir)
[10:59:35.165]         {
[10:59:35.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.165]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.165]             }
[10:59:35.165]             base::options(...future.oldOptions)
[10:59:35.165]             if (.Platform$OS.type == "windows") {
[10:59:35.165]                 old_names <- names(...future.oldEnvVars)
[10:59:35.165]                 envs <- base::Sys.getenv()
[10:59:35.165]                 names <- names(envs)
[10:59:35.165]                 common <- intersect(names, old_names)
[10:59:35.165]                 added <- setdiff(names, old_names)
[10:59:35.165]                 removed <- setdiff(old_names, names)
[10:59:35.165]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.165]                   envs[common]]
[10:59:35.165]                 NAMES <- toupper(changed)
[10:59:35.165]                 args <- list()
[10:59:35.165]                 for (kk in seq_along(NAMES)) {
[10:59:35.165]                   name <- changed[[kk]]
[10:59:35.165]                   NAME <- NAMES[[kk]]
[10:59:35.165]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.165]                     next
[10:59:35.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.165]                 }
[10:59:35.165]                 NAMES <- toupper(added)
[10:59:35.165]                 for (kk in seq_along(NAMES)) {
[10:59:35.165]                   name <- added[[kk]]
[10:59:35.165]                   NAME <- NAMES[[kk]]
[10:59:35.165]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.165]                     next
[10:59:35.165]                   args[[name]] <- ""
[10:59:35.165]                 }
[10:59:35.165]                 NAMES <- toupper(removed)
[10:59:35.165]                 for (kk in seq_along(NAMES)) {
[10:59:35.165]                   name <- removed[[kk]]
[10:59:35.165]                   NAME <- NAMES[[kk]]
[10:59:35.165]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.165]                     next
[10:59:35.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.165]                 }
[10:59:35.165]                 if (length(args) > 0) 
[10:59:35.165]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.165]             }
[10:59:35.165]             else {
[10:59:35.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.165]             }
[10:59:35.165]             {
[10:59:35.165]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.165]                   0L) {
[10:59:35.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.165]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.165]                   base::options(opts)
[10:59:35.165]                 }
[10:59:35.165]                 {
[10:59:35.165]                   {
[10:59:35.165]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.165]                     NULL
[10:59:35.165]                   }
[10:59:35.165]                   options(future.plan = NULL)
[10:59:35.165]                   if (is.na(NA_character_)) 
[10:59:35.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.165]                     .init = FALSE)
[10:59:35.165]                 }
[10:59:35.165]             }
[10:59:35.165]         }
[10:59:35.165]     })
[10:59:35.165]     if (TRUE) {
[10:59:35.165]         base::sink(type = "output", split = FALSE)
[10:59:35.165]         if (TRUE) {
[10:59:35.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.165]         }
[10:59:35.165]         else {
[10:59:35.165]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.165]         }
[10:59:35.165]         base::close(...future.stdout)
[10:59:35.165]         ...future.stdout <- NULL
[10:59:35.165]     }
[10:59:35.165]     ...future.result$conditions <- ...future.conditions
[10:59:35.165]     ...future.result$finished <- base::Sys.time()
[10:59:35.165]     ...future.result
[10:59:35.165] }
[10:59:35.168] Exporting 5 global objects (723 bytes) to cluster node #2 ...
[10:59:35.168] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:59:35.168] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:59:35.168] Exporting ‘MoreArgs’ (89 bytes) to cluster node #2 ...
[10:59:35.169] Exporting ‘MoreArgs’ (89 bytes) to cluster node #2 ... DONE
[10:59:35.169] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #2 ...
[10:59:35.169] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #2 ... DONE
[10:59:35.169] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.170] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.170] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.170] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.170] Exporting 5 global objects (723 bytes) to cluster node #2 ... DONE
[10:59:35.171] MultisessionFuture started
[10:59:35.171] - Launch lazy future ... done
[10:59:35.171] run() for ‘MultisessionFuture’ ... done
[10:59:35.171] Created future:
[10:59:35.171] MultisessionFuture:
[10:59:35.171] Label: ‘future_mapply-2’
[10:59:35.171] Expression:
[10:59:35.171] {
[10:59:35.171]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.171]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.171]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.171]         on.exit(options(oopts), add = TRUE)
[10:59:35.171]     }
[10:59:35.171]     {
[10:59:35.171]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.171]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.171]         do.call(mapply, args = args)
[10:59:35.171]     }
[10:59:35.171] }
[10:59:35.171] Lazy evaluation: FALSE
[10:59:35.171] Asynchronous evaluation: TRUE
[10:59:35.171] Local evaluation: TRUE
[10:59:35.171] Environment: R_GlobalEnv
[10:59:35.171] Capture standard output: TRUE
[10:59:35.171] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.171] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.171] Packages: <none>
[10:59:35.171] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.171] Resolved: FALSE
[10:59:35.171] Value: <not collected>
[10:59:35.171] Conditions captured: <none>
[10:59:35.171] Early signaling: FALSE
[10:59:35.171] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.171] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.182] Chunk #2 of 2 ... DONE
[10:59:35.183] Launching 2 futures (chunks) ... DONE
[10:59:35.183] Resolving 2 futures (chunks) ...
[10:59:35.183] resolve() on list ...
[10:59:35.183]  recursive: 0
[10:59:35.183]  length: 2
[10:59:35.183] 
[10:59:35.183] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.184] - Validating connection of MultisessionFuture
[10:59:35.184] - received message: FutureResult
[10:59:35.184] - Received FutureResult
[10:59:35.184] - Erased future from FutureRegistry
[10:59:35.184] result() for ClusterFuture ...
[10:59:35.184] - result already collected: FutureResult
[10:59:35.184] result() for ClusterFuture ... done
[10:59:35.184] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.184] Future #1
[10:59:35.184] result() for ClusterFuture ...
[10:59:35.184] - result already collected: FutureResult
[10:59:35.185] result() for ClusterFuture ... done
[10:59:35.185] result() for ClusterFuture ...
[10:59:35.185] - result already collected: FutureResult
[10:59:35.185] result() for ClusterFuture ... done
[10:59:35.185] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:35.185] - nx: 2
[10:59:35.185] - relay: TRUE
[10:59:35.185] - stdout: TRUE
[10:59:35.185] - signal: TRUE
[10:59:35.185] - resignal: FALSE
[10:59:35.185] - force: TRUE
[10:59:35.185] - relayed: [n=2] FALSE, FALSE
[10:59:35.185] - queued futures: [n=2] FALSE, FALSE
[10:59:35.186]  - until=1
[10:59:35.186]  - relaying element #1
[10:59:35.186] result() for ClusterFuture ...
[10:59:35.186] - result already collected: FutureResult
[10:59:35.186] result() for ClusterFuture ... done
[10:59:35.186] result() for ClusterFuture ...
[10:59:35.186] - result already collected: FutureResult
[10:59:35.186] result() for ClusterFuture ... done
[10:59:35.186] result() for ClusterFuture ...
[10:59:35.186] - result already collected: FutureResult
[10:59:35.186] result() for ClusterFuture ... done
[10:59:35.186] result() for ClusterFuture ...
[10:59:35.187] - result already collected: FutureResult
[10:59:35.187] result() for ClusterFuture ... done
[10:59:35.187] - relayed: [n=2] TRUE, FALSE
[10:59:35.187] - queued futures: [n=2] TRUE, FALSE
[10:59:35.187] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:35.187]  length: 1 (resolved future 1)
[10:59:35.213] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.213] - Validating connection of MultisessionFuture
[10:59:35.213] - received message: FutureResult
[10:59:35.214] - Received FutureResult
[10:59:35.214] - Erased future from FutureRegistry
[10:59:35.214] result() for ClusterFuture ...
[10:59:35.214] - result already collected: FutureResult
[10:59:35.214] result() for ClusterFuture ... done
[10:59:35.214] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.214] Future #2
[10:59:35.214] result() for ClusterFuture ...
[10:59:35.214] - result already collected: FutureResult
[10:59:35.214] result() for ClusterFuture ... done
[10:59:35.214] result() for ClusterFuture ...
[10:59:35.215] - result already collected: FutureResult
[10:59:35.215] result() for ClusterFuture ... done
[10:59:35.215] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:35.215] - nx: 2
[10:59:35.215] - relay: TRUE
[10:59:35.215] - stdout: TRUE
[10:59:35.215] - signal: TRUE
[10:59:35.215] - resignal: FALSE
[10:59:35.215] - force: TRUE
[10:59:35.215] - relayed: [n=2] TRUE, FALSE
[10:59:35.215] - queued futures: [n=2] TRUE, FALSE
[10:59:35.215]  - until=2
[10:59:35.215]  - relaying element #2
[10:59:35.216] result() for ClusterFuture ...
[10:59:35.216] - result already collected: FutureResult
[10:59:35.216] result() for ClusterFuture ... done
[10:59:35.216] result() for ClusterFuture ...
[10:59:35.216] - result already collected: FutureResult
[10:59:35.216] result() for ClusterFuture ... done
[10:59:35.216] result() for ClusterFuture ...
[10:59:35.216] - result already collected: FutureResult
[10:59:35.216] result() for ClusterFuture ... done
[10:59:35.216] result() for ClusterFuture ...
[10:59:35.216] - result already collected: FutureResult
[10:59:35.216] result() for ClusterFuture ... done
[10:59:35.217] - relayed: [n=2] TRUE, TRUE
[10:59:35.217] - queued futures: [n=2] TRUE, TRUE
[10:59:35.217] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:35.217]  length: 0 (resolved future 2)
[10:59:35.217] Relaying remaining futures
[10:59:35.217] signalConditionsASAP(NULL, pos=0) ...
[10:59:35.217] - nx: 2
[10:59:35.217] - relay: TRUE
[10:59:35.217] - stdout: TRUE
[10:59:35.217] - signal: TRUE
[10:59:35.217] - resignal: FALSE
[10:59:35.217] - force: TRUE
[10:59:35.217] - relayed: [n=2] TRUE, TRUE
[10:59:35.217] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:35.218] - relayed: [n=2] TRUE, TRUE
[10:59:35.218] - queued futures: [n=2] TRUE, TRUE
[10:59:35.218] signalConditionsASAP(NULL, pos=0) ... done
[10:59:35.218] resolve() on list ... DONE
[10:59:35.218] result() for ClusterFuture ...
[10:59:35.218] - result already collected: FutureResult
[10:59:35.218] result() for ClusterFuture ... done
[10:59:35.218] result() for ClusterFuture ...
[10:59:35.218] - result already collected: FutureResult
[10:59:35.218] result() for ClusterFuture ... done
[10:59:35.218] result() for ClusterFuture ...
[10:59:35.219] - result already collected: FutureResult
[10:59:35.219] result() for ClusterFuture ... done
[10:59:35.219] result() for ClusterFuture ...
[10:59:35.219] - result already collected: FutureResult
[10:59:35.219] result() for ClusterFuture ... done
[10:59:35.219]  - Number of value chunks collected: 2
[10:59:35.219] Resolving 2 futures (chunks) ... DONE
[10:59:35.219] Reducing values from 2 chunks ...
[10:59:35.219]  - Number of values collected after concatenation: 4
[10:59:35.219]  - Number of values expected: 4
[10:59:35.219] Reducing values from 2 chunks ... DONE
[10:59:35.219] future_mapply() ... DONE
[10:59:35.220] future_mapply() ...
[10:59:35.221] Number of chunks: 2
[10:59:35.221] getGlobalsAndPackagesXApply() ...
[10:59:35.221]  - future.globals: TRUE
[10:59:35.221] getGlobalsAndPackages() ...
[10:59:35.221] Searching for globals...
[10:59:35.223] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:59:35.223] Searching for globals ... DONE
[10:59:35.223] Resolving globals: FALSE
[10:59:35.223] The total size of the 1 globals is 414 bytes (414 bytes)
[10:59:35.223] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:59:35.224] - globals: [1] ‘FUN’
[10:59:35.224] 
[10:59:35.224] getGlobalsAndPackages() ... DONE
[10:59:35.224]  - globals found/used: [n=1] ‘FUN’
[10:59:35.224]  - needed namespaces: [n=0] 
[10:59:35.224] Finding globals ... DONE
[10:59:35.224] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:35.224] List of 2
[10:59:35.224]  $ ...future.FUN:function (x, y)  
[10:59:35.224]  $ MoreArgs     : NULL
[10:59:35.224]  - attr(*, "where")=List of 2
[10:59:35.224]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:35.224]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:35.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:35.224]  - attr(*, "resolved")= logi FALSE
[10:59:35.224]  - attr(*, "total_size")= num NA
[10:59:35.227] Packages to be attached in all futures: [n=0] 
[10:59:35.227] getGlobalsAndPackagesXApply() ... DONE
[10:59:35.227] Number of futures (= number of chunks): 2
[10:59:35.227] Launching 2 futures (chunks) ...
[10:59:35.227] Chunk #1 of 2 ...
[10:59:35.227]  - Finding globals in '...' for chunk #1 ...
[10:59:35.227] getGlobalsAndPackages() ...
[10:59:35.227] Searching for globals...
[10:59:35.228] 
[10:59:35.228] Searching for globals ... DONE
[10:59:35.228] - globals: [0] <none>
[10:59:35.228] getGlobalsAndPackages() ... DONE
[10:59:35.228]    + additional globals found: [n=0] 
[10:59:35.228]    + additional namespaces needed: [n=0] 
[10:59:35.228]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:35.228]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.228]  - seeds: <none>
[10:59:35.228]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.229] getGlobalsAndPackages() ...
[10:59:35.229] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.229] Resolving globals: FALSE
[10:59:35.229] The total size of the 5 globals is 645 bytes (645 bytes)
[10:59:35.229] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 645 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.230] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.230] 
[10:59:35.230] getGlobalsAndPackages() ... DONE
[10:59:35.230] run() for ‘Future’ ...
[10:59:35.230] - state: ‘created’
[10:59:35.230] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.245]   - Field: ‘node’
[10:59:35.245]   - Field: ‘label’
[10:59:35.246]   - Field: ‘local’
[10:59:35.246]   - Field: ‘owner’
[10:59:35.246]   - Field: ‘envir’
[10:59:35.246]   - Field: ‘workers’
[10:59:35.246]   - Field: ‘packages’
[10:59:35.246]   - Field: ‘gc’
[10:59:35.246]   - Field: ‘conditions’
[10:59:35.246]   - Field: ‘persistent’
[10:59:35.246]   - Field: ‘expr’
[10:59:35.246]   - Field: ‘uuid’
[10:59:35.246]   - Field: ‘seed’
[10:59:35.247]   - Field: ‘version’
[10:59:35.247]   - Field: ‘result’
[10:59:35.247]   - Field: ‘asynchronous’
[10:59:35.247]   - Field: ‘calls’
[10:59:35.247]   - Field: ‘globals’
[10:59:35.247]   - Field: ‘stdout’
[10:59:35.247]   - Field: ‘earlySignal’
[10:59:35.247]   - Field: ‘lazy’
[10:59:35.247]   - Field: ‘state’
[10:59:35.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.247] - Launch lazy future ...
[10:59:35.248] Packages needed by the future expression (n = 0): <none>
[10:59:35.248] Packages needed by future strategies (n = 0): <none>
[10:59:35.248] {
[10:59:35.248]     {
[10:59:35.248]         {
[10:59:35.248]             ...future.startTime <- base::Sys.time()
[10:59:35.248]             {
[10:59:35.248]                 {
[10:59:35.248]                   {
[10:59:35.248]                     {
[10:59:35.248]                       base::local({
[10:59:35.248]                         has_future <- base::requireNamespace("future", 
[10:59:35.248]                           quietly = TRUE)
[10:59:35.248]                         if (has_future) {
[10:59:35.248]                           ns <- base::getNamespace("future")
[10:59:35.248]                           version <- ns[[".package"]][["version"]]
[10:59:35.248]                           if (is.null(version)) 
[10:59:35.248]                             version <- utils::packageVersion("future")
[10:59:35.248]                         }
[10:59:35.248]                         else {
[10:59:35.248]                           version <- NULL
[10:59:35.248]                         }
[10:59:35.248]                         if (!has_future || version < "1.8.0") {
[10:59:35.248]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.248]                             "", base::R.version$version.string), 
[10:59:35.248]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.248]                               "release", "version")], collapse = " "), 
[10:59:35.248]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.248]                             info)
[10:59:35.248]                           info <- base::paste(info, collapse = "; ")
[10:59:35.248]                           if (!has_future) {
[10:59:35.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.248]                               info)
[10:59:35.248]                           }
[10:59:35.248]                           else {
[10:59:35.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.248]                               info, version)
[10:59:35.248]                           }
[10:59:35.248]                           base::stop(msg)
[10:59:35.248]                         }
[10:59:35.248]                       })
[10:59:35.248]                     }
[10:59:35.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.248]                     base::options(mc.cores = 1L)
[10:59:35.248]                   }
[10:59:35.248]                   ...future.strategy.old <- future::plan("list")
[10:59:35.248]                   options(future.plan = NULL)
[10:59:35.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.248]                 }
[10:59:35.248]                 ...future.workdir <- getwd()
[10:59:35.248]             }
[10:59:35.248]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.248]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.248]         }
[10:59:35.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.248]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.248]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.248]             base::names(...future.oldOptions))
[10:59:35.248]     }
[10:59:35.248]     if (FALSE) {
[10:59:35.248]     }
[10:59:35.248]     else {
[10:59:35.248]         if (TRUE) {
[10:59:35.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.248]                 open = "w")
[10:59:35.248]         }
[10:59:35.248]         else {
[10:59:35.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.248]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.248]         }
[10:59:35.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.248]             base::sink(type = "output", split = FALSE)
[10:59:35.248]             base::close(...future.stdout)
[10:59:35.248]         }, add = TRUE)
[10:59:35.248]     }
[10:59:35.248]     ...future.frame <- base::sys.nframe()
[10:59:35.248]     ...future.conditions <- base::list()
[10:59:35.248]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.248]     if (FALSE) {
[10:59:35.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.248]     }
[10:59:35.248]     ...future.result <- base::tryCatch({
[10:59:35.248]         base::withCallingHandlers({
[10:59:35.248]             ...future.value <- base::withVisible(base::local({
[10:59:35.248]                 ...future.makeSendCondition <- base::local({
[10:59:35.248]                   sendCondition <- NULL
[10:59:35.248]                   function(frame = 1L) {
[10:59:35.248]                     if (is.function(sendCondition)) 
[10:59:35.248]                       return(sendCondition)
[10:59:35.248]                     ns <- getNamespace("parallel")
[10:59:35.248]                     if (exists("sendData", mode = "function", 
[10:59:35.248]                       envir = ns)) {
[10:59:35.248]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.248]                         envir = ns)
[10:59:35.248]                       envir <- sys.frame(frame)
[10:59:35.248]                       master <- NULL
[10:59:35.248]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.248]                         !identical(envir, emptyenv())) {
[10:59:35.248]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.248]                           inherits = FALSE)) {
[10:59:35.248]                           master <- get("master", mode = "list", 
[10:59:35.248]                             envir = envir, inherits = FALSE)
[10:59:35.248]                           if (inherits(master, c("SOCKnode", 
[10:59:35.248]                             "SOCK0node"))) {
[10:59:35.248]                             sendCondition <<- function(cond) {
[10:59:35.248]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.248]                                 success = TRUE)
[10:59:35.248]                               parallel_sendData(master, data)
[10:59:35.248]                             }
[10:59:35.248]                             return(sendCondition)
[10:59:35.248]                           }
[10:59:35.248]                         }
[10:59:35.248]                         frame <- frame + 1L
[10:59:35.248]                         envir <- sys.frame(frame)
[10:59:35.248]                       }
[10:59:35.248]                     }
[10:59:35.248]                     sendCondition <<- function(cond) NULL
[10:59:35.248]                   }
[10:59:35.248]                 })
[10:59:35.248]                 withCallingHandlers({
[10:59:35.248]                   {
[10:59:35.248]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.248]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.248]                       ...future.globals.maxSize)) {
[10:59:35.248]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.248]                       on.exit(options(oopts), add = TRUE)
[10:59:35.248]                     }
[10:59:35.248]                     {
[10:59:35.248]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.248]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.248]                         USE.NAMES = FALSE)
[10:59:35.248]                       do.call(mapply, args = args)
[10:59:35.248]                     }
[10:59:35.248]                   }
[10:59:35.248]                 }, immediateCondition = function(cond) {
[10:59:35.248]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.248]                   sendCondition(cond)
[10:59:35.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.248]                   {
[10:59:35.248]                     inherits <- base::inherits
[10:59:35.248]                     invokeRestart <- base::invokeRestart
[10:59:35.248]                     is.null <- base::is.null
[10:59:35.248]                     muffled <- FALSE
[10:59:35.248]                     if (inherits(cond, "message")) {
[10:59:35.248]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.248]                       if (muffled) 
[10:59:35.248]                         invokeRestart("muffleMessage")
[10:59:35.248]                     }
[10:59:35.248]                     else if (inherits(cond, "warning")) {
[10:59:35.248]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.248]                       if (muffled) 
[10:59:35.248]                         invokeRestart("muffleWarning")
[10:59:35.248]                     }
[10:59:35.248]                     else if (inherits(cond, "condition")) {
[10:59:35.248]                       if (!is.null(pattern)) {
[10:59:35.248]                         computeRestarts <- base::computeRestarts
[10:59:35.248]                         grepl <- base::grepl
[10:59:35.248]                         restarts <- computeRestarts(cond)
[10:59:35.248]                         for (restart in restarts) {
[10:59:35.248]                           name <- restart$name
[10:59:35.248]                           if (is.null(name)) 
[10:59:35.248]                             next
[10:59:35.248]                           if (!grepl(pattern, name)) 
[10:59:35.248]                             next
[10:59:35.248]                           invokeRestart(restart)
[10:59:35.248]                           muffled <- TRUE
[10:59:35.248]                           break
[10:59:35.248]                         }
[10:59:35.248]                       }
[10:59:35.248]                     }
[10:59:35.248]                     invisible(muffled)
[10:59:35.248]                   }
[10:59:35.248]                   muffleCondition(cond)
[10:59:35.248]                 })
[10:59:35.248]             }))
[10:59:35.248]             future::FutureResult(value = ...future.value$value, 
[10:59:35.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.248]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.248]                     ...future.globalenv.names))
[10:59:35.248]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.248]         }, condition = base::local({
[10:59:35.248]             c <- base::c
[10:59:35.248]             inherits <- base::inherits
[10:59:35.248]             invokeRestart <- base::invokeRestart
[10:59:35.248]             length <- base::length
[10:59:35.248]             list <- base::list
[10:59:35.248]             seq.int <- base::seq.int
[10:59:35.248]             signalCondition <- base::signalCondition
[10:59:35.248]             sys.calls <- base::sys.calls
[10:59:35.248]             `[[` <- base::`[[`
[10:59:35.248]             `+` <- base::`+`
[10:59:35.248]             `<<-` <- base::`<<-`
[10:59:35.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.248]                   3L)]
[10:59:35.248]             }
[10:59:35.248]             function(cond) {
[10:59:35.248]                 is_error <- inherits(cond, "error")
[10:59:35.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.248]                   NULL)
[10:59:35.248]                 if (is_error) {
[10:59:35.248]                   sessionInformation <- function() {
[10:59:35.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.248]                       search = base::search(), system = base::Sys.info())
[10:59:35.248]                   }
[10:59:35.248]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.248]                     cond$call), session = sessionInformation(), 
[10:59:35.248]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.248]                   signalCondition(cond)
[10:59:35.248]                 }
[10:59:35.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.248]                 "immediateCondition"))) {
[10:59:35.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.248]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.248]                   if (TRUE && !signal) {
[10:59:35.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.248]                     {
[10:59:35.248]                       inherits <- base::inherits
[10:59:35.248]                       invokeRestart <- base::invokeRestart
[10:59:35.248]                       is.null <- base::is.null
[10:59:35.248]                       muffled <- FALSE
[10:59:35.248]                       if (inherits(cond, "message")) {
[10:59:35.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.248]                         if (muffled) 
[10:59:35.248]                           invokeRestart("muffleMessage")
[10:59:35.248]                       }
[10:59:35.248]                       else if (inherits(cond, "warning")) {
[10:59:35.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.248]                         if (muffled) 
[10:59:35.248]                           invokeRestart("muffleWarning")
[10:59:35.248]                       }
[10:59:35.248]                       else if (inherits(cond, "condition")) {
[10:59:35.248]                         if (!is.null(pattern)) {
[10:59:35.248]                           computeRestarts <- base::computeRestarts
[10:59:35.248]                           grepl <- base::grepl
[10:59:35.248]                           restarts <- computeRestarts(cond)
[10:59:35.248]                           for (restart in restarts) {
[10:59:35.248]                             name <- restart$name
[10:59:35.248]                             if (is.null(name)) 
[10:59:35.248]                               next
[10:59:35.248]                             if (!grepl(pattern, name)) 
[10:59:35.248]                               next
[10:59:35.248]                             invokeRestart(restart)
[10:59:35.248]                             muffled <- TRUE
[10:59:35.248]                             break
[10:59:35.248]                           }
[10:59:35.248]                         }
[10:59:35.248]                       }
[10:59:35.248]                       invisible(muffled)
[10:59:35.248]                     }
[10:59:35.248]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.248]                   }
[10:59:35.248]                 }
[10:59:35.248]                 else {
[10:59:35.248]                   if (TRUE) {
[10:59:35.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.248]                     {
[10:59:35.248]                       inherits <- base::inherits
[10:59:35.248]                       invokeRestart <- base::invokeRestart
[10:59:35.248]                       is.null <- base::is.null
[10:59:35.248]                       muffled <- FALSE
[10:59:35.248]                       if (inherits(cond, "message")) {
[10:59:35.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.248]                         if (muffled) 
[10:59:35.248]                           invokeRestart("muffleMessage")
[10:59:35.248]                       }
[10:59:35.248]                       else if (inherits(cond, "warning")) {
[10:59:35.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.248]                         if (muffled) 
[10:59:35.248]                           invokeRestart("muffleWarning")
[10:59:35.248]                       }
[10:59:35.248]                       else if (inherits(cond, "condition")) {
[10:59:35.248]                         if (!is.null(pattern)) {
[10:59:35.248]                           computeRestarts <- base::computeRestarts
[10:59:35.248]                           grepl <- base::grepl
[10:59:35.248]                           restarts <- computeRestarts(cond)
[10:59:35.248]                           for (restart in restarts) {
[10:59:35.248]                             name <- restart$name
[10:59:35.248]                             if (is.null(name)) 
[10:59:35.248]                               next
[10:59:35.248]                             if (!grepl(pattern, name)) 
[10:59:35.248]                               next
[10:59:35.248]                             invokeRestart(restart)
[10:59:35.248]                             muffled <- TRUE
[10:59:35.248]                             break
[10:59:35.248]                           }
[10:59:35.248]                         }
[10:59:35.248]                       }
[10:59:35.248]                       invisible(muffled)
[10:59:35.248]                     }
[10:59:35.248]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.248]                   }
[10:59:35.248]                 }
[10:59:35.248]             }
[10:59:35.248]         }))
[10:59:35.248]     }, error = function(ex) {
[10:59:35.248]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.248]                 ...future.rng), started = ...future.startTime, 
[10:59:35.248]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.248]             version = "1.8"), class = "FutureResult")
[10:59:35.248]     }, finally = {
[10:59:35.248]         if (!identical(...future.workdir, getwd())) 
[10:59:35.248]             setwd(...future.workdir)
[10:59:35.248]         {
[10:59:35.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.248]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.248]             }
[10:59:35.248]             base::options(...future.oldOptions)
[10:59:35.248]             if (.Platform$OS.type == "windows") {
[10:59:35.248]                 old_names <- names(...future.oldEnvVars)
[10:59:35.248]                 envs <- base::Sys.getenv()
[10:59:35.248]                 names <- names(envs)
[10:59:35.248]                 common <- intersect(names, old_names)
[10:59:35.248]                 added <- setdiff(names, old_names)
[10:59:35.248]                 removed <- setdiff(old_names, names)
[10:59:35.248]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.248]                   envs[common]]
[10:59:35.248]                 NAMES <- toupper(changed)
[10:59:35.248]                 args <- list()
[10:59:35.248]                 for (kk in seq_along(NAMES)) {
[10:59:35.248]                   name <- changed[[kk]]
[10:59:35.248]                   NAME <- NAMES[[kk]]
[10:59:35.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.248]                     next
[10:59:35.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.248]                 }
[10:59:35.248]                 NAMES <- toupper(added)
[10:59:35.248]                 for (kk in seq_along(NAMES)) {
[10:59:35.248]                   name <- added[[kk]]
[10:59:35.248]                   NAME <- NAMES[[kk]]
[10:59:35.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.248]                     next
[10:59:35.248]                   args[[name]] <- ""
[10:59:35.248]                 }
[10:59:35.248]                 NAMES <- toupper(removed)
[10:59:35.248]                 for (kk in seq_along(NAMES)) {
[10:59:35.248]                   name <- removed[[kk]]
[10:59:35.248]                   NAME <- NAMES[[kk]]
[10:59:35.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.248]                     next
[10:59:35.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.248]                 }
[10:59:35.248]                 if (length(args) > 0) 
[10:59:35.248]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.248]             }
[10:59:35.248]             else {
[10:59:35.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.248]             }
[10:59:35.248]             {
[10:59:35.248]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.248]                   0L) {
[10:59:35.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.248]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.248]                   base::options(opts)
[10:59:35.248]                 }
[10:59:35.248]                 {
[10:59:35.248]                   {
[10:59:35.248]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.248]                     NULL
[10:59:35.248]                   }
[10:59:35.248]                   options(future.plan = NULL)
[10:59:35.248]                   if (is.na(NA_character_)) 
[10:59:35.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.248]                     .init = FALSE)
[10:59:35.248]                 }
[10:59:35.248]             }
[10:59:35.248]         }
[10:59:35.248]     })
[10:59:35.248]     if (TRUE) {
[10:59:35.248]         base::sink(type = "output", split = FALSE)
[10:59:35.248]         if (TRUE) {
[10:59:35.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.248]         }
[10:59:35.248]         else {
[10:59:35.248]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.248]         }
[10:59:35.248]         base::close(...future.stdout)
[10:59:35.248]         ...future.stdout <- NULL
[10:59:35.248]     }
[10:59:35.248]     ...future.result$conditions <- ...future.conditions
[10:59:35.248]     ...future.result$finished <- base::Sys.time()
[10:59:35.248]     ...future.result
[10:59:35.248] }
[10:59:35.251] Exporting 5 global objects (1.06 KiB) to cluster node #1 ...
[10:59:35.251] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ...
[10:59:35.251] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ... DONE
[10:59:35.251] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:35.252] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.252] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[10:59:35.252] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[10:59:35.252] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.253] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.253] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.253] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.253] Exporting 5 global objects (1.06 KiB) to cluster node #1 ... DONE
[10:59:35.254] MultisessionFuture started
[10:59:35.254] - Launch lazy future ... done
[10:59:35.254] run() for ‘MultisessionFuture’ ... done
[10:59:35.254] Created future:
[10:59:35.254] MultisessionFuture:
[10:59:35.254] Label: ‘future_mapply-1’
[10:59:35.254] Expression:
[10:59:35.254] {
[10:59:35.254]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.254]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.254]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.254]         on.exit(options(oopts), add = TRUE)
[10:59:35.254]     }
[10:59:35.254]     {
[10:59:35.254]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.254]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.254]         do.call(mapply, args = args)
[10:59:35.254]     }
[10:59:35.254] }
[10:59:35.254] Lazy evaluation: FALSE
[10:59:35.254] Asynchronous evaluation: TRUE
[10:59:35.254] Local evaluation: TRUE
[10:59:35.254] Environment: R_GlobalEnv
[10:59:35.254] Capture standard output: TRUE
[10:59:35.254] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.254] Globals: 5 objects totaling 645 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.254] Packages: <none>
[10:59:35.254] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.254] Resolved: FALSE
[10:59:35.254] Value: <not collected>
[10:59:35.254] Conditions captured: <none>
[10:59:35.254] Early signaling: FALSE
[10:59:35.254] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.254] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.265] Chunk #1 of 2 ... DONE
[10:59:35.265] Chunk #2 of 2 ...
[10:59:35.266]  - Finding globals in '...' for chunk #2 ...
[10:59:35.266] getGlobalsAndPackages() ...
[10:59:35.266] Searching for globals...
[10:59:35.266] 
[10:59:35.266] Searching for globals ... DONE
[10:59:35.266] - globals: [0] <none>
[10:59:35.266] getGlobalsAndPackages() ... DONE
[10:59:35.266]    + additional globals found: [n=0] 
[10:59:35.266]    + additional namespaces needed: [n=0] 
[10:59:35.267]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:35.267]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.267]  - seeds: <none>
[10:59:35.267]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.269] getGlobalsAndPackages() ...
[10:59:35.269] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.269] Resolving globals: FALSE
[10:59:35.269] The total size of the 5 globals is 695 bytes (695 bytes)
[10:59:35.270] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 695 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.270] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.270] 
[10:59:35.270] getGlobalsAndPackages() ... DONE
[10:59:35.270] run() for ‘Future’ ...
[10:59:35.270] - state: ‘created’
[10:59:35.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.284]   - Field: ‘node’
[10:59:35.284]   - Field: ‘label’
[10:59:35.284]   - Field: ‘local’
[10:59:35.284]   - Field: ‘owner’
[10:59:35.284]   - Field: ‘envir’
[10:59:35.284]   - Field: ‘workers’
[10:59:35.285]   - Field: ‘packages’
[10:59:35.285]   - Field: ‘gc’
[10:59:35.285]   - Field: ‘conditions’
[10:59:35.285]   - Field: ‘persistent’
[10:59:35.285]   - Field: ‘expr’
[10:59:35.285]   - Field: ‘uuid’
[10:59:35.285]   - Field: ‘seed’
[10:59:35.285]   - Field: ‘version’
[10:59:35.285]   - Field: ‘result’
[10:59:35.285]   - Field: ‘asynchronous’
[10:59:35.285]   - Field: ‘calls’
[10:59:35.285]   - Field: ‘globals’
[10:59:35.286]   - Field: ‘stdout’
[10:59:35.286]   - Field: ‘earlySignal’
[10:59:35.286]   - Field: ‘lazy’
[10:59:35.286]   - Field: ‘state’
[10:59:35.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.286] - Launch lazy future ...
[10:59:35.286] Packages needed by the future expression (n = 0): <none>
[10:59:35.286] Packages needed by future strategies (n = 0): <none>
[10:59:35.287] {
[10:59:35.287]     {
[10:59:35.287]         {
[10:59:35.287]             ...future.startTime <- base::Sys.time()
[10:59:35.287]             {
[10:59:35.287]                 {
[10:59:35.287]                   {
[10:59:35.287]                     {
[10:59:35.287]                       base::local({
[10:59:35.287]                         has_future <- base::requireNamespace("future", 
[10:59:35.287]                           quietly = TRUE)
[10:59:35.287]                         if (has_future) {
[10:59:35.287]                           ns <- base::getNamespace("future")
[10:59:35.287]                           version <- ns[[".package"]][["version"]]
[10:59:35.287]                           if (is.null(version)) 
[10:59:35.287]                             version <- utils::packageVersion("future")
[10:59:35.287]                         }
[10:59:35.287]                         else {
[10:59:35.287]                           version <- NULL
[10:59:35.287]                         }
[10:59:35.287]                         if (!has_future || version < "1.8.0") {
[10:59:35.287]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.287]                             "", base::R.version$version.string), 
[10:59:35.287]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.287]                               "release", "version")], collapse = " "), 
[10:59:35.287]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.287]                             info)
[10:59:35.287]                           info <- base::paste(info, collapse = "; ")
[10:59:35.287]                           if (!has_future) {
[10:59:35.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.287]                               info)
[10:59:35.287]                           }
[10:59:35.287]                           else {
[10:59:35.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.287]                               info, version)
[10:59:35.287]                           }
[10:59:35.287]                           base::stop(msg)
[10:59:35.287]                         }
[10:59:35.287]                       })
[10:59:35.287]                     }
[10:59:35.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.287]                     base::options(mc.cores = 1L)
[10:59:35.287]                   }
[10:59:35.287]                   ...future.strategy.old <- future::plan("list")
[10:59:35.287]                   options(future.plan = NULL)
[10:59:35.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.287]                 }
[10:59:35.287]                 ...future.workdir <- getwd()
[10:59:35.287]             }
[10:59:35.287]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.287]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.287]         }
[10:59:35.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.287]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.287]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.287]             base::names(...future.oldOptions))
[10:59:35.287]     }
[10:59:35.287]     if (FALSE) {
[10:59:35.287]     }
[10:59:35.287]     else {
[10:59:35.287]         if (TRUE) {
[10:59:35.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.287]                 open = "w")
[10:59:35.287]         }
[10:59:35.287]         else {
[10:59:35.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.287]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.287]         }
[10:59:35.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.287]             base::sink(type = "output", split = FALSE)
[10:59:35.287]             base::close(...future.stdout)
[10:59:35.287]         }, add = TRUE)
[10:59:35.287]     }
[10:59:35.287]     ...future.frame <- base::sys.nframe()
[10:59:35.287]     ...future.conditions <- base::list()
[10:59:35.287]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.287]     if (FALSE) {
[10:59:35.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.287]     }
[10:59:35.287]     ...future.result <- base::tryCatch({
[10:59:35.287]         base::withCallingHandlers({
[10:59:35.287]             ...future.value <- base::withVisible(base::local({
[10:59:35.287]                 ...future.makeSendCondition <- base::local({
[10:59:35.287]                   sendCondition <- NULL
[10:59:35.287]                   function(frame = 1L) {
[10:59:35.287]                     if (is.function(sendCondition)) 
[10:59:35.287]                       return(sendCondition)
[10:59:35.287]                     ns <- getNamespace("parallel")
[10:59:35.287]                     if (exists("sendData", mode = "function", 
[10:59:35.287]                       envir = ns)) {
[10:59:35.287]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.287]                         envir = ns)
[10:59:35.287]                       envir <- sys.frame(frame)
[10:59:35.287]                       master <- NULL
[10:59:35.287]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.287]                         !identical(envir, emptyenv())) {
[10:59:35.287]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.287]                           inherits = FALSE)) {
[10:59:35.287]                           master <- get("master", mode = "list", 
[10:59:35.287]                             envir = envir, inherits = FALSE)
[10:59:35.287]                           if (inherits(master, c("SOCKnode", 
[10:59:35.287]                             "SOCK0node"))) {
[10:59:35.287]                             sendCondition <<- function(cond) {
[10:59:35.287]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.287]                                 success = TRUE)
[10:59:35.287]                               parallel_sendData(master, data)
[10:59:35.287]                             }
[10:59:35.287]                             return(sendCondition)
[10:59:35.287]                           }
[10:59:35.287]                         }
[10:59:35.287]                         frame <- frame + 1L
[10:59:35.287]                         envir <- sys.frame(frame)
[10:59:35.287]                       }
[10:59:35.287]                     }
[10:59:35.287]                     sendCondition <<- function(cond) NULL
[10:59:35.287]                   }
[10:59:35.287]                 })
[10:59:35.287]                 withCallingHandlers({
[10:59:35.287]                   {
[10:59:35.287]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.287]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.287]                       ...future.globals.maxSize)) {
[10:59:35.287]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.287]                       on.exit(options(oopts), add = TRUE)
[10:59:35.287]                     }
[10:59:35.287]                     {
[10:59:35.287]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.287]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.287]                         USE.NAMES = FALSE)
[10:59:35.287]                       do.call(mapply, args = args)
[10:59:35.287]                     }
[10:59:35.287]                   }
[10:59:35.287]                 }, immediateCondition = function(cond) {
[10:59:35.287]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.287]                   sendCondition(cond)
[10:59:35.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.287]                   {
[10:59:35.287]                     inherits <- base::inherits
[10:59:35.287]                     invokeRestart <- base::invokeRestart
[10:59:35.287]                     is.null <- base::is.null
[10:59:35.287]                     muffled <- FALSE
[10:59:35.287]                     if (inherits(cond, "message")) {
[10:59:35.287]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.287]                       if (muffled) 
[10:59:35.287]                         invokeRestart("muffleMessage")
[10:59:35.287]                     }
[10:59:35.287]                     else if (inherits(cond, "warning")) {
[10:59:35.287]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.287]                       if (muffled) 
[10:59:35.287]                         invokeRestart("muffleWarning")
[10:59:35.287]                     }
[10:59:35.287]                     else if (inherits(cond, "condition")) {
[10:59:35.287]                       if (!is.null(pattern)) {
[10:59:35.287]                         computeRestarts <- base::computeRestarts
[10:59:35.287]                         grepl <- base::grepl
[10:59:35.287]                         restarts <- computeRestarts(cond)
[10:59:35.287]                         for (restart in restarts) {
[10:59:35.287]                           name <- restart$name
[10:59:35.287]                           if (is.null(name)) 
[10:59:35.287]                             next
[10:59:35.287]                           if (!grepl(pattern, name)) 
[10:59:35.287]                             next
[10:59:35.287]                           invokeRestart(restart)
[10:59:35.287]                           muffled <- TRUE
[10:59:35.287]                           break
[10:59:35.287]                         }
[10:59:35.287]                       }
[10:59:35.287]                     }
[10:59:35.287]                     invisible(muffled)
[10:59:35.287]                   }
[10:59:35.287]                   muffleCondition(cond)
[10:59:35.287]                 })
[10:59:35.287]             }))
[10:59:35.287]             future::FutureResult(value = ...future.value$value, 
[10:59:35.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.287]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.287]                     ...future.globalenv.names))
[10:59:35.287]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.287]         }, condition = base::local({
[10:59:35.287]             c <- base::c
[10:59:35.287]             inherits <- base::inherits
[10:59:35.287]             invokeRestart <- base::invokeRestart
[10:59:35.287]             length <- base::length
[10:59:35.287]             list <- base::list
[10:59:35.287]             seq.int <- base::seq.int
[10:59:35.287]             signalCondition <- base::signalCondition
[10:59:35.287]             sys.calls <- base::sys.calls
[10:59:35.287]             `[[` <- base::`[[`
[10:59:35.287]             `+` <- base::`+`
[10:59:35.287]             `<<-` <- base::`<<-`
[10:59:35.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.287]                   3L)]
[10:59:35.287]             }
[10:59:35.287]             function(cond) {
[10:59:35.287]                 is_error <- inherits(cond, "error")
[10:59:35.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.287]                   NULL)
[10:59:35.287]                 if (is_error) {
[10:59:35.287]                   sessionInformation <- function() {
[10:59:35.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.287]                       search = base::search(), system = base::Sys.info())
[10:59:35.287]                   }
[10:59:35.287]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.287]                     cond$call), session = sessionInformation(), 
[10:59:35.287]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.287]                   signalCondition(cond)
[10:59:35.287]                 }
[10:59:35.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.287]                 "immediateCondition"))) {
[10:59:35.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.287]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.287]                   if (TRUE && !signal) {
[10:59:35.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.287]                     {
[10:59:35.287]                       inherits <- base::inherits
[10:59:35.287]                       invokeRestart <- base::invokeRestart
[10:59:35.287]                       is.null <- base::is.null
[10:59:35.287]                       muffled <- FALSE
[10:59:35.287]                       if (inherits(cond, "message")) {
[10:59:35.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.287]                         if (muffled) 
[10:59:35.287]                           invokeRestart("muffleMessage")
[10:59:35.287]                       }
[10:59:35.287]                       else if (inherits(cond, "warning")) {
[10:59:35.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.287]                         if (muffled) 
[10:59:35.287]                           invokeRestart("muffleWarning")
[10:59:35.287]                       }
[10:59:35.287]                       else if (inherits(cond, "condition")) {
[10:59:35.287]                         if (!is.null(pattern)) {
[10:59:35.287]                           computeRestarts <- base::computeRestarts
[10:59:35.287]                           grepl <- base::grepl
[10:59:35.287]                           restarts <- computeRestarts(cond)
[10:59:35.287]                           for (restart in restarts) {
[10:59:35.287]                             name <- restart$name
[10:59:35.287]                             if (is.null(name)) 
[10:59:35.287]                               next
[10:59:35.287]                             if (!grepl(pattern, name)) 
[10:59:35.287]                               next
[10:59:35.287]                             invokeRestart(restart)
[10:59:35.287]                             muffled <- TRUE
[10:59:35.287]                             break
[10:59:35.287]                           }
[10:59:35.287]                         }
[10:59:35.287]                       }
[10:59:35.287]                       invisible(muffled)
[10:59:35.287]                     }
[10:59:35.287]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.287]                   }
[10:59:35.287]                 }
[10:59:35.287]                 else {
[10:59:35.287]                   if (TRUE) {
[10:59:35.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.287]                     {
[10:59:35.287]                       inherits <- base::inherits
[10:59:35.287]                       invokeRestart <- base::invokeRestart
[10:59:35.287]                       is.null <- base::is.null
[10:59:35.287]                       muffled <- FALSE
[10:59:35.287]                       if (inherits(cond, "message")) {
[10:59:35.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.287]                         if (muffled) 
[10:59:35.287]                           invokeRestart("muffleMessage")
[10:59:35.287]                       }
[10:59:35.287]                       else if (inherits(cond, "warning")) {
[10:59:35.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.287]                         if (muffled) 
[10:59:35.287]                           invokeRestart("muffleWarning")
[10:59:35.287]                       }
[10:59:35.287]                       else if (inherits(cond, "condition")) {
[10:59:35.287]                         if (!is.null(pattern)) {
[10:59:35.287]                           computeRestarts <- base::computeRestarts
[10:59:35.287]                           grepl <- base::grepl
[10:59:35.287]                           restarts <- computeRestarts(cond)
[10:59:35.287]                           for (restart in restarts) {
[10:59:35.287]                             name <- restart$name
[10:59:35.287]                             if (is.null(name)) 
[10:59:35.287]                               next
[10:59:35.287]                             if (!grepl(pattern, name)) 
[10:59:35.287]                               next
[10:59:35.287]                             invokeRestart(restart)
[10:59:35.287]                             muffled <- TRUE
[10:59:35.287]                             break
[10:59:35.287]                           }
[10:59:35.287]                         }
[10:59:35.287]                       }
[10:59:35.287]                       invisible(muffled)
[10:59:35.287]                     }
[10:59:35.287]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.287]                   }
[10:59:35.287]                 }
[10:59:35.287]             }
[10:59:35.287]         }))
[10:59:35.287]     }, error = function(ex) {
[10:59:35.287]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.287]                 ...future.rng), started = ...future.startTime, 
[10:59:35.287]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.287]             version = "1.8"), class = "FutureResult")
[10:59:35.287]     }, finally = {
[10:59:35.287]         if (!identical(...future.workdir, getwd())) 
[10:59:35.287]             setwd(...future.workdir)
[10:59:35.287]         {
[10:59:35.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.287]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.287]             }
[10:59:35.287]             base::options(...future.oldOptions)
[10:59:35.287]             if (.Platform$OS.type == "windows") {
[10:59:35.287]                 old_names <- names(...future.oldEnvVars)
[10:59:35.287]                 envs <- base::Sys.getenv()
[10:59:35.287]                 names <- names(envs)
[10:59:35.287]                 common <- intersect(names, old_names)
[10:59:35.287]                 added <- setdiff(names, old_names)
[10:59:35.287]                 removed <- setdiff(old_names, names)
[10:59:35.287]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.287]                   envs[common]]
[10:59:35.287]                 NAMES <- toupper(changed)
[10:59:35.287]                 args <- list()
[10:59:35.287]                 for (kk in seq_along(NAMES)) {
[10:59:35.287]                   name <- changed[[kk]]
[10:59:35.287]                   NAME <- NAMES[[kk]]
[10:59:35.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.287]                     next
[10:59:35.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.287]                 }
[10:59:35.287]                 NAMES <- toupper(added)
[10:59:35.287]                 for (kk in seq_along(NAMES)) {
[10:59:35.287]                   name <- added[[kk]]
[10:59:35.287]                   NAME <- NAMES[[kk]]
[10:59:35.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.287]                     next
[10:59:35.287]                   args[[name]] <- ""
[10:59:35.287]                 }
[10:59:35.287]                 NAMES <- toupper(removed)
[10:59:35.287]                 for (kk in seq_along(NAMES)) {
[10:59:35.287]                   name <- removed[[kk]]
[10:59:35.287]                   NAME <- NAMES[[kk]]
[10:59:35.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.287]                     next
[10:59:35.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.287]                 }
[10:59:35.287]                 if (length(args) > 0) 
[10:59:35.287]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.287]             }
[10:59:35.287]             else {
[10:59:35.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.287]             }
[10:59:35.287]             {
[10:59:35.287]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.287]                   0L) {
[10:59:35.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.287]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.287]                   base::options(opts)
[10:59:35.287]                 }
[10:59:35.287]                 {
[10:59:35.287]                   {
[10:59:35.287]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.287]                     NULL
[10:59:35.287]                   }
[10:59:35.287]                   options(future.plan = NULL)
[10:59:35.287]                   if (is.na(NA_character_)) 
[10:59:35.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.287]                     .init = FALSE)
[10:59:35.287]                 }
[10:59:35.287]             }
[10:59:35.287]         }
[10:59:35.287]     })
[10:59:35.287]     if (TRUE) {
[10:59:35.287]         base::sink(type = "output", split = FALSE)
[10:59:35.287]         if (TRUE) {
[10:59:35.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.287]         }
[10:59:35.287]         else {
[10:59:35.287]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.287]         }
[10:59:35.287]         base::close(...future.stdout)
[10:59:35.287]         ...future.stdout <- NULL
[10:59:35.287]     }
[10:59:35.287]     ...future.result$conditions <- ...future.conditions
[10:59:35.287]     ...future.result$finished <- base::Sys.time()
[10:59:35.287]     ...future.result
[10:59:35.287] }
[10:59:35.289] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[10:59:35.289] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ...
[10:59:35.290] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ... DONE
[10:59:35.290] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:35.290] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.290] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ...
[10:59:35.291] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ... DONE
[10:59:35.291] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.291] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.291] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.292] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.292] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[10:59:35.292] MultisessionFuture started
[10:59:35.292] - Launch lazy future ... done
[10:59:35.292] run() for ‘MultisessionFuture’ ... done
[10:59:35.293] Created future:
[10:59:35.293] MultisessionFuture:
[10:59:35.293] Label: ‘future_mapply-2’
[10:59:35.293] Expression:
[10:59:35.293] {
[10:59:35.293]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.293]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.293]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.293]         on.exit(options(oopts), add = TRUE)
[10:59:35.293]     }
[10:59:35.293]     {
[10:59:35.293]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.293]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.293]         do.call(mapply, args = args)
[10:59:35.293]     }
[10:59:35.293] }
[10:59:35.293] Lazy evaluation: FALSE
[10:59:35.293] Asynchronous evaluation: TRUE
[10:59:35.293] Local evaluation: TRUE
[10:59:35.293] Environment: R_GlobalEnv
[10:59:35.293] Capture standard output: TRUE
[10:59:35.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.293] Globals: 5 objects totaling 695 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.293] Packages: <none>
[10:59:35.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.293] Resolved: FALSE
[10:59:35.293] Value: <not collected>
[10:59:35.293] Conditions captured: <none>
[10:59:35.293] Early signaling: FALSE
[10:59:35.293] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.293] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.304] Chunk #2 of 2 ... DONE
[10:59:35.304] Launching 2 futures (chunks) ... DONE
[10:59:35.304] Resolving 2 futures (chunks) ...
[10:59:35.304] resolve() on list ...
[10:59:35.304]  recursive: 0
[10:59:35.304]  length: 2
[10:59:35.304] 
[10:59:35.305] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.305] - Validating connection of MultisessionFuture
[10:59:35.305] - received message: FutureResult
[10:59:35.305] - Received FutureResult
[10:59:35.305] - Erased future from FutureRegistry
[10:59:35.305] result() for ClusterFuture ...
[10:59:35.306] - result already collected: FutureResult
[10:59:35.306] result() for ClusterFuture ... done
[10:59:35.306] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.306] Future #1
[10:59:35.306] result() for ClusterFuture ...
[10:59:35.306] - result already collected: FutureResult
[10:59:35.306] result() for ClusterFuture ... done
[10:59:35.306] result() for ClusterFuture ...
[10:59:35.306] - result already collected: FutureResult
[10:59:35.306] result() for ClusterFuture ... done
[10:59:35.306] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:35.306] - nx: 2
[10:59:35.306] - relay: TRUE
[10:59:35.307] - stdout: TRUE
[10:59:35.307] - signal: TRUE
[10:59:35.307] - resignal: FALSE
[10:59:35.307] - force: TRUE
[10:59:35.307] - relayed: [n=2] FALSE, FALSE
[10:59:35.307] - queued futures: [n=2] FALSE, FALSE
[10:59:35.307]  - until=1
[10:59:35.307]  - relaying element #1
[10:59:35.307] result() for ClusterFuture ...
[10:59:35.307] - result already collected: FutureResult
[10:59:35.307] result() for ClusterFuture ... done
[10:59:35.307] result() for ClusterFuture ...
[10:59:35.307] - result already collected: FutureResult
[10:59:35.308] result() for ClusterFuture ... done
[10:59:35.308] result() for ClusterFuture ...
[10:59:35.308] - result already collected: FutureResult
[10:59:35.308] result() for ClusterFuture ... done
[10:59:35.308] result() for ClusterFuture ...
[10:59:35.308] - result already collected: FutureResult
[10:59:35.308] result() for ClusterFuture ... done
[10:59:35.308] - relayed: [n=2] TRUE, FALSE
[10:59:35.308] - queued futures: [n=2] TRUE, FALSE
[10:59:35.308] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:35.308]  length: 1 (resolved future 1)
[10:59:35.334] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.334] - Validating connection of MultisessionFuture
[10:59:35.335] - received message: FutureResult
[10:59:35.335] - Received FutureResult
[10:59:35.335] - Erased future from FutureRegistry
[10:59:35.335] result() for ClusterFuture ...
[10:59:35.335] - result already collected: FutureResult
[10:59:35.335] result() for ClusterFuture ... done
[10:59:35.335] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.335] Future #2
[10:59:35.335] result() for ClusterFuture ...
[10:59:35.335] - result already collected: FutureResult
[10:59:35.335] result() for ClusterFuture ... done
[10:59:35.335] result() for ClusterFuture ...
[10:59:35.336] - result already collected: FutureResult
[10:59:35.336] result() for ClusterFuture ... done
[10:59:35.336] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:35.336] - nx: 2
[10:59:35.336] - relay: TRUE
[10:59:35.336] - stdout: TRUE
[10:59:35.336] - signal: TRUE
[10:59:35.336] - resignal: FALSE
[10:59:35.336] - force: TRUE
[10:59:35.336] - relayed: [n=2] TRUE, FALSE
[10:59:35.336] - queued futures: [n=2] TRUE, FALSE
[10:59:35.336]  - until=2
[10:59:35.337]  - relaying element #2
[10:59:35.337] result() for ClusterFuture ...
[10:59:35.337] - result already collected: FutureResult
[10:59:35.337] result() for ClusterFuture ... done
[10:59:35.337] result() for ClusterFuture ...
[10:59:35.337] - result already collected: FutureResult
[10:59:35.337] result() for ClusterFuture ... done
[10:59:35.337] result() for ClusterFuture ...
[10:59:35.337] - result already collected: FutureResult
[10:59:35.337] result() for ClusterFuture ... done
[10:59:35.337] result() for ClusterFuture ...
[10:59:35.337] - result already collected: FutureResult
[10:59:35.337] result() for ClusterFuture ... done
[10:59:35.338] - relayed: [n=2] TRUE, TRUE
[10:59:35.338] - queued futures: [n=2] TRUE, TRUE
[10:59:35.338] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:35.338]  length: 0 (resolved future 2)
[10:59:35.338] Relaying remaining futures
[10:59:35.338] signalConditionsASAP(NULL, pos=0) ...
[10:59:35.338] - nx: 2
[10:59:35.338] - relay: TRUE
[10:59:35.338] - stdout: TRUE
[10:59:35.338] - signal: TRUE
[10:59:35.338] - resignal: FALSE
[10:59:35.338] - force: TRUE
[10:59:35.338] - relayed: [n=2] TRUE, TRUE
[10:59:35.339] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:35.339] - relayed: [n=2] TRUE, TRUE
[10:59:35.339] - queued futures: [n=2] TRUE, TRUE
[10:59:35.339] signalConditionsASAP(NULL, pos=0) ... done
[10:59:35.339] resolve() on list ... DONE
[10:59:35.339] result() for ClusterFuture ...
[10:59:35.339] - result already collected: FutureResult
[10:59:35.339] result() for ClusterFuture ... done
[10:59:35.339] result() for ClusterFuture ...
[10:59:35.339] - result already collected: FutureResult
[10:59:35.339] result() for ClusterFuture ... done
[10:59:35.339] result() for ClusterFuture ...
[10:59:35.340] - result already collected: FutureResult
[10:59:35.340] result() for ClusterFuture ... done
[10:59:35.340] result() for ClusterFuture ...
[10:59:35.340] - result already collected: FutureResult
[10:59:35.340] result() for ClusterFuture ... done
[10:59:35.340]  - Number of value chunks collected: 2
[10:59:35.340] Resolving 2 futures (chunks) ... DONE
[10:59:35.340] Reducing values from 2 chunks ...
[10:59:35.340]  - Number of values collected after concatenation: 3
[10:59:35.340]  - Number of values expected: 3
[10:59:35.340] Reducing values from 2 chunks ... DONE
[10:59:35.340] future_mapply() ... DONE
- future_.mapply()
[10:59:35.341] future_mapply() ...
[10:59:35.342] Number of chunks: 2
[10:59:35.342] getGlobalsAndPackagesXApply() ...
[10:59:35.342]  - future.globals: TRUE
[10:59:35.342] getGlobalsAndPackages() ...
[10:59:35.342] Searching for globals...
[10:59:35.344] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:59:35.344] Searching for globals ... DONE
[10:59:35.344] Resolving globals: FALSE
[10:59:35.344] The total size of the 1 globals is 414 bytes (414 bytes)
[10:59:35.344] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:59:35.345] - globals: [1] ‘FUN’
[10:59:35.345] 
[10:59:35.345] getGlobalsAndPackages() ... DONE
[10:59:35.345]  - globals found/used: [n=1] ‘FUN’
[10:59:35.345]  - needed namespaces: [n=0] 
[10:59:35.345] Finding globals ... DONE
[10:59:35.345] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:35.345] List of 2
[10:59:35.345]  $ ...future.FUN:function (x, y)  
[10:59:35.345]  $ MoreArgs     : list()
[10:59:35.345]  - attr(*, "where")=List of 2
[10:59:35.345]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:35.345]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:35.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:35.345]  - attr(*, "resolved")= logi FALSE
[10:59:35.345]  - attr(*, "total_size")= num NA
[10:59:35.348] Packages to be attached in all futures: [n=0] 
[10:59:35.348] getGlobalsAndPackagesXApply() ... DONE
[10:59:35.348] Number of futures (= number of chunks): 2
[10:59:35.348] Launching 2 futures (chunks) ...
[10:59:35.348] Chunk #1 of 2 ...
[10:59:35.348]  - Finding globals in '...' for chunk #1 ...
[10:59:35.348] getGlobalsAndPackages() ...
[10:59:35.348] Searching for globals...
[10:59:35.349] 
[10:59:35.349] Searching for globals ... DONE
[10:59:35.349] - globals: [0] <none>
[10:59:35.349] getGlobalsAndPackages() ... DONE
[10:59:35.349]    + additional globals found: [n=0] 
[10:59:35.349]    + additional namespaces needed: [n=0] 
[10:59:35.349]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:35.349]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.349]  - seeds: <none>
[10:59:35.349]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.349] getGlobalsAndPackages() ...
[10:59:35.350] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.350] Resolving globals: FALSE
[10:59:35.350] The total size of the 5 globals is 649 bytes (649 bytes)
[10:59:35.350] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 649 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:35.350] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.351] 
[10:59:35.351] getGlobalsAndPackages() ... DONE
[10:59:35.351] run() for ‘Future’ ...
[10:59:35.351] - state: ‘created’
[10:59:35.351] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.364] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.365]   - Field: ‘node’
[10:59:35.365]   - Field: ‘label’
[10:59:35.365]   - Field: ‘local’
[10:59:35.365]   - Field: ‘owner’
[10:59:35.365]   - Field: ‘envir’
[10:59:35.365]   - Field: ‘workers’
[10:59:35.365]   - Field: ‘packages’
[10:59:35.365]   - Field: ‘gc’
[10:59:35.365]   - Field: ‘conditions’
[10:59:35.365]   - Field: ‘persistent’
[10:59:35.366]   - Field: ‘expr’
[10:59:35.366]   - Field: ‘uuid’
[10:59:35.366]   - Field: ‘seed’
[10:59:35.366]   - Field: ‘version’
[10:59:35.366]   - Field: ‘result’
[10:59:35.366]   - Field: ‘asynchronous’
[10:59:35.366]   - Field: ‘calls’
[10:59:35.366]   - Field: ‘globals’
[10:59:35.366]   - Field: ‘stdout’
[10:59:35.366]   - Field: ‘earlySignal’
[10:59:35.366]   - Field: ‘lazy’
[10:59:35.366]   - Field: ‘state’
[10:59:35.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.367] - Launch lazy future ...
[10:59:35.367] Packages needed by the future expression (n = 0): <none>
[10:59:35.367] Packages needed by future strategies (n = 0): <none>
[10:59:35.367] {
[10:59:35.367]     {
[10:59:35.367]         {
[10:59:35.367]             ...future.startTime <- base::Sys.time()
[10:59:35.367]             {
[10:59:35.367]                 {
[10:59:35.367]                   {
[10:59:35.367]                     {
[10:59:35.367]                       base::local({
[10:59:35.367]                         has_future <- base::requireNamespace("future", 
[10:59:35.367]                           quietly = TRUE)
[10:59:35.367]                         if (has_future) {
[10:59:35.367]                           ns <- base::getNamespace("future")
[10:59:35.367]                           version <- ns[[".package"]][["version"]]
[10:59:35.367]                           if (is.null(version)) 
[10:59:35.367]                             version <- utils::packageVersion("future")
[10:59:35.367]                         }
[10:59:35.367]                         else {
[10:59:35.367]                           version <- NULL
[10:59:35.367]                         }
[10:59:35.367]                         if (!has_future || version < "1.8.0") {
[10:59:35.367]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.367]                             "", base::R.version$version.string), 
[10:59:35.367]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.367]                               "release", "version")], collapse = " "), 
[10:59:35.367]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.367]                             info)
[10:59:35.367]                           info <- base::paste(info, collapse = "; ")
[10:59:35.367]                           if (!has_future) {
[10:59:35.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.367]                               info)
[10:59:35.367]                           }
[10:59:35.367]                           else {
[10:59:35.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.367]                               info, version)
[10:59:35.367]                           }
[10:59:35.367]                           base::stop(msg)
[10:59:35.367]                         }
[10:59:35.367]                       })
[10:59:35.367]                     }
[10:59:35.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.367]                     base::options(mc.cores = 1L)
[10:59:35.367]                   }
[10:59:35.367]                   ...future.strategy.old <- future::plan("list")
[10:59:35.367]                   options(future.plan = NULL)
[10:59:35.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.367]                 }
[10:59:35.367]                 ...future.workdir <- getwd()
[10:59:35.367]             }
[10:59:35.367]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.367]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.367]         }
[10:59:35.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.367]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.367]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.367]             base::names(...future.oldOptions))
[10:59:35.367]     }
[10:59:35.367]     if (FALSE) {
[10:59:35.367]     }
[10:59:35.367]     else {
[10:59:35.367]         if (TRUE) {
[10:59:35.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.367]                 open = "w")
[10:59:35.367]         }
[10:59:35.367]         else {
[10:59:35.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.367]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.367]         }
[10:59:35.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.367]             base::sink(type = "output", split = FALSE)
[10:59:35.367]             base::close(...future.stdout)
[10:59:35.367]         }, add = TRUE)
[10:59:35.367]     }
[10:59:35.367]     ...future.frame <- base::sys.nframe()
[10:59:35.367]     ...future.conditions <- base::list()
[10:59:35.367]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.367]     if (FALSE) {
[10:59:35.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.367]     }
[10:59:35.367]     ...future.result <- base::tryCatch({
[10:59:35.367]         base::withCallingHandlers({
[10:59:35.367]             ...future.value <- base::withVisible(base::local({
[10:59:35.367]                 ...future.makeSendCondition <- base::local({
[10:59:35.367]                   sendCondition <- NULL
[10:59:35.367]                   function(frame = 1L) {
[10:59:35.367]                     if (is.function(sendCondition)) 
[10:59:35.367]                       return(sendCondition)
[10:59:35.367]                     ns <- getNamespace("parallel")
[10:59:35.367]                     if (exists("sendData", mode = "function", 
[10:59:35.367]                       envir = ns)) {
[10:59:35.367]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.367]                         envir = ns)
[10:59:35.367]                       envir <- sys.frame(frame)
[10:59:35.367]                       master <- NULL
[10:59:35.367]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.367]                         !identical(envir, emptyenv())) {
[10:59:35.367]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.367]                           inherits = FALSE)) {
[10:59:35.367]                           master <- get("master", mode = "list", 
[10:59:35.367]                             envir = envir, inherits = FALSE)
[10:59:35.367]                           if (inherits(master, c("SOCKnode", 
[10:59:35.367]                             "SOCK0node"))) {
[10:59:35.367]                             sendCondition <<- function(cond) {
[10:59:35.367]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.367]                                 success = TRUE)
[10:59:35.367]                               parallel_sendData(master, data)
[10:59:35.367]                             }
[10:59:35.367]                             return(sendCondition)
[10:59:35.367]                           }
[10:59:35.367]                         }
[10:59:35.367]                         frame <- frame + 1L
[10:59:35.367]                         envir <- sys.frame(frame)
[10:59:35.367]                       }
[10:59:35.367]                     }
[10:59:35.367]                     sendCondition <<- function(cond) NULL
[10:59:35.367]                   }
[10:59:35.367]                 })
[10:59:35.367]                 withCallingHandlers({
[10:59:35.367]                   {
[10:59:35.367]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.367]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.367]                       ...future.globals.maxSize)) {
[10:59:35.367]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.367]                       on.exit(options(oopts), add = TRUE)
[10:59:35.367]                     }
[10:59:35.367]                     {
[10:59:35.367]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.367]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.367]                         USE.NAMES = FALSE)
[10:59:35.367]                       do.call(mapply, args = args)
[10:59:35.367]                     }
[10:59:35.367]                   }
[10:59:35.367]                 }, immediateCondition = function(cond) {
[10:59:35.367]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.367]                   sendCondition(cond)
[10:59:35.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.367]                   {
[10:59:35.367]                     inherits <- base::inherits
[10:59:35.367]                     invokeRestart <- base::invokeRestart
[10:59:35.367]                     is.null <- base::is.null
[10:59:35.367]                     muffled <- FALSE
[10:59:35.367]                     if (inherits(cond, "message")) {
[10:59:35.367]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.367]                       if (muffled) 
[10:59:35.367]                         invokeRestart("muffleMessage")
[10:59:35.367]                     }
[10:59:35.367]                     else if (inherits(cond, "warning")) {
[10:59:35.367]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.367]                       if (muffled) 
[10:59:35.367]                         invokeRestart("muffleWarning")
[10:59:35.367]                     }
[10:59:35.367]                     else if (inherits(cond, "condition")) {
[10:59:35.367]                       if (!is.null(pattern)) {
[10:59:35.367]                         computeRestarts <- base::computeRestarts
[10:59:35.367]                         grepl <- base::grepl
[10:59:35.367]                         restarts <- computeRestarts(cond)
[10:59:35.367]                         for (restart in restarts) {
[10:59:35.367]                           name <- restart$name
[10:59:35.367]                           if (is.null(name)) 
[10:59:35.367]                             next
[10:59:35.367]                           if (!grepl(pattern, name)) 
[10:59:35.367]                             next
[10:59:35.367]                           invokeRestart(restart)
[10:59:35.367]                           muffled <- TRUE
[10:59:35.367]                           break
[10:59:35.367]                         }
[10:59:35.367]                       }
[10:59:35.367]                     }
[10:59:35.367]                     invisible(muffled)
[10:59:35.367]                   }
[10:59:35.367]                   muffleCondition(cond)
[10:59:35.367]                 })
[10:59:35.367]             }))
[10:59:35.367]             future::FutureResult(value = ...future.value$value, 
[10:59:35.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.367]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.367]                     ...future.globalenv.names))
[10:59:35.367]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.367]         }, condition = base::local({
[10:59:35.367]             c <- base::c
[10:59:35.367]             inherits <- base::inherits
[10:59:35.367]             invokeRestart <- base::invokeRestart
[10:59:35.367]             length <- base::length
[10:59:35.367]             list <- base::list
[10:59:35.367]             seq.int <- base::seq.int
[10:59:35.367]             signalCondition <- base::signalCondition
[10:59:35.367]             sys.calls <- base::sys.calls
[10:59:35.367]             `[[` <- base::`[[`
[10:59:35.367]             `+` <- base::`+`
[10:59:35.367]             `<<-` <- base::`<<-`
[10:59:35.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.367]                   3L)]
[10:59:35.367]             }
[10:59:35.367]             function(cond) {
[10:59:35.367]                 is_error <- inherits(cond, "error")
[10:59:35.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.367]                   NULL)
[10:59:35.367]                 if (is_error) {
[10:59:35.367]                   sessionInformation <- function() {
[10:59:35.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.367]                       search = base::search(), system = base::Sys.info())
[10:59:35.367]                   }
[10:59:35.367]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.367]                     cond$call), session = sessionInformation(), 
[10:59:35.367]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.367]                   signalCondition(cond)
[10:59:35.367]                 }
[10:59:35.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.367]                 "immediateCondition"))) {
[10:59:35.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.367]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.367]                   if (TRUE && !signal) {
[10:59:35.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.367]                     {
[10:59:35.367]                       inherits <- base::inherits
[10:59:35.367]                       invokeRestart <- base::invokeRestart
[10:59:35.367]                       is.null <- base::is.null
[10:59:35.367]                       muffled <- FALSE
[10:59:35.367]                       if (inherits(cond, "message")) {
[10:59:35.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.367]                         if (muffled) 
[10:59:35.367]                           invokeRestart("muffleMessage")
[10:59:35.367]                       }
[10:59:35.367]                       else if (inherits(cond, "warning")) {
[10:59:35.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.367]                         if (muffled) 
[10:59:35.367]                           invokeRestart("muffleWarning")
[10:59:35.367]                       }
[10:59:35.367]                       else if (inherits(cond, "condition")) {
[10:59:35.367]                         if (!is.null(pattern)) {
[10:59:35.367]                           computeRestarts <- base::computeRestarts
[10:59:35.367]                           grepl <- base::grepl
[10:59:35.367]                           restarts <- computeRestarts(cond)
[10:59:35.367]                           for (restart in restarts) {
[10:59:35.367]                             name <- restart$name
[10:59:35.367]                             if (is.null(name)) 
[10:59:35.367]                               next
[10:59:35.367]                             if (!grepl(pattern, name)) 
[10:59:35.367]                               next
[10:59:35.367]                             invokeRestart(restart)
[10:59:35.367]                             muffled <- TRUE
[10:59:35.367]                             break
[10:59:35.367]                           }
[10:59:35.367]                         }
[10:59:35.367]                       }
[10:59:35.367]                       invisible(muffled)
[10:59:35.367]                     }
[10:59:35.367]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.367]                   }
[10:59:35.367]                 }
[10:59:35.367]                 else {
[10:59:35.367]                   if (TRUE) {
[10:59:35.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.367]                     {
[10:59:35.367]                       inherits <- base::inherits
[10:59:35.367]                       invokeRestart <- base::invokeRestart
[10:59:35.367]                       is.null <- base::is.null
[10:59:35.367]                       muffled <- FALSE
[10:59:35.367]                       if (inherits(cond, "message")) {
[10:59:35.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.367]                         if (muffled) 
[10:59:35.367]                           invokeRestart("muffleMessage")
[10:59:35.367]                       }
[10:59:35.367]                       else if (inherits(cond, "warning")) {
[10:59:35.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.367]                         if (muffled) 
[10:59:35.367]                           invokeRestart("muffleWarning")
[10:59:35.367]                       }
[10:59:35.367]                       else if (inherits(cond, "condition")) {
[10:59:35.367]                         if (!is.null(pattern)) {
[10:59:35.367]                           computeRestarts <- base::computeRestarts
[10:59:35.367]                           grepl <- base::grepl
[10:59:35.367]                           restarts <- computeRestarts(cond)
[10:59:35.367]                           for (restart in restarts) {
[10:59:35.367]                             name <- restart$name
[10:59:35.367]                             if (is.null(name)) 
[10:59:35.367]                               next
[10:59:35.367]                             if (!grepl(pattern, name)) 
[10:59:35.367]                               next
[10:59:35.367]                             invokeRestart(restart)
[10:59:35.367]                             muffled <- TRUE
[10:59:35.367]                             break
[10:59:35.367]                           }
[10:59:35.367]                         }
[10:59:35.367]                       }
[10:59:35.367]                       invisible(muffled)
[10:59:35.367]                     }
[10:59:35.367]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.367]                   }
[10:59:35.367]                 }
[10:59:35.367]             }
[10:59:35.367]         }))
[10:59:35.367]     }, error = function(ex) {
[10:59:35.367]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.367]                 ...future.rng), started = ...future.startTime, 
[10:59:35.367]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.367]             version = "1.8"), class = "FutureResult")
[10:59:35.367]     }, finally = {
[10:59:35.367]         if (!identical(...future.workdir, getwd())) 
[10:59:35.367]             setwd(...future.workdir)
[10:59:35.367]         {
[10:59:35.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.367]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.367]             }
[10:59:35.367]             base::options(...future.oldOptions)
[10:59:35.367]             if (.Platform$OS.type == "windows") {
[10:59:35.367]                 old_names <- names(...future.oldEnvVars)
[10:59:35.367]                 envs <- base::Sys.getenv()
[10:59:35.367]                 names <- names(envs)
[10:59:35.367]                 common <- intersect(names, old_names)
[10:59:35.367]                 added <- setdiff(names, old_names)
[10:59:35.367]                 removed <- setdiff(old_names, names)
[10:59:35.367]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.367]                   envs[common]]
[10:59:35.367]                 NAMES <- toupper(changed)
[10:59:35.367]                 args <- list()
[10:59:35.367]                 for (kk in seq_along(NAMES)) {
[10:59:35.367]                   name <- changed[[kk]]
[10:59:35.367]                   NAME <- NAMES[[kk]]
[10:59:35.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.367]                     next
[10:59:35.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.367]                 }
[10:59:35.367]                 NAMES <- toupper(added)
[10:59:35.367]                 for (kk in seq_along(NAMES)) {
[10:59:35.367]                   name <- added[[kk]]
[10:59:35.367]                   NAME <- NAMES[[kk]]
[10:59:35.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.367]                     next
[10:59:35.367]                   args[[name]] <- ""
[10:59:35.367]                 }
[10:59:35.367]                 NAMES <- toupper(removed)
[10:59:35.367]                 for (kk in seq_along(NAMES)) {
[10:59:35.367]                   name <- removed[[kk]]
[10:59:35.367]                   NAME <- NAMES[[kk]]
[10:59:35.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.367]                     next
[10:59:35.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.367]                 }
[10:59:35.367]                 if (length(args) > 0) 
[10:59:35.367]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.367]             }
[10:59:35.367]             else {
[10:59:35.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.367]             }
[10:59:35.367]             {
[10:59:35.367]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.367]                   0L) {
[10:59:35.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.367]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.367]                   base::options(opts)
[10:59:35.367]                 }
[10:59:35.367]                 {
[10:59:35.367]                   {
[10:59:35.367]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.367]                     NULL
[10:59:35.367]                   }
[10:59:35.367]                   options(future.plan = NULL)
[10:59:35.367]                   if (is.na(NA_character_)) 
[10:59:35.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.367]                     .init = FALSE)
[10:59:35.367]                 }
[10:59:35.367]             }
[10:59:35.367]         }
[10:59:35.367]     })
[10:59:35.367]     if (TRUE) {
[10:59:35.367]         base::sink(type = "output", split = FALSE)
[10:59:35.367]         if (TRUE) {
[10:59:35.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.367]         }
[10:59:35.367]         else {
[10:59:35.367]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.367]         }
[10:59:35.367]         base::close(...future.stdout)
[10:59:35.367]         ...future.stdout <- NULL
[10:59:35.367]     }
[10:59:35.367]     ...future.result$conditions <- ...future.conditions
[10:59:35.367]     ...future.result$finished <- base::Sys.time()
[10:59:35.367]     ...future.result
[10:59:35.367] }
[10:59:35.370] Exporting 5 global objects (1.06 KiB) to cluster node #1 ...
[10:59:35.370] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ...
[10:59:35.370] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ... DONE
[10:59:35.371] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:59:35.371] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:59:35.371] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[10:59:35.371] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[10:59:35.372] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.372] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.372] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.372] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.372] Exporting 5 global objects (1.06 KiB) to cluster node #1 ... DONE
[10:59:35.373] MultisessionFuture started
[10:59:35.373] - Launch lazy future ... done
[10:59:35.373] run() for ‘MultisessionFuture’ ... done
[10:59:35.373] Created future:
[10:59:35.373] MultisessionFuture:
[10:59:35.373] Label: ‘future_.mapply-1’
[10:59:35.373] Expression:
[10:59:35.373] {
[10:59:35.373]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.373]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.373]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.373]         on.exit(options(oopts), add = TRUE)
[10:59:35.373]     }
[10:59:35.373]     {
[10:59:35.373]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.373]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.373]         do.call(mapply, args = args)
[10:59:35.373]     }
[10:59:35.373] }
[10:59:35.373] Lazy evaluation: FALSE
[10:59:35.373] Asynchronous evaluation: TRUE
[10:59:35.373] Local evaluation: TRUE
[10:59:35.373] Environment: R_GlobalEnv
[10:59:35.373] Capture standard output: TRUE
[10:59:35.373] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.373] Globals: 5 objects totaling 649 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.373] Packages: <none>
[10:59:35.373] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.373] Resolved: FALSE
[10:59:35.373] Value: <not collected>
[10:59:35.373] Conditions captured: <none>
[10:59:35.373] Early signaling: FALSE
[10:59:35.373] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.373] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.384] Chunk #1 of 2 ... DONE
[10:59:35.385] Chunk #2 of 2 ...
[10:59:35.385]  - Finding globals in '...' for chunk #2 ...
[10:59:35.385] getGlobalsAndPackages() ...
[10:59:35.385] Searching for globals...
[10:59:35.385] 
[10:59:35.385] Searching for globals ... DONE
[10:59:35.385] - globals: [0] <none>
[10:59:35.385] getGlobalsAndPackages() ... DONE
[10:59:35.386]    + additional globals found: [n=0] 
[10:59:35.386]    + additional namespaces needed: [n=0] 
[10:59:35.386]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:35.386]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.386]  - seeds: <none>
[10:59:35.386]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.386] getGlobalsAndPackages() ...
[10:59:35.386] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.386] Resolving globals: FALSE
[10:59:35.387] The total size of the 5 globals is 699 bytes (699 bytes)
[10:59:35.387] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 699 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:35.387] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.387] 
[10:59:35.387] getGlobalsAndPackages() ... DONE
[10:59:35.388] run() for ‘Future’ ...
[10:59:35.388] - state: ‘created’
[10:59:35.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.402]   - Field: ‘node’
[10:59:35.402]   - Field: ‘label’
[10:59:35.402]   - Field: ‘local’
[10:59:35.402]   - Field: ‘owner’
[10:59:35.402]   - Field: ‘envir’
[10:59:35.402]   - Field: ‘workers’
[10:59:35.402]   - Field: ‘packages’
[10:59:35.402]   - Field: ‘gc’
[10:59:35.402]   - Field: ‘conditions’
[10:59:35.402]   - Field: ‘persistent’
[10:59:35.403]   - Field: ‘expr’
[10:59:35.403]   - Field: ‘uuid’
[10:59:35.403]   - Field: ‘seed’
[10:59:35.403]   - Field: ‘version’
[10:59:35.403]   - Field: ‘result’
[10:59:35.403]   - Field: ‘asynchronous’
[10:59:35.403]   - Field: ‘calls’
[10:59:35.403]   - Field: ‘globals’
[10:59:35.403]   - Field: ‘stdout’
[10:59:35.403]   - Field: ‘earlySignal’
[10:59:35.403]   - Field: ‘lazy’
[10:59:35.403]   - Field: ‘state’
[10:59:35.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.404] - Launch lazy future ...
[10:59:35.404] Packages needed by the future expression (n = 0): <none>
[10:59:35.404] Packages needed by future strategies (n = 0): <none>
[10:59:35.404] {
[10:59:35.404]     {
[10:59:35.404]         {
[10:59:35.404]             ...future.startTime <- base::Sys.time()
[10:59:35.404]             {
[10:59:35.404]                 {
[10:59:35.404]                   {
[10:59:35.404]                     {
[10:59:35.404]                       base::local({
[10:59:35.404]                         has_future <- base::requireNamespace("future", 
[10:59:35.404]                           quietly = TRUE)
[10:59:35.404]                         if (has_future) {
[10:59:35.404]                           ns <- base::getNamespace("future")
[10:59:35.404]                           version <- ns[[".package"]][["version"]]
[10:59:35.404]                           if (is.null(version)) 
[10:59:35.404]                             version <- utils::packageVersion("future")
[10:59:35.404]                         }
[10:59:35.404]                         else {
[10:59:35.404]                           version <- NULL
[10:59:35.404]                         }
[10:59:35.404]                         if (!has_future || version < "1.8.0") {
[10:59:35.404]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.404]                             "", base::R.version$version.string), 
[10:59:35.404]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.404]                               "release", "version")], collapse = " "), 
[10:59:35.404]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.404]                             info)
[10:59:35.404]                           info <- base::paste(info, collapse = "; ")
[10:59:35.404]                           if (!has_future) {
[10:59:35.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.404]                               info)
[10:59:35.404]                           }
[10:59:35.404]                           else {
[10:59:35.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.404]                               info, version)
[10:59:35.404]                           }
[10:59:35.404]                           base::stop(msg)
[10:59:35.404]                         }
[10:59:35.404]                       })
[10:59:35.404]                     }
[10:59:35.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.404]                     base::options(mc.cores = 1L)
[10:59:35.404]                   }
[10:59:35.404]                   ...future.strategy.old <- future::plan("list")
[10:59:35.404]                   options(future.plan = NULL)
[10:59:35.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.404]                 }
[10:59:35.404]                 ...future.workdir <- getwd()
[10:59:35.404]             }
[10:59:35.404]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.404]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.404]         }
[10:59:35.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.404]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.404]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.404]             base::names(...future.oldOptions))
[10:59:35.404]     }
[10:59:35.404]     if (FALSE) {
[10:59:35.404]     }
[10:59:35.404]     else {
[10:59:35.404]         if (TRUE) {
[10:59:35.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.404]                 open = "w")
[10:59:35.404]         }
[10:59:35.404]         else {
[10:59:35.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.404]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.404]         }
[10:59:35.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.404]             base::sink(type = "output", split = FALSE)
[10:59:35.404]             base::close(...future.stdout)
[10:59:35.404]         }, add = TRUE)
[10:59:35.404]     }
[10:59:35.404]     ...future.frame <- base::sys.nframe()
[10:59:35.404]     ...future.conditions <- base::list()
[10:59:35.404]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.404]     if (FALSE) {
[10:59:35.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.404]     }
[10:59:35.404]     ...future.result <- base::tryCatch({
[10:59:35.404]         base::withCallingHandlers({
[10:59:35.404]             ...future.value <- base::withVisible(base::local({
[10:59:35.404]                 ...future.makeSendCondition <- base::local({
[10:59:35.404]                   sendCondition <- NULL
[10:59:35.404]                   function(frame = 1L) {
[10:59:35.404]                     if (is.function(sendCondition)) 
[10:59:35.404]                       return(sendCondition)
[10:59:35.404]                     ns <- getNamespace("parallel")
[10:59:35.404]                     if (exists("sendData", mode = "function", 
[10:59:35.404]                       envir = ns)) {
[10:59:35.404]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.404]                         envir = ns)
[10:59:35.404]                       envir <- sys.frame(frame)
[10:59:35.404]                       master <- NULL
[10:59:35.404]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.404]                         !identical(envir, emptyenv())) {
[10:59:35.404]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.404]                           inherits = FALSE)) {
[10:59:35.404]                           master <- get("master", mode = "list", 
[10:59:35.404]                             envir = envir, inherits = FALSE)
[10:59:35.404]                           if (inherits(master, c("SOCKnode", 
[10:59:35.404]                             "SOCK0node"))) {
[10:59:35.404]                             sendCondition <<- function(cond) {
[10:59:35.404]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.404]                                 success = TRUE)
[10:59:35.404]                               parallel_sendData(master, data)
[10:59:35.404]                             }
[10:59:35.404]                             return(sendCondition)
[10:59:35.404]                           }
[10:59:35.404]                         }
[10:59:35.404]                         frame <- frame + 1L
[10:59:35.404]                         envir <- sys.frame(frame)
[10:59:35.404]                       }
[10:59:35.404]                     }
[10:59:35.404]                     sendCondition <<- function(cond) NULL
[10:59:35.404]                   }
[10:59:35.404]                 })
[10:59:35.404]                 withCallingHandlers({
[10:59:35.404]                   {
[10:59:35.404]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.404]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.404]                       ...future.globals.maxSize)) {
[10:59:35.404]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.404]                       on.exit(options(oopts), add = TRUE)
[10:59:35.404]                     }
[10:59:35.404]                     {
[10:59:35.404]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.404]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.404]                         USE.NAMES = FALSE)
[10:59:35.404]                       do.call(mapply, args = args)
[10:59:35.404]                     }
[10:59:35.404]                   }
[10:59:35.404]                 }, immediateCondition = function(cond) {
[10:59:35.404]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.404]                   sendCondition(cond)
[10:59:35.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.404]                   {
[10:59:35.404]                     inherits <- base::inherits
[10:59:35.404]                     invokeRestart <- base::invokeRestart
[10:59:35.404]                     is.null <- base::is.null
[10:59:35.404]                     muffled <- FALSE
[10:59:35.404]                     if (inherits(cond, "message")) {
[10:59:35.404]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.404]                       if (muffled) 
[10:59:35.404]                         invokeRestart("muffleMessage")
[10:59:35.404]                     }
[10:59:35.404]                     else if (inherits(cond, "warning")) {
[10:59:35.404]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.404]                       if (muffled) 
[10:59:35.404]                         invokeRestart("muffleWarning")
[10:59:35.404]                     }
[10:59:35.404]                     else if (inherits(cond, "condition")) {
[10:59:35.404]                       if (!is.null(pattern)) {
[10:59:35.404]                         computeRestarts <- base::computeRestarts
[10:59:35.404]                         grepl <- base::grepl
[10:59:35.404]                         restarts <- computeRestarts(cond)
[10:59:35.404]                         for (restart in restarts) {
[10:59:35.404]                           name <- restart$name
[10:59:35.404]                           if (is.null(name)) 
[10:59:35.404]                             next
[10:59:35.404]                           if (!grepl(pattern, name)) 
[10:59:35.404]                             next
[10:59:35.404]                           invokeRestart(restart)
[10:59:35.404]                           muffled <- TRUE
[10:59:35.404]                           break
[10:59:35.404]                         }
[10:59:35.404]                       }
[10:59:35.404]                     }
[10:59:35.404]                     invisible(muffled)
[10:59:35.404]                   }
[10:59:35.404]                   muffleCondition(cond)
[10:59:35.404]                 })
[10:59:35.404]             }))
[10:59:35.404]             future::FutureResult(value = ...future.value$value, 
[10:59:35.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.404]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.404]                     ...future.globalenv.names))
[10:59:35.404]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.404]         }, condition = base::local({
[10:59:35.404]             c <- base::c
[10:59:35.404]             inherits <- base::inherits
[10:59:35.404]             invokeRestart <- base::invokeRestart
[10:59:35.404]             length <- base::length
[10:59:35.404]             list <- base::list
[10:59:35.404]             seq.int <- base::seq.int
[10:59:35.404]             signalCondition <- base::signalCondition
[10:59:35.404]             sys.calls <- base::sys.calls
[10:59:35.404]             `[[` <- base::`[[`
[10:59:35.404]             `+` <- base::`+`
[10:59:35.404]             `<<-` <- base::`<<-`
[10:59:35.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.404]                   3L)]
[10:59:35.404]             }
[10:59:35.404]             function(cond) {
[10:59:35.404]                 is_error <- inherits(cond, "error")
[10:59:35.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.404]                   NULL)
[10:59:35.404]                 if (is_error) {
[10:59:35.404]                   sessionInformation <- function() {
[10:59:35.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.404]                       search = base::search(), system = base::Sys.info())
[10:59:35.404]                   }
[10:59:35.404]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.404]                     cond$call), session = sessionInformation(), 
[10:59:35.404]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.404]                   signalCondition(cond)
[10:59:35.404]                 }
[10:59:35.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.404]                 "immediateCondition"))) {
[10:59:35.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.404]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.404]                   if (TRUE && !signal) {
[10:59:35.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.404]                     {
[10:59:35.404]                       inherits <- base::inherits
[10:59:35.404]                       invokeRestart <- base::invokeRestart
[10:59:35.404]                       is.null <- base::is.null
[10:59:35.404]                       muffled <- FALSE
[10:59:35.404]                       if (inherits(cond, "message")) {
[10:59:35.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.404]                         if (muffled) 
[10:59:35.404]                           invokeRestart("muffleMessage")
[10:59:35.404]                       }
[10:59:35.404]                       else if (inherits(cond, "warning")) {
[10:59:35.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.404]                         if (muffled) 
[10:59:35.404]                           invokeRestart("muffleWarning")
[10:59:35.404]                       }
[10:59:35.404]                       else if (inherits(cond, "condition")) {
[10:59:35.404]                         if (!is.null(pattern)) {
[10:59:35.404]                           computeRestarts <- base::computeRestarts
[10:59:35.404]                           grepl <- base::grepl
[10:59:35.404]                           restarts <- computeRestarts(cond)
[10:59:35.404]                           for (restart in restarts) {
[10:59:35.404]                             name <- restart$name
[10:59:35.404]                             if (is.null(name)) 
[10:59:35.404]                               next
[10:59:35.404]                             if (!grepl(pattern, name)) 
[10:59:35.404]                               next
[10:59:35.404]                             invokeRestart(restart)
[10:59:35.404]                             muffled <- TRUE
[10:59:35.404]                             break
[10:59:35.404]                           }
[10:59:35.404]                         }
[10:59:35.404]                       }
[10:59:35.404]                       invisible(muffled)
[10:59:35.404]                     }
[10:59:35.404]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.404]                   }
[10:59:35.404]                 }
[10:59:35.404]                 else {
[10:59:35.404]                   if (TRUE) {
[10:59:35.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.404]                     {
[10:59:35.404]                       inherits <- base::inherits
[10:59:35.404]                       invokeRestart <- base::invokeRestart
[10:59:35.404]                       is.null <- base::is.null
[10:59:35.404]                       muffled <- FALSE
[10:59:35.404]                       if (inherits(cond, "message")) {
[10:59:35.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.404]                         if (muffled) 
[10:59:35.404]                           invokeRestart("muffleMessage")
[10:59:35.404]                       }
[10:59:35.404]                       else if (inherits(cond, "warning")) {
[10:59:35.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.404]                         if (muffled) 
[10:59:35.404]                           invokeRestart("muffleWarning")
[10:59:35.404]                       }
[10:59:35.404]                       else if (inherits(cond, "condition")) {
[10:59:35.404]                         if (!is.null(pattern)) {
[10:59:35.404]                           computeRestarts <- base::computeRestarts
[10:59:35.404]                           grepl <- base::grepl
[10:59:35.404]                           restarts <- computeRestarts(cond)
[10:59:35.404]                           for (restart in restarts) {
[10:59:35.404]                             name <- restart$name
[10:59:35.404]                             if (is.null(name)) 
[10:59:35.404]                               next
[10:59:35.404]                             if (!grepl(pattern, name)) 
[10:59:35.404]                               next
[10:59:35.404]                             invokeRestart(restart)
[10:59:35.404]                             muffled <- TRUE
[10:59:35.404]                             break
[10:59:35.404]                           }
[10:59:35.404]                         }
[10:59:35.404]                       }
[10:59:35.404]                       invisible(muffled)
[10:59:35.404]                     }
[10:59:35.404]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.404]                   }
[10:59:35.404]                 }
[10:59:35.404]             }
[10:59:35.404]         }))
[10:59:35.404]     }, error = function(ex) {
[10:59:35.404]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.404]                 ...future.rng), started = ...future.startTime, 
[10:59:35.404]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.404]             version = "1.8"), class = "FutureResult")
[10:59:35.404]     }, finally = {
[10:59:35.404]         if (!identical(...future.workdir, getwd())) 
[10:59:35.404]             setwd(...future.workdir)
[10:59:35.404]         {
[10:59:35.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.404]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.404]             }
[10:59:35.404]             base::options(...future.oldOptions)
[10:59:35.404]             if (.Platform$OS.type == "windows") {
[10:59:35.404]                 old_names <- names(...future.oldEnvVars)
[10:59:35.404]                 envs <- base::Sys.getenv()
[10:59:35.404]                 names <- names(envs)
[10:59:35.404]                 common <- intersect(names, old_names)
[10:59:35.404]                 added <- setdiff(names, old_names)
[10:59:35.404]                 removed <- setdiff(old_names, names)
[10:59:35.404]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.404]                   envs[common]]
[10:59:35.404]                 NAMES <- toupper(changed)
[10:59:35.404]                 args <- list()
[10:59:35.404]                 for (kk in seq_along(NAMES)) {
[10:59:35.404]                   name <- changed[[kk]]
[10:59:35.404]                   NAME <- NAMES[[kk]]
[10:59:35.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.404]                     next
[10:59:35.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.404]                 }
[10:59:35.404]                 NAMES <- toupper(added)
[10:59:35.404]                 for (kk in seq_along(NAMES)) {
[10:59:35.404]                   name <- added[[kk]]
[10:59:35.404]                   NAME <- NAMES[[kk]]
[10:59:35.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.404]                     next
[10:59:35.404]                   args[[name]] <- ""
[10:59:35.404]                 }
[10:59:35.404]                 NAMES <- toupper(removed)
[10:59:35.404]                 for (kk in seq_along(NAMES)) {
[10:59:35.404]                   name <- removed[[kk]]
[10:59:35.404]                   NAME <- NAMES[[kk]]
[10:59:35.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.404]                     next
[10:59:35.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.404]                 }
[10:59:35.404]                 if (length(args) > 0) 
[10:59:35.404]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.404]             }
[10:59:35.404]             else {
[10:59:35.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.404]             }
[10:59:35.404]             {
[10:59:35.404]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.404]                   0L) {
[10:59:35.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.404]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.404]                   base::options(opts)
[10:59:35.404]                 }
[10:59:35.404]                 {
[10:59:35.404]                   {
[10:59:35.404]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.404]                     NULL
[10:59:35.404]                   }
[10:59:35.404]                   options(future.plan = NULL)
[10:59:35.404]                   if (is.na(NA_character_)) 
[10:59:35.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.404]                     .init = FALSE)
[10:59:35.404]                 }
[10:59:35.404]             }
[10:59:35.404]         }
[10:59:35.404]     })
[10:59:35.404]     if (TRUE) {
[10:59:35.404]         base::sink(type = "output", split = FALSE)
[10:59:35.404]         if (TRUE) {
[10:59:35.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.404]         }
[10:59:35.404]         else {
[10:59:35.404]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.404]         }
[10:59:35.404]         base::close(...future.stdout)
[10:59:35.404]         ...future.stdout <- NULL
[10:59:35.404]     }
[10:59:35.404]     ...future.result$conditions <- ...future.conditions
[10:59:35.404]     ...future.result$finished <- base::Sys.time()
[10:59:35.404]     ...future.result
[10:59:35.404] }
[10:59:35.407] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[10:59:35.407] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ...
[10:59:35.407] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ... DONE
[10:59:35.408] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:59:35.408] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:59:35.408] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ...
[10:59:35.408] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ... DONE
[10:59:35.408] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.409] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.409] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.409] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.409] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[10:59:35.410] MultisessionFuture started
[10:59:35.410] - Launch lazy future ... done
[10:59:35.410] run() for ‘MultisessionFuture’ ... done
[10:59:35.410] Created future:
[10:59:35.410] MultisessionFuture:
[10:59:35.410] Label: ‘future_.mapply-2’
[10:59:35.410] Expression:
[10:59:35.410] {
[10:59:35.410]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.410]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.410]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.410]         on.exit(options(oopts), add = TRUE)
[10:59:35.410]     }
[10:59:35.410]     {
[10:59:35.410]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.410]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.410]         do.call(mapply, args = args)
[10:59:35.410]     }
[10:59:35.410] }
[10:59:35.410] Lazy evaluation: FALSE
[10:59:35.410] Asynchronous evaluation: TRUE
[10:59:35.410] Local evaluation: TRUE
[10:59:35.410] Environment: R_GlobalEnv
[10:59:35.410] Capture standard output: TRUE
[10:59:35.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.410] Globals: 5 objects totaling 699 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.410] Packages: <none>
[10:59:35.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.410] Resolved: FALSE
[10:59:35.410] Value: <not collected>
[10:59:35.410] Conditions captured: <none>
[10:59:35.410] Early signaling: FALSE
[10:59:35.410] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.410] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.422] Chunk #2 of 2 ... DONE
[10:59:35.422] Launching 2 futures (chunks) ... DONE
[10:59:35.422] Resolving 2 futures (chunks) ...
[10:59:35.422] resolve() on list ...
[10:59:35.422]  recursive: 0
[10:59:35.422]  length: 2
[10:59:35.422] 
[10:59:35.423] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.423] - Validating connection of MultisessionFuture
[10:59:35.423] - received message: FutureResult
[10:59:35.423] - Received FutureResult
[10:59:35.423] - Erased future from FutureRegistry
[10:59:35.423] result() for ClusterFuture ...
[10:59:35.423] - result already collected: FutureResult
[10:59:35.423] result() for ClusterFuture ... done
[10:59:35.423] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.423] Future #1
[10:59:35.424] result() for ClusterFuture ...
[10:59:35.424] - result already collected: FutureResult
[10:59:35.424] result() for ClusterFuture ... done
[10:59:35.424] result() for ClusterFuture ...
[10:59:35.424] - result already collected: FutureResult
[10:59:35.424] result() for ClusterFuture ... done
[10:59:35.424] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:35.424] - nx: 2
[10:59:35.424] - relay: TRUE
[10:59:35.424] - stdout: TRUE
[10:59:35.424] - signal: TRUE
[10:59:35.424] - resignal: FALSE
[10:59:35.425] - force: TRUE
[10:59:35.425] - relayed: [n=2] FALSE, FALSE
[10:59:35.425] - queued futures: [n=2] FALSE, FALSE
[10:59:35.425]  - until=1
[10:59:35.425]  - relaying element #1
[10:59:35.425] result() for ClusterFuture ...
[10:59:35.425] - result already collected: FutureResult
[10:59:35.425] result() for ClusterFuture ... done
[10:59:35.425] result() for ClusterFuture ...
[10:59:35.425] - result already collected: FutureResult
[10:59:35.425] result() for ClusterFuture ... done
[10:59:35.425] result() for ClusterFuture ...
[10:59:35.426] - result already collected: FutureResult
[10:59:35.426] result() for ClusterFuture ... done
[10:59:35.426] result() for ClusterFuture ...
[10:59:35.426] - result already collected: FutureResult
[10:59:35.426] result() for ClusterFuture ... done
[10:59:35.426] - relayed: [n=2] TRUE, FALSE
[10:59:35.426] - queued futures: [n=2] TRUE, FALSE
[10:59:35.426] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:35.426]  length: 1 (resolved future 1)
[10:59:35.452] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.452] - Validating connection of MultisessionFuture
[10:59:35.452] - received message: FutureResult
[10:59:35.452] - Received FutureResult
[10:59:35.453] - Erased future from FutureRegistry
[10:59:35.453] result() for ClusterFuture ...
[10:59:35.453] - result already collected: FutureResult
[10:59:35.453] result() for ClusterFuture ... done
[10:59:35.453] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.453] Future #2
[10:59:35.453] result() for ClusterFuture ...
[10:59:35.453] - result already collected: FutureResult
[10:59:35.453] result() for ClusterFuture ... done
[10:59:35.453] result() for ClusterFuture ...
[10:59:35.453] - result already collected: FutureResult
[10:59:35.454] result() for ClusterFuture ... done
[10:59:35.454] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:35.454] - nx: 2
[10:59:35.454] - relay: TRUE
[10:59:35.454] - stdout: TRUE
[10:59:35.454] - signal: TRUE
[10:59:35.454] - resignal: FALSE
[10:59:35.454] - force: TRUE
[10:59:35.454] - relayed: [n=2] TRUE, FALSE
[10:59:35.454] - queued futures: [n=2] TRUE, FALSE
[10:59:35.454]  - until=2
[10:59:35.454]  - relaying element #2
[10:59:35.455] result() for ClusterFuture ...
[10:59:35.455] - result already collected: FutureResult
[10:59:35.455] result() for ClusterFuture ... done
[10:59:35.455] result() for ClusterFuture ...
[10:59:35.455] - result already collected: FutureResult
[10:59:35.455] result() for ClusterFuture ... done
[10:59:35.455] result() for ClusterFuture ...
[10:59:35.455] - result already collected: FutureResult
[10:59:35.455] result() for ClusterFuture ... done
[10:59:35.455] result() for ClusterFuture ...
[10:59:35.455] - result already collected: FutureResult
[10:59:35.455] result() for ClusterFuture ... done
[10:59:35.456] - relayed: [n=2] TRUE, TRUE
[10:59:35.456] - queued futures: [n=2] TRUE, TRUE
[10:59:35.456] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:35.456]  length: 0 (resolved future 2)
[10:59:35.456] Relaying remaining futures
[10:59:35.456] signalConditionsASAP(NULL, pos=0) ...
[10:59:35.456] - nx: 2
[10:59:35.456] - relay: TRUE
[10:59:35.456] - stdout: TRUE
[10:59:35.456] - signal: TRUE
[10:59:35.456] - resignal: FALSE
[10:59:35.456] - force: TRUE
[10:59:35.457] - relayed: [n=2] TRUE, TRUE
[10:59:35.457] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:35.457] - relayed: [n=2] TRUE, TRUE
[10:59:35.457] - queued futures: [n=2] TRUE, TRUE
[10:59:35.457] signalConditionsASAP(NULL, pos=0) ... done
[10:59:35.457] resolve() on list ... DONE
[10:59:35.457] result() for ClusterFuture ...
[10:59:35.457] - result already collected: FutureResult
[10:59:35.457] result() for ClusterFuture ... done
[10:59:35.457] result() for ClusterFuture ...
[10:59:35.457] - result already collected: FutureResult
[10:59:35.458] result() for ClusterFuture ... done
[10:59:35.458] result() for ClusterFuture ...
[10:59:35.458] - result already collected: FutureResult
[10:59:35.458] result() for ClusterFuture ... done
[10:59:35.458] result() for ClusterFuture ...
[10:59:35.458] - result already collected: FutureResult
[10:59:35.458] result() for ClusterFuture ... done
[10:59:35.458]  - Number of value chunks collected: 2
[10:59:35.458] Resolving 2 futures (chunks) ... DONE
[10:59:35.458] Reducing values from 2 chunks ...
[10:59:35.458]  - Number of values collected after concatenation: 3
[10:59:35.458]  - Number of values expected: 3
[10:59:35.459] Reducing values from 2 chunks ... DONE
[10:59:35.459] future_mapply() ... DONE
[10:59:35.459] future_mapply() ...
[10:59:35.462] Number of chunks: 5
[10:59:35.462] getGlobalsAndPackagesXApply() ...
[10:59:35.462]  - future.globals: TRUE
[10:59:35.462] getGlobalsAndPackages() ...
[10:59:35.462] Searching for globals...
[10:59:35.464] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:35.464] Searching for globals ... DONE
[10:59:35.464] Resolving globals: FALSE
[10:59:35.464] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:35.464] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:35.465] - globals: [1] ‘FUN’
[10:59:35.465] 
[10:59:35.465] getGlobalsAndPackages() ... DONE
[10:59:35.465]  - globals found/used: [n=1] ‘FUN’
[10:59:35.465]  - needed namespaces: [n=0] 
[10:59:35.465] Finding globals ... DONE
[10:59:35.465] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:35.465] List of 2
[10:59:35.465]  $ ...future.FUN:function (C, k)  
[10:59:35.465]  $ MoreArgs     : NULL
[10:59:35.465]  - attr(*, "where")=List of 2
[10:59:35.465]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:35.465]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:35.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:35.465]  - attr(*, "resolved")= logi FALSE
[10:59:35.465]  - attr(*, "total_size")= num NA
[10:59:35.468] Packages to be attached in all futures: [n=0] 
[10:59:35.468] getGlobalsAndPackagesXApply() ... DONE
[10:59:35.468] Number of futures (= number of chunks): 5
[10:59:35.468] Launching 5 futures (chunks) ...
[10:59:35.468] Chunk #1 of 5 ...
[10:59:35.468]  - Finding globals in '...' for chunk #1 ...
[10:59:35.468] getGlobalsAndPackages() ...
[10:59:35.468] Searching for globals...
[10:59:35.469] 
[10:59:35.469] Searching for globals ... DONE
[10:59:35.469] - globals: [0] <none>
[10:59:35.469] getGlobalsAndPackages() ... DONE
[10:59:35.469]    + additional globals found: [n=0] 
[10:59:35.469]    + additional namespaces needed: [n=0] 
[10:59:35.469]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:35.469]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:35.469]  - seeds: <none>
[10:59:35.469]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.469] getGlobalsAndPackages() ...
[10:59:35.470] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.470] Resolving globals: FALSE
[10:59:35.470] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:35.470] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.471] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.471] 
[10:59:35.471] getGlobalsAndPackages() ... DONE
[10:59:35.471] run() for ‘Future’ ...
[10:59:35.471] - state: ‘created’
[10:59:35.471] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.484] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.484] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.485]   - Field: ‘node’
[10:59:35.485]   - Field: ‘label’
[10:59:35.485]   - Field: ‘local’
[10:59:35.485]   - Field: ‘owner’
[10:59:35.485]   - Field: ‘envir’
[10:59:35.485]   - Field: ‘workers’
[10:59:35.485]   - Field: ‘packages’
[10:59:35.485]   - Field: ‘gc’
[10:59:35.485]   - Field: ‘conditions’
[10:59:35.485]   - Field: ‘persistent’
[10:59:35.485]   - Field: ‘expr’
[10:59:35.486]   - Field: ‘uuid’
[10:59:35.486]   - Field: ‘seed’
[10:59:35.486]   - Field: ‘version’
[10:59:35.486]   - Field: ‘result’
[10:59:35.486]   - Field: ‘asynchronous’
[10:59:35.486]   - Field: ‘calls’
[10:59:35.486]   - Field: ‘globals’
[10:59:35.486]   - Field: ‘stdout’
[10:59:35.486]   - Field: ‘earlySignal’
[10:59:35.486]   - Field: ‘lazy’
[10:59:35.486]   - Field: ‘state’
[10:59:35.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.486] - Launch lazy future ...
[10:59:35.487] Packages needed by the future expression (n = 0): <none>
[10:59:35.487] Packages needed by future strategies (n = 0): <none>
[10:59:35.487] {
[10:59:35.487]     {
[10:59:35.487]         {
[10:59:35.487]             ...future.startTime <- base::Sys.time()
[10:59:35.487]             {
[10:59:35.487]                 {
[10:59:35.487]                   {
[10:59:35.487]                     {
[10:59:35.487]                       base::local({
[10:59:35.487]                         has_future <- base::requireNamespace("future", 
[10:59:35.487]                           quietly = TRUE)
[10:59:35.487]                         if (has_future) {
[10:59:35.487]                           ns <- base::getNamespace("future")
[10:59:35.487]                           version <- ns[[".package"]][["version"]]
[10:59:35.487]                           if (is.null(version)) 
[10:59:35.487]                             version <- utils::packageVersion("future")
[10:59:35.487]                         }
[10:59:35.487]                         else {
[10:59:35.487]                           version <- NULL
[10:59:35.487]                         }
[10:59:35.487]                         if (!has_future || version < "1.8.0") {
[10:59:35.487]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.487]                             "", base::R.version$version.string), 
[10:59:35.487]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.487]                               "release", "version")], collapse = " "), 
[10:59:35.487]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.487]                             info)
[10:59:35.487]                           info <- base::paste(info, collapse = "; ")
[10:59:35.487]                           if (!has_future) {
[10:59:35.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.487]                               info)
[10:59:35.487]                           }
[10:59:35.487]                           else {
[10:59:35.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.487]                               info, version)
[10:59:35.487]                           }
[10:59:35.487]                           base::stop(msg)
[10:59:35.487]                         }
[10:59:35.487]                       })
[10:59:35.487]                     }
[10:59:35.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.487]                     base::options(mc.cores = 1L)
[10:59:35.487]                   }
[10:59:35.487]                   ...future.strategy.old <- future::plan("list")
[10:59:35.487]                   options(future.plan = NULL)
[10:59:35.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.487]                 }
[10:59:35.487]                 ...future.workdir <- getwd()
[10:59:35.487]             }
[10:59:35.487]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.487]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.487]         }
[10:59:35.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.487]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:35.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.487]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.487]             base::names(...future.oldOptions))
[10:59:35.487]     }
[10:59:35.487]     if (FALSE) {
[10:59:35.487]     }
[10:59:35.487]     else {
[10:59:35.487]         if (TRUE) {
[10:59:35.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.487]                 open = "w")
[10:59:35.487]         }
[10:59:35.487]         else {
[10:59:35.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.487]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.487]         }
[10:59:35.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.487]             base::sink(type = "output", split = FALSE)
[10:59:35.487]             base::close(...future.stdout)
[10:59:35.487]         }, add = TRUE)
[10:59:35.487]     }
[10:59:35.487]     ...future.frame <- base::sys.nframe()
[10:59:35.487]     ...future.conditions <- base::list()
[10:59:35.487]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.487]     if (FALSE) {
[10:59:35.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.487]     }
[10:59:35.487]     ...future.result <- base::tryCatch({
[10:59:35.487]         base::withCallingHandlers({
[10:59:35.487]             ...future.value <- base::withVisible(base::local({
[10:59:35.487]                 ...future.makeSendCondition <- base::local({
[10:59:35.487]                   sendCondition <- NULL
[10:59:35.487]                   function(frame = 1L) {
[10:59:35.487]                     if (is.function(sendCondition)) 
[10:59:35.487]                       return(sendCondition)
[10:59:35.487]                     ns <- getNamespace("parallel")
[10:59:35.487]                     if (exists("sendData", mode = "function", 
[10:59:35.487]                       envir = ns)) {
[10:59:35.487]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.487]                         envir = ns)
[10:59:35.487]                       envir <- sys.frame(frame)
[10:59:35.487]                       master <- NULL
[10:59:35.487]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.487]                         !identical(envir, emptyenv())) {
[10:59:35.487]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.487]                           inherits = FALSE)) {
[10:59:35.487]                           master <- get("master", mode = "list", 
[10:59:35.487]                             envir = envir, inherits = FALSE)
[10:59:35.487]                           if (inherits(master, c("SOCKnode", 
[10:59:35.487]                             "SOCK0node"))) {
[10:59:35.487]                             sendCondition <<- function(cond) {
[10:59:35.487]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.487]                                 success = TRUE)
[10:59:35.487]                               parallel_sendData(master, data)
[10:59:35.487]                             }
[10:59:35.487]                             return(sendCondition)
[10:59:35.487]                           }
[10:59:35.487]                         }
[10:59:35.487]                         frame <- frame + 1L
[10:59:35.487]                         envir <- sys.frame(frame)
[10:59:35.487]                       }
[10:59:35.487]                     }
[10:59:35.487]                     sendCondition <<- function(cond) NULL
[10:59:35.487]                   }
[10:59:35.487]                 })
[10:59:35.487]                 withCallingHandlers({
[10:59:35.487]                   {
[10:59:35.487]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.487]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.487]                       ...future.globals.maxSize)) {
[10:59:35.487]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.487]                       on.exit(options(oopts), add = TRUE)
[10:59:35.487]                     }
[10:59:35.487]                     {
[10:59:35.487]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.487]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.487]                         USE.NAMES = FALSE)
[10:59:35.487]                       do.call(mapply, args = args)
[10:59:35.487]                     }
[10:59:35.487]                   }
[10:59:35.487]                 }, immediateCondition = function(cond) {
[10:59:35.487]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.487]                   sendCondition(cond)
[10:59:35.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.487]                   {
[10:59:35.487]                     inherits <- base::inherits
[10:59:35.487]                     invokeRestart <- base::invokeRestart
[10:59:35.487]                     is.null <- base::is.null
[10:59:35.487]                     muffled <- FALSE
[10:59:35.487]                     if (inherits(cond, "message")) {
[10:59:35.487]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.487]                       if (muffled) 
[10:59:35.487]                         invokeRestart("muffleMessage")
[10:59:35.487]                     }
[10:59:35.487]                     else if (inherits(cond, "warning")) {
[10:59:35.487]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.487]                       if (muffled) 
[10:59:35.487]                         invokeRestart("muffleWarning")
[10:59:35.487]                     }
[10:59:35.487]                     else if (inherits(cond, "condition")) {
[10:59:35.487]                       if (!is.null(pattern)) {
[10:59:35.487]                         computeRestarts <- base::computeRestarts
[10:59:35.487]                         grepl <- base::grepl
[10:59:35.487]                         restarts <- computeRestarts(cond)
[10:59:35.487]                         for (restart in restarts) {
[10:59:35.487]                           name <- restart$name
[10:59:35.487]                           if (is.null(name)) 
[10:59:35.487]                             next
[10:59:35.487]                           if (!grepl(pattern, name)) 
[10:59:35.487]                             next
[10:59:35.487]                           invokeRestart(restart)
[10:59:35.487]                           muffled <- TRUE
[10:59:35.487]                           break
[10:59:35.487]                         }
[10:59:35.487]                       }
[10:59:35.487]                     }
[10:59:35.487]                     invisible(muffled)
[10:59:35.487]                   }
[10:59:35.487]                   muffleCondition(cond)
[10:59:35.487]                 })
[10:59:35.487]             }))
[10:59:35.487]             future::FutureResult(value = ...future.value$value, 
[10:59:35.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.487]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.487]                     ...future.globalenv.names))
[10:59:35.487]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.487]         }, condition = base::local({
[10:59:35.487]             c <- base::c
[10:59:35.487]             inherits <- base::inherits
[10:59:35.487]             invokeRestart <- base::invokeRestart
[10:59:35.487]             length <- base::length
[10:59:35.487]             list <- base::list
[10:59:35.487]             seq.int <- base::seq.int
[10:59:35.487]             signalCondition <- base::signalCondition
[10:59:35.487]             sys.calls <- base::sys.calls
[10:59:35.487]             `[[` <- base::`[[`
[10:59:35.487]             `+` <- base::`+`
[10:59:35.487]             `<<-` <- base::`<<-`
[10:59:35.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.487]                   3L)]
[10:59:35.487]             }
[10:59:35.487]             function(cond) {
[10:59:35.487]                 is_error <- inherits(cond, "error")
[10:59:35.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.487]                   NULL)
[10:59:35.487]                 if (is_error) {
[10:59:35.487]                   sessionInformation <- function() {
[10:59:35.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.487]                       search = base::search(), system = base::Sys.info())
[10:59:35.487]                   }
[10:59:35.487]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.487]                     cond$call), session = sessionInformation(), 
[10:59:35.487]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.487]                   signalCondition(cond)
[10:59:35.487]                 }
[10:59:35.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.487]                 "immediateCondition"))) {
[10:59:35.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.487]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.487]                   if (TRUE && !signal) {
[10:59:35.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.487]                     {
[10:59:35.487]                       inherits <- base::inherits
[10:59:35.487]                       invokeRestart <- base::invokeRestart
[10:59:35.487]                       is.null <- base::is.null
[10:59:35.487]                       muffled <- FALSE
[10:59:35.487]                       if (inherits(cond, "message")) {
[10:59:35.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.487]                         if (muffled) 
[10:59:35.487]                           invokeRestart("muffleMessage")
[10:59:35.487]                       }
[10:59:35.487]                       else if (inherits(cond, "warning")) {
[10:59:35.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.487]                         if (muffled) 
[10:59:35.487]                           invokeRestart("muffleWarning")
[10:59:35.487]                       }
[10:59:35.487]                       else if (inherits(cond, "condition")) {
[10:59:35.487]                         if (!is.null(pattern)) {
[10:59:35.487]                           computeRestarts <- base::computeRestarts
[10:59:35.487]                           grepl <- base::grepl
[10:59:35.487]                           restarts <- computeRestarts(cond)
[10:59:35.487]                           for (restart in restarts) {
[10:59:35.487]                             name <- restart$name
[10:59:35.487]                             if (is.null(name)) 
[10:59:35.487]                               next
[10:59:35.487]                             if (!grepl(pattern, name)) 
[10:59:35.487]                               next
[10:59:35.487]                             invokeRestart(restart)
[10:59:35.487]                             muffled <- TRUE
[10:59:35.487]                             break
[10:59:35.487]                           }
[10:59:35.487]                         }
[10:59:35.487]                       }
[10:59:35.487]                       invisible(muffled)
[10:59:35.487]                     }
[10:59:35.487]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.487]                   }
[10:59:35.487]                 }
[10:59:35.487]                 else {
[10:59:35.487]                   if (TRUE) {
[10:59:35.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.487]                     {
[10:59:35.487]                       inherits <- base::inherits
[10:59:35.487]                       invokeRestart <- base::invokeRestart
[10:59:35.487]                       is.null <- base::is.null
[10:59:35.487]                       muffled <- FALSE
[10:59:35.487]                       if (inherits(cond, "message")) {
[10:59:35.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.487]                         if (muffled) 
[10:59:35.487]                           invokeRestart("muffleMessage")
[10:59:35.487]                       }
[10:59:35.487]                       else if (inherits(cond, "warning")) {
[10:59:35.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.487]                         if (muffled) 
[10:59:35.487]                           invokeRestart("muffleWarning")
[10:59:35.487]                       }
[10:59:35.487]                       else if (inherits(cond, "condition")) {
[10:59:35.487]                         if (!is.null(pattern)) {
[10:59:35.487]                           computeRestarts <- base::computeRestarts
[10:59:35.487]                           grepl <- base::grepl
[10:59:35.487]                           restarts <- computeRestarts(cond)
[10:59:35.487]                           for (restart in restarts) {
[10:59:35.487]                             name <- restart$name
[10:59:35.487]                             if (is.null(name)) 
[10:59:35.487]                               next
[10:59:35.487]                             if (!grepl(pattern, name)) 
[10:59:35.487]                               next
[10:59:35.487]                             invokeRestart(restart)
[10:59:35.487]                             muffled <- TRUE
[10:59:35.487]                             break
[10:59:35.487]                           }
[10:59:35.487]                         }
[10:59:35.487]                       }
[10:59:35.487]                       invisible(muffled)
[10:59:35.487]                     }
[10:59:35.487]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.487]                   }
[10:59:35.487]                 }
[10:59:35.487]             }
[10:59:35.487]         }))
[10:59:35.487]     }, error = function(ex) {
[10:59:35.487]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.487]                 ...future.rng), started = ...future.startTime, 
[10:59:35.487]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.487]             version = "1.8"), class = "FutureResult")
[10:59:35.487]     }, finally = {
[10:59:35.487]         if (!identical(...future.workdir, getwd())) 
[10:59:35.487]             setwd(...future.workdir)
[10:59:35.487]         {
[10:59:35.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.487]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.487]             }
[10:59:35.487]             base::options(...future.oldOptions)
[10:59:35.487]             if (.Platform$OS.type == "windows") {
[10:59:35.487]                 old_names <- names(...future.oldEnvVars)
[10:59:35.487]                 envs <- base::Sys.getenv()
[10:59:35.487]                 names <- names(envs)
[10:59:35.487]                 common <- intersect(names, old_names)
[10:59:35.487]                 added <- setdiff(names, old_names)
[10:59:35.487]                 removed <- setdiff(old_names, names)
[10:59:35.487]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.487]                   envs[common]]
[10:59:35.487]                 NAMES <- toupper(changed)
[10:59:35.487]                 args <- list()
[10:59:35.487]                 for (kk in seq_along(NAMES)) {
[10:59:35.487]                   name <- changed[[kk]]
[10:59:35.487]                   NAME <- NAMES[[kk]]
[10:59:35.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.487]                     next
[10:59:35.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.487]                 }
[10:59:35.487]                 NAMES <- toupper(added)
[10:59:35.487]                 for (kk in seq_along(NAMES)) {
[10:59:35.487]                   name <- added[[kk]]
[10:59:35.487]                   NAME <- NAMES[[kk]]
[10:59:35.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.487]                     next
[10:59:35.487]                   args[[name]] <- ""
[10:59:35.487]                 }
[10:59:35.487]                 NAMES <- toupper(removed)
[10:59:35.487]                 for (kk in seq_along(NAMES)) {
[10:59:35.487]                   name <- removed[[kk]]
[10:59:35.487]                   NAME <- NAMES[[kk]]
[10:59:35.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.487]                     next
[10:59:35.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.487]                 }
[10:59:35.487]                 if (length(args) > 0) 
[10:59:35.487]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.487]             }
[10:59:35.487]             else {
[10:59:35.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.487]             }
[10:59:35.487]             {
[10:59:35.487]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.487]                   0L) {
[10:59:35.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.487]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.487]                   base::options(opts)
[10:59:35.487]                 }
[10:59:35.487]                 {
[10:59:35.487]                   {
[10:59:35.487]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.487]                     NULL
[10:59:35.487]                   }
[10:59:35.487]                   options(future.plan = NULL)
[10:59:35.487]                   if (is.na(NA_character_)) 
[10:59:35.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.487]                     .init = FALSE)
[10:59:35.487]                 }
[10:59:35.487]             }
[10:59:35.487]         }
[10:59:35.487]     })
[10:59:35.487]     if (TRUE) {
[10:59:35.487]         base::sink(type = "output", split = FALSE)
[10:59:35.487]         if (TRUE) {
[10:59:35.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.487]         }
[10:59:35.487]         else {
[10:59:35.487]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.487]         }
[10:59:35.487]         base::close(...future.stdout)
[10:59:35.487]         ...future.stdout <- NULL
[10:59:35.487]     }
[10:59:35.487]     ...future.result$conditions <- ...future.conditions
[10:59:35.487]     ...future.result$finished <- base::Sys.time()
[10:59:35.487]     ...future.result
[10:59:35.487] }
[10:59:35.490] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:59:35.490] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:35.490] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:35.490] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:35.491] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.491] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[10:59:35.491] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[10:59:35.491] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.492] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.492] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.492] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.492] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:59:35.493] MultisessionFuture started
[10:59:35.493] - Launch lazy future ... done
[10:59:35.493] run() for ‘MultisessionFuture’ ... done
[10:59:35.493] Created future:
[10:59:35.493] MultisessionFuture:
[10:59:35.493] Label: ‘future_mapply-1’
[10:59:35.493] Expression:
[10:59:35.493] {
[10:59:35.493]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.493]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.493]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.493]         on.exit(options(oopts), add = TRUE)
[10:59:35.493]     }
[10:59:35.493]     {
[10:59:35.493]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.493]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.493]         do.call(mapply, args = args)
[10:59:35.493]     }
[10:59:35.493] }
[10:59:35.493] Lazy evaluation: FALSE
[10:59:35.493] Asynchronous evaluation: TRUE
[10:59:35.493] Local evaluation: TRUE
[10:59:35.493] Environment: R_GlobalEnv
[10:59:35.493] Capture standard output: TRUE
[10:59:35.493] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.493] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.493] Packages: <none>
[10:59:35.493] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.493] Resolved: FALSE
[10:59:35.493] Value: <not collected>
[10:59:35.493] Conditions captured: <none>
[10:59:35.493] Early signaling: FALSE
[10:59:35.493] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.493] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.504] Chunk #1 of 5 ... DONE
[10:59:35.504] Chunk #2 of 5 ...
[10:59:35.505]  - Finding globals in '...' for chunk #2 ...
[10:59:35.505] getGlobalsAndPackages() ...
[10:59:35.505] Searching for globals...
[10:59:35.505] 
[10:59:35.505] Searching for globals ... DONE
[10:59:35.505] - globals: [0] <none>
[10:59:35.505] getGlobalsAndPackages() ... DONE
[10:59:35.505]    + additional globals found: [n=0] 
[10:59:35.506]    + additional namespaces needed: [n=0] 
[10:59:35.506]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:35.506]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:35.506]  - seeds: <none>
[10:59:35.506]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.506] getGlobalsAndPackages() ...
[10:59:35.506] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.506] Resolving globals: FALSE
[10:59:35.506] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:35.507] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.507] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.507] 
[10:59:35.507] getGlobalsAndPackages() ... DONE
[10:59:35.507] run() for ‘Future’ ...
[10:59:35.507] - state: ‘created’
[10:59:35.508] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.521]   - Field: ‘node’
[10:59:35.521]   - Field: ‘label’
[10:59:35.521]   - Field: ‘local’
[10:59:35.521]   - Field: ‘owner’
[10:59:35.521]   - Field: ‘envir’
[10:59:35.521]   - Field: ‘workers’
[10:59:35.521]   - Field: ‘packages’
[10:59:35.522]   - Field: ‘gc’
[10:59:35.522]   - Field: ‘conditions’
[10:59:35.522]   - Field: ‘persistent’
[10:59:35.522]   - Field: ‘expr’
[10:59:35.522]   - Field: ‘uuid’
[10:59:35.522]   - Field: ‘seed’
[10:59:35.522]   - Field: ‘version’
[10:59:35.522]   - Field: ‘result’
[10:59:35.522]   - Field: ‘asynchronous’
[10:59:35.522]   - Field: ‘calls’
[10:59:35.522]   - Field: ‘globals’
[10:59:35.522]   - Field: ‘stdout’
[10:59:35.522]   - Field: ‘earlySignal’
[10:59:35.523]   - Field: ‘lazy’
[10:59:35.523]   - Field: ‘state’
[10:59:35.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.523] - Launch lazy future ...
[10:59:35.523] Packages needed by the future expression (n = 0): <none>
[10:59:35.523] Packages needed by future strategies (n = 0): <none>
[10:59:35.523] {
[10:59:35.523]     {
[10:59:35.523]         {
[10:59:35.523]             ...future.startTime <- base::Sys.time()
[10:59:35.523]             {
[10:59:35.523]                 {
[10:59:35.523]                   {
[10:59:35.523]                     {
[10:59:35.523]                       base::local({
[10:59:35.523]                         has_future <- base::requireNamespace("future", 
[10:59:35.523]                           quietly = TRUE)
[10:59:35.523]                         if (has_future) {
[10:59:35.523]                           ns <- base::getNamespace("future")
[10:59:35.523]                           version <- ns[[".package"]][["version"]]
[10:59:35.523]                           if (is.null(version)) 
[10:59:35.523]                             version <- utils::packageVersion("future")
[10:59:35.523]                         }
[10:59:35.523]                         else {
[10:59:35.523]                           version <- NULL
[10:59:35.523]                         }
[10:59:35.523]                         if (!has_future || version < "1.8.0") {
[10:59:35.523]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.523]                             "", base::R.version$version.string), 
[10:59:35.523]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.523]                               "release", "version")], collapse = " "), 
[10:59:35.523]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.523]                             info)
[10:59:35.523]                           info <- base::paste(info, collapse = "; ")
[10:59:35.523]                           if (!has_future) {
[10:59:35.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.523]                               info)
[10:59:35.523]                           }
[10:59:35.523]                           else {
[10:59:35.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.523]                               info, version)
[10:59:35.523]                           }
[10:59:35.523]                           base::stop(msg)
[10:59:35.523]                         }
[10:59:35.523]                       })
[10:59:35.523]                     }
[10:59:35.523]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.523]                     base::options(mc.cores = 1L)
[10:59:35.523]                   }
[10:59:35.523]                   ...future.strategy.old <- future::plan("list")
[10:59:35.523]                   options(future.plan = NULL)
[10:59:35.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.523]                 }
[10:59:35.523]                 ...future.workdir <- getwd()
[10:59:35.523]             }
[10:59:35.523]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.523]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.523]         }
[10:59:35.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.523]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:35.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.523]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.523]             base::names(...future.oldOptions))
[10:59:35.523]     }
[10:59:35.523]     if (FALSE) {
[10:59:35.523]     }
[10:59:35.523]     else {
[10:59:35.523]         if (TRUE) {
[10:59:35.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.523]                 open = "w")
[10:59:35.523]         }
[10:59:35.523]         else {
[10:59:35.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.523]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.523]         }
[10:59:35.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.523]             base::sink(type = "output", split = FALSE)
[10:59:35.523]             base::close(...future.stdout)
[10:59:35.523]         }, add = TRUE)
[10:59:35.523]     }
[10:59:35.523]     ...future.frame <- base::sys.nframe()
[10:59:35.523]     ...future.conditions <- base::list()
[10:59:35.523]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.523]     if (FALSE) {
[10:59:35.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.523]     }
[10:59:35.523]     ...future.result <- base::tryCatch({
[10:59:35.523]         base::withCallingHandlers({
[10:59:35.523]             ...future.value <- base::withVisible(base::local({
[10:59:35.523]                 ...future.makeSendCondition <- base::local({
[10:59:35.523]                   sendCondition <- NULL
[10:59:35.523]                   function(frame = 1L) {
[10:59:35.523]                     if (is.function(sendCondition)) 
[10:59:35.523]                       return(sendCondition)
[10:59:35.523]                     ns <- getNamespace("parallel")
[10:59:35.523]                     if (exists("sendData", mode = "function", 
[10:59:35.523]                       envir = ns)) {
[10:59:35.523]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.523]                         envir = ns)
[10:59:35.523]                       envir <- sys.frame(frame)
[10:59:35.523]                       master <- NULL
[10:59:35.523]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.523]                         !identical(envir, emptyenv())) {
[10:59:35.523]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.523]                           inherits = FALSE)) {
[10:59:35.523]                           master <- get("master", mode = "list", 
[10:59:35.523]                             envir = envir, inherits = FALSE)
[10:59:35.523]                           if (inherits(master, c("SOCKnode", 
[10:59:35.523]                             "SOCK0node"))) {
[10:59:35.523]                             sendCondition <<- function(cond) {
[10:59:35.523]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.523]                                 success = TRUE)
[10:59:35.523]                               parallel_sendData(master, data)
[10:59:35.523]                             }
[10:59:35.523]                             return(sendCondition)
[10:59:35.523]                           }
[10:59:35.523]                         }
[10:59:35.523]                         frame <- frame + 1L
[10:59:35.523]                         envir <- sys.frame(frame)
[10:59:35.523]                       }
[10:59:35.523]                     }
[10:59:35.523]                     sendCondition <<- function(cond) NULL
[10:59:35.523]                   }
[10:59:35.523]                 })
[10:59:35.523]                 withCallingHandlers({
[10:59:35.523]                   {
[10:59:35.523]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.523]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.523]                       ...future.globals.maxSize)) {
[10:59:35.523]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.523]                       on.exit(options(oopts), add = TRUE)
[10:59:35.523]                     }
[10:59:35.523]                     {
[10:59:35.523]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.523]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.523]                         USE.NAMES = FALSE)
[10:59:35.523]                       do.call(mapply, args = args)
[10:59:35.523]                     }
[10:59:35.523]                   }
[10:59:35.523]                 }, immediateCondition = function(cond) {
[10:59:35.523]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.523]                   sendCondition(cond)
[10:59:35.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.523]                   {
[10:59:35.523]                     inherits <- base::inherits
[10:59:35.523]                     invokeRestart <- base::invokeRestart
[10:59:35.523]                     is.null <- base::is.null
[10:59:35.523]                     muffled <- FALSE
[10:59:35.523]                     if (inherits(cond, "message")) {
[10:59:35.523]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.523]                       if (muffled) 
[10:59:35.523]                         invokeRestart("muffleMessage")
[10:59:35.523]                     }
[10:59:35.523]                     else if (inherits(cond, "warning")) {
[10:59:35.523]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.523]                       if (muffled) 
[10:59:35.523]                         invokeRestart("muffleWarning")
[10:59:35.523]                     }
[10:59:35.523]                     else if (inherits(cond, "condition")) {
[10:59:35.523]                       if (!is.null(pattern)) {
[10:59:35.523]                         computeRestarts <- base::computeRestarts
[10:59:35.523]                         grepl <- base::grepl
[10:59:35.523]                         restarts <- computeRestarts(cond)
[10:59:35.523]                         for (restart in restarts) {
[10:59:35.523]                           name <- restart$name
[10:59:35.523]                           if (is.null(name)) 
[10:59:35.523]                             next
[10:59:35.523]                           if (!grepl(pattern, name)) 
[10:59:35.523]                             next
[10:59:35.523]                           invokeRestart(restart)
[10:59:35.523]                           muffled <- TRUE
[10:59:35.523]                           break
[10:59:35.523]                         }
[10:59:35.523]                       }
[10:59:35.523]                     }
[10:59:35.523]                     invisible(muffled)
[10:59:35.523]                   }
[10:59:35.523]                   muffleCondition(cond)
[10:59:35.523]                 })
[10:59:35.523]             }))
[10:59:35.523]             future::FutureResult(value = ...future.value$value, 
[10:59:35.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.523]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.523]                     ...future.globalenv.names))
[10:59:35.523]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.523]         }, condition = base::local({
[10:59:35.523]             c <- base::c
[10:59:35.523]             inherits <- base::inherits
[10:59:35.523]             invokeRestart <- base::invokeRestart
[10:59:35.523]             length <- base::length
[10:59:35.523]             list <- base::list
[10:59:35.523]             seq.int <- base::seq.int
[10:59:35.523]             signalCondition <- base::signalCondition
[10:59:35.523]             sys.calls <- base::sys.calls
[10:59:35.523]             `[[` <- base::`[[`
[10:59:35.523]             `+` <- base::`+`
[10:59:35.523]             `<<-` <- base::`<<-`
[10:59:35.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.523]                   3L)]
[10:59:35.523]             }
[10:59:35.523]             function(cond) {
[10:59:35.523]                 is_error <- inherits(cond, "error")
[10:59:35.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.523]                   NULL)
[10:59:35.523]                 if (is_error) {
[10:59:35.523]                   sessionInformation <- function() {
[10:59:35.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.523]                       search = base::search(), system = base::Sys.info())
[10:59:35.523]                   }
[10:59:35.523]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.523]                     cond$call), session = sessionInformation(), 
[10:59:35.523]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.523]                   signalCondition(cond)
[10:59:35.523]                 }
[10:59:35.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.523]                 "immediateCondition"))) {
[10:59:35.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.523]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.523]                   if (TRUE && !signal) {
[10:59:35.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.523]                     {
[10:59:35.523]                       inherits <- base::inherits
[10:59:35.523]                       invokeRestart <- base::invokeRestart
[10:59:35.523]                       is.null <- base::is.null
[10:59:35.523]                       muffled <- FALSE
[10:59:35.523]                       if (inherits(cond, "message")) {
[10:59:35.523]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.523]                         if (muffled) 
[10:59:35.523]                           invokeRestart("muffleMessage")
[10:59:35.523]                       }
[10:59:35.523]                       else if (inherits(cond, "warning")) {
[10:59:35.523]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.523]                         if (muffled) 
[10:59:35.523]                           invokeRestart("muffleWarning")
[10:59:35.523]                       }
[10:59:35.523]                       else if (inherits(cond, "condition")) {
[10:59:35.523]                         if (!is.null(pattern)) {
[10:59:35.523]                           computeRestarts <- base::computeRestarts
[10:59:35.523]                           grepl <- base::grepl
[10:59:35.523]                           restarts <- computeRestarts(cond)
[10:59:35.523]                           for (restart in restarts) {
[10:59:35.523]                             name <- restart$name
[10:59:35.523]                             if (is.null(name)) 
[10:59:35.523]                               next
[10:59:35.523]                             if (!grepl(pattern, name)) 
[10:59:35.523]                               next
[10:59:35.523]                             invokeRestart(restart)
[10:59:35.523]                             muffled <- TRUE
[10:59:35.523]                             break
[10:59:35.523]                           }
[10:59:35.523]                         }
[10:59:35.523]                       }
[10:59:35.523]                       invisible(muffled)
[10:59:35.523]                     }
[10:59:35.523]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.523]                   }
[10:59:35.523]                 }
[10:59:35.523]                 else {
[10:59:35.523]                   if (TRUE) {
[10:59:35.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.523]                     {
[10:59:35.523]                       inherits <- base::inherits
[10:59:35.523]                       invokeRestart <- base::invokeRestart
[10:59:35.523]                       is.null <- base::is.null
[10:59:35.523]                       muffled <- FALSE
[10:59:35.523]                       if (inherits(cond, "message")) {
[10:59:35.523]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.523]                         if (muffled) 
[10:59:35.523]                           invokeRestart("muffleMessage")
[10:59:35.523]                       }
[10:59:35.523]                       else if (inherits(cond, "warning")) {
[10:59:35.523]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.523]                         if (muffled) 
[10:59:35.523]                           invokeRestart("muffleWarning")
[10:59:35.523]                       }
[10:59:35.523]                       else if (inherits(cond, "condition")) {
[10:59:35.523]                         if (!is.null(pattern)) {
[10:59:35.523]                           computeRestarts <- base::computeRestarts
[10:59:35.523]                           grepl <- base::grepl
[10:59:35.523]                           restarts <- computeRestarts(cond)
[10:59:35.523]                           for (restart in restarts) {
[10:59:35.523]                             name <- restart$name
[10:59:35.523]                             if (is.null(name)) 
[10:59:35.523]                               next
[10:59:35.523]                             if (!grepl(pattern, name)) 
[10:59:35.523]                               next
[10:59:35.523]                             invokeRestart(restart)
[10:59:35.523]                             muffled <- TRUE
[10:59:35.523]                             break
[10:59:35.523]                           }
[10:59:35.523]                         }
[10:59:35.523]                       }
[10:59:35.523]                       invisible(muffled)
[10:59:35.523]                     }
[10:59:35.523]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.523]                   }
[10:59:35.523]                 }
[10:59:35.523]             }
[10:59:35.523]         }))
[10:59:35.523]     }, error = function(ex) {
[10:59:35.523]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.523]                 ...future.rng), started = ...future.startTime, 
[10:59:35.523]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.523]             version = "1.8"), class = "FutureResult")
[10:59:35.523]     }, finally = {
[10:59:35.523]         if (!identical(...future.workdir, getwd())) 
[10:59:35.523]             setwd(...future.workdir)
[10:59:35.523]         {
[10:59:35.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.523]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.523]             }
[10:59:35.523]             base::options(...future.oldOptions)
[10:59:35.523]             if (.Platform$OS.type == "windows") {
[10:59:35.523]                 old_names <- names(...future.oldEnvVars)
[10:59:35.523]                 envs <- base::Sys.getenv()
[10:59:35.523]                 names <- names(envs)
[10:59:35.523]                 common <- intersect(names, old_names)
[10:59:35.523]                 added <- setdiff(names, old_names)
[10:59:35.523]                 removed <- setdiff(old_names, names)
[10:59:35.523]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.523]                   envs[common]]
[10:59:35.523]                 NAMES <- toupper(changed)
[10:59:35.523]                 args <- list()
[10:59:35.523]                 for (kk in seq_along(NAMES)) {
[10:59:35.523]                   name <- changed[[kk]]
[10:59:35.523]                   NAME <- NAMES[[kk]]
[10:59:35.523]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.523]                     next
[10:59:35.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.523]                 }
[10:59:35.523]                 NAMES <- toupper(added)
[10:59:35.523]                 for (kk in seq_along(NAMES)) {
[10:59:35.523]                   name <- added[[kk]]
[10:59:35.523]                   NAME <- NAMES[[kk]]
[10:59:35.523]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.523]                     next
[10:59:35.523]                   args[[name]] <- ""
[10:59:35.523]                 }
[10:59:35.523]                 NAMES <- toupper(removed)
[10:59:35.523]                 for (kk in seq_along(NAMES)) {
[10:59:35.523]                   name <- removed[[kk]]
[10:59:35.523]                   NAME <- NAMES[[kk]]
[10:59:35.523]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.523]                     next
[10:59:35.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.523]                 }
[10:59:35.523]                 if (length(args) > 0) 
[10:59:35.523]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.523]             }
[10:59:35.523]             else {
[10:59:35.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.523]             }
[10:59:35.523]             {
[10:59:35.523]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.523]                   0L) {
[10:59:35.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.523]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.523]                   base::options(opts)
[10:59:35.523]                 }
[10:59:35.523]                 {
[10:59:35.523]                   {
[10:59:35.523]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.523]                     NULL
[10:59:35.523]                   }
[10:59:35.523]                   options(future.plan = NULL)
[10:59:35.523]                   if (is.na(NA_character_)) 
[10:59:35.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.523]                     .init = FALSE)
[10:59:35.523]                 }
[10:59:35.523]             }
[10:59:35.523]         }
[10:59:35.523]     })
[10:59:35.523]     if (TRUE) {
[10:59:35.523]         base::sink(type = "output", split = FALSE)
[10:59:35.523]         if (TRUE) {
[10:59:35.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.523]         }
[10:59:35.523]         else {
[10:59:35.523]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.523]         }
[10:59:35.523]         base::close(...future.stdout)
[10:59:35.523]         ...future.stdout <- NULL
[10:59:35.523]     }
[10:59:35.523]     ...future.result$conditions <- ...future.conditions
[10:59:35.523]     ...future.result$finished <- base::Sys.time()
[10:59:35.523]     ...future.result
[10:59:35.523] }
[10:59:35.526] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:59:35.526] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:59:35.527] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:59:35.527] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:35.527] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.527] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[10:59:35.528] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[10:59:35.528] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.528] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.528] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.529] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.529] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:59:35.529] MultisessionFuture started
[10:59:35.529] - Launch lazy future ... done
[10:59:35.529] run() for ‘MultisessionFuture’ ... done
[10:59:35.530] Created future:
[10:59:35.530] MultisessionFuture:
[10:59:35.530] Label: ‘future_mapply-2’
[10:59:35.530] Expression:
[10:59:35.530] {
[10:59:35.530]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.530]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.530]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.530]         on.exit(options(oopts), add = TRUE)
[10:59:35.530]     }
[10:59:35.530]     {
[10:59:35.530]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.530]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.530]         do.call(mapply, args = args)
[10:59:35.530]     }
[10:59:35.530] }
[10:59:35.530] Lazy evaluation: FALSE
[10:59:35.530] Asynchronous evaluation: TRUE
[10:59:35.530] Local evaluation: TRUE
[10:59:35.530] Environment: R_GlobalEnv
[10:59:35.530] Capture standard output: TRUE
[10:59:35.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.530] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.530] Packages: <none>
[10:59:35.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.530] Resolved: FALSE
[10:59:35.530] Value: <not collected>
[10:59:35.530] Conditions captured: <none>
[10:59:35.530] Early signaling: FALSE
[10:59:35.530] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.530] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.541] Chunk #2 of 5 ... DONE
[10:59:35.541] Chunk #3 of 5 ...
[10:59:35.541]  - Finding globals in '...' for chunk #3 ...
[10:59:35.541] getGlobalsAndPackages() ...
[10:59:35.541] Searching for globals...
[10:59:35.542] 
[10:59:35.542] Searching for globals ... DONE
[10:59:35.542] - globals: [0] <none>
[10:59:35.542] getGlobalsAndPackages() ... DONE
[10:59:35.542]    + additional globals found: [n=0] 
[10:59:35.542]    + additional namespaces needed: [n=0] 
[10:59:35.542]  - Finding globals in '...' for chunk #3 ... DONE
[10:59:35.542]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:35.542]  - seeds: <none>
[10:59:35.542]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.543] getGlobalsAndPackages() ...
[10:59:35.543] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.543] Resolving globals: FALSE
[10:59:35.543] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:35.543] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.544] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.544] 
[10:59:35.544] getGlobalsAndPackages() ... DONE
[10:59:35.544] run() for ‘Future’ ...
[10:59:35.544] - state: ‘created’
[10:59:35.544] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.557] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.558]   - Field: ‘node’
[10:59:35.558]   - Field: ‘label’
[10:59:35.558]   - Field: ‘local’
[10:59:35.558]   - Field: ‘owner’
[10:59:35.558]   - Field: ‘envir’
[10:59:35.558]   - Field: ‘workers’
[10:59:35.558]   - Field: ‘packages’
[10:59:35.558]   - Field: ‘gc’
[10:59:35.558]   - Field: ‘conditions’
[10:59:35.558]   - Field: ‘persistent’
[10:59:35.559]   - Field: ‘expr’
[10:59:35.559]   - Field: ‘uuid’
[10:59:35.559]   - Field: ‘seed’
[10:59:35.559]   - Field: ‘version’
[10:59:35.559]   - Field: ‘result’
[10:59:35.559]   - Field: ‘asynchronous’
[10:59:35.559]   - Field: ‘calls’
[10:59:35.559]   - Field: ‘globals’
[10:59:35.559]   - Field: ‘stdout’
[10:59:35.559]   - Field: ‘earlySignal’
[10:59:35.559]   - Field: ‘lazy’
[10:59:35.559]   - Field: ‘state’
[10:59:35.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.560] - Launch lazy future ...
[10:59:35.560] Packages needed by the future expression (n = 0): <none>
[10:59:35.560] Packages needed by future strategies (n = 0): <none>
[10:59:35.560] {
[10:59:35.560]     {
[10:59:35.560]         {
[10:59:35.560]             ...future.startTime <- base::Sys.time()
[10:59:35.560]             {
[10:59:35.560]                 {
[10:59:35.560]                   {
[10:59:35.560]                     {
[10:59:35.560]                       base::local({
[10:59:35.560]                         has_future <- base::requireNamespace("future", 
[10:59:35.560]                           quietly = TRUE)
[10:59:35.560]                         if (has_future) {
[10:59:35.560]                           ns <- base::getNamespace("future")
[10:59:35.560]                           version <- ns[[".package"]][["version"]]
[10:59:35.560]                           if (is.null(version)) 
[10:59:35.560]                             version <- utils::packageVersion("future")
[10:59:35.560]                         }
[10:59:35.560]                         else {
[10:59:35.560]                           version <- NULL
[10:59:35.560]                         }
[10:59:35.560]                         if (!has_future || version < "1.8.0") {
[10:59:35.560]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.560]                             "", base::R.version$version.string), 
[10:59:35.560]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.560]                               "release", "version")], collapse = " "), 
[10:59:35.560]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.560]                             info)
[10:59:35.560]                           info <- base::paste(info, collapse = "; ")
[10:59:35.560]                           if (!has_future) {
[10:59:35.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.560]                               info)
[10:59:35.560]                           }
[10:59:35.560]                           else {
[10:59:35.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.560]                               info, version)
[10:59:35.560]                           }
[10:59:35.560]                           base::stop(msg)
[10:59:35.560]                         }
[10:59:35.560]                       })
[10:59:35.560]                     }
[10:59:35.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.560]                     base::options(mc.cores = 1L)
[10:59:35.560]                   }
[10:59:35.560]                   ...future.strategy.old <- future::plan("list")
[10:59:35.560]                   options(future.plan = NULL)
[10:59:35.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.560]                 }
[10:59:35.560]                 ...future.workdir <- getwd()
[10:59:35.560]             }
[10:59:35.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.560]         }
[10:59:35.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.560]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:35.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.560]             base::names(...future.oldOptions))
[10:59:35.560]     }
[10:59:35.560]     if (FALSE) {
[10:59:35.560]     }
[10:59:35.560]     else {
[10:59:35.560]         if (TRUE) {
[10:59:35.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.560]                 open = "w")
[10:59:35.560]         }
[10:59:35.560]         else {
[10:59:35.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.560]         }
[10:59:35.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.560]             base::sink(type = "output", split = FALSE)
[10:59:35.560]             base::close(...future.stdout)
[10:59:35.560]         }, add = TRUE)
[10:59:35.560]     }
[10:59:35.560]     ...future.frame <- base::sys.nframe()
[10:59:35.560]     ...future.conditions <- base::list()
[10:59:35.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.560]     if (FALSE) {
[10:59:35.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.560]     }
[10:59:35.560]     ...future.result <- base::tryCatch({
[10:59:35.560]         base::withCallingHandlers({
[10:59:35.560]             ...future.value <- base::withVisible(base::local({
[10:59:35.560]                 ...future.makeSendCondition <- base::local({
[10:59:35.560]                   sendCondition <- NULL
[10:59:35.560]                   function(frame = 1L) {
[10:59:35.560]                     if (is.function(sendCondition)) 
[10:59:35.560]                       return(sendCondition)
[10:59:35.560]                     ns <- getNamespace("parallel")
[10:59:35.560]                     if (exists("sendData", mode = "function", 
[10:59:35.560]                       envir = ns)) {
[10:59:35.560]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.560]                         envir = ns)
[10:59:35.560]                       envir <- sys.frame(frame)
[10:59:35.560]                       master <- NULL
[10:59:35.560]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.560]                         !identical(envir, emptyenv())) {
[10:59:35.560]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.560]                           inherits = FALSE)) {
[10:59:35.560]                           master <- get("master", mode = "list", 
[10:59:35.560]                             envir = envir, inherits = FALSE)
[10:59:35.560]                           if (inherits(master, c("SOCKnode", 
[10:59:35.560]                             "SOCK0node"))) {
[10:59:35.560]                             sendCondition <<- function(cond) {
[10:59:35.560]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.560]                                 success = TRUE)
[10:59:35.560]                               parallel_sendData(master, data)
[10:59:35.560]                             }
[10:59:35.560]                             return(sendCondition)
[10:59:35.560]                           }
[10:59:35.560]                         }
[10:59:35.560]                         frame <- frame + 1L
[10:59:35.560]                         envir <- sys.frame(frame)
[10:59:35.560]                       }
[10:59:35.560]                     }
[10:59:35.560]                     sendCondition <<- function(cond) NULL
[10:59:35.560]                   }
[10:59:35.560]                 })
[10:59:35.560]                 withCallingHandlers({
[10:59:35.560]                   {
[10:59:35.560]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.560]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.560]                       ...future.globals.maxSize)) {
[10:59:35.560]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.560]                       on.exit(options(oopts), add = TRUE)
[10:59:35.560]                     }
[10:59:35.560]                     {
[10:59:35.560]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.560]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.560]                         USE.NAMES = FALSE)
[10:59:35.560]                       do.call(mapply, args = args)
[10:59:35.560]                     }
[10:59:35.560]                   }
[10:59:35.560]                 }, immediateCondition = function(cond) {
[10:59:35.560]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.560]                   sendCondition(cond)
[10:59:35.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.560]                   {
[10:59:35.560]                     inherits <- base::inherits
[10:59:35.560]                     invokeRestart <- base::invokeRestart
[10:59:35.560]                     is.null <- base::is.null
[10:59:35.560]                     muffled <- FALSE
[10:59:35.560]                     if (inherits(cond, "message")) {
[10:59:35.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.560]                       if (muffled) 
[10:59:35.560]                         invokeRestart("muffleMessage")
[10:59:35.560]                     }
[10:59:35.560]                     else if (inherits(cond, "warning")) {
[10:59:35.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.560]                       if (muffled) 
[10:59:35.560]                         invokeRestart("muffleWarning")
[10:59:35.560]                     }
[10:59:35.560]                     else if (inherits(cond, "condition")) {
[10:59:35.560]                       if (!is.null(pattern)) {
[10:59:35.560]                         computeRestarts <- base::computeRestarts
[10:59:35.560]                         grepl <- base::grepl
[10:59:35.560]                         restarts <- computeRestarts(cond)
[10:59:35.560]                         for (restart in restarts) {
[10:59:35.560]                           name <- restart$name
[10:59:35.560]                           if (is.null(name)) 
[10:59:35.560]                             next
[10:59:35.560]                           if (!grepl(pattern, name)) 
[10:59:35.560]                             next
[10:59:35.560]                           invokeRestart(restart)
[10:59:35.560]                           muffled <- TRUE
[10:59:35.560]                           break
[10:59:35.560]                         }
[10:59:35.560]                       }
[10:59:35.560]                     }
[10:59:35.560]                     invisible(muffled)
[10:59:35.560]                   }
[10:59:35.560]                   muffleCondition(cond)
[10:59:35.560]                 })
[10:59:35.560]             }))
[10:59:35.560]             future::FutureResult(value = ...future.value$value, 
[10:59:35.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.560]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.560]                     ...future.globalenv.names))
[10:59:35.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.560]         }, condition = base::local({
[10:59:35.560]             c <- base::c
[10:59:35.560]             inherits <- base::inherits
[10:59:35.560]             invokeRestart <- base::invokeRestart
[10:59:35.560]             length <- base::length
[10:59:35.560]             list <- base::list
[10:59:35.560]             seq.int <- base::seq.int
[10:59:35.560]             signalCondition <- base::signalCondition
[10:59:35.560]             sys.calls <- base::sys.calls
[10:59:35.560]             `[[` <- base::`[[`
[10:59:35.560]             `+` <- base::`+`
[10:59:35.560]             `<<-` <- base::`<<-`
[10:59:35.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.560]                   3L)]
[10:59:35.560]             }
[10:59:35.560]             function(cond) {
[10:59:35.560]                 is_error <- inherits(cond, "error")
[10:59:35.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.560]                   NULL)
[10:59:35.560]                 if (is_error) {
[10:59:35.560]                   sessionInformation <- function() {
[10:59:35.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.560]                       search = base::search(), system = base::Sys.info())
[10:59:35.560]                   }
[10:59:35.560]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.560]                     cond$call), session = sessionInformation(), 
[10:59:35.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.560]                   signalCondition(cond)
[10:59:35.560]                 }
[10:59:35.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.560]                 "immediateCondition"))) {
[10:59:35.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.560]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.560]                   if (TRUE && !signal) {
[10:59:35.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.560]                     {
[10:59:35.560]                       inherits <- base::inherits
[10:59:35.560]                       invokeRestart <- base::invokeRestart
[10:59:35.560]                       is.null <- base::is.null
[10:59:35.560]                       muffled <- FALSE
[10:59:35.560]                       if (inherits(cond, "message")) {
[10:59:35.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.560]                         if (muffled) 
[10:59:35.560]                           invokeRestart("muffleMessage")
[10:59:35.560]                       }
[10:59:35.560]                       else if (inherits(cond, "warning")) {
[10:59:35.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.560]                         if (muffled) 
[10:59:35.560]                           invokeRestart("muffleWarning")
[10:59:35.560]                       }
[10:59:35.560]                       else if (inherits(cond, "condition")) {
[10:59:35.560]                         if (!is.null(pattern)) {
[10:59:35.560]                           computeRestarts <- base::computeRestarts
[10:59:35.560]                           grepl <- base::grepl
[10:59:35.560]                           restarts <- computeRestarts(cond)
[10:59:35.560]                           for (restart in restarts) {
[10:59:35.560]                             name <- restart$name
[10:59:35.560]                             if (is.null(name)) 
[10:59:35.560]                               next
[10:59:35.560]                             if (!grepl(pattern, name)) 
[10:59:35.560]                               next
[10:59:35.560]                             invokeRestart(restart)
[10:59:35.560]                             muffled <- TRUE
[10:59:35.560]                             break
[10:59:35.560]                           }
[10:59:35.560]                         }
[10:59:35.560]                       }
[10:59:35.560]                       invisible(muffled)
[10:59:35.560]                     }
[10:59:35.560]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.560]                   }
[10:59:35.560]                 }
[10:59:35.560]                 else {
[10:59:35.560]                   if (TRUE) {
[10:59:35.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.560]                     {
[10:59:35.560]                       inherits <- base::inherits
[10:59:35.560]                       invokeRestart <- base::invokeRestart
[10:59:35.560]                       is.null <- base::is.null
[10:59:35.560]                       muffled <- FALSE
[10:59:35.560]                       if (inherits(cond, "message")) {
[10:59:35.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.560]                         if (muffled) 
[10:59:35.560]                           invokeRestart("muffleMessage")
[10:59:35.560]                       }
[10:59:35.560]                       else if (inherits(cond, "warning")) {
[10:59:35.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.560]                         if (muffled) 
[10:59:35.560]                           invokeRestart("muffleWarning")
[10:59:35.560]                       }
[10:59:35.560]                       else if (inherits(cond, "condition")) {
[10:59:35.560]                         if (!is.null(pattern)) {
[10:59:35.560]                           computeRestarts <- base::computeRestarts
[10:59:35.560]                           grepl <- base::grepl
[10:59:35.560]                           restarts <- computeRestarts(cond)
[10:59:35.560]                           for (restart in restarts) {
[10:59:35.560]                             name <- restart$name
[10:59:35.560]                             if (is.null(name)) 
[10:59:35.560]                               next
[10:59:35.560]                             if (!grepl(pattern, name)) 
[10:59:35.560]                               next
[10:59:35.560]                             invokeRestart(restart)
[10:59:35.560]                             muffled <- TRUE
[10:59:35.560]                             break
[10:59:35.560]                           }
[10:59:35.560]                         }
[10:59:35.560]                       }
[10:59:35.560]                       invisible(muffled)
[10:59:35.560]                     }
[10:59:35.560]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.560]                   }
[10:59:35.560]                 }
[10:59:35.560]             }
[10:59:35.560]         }))
[10:59:35.560]     }, error = function(ex) {
[10:59:35.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.560]                 ...future.rng), started = ...future.startTime, 
[10:59:35.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.560]             version = "1.8"), class = "FutureResult")
[10:59:35.560]     }, finally = {
[10:59:35.560]         if (!identical(...future.workdir, getwd())) 
[10:59:35.560]             setwd(...future.workdir)
[10:59:35.560]         {
[10:59:35.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.560]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.560]             }
[10:59:35.560]             base::options(...future.oldOptions)
[10:59:35.560]             if (.Platform$OS.type == "windows") {
[10:59:35.560]                 old_names <- names(...future.oldEnvVars)
[10:59:35.560]                 envs <- base::Sys.getenv()
[10:59:35.560]                 names <- names(envs)
[10:59:35.560]                 common <- intersect(names, old_names)
[10:59:35.560]                 added <- setdiff(names, old_names)
[10:59:35.560]                 removed <- setdiff(old_names, names)
[10:59:35.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.560]                   envs[common]]
[10:59:35.560]                 NAMES <- toupper(changed)
[10:59:35.560]                 args <- list()
[10:59:35.560]                 for (kk in seq_along(NAMES)) {
[10:59:35.560]                   name <- changed[[kk]]
[10:59:35.560]                   NAME <- NAMES[[kk]]
[10:59:35.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.560]                     next
[10:59:35.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.560]                 }
[10:59:35.560]                 NAMES <- toupper(added)
[10:59:35.560]                 for (kk in seq_along(NAMES)) {
[10:59:35.560]                   name <- added[[kk]]
[10:59:35.560]                   NAME <- NAMES[[kk]]
[10:59:35.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.560]                     next
[10:59:35.560]                   args[[name]] <- ""
[10:59:35.560]                 }
[10:59:35.560]                 NAMES <- toupper(removed)
[10:59:35.560]                 for (kk in seq_along(NAMES)) {
[10:59:35.560]                   name <- removed[[kk]]
[10:59:35.560]                   NAME <- NAMES[[kk]]
[10:59:35.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.560]                     next
[10:59:35.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.560]                 }
[10:59:35.560]                 if (length(args) > 0) 
[10:59:35.560]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.560]             }
[10:59:35.560]             else {
[10:59:35.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.560]             }
[10:59:35.560]             {
[10:59:35.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.560]                   0L) {
[10:59:35.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.560]                   base::options(opts)
[10:59:35.560]                 }
[10:59:35.560]                 {
[10:59:35.560]                   {
[10:59:35.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.560]                     NULL
[10:59:35.560]                   }
[10:59:35.560]                   options(future.plan = NULL)
[10:59:35.560]                   if (is.na(NA_character_)) 
[10:59:35.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.560]                     .init = FALSE)
[10:59:35.560]                 }
[10:59:35.560]             }
[10:59:35.560]         }
[10:59:35.560]     })
[10:59:35.560]     if (TRUE) {
[10:59:35.560]         base::sink(type = "output", split = FALSE)
[10:59:35.560]         if (TRUE) {
[10:59:35.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.560]         }
[10:59:35.560]         else {
[10:59:35.560]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.560]         }
[10:59:35.560]         base::close(...future.stdout)
[10:59:35.560]         ...future.stdout <- NULL
[10:59:35.560]     }
[10:59:35.560]     ...future.result$conditions <- ...future.conditions
[10:59:35.560]     ...future.result$finished <- base::Sys.time()
[10:59:35.560]     ...future.result
[10:59:35.560] }
[10:59:35.562] Poll #1 (0): usedNodes() = 2, workers = 2
[10:59:35.573] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.573] - Validating connection of MultisessionFuture
[10:59:35.573] - received message: FutureResult
[10:59:35.573] - Received FutureResult
[10:59:35.574] - Erased future from FutureRegistry
[10:59:35.574] result() for ClusterFuture ...
[10:59:35.574] - result already collected: FutureResult
[10:59:35.574] result() for ClusterFuture ... done
[10:59:35.574] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.574] result() for ClusterFuture ...
[10:59:35.574] - result already collected: FutureResult
[10:59:35.574] result() for ClusterFuture ... done
[10:59:35.574] result() for ClusterFuture ...
[10:59:35.574] - result already collected: FutureResult
[10:59:35.574] result() for ClusterFuture ... done
[10:59:35.575] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:59:35.575] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:35.575] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:35.576] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:35.576] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.576] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[10:59:35.576] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[10:59:35.577] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.577] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.577] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.577] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.577] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:59:35.578] MultisessionFuture started
[10:59:35.578] - Launch lazy future ... done
[10:59:35.578] run() for ‘MultisessionFuture’ ... done
[10:59:35.578] Created future:
[10:59:35.578] MultisessionFuture:
[10:59:35.578] Label: ‘future_mapply-3’
[10:59:35.578] Expression:
[10:59:35.578] {
[10:59:35.578]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.578]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.578]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.578]         on.exit(options(oopts), add = TRUE)
[10:59:35.578]     }
[10:59:35.578]     {
[10:59:35.578]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.578]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.578]         do.call(mapply, args = args)
[10:59:35.578]     }
[10:59:35.578] }
[10:59:35.578] Lazy evaluation: FALSE
[10:59:35.578] Asynchronous evaluation: TRUE
[10:59:35.578] Local evaluation: TRUE
[10:59:35.578] Environment: R_GlobalEnv
[10:59:35.578] Capture standard output: TRUE
[10:59:35.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.578] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.578] Packages: <none>
[10:59:35.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.578] Resolved: FALSE
[10:59:35.578] Value: <not collected>
[10:59:35.578] Conditions captured: <none>
[10:59:35.578] Early signaling: FALSE
[10:59:35.578] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.578] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.589] Chunk #3 of 5 ... DONE
[10:59:35.590] Chunk #4 of 5 ...
[10:59:35.590]  - Finding globals in '...' for chunk #4 ...
[10:59:35.590] getGlobalsAndPackages() ...
[10:59:35.590] Searching for globals...
[10:59:35.590] 
[10:59:35.590] Searching for globals ... DONE
[10:59:35.591] - globals: [0] <none>
[10:59:35.591] getGlobalsAndPackages() ... DONE
[10:59:35.591]    + additional globals found: [n=0] 
[10:59:35.591]    + additional namespaces needed: [n=0] 
[10:59:35.591]  - Finding globals in '...' for chunk #4 ... DONE
[10:59:35.591]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:35.591]  - seeds: <none>
[10:59:35.591]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.591] getGlobalsAndPackages() ...
[10:59:35.591] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.591] Resolving globals: FALSE
[10:59:35.592] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:35.592] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.592] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.592] 
[10:59:35.592] getGlobalsAndPackages() ... DONE
[10:59:35.593] run() for ‘Future’ ...
[10:59:35.593] - state: ‘created’
[10:59:35.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.608] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.608]   - Field: ‘node’
[10:59:35.608]   - Field: ‘label’
[10:59:35.608]   - Field: ‘local’
[10:59:35.608]   - Field: ‘owner’
[10:59:35.608]   - Field: ‘envir’
[10:59:35.609]   - Field: ‘workers’
[10:59:35.609]   - Field: ‘packages’
[10:59:35.609]   - Field: ‘gc’
[10:59:35.609]   - Field: ‘conditions’
[10:59:35.609]   - Field: ‘persistent’
[10:59:35.609]   - Field: ‘expr’
[10:59:35.609]   - Field: ‘uuid’
[10:59:35.609]   - Field: ‘seed’
[10:59:35.609]   - Field: ‘version’
[10:59:35.609]   - Field: ‘result’
[10:59:35.609]   - Field: ‘asynchronous’
[10:59:35.609]   - Field: ‘calls’
[10:59:35.609]   - Field: ‘globals’
[10:59:35.610]   - Field: ‘stdout’
[10:59:35.610]   - Field: ‘earlySignal’
[10:59:35.610]   - Field: ‘lazy’
[10:59:35.610]   - Field: ‘state’
[10:59:35.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.610] - Launch lazy future ...
[10:59:35.610] Packages needed by the future expression (n = 0): <none>
[10:59:35.610] Packages needed by future strategies (n = 0): <none>
[10:59:35.611] {
[10:59:35.611]     {
[10:59:35.611]         {
[10:59:35.611]             ...future.startTime <- base::Sys.time()
[10:59:35.611]             {
[10:59:35.611]                 {
[10:59:35.611]                   {
[10:59:35.611]                     {
[10:59:35.611]                       base::local({
[10:59:35.611]                         has_future <- base::requireNamespace("future", 
[10:59:35.611]                           quietly = TRUE)
[10:59:35.611]                         if (has_future) {
[10:59:35.611]                           ns <- base::getNamespace("future")
[10:59:35.611]                           version <- ns[[".package"]][["version"]]
[10:59:35.611]                           if (is.null(version)) 
[10:59:35.611]                             version <- utils::packageVersion("future")
[10:59:35.611]                         }
[10:59:35.611]                         else {
[10:59:35.611]                           version <- NULL
[10:59:35.611]                         }
[10:59:35.611]                         if (!has_future || version < "1.8.0") {
[10:59:35.611]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.611]                             "", base::R.version$version.string), 
[10:59:35.611]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.611]                               "release", "version")], collapse = " "), 
[10:59:35.611]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.611]                             info)
[10:59:35.611]                           info <- base::paste(info, collapse = "; ")
[10:59:35.611]                           if (!has_future) {
[10:59:35.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.611]                               info)
[10:59:35.611]                           }
[10:59:35.611]                           else {
[10:59:35.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.611]                               info, version)
[10:59:35.611]                           }
[10:59:35.611]                           base::stop(msg)
[10:59:35.611]                         }
[10:59:35.611]                       })
[10:59:35.611]                     }
[10:59:35.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.611]                     base::options(mc.cores = 1L)
[10:59:35.611]                   }
[10:59:35.611]                   ...future.strategy.old <- future::plan("list")
[10:59:35.611]                   options(future.plan = NULL)
[10:59:35.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.611]                 }
[10:59:35.611]                 ...future.workdir <- getwd()
[10:59:35.611]             }
[10:59:35.611]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.611]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.611]         }
[10:59:35.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.611]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:35.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.611]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.611]             base::names(...future.oldOptions))
[10:59:35.611]     }
[10:59:35.611]     if (FALSE) {
[10:59:35.611]     }
[10:59:35.611]     else {
[10:59:35.611]         if (TRUE) {
[10:59:35.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.611]                 open = "w")
[10:59:35.611]         }
[10:59:35.611]         else {
[10:59:35.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.611]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.611]         }
[10:59:35.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.611]             base::sink(type = "output", split = FALSE)
[10:59:35.611]             base::close(...future.stdout)
[10:59:35.611]         }, add = TRUE)
[10:59:35.611]     }
[10:59:35.611]     ...future.frame <- base::sys.nframe()
[10:59:35.611]     ...future.conditions <- base::list()
[10:59:35.611]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.611]     if (FALSE) {
[10:59:35.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.611]     }
[10:59:35.611]     ...future.result <- base::tryCatch({
[10:59:35.611]         base::withCallingHandlers({
[10:59:35.611]             ...future.value <- base::withVisible(base::local({
[10:59:35.611]                 ...future.makeSendCondition <- base::local({
[10:59:35.611]                   sendCondition <- NULL
[10:59:35.611]                   function(frame = 1L) {
[10:59:35.611]                     if (is.function(sendCondition)) 
[10:59:35.611]                       return(sendCondition)
[10:59:35.611]                     ns <- getNamespace("parallel")
[10:59:35.611]                     if (exists("sendData", mode = "function", 
[10:59:35.611]                       envir = ns)) {
[10:59:35.611]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.611]                         envir = ns)
[10:59:35.611]                       envir <- sys.frame(frame)
[10:59:35.611]                       master <- NULL
[10:59:35.611]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.611]                         !identical(envir, emptyenv())) {
[10:59:35.611]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.611]                           inherits = FALSE)) {
[10:59:35.611]                           master <- get("master", mode = "list", 
[10:59:35.611]                             envir = envir, inherits = FALSE)
[10:59:35.611]                           if (inherits(master, c("SOCKnode", 
[10:59:35.611]                             "SOCK0node"))) {
[10:59:35.611]                             sendCondition <<- function(cond) {
[10:59:35.611]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.611]                                 success = TRUE)
[10:59:35.611]                               parallel_sendData(master, data)
[10:59:35.611]                             }
[10:59:35.611]                             return(sendCondition)
[10:59:35.611]                           }
[10:59:35.611]                         }
[10:59:35.611]                         frame <- frame + 1L
[10:59:35.611]                         envir <- sys.frame(frame)
[10:59:35.611]                       }
[10:59:35.611]                     }
[10:59:35.611]                     sendCondition <<- function(cond) NULL
[10:59:35.611]                   }
[10:59:35.611]                 })
[10:59:35.611]                 withCallingHandlers({
[10:59:35.611]                   {
[10:59:35.611]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.611]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.611]                       ...future.globals.maxSize)) {
[10:59:35.611]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.611]                       on.exit(options(oopts), add = TRUE)
[10:59:35.611]                     }
[10:59:35.611]                     {
[10:59:35.611]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.611]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.611]                         USE.NAMES = FALSE)
[10:59:35.611]                       do.call(mapply, args = args)
[10:59:35.611]                     }
[10:59:35.611]                   }
[10:59:35.611]                 }, immediateCondition = function(cond) {
[10:59:35.611]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.611]                   sendCondition(cond)
[10:59:35.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.611]                   {
[10:59:35.611]                     inherits <- base::inherits
[10:59:35.611]                     invokeRestart <- base::invokeRestart
[10:59:35.611]                     is.null <- base::is.null
[10:59:35.611]                     muffled <- FALSE
[10:59:35.611]                     if (inherits(cond, "message")) {
[10:59:35.611]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.611]                       if (muffled) 
[10:59:35.611]                         invokeRestart("muffleMessage")
[10:59:35.611]                     }
[10:59:35.611]                     else if (inherits(cond, "warning")) {
[10:59:35.611]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.611]                       if (muffled) 
[10:59:35.611]                         invokeRestart("muffleWarning")
[10:59:35.611]                     }
[10:59:35.611]                     else if (inherits(cond, "condition")) {
[10:59:35.611]                       if (!is.null(pattern)) {
[10:59:35.611]                         computeRestarts <- base::computeRestarts
[10:59:35.611]                         grepl <- base::grepl
[10:59:35.611]                         restarts <- computeRestarts(cond)
[10:59:35.611]                         for (restart in restarts) {
[10:59:35.611]                           name <- restart$name
[10:59:35.611]                           if (is.null(name)) 
[10:59:35.611]                             next
[10:59:35.611]                           if (!grepl(pattern, name)) 
[10:59:35.611]                             next
[10:59:35.611]                           invokeRestart(restart)
[10:59:35.611]                           muffled <- TRUE
[10:59:35.611]                           break
[10:59:35.611]                         }
[10:59:35.611]                       }
[10:59:35.611]                     }
[10:59:35.611]                     invisible(muffled)
[10:59:35.611]                   }
[10:59:35.611]                   muffleCondition(cond)
[10:59:35.611]                 })
[10:59:35.611]             }))
[10:59:35.611]             future::FutureResult(value = ...future.value$value, 
[10:59:35.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.611]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.611]                     ...future.globalenv.names))
[10:59:35.611]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.611]         }, condition = base::local({
[10:59:35.611]             c <- base::c
[10:59:35.611]             inherits <- base::inherits
[10:59:35.611]             invokeRestart <- base::invokeRestart
[10:59:35.611]             length <- base::length
[10:59:35.611]             list <- base::list
[10:59:35.611]             seq.int <- base::seq.int
[10:59:35.611]             signalCondition <- base::signalCondition
[10:59:35.611]             sys.calls <- base::sys.calls
[10:59:35.611]             `[[` <- base::`[[`
[10:59:35.611]             `+` <- base::`+`
[10:59:35.611]             `<<-` <- base::`<<-`
[10:59:35.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.611]                   3L)]
[10:59:35.611]             }
[10:59:35.611]             function(cond) {
[10:59:35.611]                 is_error <- inherits(cond, "error")
[10:59:35.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.611]                   NULL)
[10:59:35.611]                 if (is_error) {
[10:59:35.611]                   sessionInformation <- function() {
[10:59:35.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.611]                       search = base::search(), system = base::Sys.info())
[10:59:35.611]                   }
[10:59:35.611]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.611]                     cond$call), session = sessionInformation(), 
[10:59:35.611]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.611]                   signalCondition(cond)
[10:59:35.611]                 }
[10:59:35.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.611]                 "immediateCondition"))) {
[10:59:35.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.611]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.611]                   if (TRUE && !signal) {
[10:59:35.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.611]                     {
[10:59:35.611]                       inherits <- base::inherits
[10:59:35.611]                       invokeRestart <- base::invokeRestart
[10:59:35.611]                       is.null <- base::is.null
[10:59:35.611]                       muffled <- FALSE
[10:59:35.611]                       if (inherits(cond, "message")) {
[10:59:35.611]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.611]                         if (muffled) 
[10:59:35.611]                           invokeRestart("muffleMessage")
[10:59:35.611]                       }
[10:59:35.611]                       else if (inherits(cond, "warning")) {
[10:59:35.611]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.611]                         if (muffled) 
[10:59:35.611]                           invokeRestart("muffleWarning")
[10:59:35.611]                       }
[10:59:35.611]                       else if (inherits(cond, "condition")) {
[10:59:35.611]                         if (!is.null(pattern)) {
[10:59:35.611]                           computeRestarts <- base::computeRestarts
[10:59:35.611]                           grepl <- base::grepl
[10:59:35.611]                           restarts <- computeRestarts(cond)
[10:59:35.611]                           for (restart in restarts) {
[10:59:35.611]                             name <- restart$name
[10:59:35.611]                             if (is.null(name)) 
[10:59:35.611]                               next
[10:59:35.611]                             if (!grepl(pattern, name)) 
[10:59:35.611]                               next
[10:59:35.611]                             invokeRestart(restart)
[10:59:35.611]                             muffled <- TRUE
[10:59:35.611]                             break
[10:59:35.611]                           }
[10:59:35.611]                         }
[10:59:35.611]                       }
[10:59:35.611]                       invisible(muffled)
[10:59:35.611]                     }
[10:59:35.611]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.611]                   }
[10:59:35.611]                 }
[10:59:35.611]                 else {
[10:59:35.611]                   if (TRUE) {
[10:59:35.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.611]                     {
[10:59:35.611]                       inherits <- base::inherits
[10:59:35.611]                       invokeRestart <- base::invokeRestart
[10:59:35.611]                       is.null <- base::is.null
[10:59:35.611]                       muffled <- FALSE
[10:59:35.611]                       if (inherits(cond, "message")) {
[10:59:35.611]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.611]                         if (muffled) 
[10:59:35.611]                           invokeRestart("muffleMessage")
[10:59:35.611]                       }
[10:59:35.611]                       else if (inherits(cond, "warning")) {
[10:59:35.611]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.611]                         if (muffled) 
[10:59:35.611]                           invokeRestart("muffleWarning")
[10:59:35.611]                       }
[10:59:35.611]                       else if (inherits(cond, "condition")) {
[10:59:35.611]                         if (!is.null(pattern)) {
[10:59:35.611]                           computeRestarts <- base::computeRestarts
[10:59:35.611]                           grepl <- base::grepl
[10:59:35.611]                           restarts <- computeRestarts(cond)
[10:59:35.611]                           for (restart in restarts) {
[10:59:35.611]                             name <- restart$name
[10:59:35.611]                             if (is.null(name)) 
[10:59:35.611]                               next
[10:59:35.611]                             if (!grepl(pattern, name)) 
[10:59:35.611]                               next
[10:59:35.611]                             invokeRestart(restart)
[10:59:35.611]                             muffled <- TRUE
[10:59:35.611]                             break
[10:59:35.611]                           }
[10:59:35.611]                         }
[10:59:35.611]                       }
[10:59:35.611]                       invisible(muffled)
[10:59:35.611]                     }
[10:59:35.611]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.611]                   }
[10:59:35.611]                 }
[10:59:35.611]             }
[10:59:35.611]         }))
[10:59:35.611]     }, error = function(ex) {
[10:59:35.611]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.611]                 ...future.rng), started = ...future.startTime, 
[10:59:35.611]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.611]             version = "1.8"), class = "FutureResult")
[10:59:35.611]     }, finally = {
[10:59:35.611]         if (!identical(...future.workdir, getwd())) 
[10:59:35.611]             setwd(...future.workdir)
[10:59:35.611]         {
[10:59:35.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.611]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.611]             }
[10:59:35.611]             base::options(...future.oldOptions)
[10:59:35.611]             if (.Platform$OS.type == "windows") {
[10:59:35.611]                 old_names <- names(...future.oldEnvVars)
[10:59:35.611]                 envs <- base::Sys.getenv()
[10:59:35.611]                 names <- names(envs)
[10:59:35.611]                 common <- intersect(names, old_names)
[10:59:35.611]                 added <- setdiff(names, old_names)
[10:59:35.611]                 removed <- setdiff(old_names, names)
[10:59:35.611]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.611]                   envs[common]]
[10:59:35.611]                 NAMES <- toupper(changed)
[10:59:35.611]                 args <- list()
[10:59:35.611]                 for (kk in seq_along(NAMES)) {
[10:59:35.611]                   name <- changed[[kk]]
[10:59:35.611]                   NAME <- NAMES[[kk]]
[10:59:35.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.611]                     next
[10:59:35.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.611]                 }
[10:59:35.611]                 NAMES <- toupper(added)
[10:59:35.611]                 for (kk in seq_along(NAMES)) {
[10:59:35.611]                   name <- added[[kk]]
[10:59:35.611]                   NAME <- NAMES[[kk]]
[10:59:35.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.611]                     next
[10:59:35.611]                   args[[name]] <- ""
[10:59:35.611]                 }
[10:59:35.611]                 NAMES <- toupper(removed)
[10:59:35.611]                 for (kk in seq_along(NAMES)) {
[10:59:35.611]                   name <- removed[[kk]]
[10:59:35.611]                   NAME <- NAMES[[kk]]
[10:59:35.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.611]                     next
[10:59:35.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.611]                 }
[10:59:35.611]                 if (length(args) > 0) 
[10:59:35.611]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.611]             }
[10:59:35.611]             else {
[10:59:35.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.611]             }
[10:59:35.611]             {
[10:59:35.611]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.611]                   0L) {
[10:59:35.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.611]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.611]                   base::options(opts)
[10:59:35.611]                 }
[10:59:35.611]                 {
[10:59:35.611]                   {
[10:59:35.611]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.611]                     NULL
[10:59:35.611]                   }
[10:59:35.611]                   options(future.plan = NULL)
[10:59:35.611]                   if (is.na(NA_character_)) 
[10:59:35.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.611]                     .init = FALSE)
[10:59:35.611]                 }
[10:59:35.611]             }
[10:59:35.611]         }
[10:59:35.611]     })
[10:59:35.611]     if (TRUE) {
[10:59:35.611]         base::sink(type = "output", split = FALSE)
[10:59:35.611]         if (TRUE) {
[10:59:35.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.611]         }
[10:59:35.611]         else {
[10:59:35.611]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.611]         }
[10:59:35.611]         base::close(...future.stdout)
[10:59:35.611]         ...future.stdout <- NULL
[10:59:35.611]     }
[10:59:35.611]     ...future.result$conditions <- ...future.conditions
[10:59:35.611]     ...future.result$finished <- base::Sys.time()
[10:59:35.611]     ...future.result
[10:59:35.611] }
[10:59:35.613] Poll #1 (0): usedNodes() = 2, workers = 2
[10:59:35.624] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.624] - Validating connection of MultisessionFuture
[10:59:35.624] - received message: FutureResult
[10:59:35.624] - Received FutureResult
[10:59:35.624] - Erased future from FutureRegistry
[10:59:35.624] result() for ClusterFuture ...
[10:59:35.625] - result already collected: FutureResult
[10:59:35.625] result() for ClusterFuture ... done
[10:59:35.625] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.625] result() for ClusterFuture ...
[10:59:35.625] - result already collected: FutureResult
[10:59:35.625] result() for ClusterFuture ... done
[10:59:35.625] result() for ClusterFuture ...
[10:59:35.625] - result already collected: FutureResult
[10:59:35.625] result() for ClusterFuture ... done
[10:59:35.626] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:59:35.626] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:59:35.626] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:59:35.626] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:35.627] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.627] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[10:59:35.627] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[10:59:35.628] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.628] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.628] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.628] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.629] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:59:35.629] MultisessionFuture started
[10:59:35.629] - Launch lazy future ... done
[10:59:35.629] run() for ‘MultisessionFuture’ ... done
[10:59:35.629] Created future:
[10:59:35.629] MultisessionFuture:
[10:59:35.629] Label: ‘future_mapply-4’
[10:59:35.629] Expression:
[10:59:35.629] {
[10:59:35.629]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.629]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.629]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.629]         on.exit(options(oopts), add = TRUE)
[10:59:35.629]     }
[10:59:35.629]     {
[10:59:35.629]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.629]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.629]         do.call(mapply, args = args)
[10:59:35.629]     }
[10:59:35.629] }
[10:59:35.629] Lazy evaluation: FALSE
[10:59:35.629] Asynchronous evaluation: TRUE
[10:59:35.629] Local evaluation: TRUE
[10:59:35.629] Environment: R_GlobalEnv
[10:59:35.629] Capture standard output: TRUE
[10:59:35.629] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.629] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.629] Packages: <none>
[10:59:35.629] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.629] Resolved: FALSE
[10:59:35.629] Value: <not collected>
[10:59:35.629] Conditions captured: <none>
[10:59:35.629] Early signaling: FALSE
[10:59:35.629] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.629] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.641] Chunk #4 of 5 ... DONE
[10:59:35.641] Chunk #5 of 5 ...
[10:59:35.641]  - Finding globals in '...' for chunk #5 ...
[10:59:35.641] getGlobalsAndPackages() ...
[10:59:35.641] Searching for globals...
[10:59:35.642] 
[10:59:35.642] Searching for globals ... DONE
[10:59:35.642] - globals: [0] <none>
[10:59:35.642] getGlobalsAndPackages() ... DONE
[10:59:35.642]    + additional globals found: [n=0] 
[10:59:35.642]    + additional namespaces needed: [n=0] 
[10:59:35.642]  - Finding globals in '...' for chunk #5 ... DONE
[10:59:35.642]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:59:35.642]  - seeds: <none>
[10:59:35.642]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.642] getGlobalsAndPackages() ...
[10:59:35.643] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.643] Resolving globals: FALSE
[10:59:35.643] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:35.643] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.644] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.644] 
[10:59:35.644] getGlobalsAndPackages() ... DONE
[10:59:35.644] run() for ‘Future’ ...
[10:59:35.644] - state: ‘created’
[10:59:35.644] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.658] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.659]   - Field: ‘node’
[10:59:35.659]   - Field: ‘label’
[10:59:35.659]   - Field: ‘local’
[10:59:35.659]   - Field: ‘owner’
[10:59:35.659]   - Field: ‘envir’
[10:59:35.659]   - Field: ‘workers’
[10:59:35.659]   - Field: ‘packages’
[10:59:35.659]   - Field: ‘gc’
[10:59:35.659]   - Field: ‘conditions’
[10:59:35.659]   - Field: ‘persistent’
[10:59:35.660]   - Field: ‘expr’
[10:59:35.660]   - Field: ‘uuid’
[10:59:35.660]   - Field: ‘seed’
[10:59:35.660]   - Field: ‘version’
[10:59:35.660]   - Field: ‘result’
[10:59:35.660]   - Field: ‘asynchronous’
[10:59:35.660]   - Field: ‘calls’
[10:59:35.660]   - Field: ‘globals’
[10:59:35.660]   - Field: ‘stdout’
[10:59:35.660]   - Field: ‘earlySignal’
[10:59:35.662]   - Field: ‘lazy’
[10:59:35.662]   - Field: ‘state’
[10:59:35.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.662] - Launch lazy future ...
[10:59:35.663] Packages needed by the future expression (n = 0): <none>
[10:59:35.663] Packages needed by future strategies (n = 0): <none>
[10:59:35.663] {
[10:59:35.663]     {
[10:59:35.663]         {
[10:59:35.663]             ...future.startTime <- base::Sys.time()
[10:59:35.663]             {
[10:59:35.663]                 {
[10:59:35.663]                   {
[10:59:35.663]                     {
[10:59:35.663]                       base::local({
[10:59:35.663]                         has_future <- base::requireNamespace("future", 
[10:59:35.663]                           quietly = TRUE)
[10:59:35.663]                         if (has_future) {
[10:59:35.663]                           ns <- base::getNamespace("future")
[10:59:35.663]                           version <- ns[[".package"]][["version"]]
[10:59:35.663]                           if (is.null(version)) 
[10:59:35.663]                             version <- utils::packageVersion("future")
[10:59:35.663]                         }
[10:59:35.663]                         else {
[10:59:35.663]                           version <- NULL
[10:59:35.663]                         }
[10:59:35.663]                         if (!has_future || version < "1.8.0") {
[10:59:35.663]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.663]                             "", base::R.version$version.string), 
[10:59:35.663]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.663]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.663]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.663]                               "release", "version")], collapse = " "), 
[10:59:35.663]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.663]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.663]                             info)
[10:59:35.663]                           info <- base::paste(info, collapse = "; ")
[10:59:35.663]                           if (!has_future) {
[10:59:35.663]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.663]                               info)
[10:59:35.663]                           }
[10:59:35.663]                           else {
[10:59:35.663]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.663]                               info, version)
[10:59:35.663]                           }
[10:59:35.663]                           base::stop(msg)
[10:59:35.663]                         }
[10:59:35.663]                       })
[10:59:35.663]                     }
[10:59:35.663]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.663]                     base::options(mc.cores = 1L)
[10:59:35.663]                   }
[10:59:35.663]                   ...future.strategy.old <- future::plan("list")
[10:59:35.663]                   options(future.plan = NULL)
[10:59:35.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.663]                 }
[10:59:35.663]                 ...future.workdir <- getwd()
[10:59:35.663]             }
[10:59:35.663]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.663]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.663]         }
[10:59:35.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.663]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:59:35.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.663]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.663]             base::names(...future.oldOptions))
[10:59:35.663]     }
[10:59:35.663]     if (FALSE) {
[10:59:35.663]     }
[10:59:35.663]     else {
[10:59:35.663]         if (TRUE) {
[10:59:35.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.663]                 open = "w")
[10:59:35.663]         }
[10:59:35.663]         else {
[10:59:35.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.663]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.663]         }
[10:59:35.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.663]             base::sink(type = "output", split = FALSE)
[10:59:35.663]             base::close(...future.stdout)
[10:59:35.663]         }, add = TRUE)
[10:59:35.663]     }
[10:59:35.663]     ...future.frame <- base::sys.nframe()
[10:59:35.663]     ...future.conditions <- base::list()
[10:59:35.663]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.663]     if (FALSE) {
[10:59:35.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.663]     }
[10:59:35.663]     ...future.result <- base::tryCatch({
[10:59:35.663]         base::withCallingHandlers({
[10:59:35.663]             ...future.value <- base::withVisible(base::local({
[10:59:35.663]                 ...future.makeSendCondition <- base::local({
[10:59:35.663]                   sendCondition <- NULL
[10:59:35.663]                   function(frame = 1L) {
[10:59:35.663]                     if (is.function(sendCondition)) 
[10:59:35.663]                       return(sendCondition)
[10:59:35.663]                     ns <- getNamespace("parallel")
[10:59:35.663]                     if (exists("sendData", mode = "function", 
[10:59:35.663]                       envir = ns)) {
[10:59:35.663]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.663]                         envir = ns)
[10:59:35.663]                       envir <- sys.frame(frame)
[10:59:35.663]                       master <- NULL
[10:59:35.663]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.663]                         !identical(envir, emptyenv())) {
[10:59:35.663]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.663]                           inherits = FALSE)) {
[10:59:35.663]                           master <- get("master", mode = "list", 
[10:59:35.663]                             envir = envir, inherits = FALSE)
[10:59:35.663]                           if (inherits(master, c("SOCKnode", 
[10:59:35.663]                             "SOCK0node"))) {
[10:59:35.663]                             sendCondition <<- function(cond) {
[10:59:35.663]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.663]                                 success = TRUE)
[10:59:35.663]                               parallel_sendData(master, data)
[10:59:35.663]                             }
[10:59:35.663]                             return(sendCondition)
[10:59:35.663]                           }
[10:59:35.663]                         }
[10:59:35.663]                         frame <- frame + 1L
[10:59:35.663]                         envir <- sys.frame(frame)
[10:59:35.663]                       }
[10:59:35.663]                     }
[10:59:35.663]                     sendCondition <<- function(cond) NULL
[10:59:35.663]                   }
[10:59:35.663]                 })
[10:59:35.663]                 withCallingHandlers({
[10:59:35.663]                   {
[10:59:35.663]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.663]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.663]                       ...future.globals.maxSize)) {
[10:59:35.663]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.663]                       on.exit(options(oopts), add = TRUE)
[10:59:35.663]                     }
[10:59:35.663]                     {
[10:59:35.663]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.663]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.663]                         USE.NAMES = FALSE)
[10:59:35.663]                       do.call(mapply, args = args)
[10:59:35.663]                     }
[10:59:35.663]                   }
[10:59:35.663]                 }, immediateCondition = function(cond) {
[10:59:35.663]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.663]                   sendCondition(cond)
[10:59:35.663]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.663]                   {
[10:59:35.663]                     inherits <- base::inherits
[10:59:35.663]                     invokeRestart <- base::invokeRestart
[10:59:35.663]                     is.null <- base::is.null
[10:59:35.663]                     muffled <- FALSE
[10:59:35.663]                     if (inherits(cond, "message")) {
[10:59:35.663]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.663]                       if (muffled) 
[10:59:35.663]                         invokeRestart("muffleMessage")
[10:59:35.663]                     }
[10:59:35.663]                     else if (inherits(cond, "warning")) {
[10:59:35.663]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.663]                       if (muffled) 
[10:59:35.663]                         invokeRestart("muffleWarning")
[10:59:35.663]                     }
[10:59:35.663]                     else if (inherits(cond, "condition")) {
[10:59:35.663]                       if (!is.null(pattern)) {
[10:59:35.663]                         computeRestarts <- base::computeRestarts
[10:59:35.663]                         grepl <- base::grepl
[10:59:35.663]                         restarts <- computeRestarts(cond)
[10:59:35.663]                         for (restart in restarts) {
[10:59:35.663]                           name <- restart$name
[10:59:35.663]                           if (is.null(name)) 
[10:59:35.663]                             next
[10:59:35.663]                           if (!grepl(pattern, name)) 
[10:59:35.663]                             next
[10:59:35.663]                           invokeRestart(restart)
[10:59:35.663]                           muffled <- TRUE
[10:59:35.663]                           break
[10:59:35.663]                         }
[10:59:35.663]                       }
[10:59:35.663]                     }
[10:59:35.663]                     invisible(muffled)
[10:59:35.663]                   }
[10:59:35.663]                   muffleCondition(cond)
[10:59:35.663]                 })
[10:59:35.663]             }))
[10:59:35.663]             future::FutureResult(value = ...future.value$value, 
[10:59:35.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.663]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.663]                     ...future.globalenv.names))
[10:59:35.663]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.663]         }, condition = base::local({
[10:59:35.663]             c <- base::c
[10:59:35.663]             inherits <- base::inherits
[10:59:35.663]             invokeRestart <- base::invokeRestart
[10:59:35.663]             length <- base::length
[10:59:35.663]             list <- base::list
[10:59:35.663]             seq.int <- base::seq.int
[10:59:35.663]             signalCondition <- base::signalCondition
[10:59:35.663]             sys.calls <- base::sys.calls
[10:59:35.663]             `[[` <- base::`[[`
[10:59:35.663]             `+` <- base::`+`
[10:59:35.663]             `<<-` <- base::`<<-`
[10:59:35.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.663]                   3L)]
[10:59:35.663]             }
[10:59:35.663]             function(cond) {
[10:59:35.663]                 is_error <- inherits(cond, "error")
[10:59:35.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.663]                   NULL)
[10:59:35.663]                 if (is_error) {
[10:59:35.663]                   sessionInformation <- function() {
[10:59:35.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.663]                       search = base::search(), system = base::Sys.info())
[10:59:35.663]                   }
[10:59:35.663]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.663]                     cond$call), session = sessionInformation(), 
[10:59:35.663]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.663]                   signalCondition(cond)
[10:59:35.663]                 }
[10:59:35.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.663]                 "immediateCondition"))) {
[10:59:35.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.663]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.663]                   if (TRUE && !signal) {
[10:59:35.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.663]                     {
[10:59:35.663]                       inherits <- base::inherits
[10:59:35.663]                       invokeRestart <- base::invokeRestart
[10:59:35.663]                       is.null <- base::is.null
[10:59:35.663]                       muffled <- FALSE
[10:59:35.663]                       if (inherits(cond, "message")) {
[10:59:35.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.663]                         if (muffled) 
[10:59:35.663]                           invokeRestart("muffleMessage")
[10:59:35.663]                       }
[10:59:35.663]                       else if (inherits(cond, "warning")) {
[10:59:35.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.663]                         if (muffled) 
[10:59:35.663]                           invokeRestart("muffleWarning")
[10:59:35.663]                       }
[10:59:35.663]                       else if (inherits(cond, "condition")) {
[10:59:35.663]                         if (!is.null(pattern)) {
[10:59:35.663]                           computeRestarts <- base::computeRestarts
[10:59:35.663]                           grepl <- base::grepl
[10:59:35.663]                           restarts <- computeRestarts(cond)
[10:59:35.663]                           for (restart in restarts) {
[10:59:35.663]                             name <- restart$name
[10:59:35.663]                             if (is.null(name)) 
[10:59:35.663]                               next
[10:59:35.663]                             if (!grepl(pattern, name)) 
[10:59:35.663]                               next
[10:59:35.663]                             invokeRestart(restart)
[10:59:35.663]                             muffled <- TRUE
[10:59:35.663]                             break
[10:59:35.663]                           }
[10:59:35.663]                         }
[10:59:35.663]                       }
[10:59:35.663]                       invisible(muffled)
[10:59:35.663]                     }
[10:59:35.663]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.663]                   }
[10:59:35.663]                 }
[10:59:35.663]                 else {
[10:59:35.663]                   if (TRUE) {
[10:59:35.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.663]                     {
[10:59:35.663]                       inherits <- base::inherits
[10:59:35.663]                       invokeRestart <- base::invokeRestart
[10:59:35.663]                       is.null <- base::is.null
[10:59:35.663]                       muffled <- FALSE
[10:59:35.663]                       if (inherits(cond, "message")) {
[10:59:35.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.663]                         if (muffled) 
[10:59:35.663]                           invokeRestart("muffleMessage")
[10:59:35.663]                       }
[10:59:35.663]                       else if (inherits(cond, "warning")) {
[10:59:35.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.663]                         if (muffled) 
[10:59:35.663]                           invokeRestart("muffleWarning")
[10:59:35.663]                       }
[10:59:35.663]                       else if (inherits(cond, "condition")) {
[10:59:35.663]                         if (!is.null(pattern)) {
[10:59:35.663]                           computeRestarts <- base::computeRestarts
[10:59:35.663]                           grepl <- base::grepl
[10:59:35.663]                           restarts <- computeRestarts(cond)
[10:59:35.663]                           for (restart in restarts) {
[10:59:35.663]                             name <- restart$name
[10:59:35.663]                             if (is.null(name)) 
[10:59:35.663]                               next
[10:59:35.663]                             if (!grepl(pattern, name)) 
[10:59:35.663]                               next
[10:59:35.663]                             invokeRestart(restart)
[10:59:35.663]                             muffled <- TRUE
[10:59:35.663]                             break
[10:59:35.663]                           }
[10:59:35.663]                         }
[10:59:35.663]                       }
[10:59:35.663]                       invisible(muffled)
[10:59:35.663]                     }
[10:59:35.663]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.663]                   }
[10:59:35.663]                 }
[10:59:35.663]             }
[10:59:35.663]         }))
[10:59:35.663]     }, error = function(ex) {
[10:59:35.663]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.663]                 ...future.rng), started = ...future.startTime, 
[10:59:35.663]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.663]             version = "1.8"), class = "FutureResult")
[10:59:35.663]     }, finally = {
[10:59:35.663]         if (!identical(...future.workdir, getwd())) 
[10:59:35.663]             setwd(...future.workdir)
[10:59:35.663]         {
[10:59:35.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.663]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.663]             }
[10:59:35.663]             base::options(...future.oldOptions)
[10:59:35.663]             if (.Platform$OS.type == "windows") {
[10:59:35.663]                 old_names <- names(...future.oldEnvVars)
[10:59:35.663]                 envs <- base::Sys.getenv()
[10:59:35.663]                 names <- names(envs)
[10:59:35.663]                 common <- intersect(names, old_names)
[10:59:35.663]                 added <- setdiff(names, old_names)
[10:59:35.663]                 removed <- setdiff(old_names, names)
[10:59:35.663]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.663]                   envs[common]]
[10:59:35.663]                 NAMES <- toupper(changed)
[10:59:35.663]                 args <- list()
[10:59:35.663]                 for (kk in seq_along(NAMES)) {
[10:59:35.663]                   name <- changed[[kk]]
[10:59:35.663]                   NAME <- NAMES[[kk]]
[10:59:35.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.663]                     next
[10:59:35.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.663]                 }
[10:59:35.663]                 NAMES <- toupper(added)
[10:59:35.663]                 for (kk in seq_along(NAMES)) {
[10:59:35.663]                   name <- added[[kk]]
[10:59:35.663]                   NAME <- NAMES[[kk]]
[10:59:35.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.663]                     next
[10:59:35.663]                   args[[name]] <- ""
[10:59:35.663]                 }
[10:59:35.663]                 NAMES <- toupper(removed)
[10:59:35.663]                 for (kk in seq_along(NAMES)) {
[10:59:35.663]                   name <- removed[[kk]]
[10:59:35.663]                   NAME <- NAMES[[kk]]
[10:59:35.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.663]                     next
[10:59:35.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.663]                 }
[10:59:35.663]                 if (length(args) > 0) 
[10:59:35.663]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.663]             }
[10:59:35.663]             else {
[10:59:35.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.663]             }
[10:59:35.663]             {
[10:59:35.663]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.663]                   0L) {
[10:59:35.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.663]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.663]                   base::options(opts)
[10:59:35.663]                 }
[10:59:35.663]                 {
[10:59:35.663]                   {
[10:59:35.663]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.663]                     NULL
[10:59:35.663]                   }
[10:59:35.663]                   options(future.plan = NULL)
[10:59:35.663]                   if (is.na(NA_character_)) 
[10:59:35.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.663]                     .init = FALSE)
[10:59:35.663]                 }
[10:59:35.663]             }
[10:59:35.663]         }
[10:59:35.663]     })
[10:59:35.663]     if (TRUE) {
[10:59:35.663]         base::sink(type = "output", split = FALSE)
[10:59:35.663]         if (TRUE) {
[10:59:35.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.663]         }
[10:59:35.663]         else {
[10:59:35.663]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.663]         }
[10:59:35.663]         base::close(...future.stdout)
[10:59:35.663]         ...future.stdout <- NULL
[10:59:35.663]     }
[10:59:35.663]     ...future.result$conditions <- ...future.conditions
[10:59:35.663]     ...future.result$finished <- base::Sys.time()
[10:59:35.663]     ...future.result
[10:59:35.663] }
[10:59:35.665] Poll #1 (0): usedNodes() = 2, workers = 2
[10:59:35.676] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.676] - Validating connection of MultisessionFuture
[10:59:35.676] - received message: FutureResult
[10:59:35.676] - Received FutureResult
[10:59:35.677] - Erased future from FutureRegistry
[10:59:35.677] result() for ClusterFuture ...
[10:59:35.677] - result already collected: FutureResult
[10:59:35.677] result() for ClusterFuture ... done
[10:59:35.677] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.677] result() for ClusterFuture ...
[10:59:35.677] - result already collected: FutureResult
[10:59:35.677] result() for ClusterFuture ... done
[10:59:35.677] result() for ClusterFuture ...
[10:59:35.677] - result already collected: FutureResult
[10:59:35.677] result() for ClusterFuture ... done
[10:59:35.678] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:59:35.678] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:35.678] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:35.679] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:35.679] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.679] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[10:59:35.679] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[10:59:35.680] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.680] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.680] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.680] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.680] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:59:35.681] MultisessionFuture started
[10:59:35.681] - Launch lazy future ... done
[10:59:35.681] run() for ‘MultisessionFuture’ ... done
[10:59:35.681] Created future:
[10:59:35.681] MultisessionFuture:
[10:59:35.681] Label: ‘future_mapply-5’
[10:59:35.681] Expression:
[10:59:35.681] {
[10:59:35.681]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.681]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.681]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.681]         on.exit(options(oopts), add = TRUE)
[10:59:35.681]     }
[10:59:35.681]     {
[10:59:35.681]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.681]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.681]         do.call(mapply, args = args)
[10:59:35.681]     }
[10:59:35.681] }
[10:59:35.681] Lazy evaluation: FALSE
[10:59:35.681] Asynchronous evaluation: TRUE
[10:59:35.681] Local evaluation: TRUE
[10:59:35.681] Environment: R_GlobalEnv
[10:59:35.681] Capture standard output: TRUE
[10:59:35.681] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.681] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.681] Packages: <none>
[10:59:35.681] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.681] Resolved: FALSE
[10:59:35.681] Value: <not collected>
[10:59:35.681] Conditions captured: <none>
[10:59:35.681] Early signaling: FALSE
[10:59:35.681] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.681] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.692] Chunk #5 of 5 ... DONE
[10:59:35.692] Launching 5 futures (chunks) ... DONE
[10:59:35.693] Resolving 5 futures (chunks) ...
[10:59:35.693] resolve() on list ...
[10:59:35.693]  recursive: 0
[10:59:35.693]  length: 5
[10:59:35.693] 
[10:59:35.693] Future #1
[10:59:35.693] result() for ClusterFuture ...
[10:59:35.693] - result already collected: FutureResult
[10:59:35.694] result() for ClusterFuture ... done
[10:59:35.694] result() for ClusterFuture ...
[10:59:35.694] - result already collected: FutureResult
[10:59:35.694] result() for ClusterFuture ... done
[10:59:35.694] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:35.694] - nx: 5
[10:59:35.694] - relay: TRUE
[10:59:35.694] - stdout: TRUE
[10:59:35.694] - signal: TRUE
[10:59:35.694] - resignal: FALSE
[10:59:35.694] - force: TRUE
[10:59:35.694] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:59:35.695] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:59:35.695]  - until=1
[10:59:35.695]  - relaying element #1
[10:59:35.695] result() for ClusterFuture ...
[10:59:35.695] - result already collected: FutureResult
[10:59:35.695] result() for ClusterFuture ... done
[10:59:35.695] result() for ClusterFuture ...
[10:59:35.695] - result already collected: FutureResult
[10:59:35.695] result() for ClusterFuture ... done
[10:59:35.695] result() for ClusterFuture ...
[10:59:35.695] - result already collected: FutureResult
[10:59:35.695] result() for ClusterFuture ... done
[10:59:35.696] result() for ClusterFuture ...
[10:59:35.696] - result already collected: FutureResult
[10:59:35.696] result() for ClusterFuture ... done
[10:59:35.696] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:35.696] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:35.696] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:35.696]  length: 4 (resolved future 1)
[10:59:35.696] Future #2
[10:59:35.696] result() for ClusterFuture ...
[10:59:35.696] - result already collected: FutureResult
[10:59:35.696] result() for ClusterFuture ... done
[10:59:35.696] result() for ClusterFuture ...
[10:59:35.697] - result already collected: FutureResult
[10:59:35.697] result() for ClusterFuture ... done
[10:59:35.697] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:35.697] - nx: 5
[10:59:35.697] - relay: TRUE
[10:59:35.697] - stdout: TRUE
[10:59:35.697] - signal: TRUE
[10:59:35.697] - resignal: FALSE
[10:59:35.697] - force: TRUE
[10:59:35.697] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:35.697] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:59:35.697]  - until=2
[10:59:35.697]  - relaying element #2
[10:59:35.698] result() for ClusterFuture ...
[10:59:35.698] - result already collected: FutureResult
[10:59:35.698] result() for ClusterFuture ... done
[10:59:35.698] result() for ClusterFuture ...
[10:59:35.698] - result already collected: FutureResult
[10:59:35.698] result() for ClusterFuture ... done
[10:59:35.698] result() for ClusterFuture ...
[10:59:35.698] - result already collected: FutureResult
[10:59:35.698] result() for ClusterFuture ... done
[10:59:35.698] result() for ClusterFuture ...
[10:59:35.698] - result already collected: FutureResult
[10:59:35.698] result() for ClusterFuture ... done
[10:59:35.698] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:35.699] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:35.699] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:35.699]  length: 3 (resolved future 2)
[10:59:35.699] Future #3
[10:59:35.699] result() for ClusterFuture ...
[10:59:35.699] - result already collected: FutureResult
[10:59:35.699] result() for ClusterFuture ... done
[10:59:35.699] result() for ClusterFuture ...
[10:59:35.699] - result already collected: FutureResult
[10:59:35.699] result() for ClusterFuture ... done
[10:59:35.699] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:59:35.699] - nx: 5
[10:59:35.700] - relay: TRUE
[10:59:35.700] - stdout: TRUE
[10:59:35.700] - signal: TRUE
[10:59:35.700] - resignal: FALSE
[10:59:35.700] - force: TRUE
[10:59:35.700] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:35.700] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:59:35.700]  - until=3
[10:59:35.700]  - relaying element #3
[10:59:35.700] result() for ClusterFuture ...
[10:59:35.700] - result already collected: FutureResult
[10:59:35.700] result() for ClusterFuture ... done
[10:59:35.700] result() for ClusterFuture ...
[10:59:35.700] - result already collected: FutureResult
[10:59:35.701] result() for ClusterFuture ... done
[10:59:35.701] result() for ClusterFuture ...
[10:59:35.701] - result already collected: FutureResult
[10:59:35.701] result() for ClusterFuture ... done
[10:59:35.701] result() for ClusterFuture ...
[10:59:35.701] - result already collected: FutureResult
[10:59:35.701] result() for ClusterFuture ... done
[10:59:35.701] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:35.701] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:35.701] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:59:35.701]  length: 2 (resolved future 3)
[10:59:35.702] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.702] - Validating connection of MultisessionFuture
[10:59:35.702] - received message: FutureResult
[10:59:35.702] - Received FutureResult
[10:59:35.702] - Erased future from FutureRegistry
[10:59:35.702] result() for ClusterFuture ...
[10:59:35.702] - result already collected: FutureResult
[10:59:35.703] result() for ClusterFuture ... done
[10:59:35.703] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.703] Future #4
[10:59:35.703] result() for ClusterFuture ...
[10:59:35.703] - result already collected: FutureResult
[10:59:35.703] result() for ClusterFuture ... done
[10:59:35.703] result() for ClusterFuture ...
[10:59:35.703] - result already collected: FutureResult
[10:59:35.703] result() for ClusterFuture ... done
[10:59:35.703] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:59:35.703] - nx: 5
[10:59:35.704] - relay: TRUE
[10:59:35.704] - stdout: TRUE
[10:59:35.704] - signal: TRUE
[10:59:35.704] - resignal: FALSE
[10:59:35.704] - force: TRUE
[10:59:35.704] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:35.704] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:59:35.704]  - until=4
[10:59:35.704]  - relaying element #4
[10:59:35.704] result() for ClusterFuture ...
[10:59:35.704] - result already collected: FutureResult
[10:59:35.704] result() for ClusterFuture ... done
[10:59:35.704] result() for ClusterFuture ...
[10:59:35.705] - result already collected: FutureResult
[10:59:35.705] result() for ClusterFuture ... done
[10:59:35.705] result() for ClusterFuture ...
[10:59:35.705] - result already collected: FutureResult
[10:59:35.705] result() for ClusterFuture ... done
[10:59:35.705] result() for ClusterFuture ...
[10:59:35.705] - result already collected: FutureResult
[10:59:35.705] result() for ClusterFuture ... done
[10:59:35.705] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:35.705] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:35.705] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:59:35.705]  length: 1 (resolved future 4)
[10:59:35.726] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.727] - Validating connection of MultisessionFuture
[10:59:35.727] - received message: FutureResult
[10:59:35.727] - Received FutureResult
[10:59:35.727] - Erased future from FutureRegistry
[10:59:35.727] result() for ClusterFuture ...
[10:59:35.727] - result already collected: FutureResult
[10:59:35.727] result() for ClusterFuture ... done
[10:59:35.727] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.727] Future #5
[10:59:35.727] result() for ClusterFuture ...
[10:59:35.728] - result already collected: FutureResult
[10:59:35.728] result() for ClusterFuture ... done
[10:59:35.728] result() for ClusterFuture ...
[10:59:35.728] - result already collected: FutureResult
[10:59:35.728] result() for ClusterFuture ... done
[10:59:35.728] signalConditionsASAP(MultisessionFuture, pos=5) ...
[10:59:35.728] - nx: 5
[10:59:35.728] - relay: TRUE
[10:59:35.728] - stdout: TRUE
[10:59:35.728] - signal: TRUE
[10:59:35.728] - resignal: FALSE
[10:59:35.728] - force: TRUE
[10:59:35.728] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:35.729] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:59:35.729]  - until=5
[10:59:35.729]  - relaying element #5
[10:59:35.729] result() for ClusterFuture ...
[10:59:35.729] - result already collected: FutureResult
[10:59:35.729] result() for ClusterFuture ... done
[10:59:35.729] result() for ClusterFuture ...
[10:59:35.729] - result already collected: FutureResult
[10:59:35.729] result() for ClusterFuture ... done
[10:59:35.729] result() for ClusterFuture ...
[10:59:35.729] - result already collected: FutureResult
[10:59:35.729] result() for ClusterFuture ... done
[10:59:35.729] result() for ClusterFuture ...
[10:59:35.730] - result already collected: FutureResult
[10:59:35.730] result() for ClusterFuture ... done
[10:59:35.730] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:35.730] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:35.730] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[10:59:35.730]  length: 0 (resolved future 5)
[10:59:35.730] Relaying remaining futures
[10:59:35.730] signalConditionsASAP(NULL, pos=0) ...
[10:59:35.730] - nx: 5
[10:59:35.730] - relay: TRUE
[10:59:35.730] - stdout: TRUE
[10:59:35.730] - signal: TRUE
[10:59:35.730] - resignal: FALSE
[10:59:35.731] - force: TRUE
[10:59:35.731] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:35.731] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:59:35.731] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:35.731] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:59:35.731] signalConditionsASAP(NULL, pos=0) ... done
[10:59:35.731] resolve() on list ... DONE
[10:59:35.731] result() for ClusterFuture ...
[10:59:35.731] - result already collected: FutureResult
[10:59:35.731] result() for ClusterFuture ... done
[10:59:35.731] result() for ClusterFuture ...
[10:59:35.731] - result already collected: FutureResult
[10:59:35.732] result() for ClusterFuture ... done
[10:59:35.732] result() for ClusterFuture ...
[10:59:35.732] - result already collected: FutureResult
[10:59:35.732] result() for ClusterFuture ... done
[10:59:35.732] result() for ClusterFuture ...
[10:59:35.732] - result already collected: FutureResult
[10:59:35.732] result() for ClusterFuture ... done
[10:59:35.732] result() for ClusterFuture ...
[10:59:35.732] - result already collected: FutureResult
[10:59:35.732] result() for ClusterFuture ... done
[10:59:35.732] result() for ClusterFuture ...
[10:59:35.732] - result already collected: FutureResult
[10:59:35.732] result() for ClusterFuture ... done
[10:59:35.733] result() for ClusterFuture ...
[10:59:35.733] - result already collected: FutureResult
[10:59:35.733] result() for ClusterFuture ... done
[10:59:35.733] result() for ClusterFuture ...
[10:59:35.733] - result already collected: FutureResult
[10:59:35.733] result() for ClusterFuture ... done
[10:59:35.733] result() for ClusterFuture ...
[10:59:35.733] - result already collected: FutureResult
[10:59:35.733] result() for ClusterFuture ... done
[10:59:35.733] result() for ClusterFuture ...
[10:59:35.733] - result already collected: FutureResult
[10:59:35.733] result() for ClusterFuture ... done
[10:59:35.733]  - Number of value chunks collected: 5
[10:59:35.734] Resolving 5 futures (chunks) ... DONE
[10:59:35.734] Reducing values from 5 chunks ...
[10:59:35.734]  - Number of values collected after concatenation: 5
[10:59:35.734]  - Number of values expected: 5
[10:59:35.734] Reducing values from 5 chunks ... DONE
[10:59:35.734] future_mapply() ... DONE
[10:59:35.734] future_mapply() ...
[10:59:35.736] Number of chunks: 2
[10:59:35.736] getGlobalsAndPackagesXApply() ...
[10:59:35.736]  - future.globals: TRUE
[10:59:35.736] getGlobalsAndPackages() ...
[10:59:35.736] Searching for globals...
[10:59:35.737] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:35.737] Searching for globals ... DONE
[10:59:35.738] Resolving globals: FALSE
[10:59:35.738] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:35.738] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:35.738] - globals: [1] ‘FUN’
[10:59:35.738] 
[10:59:35.739] getGlobalsAndPackages() ... DONE
[10:59:35.739]  - globals found/used: [n=1] ‘FUN’
[10:59:35.739]  - needed namespaces: [n=0] 
[10:59:35.739] Finding globals ... DONE
[10:59:35.739] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:35.739] List of 2
[10:59:35.739]  $ ...future.FUN:function (C, k)  
[10:59:35.739]  $ MoreArgs     : list()
[10:59:35.739]  - attr(*, "where")=List of 2
[10:59:35.739]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:35.739]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:35.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:35.739]  - attr(*, "resolved")= logi FALSE
[10:59:35.739]  - attr(*, "total_size")= num NA
[10:59:35.741] Packages to be attached in all futures: [n=0] 
[10:59:35.741] getGlobalsAndPackagesXApply() ... DONE
[10:59:35.742] Number of futures (= number of chunks): 2
[10:59:35.742] Launching 2 futures (chunks) ...
[10:59:35.742] Chunk #1 of 2 ...
[10:59:35.742]  - Finding globals in '...' for chunk #1 ...
[10:59:35.742] getGlobalsAndPackages() ...
[10:59:35.742] Searching for globals...
[10:59:35.742] 
[10:59:35.742] Searching for globals ... DONE
[10:59:35.743] - globals: [0] <none>
[10:59:35.743] getGlobalsAndPackages() ... DONE
[10:59:35.743]    + additional globals found: [n=0] 
[10:59:35.743]    + additional namespaces needed: [n=0] 
[10:59:35.743]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:35.743]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.743]  - seeds: <none>
[10:59:35.743]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.743] getGlobalsAndPackages() ...
[10:59:35.743] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.743] Resolving globals: FALSE
[10:59:35.744] The total size of the 5 globals is 880 bytes (880 bytes)
[10:59:35.744] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:35.744] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.744] 
[10:59:35.744] getGlobalsAndPackages() ... DONE
[10:59:35.745] run() for ‘Future’ ...
[10:59:35.745] - state: ‘created’
[10:59:35.745] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.758] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.759]   - Field: ‘node’
[10:59:35.759]   - Field: ‘label’
[10:59:35.759]   - Field: ‘local’
[10:59:35.759]   - Field: ‘owner’
[10:59:35.759]   - Field: ‘envir’
[10:59:35.759]   - Field: ‘workers’
[10:59:35.759]   - Field: ‘packages’
[10:59:35.759]   - Field: ‘gc’
[10:59:35.759]   - Field: ‘conditions’
[10:59:35.759]   - Field: ‘persistent’
[10:59:35.759]   - Field: ‘expr’
[10:59:35.759]   - Field: ‘uuid’
[10:59:35.760]   - Field: ‘seed’
[10:59:35.760]   - Field: ‘version’
[10:59:35.760]   - Field: ‘result’
[10:59:35.760]   - Field: ‘asynchronous’
[10:59:35.760]   - Field: ‘calls’
[10:59:35.760]   - Field: ‘globals’
[10:59:35.760]   - Field: ‘stdout’
[10:59:35.760]   - Field: ‘earlySignal’
[10:59:35.760]   - Field: ‘lazy’
[10:59:35.760]   - Field: ‘state’
[10:59:35.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.760] - Launch lazy future ...
[10:59:35.761] Packages needed by the future expression (n = 0): <none>
[10:59:35.761] Packages needed by future strategies (n = 0): <none>
[10:59:35.761] {
[10:59:35.761]     {
[10:59:35.761]         {
[10:59:35.761]             ...future.startTime <- base::Sys.time()
[10:59:35.761]             {
[10:59:35.761]                 {
[10:59:35.761]                   {
[10:59:35.761]                     {
[10:59:35.761]                       base::local({
[10:59:35.761]                         has_future <- base::requireNamespace("future", 
[10:59:35.761]                           quietly = TRUE)
[10:59:35.761]                         if (has_future) {
[10:59:35.761]                           ns <- base::getNamespace("future")
[10:59:35.761]                           version <- ns[[".package"]][["version"]]
[10:59:35.761]                           if (is.null(version)) 
[10:59:35.761]                             version <- utils::packageVersion("future")
[10:59:35.761]                         }
[10:59:35.761]                         else {
[10:59:35.761]                           version <- NULL
[10:59:35.761]                         }
[10:59:35.761]                         if (!has_future || version < "1.8.0") {
[10:59:35.761]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.761]                             "", base::R.version$version.string), 
[10:59:35.761]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.761]                               "release", "version")], collapse = " "), 
[10:59:35.761]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.761]                             info)
[10:59:35.761]                           info <- base::paste(info, collapse = "; ")
[10:59:35.761]                           if (!has_future) {
[10:59:35.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.761]                               info)
[10:59:35.761]                           }
[10:59:35.761]                           else {
[10:59:35.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.761]                               info, version)
[10:59:35.761]                           }
[10:59:35.761]                           base::stop(msg)
[10:59:35.761]                         }
[10:59:35.761]                       })
[10:59:35.761]                     }
[10:59:35.761]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.761]                     base::options(mc.cores = 1L)
[10:59:35.761]                   }
[10:59:35.761]                   ...future.strategy.old <- future::plan("list")
[10:59:35.761]                   options(future.plan = NULL)
[10:59:35.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.761]                 }
[10:59:35.761]                 ...future.workdir <- getwd()
[10:59:35.761]             }
[10:59:35.761]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.761]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.761]         }
[10:59:35.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.761]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.761]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.761]             base::names(...future.oldOptions))
[10:59:35.761]     }
[10:59:35.761]     if (FALSE) {
[10:59:35.761]     }
[10:59:35.761]     else {
[10:59:35.761]         if (TRUE) {
[10:59:35.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.761]                 open = "w")
[10:59:35.761]         }
[10:59:35.761]         else {
[10:59:35.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.761]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.761]         }
[10:59:35.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.761]             base::sink(type = "output", split = FALSE)
[10:59:35.761]             base::close(...future.stdout)
[10:59:35.761]         }, add = TRUE)
[10:59:35.761]     }
[10:59:35.761]     ...future.frame <- base::sys.nframe()
[10:59:35.761]     ...future.conditions <- base::list()
[10:59:35.761]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.761]     if (FALSE) {
[10:59:35.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.761]     }
[10:59:35.761]     ...future.result <- base::tryCatch({
[10:59:35.761]         base::withCallingHandlers({
[10:59:35.761]             ...future.value <- base::withVisible(base::local({
[10:59:35.761]                 ...future.makeSendCondition <- base::local({
[10:59:35.761]                   sendCondition <- NULL
[10:59:35.761]                   function(frame = 1L) {
[10:59:35.761]                     if (is.function(sendCondition)) 
[10:59:35.761]                       return(sendCondition)
[10:59:35.761]                     ns <- getNamespace("parallel")
[10:59:35.761]                     if (exists("sendData", mode = "function", 
[10:59:35.761]                       envir = ns)) {
[10:59:35.761]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.761]                         envir = ns)
[10:59:35.761]                       envir <- sys.frame(frame)
[10:59:35.761]                       master <- NULL
[10:59:35.761]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.761]                         !identical(envir, emptyenv())) {
[10:59:35.761]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.761]                           inherits = FALSE)) {
[10:59:35.761]                           master <- get("master", mode = "list", 
[10:59:35.761]                             envir = envir, inherits = FALSE)
[10:59:35.761]                           if (inherits(master, c("SOCKnode", 
[10:59:35.761]                             "SOCK0node"))) {
[10:59:35.761]                             sendCondition <<- function(cond) {
[10:59:35.761]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.761]                                 success = TRUE)
[10:59:35.761]                               parallel_sendData(master, data)
[10:59:35.761]                             }
[10:59:35.761]                             return(sendCondition)
[10:59:35.761]                           }
[10:59:35.761]                         }
[10:59:35.761]                         frame <- frame + 1L
[10:59:35.761]                         envir <- sys.frame(frame)
[10:59:35.761]                       }
[10:59:35.761]                     }
[10:59:35.761]                     sendCondition <<- function(cond) NULL
[10:59:35.761]                   }
[10:59:35.761]                 })
[10:59:35.761]                 withCallingHandlers({
[10:59:35.761]                   {
[10:59:35.761]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.761]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.761]                       ...future.globals.maxSize)) {
[10:59:35.761]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.761]                       on.exit(options(oopts), add = TRUE)
[10:59:35.761]                     }
[10:59:35.761]                     {
[10:59:35.761]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.761]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.761]                         USE.NAMES = FALSE)
[10:59:35.761]                       do.call(mapply, args = args)
[10:59:35.761]                     }
[10:59:35.761]                   }
[10:59:35.761]                 }, immediateCondition = function(cond) {
[10:59:35.761]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.761]                   sendCondition(cond)
[10:59:35.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.761]                   {
[10:59:35.761]                     inherits <- base::inherits
[10:59:35.761]                     invokeRestart <- base::invokeRestart
[10:59:35.761]                     is.null <- base::is.null
[10:59:35.761]                     muffled <- FALSE
[10:59:35.761]                     if (inherits(cond, "message")) {
[10:59:35.761]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.761]                       if (muffled) 
[10:59:35.761]                         invokeRestart("muffleMessage")
[10:59:35.761]                     }
[10:59:35.761]                     else if (inherits(cond, "warning")) {
[10:59:35.761]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.761]                       if (muffled) 
[10:59:35.761]                         invokeRestart("muffleWarning")
[10:59:35.761]                     }
[10:59:35.761]                     else if (inherits(cond, "condition")) {
[10:59:35.761]                       if (!is.null(pattern)) {
[10:59:35.761]                         computeRestarts <- base::computeRestarts
[10:59:35.761]                         grepl <- base::grepl
[10:59:35.761]                         restarts <- computeRestarts(cond)
[10:59:35.761]                         for (restart in restarts) {
[10:59:35.761]                           name <- restart$name
[10:59:35.761]                           if (is.null(name)) 
[10:59:35.761]                             next
[10:59:35.761]                           if (!grepl(pattern, name)) 
[10:59:35.761]                             next
[10:59:35.761]                           invokeRestart(restart)
[10:59:35.761]                           muffled <- TRUE
[10:59:35.761]                           break
[10:59:35.761]                         }
[10:59:35.761]                       }
[10:59:35.761]                     }
[10:59:35.761]                     invisible(muffled)
[10:59:35.761]                   }
[10:59:35.761]                   muffleCondition(cond)
[10:59:35.761]                 })
[10:59:35.761]             }))
[10:59:35.761]             future::FutureResult(value = ...future.value$value, 
[10:59:35.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.761]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.761]                     ...future.globalenv.names))
[10:59:35.761]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.761]         }, condition = base::local({
[10:59:35.761]             c <- base::c
[10:59:35.761]             inherits <- base::inherits
[10:59:35.761]             invokeRestart <- base::invokeRestart
[10:59:35.761]             length <- base::length
[10:59:35.761]             list <- base::list
[10:59:35.761]             seq.int <- base::seq.int
[10:59:35.761]             signalCondition <- base::signalCondition
[10:59:35.761]             sys.calls <- base::sys.calls
[10:59:35.761]             `[[` <- base::`[[`
[10:59:35.761]             `+` <- base::`+`
[10:59:35.761]             `<<-` <- base::`<<-`
[10:59:35.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.761]                   3L)]
[10:59:35.761]             }
[10:59:35.761]             function(cond) {
[10:59:35.761]                 is_error <- inherits(cond, "error")
[10:59:35.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.761]                   NULL)
[10:59:35.761]                 if (is_error) {
[10:59:35.761]                   sessionInformation <- function() {
[10:59:35.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.761]                       search = base::search(), system = base::Sys.info())
[10:59:35.761]                   }
[10:59:35.761]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.761]                     cond$call), session = sessionInformation(), 
[10:59:35.761]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.761]                   signalCondition(cond)
[10:59:35.761]                 }
[10:59:35.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.761]                 "immediateCondition"))) {
[10:59:35.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.761]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.761]                   if (TRUE && !signal) {
[10:59:35.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.761]                     {
[10:59:35.761]                       inherits <- base::inherits
[10:59:35.761]                       invokeRestart <- base::invokeRestart
[10:59:35.761]                       is.null <- base::is.null
[10:59:35.761]                       muffled <- FALSE
[10:59:35.761]                       if (inherits(cond, "message")) {
[10:59:35.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.761]                         if (muffled) 
[10:59:35.761]                           invokeRestart("muffleMessage")
[10:59:35.761]                       }
[10:59:35.761]                       else if (inherits(cond, "warning")) {
[10:59:35.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.761]                         if (muffled) 
[10:59:35.761]                           invokeRestart("muffleWarning")
[10:59:35.761]                       }
[10:59:35.761]                       else if (inherits(cond, "condition")) {
[10:59:35.761]                         if (!is.null(pattern)) {
[10:59:35.761]                           computeRestarts <- base::computeRestarts
[10:59:35.761]                           grepl <- base::grepl
[10:59:35.761]                           restarts <- computeRestarts(cond)
[10:59:35.761]                           for (restart in restarts) {
[10:59:35.761]                             name <- restart$name
[10:59:35.761]                             if (is.null(name)) 
[10:59:35.761]                               next
[10:59:35.761]                             if (!grepl(pattern, name)) 
[10:59:35.761]                               next
[10:59:35.761]                             invokeRestart(restart)
[10:59:35.761]                             muffled <- TRUE
[10:59:35.761]                             break
[10:59:35.761]                           }
[10:59:35.761]                         }
[10:59:35.761]                       }
[10:59:35.761]                       invisible(muffled)
[10:59:35.761]                     }
[10:59:35.761]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.761]                   }
[10:59:35.761]                 }
[10:59:35.761]                 else {
[10:59:35.761]                   if (TRUE) {
[10:59:35.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.761]                     {
[10:59:35.761]                       inherits <- base::inherits
[10:59:35.761]                       invokeRestart <- base::invokeRestart
[10:59:35.761]                       is.null <- base::is.null
[10:59:35.761]                       muffled <- FALSE
[10:59:35.761]                       if (inherits(cond, "message")) {
[10:59:35.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.761]                         if (muffled) 
[10:59:35.761]                           invokeRestart("muffleMessage")
[10:59:35.761]                       }
[10:59:35.761]                       else if (inherits(cond, "warning")) {
[10:59:35.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.761]                         if (muffled) 
[10:59:35.761]                           invokeRestart("muffleWarning")
[10:59:35.761]                       }
[10:59:35.761]                       else if (inherits(cond, "condition")) {
[10:59:35.761]                         if (!is.null(pattern)) {
[10:59:35.761]                           computeRestarts <- base::computeRestarts
[10:59:35.761]                           grepl <- base::grepl
[10:59:35.761]                           restarts <- computeRestarts(cond)
[10:59:35.761]                           for (restart in restarts) {
[10:59:35.761]                             name <- restart$name
[10:59:35.761]                             if (is.null(name)) 
[10:59:35.761]                               next
[10:59:35.761]                             if (!grepl(pattern, name)) 
[10:59:35.761]                               next
[10:59:35.761]                             invokeRestart(restart)
[10:59:35.761]                             muffled <- TRUE
[10:59:35.761]                             break
[10:59:35.761]                           }
[10:59:35.761]                         }
[10:59:35.761]                       }
[10:59:35.761]                       invisible(muffled)
[10:59:35.761]                     }
[10:59:35.761]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.761]                   }
[10:59:35.761]                 }
[10:59:35.761]             }
[10:59:35.761]         }))
[10:59:35.761]     }, error = function(ex) {
[10:59:35.761]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.761]                 ...future.rng), started = ...future.startTime, 
[10:59:35.761]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.761]             version = "1.8"), class = "FutureResult")
[10:59:35.761]     }, finally = {
[10:59:35.761]         if (!identical(...future.workdir, getwd())) 
[10:59:35.761]             setwd(...future.workdir)
[10:59:35.761]         {
[10:59:35.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.761]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.761]             }
[10:59:35.761]             base::options(...future.oldOptions)
[10:59:35.761]             if (.Platform$OS.type == "windows") {
[10:59:35.761]                 old_names <- names(...future.oldEnvVars)
[10:59:35.761]                 envs <- base::Sys.getenv()
[10:59:35.761]                 names <- names(envs)
[10:59:35.761]                 common <- intersect(names, old_names)
[10:59:35.761]                 added <- setdiff(names, old_names)
[10:59:35.761]                 removed <- setdiff(old_names, names)
[10:59:35.761]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.761]                   envs[common]]
[10:59:35.761]                 NAMES <- toupper(changed)
[10:59:35.761]                 args <- list()
[10:59:35.761]                 for (kk in seq_along(NAMES)) {
[10:59:35.761]                   name <- changed[[kk]]
[10:59:35.761]                   NAME <- NAMES[[kk]]
[10:59:35.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.761]                     next
[10:59:35.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.761]                 }
[10:59:35.761]                 NAMES <- toupper(added)
[10:59:35.761]                 for (kk in seq_along(NAMES)) {
[10:59:35.761]                   name <- added[[kk]]
[10:59:35.761]                   NAME <- NAMES[[kk]]
[10:59:35.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.761]                     next
[10:59:35.761]                   args[[name]] <- ""
[10:59:35.761]                 }
[10:59:35.761]                 NAMES <- toupper(removed)
[10:59:35.761]                 for (kk in seq_along(NAMES)) {
[10:59:35.761]                   name <- removed[[kk]]
[10:59:35.761]                   NAME <- NAMES[[kk]]
[10:59:35.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.761]                     next
[10:59:35.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.761]                 }
[10:59:35.761]                 if (length(args) > 0) 
[10:59:35.761]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.761]             }
[10:59:35.761]             else {
[10:59:35.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.761]             }
[10:59:35.761]             {
[10:59:35.761]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.761]                   0L) {
[10:59:35.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.761]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.761]                   base::options(opts)
[10:59:35.761]                 }
[10:59:35.761]                 {
[10:59:35.761]                   {
[10:59:35.761]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.761]                     NULL
[10:59:35.761]                   }
[10:59:35.761]                   options(future.plan = NULL)
[10:59:35.761]                   if (is.na(NA_character_)) 
[10:59:35.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.761]                     .init = FALSE)
[10:59:35.761]                 }
[10:59:35.761]             }
[10:59:35.761]         }
[10:59:35.761]     })
[10:59:35.761]     if (TRUE) {
[10:59:35.761]         base::sink(type = "output", split = FALSE)
[10:59:35.761]         if (TRUE) {
[10:59:35.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.761]         }
[10:59:35.761]         else {
[10:59:35.761]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.761]         }
[10:59:35.761]         base::close(...future.stdout)
[10:59:35.761]         ...future.stdout <- NULL
[10:59:35.761]     }
[10:59:35.761]     ...future.result$conditions <- ...future.conditions
[10:59:35.761]     ...future.result$finished <- base::Sys.time()
[10:59:35.761]     ...future.result
[10:59:35.761] }
[10:59:35.764] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[10:59:35.764] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:35.764] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:35.764] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:59:35.765] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:59:35.765] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:59:35.765] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:59:35.765] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.766] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.766] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.766] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.766] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[10:59:35.767] MultisessionFuture started
[10:59:35.767] - Launch lazy future ... done
[10:59:35.767] run() for ‘MultisessionFuture’ ... done
[10:59:35.767] Created future:
[10:59:35.767] MultisessionFuture:
[10:59:35.767] Label: ‘future_.mapply-1’
[10:59:35.767] Expression:
[10:59:35.767] {
[10:59:35.767]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.767]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.767]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.767]         on.exit(options(oopts), add = TRUE)
[10:59:35.767]     }
[10:59:35.767]     {
[10:59:35.767]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.767]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.767]         do.call(mapply, args = args)
[10:59:35.767]     }
[10:59:35.767] }
[10:59:35.767] Lazy evaluation: FALSE
[10:59:35.767] Asynchronous evaluation: TRUE
[10:59:35.767] Local evaluation: TRUE
[10:59:35.767] Environment: R_GlobalEnv
[10:59:35.767] Capture standard output: TRUE
[10:59:35.767] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.767] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.767] Packages: <none>
[10:59:35.767] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.767] Resolved: FALSE
[10:59:35.767] Value: <not collected>
[10:59:35.767] Conditions captured: <none>
[10:59:35.767] Early signaling: FALSE
[10:59:35.767] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.767] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.778] Chunk #1 of 2 ... DONE
[10:59:35.779] Chunk #2 of 2 ...
[10:59:35.779]  - Finding globals in '...' for chunk #2 ...
[10:59:35.779] getGlobalsAndPackages() ...
[10:59:35.779] Searching for globals...
[10:59:35.779] 
[10:59:35.779] Searching for globals ... DONE
[10:59:35.779] - globals: [0] <none>
[10:59:35.779] getGlobalsAndPackages() ... DONE
[10:59:35.779]    + additional globals found: [n=0] 
[10:59:35.780]    + additional namespaces needed: [n=0] 
[10:59:35.780]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:35.780]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:35.780]  - seeds: <none>
[10:59:35.780]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.780] getGlobalsAndPackages() ...
[10:59:35.780] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.780] Resolving globals: FALSE
[10:59:35.781] The total size of the 5 globals is 909 bytes (909 bytes)
[10:59:35.781] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:35.781] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.781] 
[10:59:35.781] getGlobalsAndPackages() ... DONE
[10:59:35.781] run() for ‘Future’ ...
[10:59:35.782] - state: ‘created’
[10:59:35.782] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.795] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.795]   - Field: ‘node’
[10:59:35.795]   - Field: ‘label’
[10:59:35.795]   - Field: ‘local’
[10:59:35.795]   - Field: ‘owner’
[10:59:35.796]   - Field: ‘envir’
[10:59:35.796]   - Field: ‘workers’
[10:59:35.796]   - Field: ‘packages’
[10:59:35.796]   - Field: ‘gc’
[10:59:35.796]   - Field: ‘conditions’
[10:59:35.796]   - Field: ‘persistent’
[10:59:35.796]   - Field: ‘expr’
[10:59:35.796]   - Field: ‘uuid’
[10:59:35.796]   - Field: ‘seed’
[10:59:35.796]   - Field: ‘version’
[10:59:35.796]   - Field: ‘result’
[10:59:35.796]   - Field: ‘asynchronous’
[10:59:35.797]   - Field: ‘calls’
[10:59:35.797]   - Field: ‘globals’
[10:59:35.797]   - Field: ‘stdout’
[10:59:35.797]   - Field: ‘earlySignal’
[10:59:35.797]   - Field: ‘lazy’
[10:59:35.797]   - Field: ‘state’
[10:59:35.797] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.797] - Launch lazy future ...
[10:59:35.797] Packages needed by the future expression (n = 0): <none>
[10:59:35.797] Packages needed by future strategies (n = 0): <none>
[10:59:35.798] {
[10:59:35.798]     {
[10:59:35.798]         {
[10:59:35.798]             ...future.startTime <- base::Sys.time()
[10:59:35.798]             {
[10:59:35.798]                 {
[10:59:35.798]                   {
[10:59:35.798]                     {
[10:59:35.798]                       base::local({
[10:59:35.798]                         has_future <- base::requireNamespace("future", 
[10:59:35.798]                           quietly = TRUE)
[10:59:35.798]                         if (has_future) {
[10:59:35.798]                           ns <- base::getNamespace("future")
[10:59:35.798]                           version <- ns[[".package"]][["version"]]
[10:59:35.798]                           if (is.null(version)) 
[10:59:35.798]                             version <- utils::packageVersion("future")
[10:59:35.798]                         }
[10:59:35.798]                         else {
[10:59:35.798]                           version <- NULL
[10:59:35.798]                         }
[10:59:35.798]                         if (!has_future || version < "1.8.0") {
[10:59:35.798]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.798]                             "", base::R.version$version.string), 
[10:59:35.798]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.798]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.798]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.798]                               "release", "version")], collapse = " "), 
[10:59:35.798]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.798]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.798]                             info)
[10:59:35.798]                           info <- base::paste(info, collapse = "; ")
[10:59:35.798]                           if (!has_future) {
[10:59:35.798]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.798]                               info)
[10:59:35.798]                           }
[10:59:35.798]                           else {
[10:59:35.798]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.798]                               info, version)
[10:59:35.798]                           }
[10:59:35.798]                           base::stop(msg)
[10:59:35.798]                         }
[10:59:35.798]                       })
[10:59:35.798]                     }
[10:59:35.798]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.798]                     base::options(mc.cores = 1L)
[10:59:35.798]                   }
[10:59:35.798]                   ...future.strategy.old <- future::plan("list")
[10:59:35.798]                   options(future.plan = NULL)
[10:59:35.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.798]                 }
[10:59:35.798]                 ...future.workdir <- getwd()
[10:59:35.798]             }
[10:59:35.798]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.798]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.798]         }
[10:59:35.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.798]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:35.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.798]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.798]             base::names(...future.oldOptions))
[10:59:35.798]     }
[10:59:35.798]     if (FALSE) {
[10:59:35.798]     }
[10:59:35.798]     else {
[10:59:35.798]         if (TRUE) {
[10:59:35.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.798]                 open = "w")
[10:59:35.798]         }
[10:59:35.798]         else {
[10:59:35.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.798]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.798]         }
[10:59:35.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.798]             base::sink(type = "output", split = FALSE)
[10:59:35.798]             base::close(...future.stdout)
[10:59:35.798]         }, add = TRUE)
[10:59:35.798]     }
[10:59:35.798]     ...future.frame <- base::sys.nframe()
[10:59:35.798]     ...future.conditions <- base::list()
[10:59:35.798]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.798]     if (FALSE) {
[10:59:35.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.798]     }
[10:59:35.798]     ...future.result <- base::tryCatch({
[10:59:35.798]         base::withCallingHandlers({
[10:59:35.798]             ...future.value <- base::withVisible(base::local({
[10:59:35.798]                 ...future.makeSendCondition <- base::local({
[10:59:35.798]                   sendCondition <- NULL
[10:59:35.798]                   function(frame = 1L) {
[10:59:35.798]                     if (is.function(sendCondition)) 
[10:59:35.798]                       return(sendCondition)
[10:59:35.798]                     ns <- getNamespace("parallel")
[10:59:35.798]                     if (exists("sendData", mode = "function", 
[10:59:35.798]                       envir = ns)) {
[10:59:35.798]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.798]                         envir = ns)
[10:59:35.798]                       envir <- sys.frame(frame)
[10:59:35.798]                       master <- NULL
[10:59:35.798]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.798]                         !identical(envir, emptyenv())) {
[10:59:35.798]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.798]                           inherits = FALSE)) {
[10:59:35.798]                           master <- get("master", mode = "list", 
[10:59:35.798]                             envir = envir, inherits = FALSE)
[10:59:35.798]                           if (inherits(master, c("SOCKnode", 
[10:59:35.798]                             "SOCK0node"))) {
[10:59:35.798]                             sendCondition <<- function(cond) {
[10:59:35.798]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.798]                                 success = TRUE)
[10:59:35.798]                               parallel_sendData(master, data)
[10:59:35.798]                             }
[10:59:35.798]                             return(sendCondition)
[10:59:35.798]                           }
[10:59:35.798]                         }
[10:59:35.798]                         frame <- frame + 1L
[10:59:35.798]                         envir <- sys.frame(frame)
[10:59:35.798]                       }
[10:59:35.798]                     }
[10:59:35.798]                     sendCondition <<- function(cond) NULL
[10:59:35.798]                   }
[10:59:35.798]                 })
[10:59:35.798]                 withCallingHandlers({
[10:59:35.798]                   {
[10:59:35.798]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.798]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.798]                       ...future.globals.maxSize)) {
[10:59:35.798]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.798]                       on.exit(options(oopts), add = TRUE)
[10:59:35.798]                     }
[10:59:35.798]                     {
[10:59:35.798]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.798]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.798]                         USE.NAMES = FALSE)
[10:59:35.798]                       do.call(mapply, args = args)
[10:59:35.798]                     }
[10:59:35.798]                   }
[10:59:35.798]                 }, immediateCondition = function(cond) {
[10:59:35.798]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.798]                   sendCondition(cond)
[10:59:35.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.798]                   {
[10:59:35.798]                     inherits <- base::inherits
[10:59:35.798]                     invokeRestart <- base::invokeRestart
[10:59:35.798]                     is.null <- base::is.null
[10:59:35.798]                     muffled <- FALSE
[10:59:35.798]                     if (inherits(cond, "message")) {
[10:59:35.798]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.798]                       if (muffled) 
[10:59:35.798]                         invokeRestart("muffleMessage")
[10:59:35.798]                     }
[10:59:35.798]                     else if (inherits(cond, "warning")) {
[10:59:35.798]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.798]                       if (muffled) 
[10:59:35.798]                         invokeRestart("muffleWarning")
[10:59:35.798]                     }
[10:59:35.798]                     else if (inherits(cond, "condition")) {
[10:59:35.798]                       if (!is.null(pattern)) {
[10:59:35.798]                         computeRestarts <- base::computeRestarts
[10:59:35.798]                         grepl <- base::grepl
[10:59:35.798]                         restarts <- computeRestarts(cond)
[10:59:35.798]                         for (restart in restarts) {
[10:59:35.798]                           name <- restart$name
[10:59:35.798]                           if (is.null(name)) 
[10:59:35.798]                             next
[10:59:35.798]                           if (!grepl(pattern, name)) 
[10:59:35.798]                             next
[10:59:35.798]                           invokeRestart(restart)
[10:59:35.798]                           muffled <- TRUE
[10:59:35.798]                           break
[10:59:35.798]                         }
[10:59:35.798]                       }
[10:59:35.798]                     }
[10:59:35.798]                     invisible(muffled)
[10:59:35.798]                   }
[10:59:35.798]                   muffleCondition(cond)
[10:59:35.798]                 })
[10:59:35.798]             }))
[10:59:35.798]             future::FutureResult(value = ...future.value$value, 
[10:59:35.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.798]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.798]                     ...future.globalenv.names))
[10:59:35.798]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.798]         }, condition = base::local({
[10:59:35.798]             c <- base::c
[10:59:35.798]             inherits <- base::inherits
[10:59:35.798]             invokeRestart <- base::invokeRestart
[10:59:35.798]             length <- base::length
[10:59:35.798]             list <- base::list
[10:59:35.798]             seq.int <- base::seq.int
[10:59:35.798]             signalCondition <- base::signalCondition
[10:59:35.798]             sys.calls <- base::sys.calls
[10:59:35.798]             `[[` <- base::`[[`
[10:59:35.798]             `+` <- base::`+`
[10:59:35.798]             `<<-` <- base::`<<-`
[10:59:35.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.798]                   3L)]
[10:59:35.798]             }
[10:59:35.798]             function(cond) {
[10:59:35.798]                 is_error <- inherits(cond, "error")
[10:59:35.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.798]                   NULL)
[10:59:35.798]                 if (is_error) {
[10:59:35.798]                   sessionInformation <- function() {
[10:59:35.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.798]                       search = base::search(), system = base::Sys.info())
[10:59:35.798]                   }
[10:59:35.798]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.798]                     cond$call), session = sessionInformation(), 
[10:59:35.798]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.798]                   signalCondition(cond)
[10:59:35.798]                 }
[10:59:35.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.798]                 "immediateCondition"))) {
[10:59:35.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.798]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.798]                   if (TRUE && !signal) {
[10:59:35.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.798]                     {
[10:59:35.798]                       inherits <- base::inherits
[10:59:35.798]                       invokeRestart <- base::invokeRestart
[10:59:35.798]                       is.null <- base::is.null
[10:59:35.798]                       muffled <- FALSE
[10:59:35.798]                       if (inherits(cond, "message")) {
[10:59:35.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.798]                         if (muffled) 
[10:59:35.798]                           invokeRestart("muffleMessage")
[10:59:35.798]                       }
[10:59:35.798]                       else if (inherits(cond, "warning")) {
[10:59:35.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.798]                         if (muffled) 
[10:59:35.798]                           invokeRestart("muffleWarning")
[10:59:35.798]                       }
[10:59:35.798]                       else if (inherits(cond, "condition")) {
[10:59:35.798]                         if (!is.null(pattern)) {
[10:59:35.798]                           computeRestarts <- base::computeRestarts
[10:59:35.798]                           grepl <- base::grepl
[10:59:35.798]                           restarts <- computeRestarts(cond)
[10:59:35.798]                           for (restart in restarts) {
[10:59:35.798]                             name <- restart$name
[10:59:35.798]                             if (is.null(name)) 
[10:59:35.798]                               next
[10:59:35.798]                             if (!grepl(pattern, name)) 
[10:59:35.798]                               next
[10:59:35.798]                             invokeRestart(restart)
[10:59:35.798]                             muffled <- TRUE
[10:59:35.798]                             break
[10:59:35.798]                           }
[10:59:35.798]                         }
[10:59:35.798]                       }
[10:59:35.798]                       invisible(muffled)
[10:59:35.798]                     }
[10:59:35.798]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.798]                   }
[10:59:35.798]                 }
[10:59:35.798]                 else {
[10:59:35.798]                   if (TRUE) {
[10:59:35.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.798]                     {
[10:59:35.798]                       inherits <- base::inherits
[10:59:35.798]                       invokeRestart <- base::invokeRestart
[10:59:35.798]                       is.null <- base::is.null
[10:59:35.798]                       muffled <- FALSE
[10:59:35.798]                       if (inherits(cond, "message")) {
[10:59:35.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.798]                         if (muffled) 
[10:59:35.798]                           invokeRestart("muffleMessage")
[10:59:35.798]                       }
[10:59:35.798]                       else if (inherits(cond, "warning")) {
[10:59:35.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.798]                         if (muffled) 
[10:59:35.798]                           invokeRestart("muffleWarning")
[10:59:35.798]                       }
[10:59:35.798]                       else if (inherits(cond, "condition")) {
[10:59:35.798]                         if (!is.null(pattern)) {
[10:59:35.798]                           computeRestarts <- base::computeRestarts
[10:59:35.798]                           grepl <- base::grepl
[10:59:35.798]                           restarts <- computeRestarts(cond)
[10:59:35.798]                           for (restart in restarts) {
[10:59:35.798]                             name <- restart$name
[10:59:35.798]                             if (is.null(name)) 
[10:59:35.798]                               next
[10:59:35.798]                             if (!grepl(pattern, name)) 
[10:59:35.798]                               next
[10:59:35.798]                             invokeRestart(restart)
[10:59:35.798]                             muffled <- TRUE
[10:59:35.798]                             break
[10:59:35.798]                           }
[10:59:35.798]                         }
[10:59:35.798]                       }
[10:59:35.798]                       invisible(muffled)
[10:59:35.798]                     }
[10:59:35.798]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.798]                   }
[10:59:35.798]                 }
[10:59:35.798]             }
[10:59:35.798]         }))
[10:59:35.798]     }, error = function(ex) {
[10:59:35.798]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.798]                 ...future.rng), started = ...future.startTime, 
[10:59:35.798]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.798]             version = "1.8"), class = "FutureResult")
[10:59:35.798]     }, finally = {
[10:59:35.798]         if (!identical(...future.workdir, getwd())) 
[10:59:35.798]             setwd(...future.workdir)
[10:59:35.798]         {
[10:59:35.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.798]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.798]             }
[10:59:35.798]             base::options(...future.oldOptions)
[10:59:35.798]             if (.Platform$OS.type == "windows") {
[10:59:35.798]                 old_names <- names(...future.oldEnvVars)
[10:59:35.798]                 envs <- base::Sys.getenv()
[10:59:35.798]                 names <- names(envs)
[10:59:35.798]                 common <- intersect(names, old_names)
[10:59:35.798]                 added <- setdiff(names, old_names)
[10:59:35.798]                 removed <- setdiff(old_names, names)
[10:59:35.798]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.798]                   envs[common]]
[10:59:35.798]                 NAMES <- toupper(changed)
[10:59:35.798]                 args <- list()
[10:59:35.798]                 for (kk in seq_along(NAMES)) {
[10:59:35.798]                   name <- changed[[kk]]
[10:59:35.798]                   NAME <- NAMES[[kk]]
[10:59:35.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.798]                     next
[10:59:35.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.798]                 }
[10:59:35.798]                 NAMES <- toupper(added)
[10:59:35.798]                 for (kk in seq_along(NAMES)) {
[10:59:35.798]                   name <- added[[kk]]
[10:59:35.798]                   NAME <- NAMES[[kk]]
[10:59:35.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.798]                     next
[10:59:35.798]                   args[[name]] <- ""
[10:59:35.798]                 }
[10:59:35.798]                 NAMES <- toupper(removed)
[10:59:35.798]                 for (kk in seq_along(NAMES)) {
[10:59:35.798]                   name <- removed[[kk]]
[10:59:35.798]                   NAME <- NAMES[[kk]]
[10:59:35.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.798]                     next
[10:59:35.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.798]                 }
[10:59:35.798]                 if (length(args) > 0) 
[10:59:35.798]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.798]             }
[10:59:35.798]             else {
[10:59:35.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.798]             }
[10:59:35.798]             {
[10:59:35.798]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.798]                   0L) {
[10:59:35.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.798]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.798]                   base::options(opts)
[10:59:35.798]                 }
[10:59:35.798]                 {
[10:59:35.798]                   {
[10:59:35.798]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.798]                     NULL
[10:59:35.798]                   }
[10:59:35.798]                   options(future.plan = NULL)
[10:59:35.798]                   if (is.na(NA_character_)) 
[10:59:35.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.798]                     .init = FALSE)
[10:59:35.798]                 }
[10:59:35.798]             }
[10:59:35.798]         }
[10:59:35.798]     })
[10:59:35.798]     if (TRUE) {
[10:59:35.798]         base::sink(type = "output", split = FALSE)
[10:59:35.798]         if (TRUE) {
[10:59:35.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.798]         }
[10:59:35.798]         else {
[10:59:35.798]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.798]         }
[10:59:35.798]         base::close(...future.stdout)
[10:59:35.798]         ...future.stdout <- NULL
[10:59:35.798]     }
[10:59:35.798]     ...future.result$conditions <- ...future.conditions
[10:59:35.798]     ...future.result$finished <- base::Sys.time()
[10:59:35.798]     ...future.result
[10:59:35.798] }
[10:59:35.800] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[10:59:35.801] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:59:35.801] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:59:35.801] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:59:35.802] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:59:35.802] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:59:35.802] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:59:35.802] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.803] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.803] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.803] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.803] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[10:59:35.804] MultisessionFuture started
[10:59:35.804] - Launch lazy future ... done
[10:59:35.804] run() for ‘MultisessionFuture’ ... done
[10:59:35.804] Created future:
[10:59:35.804] MultisessionFuture:
[10:59:35.804] Label: ‘future_.mapply-2’
[10:59:35.804] Expression:
[10:59:35.804] {
[10:59:35.804]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.804]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.804]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.804]         on.exit(options(oopts), add = TRUE)
[10:59:35.804]     }
[10:59:35.804]     {
[10:59:35.804]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.804]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.804]         do.call(mapply, args = args)
[10:59:35.804]     }
[10:59:35.804] }
[10:59:35.804] Lazy evaluation: FALSE
[10:59:35.804] Asynchronous evaluation: TRUE
[10:59:35.804] Local evaluation: TRUE
[10:59:35.804] Environment: R_GlobalEnv
[10:59:35.804] Capture standard output: TRUE
[10:59:35.804] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.804] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.804] Packages: <none>
[10:59:35.804] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.804] Resolved: FALSE
[10:59:35.804] Value: <not collected>
[10:59:35.804] Conditions captured: <none>
[10:59:35.804] Early signaling: FALSE
[10:59:35.804] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.804] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.815] Chunk #2 of 2 ... DONE
[10:59:35.815] Launching 2 futures (chunks) ... DONE
[10:59:35.816] Resolving 2 futures (chunks) ...
[10:59:35.816] resolve() on list ...
[10:59:35.816]  recursive: 0
[10:59:35.816]  length: 2
[10:59:35.816] 
[10:59:35.816] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.817] - Validating connection of MultisessionFuture
[10:59:35.817] - received message: FutureResult
[10:59:35.817] - Received FutureResult
[10:59:35.817] - Erased future from FutureRegistry
[10:59:35.817] result() for ClusterFuture ...
[10:59:35.817] - result already collected: FutureResult
[10:59:35.817] result() for ClusterFuture ... done
[10:59:35.817] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.817] Future #1
[10:59:35.817] result() for ClusterFuture ...
[10:59:35.818] - result already collected: FutureResult
[10:59:35.818] result() for ClusterFuture ... done
[10:59:35.818] result() for ClusterFuture ...
[10:59:35.818] - result already collected: FutureResult
[10:59:35.818] result() for ClusterFuture ... done
[10:59:35.818] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:35.818] - nx: 2
[10:59:35.818] - relay: TRUE
[10:59:35.818] - stdout: TRUE
[10:59:35.818] - signal: TRUE
[10:59:35.818] - resignal: FALSE
[10:59:35.818] - force: TRUE
[10:59:35.818] - relayed: [n=2] FALSE, FALSE
[10:59:35.819] - queued futures: [n=2] FALSE, FALSE
[10:59:35.819]  - until=1
[10:59:35.819]  - relaying element #1
[10:59:35.819] result() for ClusterFuture ...
[10:59:35.819] - result already collected: FutureResult
[10:59:35.819] result() for ClusterFuture ... done
[10:59:35.819] result() for ClusterFuture ...
[10:59:35.819] - result already collected: FutureResult
[10:59:35.819] result() for ClusterFuture ... done
[10:59:35.819] result() for ClusterFuture ...
[10:59:35.819] - result already collected: FutureResult
[10:59:35.819] result() for ClusterFuture ... done
[10:59:35.820] result() for ClusterFuture ...
[10:59:35.820] - result already collected: FutureResult
[10:59:35.820] result() for ClusterFuture ... done
[10:59:35.820] - relayed: [n=2] TRUE, FALSE
[10:59:35.820] - queued futures: [n=2] TRUE, FALSE
[10:59:35.820] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:35.820]  length: 1 (resolved future 1)
[10:59:35.846] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.846] - Validating connection of MultisessionFuture
[10:59:35.846] - received message: FutureResult
[10:59:35.846] - Received FutureResult
[10:59:35.847] - Erased future from FutureRegistry
[10:59:35.847] result() for ClusterFuture ...
[10:59:35.847] - result already collected: FutureResult
[10:59:35.847] result() for ClusterFuture ... done
[10:59:35.847] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.847] Future #2
[10:59:35.847] result() for ClusterFuture ...
[10:59:35.847] - result already collected: FutureResult
[10:59:35.847] result() for ClusterFuture ... done
[10:59:35.847] result() for ClusterFuture ...
[10:59:35.847] - result already collected: FutureResult
[10:59:35.847] result() for ClusterFuture ... done
[10:59:35.848] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:35.848] - nx: 2
[10:59:35.848] - relay: TRUE
[10:59:35.848] - stdout: TRUE
[10:59:35.848] - signal: TRUE
[10:59:35.848] - resignal: FALSE
[10:59:35.848] - force: TRUE
[10:59:35.848] - relayed: [n=2] TRUE, FALSE
[10:59:35.848] - queued futures: [n=2] TRUE, FALSE
[10:59:35.848]  - until=2
[10:59:35.848]  - relaying element #2
[10:59:35.848] result() for ClusterFuture ...
[10:59:35.848] - result already collected: FutureResult
[10:59:35.849] result() for ClusterFuture ... done
[10:59:35.849] result() for ClusterFuture ...
[10:59:35.849] - result already collected: FutureResult
[10:59:35.849] result() for ClusterFuture ... done
[10:59:35.849] result() for ClusterFuture ...
[10:59:35.849] - result already collected: FutureResult
[10:59:35.849] result() for ClusterFuture ... done
[10:59:35.849] result() for ClusterFuture ...
[10:59:35.849] - result already collected: FutureResult
[10:59:35.849] result() for ClusterFuture ... done
[10:59:35.849] - relayed: [n=2] TRUE, TRUE
[10:59:35.849] - queued futures: [n=2] TRUE, TRUE
[10:59:35.850] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:35.850]  length: 0 (resolved future 2)
[10:59:35.850] Relaying remaining futures
[10:59:35.850] signalConditionsASAP(NULL, pos=0) ...
[10:59:35.850] - nx: 2
[10:59:35.850] - relay: TRUE
[10:59:35.850] - stdout: TRUE
[10:59:35.850] - signal: TRUE
[10:59:35.850] - resignal: FALSE
[10:59:35.850] - force: TRUE
[10:59:35.850] - relayed: [n=2] TRUE, TRUE
[10:59:35.850] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:35.850] - relayed: [n=2] TRUE, TRUE
[10:59:35.851] - queued futures: [n=2] TRUE, TRUE
[10:59:35.851] signalConditionsASAP(NULL, pos=0) ... done
[10:59:35.851] resolve() on list ... DONE
[10:59:35.851] result() for ClusterFuture ...
[10:59:35.851] - result already collected: FutureResult
[10:59:35.851] result() for ClusterFuture ... done
[10:59:35.851] result() for ClusterFuture ...
[10:59:35.851] - result already collected: FutureResult
[10:59:35.851] result() for ClusterFuture ... done
[10:59:35.851] result() for ClusterFuture ...
[10:59:35.851] - result already collected: FutureResult
[10:59:35.851] result() for ClusterFuture ... done
[10:59:35.852] result() for ClusterFuture ...
[10:59:35.852] - result already collected: FutureResult
[10:59:35.852] result() for ClusterFuture ... done
[10:59:35.852]  - Number of value chunks collected: 2
[10:59:35.852] Resolving 2 futures (chunks) ... DONE
[10:59:35.852] Reducing values from 2 chunks ...
[10:59:35.852]  - Number of values collected after concatenation: 5
[10:59:35.852]  - Number of values expected: 5
[10:59:35.852] Reducing values from 2 chunks ... DONE
[10:59:35.852] future_mapply() ... DONE
[10:59:35.853] future_mapply() ...
[10:59:35.854] Number of chunks: 3
[10:59:35.854] Index remapping (attribute 'ordering'): [n = 5] 4, 1, 3, 5, 2
[10:59:35.854] getGlobalsAndPackagesXApply() ...
[10:59:35.854]  - future.globals: TRUE
[10:59:35.854] getGlobalsAndPackages() ...
[10:59:35.855] Searching for globals...
[10:59:35.856] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:35.856] Searching for globals ... DONE
[10:59:35.856] Resolving globals: FALSE
[10:59:35.856] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:35.856] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:35.857] - globals: [1] ‘FUN’
[10:59:35.857] 
[10:59:35.857] getGlobalsAndPackages() ... DONE
[10:59:35.857]  - globals found/used: [n=1] ‘FUN’
[10:59:35.857]  - needed namespaces: [n=0] 
[10:59:35.857] Finding globals ... DONE
[10:59:35.857] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:35.857] List of 2
[10:59:35.857]  $ ...future.FUN:function (C, k)  
[10:59:35.857]  $ MoreArgs     : NULL
[10:59:35.857]  - attr(*, "where")=List of 2
[10:59:35.857]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:35.857]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:35.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:35.857]  - attr(*, "resolved")= logi FALSE
[10:59:35.857]  - attr(*, "total_size")= num NA
[10:59:35.860] Packages to be attached in all futures: [n=0] 
[10:59:35.860] getGlobalsAndPackagesXApply() ... DONE
[10:59:35.860] Number of futures (= number of chunks): 3
[10:59:35.860] Launching 3 futures (chunks) ...
[10:59:35.860] Chunk #1 of 3 ...
[10:59:35.860]  - Finding globals in '...' for chunk #1 ...
[10:59:35.860] getGlobalsAndPackages() ...
[10:59:35.860] Searching for globals...
[10:59:35.861] 
[10:59:35.861] Searching for globals ... DONE
[10:59:35.861] - globals: [0] <none>
[10:59:35.861] getGlobalsAndPackages() ... DONE
[10:59:35.861]    + additional globals found: [n=0] 
[10:59:35.861]    + additional namespaces needed: [n=0] 
[10:59:35.861]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:35.861]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:35.861]  - seeds: <none>
[10:59:35.861]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.861] getGlobalsAndPackages() ...
[10:59:35.861] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.862] Resolving globals: FALSE
[10:59:35.862] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:35.862] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.862] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.863] 
[10:59:35.863] getGlobalsAndPackages() ... DONE
[10:59:35.863] run() for ‘Future’ ...
[10:59:35.863] - state: ‘created’
[10:59:35.863] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.877]   - Field: ‘node’
[10:59:35.877]   - Field: ‘label’
[10:59:35.877]   - Field: ‘local’
[10:59:35.877]   - Field: ‘owner’
[10:59:35.877]   - Field: ‘envir’
[10:59:35.877]   - Field: ‘workers’
[10:59:35.877]   - Field: ‘packages’
[10:59:35.877]   - Field: ‘gc’
[10:59:35.877]   - Field: ‘conditions’
[10:59:35.877]   - Field: ‘persistent’
[10:59:35.877]   - Field: ‘expr’
[10:59:35.877]   - Field: ‘uuid’
[10:59:35.878]   - Field: ‘seed’
[10:59:35.878]   - Field: ‘version’
[10:59:35.878]   - Field: ‘result’
[10:59:35.878]   - Field: ‘asynchronous’
[10:59:35.878]   - Field: ‘calls’
[10:59:35.878]   - Field: ‘globals’
[10:59:35.878]   - Field: ‘stdout’
[10:59:35.878]   - Field: ‘earlySignal’
[10:59:35.878]   - Field: ‘lazy’
[10:59:35.878]   - Field: ‘state’
[10:59:35.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.878] - Launch lazy future ...
[10:59:35.879] Packages needed by the future expression (n = 0): <none>
[10:59:35.879] Packages needed by future strategies (n = 0): <none>
[10:59:35.879] {
[10:59:35.879]     {
[10:59:35.879]         {
[10:59:35.879]             ...future.startTime <- base::Sys.time()
[10:59:35.879]             {
[10:59:35.879]                 {
[10:59:35.879]                   {
[10:59:35.879]                     {
[10:59:35.879]                       base::local({
[10:59:35.879]                         has_future <- base::requireNamespace("future", 
[10:59:35.879]                           quietly = TRUE)
[10:59:35.879]                         if (has_future) {
[10:59:35.879]                           ns <- base::getNamespace("future")
[10:59:35.879]                           version <- ns[[".package"]][["version"]]
[10:59:35.879]                           if (is.null(version)) 
[10:59:35.879]                             version <- utils::packageVersion("future")
[10:59:35.879]                         }
[10:59:35.879]                         else {
[10:59:35.879]                           version <- NULL
[10:59:35.879]                         }
[10:59:35.879]                         if (!has_future || version < "1.8.0") {
[10:59:35.879]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.879]                             "", base::R.version$version.string), 
[10:59:35.879]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.879]                               "release", "version")], collapse = " "), 
[10:59:35.879]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.879]                             info)
[10:59:35.879]                           info <- base::paste(info, collapse = "; ")
[10:59:35.879]                           if (!has_future) {
[10:59:35.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.879]                               info)
[10:59:35.879]                           }
[10:59:35.879]                           else {
[10:59:35.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.879]                               info, version)
[10:59:35.879]                           }
[10:59:35.879]                           base::stop(msg)
[10:59:35.879]                         }
[10:59:35.879]                       })
[10:59:35.879]                     }
[10:59:35.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.879]                     base::options(mc.cores = 1L)
[10:59:35.879]                   }
[10:59:35.879]                   ...future.strategy.old <- future::plan("list")
[10:59:35.879]                   options(future.plan = NULL)
[10:59:35.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.879]                 }
[10:59:35.879]                 ...future.workdir <- getwd()
[10:59:35.879]             }
[10:59:35.879]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.879]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.879]         }
[10:59:35.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.879]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:35.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.879]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.879]             base::names(...future.oldOptions))
[10:59:35.879]     }
[10:59:35.879]     if (FALSE) {
[10:59:35.879]     }
[10:59:35.879]     else {
[10:59:35.879]         if (TRUE) {
[10:59:35.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.879]                 open = "w")
[10:59:35.879]         }
[10:59:35.879]         else {
[10:59:35.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.879]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.879]         }
[10:59:35.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.879]             base::sink(type = "output", split = FALSE)
[10:59:35.879]             base::close(...future.stdout)
[10:59:35.879]         }, add = TRUE)
[10:59:35.879]     }
[10:59:35.879]     ...future.frame <- base::sys.nframe()
[10:59:35.879]     ...future.conditions <- base::list()
[10:59:35.879]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.879]     if (FALSE) {
[10:59:35.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.879]     }
[10:59:35.879]     ...future.result <- base::tryCatch({
[10:59:35.879]         base::withCallingHandlers({
[10:59:35.879]             ...future.value <- base::withVisible(base::local({
[10:59:35.879]                 ...future.makeSendCondition <- base::local({
[10:59:35.879]                   sendCondition <- NULL
[10:59:35.879]                   function(frame = 1L) {
[10:59:35.879]                     if (is.function(sendCondition)) 
[10:59:35.879]                       return(sendCondition)
[10:59:35.879]                     ns <- getNamespace("parallel")
[10:59:35.879]                     if (exists("sendData", mode = "function", 
[10:59:35.879]                       envir = ns)) {
[10:59:35.879]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.879]                         envir = ns)
[10:59:35.879]                       envir <- sys.frame(frame)
[10:59:35.879]                       master <- NULL
[10:59:35.879]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.879]                         !identical(envir, emptyenv())) {
[10:59:35.879]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.879]                           inherits = FALSE)) {
[10:59:35.879]                           master <- get("master", mode = "list", 
[10:59:35.879]                             envir = envir, inherits = FALSE)
[10:59:35.879]                           if (inherits(master, c("SOCKnode", 
[10:59:35.879]                             "SOCK0node"))) {
[10:59:35.879]                             sendCondition <<- function(cond) {
[10:59:35.879]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.879]                                 success = TRUE)
[10:59:35.879]                               parallel_sendData(master, data)
[10:59:35.879]                             }
[10:59:35.879]                             return(sendCondition)
[10:59:35.879]                           }
[10:59:35.879]                         }
[10:59:35.879]                         frame <- frame + 1L
[10:59:35.879]                         envir <- sys.frame(frame)
[10:59:35.879]                       }
[10:59:35.879]                     }
[10:59:35.879]                     sendCondition <<- function(cond) NULL
[10:59:35.879]                   }
[10:59:35.879]                 })
[10:59:35.879]                 withCallingHandlers({
[10:59:35.879]                   {
[10:59:35.879]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.879]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.879]                       ...future.globals.maxSize)) {
[10:59:35.879]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.879]                       on.exit(options(oopts), add = TRUE)
[10:59:35.879]                     }
[10:59:35.879]                     {
[10:59:35.879]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.879]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.879]                         USE.NAMES = FALSE)
[10:59:35.879]                       do.call(mapply, args = args)
[10:59:35.879]                     }
[10:59:35.879]                   }
[10:59:35.879]                 }, immediateCondition = function(cond) {
[10:59:35.879]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.879]                   sendCondition(cond)
[10:59:35.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.879]                   {
[10:59:35.879]                     inherits <- base::inherits
[10:59:35.879]                     invokeRestart <- base::invokeRestart
[10:59:35.879]                     is.null <- base::is.null
[10:59:35.879]                     muffled <- FALSE
[10:59:35.879]                     if (inherits(cond, "message")) {
[10:59:35.879]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.879]                       if (muffled) 
[10:59:35.879]                         invokeRestart("muffleMessage")
[10:59:35.879]                     }
[10:59:35.879]                     else if (inherits(cond, "warning")) {
[10:59:35.879]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.879]                       if (muffled) 
[10:59:35.879]                         invokeRestart("muffleWarning")
[10:59:35.879]                     }
[10:59:35.879]                     else if (inherits(cond, "condition")) {
[10:59:35.879]                       if (!is.null(pattern)) {
[10:59:35.879]                         computeRestarts <- base::computeRestarts
[10:59:35.879]                         grepl <- base::grepl
[10:59:35.879]                         restarts <- computeRestarts(cond)
[10:59:35.879]                         for (restart in restarts) {
[10:59:35.879]                           name <- restart$name
[10:59:35.879]                           if (is.null(name)) 
[10:59:35.879]                             next
[10:59:35.879]                           if (!grepl(pattern, name)) 
[10:59:35.879]                             next
[10:59:35.879]                           invokeRestart(restart)
[10:59:35.879]                           muffled <- TRUE
[10:59:35.879]                           break
[10:59:35.879]                         }
[10:59:35.879]                       }
[10:59:35.879]                     }
[10:59:35.879]                     invisible(muffled)
[10:59:35.879]                   }
[10:59:35.879]                   muffleCondition(cond)
[10:59:35.879]                 })
[10:59:35.879]             }))
[10:59:35.879]             future::FutureResult(value = ...future.value$value, 
[10:59:35.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.879]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.879]                     ...future.globalenv.names))
[10:59:35.879]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.879]         }, condition = base::local({
[10:59:35.879]             c <- base::c
[10:59:35.879]             inherits <- base::inherits
[10:59:35.879]             invokeRestart <- base::invokeRestart
[10:59:35.879]             length <- base::length
[10:59:35.879]             list <- base::list
[10:59:35.879]             seq.int <- base::seq.int
[10:59:35.879]             signalCondition <- base::signalCondition
[10:59:35.879]             sys.calls <- base::sys.calls
[10:59:35.879]             `[[` <- base::`[[`
[10:59:35.879]             `+` <- base::`+`
[10:59:35.879]             `<<-` <- base::`<<-`
[10:59:35.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.879]                   3L)]
[10:59:35.879]             }
[10:59:35.879]             function(cond) {
[10:59:35.879]                 is_error <- inherits(cond, "error")
[10:59:35.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.879]                   NULL)
[10:59:35.879]                 if (is_error) {
[10:59:35.879]                   sessionInformation <- function() {
[10:59:35.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.879]                       search = base::search(), system = base::Sys.info())
[10:59:35.879]                   }
[10:59:35.879]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.879]                     cond$call), session = sessionInformation(), 
[10:59:35.879]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.879]                   signalCondition(cond)
[10:59:35.879]                 }
[10:59:35.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.879]                 "immediateCondition"))) {
[10:59:35.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.879]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.879]                   if (TRUE && !signal) {
[10:59:35.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.879]                     {
[10:59:35.879]                       inherits <- base::inherits
[10:59:35.879]                       invokeRestart <- base::invokeRestart
[10:59:35.879]                       is.null <- base::is.null
[10:59:35.879]                       muffled <- FALSE
[10:59:35.879]                       if (inherits(cond, "message")) {
[10:59:35.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.879]                         if (muffled) 
[10:59:35.879]                           invokeRestart("muffleMessage")
[10:59:35.879]                       }
[10:59:35.879]                       else if (inherits(cond, "warning")) {
[10:59:35.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.879]                         if (muffled) 
[10:59:35.879]                           invokeRestart("muffleWarning")
[10:59:35.879]                       }
[10:59:35.879]                       else if (inherits(cond, "condition")) {
[10:59:35.879]                         if (!is.null(pattern)) {
[10:59:35.879]                           computeRestarts <- base::computeRestarts
[10:59:35.879]                           grepl <- base::grepl
[10:59:35.879]                           restarts <- computeRestarts(cond)
[10:59:35.879]                           for (restart in restarts) {
[10:59:35.879]                             name <- restart$name
[10:59:35.879]                             if (is.null(name)) 
[10:59:35.879]                               next
[10:59:35.879]                             if (!grepl(pattern, name)) 
[10:59:35.879]                               next
[10:59:35.879]                             invokeRestart(restart)
[10:59:35.879]                             muffled <- TRUE
[10:59:35.879]                             break
[10:59:35.879]                           }
[10:59:35.879]                         }
[10:59:35.879]                       }
[10:59:35.879]                       invisible(muffled)
[10:59:35.879]                     }
[10:59:35.879]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.879]                   }
[10:59:35.879]                 }
[10:59:35.879]                 else {
[10:59:35.879]                   if (TRUE) {
[10:59:35.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.879]                     {
[10:59:35.879]                       inherits <- base::inherits
[10:59:35.879]                       invokeRestart <- base::invokeRestart
[10:59:35.879]                       is.null <- base::is.null
[10:59:35.879]                       muffled <- FALSE
[10:59:35.879]                       if (inherits(cond, "message")) {
[10:59:35.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.879]                         if (muffled) 
[10:59:35.879]                           invokeRestart("muffleMessage")
[10:59:35.879]                       }
[10:59:35.879]                       else if (inherits(cond, "warning")) {
[10:59:35.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.879]                         if (muffled) 
[10:59:35.879]                           invokeRestart("muffleWarning")
[10:59:35.879]                       }
[10:59:35.879]                       else if (inherits(cond, "condition")) {
[10:59:35.879]                         if (!is.null(pattern)) {
[10:59:35.879]                           computeRestarts <- base::computeRestarts
[10:59:35.879]                           grepl <- base::grepl
[10:59:35.879]                           restarts <- computeRestarts(cond)
[10:59:35.879]                           for (restart in restarts) {
[10:59:35.879]                             name <- restart$name
[10:59:35.879]                             if (is.null(name)) 
[10:59:35.879]                               next
[10:59:35.879]                             if (!grepl(pattern, name)) 
[10:59:35.879]                               next
[10:59:35.879]                             invokeRestart(restart)
[10:59:35.879]                             muffled <- TRUE
[10:59:35.879]                             break
[10:59:35.879]                           }
[10:59:35.879]                         }
[10:59:35.879]                       }
[10:59:35.879]                       invisible(muffled)
[10:59:35.879]                     }
[10:59:35.879]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.879]                   }
[10:59:35.879]                 }
[10:59:35.879]             }
[10:59:35.879]         }))
[10:59:35.879]     }, error = function(ex) {
[10:59:35.879]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.879]                 ...future.rng), started = ...future.startTime, 
[10:59:35.879]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.879]             version = "1.8"), class = "FutureResult")
[10:59:35.879]     }, finally = {
[10:59:35.879]         if (!identical(...future.workdir, getwd())) 
[10:59:35.879]             setwd(...future.workdir)
[10:59:35.879]         {
[10:59:35.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.879]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.879]             }
[10:59:35.879]             base::options(...future.oldOptions)
[10:59:35.879]             if (.Platform$OS.type == "windows") {
[10:59:35.879]                 old_names <- names(...future.oldEnvVars)
[10:59:35.879]                 envs <- base::Sys.getenv()
[10:59:35.879]                 names <- names(envs)
[10:59:35.879]                 common <- intersect(names, old_names)
[10:59:35.879]                 added <- setdiff(names, old_names)
[10:59:35.879]                 removed <- setdiff(old_names, names)
[10:59:35.879]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.879]                   envs[common]]
[10:59:35.879]                 NAMES <- toupper(changed)
[10:59:35.879]                 args <- list()
[10:59:35.879]                 for (kk in seq_along(NAMES)) {
[10:59:35.879]                   name <- changed[[kk]]
[10:59:35.879]                   NAME <- NAMES[[kk]]
[10:59:35.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.879]                     next
[10:59:35.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.879]                 }
[10:59:35.879]                 NAMES <- toupper(added)
[10:59:35.879]                 for (kk in seq_along(NAMES)) {
[10:59:35.879]                   name <- added[[kk]]
[10:59:35.879]                   NAME <- NAMES[[kk]]
[10:59:35.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.879]                     next
[10:59:35.879]                   args[[name]] <- ""
[10:59:35.879]                 }
[10:59:35.879]                 NAMES <- toupper(removed)
[10:59:35.879]                 for (kk in seq_along(NAMES)) {
[10:59:35.879]                   name <- removed[[kk]]
[10:59:35.879]                   NAME <- NAMES[[kk]]
[10:59:35.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.879]                     next
[10:59:35.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.879]                 }
[10:59:35.879]                 if (length(args) > 0) 
[10:59:35.879]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.879]             }
[10:59:35.879]             else {
[10:59:35.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.879]             }
[10:59:35.879]             {
[10:59:35.879]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.879]                   0L) {
[10:59:35.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.879]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.879]                   base::options(opts)
[10:59:35.879]                 }
[10:59:35.879]                 {
[10:59:35.879]                   {
[10:59:35.879]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.879]                     NULL
[10:59:35.879]                   }
[10:59:35.879]                   options(future.plan = NULL)
[10:59:35.879]                   if (is.na(NA_character_)) 
[10:59:35.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.879]                     .init = FALSE)
[10:59:35.879]                 }
[10:59:35.879]             }
[10:59:35.879]         }
[10:59:35.879]     })
[10:59:35.879]     if (TRUE) {
[10:59:35.879]         base::sink(type = "output", split = FALSE)
[10:59:35.879]         if (TRUE) {
[10:59:35.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.879]         }
[10:59:35.879]         else {
[10:59:35.879]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.879]         }
[10:59:35.879]         base::close(...future.stdout)
[10:59:35.879]         ...future.stdout <- NULL
[10:59:35.879]     }
[10:59:35.879]     ...future.result$conditions <- ...future.conditions
[10:59:35.879]     ...future.result$finished <- base::Sys.time()
[10:59:35.879]     ...future.result
[10:59:35.879] }
[10:59:35.882] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[10:59:35.882] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:35.882] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:35.882] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:35.883] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.883] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:59:35.883] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:59:35.883] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.884] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.884] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.884] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.884] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[10:59:35.885] MultisessionFuture started
[10:59:35.885] - Launch lazy future ... done
[10:59:35.885] run() for ‘MultisessionFuture’ ... done
[10:59:35.885] Created future:
[10:59:35.885] MultisessionFuture:
[10:59:35.885] Label: ‘future_mapply-1’
[10:59:35.885] Expression:
[10:59:35.885] {
[10:59:35.885]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.885]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.885]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.885]         on.exit(options(oopts), add = TRUE)
[10:59:35.885]     }
[10:59:35.885]     {
[10:59:35.885]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.885]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.885]         do.call(mapply, args = args)
[10:59:35.885]     }
[10:59:35.885] }
[10:59:35.885] Lazy evaluation: FALSE
[10:59:35.885] Asynchronous evaluation: TRUE
[10:59:35.885] Local evaluation: TRUE
[10:59:35.885] Environment: R_GlobalEnv
[10:59:35.885] Capture standard output: TRUE
[10:59:35.885] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.885] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.885] Packages: <none>
[10:59:35.885] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.885] Resolved: FALSE
[10:59:35.885] Value: <not collected>
[10:59:35.885] Conditions captured: <none>
[10:59:35.885] Early signaling: FALSE
[10:59:35.885] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.885] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.896] Chunk #1 of 3 ... DONE
[10:59:35.896] Chunk #2 of 3 ...
[10:59:35.897]  - Finding globals in '...' for chunk #2 ...
[10:59:35.897] getGlobalsAndPackages() ...
[10:59:35.897] Searching for globals...
[10:59:35.897] 
[10:59:35.897] Searching for globals ... DONE
[10:59:35.897] - globals: [0] <none>
[10:59:35.897] getGlobalsAndPackages() ... DONE
[10:59:35.897]    + additional globals found: [n=0] 
[10:59:35.898]    + additional namespaces needed: [n=0] 
[10:59:35.898]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:35.898]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:35.898]  - seeds: <none>
[10:59:35.898]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.898] getGlobalsAndPackages() ...
[10:59:35.898] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.898] Resolving globals: FALSE
[10:59:35.899] The total size of the 5 globals is 847 bytes (847 bytes)
[10:59:35.899] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.899] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.899] 
[10:59:35.899] getGlobalsAndPackages() ... DONE
[10:59:35.900] run() for ‘Future’ ...
[10:59:35.900] - state: ‘created’
[10:59:35.900] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.913] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.913]   - Field: ‘node’
[10:59:35.913]   - Field: ‘label’
[10:59:35.913]   - Field: ‘local’
[10:59:35.914]   - Field: ‘owner’
[10:59:35.914]   - Field: ‘envir’
[10:59:35.914]   - Field: ‘workers’
[10:59:35.914]   - Field: ‘packages’
[10:59:35.914]   - Field: ‘gc’
[10:59:35.914]   - Field: ‘conditions’
[10:59:35.914]   - Field: ‘persistent’
[10:59:35.914]   - Field: ‘expr’
[10:59:35.914]   - Field: ‘uuid’
[10:59:35.914]   - Field: ‘seed’
[10:59:35.914]   - Field: ‘version’
[10:59:35.914]   - Field: ‘result’
[10:59:35.915]   - Field: ‘asynchronous’
[10:59:35.915]   - Field: ‘calls’
[10:59:35.915]   - Field: ‘globals’
[10:59:35.915]   - Field: ‘stdout’
[10:59:35.915]   - Field: ‘earlySignal’
[10:59:35.915]   - Field: ‘lazy’
[10:59:35.915]   - Field: ‘state’
[10:59:35.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.915] - Launch lazy future ...
[10:59:35.915] Packages needed by the future expression (n = 0): <none>
[10:59:35.916] Packages needed by future strategies (n = 0): <none>
[10:59:35.916] {
[10:59:35.916]     {
[10:59:35.916]         {
[10:59:35.916]             ...future.startTime <- base::Sys.time()
[10:59:35.916]             {
[10:59:35.916]                 {
[10:59:35.916]                   {
[10:59:35.916]                     {
[10:59:35.916]                       base::local({
[10:59:35.916]                         has_future <- base::requireNamespace("future", 
[10:59:35.916]                           quietly = TRUE)
[10:59:35.916]                         if (has_future) {
[10:59:35.916]                           ns <- base::getNamespace("future")
[10:59:35.916]                           version <- ns[[".package"]][["version"]]
[10:59:35.916]                           if (is.null(version)) 
[10:59:35.916]                             version <- utils::packageVersion("future")
[10:59:35.916]                         }
[10:59:35.916]                         else {
[10:59:35.916]                           version <- NULL
[10:59:35.916]                         }
[10:59:35.916]                         if (!has_future || version < "1.8.0") {
[10:59:35.916]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.916]                             "", base::R.version$version.string), 
[10:59:35.916]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.916]                               "release", "version")], collapse = " "), 
[10:59:35.916]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.916]                             info)
[10:59:35.916]                           info <- base::paste(info, collapse = "; ")
[10:59:35.916]                           if (!has_future) {
[10:59:35.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.916]                               info)
[10:59:35.916]                           }
[10:59:35.916]                           else {
[10:59:35.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.916]                               info, version)
[10:59:35.916]                           }
[10:59:35.916]                           base::stop(msg)
[10:59:35.916]                         }
[10:59:35.916]                       })
[10:59:35.916]                     }
[10:59:35.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.916]                     base::options(mc.cores = 1L)
[10:59:35.916]                   }
[10:59:35.916]                   ...future.strategy.old <- future::plan("list")
[10:59:35.916]                   options(future.plan = NULL)
[10:59:35.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.916]                 }
[10:59:35.916]                 ...future.workdir <- getwd()
[10:59:35.916]             }
[10:59:35.916]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.916]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.916]         }
[10:59:35.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.916]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:35.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.916]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.916]             base::names(...future.oldOptions))
[10:59:35.916]     }
[10:59:35.916]     if (FALSE) {
[10:59:35.916]     }
[10:59:35.916]     else {
[10:59:35.916]         if (TRUE) {
[10:59:35.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.916]                 open = "w")
[10:59:35.916]         }
[10:59:35.916]         else {
[10:59:35.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.916]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.916]         }
[10:59:35.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.916]             base::sink(type = "output", split = FALSE)
[10:59:35.916]             base::close(...future.stdout)
[10:59:35.916]         }, add = TRUE)
[10:59:35.916]     }
[10:59:35.916]     ...future.frame <- base::sys.nframe()
[10:59:35.916]     ...future.conditions <- base::list()
[10:59:35.916]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.916]     if (FALSE) {
[10:59:35.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.916]     }
[10:59:35.916]     ...future.result <- base::tryCatch({
[10:59:35.916]         base::withCallingHandlers({
[10:59:35.916]             ...future.value <- base::withVisible(base::local({
[10:59:35.916]                 ...future.makeSendCondition <- base::local({
[10:59:35.916]                   sendCondition <- NULL
[10:59:35.916]                   function(frame = 1L) {
[10:59:35.916]                     if (is.function(sendCondition)) 
[10:59:35.916]                       return(sendCondition)
[10:59:35.916]                     ns <- getNamespace("parallel")
[10:59:35.916]                     if (exists("sendData", mode = "function", 
[10:59:35.916]                       envir = ns)) {
[10:59:35.916]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.916]                         envir = ns)
[10:59:35.916]                       envir <- sys.frame(frame)
[10:59:35.916]                       master <- NULL
[10:59:35.916]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.916]                         !identical(envir, emptyenv())) {
[10:59:35.916]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.916]                           inherits = FALSE)) {
[10:59:35.916]                           master <- get("master", mode = "list", 
[10:59:35.916]                             envir = envir, inherits = FALSE)
[10:59:35.916]                           if (inherits(master, c("SOCKnode", 
[10:59:35.916]                             "SOCK0node"))) {
[10:59:35.916]                             sendCondition <<- function(cond) {
[10:59:35.916]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.916]                                 success = TRUE)
[10:59:35.916]                               parallel_sendData(master, data)
[10:59:35.916]                             }
[10:59:35.916]                             return(sendCondition)
[10:59:35.916]                           }
[10:59:35.916]                         }
[10:59:35.916]                         frame <- frame + 1L
[10:59:35.916]                         envir <- sys.frame(frame)
[10:59:35.916]                       }
[10:59:35.916]                     }
[10:59:35.916]                     sendCondition <<- function(cond) NULL
[10:59:35.916]                   }
[10:59:35.916]                 })
[10:59:35.916]                 withCallingHandlers({
[10:59:35.916]                   {
[10:59:35.916]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.916]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.916]                       ...future.globals.maxSize)) {
[10:59:35.916]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.916]                       on.exit(options(oopts), add = TRUE)
[10:59:35.916]                     }
[10:59:35.916]                     {
[10:59:35.916]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.916]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.916]                         USE.NAMES = FALSE)
[10:59:35.916]                       do.call(mapply, args = args)
[10:59:35.916]                     }
[10:59:35.916]                   }
[10:59:35.916]                 }, immediateCondition = function(cond) {
[10:59:35.916]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.916]                   sendCondition(cond)
[10:59:35.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.916]                   {
[10:59:35.916]                     inherits <- base::inherits
[10:59:35.916]                     invokeRestart <- base::invokeRestart
[10:59:35.916]                     is.null <- base::is.null
[10:59:35.916]                     muffled <- FALSE
[10:59:35.916]                     if (inherits(cond, "message")) {
[10:59:35.916]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.916]                       if (muffled) 
[10:59:35.916]                         invokeRestart("muffleMessage")
[10:59:35.916]                     }
[10:59:35.916]                     else if (inherits(cond, "warning")) {
[10:59:35.916]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.916]                       if (muffled) 
[10:59:35.916]                         invokeRestart("muffleWarning")
[10:59:35.916]                     }
[10:59:35.916]                     else if (inherits(cond, "condition")) {
[10:59:35.916]                       if (!is.null(pattern)) {
[10:59:35.916]                         computeRestarts <- base::computeRestarts
[10:59:35.916]                         grepl <- base::grepl
[10:59:35.916]                         restarts <- computeRestarts(cond)
[10:59:35.916]                         for (restart in restarts) {
[10:59:35.916]                           name <- restart$name
[10:59:35.916]                           if (is.null(name)) 
[10:59:35.916]                             next
[10:59:35.916]                           if (!grepl(pattern, name)) 
[10:59:35.916]                             next
[10:59:35.916]                           invokeRestart(restart)
[10:59:35.916]                           muffled <- TRUE
[10:59:35.916]                           break
[10:59:35.916]                         }
[10:59:35.916]                       }
[10:59:35.916]                     }
[10:59:35.916]                     invisible(muffled)
[10:59:35.916]                   }
[10:59:35.916]                   muffleCondition(cond)
[10:59:35.916]                 })
[10:59:35.916]             }))
[10:59:35.916]             future::FutureResult(value = ...future.value$value, 
[10:59:35.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.916]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.916]                     ...future.globalenv.names))
[10:59:35.916]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.916]         }, condition = base::local({
[10:59:35.916]             c <- base::c
[10:59:35.916]             inherits <- base::inherits
[10:59:35.916]             invokeRestart <- base::invokeRestart
[10:59:35.916]             length <- base::length
[10:59:35.916]             list <- base::list
[10:59:35.916]             seq.int <- base::seq.int
[10:59:35.916]             signalCondition <- base::signalCondition
[10:59:35.916]             sys.calls <- base::sys.calls
[10:59:35.916]             `[[` <- base::`[[`
[10:59:35.916]             `+` <- base::`+`
[10:59:35.916]             `<<-` <- base::`<<-`
[10:59:35.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.916]                   3L)]
[10:59:35.916]             }
[10:59:35.916]             function(cond) {
[10:59:35.916]                 is_error <- inherits(cond, "error")
[10:59:35.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.916]                   NULL)
[10:59:35.916]                 if (is_error) {
[10:59:35.916]                   sessionInformation <- function() {
[10:59:35.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.916]                       search = base::search(), system = base::Sys.info())
[10:59:35.916]                   }
[10:59:35.916]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.916]                     cond$call), session = sessionInformation(), 
[10:59:35.916]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.916]                   signalCondition(cond)
[10:59:35.916]                 }
[10:59:35.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.916]                 "immediateCondition"))) {
[10:59:35.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.916]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.916]                   if (TRUE && !signal) {
[10:59:35.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.916]                     {
[10:59:35.916]                       inherits <- base::inherits
[10:59:35.916]                       invokeRestart <- base::invokeRestart
[10:59:35.916]                       is.null <- base::is.null
[10:59:35.916]                       muffled <- FALSE
[10:59:35.916]                       if (inherits(cond, "message")) {
[10:59:35.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.916]                         if (muffled) 
[10:59:35.916]                           invokeRestart("muffleMessage")
[10:59:35.916]                       }
[10:59:35.916]                       else if (inherits(cond, "warning")) {
[10:59:35.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.916]                         if (muffled) 
[10:59:35.916]                           invokeRestart("muffleWarning")
[10:59:35.916]                       }
[10:59:35.916]                       else if (inherits(cond, "condition")) {
[10:59:35.916]                         if (!is.null(pattern)) {
[10:59:35.916]                           computeRestarts <- base::computeRestarts
[10:59:35.916]                           grepl <- base::grepl
[10:59:35.916]                           restarts <- computeRestarts(cond)
[10:59:35.916]                           for (restart in restarts) {
[10:59:35.916]                             name <- restart$name
[10:59:35.916]                             if (is.null(name)) 
[10:59:35.916]                               next
[10:59:35.916]                             if (!grepl(pattern, name)) 
[10:59:35.916]                               next
[10:59:35.916]                             invokeRestart(restart)
[10:59:35.916]                             muffled <- TRUE
[10:59:35.916]                             break
[10:59:35.916]                           }
[10:59:35.916]                         }
[10:59:35.916]                       }
[10:59:35.916]                       invisible(muffled)
[10:59:35.916]                     }
[10:59:35.916]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.916]                   }
[10:59:35.916]                 }
[10:59:35.916]                 else {
[10:59:35.916]                   if (TRUE) {
[10:59:35.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.916]                     {
[10:59:35.916]                       inherits <- base::inherits
[10:59:35.916]                       invokeRestart <- base::invokeRestart
[10:59:35.916]                       is.null <- base::is.null
[10:59:35.916]                       muffled <- FALSE
[10:59:35.916]                       if (inherits(cond, "message")) {
[10:59:35.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.916]                         if (muffled) 
[10:59:35.916]                           invokeRestart("muffleMessage")
[10:59:35.916]                       }
[10:59:35.916]                       else if (inherits(cond, "warning")) {
[10:59:35.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.916]                         if (muffled) 
[10:59:35.916]                           invokeRestart("muffleWarning")
[10:59:35.916]                       }
[10:59:35.916]                       else if (inherits(cond, "condition")) {
[10:59:35.916]                         if (!is.null(pattern)) {
[10:59:35.916]                           computeRestarts <- base::computeRestarts
[10:59:35.916]                           grepl <- base::grepl
[10:59:35.916]                           restarts <- computeRestarts(cond)
[10:59:35.916]                           for (restart in restarts) {
[10:59:35.916]                             name <- restart$name
[10:59:35.916]                             if (is.null(name)) 
[10:59:35.916]                               next
[10:59:35.916]                             if (!grepl(pattern, name)) 
[10:59:35.916]                               next
[10:59:35.916]                             invokeRestart(restart)
[10:59:35.916]                             muffled <- TRUE
[10:59:35.916]                             break
[10:59:35.916]                           }
[10:59:35.916]                         }
[10:59:35.916]                       }
[10:59:35.916]                       invisible(muffled)
[10:59:35.916]                     }
[10:59:35.916]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.916]                   }
[10:59:35.916]                 }
[10:59:35.916]             }
[10:59:35.916]         }))
[10:59:35.916]     }, error = function(ex) {
[10:59:35.916]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.916]                 ...future.rng), started = ...future.startTime, 
[10:59:35.916]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.916]             version = "1.8"), class = "FutureResult")
[10:59:35.916]     }, finally = {
[10:59:35.916]         if (!identical(...future.workdir, getwd())) 
[10:59:35.916]             setwd(...future.workdir)
[10:59:35.916]         {
[10:59:35.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.916]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.916]             }
[10:59:35.916]             base::options(...future.oldOptions)
[10:59:35.916]             if (.Platform$OS.type == "windows") {
[10:59:35.916]                 old_names <- names(...future.oldEnvVars)
[10:59:35.916]                 envs <- base::Sys.getenv()
[10:59:35.916]                 names <- names(envs)
[10:59:35.916]                 common <- intersect(names, old_names)
[10:59:35.916]                 added <- setdiff(names, old_names)
[10:59:35.916]                 removed <- setdiff(old_names, names)
[10:59:35.916]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.916]                   envs[common]]
[10:59:35.916]                 NAMES <- toupper(changed)
[10:59:35.916]                 args <- list()
[10:59:35.916]                 for (kk in seq_along(NAMES)) {
[10:59:35.916]                   name <- changed[[kk]]
[10:59:35.916]                   NAME <- NAMES[[kk]]
[10:59:35.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.916]                     next
[10:59:35.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.916]                 }
[10:59:35.916]                 NAMES <- toupper(added)
[10:59:35.916]                 for (kk in seq_along(NAMES)) {
[10:59:35.916]                   name <- added[[kk]]
[10:59:35.916]                   NAME <- NAMES[[kk]]
[10:59:35.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.916]                     next
[10:59:35.916]                   args[[name]] <- ""
[10:59:35.916]                 }
[10:59:35.916]                 NAMES <- toupper(removed)
[10:59:35.916]                 for (kk in seq_along(NAMES)) {
[10:59:35.916]                   name <- removed[[kk]]
[10:59:35.916]                   NAME <- NAMES[[kk]]
[10:59:35.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.916]                     next
[10:59:35.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.916]                 }
[10:59:35.916]                 if (length(args) > 0) 
[10:59:35.916]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.916]             }
[10:59:35.916]             else {
[10:59:35.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.916]             }
[10:59:35.916]             {
[10:59:35.916]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.916]                   0L) {
[10:59:35.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.916]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.916]                   base::options(opts)
[10:59:35.916]                 }
[10:59:35.916]                 {
[10:59:35.916]                   {
[10:59:35.916]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.916]                     NULL
[10:59:35.916]                   }
[10:59:35.916]                   options(future.plan = NULL)
[10:59:35.916]                   if (is.na(NA_character_)) 
[10:59:35.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.916]                     .init = FALSE)
[10:59:35.916]                 }
[10:59:35.916]             }
[10:59:35.916]         }
[10:59:35.916]     })
[10:59:35.916]     if (TRUE) {
[10:59:35.916]         base::sink(type = "output", split = FALSE)
[10:59:35.916]         if (TRUE) {
[10:59:35.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.916]         }
[10:59:35.916]         else {
[10:59:35.916]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.916]         }
[10:59:35.916]         base::close(...future.stdout)
[10:59:35.916]         ...future.stdout <- NULL
[10:59:35.916]     }
[10:59:35.916]     ...future.result$conditions <- ...future.conditions
[10:59:35.916]     ...future.result$finished <- base::Sys.time()
[10:59:35.916]     ...future.result
[10:59:35.916] }
[10:59:35.919] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:59:35.919] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:59:35.919] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:59:35.919] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:35.920] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.920] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[10:59:35.920] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[10:59:35.920] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:35.920] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.921] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:35.921] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:35.921] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:59:35.922] MultisessionFuture started
[10:59:35.922] - Launch lazy future ... done
[10:59:35.922] run() for ‘MultisessionFuture’ ... done
[10:59:35.922] Created future:
[10:59:35.922] MultisessionFuture:
[10:59:35.922] Label: ‘future_mapply-2’
[10:59:35.922] Expression:
[10:59:35.922] {
[10:59:35.922]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.922]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.922]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.922]         on.exit(options(oopts), add = TRUE)
[10:59:35.922]     }
[10:59:35.922]     {
[10:59:35.922]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.922]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.922]         do.call(mapply, args = args)
[10:59:35.922]     }
[10:59:35.922] }
[10:59:35.922] Lazy evaluation: FALSE
[10:59:35.922] Asynchronous evaluation: TRUE
[10:59:35.922] Local evaluation: TRUE
[10:59:35.922] Environment: R_GlobalEnv
[10:59:35.922] Capture standard output: TRUE
[10:59:35.922] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.922] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.922] Packages: <none>
[10:59:35.922] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.922] Resolved: FALSE
[10:59:35.922] Value: <not collected>
[10:59:35.922] Conditions captured: <none>
[10:59:35.922] Early signaling: FALSE
[10:59:35.922] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.922] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.933] Chunk #2 of 3 ... DONE
[10:59:35.933] Chunk #3 of 3 ...
[10:59:35.933]  - Finding globals in '...' for chunk #3 ...
[10:59:35.934] getGlobalsAndPackages() ...
[10:59:35.934] Searching for globals...
[10:59:35.934] 
[10:59:35.934] Searching for globals ... DONE
[10:59:35.934] - globals: [0] <none>
[10:59:35.934] getGlobalsAndPackages() ... DONE
[10:59:35.934]    + additional globals found: [n=0] 
[10:59:35.934]    + additional namespaces needed: [n=0] 
[10:59:35.935]  - Finding globals in '...' for chunk #3 ... DONE
[10:59:35.935]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:59:35.935]  - seeds: <none>
[10:59:35.935]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.935] getGlobalsAndPackages() ...
[10:59:35.935] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.935] Resolving globals: FALSE
[10:59:35.935] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:35.936] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:35.936] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:35.936] 
[10:59:35.936] getGlobalsAndPackages() ... DONE
[10:59:35.936] run() for ‘Future’ ...
[10:59:35.936] - state: ‘created’
[10:59:35.937] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:35.950] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:35.950]   - Field: ‘node’
[10:59:35.950]   - Field: ‘label’
[10:59:35.950]   - Field: ‘local’
[10:59:35.950]   - Field: ‘owner’
[10:59:35.950]   - Field: ‘envir’
[10:59:35.951]   - Field: ‘workers’
[10:59:35.951]   - Field: ‘packages’
[10:59:35.951]   - Field: ‘gc’
[10:59:35.951]   - Field: ‘conditions’
[10:59:35.951]   - Field: ‘persistent’
[10:59:35.951]   - Field: ‘expr’
[10:59:35.951]   - Field: ‘uuid’
[10:59:35.951]   - Field: ‘seed’
[10:59:35.951]   - Field: ‘version’
[10:59:35.951]   - Field: ‘result’
[10:59:35.951]   - Field: ‘asynchronous’
[10:59:35.951]   - Field: ‘calls’
[10:59:35.951]   - Field: ‘globals’
[10:59:35.952]   - Field: ‘stdout’
[10:59:35.952]   - Field: ‘earlySignal’
[10:59:35.952]   - Field: ‘lazy’
[10:59:35.952]   - Field: ‘state’
[10:59:35.952] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:35.952] - Launch lazy future ...
[10:59:35.952] Packages needed by the future expression (n = 0): <none>
[10:59:35.952] Packages needed by future strategies (n = 0): <none>
[10:59:35.953] {
[10:59:35.953]     {
[10:59:35.953]         {
[10:59:35.953]             ...future.startTime <- base::Sys.time()
[10:59:35.953]             {
[10:59:35.953]                 {
[10:59:35.953]                   {
[10:59:35.953]                     {
[10:59:35.953]                       base::local({
[10:59:35.953]                         has_future <- base::requireNamespace("future", 
[10:59:35.953]                           quietly = TRUE)
[10:59:35.953]                         if (has_future) {
[10:59:35.953]                           ns <- base::getNamespace("future")
[10:59:35.953]                           version <- ns[[".package"]][["version"]]
[10:59:35.953]                           if (is.null(version)) 
[10:59:35.953]                             version <- utils::packageVersion("future")
[10:59:35.953]                         }
[10:59:35.953]                         else {
[10:59:35.953]                           version <- NULL
[10:59:35.953]                         }
[10:59:35.953]                         if (!has_future || version < "1.8.0") {
[10:59:35.953]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:35.953]                             "", base::R.version$version.string), 
[10:59:35.953]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:35.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:35.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:35.953]                               "release", "version")], collapse = " "), 
[10:59:35.953]                             hostname = base::Sys.info()[["nodename"]])
[10:59:35.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:35.953]                             info)
[10:59:35.953]                           info <- base::paste(info, collapse = "; ")
[10:59:35.953]                           if (!has_future) {
[10:59:35.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:35.953]                               info)
[10:59:35.953]                           }
[10:59:35.953]                           else {
[10:59:35.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:35.953]                               info, version)
[10:59:35.953]                           }
[10:59:35.953]                           base::stop(msg)
[10:59:35.953]                         }
[10:59:35.953]                       })
[10:59:35.953]                     }
[10:59:35.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:35.953]                     base::options(mc.cores = 1L)
[10:59:35.953]                   }
[10:59:35.953]                   ...future.strategy.old <- future::plan("list")
[10:59:35.953]                   options(future.plan = NULL)
[10:59:35.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:35.953]                 }
[10:59:35.953]                 ...future.workdir <- getwd()
[10:59:35.953]             }
[10:59:35.953]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:35.953]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:35.953]         }
[10:59:35.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:35.953]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:59:35.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:35.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:35.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:35.953]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:35.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:35.953]             base::names(...future.oldOptions))
[10:59:35.953]     }
[10:59:35.953]     if (FALSE) {
[10:59:35.953]     }
[10:59:35.953]     else {
[10:59:35.953]         if (TRUE) {
[10:59:35.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:35.953]                 open = "w")
[10:59:35.953]         }
[10:59:35.953]         else {
[10:59:35.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:35.953]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:35.953]         }
[10:59:35.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:35.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:35.953]             base::sink(type = "output", split = FALSE)
[10:59:35.953]             base::close(...future.stdout)
[10:59:35.953]         }, add = TRUE)
[10:59:35.953]     }
[10:59:35.953]     ...future.frame <- base::sys.nframe()
[10:59:35.953]     ...future.conditions <- base::list()
[10:59:35.953]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:35.953]     if (FALSE) {
[10:59:35.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:35.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:35.953]     }
[10:59:35.953]     ...future.result <- base::tryCatch({
[10:59:35.953]         base::withCallingHandlers({
[10:59:35.953]             ...future.value <- base::withVisible(base::local({
[10:59:35.953]                 ...future.makeSendCondition <- base::local({
[10:59:35.953]                   sendCondition <- NULL
[10:59:35.953]                   function(frame = 1L) {
[10:59:35.953]                     if (is.function(sendCondition)) 
[10:59:35.953]                       return(sendCondition)
[10:59:35.953]                     ns <- getNamespace("parallel")
[10:59:35.953]                     if (exists("sendData", mode = "function", 
[10:59:35.953]                       envir = ns)) {
[10:59:35.953]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:35.953]                         envir = ns)
[10:59:35.953]                       envir <- sys.frame(frame)
[10:59:35.953]                       master <- NULL
[10:59:35.953]                       while (!identical(envir, .GlobalEnv) && 
[10:59:35.953]                         !identical(envir, emptyenv())) {
[10:59:35.953]                         if (exists("master", mode = "list", envir = envir, 
[10:59:35.953]                           inherits = FALSE)) {
[10:59:35.953]                           master <- get("master", mode = "list", 
[10:59:35.953]                             envir = envir, inherits = FALSE)
[10:59:35.953]                           if (inherits(master, c("SOCKnode", 
[10:59:35.953]                             "SOCK0node"))) {
[10:59:35.953]                             sendCondition <<- function(cond) {
[10:59:35.953]                               data <- list(type = "VALUE", value = cond, 
[10:59:35.953]                                 success = TRUE)
[10:59:35.953]                               parallel_sendData(master, data)
[10:59:35.953]                             }
[10:59:35.953]                             return(sendCondition)
[10:59:35.953]                           }
[10:59:35.953]                         }
[10:59:35.953]                         frame <- frame + 1L
[10:59:35.953]                         envir <- sys.frame(frame)
[10:59:35.953]                       }
[10:59:35.953]                     }
[10:59:35.953]                     sendCondition <<- function(cond) NULL
[10:59:35.953]                   }
[10:59:35.953]                 })
[10:59:35.953]                 withCallingHandlers({
[10:59:35.953]                   {
[10:59:35.953]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.953]                     if (!identical(...future.globals.maxSize.org, 
[10:59:35.953]                       ...future.globals.maxSize)) {
[10:59:35.953]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.953]                       on.exit(options(oopts), add = TRUE)
[10:59:35.953]                     }
[10:59:35.953]                     {
[10:59:35.953]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.953]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:35.953]                         USE.NAMES = FALSE)
[10:59:35.953]                       do.call(mapply, args = args)
[10:59:35.953]                     }
[10:59:35.953]                   }
[10:59:35.953]                 }, immediateCondition = function(cond) {
[10:59:35.953]                   sendCondition <- ...future.makeSendCondition()
[10:59:35.953]                   sendCondition(cond)
[10:59:35.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.953]                   {
[10:59:35.953]                     inherits <- base::inherits
[10:59:35.953]                     invokeRestart <- base::invokeRestart
[10:59:35.953]                     is.null <- base::is.null
[10:59:35.953]                     muffled <- FALSE
[10:59:35.953]                     if (inherits(cond, "message")) {
[10:59:35.953]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:35.953]                       if (muffled) 
[10:59:35.953]                         invokeRestart("muffleMessage")
[10:59:35.953]                     }
[10:59:35.953]                     else if (inherits(cond, "warning")) {
[10:59:35.953]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:35.953]                       if (muffled) 
[10:59:35.953]                         invokeRestart("muffleWarning")
[10:59:35.953]                     }
[10:59:35.953]                     else if (inherits(cond, "condition")) {
[10:59:35.953]                       if (!is.null(pattern)) {
[10:59:35.953]                         computeRestarts <- base::computeRestarts
[10:59:35.953]                         grepl <- base::grepl
[10:59:35.953]                         restarts <- computeRestarts(cond)
[10:59:35.953]                         for (restart in restarts) {
[10:59:35.953]                           name <- restart$name
[10:59:35.953]                           if (is.null(name)) 
[10:59:35.953]                             next
[10:59:35.953]                           if (!grepl(pattern, name)) 
[10:59:35.953]                             next
[10:59:35.953]                           invokeRestart(restart)
[10:59:35.953]                           muffled <- TRUE
[10:59:35.953]                           break
[10:59:35.953]                         }
[10:59:35.953]                       }
[10:59:35.953]                     }
[10:59:35.953]                     invisible(muffled)
[10:59:35.953]                   }
[10:59:35.953]                   muffleCondition(cond)
[10:59:35.953]                 })
[10:59:35.953]             }))
[10:59:35.953]             future::FutureResult(value = ...future.value$value, 
[10:59:35.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.953]                   ...future.rng), globalenv = if (FALSE) 
[10:59:35.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:35.953]                     ...future.globalenv.names))
[10:59:35.953]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:35.953]         }, condition = base::local({
[10:59:35.953]             c <- base::c
[10:59:35.953]             inherits <- base::inherits
[10:59:35.953]             invokeRestart <- base::invokeRestart
[10:59:35.953]             length <- base::length
[10:59:35.953]             list <- base::list
[10:59:35.953]             seq.int <- base::seq.int
[10:59:35.953]             signalCondition <- base::signalCondition
[10:59:35.953]             sys.calls <- base::sys.calls
[10:59:35.953]             `[[` <- base::`[[`
[10:59:35.953]             `+` <- base::`+`
[10:59:35.953]             `<<-` <- base::`<<-`
[10:59:35.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:35.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:35.953]                   3L)]
[10:59:35.953]             }
[10:59:35.953]             function(cond) {
[10:59:35.953]                 is_error <- inherits(cond, "error")
[10:59:35.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:35.953]                   NULL)
[10:59:35.953]                 if (is_error) {
[10:59:35.953]                   sessionInformation <- function() {
[10:59:35.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:35.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:35.953]                       search = base::search(), system = base::Sys.info())
[10:59:35.953]                   }
[10:59:35.953]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:35.953]                     cond$call), session = sessionInformation(), 
[10:59:35.953]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:35.953]                   signalCondition(cond)
[10:59:35.953]                 }
[10:59:35.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:35.953]                 "immediateCondition"))) {
[10:59:35.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:35.953]                   ...future.conditions[[length(...future.conditions) + 
[10:59:35.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:35.953]                   if (TRUE && !signal) {
[10:59:35.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.953]                     {
[10:59:35.953]                       inherits <- base::inherits
[10:59:35.953]                       invokeRestart <- base::invokeRestart
[10:59:35.953]                       is.null <- base::is.null
[10:59:35.953]                       muffled <- FALSE
[10:59:35.953]                       if (inherits(cond, "message")) {
[10:59:35.953]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.953]                         if (muffled) 
[10:59:35.953]                           invokeRestart("muffleMessage")
[10:59:35.953]                       }
[10:59:35.953]                       else if (inherits(cond, "warning")) {
[10:59:35.953]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.953]                         if (muffled) 
[10:59:35.953]                           invokeRestart("muffleWarning")
[10:59:35.953]                       }
[10:59:35.953]                       else if (inherits(cond, "condition")) {
[10:59:35.953]                         if (!is.null(pattern)) {
[10:59:35.953]                           computeRestarts <- base::computeRestarts
[10:59:35.953]                           grepl <- base::grepl
[10:59:35.953]                           restarts <- computeRestarts(cond)
[10:59:35.953]                           for (restart in restarts) {
[10:59:35.953]                             name <- restart$name
[10:59:35.953]                             if (is.null(name)) 
[10:59:35.953]                               next
[10:59:35.953]                             if (!grepl(pattern, name)) 
[10:59:35.953]                               next
[10:59:35.953]                             invokeRestart(restart)
[10:59:35.953]                             muffled <- TRUE
[10:59:35.953]                             break
[10:59:35.953]                           }
[10:59:35.953]                         }
[10:59:35.953]                       }
[10:59:35.953]                       invisible(muffled)
[10:59:35.953]                     }
[10:59:35.953]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.953]                   }
[10:59:35.953]                 }
[10:59:35.953]                 else {
[10:59:35.953]                   if (TRUE) {
[10:59:35.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:35.953]                     {
[10:59:35.953]                       inherits <- base::inherits
[10:59:35.953]                       invokeRestart <- base::invokeRestart
[10:59:35.953]                       is.null <- base::is.null
[10:59:35.953]                       muffled <- FALSE
[10:59:35.953]                       if (inherits(cond, "message")) {
[10:59:35.953]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:35.953]                         if (muffled) 
[10:59:35.953]                           invokeRestart("muffleMessage")
[10:59:35.953]                       }
[10:59:35.953]                       else if (inherits(cond, "warning")) {
[10:59:35.953]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:35.953]                         if (muffled) 
[10:59:35.953]                           invokeRestart("muffleWarning")
[10:59:35.953]                       }
[10:59:35.953]                       else if (inherits(cond, "condition")) {
[10:59:35.953]                         if (!is.null(pattern)) {
[10:59:35.953]                           computeRestarts <- base::computeRestarts
[10:59:35.953]                           grepl <- base::grepl
[10:59:35.953]                           restarts <- computeRestarts(cond)
[10:59:35.953]                           for (restart in restarts) {
[10:59:35.953]                             name <- restart$name
[10:59:35.953]                             if (is.null(name)) 
[10:59:35.953]                               next
[10:59:35.953]                             if (!grepl(pattern, name)) 
[10:59:35.953]                               next
[10:59:35.953]                             invokeRestart(restart)
[10:59:35.953]                             muffled <- TRUE
[10:59:35.953]                             break
[10:59:35.953]                           }
[10:59:35.953]                         }
[10:59:35.953]                       }
[10:59:35.953]                       invisible(muffled)
[10:59:35.953]                     }
[10:59:35.953]                     muffleCondition(cond, pattern = "^muffle")
[10:59:35.953]                   }
[10:59:35.953]                 }
[10:59:35.953]             }
[10:59:35.953]         }))
[10:59:35.953]     }, error = function(ex) {
[10:59:35.953]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:35.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:35.953]                 ...future.rng), started = ...future.startTime, 
[10:59:35.953]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:35.953]             version = "1.8"), class = "FutureResult")
[10:59:35.953]     }, finally = {
[10:59:35.953]         if (!identical(...future.workdir, getwd())) 
[10:59:35.953]             setwd(...future.workdir)
[10:59:35.953]         {
[10:59:35.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:35.953]                 ...future.oldOptions$nwarnings <- NULL
[10:59:35.953]             }
[10:59:35.953]             base::options(...future.oldOptions)
[10:59:35.953]             if (.Platform$OS.type == "windows") {
[10:59:35.953]                 old_names <- names(...future.oldEnvVars)
[10:59:35.953]                 envs <- base::Sys.getenv()
[10:59:35.953]                 names <- names(envs)
[10:59:35.953]                 common <- intersect(names, old_names)
[10:59:35.953]                 added <- setdiff(names, old_names)
[10:59:35.953]                 removed <- setdiff(old_names, names)
[10:59:35.953]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:35.953]                   envs[common]]
[10:59:35.953]                 NAMES <- toupper(changed)
[10:59:35.953]                 args <- list()
[10:59:35.953]                 for (kk in seq_along(NAMES)) {
[10:59:35.953]                   name <- changed[[kk]]
[10:59:35.953]                   NAME <- NAMES[[kk]]
[10:59:35.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.953]                     next
[10:59:35.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.953]                 }
[10:59:35.953]                 NAMES <- toupper(added)
[10:59:35.953]                 for (kk in seq_along(NAMES)) {
[10:59:35.953]                   name <- added[[kk]]
[10:59:35.953]                   NAME <- NAMES[[kk]]
[10:59:35.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.953]                     next
[10:59:35.953]                   args[[name]] <- ""
[10:59:35.953]                 }
[10:59:35.953]                 NAMES <- toupper(removed)
[10:59:35.953]                 for (kk in seq_along(NAMES)) {
[10:59:35.953]                   name <- removed[[kk]]
[10:59:35.953]                   NAME <- NAMES[[kk]]
[10:59:35.953]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:35.953]                     next
[10:59:35.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:35.953]                 }
[10:59:35.953]                 if (length(args) > 0) 
[10:59:35.953]                   base::do.call(base::Sys.setenv, args = args)
[10:59:35.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:35.953]             }
[10:59:35.953]             else {
[10:59:35.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:35.953]             }
[10:59:35.953]             {
[10:59:35.953]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:35.953]                   0L) {
[10:59:35.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:35.953]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:35.953]                   base::options(opts)
[10:59:35.953]                 }
[10:59:35.953]                 {
[10:59:35.953]                   {
[10:59:35.953]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:35.953]                     NULL
[10:59:35.953]                   }
[10:59:35.953]                   options(future.plan = NULL)
[10:59:35.953]                   if (is.na(NA_character_)) 
[10:59:35.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:35.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:35.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:35.953]                     .init = FALSE)
[10:59:35.953]                 }
[10:59:35.953]             }
[10:59:35.953]         }
[10:59:35.953]     })
[10:59:35.953]     if (TRUE) {
[10:59:35.953]         base::sink(type = "output", split = FALSE)
[10:59:35.953]         if (TRUE) {
[10:59:35.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:35.953]         }
[10:59:35.953]         else {
[10:59:35.953]             ...future.result["stdout"] <- base::list(NULL)
[10:59:35.953]         }
[10:59:35.953]         base::close(...future.stdout)
[10:59:35.953]         ...future.stdout <- NULL
[10:59:35.953]     }
[10:59:35.953]     ...future.result$conditions <- ...future.conditions
[10:59:35.953]     ...future.result$finished <- base::Sys.time()
[10:59:35.953]     ...future.result
[10:59:35.953] }
[10:59:35.955] Poll #1 (0): usedNodes() = 2, workers = 2
[10:59:35.966] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.966] - Validating connection of MultisessionFuture
[10:59:35.966] - received message: FutureResult
[10:59:35.966] - Received FutureResult
[10:59:35.966] - Erased future from FutureRegistry
[10:59:35.966] result() for ClusterFuture ...
[10:59:35.966] - result already collected: FutureResult
[10:59:35.966] result() for ClusterFuture ... done
[10:59:35.967] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.967] result() for ClusterFuture ...
[10:59:35.967] - result already collected: FutureResult
[10:59:35.967] result() for ClusterFuture ... done
[10:59:35.967] result() for ClusterFuture ...
[10:59:35.967] - result already collected: FutureResult
[10:59:35.967] result() for ClusterFuture ... done
[10:59:35.968] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[10:59:35.968] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:35.968] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:35.968] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:35.969] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.969] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:59:35.969] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:59:35.969] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:35.970] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.970] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:35.970] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:35.970] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[10:59:35.971] MultisessionFuture started
[10:59:35.971] - Launch lazy future ... done
[10:59:35.971] run() for ‘MultisessionFuture’ ... done
[10:59:35.971] Created future:
[10:59:35.971] MultisessionFuture:
[10:59:35.971] Label: ‘future_mapply-3’
[10:59:35.971] Expression:
[10:59:35.971] {
[10:59:35.971]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:35.971]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:35.971]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:35.971]         on.exit(options(oopts), add = TRUE)
[10:59:35.971]     }
[10:59:35.971]     {
[10:59:35.971]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:35.971]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:35.971]         do.call(mapply, args = args)
[10:59:35.971]     }
[10:59:35.971] }
[10:59:35.971] Lazy evaluation: FALSE
[10:59:35.971] Asynchronous evaluation: TRUE
[10:59:35.971] Local evaluation: TRUE
[10:59:35.971] Environment: R_GlobalEnv
[10:59:35.971] Capture standard output: TRUE
[10:59:35.971] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:35.971] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:35.971] Packages: <none>
[10:59:35.971] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:35.971] Resolved: FALSE
[10:59:35.971] Value: <not collected>
[10:59:35.971] Conditions captured: <none>
[10:59:35.971] Early signaling: FALSE
[10:59:35.971] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:35.971] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:35.982] Chunk #3 of 3 ... DONE
[10:59:35.982] Launching 3 futures (chunks) ... DONE
[10:59:35.982] Resolving 3 futures (chunks) ...
[10:59:35.983] resolve() on list ...
[10:59:35.983]  recursive: 0
[10:59:35.983]  length: 3
[10:59:35.983] 
[10:59:35.983] Future #1
[10:59:35.983] result() for ClusterFuture ...
[10:59:35.983] - result already collected: FutureResult
[10:59:35.983] result() for ClusterFuture ... done
[10:59:35.983] result() for ClusterFuture ...
[10:59:35.983] - result already collected: FutureResult
[10:59:35.984] result() for ClusterFuture ... done
[10:59:35.984] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:35.984] - nx: 3
[10:59:35.984] - relay: TRUE
[10:59:35.984] - stdout: TRUE
[10:59:35.984] - signal: TRUE
[10:59:35.984] - resignal: FALSE
[10:59:35.984] - force: TRUE
[10:59:35.984] - relayed: [n=3] FALSE, FALSE, FALSE
[10:59:35.984] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:59:35.984]  - until=1
[10:59:35.984]  - relaying element #1
[10:59:35.984] result() for ClusterFuture ...
[10:59:35.985] - result already collected: FutureResult
[10:59:35.985] result() for ClusterFuture ... done
[10:59:35.985] result() for ClusterFuture ...
[10:59:35.985] - result already collected: FutureResult
[10:59:35.985] result() for ClusterFuture ... done
[10:59:35.985] result() for ClusterFuture ...
[10:59:35.985] - result already collected: FutureResult
[10:59:35.985] result() for ClusterFuture ... done
[10:59:35.985] result() for ClusterFuture ...
[10:59:35.985] - result already collected: FutureResult
[10:59:35.985] result() for ClusterFuture ... done
[10:59:35.985] - relayed: [n=3] TRUE, FALSE, FALSE
[10:59:35.986] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:59:35.986] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:35.986]  length: 2 (resolved future 1)
[10:59:35.986] receiveMessageFromWorker() for ClusterFuture ...
[10:59:35.986] - Validating connection of MultisessionFuture
[10:59:35.986] - received message: FutureResult
[10:59:35.987] - Received FutureResult
[10:59:35.987] - Erased future from FutureRegistry
[10:59:35.987] result() for ClusterFuture ...
[10:59:35.987] - result already collected: FutureResult
[10:59:35.987] result() for ClusterFuture ... done
[10:59:35.987] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:35.987] Future #2
[10:59:35.987] result() for ClusterFuture ...
[10:59:35.987] - result already collected: FutureResult
[10:59:35.987] result() for ClusterFuture ... done
[10:59:35.987] result() for ClusterFuture ...
[10:59:35.987] - result already collected: FutureResult
[10:59:35.987] result() for ClusterFuture ... done
[10:59:35.988] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:35.988] - nx: 3
[10:59:35.988] - relay: TRUE
[10:59:35.988] - stdout: TRUE
[10:59:35.988] - signal: TRUE
[10:59:35.988] - resignal: FALSE
[10:59:35.988] - force: TRUE
[10:59:35.988] - relayed: [n=3] TRUE, FALSE, FALSE
[10:59:35.988] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:59:35.988]  - until=2
[10:59:35.988]  - relaying element #2
[10:59:35.988] result() for ClusterFuture ...
[10:59:35.989] - result already collected: FutureResult
[10:59:35.989] result() for ClusterFuture ... done
[10:59:35.989] result() for ClusterFuture ...
[10:59:35.989] - result already collected: FutureResult
[10:59:35.989] result() for ClusterFuture ... done
[10:59:35.989] result() for ClusterFuture ...
[10:59:35.989] - result already collected: FutureResult
[10:59:35.989] result() for ClusterFuture ... done
[10:59:35.989] result() for ClusterFuture ...
[10:59:35.989] - result already collected: FutureResult
[10:59:35.989] result() for ClusterFuture ... done
[10:59:35.989] - relayed: [n=3] TRUE, TRUE, FALSE
[10:59:35.990] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:59:35.990] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:35.990]  length: 1 (resolved future 2)
[10:59:36.013] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.013] - Validating connection of MultisessionFuture
[10:59:36.013] - received message: FutureResult
[10:59:36.013] - Received FutureResult
[10:59:36.014] - Erased future from FutureRegistry
[10:59:36.014] result() for ClusterFuture ...
[10:59:36.014] - result already collected: FutureResult
[10:59:36.014] result() for ClusterFuture ... done
[10:59:36.014] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.014] Future #3
[10:59:36.014] result() for ClusterFuture ...
[10:59:36.014] - result already collected: FutureResult
[10:59:36.014] result() for ClusterFuture ... done
[10:59:36.014] result() for ClusterFuture ...
[10:59:36.014] - result already collected: FutureResult
[10:59:36.014] result() for ClusterFuture ... done
[10:59:36.015] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:59:36.015] - nx: 3
[10:59:36.015] - relay: TRUE
[10:59:36.015] - stdout: TRUE
[10:59:36.015] - signal: TRUE
[10:59:36.015] - resignal: FALSE
[10:59:36.015] - force: TRUE
[10:59:36.015] - relayed: [n=3] TRUE, TRUE, FALSE
[10:59:36.015] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:59:36.015]  - until=3
[10:59:36.015]  - relaying element #3
[10:59:36.015] result() for ClusterFuture ...
[10:59:36.015] - result already collected: FutureResult
[10:59:36.016] result() for ClusterFuture ... done
[10:59:36.016] result() for ClusterFuture ...
[10:59:36.016] - result already collected: FutureResult
[10:59:36.016] result() for ClusterFuture ... done
[10:59:36.016] result() for ClusterFuture ...
[10:59:36.016] - result already collected: FutureResult
[10:59:36.016] result() for ClusterFuture ... done
[10:59:36.016] result() for ClusterFuture ...
[10:59:36.016] - result already collected: FutureResult
[10:59:36.016] result() for ClusterFuture ... done
[10:59:36.016] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:36.016] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:59:36.017] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:59:36.017]  length: 0 (resolved future 3)
[10:59:36.017] Relaying remaining futures
[10:59:36.017] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.017] - nx: 3
[10:59:36.017] - relay: TRUE
[10:59:36.017] - stdout: TRUE
[10:59:36.017] - signal: TRUE
[10:59:36.017] - resignal: FALSE
[10:59:36.017] - force: TRUE
[10:59:36.017] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:36.019] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:59:36.019] - relayed: [n=3] TRUE, TRUE, TRUE
[10:59:36.020] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:59:36.020] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.020] resolve() on list ... DONE
[10:59:36.020] result() for ClusterFuture ...
[10:59:36.020] - result already collected: FutureResult
[10:59:36.020] result() for ClusterFuture ... done
[10:59:36.020] result() for ClusterFuture ...
[10:59:36.020] - result already collected: FutureResult
[10:59:36.020] result() for ClusterFuture ... done
[10:59:36.020] result() for ClusterFuture ...
[10:59:36.020] - result already collected: FutureResult
[10:59:36.020] result() for ClusterFuture ... done
[10:59:36.021] result() for ClusterFuture ...
[10:59:36.021] - result already collected: FutureResult
[10:59:36.021] result() for ClusterFuture ... done
[10:59:36.021] result() for ClusterFuture ...
[10:59:36.021] - result already collected: FutureResult
[10:59:36.021] result() for ClusterFuture ... done
[10:59:36.021] result() for ClusterFuture ...
[10:59:36.021] - result already collected: FutureResult
[10:59:36.021] result() for ClusterFuture ... done
[10:59:36.021]  - Number of value chunks collected: 3
[10:59:36.021] Resolving 3 futures (chunks) ... DONE
[10:59:36.021] Reducing values from 3 chunks ...
[10:59:36.021]  - Number of values collected after concatenation: 5
[10:59:36.022]  - Number of values expected: 5
[10:59:36.022] Reverse index remapping (attribute 'ordering'): [n = 5] 2, 5, 3, 1, 4
[10:59:36.022] Reducing values from 3 chunks ... DONE
[10:59:36.022] future_mapply() ... DONE
[10:59:36.022] future_mapply() ...
[10:59:36.024] Number of chunks: 2
[10:59:36.024] getGlobalsAndPackagesXApply() ...
[10:59:36.024]  - future.globals: TRUE
[10:59:36.024] getGlobalsAndPackages() ...
[10:59:36.024] Searching for globals...
[10:59:36.025] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:36.025] Searching for globals ... DONE
[10:59:36.025] Resolving globals: FALSE
[10:59:36.026] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:36.026] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:36.026] - globals: [1] ‘FUN’
[10:59:36.026] 
[10:59:36.026] getGlobalsAndPackages() ... DONE
[10:59:36.026]  - globals found/used: [n=1] ‘FUN’
[10:59:36.026]  - needed namespaces: [n=0] 
[10:59:36.026] Finding globals ... DONE
[10:59:36.027] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.027] List of 2
[10:59:36.027]  $ ...future.FUN:function (C, k)  
[10:59:36.027]  $ MoreArgs     : list()
[10:59:36.027]  - attr(*, "where")=List of 2
[10:59:36.027]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.027]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.027]  - attr(*, "resolved")= logi FALSE
[10:59:36.027]  - attr(*, "total_size")= num NA
[10:59:36.029] Packages to be attached in all futures: [n=0] 
[10:59:36.029] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.029] Number of futures (= number of chunks): 2
[10:59:36.029] Launching 2 futures (chunks) ...
[10:59:36.030] Chunk #1 of 2 ...
[10:59:36.030]  - Finding globals in '...' for chunk #1 ...
[10:59:36.030] getGlobalsAndPackages() ...
[10:59:36.030] Searching for globals...
[10:59:36.030] 
[10:59:36.030] Searching for globals ... DONE
[10:59:36.030] - globals: [0] <none>
[10:59:36.030] getGlobalsAndPackages() ... DONE
[10:59:36.030]    + additional globals found: [n=0] 
[10:59:36.031]    + additional namespaces needed: [n=0] 
[10:59:36.031]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.031]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.031]  - seeds: <none>
[10:59:36.031]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.031] getGlobalsAndPackages() ...
[10:59:36.031] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.031] Resolving globals: FALSE
[10:59:36.031] The total size of the 5 globals is 880 bytes (880 bytes)
[10:59:36.032] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:36.032] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.032] 
[10:59:36.032] getGlobalsAndPackages() ... DONE
[10:59:36.032] run() for ‘Future’ ...
[10:59:36.033] - state: ‘created’
[10:59:36.033] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.046] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.046]   - Field: ‘node’
[10:59:36.046]   - Field: ‘label’
[10:59:36.046]   - Field: ‘local’
[10:59:36.046]   - Field: ‘owner’
[10:59:36.046]   - Field: ‘envir’
[10:59:36.047]   - Field: ‘workers’
[10:59:36.047]   - Field: ‘packages’
[10:59:36.047]   - Field: ‘gc’
[10:59:36.047]   - Field: ‘conditions’
[10:59:36.047]   - Field: ‘persistent’
[10:59:36.047]   - Field: ‘expr’
[10:59:36.047]   - Field: ‘uuid’
[10:59:36.047]   - Field: ‘seed’
[10:59:36.047]   - Field: ‘version’
[10:59:36.047]   - Field: ‘result’
[10:59:36.047]   - Field: ‘asynchronous’
[10:59:36.047]   - Field: ‘calls’
[10:59:36.047]   - Field: ‘globals’
[10:59:36.048]   - Field: ‘stdout’
[10:59:36.048]   - Field: ‘earlySignal’
[10:59:36.048]   - Field: ‘lazy’
[10:59:36.048]   - Field: ‘state’
[10:59:36.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.048] - Launch lazy future ...
[10:59:36.048] Packages needed by the future expression (n = 0): <none>
[10:59:36.048] Packages needed by future strategies (n = 0): <none>
[10:59:36.049] {
[10:59:36.049]     {
[10:59:36.049]         {
[10:59:36.049]             ...future.startTime <- base::Sys.time()
[10:59:36.049]             {
[10:59:36.049]                 {
[10:59:36.049]                   {
[10:59:36.049]                     {
[10:59:36.049]                       base::local({
[10:59:36.049]                         has_future <- base::requireNamespace("future", 
[10:59:36.049]                           quietly = TRUE)
[10:59:36.049]                         if (has_future) {
[10:59:36.049]                           ns <- base::getNamespace("future")
[10:59:36.049]                           version <- ns[[".package"]][["version"]]
[10:59:36.049]                           if (is.null(version)) 
[10:59:36.049]                             version <- utils::packageVersion("future")
[10:59:36.049]                         }
[10:59:36.049]                         else {
[10:59:36.049]                           version <- NULL
[10:59:36.049]                         }
[10:59:36.049]                         if (!has_future || version < "1.8.0") {
[10:59:36.049]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.049]                             "", base::R.version$version.string), 
[10:59:36.049]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.049]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.049]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.049]                               "release", "version")], collapse = " "), 
[10:59:36.049]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.049]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.049]                             info)
[10:59:36.049]                           info <- base::paste(info, collapse = "; ")
[10:59:36.049]                           if (!has_future) {
[10:59:36.049]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.049]                               info)
[10:59:36.049]                           }
[10:59:36.049]                           else {
[10:59:36.049]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.049]                               info, version)
[10:59:36.049]                           }
[10:59:36.049]                           base::stop(msg)
[10:59:36.049]                         }
[10:59:36.049]                       })
[10:59:36.049]                     }
[10:59:36.049]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.049]                     base::options(mc.cores = 1L)
[10:59:36.049]                   }
[10:59:36.049]                   ...future.strategy.old <- future::plan("list")
[10:59:36.049]                   options(future.plan = NULL)
[10:59:36.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.049]                 }
[10:59:36.049]                 ...future.workdir <- getwd()
[10:59:36.049]             }
[10:59:36.049]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.049]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.049]         }
[10:59:36.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.049]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.049]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.049]             base::names(...future.oldOptions))
[10:59:36.049]     }
[10:59:36.049]     if (FALSE) {
[10:59:36.049]     }
[10:59:36.049]     else {
[10:59:36.049]         if (TRUE) {
[10:59:36.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.049]                 open = "w")
[10:59:36.049]         }
[10:59:36.049]         else {
[10:59:36.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.049]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.049]         }
[10:59:36.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.049]             base::sink(type = "output", split = FALSE)
[10:59:36.049]             base::close(...future.stdout)
[10:59:36.049]         }, add = TRUE)
[10:59:36.049]     }
[10:59:36.049]     ...future.frame <- base::sys.nframe()
[10:59:36.049]     ...future.conditions <- base::list()
[10:59:36.049]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.049]     if (FALSE) {
[10:59:36.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.049]     }
[10:59:36.049]     ...future.result <- base::tryCatch({
[10:59:36.049]         base::withCallingHandlers({
[10:59:36.049]             ...future.value <- base::withVisible(base::local({
[10:59:36.049]                 ...future.makeSendCondition <- base::local({
[10:59:36.049]                   sendCondition <- NULL
[10:59:36.049]                   function(frame = 1L) {
[10:59:36.049]                     if (is.function(sendCondition)) 
[10:59:36.049]                       return(sendCondition)
[10:59:36.049]                     ns <- getNamespace("parallel")
[10:59:36.049]                     if (exists("sendData", mode = "function", 
[10:59:36.049]                       envir = ns)) {
[10:59:36.049]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.049]                         envir = ns)
[10:59:36.049]                       envir <- sys.frame(frame)
[10:59:36.049]                       master <- NULL
[10:59:36.049]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.049]                         !identical(envir, emptyenv())) {
[10:59:36.049]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.049]                           inherits = FALSE)) {
[10:59:36.049]                           master <- get("master", mode = "list", 
[10:59:36.049]                             envir = envir, inherits = FALSE)
[10:59:36.049]                           if (inherits(master, c("SOCKnode", 
[10:59:36.049]                             "SOCK0node"))) {
[10:59:36.049]                             sendCondition <<- function(cond) {
[10:59:36.049]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.049]                                 success = TRUE)
[10:59:36.049]                               parallel_sendData(master, data)
[10:59:36.049]                             }
[10:59:36.049]                             return(sendCondition)
[10:59:36.049]                           }
[10:59:36.049]                         }
[10:59:36.049]                         frame <- frame + 1L
[10:59:36.049]                         envir <- sys.frame(frame)
[10:59:36.049]                       }
[10:59:36.049]                     }
[10:59:36.049]                     sendCondition <<- function(cond) NULL
[10:59:36.049]                   }
[10:59:36.049]                 })
[10:59:36.049]                 withCallingHandlers({
[10:59:36.049]                   {
[10:59:36.049]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.049]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.049]                       ...future.globals.maxSize)) {
[10:59:36.049]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.049]                       on.exit(options(oopts), add = TRUE)
[10:59:36.049]                     }
[10:59:36.049]                     {
[10:59:36.049]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.049]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.049]                         USE.NAMES = FALSE)
[10:59:36.049]                       do.call(mapply, args = args)
[10:59:36.049]                     }
[10:59:36.049]                   }
[10:59:36.049]                 }, immediateCondition = function(cond) {
[10:59:36.049]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.049]                   sendCondition(cond)
[10:59:36.049]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.049]                   {
[10:59:36.049]                     inherits <- base::inherits
[10:59:36.049]                     invokeRestart <- base::invokeRestart
[10:59:36.049]                     is.null <- base::is.null
[10:59:36.049]                     muffled <- FALSE
[10:59:36.049]                     if (inherits(cond, "message")) {
[10:59:36.049]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.049]                       if (muffled) 
[10:59:36.049]                         invokeRestart("muffleMessage")
[10:59:36.049]                     }
[10:59:36.049]                     else if (inherits(cond, "warning")) {
[10:59:36.049]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.049]                       if (muffled) 
[10:59:36.049]                         invokeRestart("muffleWarning")
[10:59:36.049]                     }
[10:59:36.049]                     else if (inherits(cond, "condition")) {
[10:59:36.049]                       if (!is.null(pattern)) {
[10:59:36.049]                         computeRestarts <- base::computeRestarts
[10:59:36.049]                         grepl <- base::grepl
[10:59:36.049]                         restarts <- computeRestarts(cond)
[10:59:36.049]                         for (restart in restarts) {
[10:59:36.049]                           name <- restart$name
[10:59:36.049]                           if (is.null(name)) 
[10:59:36.049]                             next
[10:59:36.049]                           if (!grepl(pattern, name)) 
[10:59:36.049]                             next
[10:59:36.049]                           invokeRestart(restart)
[10:59:36.049]                           muffled <- TRUE
[10:59:36.049]                           break
[10:59:36.049]                         }
[10:59:36.049]                       }
[10:59:36.049]                     }
[10:59:36.049]                     invisible(muffled)
[10:59:36.049]                   }
[10:59:36.049]                   muffleCondition(cond)
[10:59:36.049]                 })
[10:59:36.049]             }))
[10:59:36.049]             future::FutureResult(value = ...future.value$value, 
[10:59:36.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.049]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.049]                     ...future.globalenv.names))
[10:59:36.049]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.049]         }, condition = base::local({
[10:59:36.049]             c <- base::c
[10:59:36.049]             inherits <- base::inherits
[10:59:36.049]             invokeRestart <- base::invokeRestart
[10:59:36.049]             length <- base::length
[10:59:36.049]             list <- base::list
[10:59:36.049]             seq.int <- base::seq.int
[10:59:36.049]             signalCondition <- base::signalCondition
[10:59:36.049]             sys.calls <- base::sys.calls
[10:59:36.049]             `[[` <- base::`[[`
[10:59:36.049]             `+` <- base::`+`
[10:59:36.049]             `<<-` <- base::`<<-`
[10:59:36.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.049]                   3L)]
[10:59:36.049]             }
[10:59:36.049]             function(cond) {
[10:59:36.049]                 is_error <- inherits(cond, "error")
[10:59:36.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.049]                   NULL)
[10:59:36.049]                 if (is_error) {
[10:59:36.049]                   sessionInformation <- function() {
[10:59:36.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.049]                       search = base::search(), system = base::Sys.info())
[10:59:36.049]                   }
[10:59:36.049]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.049]                     cond$call), session = sessionInformation(), 
[10:59:36.049]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.049]                   signalCondition(cond)
[10:59:36.049]                 }
[10:59:36.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.049]                 "immediateCondition"))) {
[10:59:36.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.049]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.049]                   if (TRUE && !signal) {
[10:59:36.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.049]                     {
[10:59:36.049]                       inherits <- base::inherits
[10:59:36.049]                       invokeRestart <- base::invokeRestart
[10:59:36.049]                       is.null <- base::is.null
[10:59:36.049]                       muffled <- FALSE
[10:59:36.049]                       if (inherits(cond, "message")) {
[10:59:36.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.049]                         if (muffled) 
[10:59:36.049]                           invokeRestart("muffleMessage")
[10:59:36.049]                       }
[10:59:36.049]                       else if (inherits(cond, "warning")) {
[10:59:36.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.049]                         if (muffled) 
[10:59:36.049]                           invokeRestart("muffleWarning")
[10:59:36.049]                       }
[10:59:36.049]                       else if (inherits(cond, "condition")) {
[10:59:36.049]                         if (!is.null(pattern)) {
[10:59:36.049]                           computeRestarts <- base::computeRestarts
[10:59:36.049]                           grepl <- base::grepl
[10:59:36.049]                           restarts <- computeRestarts(cond)
[10:59:36.049]                           for (restart in restarts) {
[10:59:36.049]                             name <- restart$name
[10:59:36.049]                             if (is.null(name)) 
[10:59:36.049]                               next
[10:59:36.049]                             if (!grepl(pattern, name)) 
[10:59:36.049]                               next
[10:59:36.049]                             invokeRestart(restart)
[10:59:36.049]                             muffled <- TRUE
[10:59:36.049]                             break
[10:59:36.049]                           }
[10:59:36.049]                         }
[10:59:36.049]                       }
[10:59:36.049]                       invisible(muffled)
[10:59:36.049]                     }
[10:59:36.049]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.049]                   }
[10:59:36.049]                 }
[10:59:36.049]                 else {
[10:59:36.049]                   if (TRUE) {
[10:59:36.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.049]                     {
[10:59:36.049]                       inherits <- base::inherits
[10:59:36.049]                       invokeRestart <- base::invokeRestart
[10:59:36.049]                       is.null <- base::is.null
[10:59:36.049]                       muffled <- FALSE
[10:59:36.049]                       if (inherits(cond, "message")) {
[10:59:36.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.049]                         if (muffled) 
[10:59:36.049]                           invokeRestart("muffleMessage")
[10:59:36.049]                       }
[10:59:36.049]                       else if (inherits(cond, "warning")) {
[10:59:36.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.049]                         if (muffled) 
[10:59:36.049]                           invokeRestart("muffleWarning")
[10:59:36.049]                       }
[10:59:36.049]                       else if (inherits(cond, "condition")) {
[10:59:36.049]                         if (!is.null(pattern)) {
[10:59:36.049]                           computeRestarts <- base::computeRestarts
[10:59:36.049]                           grepl <- base::grepl
[10:59:36.049]                           restarts <- computeRestarts(cond)
[10:59:36.049]                           for (restart in restarts) {
[10:59:36.049]                             name <- restart$name
[10:59:36.049]                             if (is.null(name)) 
[10:59:36.049]                               next
[10:59:36.049]                             if (!grepl(pattern, name)) 
[10:59:36.049]                               next
[10:59:36.049]                             invokeRestart(restart)
[10:59:36.049]                             muffled <- TRUE
[10:59:36.049]                             break
[10:59:36.049]                           }
[10:59:36.049]                         }
[10:59:36.049]                       }
[10:59:36.049]                       invisible(muffled)
[10:59:36.049]                     }
[10:59:36.049]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.049]                   }
[10:59:36.049]                 }
[10:59:36.049]             }
[10:59:36.049]         }))
[10:59:36.049]     }, error = function(ex) {
[10:59:36.049]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.049]                 ...future.rng), started = ...future.startTime, 
[10:59:36.049]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.049]             version = "1.8"), class = "FutureResult")
[10:59:36.049]     }, finally = {
[10:59:36.049]         if (!identical(...future.workdir, getwd())) 
[10:59:36.049]             setwd(...future.workdir)
[10:59:36.049]         {
[10:59:36.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.049]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.049]             }
[10:59:36.049]             base::options(...future.oldOptions)
[10:59:36.049]             if (.Platform$OS.type == "windows") {
[10:59:36.049]                 old_names <- names(...future.oldEnvVars)
[10:59:36.049]                 envs <- base::Sys.getenv()
[10:59:36.049]                 names <- names(envs)
[10:59:36.049]                 common <- intersect(names, old_names)
[10:59:36.049]                 added <- setdiff(names, old_names)
[10:59:36.049]                 removed <- setdiff(old_names, names)
[10:59:36.049]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.049]                   envs[common]]
[10:59:36.049]                 NAMES <- toupper(changed)
[10:59:36.049]                 args <- list()
[10:59:36.049]                 for (kk in seq_along(NAMES)) {
[10:59:36.049]                   name <- changed[[kk]]
[10:59:36.049]                   NAME <- NAMES[[kk]]
[10:59:36.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.049]                     next
[10:59:36.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.049]                 }
[10:59:36.049]                 NAMES <- toupper(added)
[10:59:36.049]                 for (kk in seq_along(NAMES)) {
[10:59:36.049]                   name <- added[[kk]]
[10:59:36.049]                   NAME <- NAMES[[kk]]
[10:59:36.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.049]                     next
[10:59:36.049]                   args[[name]] <- ""
[10:59:36.049]                 }
[10:59:36.049]                 NAMES <- toupper(removed)
[10:59:36.049]                 for (kk in seq_along(NAMES)) {
[10:59:36.049]                   name <- removed[[kk]]
[10:59:36.049]                   NAME <- NAMES[[kk]]
[10:59:36.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.049]                     next
[10:59:36.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.049]                 }
[10:59:36.049]                 if (length(args) > 0) 
[10:59:36.049]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.049]             }
[10:59:36.049]             else {
[10:59:36.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.049]             }
[10:59:36.049]             {
[10:59:36.049]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.049]                   0L) {
[10:59:36.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.049]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.049]                   base::options(opts)
[10:59:36.049]                 }
[10:59:36.049]                 {
[10:59:36.049]                   {
[10:59:36.049]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.049]                     NULL
[10:59:36.049]                   }
[10:59:36.049]                   options(future.plan = NULL)
[10:59:36.049]                   if (is.na(NA_character_)) 
[10:59:36.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.049]                     .init = FALSE)
[10:59:36.049]                 }
[10:59:36.049]             }
[10:59:36.049]         }
[10:59:36.049]     })
[10:59:36.049]     if (TRUE) {
[10:59:36.049]         base::sink(type = "output", split = FALSE)
[10:59:36.049]         if (TRUE) {
[10:59:36.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.049]         }
[10:59:36.049]         else {
[10:59:36.049]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.049]         }
[10:59:36.049]         base::close(...future.stdout)
[10:59:36.049]         ...future.stdout <- NULL
[10:59:36.049]     }
[10:59:36.049]     ...future.result$conditions <- ...future.conditions
[10:59:36.049]     ...future.result$finished <- base::Sys.time()
[10:59:36.049]     ...future.result
[10:59:36.049] }
[10:59:36.051] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[10:59:36.051] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:36.052] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:36.052] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:59:36.052] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:59:36.052] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:59:36.053] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:59:36.053] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.053] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.053] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.054] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.054] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[10:59:36.054] MultisessionFuture started
[10:59:36.054] - Launch lazy future ... done
[10:59:36.054] run() for ‘MultisessionFuture’ ... done
[10:59:36.055] Created future:
[10:59:36.055] MultisessionFuture:
[10:59:36.055] Label: ‘future_.mapply-1’
[10:59:36.055] Expression:
[10:59:36.055] {
[10:59:36.055]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.055]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.055]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.055]         on.exit(options(oopts), add = TRUE)
[10:59:36.055]     }
[10:59:36.055]     {
[10:59:36.055]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.055]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.055]         do.call(mapply, args = args)
[10:59:36.055]     }
[10:59:36.055] }
[10:59:36.055] Lazy evaluation: FALSE
[10:59:36.055] Asynchronous evaluation: TRUE
[10:59:36.055] Local evaluation: TRUE
[10:59:36.055] Environment: R_GlobalEnv
[10:59:36.055] Capture standard output: TRUE
[10:59:36.055] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.055] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.055] Packages: <none>
[10:59:36.055] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.055] Resolved: FALSE
[10:59:36.055] Value: <not collected>
[10:59:36.055] Conditions captured: <none>
[10:59:36.055] Early signaling: FALSE
[10:59:36.055] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.055] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.066] Chunk #1 of 2 ... DONE
[10:59:36.066] Chunk #2 of 2 ...
[10:59:36.066]  - Finding globals in '...' for chunk #2 ...
[10:59:36.066] getGlobalsAndPackages() ...
[10:59:36.066] Searching for globals...
[10:59:36.067] 
[10:59:36.067] Searching for globals ... DONE
[10:59:36.067] - globals: [0] <none>
[10:59:36.067] getGlobalsAndPackages() ... DONE
[10:59:36.067]    + additional globals found: [n=0] 
[10:59:36.067]    + additional namespaces needed: [n=0] 
[10:59:36.067]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:36.067]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.067]  - seeds: <none>
[10:59:36.067]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.068] getGlobalsAndPackages() ...
[10:59:36.068] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.068] Resolving globals: FALSE
[10:59:36.068] The total size of the 5 globals is 909 bytes (909 bytes)
[10:59:36.068] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:36.069] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.069] 
[10:59:36.069] getGlobalsAndPackages() ... DONE
[10:59:36.069] run() for ‘Future’ ...
[10:59:36.069] - state: ‘created’
[10:59:36.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.083]   - Field: ‘node’
[10:59:36.083]   - Field: ‘label’
[10:59:36.083]   - Field: ‘local’
[10:59:36.083]   - Field: ‘owner’
[10:59:36.083]   - Field: ‘envir’
[10:59:36.083]   - Field: ‘workers’
[10:59:36.084]   - Field: ‘packages’
[10:59:36.084]   - Field: ‘gc’
[10:59:36.084]   - Field: ‘conditions’
[10:59:36.084]   - Field: ‘persistent’
[10:59:36.084]   - Field: ‘expr’
[10:59:36.084]   - Field: ‘uuid’
[10:59:36.084]   - Field: ‘seed’
[10:59:36.084]   - Field: ‘version’
[10:59:36.084]   - Field: ‘result’
[10:59:36.084]   - Field: ‘asynchronous’
[10:59:36.084]   - Field: ‘calls’
[10:59:36.084]   - Field: ‘globals’
[10:59:36.085]   - Field: ‘stdout’
[10:59:36.085]   - Field: ‘earlySignal’
[10:59:36.085]   - Field: ‘lazy’
[10:59:36.085]   - Field: ‘state’
[10:59:36.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.085] - Launch lazy future ...
[10:59:36.085] Packages needed by the future expression (n = 0): <none>
[10:59:36.085] Packages needed by future strategies (n = 0): <none>
[10:59:36.086] {
[10:59:36.086]     {
[10:59:36.086]         {
[10:59:36.086]             ...future.startTime <- base::Sys.time()
[10:59:36.086]             {
[10:59:36.086]                 {
[10:59:36.086]                   {
[10:59:36.086]                     {
[10:59:36.086]                       base::local({
[10:59:36.086]                         has_future <- base::requireNamespace("future", 
[10:59:36.086]                           quietly = TRUE)
[10:59:36.086]                         if (has_future) {
[10:59:36.086]                           ns <- base::getNamespace("future")
[10:59:36.086]                           version <- ns[[".package"]][["version"]]
[10:59:36.086]                           if (is.null(version)) 
[10:59:36.086]                             version <- utils::packageVersion("future")
[10:59:36.086]                         }
[10:59:36.086]                         else {
[10:59:36.086]                           version <- NULL
[10:59:36.086]                         }
[10:59:36.086]                         if (!has_future || version < "1.8.0") {
[10:59:36.086]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.086]                             "", base::R.version$version.string), 
[10:59:36.086]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.086]                               "release", "version")], collapse = " "), 
[10:59:36.086]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.086]                             info)
[10:59:36.086]                           info <- base::paste(info, collapse = "; ")
[10:59:36.086]                           if (!has_future) {
[10:59:36.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.086]                               info)
[10:59:36.086]                           }
[10:59:36.086]                           else {
[10:59:36.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.086]                               info, version)
[10:59:36.086]                           }
[10:59:36.086]                           base::stop(msg)
[10:59:36.086]                         }
[10:59:36.086]                       })
[10:59:36.086]                     }
[10:59:36.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.086]                     base::options(mc.cores = 1L)
[10:59:36.086]                   }
[10:59:36.086]                   ...future.strategy.old <- future::plan("list")
[10:59:36.086]                   options(future.plan = NULL)
[10:59:36.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.086]                 }
[10:59:36.086]                 ...future.workdir <- getwd()
[10:59:36.086]             }
[10:59:36.086]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.086]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.086]         }
[10:59:36.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.086]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.086]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.086]             base::names(...future.oldOptions))
[10:59:36.086]     }
[10:59:36.086]     if (FALSE) {
[10:59:36.086]     }
[10:59:36.086]     else {
[10:59:36.086]         if (TRUE) {
[10:59:36.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.086]                 open = "w")
[10:59:36.086]         }
[10:59:36.086]         else {
[10:59:36.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.086]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.086]         }
[10:59:36.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.086]             base::sink(type = "output", split = FALSE)
[10:59:36.086]             base::close(...future.stdout)
[10:59:36.086]         }, add = TRUE)
[10:59:36.086]     }
[10:59:36.086]     ...future.frame <- base::sys.nframe()
[10:59:36.086]     ...future.conditions <- base::list()
[10:59:36.086]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.086]     if (FALSE) {
[10:59:36.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.086]     }
[10:59:36.086]     ...future.result <- base::tryCatch({
[10:59:36.086]         base::withCallingHandlers({
[10:59:36.086]             ...future.value <- base::withVisible(base::local({
[10:59:36.086]                 ...future.makeSendCondition <- base::local({
[10:59:36.086]                   sendCondition <- NULL
[10:59:36.086]                   function(frame = 1L) {
[10:59:36.086]                     if (is.function(sendCondition)) 
[10:59:36.086]                       return(sendCondition)
[10:59:36.086]                     ns <- getNamespace("parallel")
[10:59:36.086]                     if (exists("sendData", mode = "function", 
[10:59:36.086]                       envir = ns)) {
[10:59:36.086]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.086]                         envir = ns)
[10:59:36.086]                       envir <- sys.frame(frame)
[10:59:36.086]                       master <- NULL
[10:59:36.086]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.086]                         !identical(envir, emptyenv())) {
[10:59:36.086]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.086]                           inherits = FALSE)) {
[10:59:36.086]                           master <- get("master", mode = "list", 
[10:59:36.086]                             envir = envir, inherits = FALSE)
[10:59:36.086]                           if (inherits(master, c("SOCKnode", 
[10:59:36.086]                             "SOCK0node"))) {
[10:59:36.086]                             sendCondition <<- function(cond) {
[10:59:36.086]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.086]                                 success = TRUE)
[10:59:36.086]                               parallel_sendData(master, data)
[10:59:36.086]                             }
[10:59:36.086]                             return(sendCondition)
[10:59:36.086]                           }
[10:59:36.086]                         }
[10:59:36.086]                         frame <- frame + 1L
[10:59:36.086]                         envir <- sys.frame(frame)
[10:59:36.086]                       }
[10:59:36.086]                     }
[10:59:36.086]                     sendCondition <<- function(cond) NULL
[10:59:36.086]                   }
[10:59:36.086]                 })
[10:59:36.086]                 withCallingHandlers({
[10:59:36.086]                   {
[10:59:36.086]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.086]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.086]                       ...future.globals.maxSize)) {
[10:59:36.086]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.086]                       on.exit(options(oopts), add = TRUE)
[10:59:36.086]                     }
[10:59:36.086]                     {
[10:59:36.086]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.086]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.086]                         USE.NAMES = FALSE)
[10:59:36.086]                       do.call(mapply, args = args)
[10:59:36.086]                     }
[10:59:36.086]                   }
[10:59:36.086]                 }, immediateCondition = function(cond) {
[10:59:36.086]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.086]                   sendCondition(cond)
[10:59:36.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.086]                   {
[10:59:36.086]                     inherits <- base::inherits
[10:59:36.086]                     invokeRestart <- base::invokeRestart
[10:59:36.086]                     is.null <- base::is.null
[10:59:36.086]                     muffled <- FALSE
[10:59:36.086]                     if (inherits(cond, "message")) {
[10:59:36.086]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.086]                       if (muffled) 
[10:59:36.086]                         invokeRestart("muffleMessage")
[10:59:36.086]                     }
[10:59:36.086]                     else if (inherits(cond, "warning")) {
[10:59:36.086]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.086]                       if (muffled) 
[10:59:36.086]                         invokeRestart("muffleWarning")
[10:59:36.086]                     }
[10:59:36.086]                     else if (inherits(cond, "condition")) {
[10:59:36.086]                       if (!is.null(pattern)) {
[10:59:36.086]                         computeRestarts <- base::computeRestarts
[10:59:36.086]                         grepl <- base::grepl
[10:59:36.086]                         restarts <- computeRestarts(cond)
[10:59:36.086]                         for (restart in restarts) {
[10:59:36.086]                           name <- restart$name
[10:59:36.086]                           if (is.null(name)) 
[10:59:36.086]                             next
[10:59:36.086]                           if (!grepl(pattern, name)) 
[10:59:36.086]                             next
[10:59:36.086]                           invokeRestart(restart)
[10:59:36.086]                           muffled <- TRUE
[10:59:36.086]                           break
[10:59:36.086]                         }
[10:59:36.086]                       }
[10:59:36.086]                     }
[10:59:36.086]                     invisible(muffled)
[10:59:36.086]                   }
[10:59:36.086]                   muffleCondition(cond)
[10:59:36.086]                 })
[10:59:36.086]             }))
[10:59:36.086]             future::FutureResult(value = ...future.value$value, 
[10:59:36.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.086]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.086]                     ...future.globalenv.names))
[10:59:36.086]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.086]         }, condition = base::local({
[10:59:36.086]             c <- base::c
[10:59:36.086]             inherits <- base::inherits
[10:59:36.086]             invokeRestart <- base::invokeRestart
[10:59:36.086]             length <- base::length
[10:59:36.086]             list <- base::list
[10:59:36.086]             seq.int <- base::seq.int
[10:59:36.086]             signalCondition <- base::signalCondition
[10:59:36.086]             sys.calls <- base::sys.calls
[10:59:36.086]             `[[` <- base::`[[`
[10:59:36.086]             `+` <- base::`+`
[10:59:36.086]             `<<-` <- base::`<<-`
[10:59:36.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.086]                   3L)]
[10:59:36.086]             }
[10:59:36.086]             function(cond) {
[10:59:36.086]                 is_error <- inherits(cond, "error")
[10:59:36.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.086]                   NULL)
[10:59:36.086]                 if (is_error) {
[10:59:36.086]                   sessionInformation <- function() {
[10:59:36.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.086]                       search = base::search(), system = base::Sys.info())
[10:59:36.086]                   }
[10:59:36.086]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.086]                     cond$call), session = sessionInformation(), 
[10:59:36.086]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.086]                   signalCondition(cond)
[10:59:36.086]                 }
[10:59:36.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.086]                 "immediateCondition"))) {
[10:59:36.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.086]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.086]                   if (TRUE && !signal) {
[10:59:36.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.086]                     {
[10:59:36.086]                       inherits <- base::inherits
[10:59:36.086]                       invokeRestart <- base::invokeRestart
[10:59:36.086]                       is.null <- base::is.null
[10:59:36.086]                       muffled <- FALSE
[10:59:36.086]                       if (inherits(cond, "message")) {
[10:59:36.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.086]                         if (muffled) 
[10:59:36.086]                           invokeRestart("muffleMessage")
[10:59:36.086]                       }
[10:59:36.086]                       else if (inherits(cond, "warning")) {
[10:59:36.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.086]                         if (muffled) 
[10:59:36.086]                           invokeRestart("muffleWarning")
[10:59:36.086]                       }
[10:59:36.086]                       else if (inherits(cond, "condition")) {
[10:59:36.086]                         if (!is.null(pattern)) {
[10:59:36.086]                           computeRestarts <- base::computeRestarts
[10:59:36.086]                           grepl <- base::grepl
[10:59:36.086]                           restarts <- computeRestarts(cond)
[10:59:36.086]                           for (restart in restarts) {
[10:59:36.086]                             name <- restart$name
[10:59:36.086]                             if (is.null(name)) 
[10:59:36.086]                               next
[10:59:36.086]                             if (!grepl(pattern, name)) 
[10:59:36.086]                               next
[10:59:36.086]                             invokeRestart(restart)
[10:59:36.086]                             muffled <- TRUE
[10:59:36.086]                             break
[10:59:36.086]                           }
[10:59:36.086]                         }
[10:59:36.086]                       }
[10:59:36.086]                       invisible(muffled)
[10:59:36.086]                     }
[10:59:36.086]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.086]                   }
[10:59:36.086]                 }
[10:59:36.086]                 else {
[10:59:36.086]                   if (TRUE) {
[10:59:36.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.086]                     {
[10:59:36.086]                       inherits <- base::inherits
[10:59:36.086]                       invokeRestart <- base::invokeRestart
[10:59:36.086]                       is.null <- base::is.null
[10:59:36.086]                       muffled <- FALSE
[10:59:36.086]                       if (inherits(cond, "message")) {
[10:59:36.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.086]                         if (muffled) 
[10:59:36.086]                           invokeRestart("muffleMessage")
[10:59:36.086]                       }
[10:59:36.086]                       else if (inherits(cond, "warning")) {
[10:59:36.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.086]                         if (muffled) 
[10:59:36.086]                           invokeRestart("muffleWarning")
[10:59:36.086]                       }
[10:59:36.086]                       else if (inherits(cond, "condition")) {
[10:59:36.086]                         if (!is.null(pattern)) {
[10:59:36.086]                           computeRestarts <- base::computeRestarts
[10:59:36.086]                           grepl <- base::grepl
[10:59:36.086]                           restarts <- computeRestarts(cond)
[10:59:36.086]                           for (restart in restarts) {
[10:59:36.086]                             name <- restart$name
[10:59:36.086]                             if (is.null(name)) 
[10:59:36.086]                               next
[10:59:36.086]                             if (!grepl(pattern, name)) 
[10:59:36.086]                               next
[10:59:36.086]                             invokeRestart(restart)
[10:59:36.086]                             muffled <- TRUE
[10:59:36.086]                             break
[10:59:36.086]                           }
[10:59:36.086]                         }
[10:59:36.086]                       }
[10:59:36.086]                       invisible(muffled)
[10:59:36.086]                     }
[10:59:36.086]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.086]                   }
[10:59:36.086]                 }
[10:59:36.086]             }
[10:59:36.086]         }))
[10:59:36.086]     }, error = function(ex) {
[10:59:36.086]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.086]                 ...future.rng), started = ...future.startTime, 
[10:59:36.086]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.086]             version = "1.8"), class = "FutureResult")
[10:59:36.086]     }, finally = {
[10:59:36.086]         if (!identical(...future.workdir, getwd())) 
[10:59:36.086]             setwd(...future.workdir)
[10:59:36.086]         {
[10:59:36.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.086]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.086]             }
[10:59:36.086]             base::options(...future.oldOptions)
[10:59:36.086]             if (.Platform$OS.type == "windows") {
[10:59:36.086]                 old_names <- names(...future.oldEnvVars)
[10:59:36.086]                 envs <- base::Sys.getenv()
[10:59:36.086]                 names <- names(envs)
[10:59:36.086]                 common <- intersect(names, old_names)
[10:59:36.086]                 added <- setdiff(names, old_names)
[10:59:36.086]                 removed <- setdiff(old_names, names)
[10:59:36.086]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.086]                   envs[common]]
[10:59:36.086]                 NAMES <- toupper(changed)
[10:59:36.086]                 args <- list()
[10:59:36.086]                 for (kk in seq_along(NAMES)) {
[10:59:36.086]                   name <- changed[[kk]]
[10:59:36.086]                   NAME <- NAMES[[kk]]
[10:59:36.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.086]                     next
[10:59:36.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.086]                 }
[10:59:36.086]                 NAMES <- toupper(added)
[10:59:36.086]                 for (kk in seq_along(NAMES)) {
[10:59:36.086]                   name <- added[[kk]]
[10:59:36.086]                   NAME <- NAMES[[kk]]
[10:59:36.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.086]                     next
[10:59:36.086]                   args[[name]] <- ""
[10:59:36.086]                 }
[10:59:36.086]                 NAMES <- toupper(removed)
[10:59:36.086]                 for (kk in seq_along(NAMES)) {
[10:59:36.086]                   name <- removed[[kk]]
[10:59:36.086]                   NAME <- NAMES[[kk]]
[10:59:36.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.086]                     next
[10:59:36.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.086]                 }
[10:59:36.086]                 if (length(args) > 0) 
[10:59:36.086]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.086]             }
[10:59:36.086]             else {
[10:59:36.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.086]             }
[10:59:36.086]             {
[10:59:36.086]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.086]                   0L) {
[10:59:36.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.086]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.086]                   base::options(opts)
[10:59:36.086]                 }
[10:59:36.086]                 {
[10:59:36.086]                   {
[10:59:36.086]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.086]                     NULL
[10:59:36.086]                   }
[10:59:36.086]                   options(future.plan = NULL)
[10:59:36.086]                   if (is.na(NA_character_)) 
[10:59:36.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.086]                     .init = FALSE)
[10:59:36.086]                 }
[10:59:36.086]             }
[10:59:36.086]         }
[10:59:36.086]     })
[10:59:36.086]     if (TRUE) {
[10:59:36.086]         base::sink(type = "output", split = FALSE)
[10:59:36.086]         if (TRUE) {
[10:59:36.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.086]         }
[10:59:36.086]         else {
[10:59:36.086]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.086]         }
[10:59:36.086]         base::close(...future.stdout)
[10:59:36.086]         ...future.stdout <- NULL
[10:59:36.086]     }
[10:59:36.086]     ...future.result$conditions <- ...future.conditions
[10:59:36.086]     ...future.result$finished <- base::Sys.time()
[10:59:36.086]     ...future.result
[10:59:36.086] }
[10:59:36.088] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[10:59:36.088] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:59:36.089] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:59:36.089] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:59:36.089] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:59:36.089] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:59:36.090] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:59:36.090] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:36.090] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.090] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:36.091] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.091] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[10:59:36.091] MultisessionFuture started
[10:59:36.091] - Launch lazy future ... done
[10:59:36.092] run() for ‘MultisessionFuture’ ... done
[10:59:36.092] Created future:
[10:59:36.092] MultisessionFuture:
[10:59:36.092] Label: ‘future_.mapply-2’
[10:59:36.092] Expression:
[10:59:36.092] {
[10:59:36.092]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.092]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.092]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.092]         on.exit(options(oopts), add = TRUE)
[10:59:36.092]     }
[10:59:36.092]     {
[10:59:36.092]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.092]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.092]         do.call(mapply, args = args)
[10:59:36.092]     }
[10:59:36.092] }
[10:59:36.092] Lazy evaluation: FALSE
[10:59:36.092] Asynchronous evaluation: TRUE
[10:59:36.092] Local evaluation: TRUE
[10:59:36.092] Environment: R_GlobalEnv
[10:59:36.092] Capture standard output: TRUE
[10:59:36.092] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.092] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.092] Packages: <none>
[10:59:36.092] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.092] Resolved: FALSE
[10:59:36.092] Value: <not collected>
[10:59:36.092] Conditions captured: <none>
[10:59:36.092] Early signaling: FALSE
[10:59:36.092] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.092] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.103] Chunk #2 of 2 ... DONE
[10:59:36.103] Launching 2 futures (chunks) ... DONE
[10:59:36.103] Resolving 2 futures (chunks) ...
[10:59:36.103] resolve() on list ...
[10:59:36.103]  recursive: 0
[10:59:36.103]  length: 2
[10:59:36.103] 
[10:59:36.104] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.104] - Validating connection of MultisessionFuture
[10:59:36.104] - received message: FutureResult
[10:59:36.104] - Received FutureResult
[10:59:36.104] - Erased future from FutureRegistry
[10:59:36.105] result() for ClusterFuture ...
[10:59:36.105] - result already collected: FutureResult
[10:59:36.105] result() for ClusterFuture ... done
[10:59:36.105] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.105] Future #1
[10:59:36.105] result() for ClusterFuture ...
[10:59:36.105] - result already collected: FutureResult
[10:59:36.105] result() for ClusterFuture ... done
[10:59:36.105] result() for ClusterFuture ...
[10:59:36.105] - result already collected: FutureResult
[10:59:36.105] result() for ClusterFuture ... done
[10:59:36.105] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.105] - nx: 2
[10:59:36.106] - relay: TRUE
[10:59:36.106] - stdout: TRUE
[10:59:36.106] - signal: TRUE
[10:59:36.106] - resignal: FALSE
[10:59:36.106] - force: TRUE
[10:59:36.106] - relayed: [n=2] FALSE, FALSE
[10:59:36.106] - queued futures: [n=2] FALSE, FALSE
[10:59:36.106]  - until=1
[10:59:36.106]  - relaying element #1
[10:59:36.106] result() for ClusterFuture ...
[10:59:36.106] - result already collected: FutureResult
[10:59:36.106] result() for ClusterFuture ... done
[10:59:36.107] result() for ClusterFuture ...
[10:59:36.107] - result already collected: FutureResult
[10:59:36.107] result() for ClusterFuture ... done
[10:59:36.107] result() for ClusterFuture ...
[10:59:36.107] - result already collected: FutureResult
[10:59:36.107] result() for ClusterFuture ... done
[10:59:36.107] result() for ClusterFuture ...
[10:59:36.107] - result already collected: FutureResult
[10:59:36.107] result() for ClusterFuture ... done
[10:59:36.107] - relayed: [n=2] TRUE, FALSE
[10:59:36.107] - queued futures: [n=2] TRUE, FALSE
[10:59:36.107] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.108]  length: 1 (resolved future 1)
[10:59:36.133] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.133] - Validating connection of MultisessionFuture
[10:59:36.134] - received message: FutureResult
[10:59:36.134] - Received FutureResult
[10:59:36.134] - Erased future from FutureRegistry
[10:59:36.134] result() for ClusterFuture ...
[10:59:36.134] - result already collected: FutureResult
[10:59:36.134] result() for ClusterFuture ... done
[10:59:36.134] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.134] Future #2
[10:59:36.134] result() for ClusterFuture ...
[10:59:36.134] - result already collected: FutureResult
[10:59:36.134] result() for ClusterFuture ... done
[10:59:36.135] result() for ClusterFuture ...
[10:59:36.135] - result already collected: FutureResult
[10:59:36.135] result() for ClusterFuture ... done
[10:59:36.135] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:36.135] - nx: 2
[10:59:36.135] - relay: TRUE
[10:59:36.135] - stdout: TRUE
[10:59:36.135] - signal: TRUE
[10:59:36.135] - resignal: FALSE
[10:59:36.135] - force: TRUE
[10:59:36.135] - relayed: [n=2] TRUE, FALSE
[10:59:36.135] - queued futures: [n=2] TRUE, FALSE
[10:59:36.135]  - until=2
[10:59:36.136]  - relaying element #2
[10:59:36.136] result() for ClusterFuture ...
[10:59:36.136] - result already collected: FutureResult
[10:59:36.136] result() for ClusterFuture ... done
[10:59:36.136] result() for ClusterFuture ...
[10:59:36.136] - result already collected: FutureResult
[10:59:36.136] result() for ClusterFuture ... done
[10:59:36.136] result() for ClusterFuture ...
[10:59:36.136] - result already collected: FutureResult
[10:59:36.136] result() for ClusterFuture ... done
[10:59:36.136] result() for ClusterFuture ...
[10:59:36.136] - result already collected: FutureResult
[10:59:36.137] result() for ClusterFuture ... done
[10:59:36.137] - relayed: [n=2] TRUE, TRUE
[10:59:36.137] - queued futures: [n=2] TRUE, TRUE
[10:59:36.137] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:36.137]  length: 0 (resolved future 2)
[10:59:36.137] Relaying remaining futures
[10:59:36.137] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.137] - nx: 2
[10:59:36.137] - relay: TRUE
[10:59:36.137] - stdout: TRUE
[10:59:36.137] - signal: TRUE
[10:59:36.137] - resignal: FALSE
[10:59:36.137] - force: TRUE
[10:59:36.138] - relayed: [n=2] TRUE, TRUE
[10:59:36.138] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:36.138] - relayed: [n=2] TRUE, TRUE
[10:59:36.138] - queued futures: [n=2] TRUE, TRUE
[10:59:36.138] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.138] resolve() on list ... DONE
[10:59:36.138] result() for ClusterFuture ...
[10:59:36.138] - result already collected: FutureResult
[10:59:36.138] result() for ClusterFuture ... done
[10:59:36.138] result() for ClusterFuture ...
[10:59:36.138] - result already collected: FutureResult
[10:59:36.138] result() for ClusterFuture ... done
[10:59:36.139] result() for ClusterFuture ...
[10:59:36.139] - result already collected: FutureResult
[10:59:36.139] result() for ClusterFuture ... done
[10:59:36.139] result() for ClusterFuture ...
[10:59:36.139] - result already collected: FutureResult
[10:59:36.139] result() for ClusterFuture ... done
[10:59:36.139]  - Number of value chunks collected: 2
[10:59:36.139] Resolving 2 futures (chunks) ... DONE
[10:59:36.139] Reducing values from 2 chunks ...
[10:59:36.139]  - Number of values collected after concatenation: 5
[10:59:36.139]  - Number of values expected: 5
[10:59:36.139] Reducing values from 2 chunks ... DONE
[10:59:36.140] future_mapply() ... DONE
[10:59:36.140] future_mapply() ...
[10:59:36.141] Number of chunks: 2
[10:59:36.141] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:59:36.141] getGlobalsAndPackagesXApply() ...
[10:59:36.142]  - future.globals: TRUE
[10:59:36.142] getGlobalsAndPackages() ...
[10:59:36.142] Searching for globals...
[10:59:36.143] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:36.143] Searching for globals ... DONE
[10:59:36.143] Resolving globals: FALSE
[10:59:36.143] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:36.144] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:36.144] - globals: [1] ‘FUN’
[10:59:36.144] 
[10:59:36.144] getGlobalsAndPackages() ... DONE
[10:59:36.144]  - globals found/used: [n=1] ‘FUN’
[10:59:36.144]  - needed namespaces: [n=0] 
[10:59:36.144] Finding globals ... DONE
[10:59:36.144] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.145] List of 2
[10:59:36.145]  $ ...future.FUN:function (C, k)  
[10:59:36.145]  $ MoreArgs     : NULL
[10:59:36.145]  - attr(*, "where")=List of 2
[10:59:36.145]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.145]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.145]  - attr(*, "resolved")= logi FALSE
[10:59:36.145]  - attr(*, "total_size")= num NA
[10:59:36.147] Packages to be attached in all futures: [n=0] 
[10:59:36.147] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.147] Number of futures (= number of chunks): 2
[10:59:36.147] Launching 2 futures (chunks) ...
[10:59:36.147] Chunk #1 of 2 ...
[10:59:36.148]  - Finding globals in '...' for chunk #1 ...
[10:59:36.148] getGlobalsAndPackages() ...
[10:59:36.148] Searching for globals...
[10:59:36.148] 
[10:59:36.148] Searching for globals ... DONE
[10:59:36.148] - globals: [0] <none>
[10:59:36.148] getGlobalsAndPackages() ... DONE
[10:59:36.148]    + additional globals found: [n=0] 
[10:59:36.148]    + additional namespaces needed: [n=0] 
[10:59:36.148]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.149]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.149]  - seeds: <none>
[10:59:36.149]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.149] getGlobalsAndPackages() ...
[10:59:36.149] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.149] Resolving globals: FALSE
[10:59:36.149] The total size of the 5 globals is 876 bytes (876 bytes)
[10:59:36.150] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:36.150] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.150] 
[10:59:36.150] getGlobalsAndPackages() ... DONE
[10:59:36.150] run() for ‘Future’ ...
[10:59:36.150] - state: ‘created’
[10:59:36.151] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.164] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.164]   - Field: ‘node’
[10:59:36.165]   - Field: ‘label’
[10:59:36.165]   - Field: ‘local’
[10:59:36.165]   - Field: ‘owner’
[10:59:36.165]   - Field: ‘envir’
[10:59:36.165]   - Field: ‘workers’
[10:59:36.165]   - Field: ‘packages’
[10:59:36.165]   - Field: ‘gc’
[10:59:36.165]   - Field: ‘conditions’
[10:59:36.165]   - Field: ‘persistent’
[10:59:36.165]   - Field: ‘expr’
[10:59:36.165]   - Field: ‘uuid’
[10:59:36.166]   - Field: ‘seed’
[10:59:36.166]   - Field: ‘version’
[10:59:36.166]   - Field: ‘result’
[10:59:36.166]   - Field: ‘asynchronous’
[10:59:36.166]   - Field: ‘calls’
[10:59:36.166]   - Field: ‘globals’
[10:59:36.166]   - Field: ‘stdout’
[10:59:36.166]   - Field: ‘earlySignal’
[10:59:36.166]   - Field: ‘lazy’
[10:59:36.166]   - Field: ‘state’
[10:59:36.166] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.166] - Launch lazy future ...
[10:59:36.167] Packages needed by the future expression (n = 0): <none>
[10:59:36.167] Packages needed by future strategies (n = 0): <none>
[10:59:36.167] {
[10:59:36.167]     {
[10:59:36.167]         {
[10:59:36.167]             ...future.startTime <- base::Sys.time()
[10:59:36.167]             {
[10:59:36.167]                 {
[10:59:36.167]                   {
[10:59:36.167]                     {
[10:59:36.167]                       base::local({
[10:59:36.167]                         has_future <- base::requireNamespace("future", 
[10:59:36.167]                           quietly = TRUE)
[10:59:36.167]                         if (has_future) {
[10:59:36.167]                           ns <- base::getNamespace("future")
[10:59:36.167]                           version <- ns[[".package"]][["version"]]
[10:59:36.167]                           if (is.null(version)) 
[10:59:36.167]                             version <- utils::packageVersion("future")
[10:59:36.167]                         }
[10:59:36.167]                         else {
[10:59:36.167]                           version <- NULL
[10:59:36.167]                         }
[10:59:36.167]                         if (!has_future || version < "1.8.0") {
[10:59:36.167]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.167]                             "", base::R.version$version.string), 
[10:59:36.167]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.167]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.167]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.167]                               "release", "version")], collapse = " "), 
[10:59:36.167]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.167]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.167]                             info)
[10:59:36.167]                           info <- base::paste(info, collapse = "; ")
[10:59:36.167]                           if (!has_future) {
[10:59:36.167]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.167]                               info)
[10:59:36.167]                           }
[10:59:36.167]                           else {
[10:59:36.167]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.167]                               info, version)
[10:59:36.167]                           }
[10:59:36.167]                           base::stop(msg)
[10:59:36.167]                         }
[10:59:36.167]                       })
[10:59:36.167]                     }
[10:59:36.167]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.167]                     base::options(mc.cores = 1L)
[10:59:36.167]                   }
[10:59:36.167]                   ...future.strategy.old <- future::plan("list")
[10:59:36.167]                   options(future.plan = NULL)
[10:59:36.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.167]                 }
[10:59:36.167]                 ...future.workdir <- getwd()
[10:59:36.167]             }
[10:59:36.167]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.167]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.167]         }
[10:59:36.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.167]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.167]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.167]             base::names(...future.oldOptions))
[10:59:36.167]     }
[10:59:36.167]     if (FALSE) {
[10:59:36.167]     }
[10:59:36.167]     else {
[10:59:36.167]         if (TRUE) {
[10:59:36.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.167]                 open = "w")
[10:59:36.167]         }
[10:59:36.167]         else {
[10:59:36.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.167]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.167]         }
[10:59:36.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.167]             base::sink(type = "output", split = FALSE)
[10:59:36.167]             base::close(...future.stdout)
[10:59:36.167]         }, add = TRUE)
[10:59:36.167]     }
[10:59:36.167]     ...future.frame <- base::sys.nframe()
[10:59:36.167]     ...future.conditions <- base::list()
[10:59:36.167]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.167]     if (FALSE) {
[10:59:36.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.167]     }
[10:59:36.167]     ...future.result <- base::tryCatch({
[10:59:36.167]         base::withCallingHandlers({
[10:59:36.167]             ...future.value <- base::withVisible(base::local({
[10:59:36.167]                 ...future.makeSendCondition <- base::local({
[10:59:36.167]                   sendCondition <- NULL
[10:59:36.167]                   function(frame = 1L) {
[10:59:36.167]                     if (is.function(sendCondition)) 
[10:59:36.167]                       return(sendCondition)
[10:59:36.167]                     ns <- getNamespace("parallel")
[10:59:36.167]                     if (exists("sendData", mode = "function", 
[10:59:36.167]                       envir = ns)) {
[10:59:36.167]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.167]                         envir = ns)
[10:59:36.167]                       envir <- sys.frame(frame)
[10:59:36.167]                       master <- NULL
[10:59:36.167]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.167]                         !identical(envir, emptyenv())) {
[10:59:36.167]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.167]                           inherits = FALSE)) {
[10:59:36.167]                           master <- get("master", mode = "list", 
[10:59:36.167]                             envir = envir, inherits = FALSE)
[10:59:36.167]                           if (inherits(master, c("SOCKnode", 
[10:59:36.167]                             "SOCK0node"))) {
[10:59:36.167]                             sendCondition <<- function(cond) {
[10:59:36.167]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.167]                                 success = TRUE)
[10:59:36.167]                               parallel_sendData(master, data)
[10:59:36.167]                             }
[10:59:36.167]                             return(sendCondition)
[10:59:36.167]                           }
[10:59:36.167]                         }
[10:59:36.167]                         frame <- frame + 1L
[10:59:36.167]                         envir <- sys.frame(frame)
[10:59:36.167]                       }
[10:59:36.167]                     }
[10:59:36.167]                     sendCondition <<- function(cond) NULL
[10:59:36.167]                   }
[10:59:36.167]                 })
[10:59:36.167]                 withCallingHandlers({
[10:59:36.167]                   {
[10:59:36.167]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.167]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.167]                       ...future.globals.maxSize)) {
[10:59:36.167]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.167]                       on.exit(options(oopts), add = TRUE)
[10:59:36.167]                     }
[10:59:36.167]                     {
[10:59:36.167]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.167]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.167]                         USE.NAMES = FALSE)
[10:59:36.167]                       do.call(mapply, args = args)
[10:59:36.167]                     }
[10:59:36.167]                   }
[10:59:36.167]                 }, immediateCondition = function(cond) {
[10:59:36.167]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.167]                   sendCondition(cond)
[10:59:36.167]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.167]                   {
[10:59:36.167]                     inherits <- base::inherits
[10:59:36.167]                     invokeRestart <- base::invokeRestart
[10:59:36.167]                     is.null <- base::is.null
[10:59:36.167]                     muffled <- FALSE
[10:59:36.167]                     if (inherits(cond, "message")) {
[10:59:36.167]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.167]                       if (muffled) 
[10:59:36.167]                         invokeRestart("muffleMessage")
[10:59:36.167]                     }
[10:59:36.167]                     else if (inherits(cond, "warning")) {
[10:59:36.167]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.167]                       if (muffled) 
[10:59:36.167]                         invokeRestart("muffleWarning")
[10:59:36.167]                     }
[10:59:36.167]                     else if (inherits(cond, "condition")) {
[10:59:36.167]                       if (!is.null(pattern)) {
[10:59:36.167]                         computeRestarts <- base::computeRestarts
[10:59:36.167]                         grepl <- base::grepl
[10:59:36.167]                         restarts <- computeRestarts(cond)
[10:59:36.167]                         for (restart in restarts) {
[10:59:36.167]                           name <- restart$name
[10:59:36.167]                           if (is.null(name)) 
[10:59:36.167]                             next
[10:59:36.167]                           if (!grepl(pattern, name)) 
[10:59:36.167]                             next
[10:59:36.167]                           invokeRestart(restart)
[10:59:36.167]                           muffled <- TRUE
[10:59:36.167]                           break
[10:59:36.167]                         }
[10:59:36.167]                       }
[10:59:36.167]                     }
[10:59:36.167]                     invisible(muffled)
[10:59:36.167]                   }
[10:59:36.167]                   muffleCondition(cond)
[10:59:36.167]                 })
[10:59:36.167]             }))
[10:59:36.167]             future::FutureResult(value = ...future.value$value, 
[10:59:36.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.167]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.167]                     ...future.globalenv.names))
[10:59:36.167]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.167]         }, condition = base::local({
[10:59:36.167]             c <- base::c
[10:59:36.167]             inherits <- base::inherits
[10:59:36.167]             invokeRestart <- base::invokeRestart
[10:59:36.167]             length <- base::length
[10:59:36.167]             list <- base::list
[10:59:36.167]             seq.int <- base::seq.int
[10:59:36.167]             signalCondition <- base::signalCondition
[10:59:36.167]             sys.calls <- base::sys.calls
[10:59:36.167]             `[[` <- base::`[[`
[10:59:36.167]             `+` <- base::`+`
[10:59:36.167]             `<<-` <- base::`<<-`
[10:59:36.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.167]                   3L)]
[10:59:36.167]             }
[10:59:36.167]             function(cond) {
[10:59:36.167]                 is_error <- inherits(cond, "error")
[10:59:36.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.167]                   NULL)
[10:59:36.167]                 if (is_error) {
[10:59:36.167]                   sessionInformation <- function() {
[10:59:36.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.167]                       search = base::search(), system = base::Sys.info())
[10:59:36.167]                   }
[10:59:36.167]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.167]                     cond$call), session = sessionInformation(), 
[10:59:36.167]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.167]                   signalCondition(cond)
[10:59:36.167]                 }
[10:59:36.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.167]                 "immediateCondition"))) {
[10:59:36.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.167]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.167]                   if (TRUE && !signal) {
[10:59:36.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.167]                     {
[10:59:36.167]                       inherits <- base::inherits
[10:59:36.167]                       invokeRestart <- base::invokeRestart
[10:59:36.167]                       is.null <- base::is.null
[10:59:36.167]                       muffled <- FALSE
[10:59:36.167]                       if (inherits(cond, "message")) {
[10:59:36.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.167]                         if (muffled) 
[10:59:36.167]                           invokeRestart("muffleMessage")
[10:59:36.167]                       }
[10:59:36.167]                       else if (inherits(cond, "warning")) {
[10:59:36.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.167]                         if (muffled) 
[10:59:36.167]                           invokeRestart("muffleWarning")
[10:59:36.167]                       }
[10:59:36.167]                       else if (inherits(cond, "condition")) {
[10:59:36.167]                         if (!is.null(pattern)) {
[10:59:36.167]                           computeRestarts <- base::computeRestarts
[10:59:36.167]                           grepl <- base::grepl
[10:59:36.167]                           restarts <- computeRestarts(cond)
[10:59:36.167]                           for (restart in restarts) {
[10:59:36.167]                             name <- restart$name
[10:59:36.167]                             if (is.null(name)) 
[10:59:36.167]                               next
[10:59:36.167]                             if (!grepl(pattern, name)) 
[10:59:36.167]                               next
[10:59:36.167]                             invokeRestart(restart)
[10:59:36.167]                             muffled <- TRUE
[10:59:36.167]                             break
[10:59:36.167]                           }
[10:59:36.167]                         }
[10:59:36.167]                       }
[10:59:36.167]                       invisible(muffled)
[10:59:36.167]                     }
[10:59:36.167]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.167]                   }
[10:59:36.167]                 }
[10:59:36.167]                 else {
[10:59:36.167]                   if (TRUE) {
[10:59:36.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.167]                     {
[10:59:36.167]                       inherits <- base::inherits
[10:59:36.167]                       invokeRestart <- base::invokeRestart
[10:59:36.167]                       is.null <- base::is.null
[10:59:36.167]                       muffled <- FALSE
[10:59:36.167]                       if (inherits(cond, "message")) {
[10:59:36.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.167]                         if (muffled) 
[10:59:36.167]                           invokeRestart("muffleMessage")
[10:59:36.167]                       }
[10:59:36.167]                       else if (inherits(cond, "warning")) {
[10:59:36.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.167]                         if (muffled) 
[10:59:36.167]                           invokeRestart("muffleWarning")
[10:59:36.167]                       }
[10:59:36.167]                       else if (inherits(cond, "condition")) {
[10:59:36.167]                         if (!is.null(pattern)) {
[10:59:36.167]                           computeRestarts <- base::computeRestarts
[10:59:36.167]                           grepl <- base::grepl
[10:59:36.167]                           restarts <- computeRestarts(cond)
[10:59:36.167]                           for (restart in restarts) {
[10:59:36.167]                             name <- restart$name
[10:59:36.167]                             if (is.null(name)) 
[10:59:36.167]                               next
[10:59:36.167]                             if (!grepl(pattern, name)) 
[10:59:36.167]                               next
[10:59:36.167]                             invokeRestart(restart)
[10:59:36.167]                             muffled <- TRUE
[10:59:36.167]                             break
[10:59:36.167]                           }
[10:59:36.167]                         }
[10:59:36.167]                       }
[10:59:36.167]                       invisible(muffled)
[10:59:36.167]                     }
[10:59:36.167]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.167]                   }
[10:59:36.167]                 }
[10:59:36.167]             }
[10:59:36.167]         }))
[10:59:36.167]     }, error = function(ex) {
[10:59:36.167]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.167]                 ...future.rng), started = ...future.startTime, 
[10:59:36.167]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.167]             version = "1.8"), class = "FutureResult")
[10:59:36.167]     }, finally = {
[10:59:36.167]         if (!identical(...future.workdir, getwd())) 
[10:59:36.167]             setwd(...future.workdir)
[10:59:36.167]         {
[10:59:36.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.167]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.167]             }
[10:59:36.167]             base::options(...future.oldOptions)
[10:59:36.167]             if (.Platform$OS.type == "windows") {
[10:59:36.167]                 old_names <- names(...future.oldEnvVars)
[10:59:36.167]                 envs <- base::Sys.getenv()
[10:59:36.167]                 names <- names(envs)
[10:59:36.167]                 common <- intersect(names, old_names)
[10:59:36.167]                 added <- setdiff(names, old_names)
[10:59:36.167]                 removed <- setdiff(old_names, names)
[10:59:36.167]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.167]                   envs[common]]
[10:59:36.167]                 NAMES <- toupper(changed)
[10:59:36.167]                 args <- list()
[10:59:36.167]                 for (kk in seq_along(NAMES)) {
[10:59:36.167]                   name <- changed[[kk]]
[10:59:36.167]                   NAME <- NAMES[[kk]]
[10:59:36.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.167]                     next
[10:59:36.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.167]                 }
[10:59:36.167]                 NAMES <- toupper(added)
[10:59:36.167]                 for (kk in seq_along(NAMES)) {
[10:59:36.167]                   name <- added[[kk]]
[10:59:36.167]                   NAME <- NAMES[[kk]]
[10:59:36.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.167]                     next
[10:59:36.167]                   args[[name]] <- ""
[10:59:36.167]                 }
[10:59:36.167]                 NAMES <- toupper(removed)
[10:59:36.167]                 for (kk in seq_along(NAMES)) {
[10:59:36.167]                   name <- removed[[kk]]
[10:59:36.167]                   NAME <- NAMES[[kk]]
[10:59:36.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.167]                     next
[10:59:36.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.167]                 }
[10:59:36.167]                 if (length(args) > 0) 
[10:59:36.167]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.167]             }
[10:59:36.167]             else {
[10:59:36.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.167]             }
[10:59:36.167]             {
[10:59:36.167]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.167]                   0L) {
[10:59:36.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.167]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.167]                   base::options(opts)
[10:59:36.167]                 }
[10:59:36.167]                 {
[10:59:36.167]                   {
[10:59:36.167]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.167]                     NULL
[10:59:36.167]                   }
[10:59:36.167]                   options(future.plan = NULL)
[10:59:36.167]                   if (is.na(NA_character_)) 
[10:59:36.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.167]                     .init = FALSE)
[10:59:36.167]                 }
[10:59:36.167]             }
[10:59:36.167]         }
[10:59:36.167]     })
[10:59:36.167]     if (TRUE) {
[10:59:36.167]         base::sink(type = "output", split = FALSE)
[10:59:36.167]         if (TRUE) {
[10:59:36.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.167]         }
[10:59:36.167]         else {
[10:59:36.167]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.167]         }
[10:59:36.167]         base::close(...future.stdout)
[10:59:36.167]         ...future.stdout <- NULL
[10:59:36.167]     }
[10:59:36.167]     ...future.result$conditions <- ...future.conditions
[10:59:36.167]     ...future.result$finished <- base::Sys.time()
[10:59:36.167]     ...future.result
[10:59:36.167] }
[10:59:36.170] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[10:59:36.170] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:36.170] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:36.170] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:36.171] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.171] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:59:36.171] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:59:36.171] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.172] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.172] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.172] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.172] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[10:59:36.173] MultisessionFuture started
[10:59:36.173] - Launch lazy future ... done
[10:59:36.173] run() for ‘MultisessionFuture’ ... done
[10:59:36.173] Created future:
[10:59:36.173] MultisessionFuture:
[10:59:36.173] Label: ‘future_mapply-1’
[10:59:36.173] Expression:
[10:59:36.173] {
[10:59:36.173]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.173]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.173]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.173]         on.exit(options(oopts), add = TRUE)
[10:59:36.173]     }
[10:59:36.173]     {
[10:59:36.173]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.173]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.173]         do.call(mapply, args = args)
[10:59:36.173]     }
[10:59:36.173] }
[10:59:36.173] Lazy evaluation: FALSE
[10:59:36.173] Asynchronous evaluation: TRUE
[10:59:36.173] Local evaluation: TRUE
[10:59:36.173] Environment: R_GlobalEnv
[10:59:36.173] Capture standard output: TRUE
[10:59:36.173] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.173] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.173] Packages: <none>
[10:59:36.173] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.173] Resolved: FALSE
[10:59:36.173] Value: <not collected>
[10:59:36.173] Conditions captured: <none>
[10:59:36.173] Early signaling: FALSE
[10:59:36.173] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.173] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.190] Chunk #1 of 2 ... DONE
[10:59:36.191] Chunk #2 of 2 ...
[10:59:36.191]  - Finding globals in '...' for chunk #2 ...
[10:59:36.191] getGlobalsAndPackages() ...
[10:59:36.191] Searching for globals...
[10:59:36.191] 
[10:59:36.192] Searching for globals ... DONE
[10:59:36.192] - globals: [0] <none>
[10:59:36.192] getGlobalsAndPackages() ... DONE
[10:59:36.192]    + additional globals found: [n=0] 
[10:59:36.192]    + additional namespaces needed: [n=0] 
[10:59:36.192]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:36.192]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.192]  - seeds: <none>
[10:59:36.192]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.192] getGlobalsAndPackages() ...
[10:59:36.192] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.193] Resolving globals: FALSE
[10:59:36.193] The total size of the 5 globals is 905 bytes (905 bytes)
[10:59:36.193] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:36.193] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.194] 
[10:59:36.194] getGlobalsAndPackages() ... DONE
[10:59:36.194] run() for ‘Future’ ...
[10:59:36.194] - state: ‘created’
[10:59:36.194] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.208]   - Field: ‘node’
[10:59:36.208]   - Field: ‘label’
[10:59:36.208]   - Field: ‘local’
[10:59:36.208]   - Field: ‘owner’
[10:59:36.208]   - Field: ‘envir’
[10:59:36.209]   - Field: ‘workers’
[10:59:36.209]   - Field: ‘packages’
[10:59:36.209]   - Field: ‘gc’
[10:59:36.209]   - Field: ‘conditions’
[10:59:36.209]   - Field: ‘persistent’
[10:59:36.209]   - Field: ‘expr’
[10:59:36.209]   - Field: ‘uuid’
[10:59:36.209]   - Field: ‘seed’
[10:59:36.209]   - Field: ‘version’
[10:59:36.209]   - Field: ‘result’
[10:59:36.209]   - Field: ‘asynchronous’
[10:59:36.209]   - Field: ‘calls’
[10:59:36.209]   - Field: ‘globals’
[10:59:36.210]   - Field: ‘stdout’
[10:59:36.210]   - Field: ‘earlySignal’
[10:59:36.210]   - Field: ‘lazy’
[10:59:36.210]   - Field: ‘state’
[10:59:36.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.210] - Launch lazy future ...
[10:59:36.210] Packages needed by the future expression (n = 0): <none>
[10:59:36.210] Packages needed by future strategies (n = 0): <none>
[10:59:36.211] {
[10:59:36.211]     {
[10:59:36.211]         {
[10:59:36.211]             ...future.startTime <- base::Sys.time()
[10:59:36.211]             {
[10:59:36.211]                 {
[10:59:36.211]                   {
[10:59:36.211]                     {
[10:59:36.211]                       base::local({
[10:59:36.211]                         has_future <- base::requireNamespace("future", 
[10:59:36.211]                           quietly = TRUE)
[10:59:36.211]                         if (has_future) {
[10:59:36.211]                           ns <- base::getNamespace("future")
[10:59:36.211]                           version <- ns[[".package"]][["version"]]
[10:59:36.211]                           if (is.null(version)) 
[10:59:36.211]                             version <- utils::packageVersion("future")
[10:59:36.211]                         }
[10:59:36.211]                         else {
[10:59:36.211]                           version <- NULL
[10:59:36.211]                         }
[10:59:36.211]                         if (!has_future || version < "1.8.0") {
[10:59:36.211]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.211]                             "", base::R.version$version.string), 
[10:59:36.211]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.211]                               "release", "version")], collapse = " "), 
[10:59:36.211]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.211]                             info)
[10:59:36.211]                           info <- base::paste(info, collapse = "; ")
[10:59:36.211]                           if (!has_future) {
[10:59:36.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.211]                               info)
[10:59:36.211]                           }
[10:59:36.211]                           else {
[10:59:36.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.211]                               info, version)
[10:59:36.211]                           }
[10:59:36.211]                           base::stop(msg)
[10:59:36.211]                         }
[10:59:36.211]                       })
[10:59:36.211]                     }
[10:59:36.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.211]                     base::options(mc.cores = 1L)
[10:59:36.211]                   }
[10:59:36.211]                   ...future.strategy.old <- future::plan("list")
[10:59:36.211]                   options(future.plan = NULL)
[10:59:36.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.211]                 }
[10:59:36.211]                 ...future.workdir <- getwd()
[10:59:36.211]             }
[10:59:36.211]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.211]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.211]         }
[10:59:36.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.211]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.211]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.211]             base::names(...future.oldOptions))
[10:59:36.211]     }
[10:59:36.211]     if (FALSE) {
[10:59:36.211]     }
[10:59:36.211]     else {
[10:59:36.211]         if (TRUE) {
[10:59:36.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.211]                 open = "w")
[10:59:36.211]         }
[10:59:36.211]         else {
[10:59:36.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.211]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.211]         }
[10:59:36.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.211]             base::sink(type = "output", split = FALSE)
[10:59:36.211]             base::close(...future.stdout)
[10:59:36.211]         }, add = TRUE)
[10:59:36.211]     }
[10:59:36.211]     ...future.frame <- base::sys.nframe()
[10:59:36.211]     ...future.conditions <- base::list()
[10:59:36.211]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.211]     if (FALSE) {
[10:59:36.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.211]     }
[10:59:36.211]     ...future.result <- base::tryCatch({
[10:59:36.211]         base::withCallingHandlers({
[10:59:36.211]             ...future.value <- base::withVisible(base::local({
[10:59:36.211]                 ...future.makeSendCondition <- base::local({
[10:59:36.211]                   sendCondition <- NULL
[10:59:36.211]                   function(frame = 1L) {
[10:59:36.211]                     if (is.function(sendCondition)) 
[10:59:36.211]                       return(sendCondition)
[10:59:36.211]                     ns <- getNamespace("parallel")
[10:59:36.211]                     if (exists("sendData", mode = "function", 
[10:59:36.211]                       envir = ns)) {
[10:59:36.211]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.211]                         envir = ns)
[10:59:36.211]                       envir <- sys.frame(frame)
[10:59:36.211]                       master <- NULL
[10:59:36.211]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.211]                         !identical(envir, emptyenv())) {
[10:59:36.211]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.211]                           inherits = FALSE)) {
[10:59:36.211]                           master <- get("master", mode = "list", 
[10:59:36.211]                             envir = envir, inherits = FALSE)
[10:59:36.211]                           if (inherits(master, c("SOCKnode", 
[10:59:36.211]                             "SOCK0node"))) {
[10:59:36.211]                             sendCondition <<- function(cond) {
[10:59:36.211]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.211]                                 success = TRUE)
[10:59:36.211]                               parallel_sendData(master, data)
[10:59:36.211]                             }
[10:59:36.211]                             return(sendCondition)
[10:59:36.211]                           }
[10:59:36.211]                         }
[10:59:36.211]                         frame <- frame + 1L
[10:59:36.211]                         envir <- sys.frame(frame)
[10:59:36.211]                       }
[10:59:36.211]                     }
[10:59:36.211]                     sendCondition <<- function(cond) NULL
[10:59:36.211]                   }
[10:59:36.211]                 })
[10:59:36.211]                 withCallingHandlers({
[10:59:36.211]                   {
[10:59:36.211]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.211]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.211]                       ...future.globals.maxSize)) {
[10:59:36.211]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.211]                       on.exit(options(oopts), add = TRUE)
[10:59:36.211]                     }
[10:59:36.211]                     {
[10:59:36.211]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.211]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.211]                         USE.NAMES = FALSE)
[10:59:36.211]                       do.call(mapply, args = args)
[10:59:36.211]                     }
[10:59:36.211]                   }
[10:59:36.211]                 }, immediateCondition = function(cond) {
[10:59:36.211]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.211]                   sendCondition(cond)
[10:59:36.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.211]                   {
[10:59:36.211]                     inherits <- base::inherits
[10:59:36.211]                     invokeRestart <- base::invokeRestart
[10:59:36.211]                     is.null <- base::is.null
[10:59:36.211]                     muffled <- FALSE
[10:59:36.211]                     if (inherits(cond, "message")) {
[10:59:36.211]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.211]                       if (muffled) 
[10:59:36.211]                         invokeRestart("muffleMessage")
[10:59:36.211]                     }
[10:59:36.211]                     else if (inherits(cond, "warning")) {
[10:59:36.211]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.211]                       if (muffled) 
[10:59:36.211]                         invokeRestart("muffleWarning")
[10:59:36.211]                     }
[10:59:36.211]                     else if (inherits(cond, "condition")) {
[10:59:36.211]                       if (!is.null(pattern)) {
[10:59:36.211]                         computeRestarts <- base::computeRestarts
[10:59:36.211]                         grepl <- base::grepl
[10:59:36.211]                         restarts <- computeRestarts(cond)
[10:59:36.211]                         for (restart in restarts) {
[10:59:36.211]                           name <- restart$name
[10:59:36.211]                           if (is.null(name)) 
[10:59:36.211]                             next
[10:59:36.211]                           if (!grepl(pattern, name)) 
[10:59:36.211]                             next
[10:59:36.211]                           invokeRestart(restart)
[10:59:36.211]                           muffled <- TRUE
[10:59:36.211]                           break
[10:59:36.211]                         }
[10:59:36.211]                       }
[10:59:36.211]                     }
[10:59:36.211]                     invisible(muffled)
[10:59:36.211]                   }
[10:59:36.211]                   muffleCondition(cond)
[10:59:36.211]                 })
[10:59:36.211]             }))
[10:59:36.211]             future::FutureResult(value = ...future.value$value, 
[10:59:36.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.211]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.211]                     ...future.globalenv.names))
[10:59:36.211]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.211]         }, condition = base::local({
[10:59:36.211]             c <- base::c
[10:59:36.211]             inherits <- base::inherits
[10:59:36.211]             invokeRestart <- base::invokeRestart
[10:59:36.211]             length <- base::length
[10:59:36.211]             list <- base::list
[10:59:36.211]             seq.int <- base::seq.int
[10:59:36.211]             signalCondition <- base::signalCondition
[10:59:36.211]             sys.calls <- base::sys.calls
[10:59:36.211]             `[[` <- base::`[[`
[10:59:36.211]             `+` <- base::`+`
[10:59:36.211]             `<<-` <- base::`<<-`
[10:59:36.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.211]                   3L)]
[10:59:36.211]             }
[10:59:36.211]             function(cond) {
[10:59:36.211]                 is_error <- inherits(cond, "error")
[10:59:36.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.211]                   NULL)
[10:59:36.211]                 if (is_error) {
[10:59:36.211]                   sessionInformation <- function() {
[10:59:36.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.211]                       search = base::search(), system = base::Sys.info())
[10:59:36.211]                   }
[10:59:36.211]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.211]                     cond$call), session = sessionInformation(), 
[10:59:36.211]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.211]                   signalCondition(cond)
[10:59:36.211]                 }
[10:59:36.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.211]                 "immediateCondition"))) {
[10:59:36.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.211]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.211]                   if (TRUE && !signal) {
[10:59:36.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.211]                     {
[10:59:36.211]                       inherits <- base::inherits
[10:59:36.211]                       invokeRestart <- base::invokeRestart
[10:59:36.211]                       is.null <- base::is.null
[10:59:36.211]                       muffled <- FALSE
[10:59:36.211]                       if (inherits(cond, "message")) {
[10:59:36.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.211]                         if (muffled) 
[10:59:36.211]                           invokeRestart("muffleMessage")
[10:59:36.211]                       }
[10:59:36.211]                       else if (inherits(cond, "warning")) {
[10:59:36.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.211]                         if (muffled) 
[10:59:36.211]                           invokeRestart("muffleWarning")
[10:59:36.211]                       }
[10:59:36.211]                       else if (inherits(cond, "condition")) {
[10:59:36.211]                         if (!is.null(pattern)) {
[10:59:36.211]                           computeRestarts <- base::computeRestarts
[10:59:36.211]                           grepl <- base::grepl
[10:59:36.211]                           restarts <- computeRestarts(cond)
[10:59:36.211]                           for (restart in restarts) {
[10:59:36.211]                             name <- restart$name
[10:59:36.211]                             if (is.null(name)) 
[10:59:36.211]                               next
[10:59:36.211]                             if (!grepl(pattern, name)) 
[10:59:36.211]                               next
[10:59:36.211]                             invokeRestart(restart)
[10:59:36.211]                             muffled <- TRUE
[10:59:36.211]                             break
[10:59:36.211]                           }
[10:59:36.211]                         }
[10:59:36.211]                       }
[10:59:36.211]                       invisible(muffled)
[10:59:36.211]                     }
[10:59:36.211]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.211]                   }
[10:59:36.211]                 }
[10:59:36.211]                 else {
[10:59:36.211]                   if (TRUE) {
[10:59:36.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.211]                     {
[10:59:36.211]                       inherits <- base::inherits
[10:59:36.211]                       invokeRestart <- base::invokeRestart
[10:59:36.211]                       is.null <- base::is.null
[10:59:36.211]                       muffled <- FALSE
[10:59:36.211]                       if (inherits(cond, "message")) {
[10:59:36.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.211]                         if (muffled) 
[10:59:36.211]                           invokeRestart("muffleMessage")
[10:59:36.211]                       }
[10:59:36.211]                       else if (inherits(cond, "warning")) {
[10:59:36.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.211]                         if (muffled) 
[10:59:36.211]                           invokeRestart("muffleWarning")
[10:59:36.211]                       }
[10:59:36.211]                       else if (inherits(cond, "condition")) {
[10:59:36.211]                         if (!is.null(pattern)) {
[10:59:36.211]                           computeRestarts <- base::computeRestarts
[10:59:36.211]                           grepl <- base::grepl
[10:59:36.211]                           restarts <- computeRestarts(cond)
[10:59:36.211]                           for (restart in restarts) {
[10:59:36.211]                             name <- restart$name
[10:59:36.211]                             if (is.null(name)) 
[10:59:36.211]                               next
[10:59:36.211]                             if (!grepl(pattern, name)) 
[10:59:36.211]                               next
[10:59:36.211]                             invokeRestart(restart)
[10:59:36.211]                             muffled <- TRUE
[10:59:36.211]                             break
[10:59:36.211]                           }
[10:59:36.211]                         }
[10:59:36.211]                       }
[10:59:36.211]                       invisible(muffled)
[10:59:36.211]                     }
[10:59:36.211]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.211]                   }
[10:59:36.211]                 }
[10:59:36.211]             }
[10:59:36.211]         }))
[10:59:36.211]     }, error = function(ex) {
[10:59:36.211]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.211]                 ...future.rng), started = ...future.startTime, 
[10:59:36.211]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.211]             version = "1.8"), class = "FutureResult")
[10:59:36.211]     }, finally = {
[10:59:36.211]         if (!identical(...future.workdir, getwd())) 
[10:59:36.211]             setwd(...future.workdir)
[10:59:36.211]         {
[10:59:36.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.211]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.211]             }
[10:59:36.211]             base::options(...future.oldOptions)
[10:59:36.211]             if (.Platform$OS.type == "windows") {
[10:59:36.211]                 old_names <- names(...future.oldEnvVars)
[10:59:36.211]                 envs <- base::Sys.getenv()
[10:59:36.211]                 names <- names(envs)
[10:59:36.211]                 common <- intersect(names, old_names)
[10:59:36.211]                 added <- setdiff(names, old_names)
[10:59:36.211]                 removed <- setdiff(old_names, names)
[10:59:36.211]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.211]                   envs[common]]
[10:59:36.211]                 NAMES <- toupper(changed)
[10:59:36.211]                 args <- list()
[10:59:36.211]                 for (kk in seq_along(NAMES)) {
[10:59:36.211]                   name <- changed[[kk]]
[10:59:36.211]                   NAME <- NAMES[[kk]]
[10:59:36.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.211]                     next
[10:59:36.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.211]                 }
[10:59:36.211]                 NAMES <- toupper(added)
[10:59:36.211]                 for (kk in seq_along(NAMES)) {
[10:59:36.211]                   name <- added[[kk]]
[10:59:36.211]                   NAME <- NAMES[[kk]]
[10:59:36.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.211]                     next
[10:59:36.211]                   args[[name]] <- ""
[10:59:36.211]                 }
[10:59:36.211]                 NAMES <- toupper(removed)
[10:59:36.211]                 for (kk in seq_along(NAMES)) {
[10:59:36.211]                   name <- removed[[kk]]
[10:59:36.211]                   NAME <- NAMES[[kk]]
[10:59:36.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.211]                     next
[10:59:36.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.211]                 }
[10:59:36.211]                 if (length(args) > 0) 
[10:59:36.211]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.211]             }
[10:59:36.211]             else {
[10:59:36.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.211]             }
[10:59:36.211]             {
[10:59:36.211]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.211]                   0L) {
[10:59:36.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.211]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.211]                   base::options(opts)
[10:59:36.211]                 }
[10:59:36.211]                 {
[10:59:36.211]                   {
[10:59:36.211]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.211]                     NULL
[10:59:36.211]                   }
[10:59:36.211]                   options(future.plan = NULL)
[10:59:36.211]                   if (is.na(NA_character_)) 
[10:59:36.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.211]                     .init = FALSE)
[10:59:36.211]                 }
[10:59:36.211]             }
[10:59:36.211]         }
[10:59:36.211]     })
[10:59:36.211]     if (TRUE) {
[10:59:36.211]         base::sink(type = "output", split = FALSE)
[10:59:36.211]         if (TRUE) {
[10:59:36.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.211]         }
[10:59:36.211]         else {
[10:59:36.211]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.211]         }
[10:59:36.211]         base::close(...future.stdout)
[10:59:36.211]         ...future.stdout <- NULL
[10:59:36.211]     }
[10:59:36.211]     ...future.result$conditions <- ...future.conditions
[10:59:36.211]     ...future.result$finished <- base::Sys.time()
[10:59:36.211]     ...future.result
[10:59:36.211] }
[10:59:36.213] Exporting 5 global objects (1.32 KiB) to cluster node #2 ...
[10:59:36.213] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:59:36.214] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:59:36.214] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:36.214] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.215] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:59:36.215] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:59:36.215] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:36.215] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.215] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:36.216] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.216] Exporting 5 global objects (1.32 KiB) to cluster node #2 ... DONE
[10:59:36.216] MultisessionFuture started
[10:59:36.217] - Launch lazy future ... done
[10:59:36.217] run() for ‘MultisessionFuture’ ... done
[10:59:36.217] Created future:
[10:59:36.217] MultisessionFuture:
[10:59:36.217] Label: ‘future_mapply-2’
[10:59:36.217] Expression:
[10:59:36.217] {
[10:59:36.217]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.217]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.217]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.217]         on.exit(options(oopts), add = TRUE)
[10:59:36.217]     }
[10:59:36.217]     {
[10:59:36.217]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.217]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.217]         do.call(mapply, args = args)
[10:59:36.217]     }
[10:59:36.217] }
[10:59:36.217] Lazy evaluation: FALSE
[10:59:36.217] Asynchronous evaluation: TRUE
[10:59:36.217] Local evaluation: TRUE
[10:59:36.217] Environment: R_GlobalEnv
[10:59:36.217] Capture standard output: TRUE
[10:59:36.217] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.217] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.217] Packages: <none>
[10:59:36.217] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.217] Resolved: FALSE
[10:59:36.217] Value: <not collected>
[10:59:36.217] Conditions captured: <none>
[10:59:36.217] Early signaling: FALSE
[10:59:36.217] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.217] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.228] Chunk #2 of 2 ... DONE
[10:59:36.228] Launching 2 futures (chunks) ... DONE
[10:59:36.228] Resolving 2 futures (chunks) ...
[10:59:36.228] resolve() on list ...
[10:59:36.229]  recursive: 0
[10:59:36.229]  length: 2
[10:59:36.229] 
[10:59:36.229] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.229] - Validating connection of MultisessionFuture
[10:59:36.229] - received message: FutureResult
[10:59:36.229] - Received FutureResult
[10:59:36.230] - Erased future from FutureRegistry
[10:59:36.230] result() for ClusterFuture ...
[10:59:36.230] - result already collected: FutureResult
[10:59:36.230] result() for ClusterFuture ... done
[10:59:36.230] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.230] Future #1
[10:59:36.230] result() for ClusterFuture ...
[10:59:36.230] - result already collected: FutureResult
[10:59:36.230] result() for ClusterFuture ... done
[10:59:36.230] result() for ClusterFuture ...
[10:59:36.230] - result already collected: FutureResult
[10:59:36.230] result() for ClusterFuture ... done
[10:59:36.231] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.231] - nx: 2
[10:59:36.231] - relay: TRUE
[10:59:36.231] - stdout: TRUE
[10:59:36.231] - signal: TRUE
[10:59:36.231] - resignal: FALSE
[10:59:36.231] - force: TRUE
[10:59:36.231] - relayed: [n=2] FALSE, FALSE
[10:59:36.231] - queued futures: [n=2] FALSE, FALSE
[10:59:36.231]  - until=1
[10:59:36.231]  - relaying element #1
[10:59:36.231] result() for ClusterFuture ...
[10:59:36.231] - result already collected: FutureResult
[10:59:36.232] result() for ClusterFuture ... done
[10:59:36.232] result() for ClusterFuture ...
[10:59:36.232] - result already collected: FutureResult
[10:59:36.232] result() for ClusterFuture ... done
[10:59:36.232] result() for ClusterFuture ...
[10:59:36.232] - result already collected: FutureResult
[10:59:36.232] result() for ClusterFuture ... done
[10:59:36.232] result() for ClusterFuture ...
[10:59:36.232] - result already collected: FutureResult
[10:59:36.232] result() for ClusterFuture ... done
[10:59:36.232] - relayed: [n=2] TRUE, FALSE
[10:59:36.232] - queued futures: [n=2] TRUE, FALSE
[10:59:36.232] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.233]  length: 1 (resolved future 1)
[10:59:36.258] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.258] - Validating connection of MultisessionFuture
[10:59:36.258] - received message: FutureResult
[10:59:36.258] - Received FutureResult
[10:59:36.259] - Erased future from FutureRegistry
[10:59:36.259] result() for ClusterFuture ...
[10:59:36.259] - result already collected: FutureResult
[10:59:36.259] result() for ClusterFuture ... done
[10:59:36.259] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.259] Future #2
[10:59:36.259] result() for ClusterFuture ...
[10:59:36.259] - result already collected: FutureResult
[10:59:36.259] result() for ClusterFuture ... done
[10:59:36.259] result() for ClusterFuture ...
[10:59:36.259] - result already collected: FutureResult
[10:59:36.259] result() for ClusterFuture ... done
[10:59:36.259] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:36.260] - nx: 2
[10:59:36.260] - relay: TRUE
[10:59:36.260] - stdout: TRUE
[10:59:36.260] - signal: TRUE
[10:59:36.260] - resignal: FALSE
[10:59:36.260] - force: TRUE
[10:59:36.260] - relayed: [n=2] TRUE, FALSE
[10:59:36.260] - queued futures: [n=2] TRUE, FALSE
[10:59:36.260]  - until=2
[10:59:36.260]  - relaying element #2
[10:59:36.260] result() for ClusterFuture ...
[10:59:36.260] - result already collected: FutureResult
[10:59:36.260] result() for ClusterFuture ... done
[10:59:36.261] result() for ClusterFuture ...
[10:59:36.261] - result already collected: FutureResult
[10:59:36.261] result() for ClusterFuture ... done
[10:59:36.261] result() for ClusterFuture ...
[10:59:36.261] - result already collected: FutureResult
[10:59:36.261] result() for ClusterFuture ... done
[10:59:36.261] result() for ClusterFuture ...
[10:59:36.261] - result already collected: FutureResult
[10:59:36.261] result() for ClusterFuture ... done
[10:59:36.261] - relayed: [n=2] TRUE, TRUE
[10:59:36.261] - queued futures: [n=2] TRUE, TRUE
[10:59:36.261] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:36.262]  length: 0 (resolved future 2)
[10:59:36.262] Relaying remaining futures
[10:59:36.262] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.262] - nx: 2
[10:59:36.262] - relay: TRUE
[10:59:36.262] - stdout: TRUE
[10:59:36.262] - signal: TRUE
[10:59:36.262] - resignal: FALSE
[10:59:36.262] - force: TRUE
[10:59:36.262] - relayed: [n=2] TRUE, TRUE
[10:59:36.262] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:36.262] - relayed: [n=2] TRUE, TRUE
[10:59:36.263] - queued futures: [n=2] TRUE, TRUE
[10:59:36.263] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.263] resolve() on list ... DONE
[10:59:36.263] result() for ClusterFuture ...
[10:59:36.263] - result already collected: FutureResult
[10:59:36.263] result() for ClusterFuture ... done
[10:59:36.263] result() for ClusterFuture ...
[10:59:36.263] - result already collected: FutureResult
[10:59:36.263] result() for ClusterFuture ... done
[10:59:36.263] result() for ClusterFuture ...
[10:59:36.263] - result already collected: FutureResult
[10:59:36.263] result() for ClusterFuture ... done
[10:59:36.264] result() for ClusterFuture ...
[10:59:36.264] - result already collected: FutureResult
[10:59:36.264] result() for ClusterFuture ... done
[10:59:36.264]  - Number of value chunks collected: 2
[10:59:36.264] Resolving 2 futures (chunks) ... DONE
[10:59:36.264] Reducing values from 2 chunks ...
[10:59:36.264]  - Number of values collected after concatenation: 5
[10:59:36.264]  - Number of values expected: 5
[10:59:36.264] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:59:36.264] Reducing values from 2 chunks ... DONE
[10:59:36.264] future_mapply() ... DONE
[10:59:36.265] future_mapply() ...
[10:59:36.266] Number of chunks: 2
[10:59:36.266] getGlobalsAndPackagesXApply() ...
[10:59:36.266]  - future.globals: TRUE
[10:59:36.266] getGlobalsAndPackages() ...
[10:59:36.266] Searching for globals...
[10:59:36.268] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:59:36.268] Searching for globals ... DONE
[10:59:36.268] Resolving globals: FALSE
[10:59:36.268] The total size of the 1 globals is 690 bytes (690 bytes)
[10:59:36.268] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:59:36.269] - globals: [1] ‘FUN’
[10:59:36.269] 
[10:59:36.269] getGlobalsAndPackages() ... DONE
[10:59:36.269]  - globals found/used: [n=1] ‘FUN’
[10:59:36.269]  - needed namespaces: [n=0] 
[10:59:36.269] Finding globals ... DONE
[10:59:36.269] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.269] List of 2
[10:59:36.269]  $ ...future.FUN:function (C, k)  
[10:59:36.269]  $ MoreArgs     : list()
[10:59:36.269]  - attr(*, "where")=List of 2
[10:59:36.269]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.269]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.269]  - attr(*, "resolved")= logi FALSE
[10:59:36.269]  - attr(*, "total_size")= num NA
[10:59:36.272] Packages to be attached in all futures: [n=0] 
[10:59:36.272] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.272] Number of futures (= number of chunks): 2
[10:59:36.272] Launching 2 futures (chunks) ...
[10:59:36.272] Chunk #1 of 2 ...
[10:59:36.272]  - Finding globals in '...' for chunk #1 ...
[10:59:36.272] getGlobalsAndPackages() ...
[10:59:36.273] Searching for globals...
[10:59:36.273] 
[10:59:36.273] Searching for globals ... DONE
[10:59:36.273] - globals: [0] <none>
[10:59:36.273] getGlobalsAndPackages() ... DONE
[10:59:36.273]    + additional globals found: [n=0] 
[10:59:36.273]    + additional namespaces needed: [n=0] 
[10:59:36.273]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.273]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.273]  - seeds: <none>
[10:59:36.274]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.274] getGlobalsAndPackages() ...
[10:59:36.274] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.274] Resolving globals: FALSE
[10:59:36.274] The total size of the 5 globals is 880 bytes (880 bytes)
[10:59:36.275] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:36.275] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.275] 
[10:59:36.275] getGlobalsAndPackages() ... DONE
[10:59:36.275] run() for ‘Future’ ...
[10:59:36.275] - state: ‘created’
[10:59:36.275] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.289] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.289]   - Field: ‘node’
[10:59:36.289]   - Field: ‘label’
[10:59:36.289]   - Field: ‘local’
[10:59:36.290]   - Field: ‘owner’
[10:59:36.290]   - Field: ‘envir’
[10:59:36.290]   - Field: ‘workers’
[10:59:36.290]   - Field: ‘packages’
[10:59:36.290]   - Field: ‘gc’
[10:59:36.290]   - Field: ‘conditions’
[10:59:36.290]   - Field: ‘persistent’
[10:59:36.290]   - Field: ‘expr’
[10:59:36.290]   - Field: ‘uuid’
[10:59:36.290]   - Field: ‘seed’
[10:59:36.290]   - Field: ‘version’
[10:59:36.290]   - Field: ‘result’
[10:59:36.291]   - Field: ‘asynchronous’
[10:59:36.291]   - Field: ‘calls’
[10:59:36.291]   - Field: ‘globals’
[10:59:36.291]   - Field: ‘stdout’
[10:59:36.291]   - Field: ‘earlySignal’
[10:59:36.291]   - Field: ‘lazy’
[10:59:36.291]   - Field: ‘state’
[10:59:36.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.291] - Launch lazy future ...
[10:59:36.291] Packages needed by the future expression (n = 0): <none>
[10:59:36.292] Packages needed by future strategies (n = 0): <none>
[10:59:36.292] {
[10:59:36.292]     {
[10:59:36.292]         {
[10:59:36.292]             ...future.startTime <- base::Sys.time()
[10:59:36.292]             {
[10:59:36.292]                 {
[10:59:36.292]                   {
[10:59:36.292]                     {
[10:59:36.292]                       base::local({
[10:59:36.292]                         has_future <- base::requireNamespace("future", 
[10:59:36.292]                           quietly = TRUE)
[10:59:36.292]                         if (has_future) {
[10:59:36.292]                           ns <- base::getNamespace("future")
[10:59:36.292]                           version <- ns[[".package"]][["version"]]
[10:59:36.292]                           if (is.null(version)) 
[10:59:36.292]                             version <- utils::packageVersion("future")
[10:59:36.292]                         }
[10:59:36.292]                         else {
[10:59:36.292]                           version <- NULL
[10:59:36.292]                         }
[10:59:36.292]                         if (!has_future || version < "1.8.0") {
[10:59:36.292]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.292]                             "", base::R.version$version.string), 
[10:59:36.292]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.292]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.292]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.292]                               "release", "version")], collapse = " "), 
[10:59:36.292]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.292]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.292]                             info)
[10:59:36.292]                           info <- base::paste(info, collapse = "; ")
[10:59:36.292]                           if (!has_future) {
[10:59:36.292]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.292]                               info)
[10:59:36.292]                           }
[10:59:36.292]                           else {
[10:59:36.292]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.292]                               info, version)
[10:59:36.292]                           }
[10:59:36.292]                           base::stop(msg)
[10:59:36.292]                         }
[10:59:36.292]                       })
[10:59:36.292]                     }
[10:59:36.292]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.292]                     base::options(mc.cores = 1L)
[10:59:36.292]                   }
[10:59:36.292]                   ...future.strategy.old <- future::plan("list")
[10:59:36.292]                   options(future.plan = NULL)
[10:59:36.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.292]                 }
[10:59:36.292]                 ...future.workdir <- getwd()
[10:59:36.292]             }
[10:59:36.292]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.292]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.292]         }
[10:59:36.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.292]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.292]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.292]             base::names(...future.oldOptions))
[10:59:36.292]     }
[10:59:36.292]     if (FALSE) {
[10:59:36.292]     }
[10:59:36.292]     else {
[10:59:36.292]         if (TRUE) {
[10:59:36.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.292]                 open = "w")
[10:59:36.292]         }
[10:59:36.292]         else {
[10:59:36.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.292]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.292]         }
[10:59:36.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.292]             base::sink(type = "output", split = FALSE)
[10:59:36.292]             base::close(...future.stdout)
[10:59:36.292]         }, add = TRUE)
[10:59:36.292]     }
[10:59:36.292]     ...future.frame <- base::sys.nframe()
[10:59:36.292]     ...future.conditions <- base::list()
[10:59:36.292]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.292]     if (FALSE) {
[10:59:36.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.292]     }
[10:59:36.292]     ...future.result <- base::tryCatch({
[10:59:36.292]         base::withCallingHandlers({
[10:59:36.292]             ...future.value <- base::withVisible(base::local({
[10:59:36.292]                 ...future.makeSendCondition <- base::local({
[10:59:36.292]                   sendCondition <- NULL
[10:59:36.292]                   function(frame = 1L) {
[10:59:36.292]                     if (is.function(sendCondition)) 
[10:59:36.292]                       return(sendCondition)
[10:59:36.292]                     ns <- getNamespace("parallel")
[10:59:36.292]                     if (exists("sendData", mode = "function", 
[10:59:36.292]                       envir = ns)) {
[10:59:36.292]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.292]                         envir = ns)
[10:59:36.292]                       envir <- sys.frame(frame)
[10:59:36.292]                       master <- NULL
[10:59:36.292]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.292]                         !identical(envir, emptyenv())) {
[10:59:36.292]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.292]                           inherits = FALSE)) {
[10:59:36.292]                           master <- get("master", mode = "list", 
[10:59:36.292]                             envir = envir, inherits = FALSE)
[10:59:36.292]                           if (inherits(master, c("SOCKnode", 
[10:59:36.292]                             "SOCK0node"))) {
[10:59:36.292]                             sendCondition <<- function(cond) {
[10:59:36.292]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.292]                                 success = TRUE)
[10:59:36.292]                               parallel_sendData(master, data)
[10:59:36.292]                             }
[10:59:36.292]                             return(sendCondition)
[10:59:36.292]                           }
[10:59:36.292]                         }
[10:59:36.292]                         frame <- frame + 1L
[10:59:36.292]                         envir <- sys.frame(frame)
[10:59:36.292]                       }
[10:59:36.292]                     }
[10:59:36.292]                     sendCondition <<- function(cond) NULL
[10:59:36.292]                   }
[10:59:36.292]                 })
[10:59:36.292]                 withCallingHandlers({
[10:59:36.292]                   {
[10:59:36.292]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.292]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.292]                       ...future.globals.maxSize)) {
[10:59:36.292]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.292]                       on.exit(options(oopts), add = TRUE)
[10:59:36.292]                     }
[10:59:36.292]                     {
[10:59:36.292]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.292]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.292]                         USE.NAMES = FALSE)
[10:59:36.292]                       do.call(mapply, args = args)
[10:59:36.292]                     }
[10:59:36.292]                   }
[10:59:36.292]                 }, immediateCondition = function(cond) {
[10:59:36.292]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.292]                   sendCondition(cond)
[10:59:36.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.292]                   {
[10:59:36.292]                     inherits <- base::inherits
[10:59:36.292]                     invokeRestart <- base::invokeRestart
[10:59:36.292]                     is.null <- base::is.null
[10:59:36.292]                     muffled <- FALSE
[10:59:36.292]                     if (inherits(cond, "message")) {
[10:59:36.292]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.292]                       if (muffled) 
[10:59:36.292]                         invokeRestart("muffleMessage")
[10:59:36.292]                     }
[10:59:36.292]                     else if (inherits(cond, "warning")) {
[10:59:36.292]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.292]                       if (muffled) 
[10:59:36.292]                         invokeRestart("muffleWarning")
[10:59:36.292]                     }
[10:59:36.292]                     else if (inherits(cond, "condition")) {
[10:59:36.292]                       if (!is.null(pattern)) {
[10:59:36.292]                         computeRestarts <- base::computeRestarts
[10:59:36.292]                         grepl <- base::grepl
[10:59:36.292]                         restarts <- computeRestarts(cond)
[10:59:36.292]                         for (restart in restarts) {
[10:59:36.292]                           name <- restart$name
[10:59:36.292]                           if (is.null(name)) 
[10:59:36.292]                             next
[10:59:36.292]                           if (!grepl(pattern, name)) 
[10:59:36.292]                             next
[10:59:36.292]                           invokeRestart(restart)
[10:59:36.292]                           muffled <- TRUE
[10:59:36.292]                           break
[10:59:36.292]                         }
[10:59:36.292]                       }
[10:59:36.292]                     }
[10:59:36.292]                     invisible(muffled)
[10:59:36.292]                   }
[10:59:36.292]                   muffleCondition(cond)
[10:59:36.292]                 })
[10:59:36.292]             }))
[10:59:36.292]             future::FutureResult(value = ...future.value$value, 
[10:59:36.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.292]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.292]                     ...future.globalenv.names))
[10:59:36.292]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.292]         }, condition = base::local({
[10:59:36.292]             c <- base::c
[10:59:36.292]             inherits <- base::inherits
[10:59:36.292]             invokeRestart <- base::invokeRestart
[10:59:36.292]             length <- base::length
[10:59:36.292]             list <- base::list
[10:59:36.292]             seq.int <- base::seq.int
[10:59:36.292]             signalCondition <- base::signalCondition
[10:59:36.292]             sys.calls <- base::sys.calls
[10:59:36.292]             `[[` <- base::`[[`
[10:59:36.292]             `+` <- base::`+`
[10:59:36.292]             `<<-` <- base::`<<-`
[10:59:36.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.292]                   3L)]
[10:59:36.292]             }
[10:59:36.292]             function(cond) {
[10:59:36.292]                 is_error <- inherits(cond, "error")
[10:59:36.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.292]                   NULL)
[10:59:36.292]                 if (is_error) {
[10:59:36.292]                   sessionInformation <- function() {
[10:59:36.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.292]                       search = base::search(), system = base::Sys.info())
[10:59:36.292]                   }
[10:59:36.292]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.292]                     cond$call), session = sessionInformation(), 
[10:59:36.292]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.292]                   signalCondition(cond)
[10:59:36.292]                 }
[10:59:36.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.292]                 "immediateCondition"))) {
[10:59:36.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.292]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.292]                   if (TRUE && !signal) {
[10:59:36.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.292]                     {
[10:59:36.292]                       inherits <- base::inherits
[10:59:36.292]                       invokeRestart <- base::invokeRestart
[10:59:36.292]                       is.null <- base::is.null
[10:59:36.292]                       muffled <- FALSE
[10:59:36.292]                       if (inherits(cond, "message")) {
[10:59:36.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.292]                         if (muffled) 
[10:59:36.292]                           invokeRestart("muffleMessage")
[10:59:36.292]                       }
[10:59:36.292]                       else if (inherits(cond, "warning")) {
[10:59:36.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.292]                         if (muffled) 
[10:59:36.292]                           invokeRestart("muffleWarning")
[10:59:36.292]                       }
[10:59:36.292]                       else if (inherits(cond, "condition")) {
[10:59:36.292]                         if (!is.null(pattern)) {
[10:59:36.292]                           computeRestarts <- base::computeRestarts
[10:59:36.292]                           grepl <- base::grepl
[10:59:36.292]                           restarts <- computeRestarts(cond)
[10:59:36.292]                           for (restart in restarts) {
[10:59:36.292]                             name <- restart$name
[10:59:36.292]                             if (is.null(name)) 
[10:59:36.292]                               next
[10:59:36.292]                             if (!grepl(pattern, name)) 
[10:59:36.292]                               next
[10:59:36.292]                             invokeRestart(restart)
[10:59:36.292]                             muffled <- TRUE
[10:59:36.292]                             break
[10:59:36.292]                           }
[10:59:36.292]                         }
[10:59:36.292]                       }
[10:59:36.292]                       invisible(muffled)
[10:59:36.292]                     }
[10:59:36.292]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.292]                   }
[10:59:36.292]                 }
[10:59:36.292]                 else {
[10:59:36.292]                   if (TRUE) {
[10:59:36.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.292]                     {
[10:59:36.292]                       inherits <- base::inherits
[10:59:36.292]                       invokeRestart <- base::invokeRestart
[10:59:36.292]                       is.null <- base::is.null
[10:59:36.292]                       muffled <- FALSE
[10:59:36.292]                       if (inherits(cond, "message")) {
[10:59:36.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.292]                         if (muffled) 
[10:59:36.292]                           invokeRestart("muffleMessage")
[10:59:36.292]                       }
[10:59:36.292]                       else if (inherits(cond, "warning")) {
[10:59:36.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.292]                         if (muffled) 
[10:59:36.292]                           invokeRestart("muffleWarning")
[10:59:36.292]                       }
[10:59:36.292]                       else if (inherits(cond, "condition")) {
[10:59:36.292]                         if (!is.null(pattern)) {
[10:59:36.292]                           computeRestarts <- base::computeRestarts
[10:59:36.292]                           grepl <- base::grepl
[10:59:36.292]                           restarts <- computeRestarts(cond)
[10:59:36.292]                           for (restart in restarts) {
[10:59:36.292]                             name <- restart$name
[10:59:36.292]                             if (is.null(name)) 
[10:59:36.292]                               next
[10:59:36.292]                             if (!grepl(pattern, name)) 
[10:59:36.292]                               next
[10:59:36.292]                             invokeRestart(restart)
[10:59:36.292]                             muffled <- TRUE
[10:59:36.292]                             break
[10:59:36.292]                           }
[10:59:36.292]                         }
[10:59:36.292]                       }
[10:59:36.292]                       invisible(muffled)
[10:59:36.292]                     }
[10:59:36.292]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.292]                   }
[10:59:36.292]                 }
[10:59:36.292]             }
[10:59:36.292]         }))
[10:59:36.292]     }, error = function(ex) {
[10:59:36.292]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.292]                 ...future.rng), started = ...future.startTime, 
[10:59:36.292]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.292]             version = "1.8"), class = "FutureResult")
[10:59:36.292]     }, finally = {
[10:59:36.292]         if (!identical(...future.workdir, getwd())) 
[10:59:36.292]             setwd(...future.workdir)
[10:59:36.292]         {
[10:59:36.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.292]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.292]             }
[10:59:36.292]             base::options(...future.oldOptions)
[10:59:36.292]             if (.Platform$OS.type == "windows") {
[10:59:36.292]                 old_names <- names(...future.oldEnvVars)
[10:59:36.292]                 envs <- base::Sys.getenv()
[10:59:36.292]                 names <- names(envs)
[10:59:36.292]                 common <- intersect(names, old_names)
[10:59:36.292]                 added <- setdiff(names, old_names)
[10:59:36.292]                 removed <- setdiff(old_names, names)
[10:59:36.292]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.292]                   envs[common]]
[10:59:36.292]                 NAMES <- toupper(changed)
[10:59:36.292]                 args <- list()
[10:59:36.292]                 for (kk in seq_along(NAMES)) {
[10:59:36.292]                   name <- changed[[kk]]
[10:59:36.292]                   NAME <- NAMES[[kk]]
[10:59:36.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.292]                     next
[10:59:36.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.292]                 }
[10:59:36.292]                 NAMES <- toupper(added)
[10:59:36.292]                 for (kk in seq_along(NAMES)) {
[10:59:36.292]                   name <- added[[kk]]
[10:59:36.292]                   NAME <- NAMES[[kk]]
[10:59:36.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.292]                     next
[10:59:36.292]                   args[[name]] <- ""
[10:59:36.292]                 }
[10:59:36.292]                 NAMES <- toupper(removed)
[10:59:36.292]                 for (kk in seq_along(NAMES)) {
[10:59:36.292]                   name <- removed[[kk]]
[10:59:36.292]                   NAME <- NAMES[[kk]]
[10:59:36.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.292]                     next
[10:59:36.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.292]                 }
[10:59:36.292]                 if (length(args) > 0) 
[10:59:36.292]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.292]             }
[10:59:36.292]             else {
[10:59:36.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.292]             }
[10:59:36.292]             {
[10:59:36.292]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.292]                   0L) {
[10:59:36.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.292]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.292]                   base::options(opts)
[10:59:36.292]                 }
[10:59:36.292]                 {
[10:59:36.292]                   {
[10:59:36.292]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.292]                     NULL
[10:59:36.292]                   }
[10:59:36.292]                   options(future.plan = NULL)
[10:59:36.292]                   if (is.na(NA_character_)) 
[10:59:36.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.292]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.292]                     .init = FALSE)
[10:59:36.292]                 }
[10:59:36.292]             }
[10:59:36.292]         }
[10:59:36.292]     })
[10:59:36.292]     if (TRUE) {
[10:59:36.292]         base::sink(type = "output", split = FALSE)
[10:59:36.292]         if (TRUE) {
[10:59:36.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.292]         }
[10:59:36.292]         else {
[10:59:36.292]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.292]         }
[10:59:36.292]         base::close(...future.stdout)
[10:59:36.292]         ...future.stdout <- NULL
[10:59:36.292]     }
[10:59:36.292]     ...future.result$conditions <- ...future.conditions
[10:59:36.292]     ...future.result$finished <- base::Sys.time()
[10:59:36.292]     ...future.result
[10:59:36.292] }
[10:59:36.295] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[10:59:36.295] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:59:36.295] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:59:36.295] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:59:36.296] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:59:36.296] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:59:36.296] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:59:36.296] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.297] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.297] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.297] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.297] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[10:59:36.298] MultisessionFuture started
[10:59:36.298] - Launch lazy future ... done
[10:59:36.298] run() for ‘MultisessionFuture’ ... done
[10:59:36.298] Created future:
[10:59:36.298] MultisessionFuture:
[10:59:36.298] Label: ‘future_.mapply-1’
[10:59:36.298] Expression:
[10:59:36.298] {
[10:59:36.298]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.298]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.298]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.298]         on.exit(options(oopts), add = TRUE)
[10:59:36.298]     }
[10:59:36.298]     {
[10:59:36.298]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.298]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.298]         do.call(mapply, args = args)
[10:59:36.298]     }
[10:59:36.298] }
[10:59:36.298] Lazy evaluation: FALSE
[10:59:36.298] Asynchronous evaluation: TRUE
[10:59:36.298] Local evaluation: TRUE
[10:59:36.298] Environment: R_GlobalEnv
[10:59:36.298] Capture standard output: TRUE
[10:59:36.298] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.298] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.298] Packages: <none>
[10:59:36.298] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.298] Resolved: FALSE
[10:59:36.298] Value: <not collected>
[10:59:36.298] Conditions captured: <none>
[10:59:36.298] Early signaling: FALSE
[10:59:36.298] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.298] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.309] Chunk #1 of 2 ... DONE
[10:59:36.309] Chunk #2 of 2 ...
[10:59:36.310]  - Finding globals in '...' for chunk #2 ...
[10:59:36.310] getGlobalsAndPackages() ...
[10:59:36.310] Searching for globals...
[10:59:36.310] 
[10:59:36.310] Searching for globals ... DONE
[10:59:36.310] - globals: [0] <none>
[10:59:36.310] getGlobalsAndPackages() ... DONE
[10:59:36.311]    + additional globals found: [n=0] 
[10:59:36.311]    + additional namespaces needed: [n=0] 
[10:59:36.311]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:36.311]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.311]  - seeds: <none>
[10:59:36.311]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.311] getGlobalsAndPackages() ...
[10:59:36.311] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.311] Resolving globals: FALSE
[10:59:36.312] The total size of the 5 globals is 909 bytes (909 bytes)
[10:59:36.312] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:36.312] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.312] 
[10:59:36.312] getGlobalsAndPackages() ... DONE
[10:59:36.313] run() for ‘Future’ ...
[10:59:36.313] - state: ‘created’
[10:59:36.313] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.327]   - Field: ‘node’
[10:59:36.327]   - Field: ‘label’
[10:59:36.327]   - Field: ‘local’
[10:59:36.327]   - Field: ‘owner’
[10:59:36.327]   - Field: ‘envir’
[10:59:36.327]   - Field: ‘workers’
[10:59:36.327]   - Field: ‘packages’
[10:59:36.327]   - Field: ‘gc’
[10:59:36.327]   - Field: ‘conditions’
[10:59:36.327]   - Field: ‘persistent’
[10:59:36.327]   - Field: ‘expr’
[10:59:36.328]   - Field: ‘uuid’
[10:59:36.328]   - Field: ‘seed’
[10:59:36.328]   - Field: ‘version’
[10:59:36.328]   - Field: ‘result’
[10:59:36.328]   - Field: ‘asynchronous’
[10:59:36.328]   - Field: ‘calls’
[10:59:36.328]   - Field: ‘globals’
[10:59:36.328]   - Field: ‘stdout’
[10:59:36.328]   - Field: ‘earlySignal’
[10:59:36.328]   - Field: ‘lazy’
[10:59:36.328]   - Field: ‘state’
[10:59:36.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.329] - Launch lazy future ...
[10:59:36.329] Packages needed by the future expression (n = 0): <none>
[10:59:36.329] Packages needed by future strategies (n = 0): <none>
[10:59:36.329] {
[10:59:36.329]     {
[10:59:36.329]         {
[10:59:36.329]             ...future.startTime <- base::Sys.time()
[10:59:36.329]             {
[10:59:36.329]                 {
[10:59:36.329]                   {
[10:59:36.329]                     {
[10:59:36.329]                       base::local({
[10:59:36.329]                         has_future <- base::requireNamespace("future", 
[10:59:36.329]                           quietly = TRUE)
[10:59:36.329]                         if (has_future) {
[10:59:36.329]                           ns <- base::getNamespace("future")
[10:59:36.329]                           version <- ns[[".package"]][["version"]]
[10:59:36.329]                           if (is.null(version)) 
[10:59:36.329]                             version <- utils::packageVersion("future")
[10:59:36.329]                         }
[10:59:36.329]                         else {
[10:59:36.329]                           version <- NULL
[10:59:36.329]                         }
[10:59:36.329]                         if (!has_future || version < "1.8.0") {
[10:59:36.329]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.329]                             "", base::R.version$version.string), 
[10:59:36.329]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.329]                               "release", "version")], collapse = " "), 
[10:59:36.329]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.329]                             info)
[10:59:36.329]                           info <- base::paste(info, collapse = "; ")
[10:59:36.329]                           if (!has_future) {
[10:59:36.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.329]                               info)
[10:59:36.329]                           }
[10:59:36.329]                           else {
[10:59:36.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.329]                               info, version)
[10:59:36.329]                           }
[10:59:36.329]                           base::stop(msg)
[10:59:36.329]                         }
[10:59:36.329]                       })
[10:59:36.329]                     }
[10:59:36.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.329]                     base::options(mc.cores = 1L)
[10:59:36.329]                   }
[10:59:36.329]                   ...future.strategy.old <- future::plan("list")
[10:59:36.329]                   options(future.plan = NULL)
[10:59:36.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.329]                 }
[10:59:36.329]                 ...future.workdir <- getwd()
[10:59:36.329]             }
[10:59:36.329]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.329]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.329]         }
[10:59:36.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.329]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.329]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.329]             base::names(...future.oldOptions))
[10:59:36.329]     }
[10:59:36.329]     if (FALSE) {
[10:59:36.329]     }
[10:59:36.329]     else {
[10:59:36.329]         if (TRUE) {
[10:59:36.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.329]                 open = "w")
[10:59:36.329]         }
[10:59:36.329]         else {
[10:59:36.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.329]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.329]         }
[10:59:36.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.329]             base::sink(type = "output", split = FALSE)
[10:59:36.329]             base::close(...future.stdout)
[10:59:36.329]         }, add = TRUE)
[10:59:36.329]     }
[10:59:36.329]     ...future.frame <- base::sys.nframe()
[10:59:36.329]     ...future.conditions <- base::list()
[10:59:36.329]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.329]     if (FALSE) {
[10:59:36.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.329]     }
[10:59:36.329]     ...future.result <- base::tryCatch({
[10:59:36.329]         base::withCallingHandlers({
[10:59:36.329]             ...future.value <- base::withVisible(base::local({
[10:59:36.329]                 ...future.makeSendCondition <- base::local({
[10:59:36.329]                   sendCondition <- NULL
[10:59:36.329]                   function(frame = 1L) {
[10:59:36.329]                     if (is.function(sendCondition)) 
[10:59:36.329]                       return(sendCondition)
[10:59:36.329]                     ns <- getNamespace("parallel")
[10:59:36.329]                     if (exists("sendData", mode = "function", 
[10:59:36.329]                       envir = ns)) {
[10:59:36.329]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.329]                         envir = ns)
[10:59:36.329]                       envir <- sys.frame(frame)
[10:59:36.329]                       master <- NULL
[10:59:36.329]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.329]                         !identical(envir, emptyenv())) {
[10:59:36.329]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.329]                           inherits = FALSE)) {
[10:59:36.329]                           master <- get("master", mode = "list", 
[10:59:36.329]                             envir = envir, inherits = FALSE)
[10:59:36.329]                           if (inherits(master, c("SOCKnode", 
[10:59:36.329]                             "SOCK0node"))) {
[10:59:36.329]                             sendCondition <<- function(cond) {
[10:59:36.329]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.329]                                 success = TRUE)
[10:59:36.329]                               parallel_sendData(master, data)
[10:59:36.329]                             }
[10:59:36.329]                             return(sendCondition)
[10:59:36.329]                           }
[10:59:36.329]                         }
[10:59:36.329]                         frame <- frame + 1L
[10:59:36.329]                         envir <- sys.frame(frame)
[10:59:36.329]                       }
[10:59:36.329]                     }
[10:59:36.329]                     sendCondition <<- function(cond) NULL
[10:59:36.329]                   }
[10:59:36.329]                 })
[10:59:36.329]                 withCallingHandlers({
[10:59:36.329]                   {
[10:59:36.329]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.329]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.329]                       ...future.globals.maxSize)) {
[10:59:36.329]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.329]                       on.exit(options(oopts), add = TRUE)
[10:59:36.329]                     }
[10:59:36.329]                     {
[10:59:36.329]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.329]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.329]                         USE.NAMES = FALSE)
[10:59:36.329]                       do.call(mapply, args = args)
[10:59:36.329]                     }
[10:59:36.329]                   }
[10:59:36.329]                 }, immediateCondition = function(cond) {
[10:59:36.329]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.329]                   sendCondition(cond)
[10:59:36.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.329]                   {
[10:59:36.329]                     inherits <- base::inherits
[10:59:36.329]                     invokeRestart <- base::invokeRestart
[10:59:36.329]                     is.null <- base::is.null
[10:59:36.329]                     muffled <- FALSE
[10:59:36.329]                     if (inherits(cond, "message")) {
[10:59:36.329]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.329]                       if (muffled) 
[10:59:36.329]                         invokeRestart("muffleMessage")
[10:59:36.329]                     }
[10:59:36.329]                     else if (inherits(cond, "warning")) {
[10:59:36.329]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.329]                       if (muffled) 
[10:59:36.329]                         invokeRestart("muffleWarning")
[10:59:36.329]                     }
[10:59:36.329]                     else if (inherits(cond, "condition")) {
[10:59:36.329]                       if (!is.null(pattern)) {
[10:59:36.329]                         computeRestarts <- base::computeRestarts
[10:59:36.329]                         grepl <- base::grepl
[10:59:36.329]                         restarts <- computeRestarts(cond)
[10:59:36.329]                         for (restart in restarts) {
[10:59:36.329]                           name <- restart$name
[10:59:36.329]                           if (is.null(name)) 
[10:59:36.329]                             next
[10:59:36.329]                           if (!grepl(pattern, name)) 
[10:59:36.329]                             next
[10:59:36.329]                           invokeRestart(restart)
[10:59:36.329]                           muffled <- TRUE
[10:59:36.329]                           break
[10:59:36.329]                         }
[10:59:36.329]                       }
[10:59:36.329]                     }
[10:59:36.329]                     invisible(muffled)
[10:59:36.329]                   }
[10:59:36.329]                   muffleCondition(cond)
[10:59:36.329]                 })
[10:59:36.329]             }))
[10:59:36.329]             future::FutureResult(value = ...future.value$value, 
[10:59:36.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.329]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.329]                     ...future.globalenv.names))
[10:59:36.329]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.329]         }, condition = base::local({
[10:59:36.329]             c <- base::c
[10:59:36.329]             inherits <- base::inherits
[10:59:36.329]             invokeRestart <- base::invokeRestart
[10:59:36.329]             length <- base::length
[10:59:36.329]             list <- base::list
[10:59:36.329]             seq.int <- base::seq.int
[10:59:36.329]             signalCondition <- base::signalCondition
[10:59:36.329]             sys.calls <- base::sys.calls
[10:59:36.329]             `[[` <- base::`[[`
[10:59:36.329]             `+` <- base::`+`
[10:59:36.329]             `<<-` <- base::`<<-`
[10:59:36.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.329]                   3L)]
[10:59:36.329]             }
[10:59:36.329]             function(cond) {
[10:59:36.329]                 is_error <- inherits(cond, "error")
[10:59:36.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.329]                   NULL)
[10:59:36.329]                 if (is_error) {
[10:59:36.329]                   sessionInformation <- function() {
[10:59:36.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.329]                       search = base::search(), system = base::Sys.info())
[10:59:36.329]                   }
[10:59:36.329]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.329]                     cond$call), session = sessionInformation(), 
[10:59:36.329]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.329]                   signalCondition(cond)
[10:59:36.329]                 }
[10:59:36.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.329]                 "immediateCondition"))) {
[10:59:36.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.329]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.329]                   if (TRUE && !signal) {
[10:59:36.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.329]                     {
[10:59:36.329]                       inherits <- base::inherits
[10:59:36.329]                       invokeRestart <- base::invokeRestart
[10:59:36.329]                       is.null <- base::is.null
[10:59:36.329]                       muffled <- FALSE
[10:59:36.329]                       if (inherits(cond, "message")) {
[10:59:36.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.329]                         if (muffled) 
[10:59:36.329]                           invokeRestart("muffleMessage")
[10:59:36.329]                       }
[10:59:36.329]                       else if (inherits(cond, "warning")) {
[10:59:36.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.329]                         if (muffled) 
[10:59:36.329]                           invokeRestart("muffleWarning")
[10:59:36.329]                       }
[10:59:36.329]                       else if (inherits(cond, "condition")) {
[10:59:36.329]                         if (!is.null(pattern)) {
[10:59:36.329]                           computeRestarts <- base::computeRestarts
[10:59:36.329]                           grepl <- base::grepl
[10:59:36.329]                           restarts <- computeRestarts(cond)
[10:59:36.329]                           for (restart in restarts) {
[10:59:36.329]                             name <- restart$name
[10:59:36.329]                             if (is.null(name)) 
[10:59:36.329]                               next
[10:59:36.329]                             if (!grepl(pattern, name)) 
[10:59:36.329]                               next
[10:59:36.329]                             invokeRestart(restart)
[10:59:36.329]                             muffled <- TRUE
[10:59:36.329]                             break
[10:59:36.329]                           }
[10:59:36.329]                         }
[10:59:36.329]                       }
[10:59:36.329]                       invisible(muffled)
[10:59:36.329]                     }
[10:59:36.329]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.329]                   }
[10:59:36.329]                 }
[10:59:36.329]                 else {
[10:59:36.329]                   if (TRUE) {
[10:59:36.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.329]                     {
[10:59:36.329]                       inherits <- base::inherits
[10:59:36.329]                       invokeRestart <- base::invokeRestart
[10:59:36.329]                       is.null <- base::is.null
[10:59:36.329]                       muffled <- FALSE
[10:59:36.329]                       if (inherits(cond, "message")) {
[10:59:36.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.329]                         if (muffled) 
[10:59:36.329]                           invokeRestart("muffleMessage")
[10:59:36.329]                       }
[10:59:36.329]                       else if (inherits(cond, "warning")) {
[10:59:36.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.329]                         if (muffled) 
[10:59:36.329]                           invokeRestart("muffleWarning")
[10:59:36.329]                       }
[10:59:36.329]                       else if (inherits(cond, "condition")) {
[10:59:36.329]                         if (!is.null(pattern)) {
[10:59:36.329]                           computeRestarts <- base::computeRestarts
[10:59:36.329]                           grepl <- base::grepl
[10:59:36.329]                           restarts <- computeRestarts(cond)
[10:59:36.329]                           for (restart in restarts) {
[10:59:36.329]                             name <- restart$name
[10:59:36.329]                             if (is.null(name)) 
[10:59:36.329]                               next
[10:59:36.329]                             if (!grepl(pattern, name)) 
[10:59:36.329]                               next
[10:59:36.329]                             invokeRestart(restart)
[10:59:36.329]                             muffled <- TRUE
[10:59:36.329]                             break
[10:59:36.329]                           }
[10:59:36.329]                         }
[10:59:36.329]                       }
[10:59:36.329]                       invisible(muffled)
[10:59:36.329]                     }
[10:59:36.329]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.329]                   }
[10:59:36.329]                 }
[10:59:36.329]             }
[10:59:36.329]         }))
[10:59:36.329]     }, error = function(ex) {
[10:59:36.329]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.329]                 ...future.rng), started = ...future.startTime, 
[10:59:36.329]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.329]             version = "1.8"), class = "FutureResult")
[10:59:36.329]     }, finally = {
[10:59:36.329]         if (!identical(...future.workdir, getwd())) 
[10:59:36.329]             setwd(...future.workdir)
[10:59:36.329]         {
[10:59:36.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.329]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.329]             }
[10:59:36.329]             base::options(...future.oldOptions)
[10:59:36.329]             if (.Platform$OS.type == "windows") {
[10:59:36.329]                 old_names <- names(...future.oldEnvVars)
[10:59:36.329]                 envs <- base::Sys.getenv()
[10:59:36.329]                 names <- names(envs)
[10:59:36.329]                 common <- intersect(names, old_names)
[10:59:36.329]                 added <- setdiff(names, old_names)
[10:59:36.329]                 removed <- setdiff(old_names, names)
[10:59:36.329]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.329]                   envs[common]]
[10:59:36.329]                 NAMES <- toupper(changed)
[10:59:36.329]                 args <- list()
[10:59:36.329]                 for (kk in seq_along(NAMES)) {
[10:59:36.329]                   name <- changed[[kk]]
[10:59:36.329]                   NAME <- NAMES[[kk]]
[10:59:36.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.329]                     next
[10:59:36.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.329]                 }
[10:59:36.329]                 NAMES <- toupper(added)
[10:59:36.329]                 for (kk in seq_along(NAMES)) {
[10:59:36.329]                   name <- added[[kk]]
[10:59:36.329]                   NAME <- NAMES[[kk]]
[10:59:36.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.329]                     next
[10:59:36.329]                   args[[name]] <- ""
[10:59:36.329]                 }
[10:59:36.329]                 NAMES <- toupper(removed)
[10:59:36.329]                 for (kk in seq_along(NAMES)) {
[10:59:36.329]                   name <- removed[[kk]]
[10:59:36.329]                   NAME <- NAMES[[kk]]
[10:59:36.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.329]                     next
[10:59:36.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.329]                 }
[10:59:36.329]                 if (length(args) > 0) 
[10:59:36.329]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.329]             }
[10:59:36.329]             else {
[10:59:36.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.329]             }
[10:59:36.329]             {
[10:59:36.329]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.329]                   0L) {
[10:59:36.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.329]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.329]                   base::options(opts)
[10:59:36.329]                 }
[10:59:36.329]                 {
[10:59:36.329]                   {
[10:59:36.329]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.329]                     NULL
[10:59:36.329]                   }
[10:59:36.329]                   options(future.plan = NULL)
[10:59:36.329]                   if (is.na(NA_character_)) 
[10:59:36.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.329]                     .init = FALSE)
[10:59:36.329]                 }
[10:59:36.329]             }
[10:59:36.329]         }
[10:59:36.329]     })
[10:59:36.329]     if (TRUE) {
[10:59:36.329]         base::sink(type = "output", split = FALSE)
[10:59:36.329]         if (TRUE) {
[10:59:36.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.329]         }
[10:59:36.329]         else {
[10:59:36.329]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.329]         }
[10:59:36.329]         base::close(...future.stdout)
[10:59:36.329]         ...future.stdout <- NULL
[10:59:36.329]     }
[10:59:36.329]     ...future.result$conditions <- ...future.conditions
[10:59:36.329]     ...future.result$finished <- base::Sys.time()
[10:59:36.329]     ...future.result
[10:59:36.329] }
[10:59:36.332] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[10:59:36.332] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:59:36.332] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:59:36.333] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:59:36.333] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:59:36.333] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:59:36.333] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:59:36.334] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:36.334] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.334] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:36.334] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.335] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[10:59:36.335] MultisessionFuture started
[10:59:36.335] - Launch lazy future ... done
[10:59:36.335] run() for ‘MultisessionFuture’ ... done
[10:59:36.335] Created future:
[10:59:36.335] MultisessionFuture:
[10:59:36.335] Label: ‘future_.mapply-2’
[10:59:36.335] Expression:
[10:59:36.335] {
[10:59:36.335]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.335]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.335]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.335]         on.exit(options(oopts), add = TRUE)
[10:59:36.335]     }
[10:59:36.335]     {
[10:59:36.335]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.335]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.335]         do.call(mapply, args = args)
[10:59:36.335]     }
[10:59:36.335] }
[10:59:36.335] Lazy evaluation: FALSE
[10:59:36.335] Asynchronous evaluation: TRUE
[10:59:36.335] Local evaluation: TRUE
[10:59:36.335] Environment: R_GlobalEnv
[10:59:36.335] Capture standard output: TRUE
[10:59:36.335] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.335] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.335] Packages: <none>
[10:59:36.335] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.335] Resolved: FALSE
[10:59:36.335] Value: <not collected>
[10:59:36.335] Conditions captured: <none>
[10:59:36.335] Early signaling: FALSE
[10:59:36.335] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.335] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.347] Chunk #2 of 2 ... DONE
[10:59:36.347] Launching 2 futures (chunks) ... DONE
[10:59:36.347] Resolving 2 futures (chunks) ...
[10:59:36.347] resolve() on list ...
[10:59:36.347]  recursive: 0
[10:59:36.347]  length: 2
[10:59:36.347] 
[10:59:36.348] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.348] - Validating connection of MultisessionFuture
[10:59:36.348] - received message: FutureResult
[10:59:36.348] - Received FutureResult
[10:59:36.348] - Erased future from FutureRegistry
[10:59:36.349] result() for ClusterFuture ...
[10:59:36.349] - result already collected: FutureResult
[10:59:36.349] result() for ClusterFuture ... done
[10:59:36.349] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.349] Future #1
[10:59:36.349] result() for ClusterFuture ...
[10:59:36.349] - result already collected: FutureResult
[10:59:36.349] result() for ClusterFuture ... done
[10:59:36.349] result() for ClusterFuture ...
[10:59:36.349] - result already collected: FutureResult
[10:59:36.349] result() for ClusterFuture ... done
[10:59:36.350] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.350] - nx: 2
[10:59:36.350] - relay: TRUE
[10:59:36.350] - stdout: TRUE
[10:59:36.350] - signal: TRUE
[10:59:36.350] - resignal: FALSE
[10:59:36.350] - force: TRUE
[10:59:36.350] - relayed: [n=2] FALSE, FALSE
[10:59:36.350] - queued futures: [n=2] FALSE, FALSE
[10:59:36.350]  - until=1
[10:59:36.350]  - relaying element #1
[10:59:36.350] result() for ClusterFuture ...
[10:59:36.350] - result already collected: FutureResult
[10:59:36.351] result() for ClusterFuture ... done
[10:59:36.351] result() for ClusterFuture ...
[10:59:36.351] - result already collected: FutureResult
[10:59:36.351] result() for ClusterFuture ... done
[10:59:36.351] result() for ClusterFuture ...
[10:59:36.351] - result already collected: FutureResult
[10:59:36.351] result() for ClusterFuture ... done
[10:59:36.351] result() for ClusterFuture ...
[10:59:36.351] - result already collected: FutureResult
[10:59:36.351] result() for ClusterFuture ... done
[10:59:36.351] - relayed: [n=2] TRUE, FALSE
[10:59:36.351] - queued futures: [n=2] TRUE, FALSE
[10:59:36.352] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.352]  length: 1 (resolved future 1)
[10:59:36.377] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.377] - Validating connection of MultisessionFuture
[10:59:36.378] - received message: FutureResult
[10:59:36.378] - Received FutureResult
[10:59:36.378] - Erased future from FutureRegistry
[10:59:36.378] result() for ClusterFuture ...
[10:59:36.378] - result already collected: FutureResult
[10:59:36.378] result() for ClusterFuture ... done
[10:59:36.378] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.378] Future #2
[10:59:36.378] result() for ClusterFuture ...
[10:59:36.378] - result already collected: FutureResult
[10:59:36.378] result() for ClusterFuture ... done
[10:59:36.379] result() for ClusterFuture ...
[10:59:36.379] - result already collected: FutureResult
[10:59:36.379] result() for ClusterFuture ... done
[10:59:36.379] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:36.379] - nx: 2
[10:59:36.379] - relay: TRUE
[10:59:36.379] - stdout: TRUE
[10:59:36.379] - signal: TRUE
[10:59:36.379] - resignal: FALSE
[10:59:36.379] - force: TRUE
[10:59:36.379] - relayed: [n=2] TRUE, FALSE
[10:59:36.379] - queued futures: [n=2] TRUE, FALSE
[10:59:36.380]  - until=2
[10:59:36.380]  - relaying element #2
[10:59:36.380] result() for ClusterFuture ...
[10:59:36.380] - result already collected: FutureResult
[10:59:36.380] result() for ClusterFuture ... done
[10:59:36.380] result() for ClusterFuture ...
[10:59:36.380] - result already collected: FutureResult
[10:59:36.380] result() for ClusterFuture ... done
[10:59:36.380] result() for ClusterFuture ...
[10:59:36.380] - result already collected: FutureResult
[10:59:36.380] result() for ClusterFuture ... done
[10:59:36.381] result() for ClusterFuture ...
[10:59:36.381] - result already collected: FutureResult
[10:59:36.381] result() for ClusterFuture ... done
[10:59:36.381] - relayed: [n=2] TRUE, TRUE
[10:59:36.381] - queued futures: [n=2] TRUE, TRUE
[10:59:36.381] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:36.381]  length: 0 (resolved future 2)
[10:59:36.381] Relaying remaining futures
[10:59:36.381] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.381] - nx: 2
[10:59:36.381] - relay: TRUE
[10:59:36.381] - stdout: TRUE
[10:59:36.383] - signal: TRUE
[10:59:36.384] - resignal: FALSE
[10:59:36.384] - force: TRUE
[10:59:36.384] - relayed: [n=2] TRUE, TRUE
[10:59:36.384] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:36.384] - relayed: [n=2] TRUE, TRUE
[10:59:36.384] - queued futures: [n=2] TRUE, TRUE
[10:59:36.384] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.384] resolve() on list ... DONE
[10:59:36.384] result() for ClusterFuture ...
[10:59:36.384] - result already collected: FutureResult
[10:59:36.384] result() for ClusterFuture ... done
[10:59:36.385] result() for ClusterFuture ...
[10:59:36.385] - result already collected: FutureResult
[10:59:36.385] result() for ClusterFuture ... done
[10:59:36.385] result() for ClusterFuture ...
[10:59:36.385] - result already collected: FutureResult
[10:59:36.385] result() for ClusterFuture ... done
[10:59:36.385] result() for ClusterFuture ...
[10:59:36.385] - result already collected: FutureResult
[10:59:36.385] result() for ClusterFuture ... done
[10:59:36.385]  - Number of value chunks collected: 2
[10:59:36.385] Resolving 2 futures (chunks) ... DONE
[10:59:36.385] Reducing values from 2 chunks ...
[10:59:36.386]  - Number of values collected after concatenation: 5
[10:59:36.386]  - Number of values expected: 5
[10:59:36.386] Reducing values from 2 chunks ... DONE
[10:59:36.386] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:59:36.386] future_mapply() ...
[10:59:36.387] Number of chunks: 1
[10:59:36.388] getGlobalsAndPackagesXApply() ...
[10:59:36.388]  - future.globals: TRUE
[10:59:36.388] getGlobalsAndPackages() ...
[10:59:36.388] Searching for globals...
[10:59:36.389] - globals found: [1] ‘FUN’
[10:59:36.389] Searching for globals ... DONE
[10:59:36.389] Resolving globals: FALSE
[10:59:36.389] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:36.389] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:36.390] - globals: [1] ‘FUN’
[10:59:36.390] 
[10:59:36.390] getGlobalsAndPackages() ... DONE
[10:59:36.390]  - globals found/used: [n=1] ‘FUN’
[10:59:36.390]  - needed namespaces: [n=0] 
[10:59:36.390] Finding globals ... DONE
[10:59:36.390] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.390] List of 2
[10:59:36.390]  $ ...future.FUN:function (x)  
[10:59:36.390]  $ MoreArgs     : NULL
[10:59:36.390]  - attr(*, "where")=List of 2
[10:59:36.390]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.390]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.390]  - attr(*, "resolved")= logi FALSE
[10:59:36.390]  - attr(*, "total_size")= num NA
[10:59:36.393] Packages to be attached in all futures: [n=0] 
[10:59:36.393] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.393] Number of futures (= number of chunks): 1
[10:59:36.393] Launching 1 futures (chunks) ...
[10:59:36.393] Chunk #1 of 1 ...
[10:59:36.393]  - Finding globals in '...' for chunk #1 ...
[10:59:36.393] getGlobalsAndPackages() ...
[10:59:36.393] Searching for globals...
[10:59:36.394] 
[10:59:36.394] Searching for globals ... DONE
[10:59:36.394] - globals: [0] <none>
[10:59:36.394] getGlobalsAndPackages() ... DONE
[10:59:36.394]    + additional globals found: [n=0] 
[10:59:36.394]    + additional namespaces needed: [n=0] 
[10:59:36.394]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.394]  - seeds: <none>
[10:59:36.394]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.394] getGlobalsAndPackages() ...
[10:59:36.394] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.395] Resolving globals: FALSE
[10:59:36.395] The total size of the 5 globals is 366 bytes (366 bytes)
[10:59:36.395] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:36.395] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.396] 
[10:59:36.396] getGlobalsAndPackages() ... DONE
[10:59:36.396] run() for ‘Future’ ...
[10:59:36.396] - state: ‘created’
[10:59:36.396] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.410] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.410]   - Field: ‘node’
[10:59:36.410]   - Field: ‘label’
[10:59:36.410]   - Field: ‘local’
[10:59:36.410]   - Field: ‘owner’
[10:59:36.411]   - Field: ‘envir’
[10:59:36.411]   - Field: ‘workers’
[10:59:36.411]   - Field: ‘packages’
[10:59:36.411]   - Field: ‘gc’
[10:59:36.411]   - Field: ‘conditions’
[10:59:36.411]   - Field: ‘persistent’
[10:59:36.411]   - Field: ‘expr’
[10:59:36.411]   - Field: ‘uuid’
[10:59:36.411]   - Field: ‘seed’
[10:59:36.411]   - Field: ‘version’
[10:59:36.411]   - Field: ‘result’
[10:59:36.411]   - Field: ‘asynchronous’
[10:59:36.411]   - Field: ‘calls’
[10:59:36.412]   - Field: ‘globals’
[10:59:36.412]   - Field: ‘stdout’
[10:59:36.412]   - Field: ‘earlySignal’
[10:59:36.412]   - Field: ‘lazy’
[10:59:36.412]   - Field: ‘state’
[10:59:36.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.412] - Launch lazy future ...
[10:59:36.412] Packages needed by the future expression (n = 0): <none>
[10:59:36.412] Packages needed by future strategies (n = 0): <none>
[10:59:36.413] {
[10:59:36.413]     {
[10:59:36.413]         {
[10:59:36.413]             ...future.startTime <- base::Sys.time()
[10:59:36.413]             {
[10:59:36.413]                 {
[10:59:36.413]                   {
[10:59:36.413]                     {
[10:59:36.413]                       base::local({
[10:59:36.413]                         has_future <- base::requireNamespace("future", 
[10:59:36.413]                           quietly = TRUE)
[10:59:36.413]                         if (has_future) {
[10:59:36.413]                           ns <- base::getNamespace("future")
[10:59:36.413]                           version <- ns[[".package"]][["version"]]
[10:59:36.413]                           if (is.null(version)) 
[10:59:36.413]                             version <- utils::packageVersion("future")
[10:59:36.413]                         }
[10:59:36.413]                         else {
[10:59:36.413]                           version <- NULL
[10:59:36.413]                         }
[10:59:36.413]                         if (!has_future || version < "1.8.0") {
[10:59:36.413]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.413]                             "", base::R.version$version.string), 
[10:59:36.413]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.413]                               "release", "version")], collapse = " "), 
[10:59:36.413]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.413]                             info)
[10:59:36.413]                           info <- base::paste(info, collapse = "; ")
[10:59:36.413]                           if (!has_future) {
[10:59:36.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.413]                               info)
[10:59:36.413]                           }
[10:59:36.413]                           else {
[10:59:36.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.413]                               info, version)
[10:59:36.413]                           }
[10:59:36.413]                           base::stop(msg)
[10:59:36.413]                         }
[10:59:36.413]                       })
[10:59:36.413]                     }
[10:59:36.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.413]                     base::options(mc.cores = 1L)
[10:59:36.413]                   }
[10:59:36.413]                   ...future.strategy.old <- future::plan("list")
[10:59:36.413]                   options(future.plan = NULL)
[10:59:36.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.413]                 }
[10:59:36.413]                 ...future.workdir <- getwd()
[10:59:36.413]             }
[10:59:36.413]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.413]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.413]         }
[10:59:36.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:36.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.413]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.413]             base::names(...future.oldOptions))
[10:59:36.413]     }
[10:59:36.413]     if (FALSE) {
[10:59:36.413]     }
[10:59:36.413]     else {
[10:59:36.413]         if (TRUE) {
[10:59:36.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.413]                 open = "w")
[10:59:36.413]         }
[10:59:36.413]         else {
[10:59:36.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.413]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.413]         }
[10:59:36.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.413]             base::sink(type = "output", split = FALSE)
[10:59:36.413]             base::close(...future.stdout)
[10:59:36.413]         }, add = TRUE)
[10:59:36.413]     }
[10:59:36.413]     ...future.frame <- base::sys.nframe()
[10:59:36.413]     ...future.conditions <- base::list()
[10:59:36.413]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.413]     if (FALSE) {
[10:59:36.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.413]     }
[10:59:36.413]     ...future.result <- base::tryCatch({
[10:59:36.413]         base::withCallingHandlers({
[10:59:36.413]             ...future.value <- base::withVisible(base::local({
[10:59:36.413]                 ...future.makeSendCondition <- base::local({
[10:59:36.413]                   sendCondition <- NULL
[10:59:36.413]                   function(frame = 1L) {
[10:59:36.413]                     if (is.function(sendCondition)) 
[10:59:36.413]                       return(sendCondition)
[10:59:36.413]                     ns <- getNamespace("parallel")
[10:59:36.413]                     if (exists("sendData", mode = "function", 
[10:59:36.413]                       envir = ns)) {
[10:59:36.413]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.413]                         envir = ns)
[10:59:36.413]                       envir <- sys.frame(frame)
[10:59:36.413]                       master <- NULL
[10:59:36.413]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.413]                         !identical(envir, emptyenv())) {
[10:59:36.413]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.413]                           inherits = FALSE)) {
[10:59:36.413]                           master <- get("master", mode = "list", 
[10:59:36.413]                             envir = envir, inherits = FALSE)
[10:59:36.413]                           if (inherits(master, c("SOCKnode", 
[10:59:36.413]                             "SOCK0node"))) {
[10:59:36.413]                             sendCondition <<- function(cond) {
[10:59:36.413]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.413]                                 success = TRUE)
[10:59:36.413]                               parallel_sendData(master, data)
[10:59:36.413]                             }
[10:59:36.413]                             return(sendCondition)
[10:59:36.413]                           }
[10:59:36.413]                         }
[10:59:36.413]                         frame <- frame + 1L
[10:59:36.413]                         envir <- sys.frame(frame)
[10:59:36.413]                       }
[10:59:36.413]                     }
[10:59:36.413]                     sendCondition <<- function(cond) NULL
[10:59:36.413]                   }
[10:59:36.413]                 })
[10:59:36.413]                 withCallingHandlers({
[10:59:36.413]                   {
[10:59:36.413]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.413]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.413]                       ...future.globals.maxSize)) {
[10:59:36.413]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.413]                       on.exit(options(oopts), add = TRUE)
[10:59:36.413]                     }
[10:59:36.413]                     {
[10:59:36.413]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.413]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.413]                         USE.NAMES = FALSE)
[10:59:36.413]                       do.call(mapply, args = args)
[10:59:36.413]                     }
[10:59:36.413]                   }
[10:59:36.413]                 }, immediateCondition = function(cond) {
[10:59:36.413]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.413]                   sendCondition(cond)
[10:59:36.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.413]                   {
[10:59:36.413]                     inherits <- base::inherits
[10:59:36.413]                     invokeRestart <- base::invokeRestart
[10:59:36.413]                     is.null <- base::is.null
[10:59:36.413]                     muffled <- FALSE
[10:59:36.413]                     if (inherits(cond, "message")) {
[10:59:36.413]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.413]                       if (muffled) 
[10:59:36.413]                         invokeRestart("muffleMessage")
[10:59:36.413]                     }
[10:59:36.413]                     else if (inherits(cond, "warning")) {
[10:59:36.413]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.413]                       if (muffled) 
[10:59:36.413]                         invokeRestart("muffleWarning")
[10:59:36.413]                     }
[10:59:36.413]                     else if (inherits(cond, "condition")) {
[10:59:36.413]                       if (!is.null(pattern)) {
[10:59:36.413]                         computeRestarts <- base::computeRestarts
[10:59:36.413]                         grepl <- base::grepl
[10:59:36.413]                         restarts <- computeRestarts(cond)
[10:59:36.413]                         for (restart in restarts) {
[10:59:36.413]                           name <- restart$name
[10:59:36.413]                           if (is.null(name)) 
[10:59:36.413]                             next
[10:59:36.413]                           if (!grepl(pattern, name)) 
[10:59:36.413]                             next
[10:59:36.413]                           invokeRestart(restart)
[10:59:36.413]                           muffled <- TRUE
[10:59:36.413]                           break
[10:59:36.413]                         }
[10:59:36.413]                       }
[10:59:36.413]                     }
[10:59:36.413]                     invisible(muffled)
[10:59:36.413]                   }
[10:59:36.413]                   muffleCondition(cond)
[10:59:36.413]                 })
[10:59:36.413]             }))
[10:59:36.413]             future::FutureResult(value = ...future.value$value, 
[10:59:36.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.413]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.413]                     ...future.globalenv.names))
[10:59:36.413]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.413]         }, condition = base::local({
[10:59:36.413]             c <- base::c
[10:59:36.413]             inherits <- base::inherits
[10:59:36.413]             invokeRestart <- base::invokeRestart
[10:59:36.413]             length <- base::length
[10:59:36.413]             list <- base::list
[10:59:36.413]             seq.int <- base::seq.int
[10:59:36.413]             signalCondition <- base::signalCondition
[10:59:36.413]             sys.calls <- base::sys.calls
[10:59:36.413]             `[[` <- base::`[[`
[10:59:36.413]             `+` <- base::`+`
[10:59:36.413]             `<<-` <- base::`<<-`
[10:59:36.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.413]                   3L)]
[10:59:36.413]             }
[10:59:36.413]             function(cond) {
[10:59:36.413]                 is_error <- inherits(cond, "error")
[10:59:36.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.413]                   NULL)
[10:59:36.413]                 if (is_error) {
[10:59:36.413]                   sessionInformation <- function() {
[10:59:36.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.413]                       search = base::search(), system = base::Sys.info())
[10:59:36.413]                   }
[10:59:36.413]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.413]                     cond$call), session = sessionInformation(), 
[10:59:36.413]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.413]                   signalCondition(cond)
[10:59:36.413]                 }
[10:59:36.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.413]                 "immediateCondition"))) {
[10:59:36.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.413]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.413]                   if (TRUE && !signal) {
[10:59:36.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.413]                     {
[10:59:36.413]                       inherits <- base::inherits
[10:59:36.413]                       invokeRestart <- base::invokeRestart
[10:59:36.413]                       is.null <- base::is.null
[10:59:36.413]                       muffled <- FALSE
[10:59:36.413]                       if (inherits(cond, "message")) {
[10:59:36.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.413]                         if (muffled) 
[10:59:36.413]                           invokeRestart("muffleMessage")
[10:59:36.413]                       }
[10:59:36.413]                       else if (inherits(cond, "warning")) {
[10:59:36.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.413]                         if (muffled) 
[10:59:36.413]                           invokeRestart("muffleWarning")
[10:59:36.413]                       }
[10:59:36.413]                       else if (inherits(cond, "condition")) {
[10:59:36.413]                         if (!is.null(pattern)) {
[10:59:36.413]                           computeRestarts <- base::computeRestarts
[10:59:36.413]                           grepl <- base::grepl
[10:59:36.413]                           restarts <- computeRestarts(cond)
[10:59:36.413]                           for (restart in restarts) {
[10:59:36.413]                             name <- restart$name
[10:59:36.413]                             if (is.null(name)) 
[10:59:36.413]                               next
[10:59:36.413]                             if (!grepl(pattern, name)) 
[10:59:36.413]                               next
[10:59:36.413]                             invokeRestart(restart)
[10:59:36.413]                             muffled <- TRUE
[10:59:36.413]                             break
[10:59:36.413]                           }
[10:59:36.413]                         }
[10:59:36.413]                       }
[10:59:36.413]                       invisible(muffled)
[10:59:36.413]                     }
[10:59:36.413]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.413]                   }
[10:59:36.413]                 }
[10:59:36.413]                 else {
[10:59:36.413]                   if (TRUE) {
[10:59:36.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.413]                     {
[10:59:36.413]                       inherits <- base::inherits
[10:59:36.413]                       invokeRestart <- base::invokeRestart
[10:59:36.413]                       is.null <- base::is.null
[10:59:36.413]                       muffled <- FALSE
[10:59:36.413]                       if (inherits(cond, "message")) {
[10:59:36.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.413]                         if (muffled) 
[10:59:36.413]                           invokeRestart("muffleMessage")
[10:59:36.413]                       }
[10:59:36.413]                       else if (inherits(cond, "warning")) {
[10:59:36.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.413]                         if (muffled) 
[10:59:36.413]                           invokeRestart("muffleWarning")
[10:59:36.413]                       }
[10:59:36.413]                       else if (inherits(cond, "condition")) {
[10:59:36.413]                         if (!is.null(pattern)) {
[10:59:36.413]                           computeRestarts <- base::computeRestarts
[10:59:36.413]                           grepl <- base::grepl
[10:59:36.413]                           restarts <- computeRestarts(cond)
[10:59:36.413]                           for (restart in restarts) {
[10:59:36.413]                             name <- restart$name
[10:59:36.413]                             if (is.null(name)) 
[10:59:36.413]                               next
[10:59:36.413]                             if (!grepl(pattern, name)) 
[10:59:36.413]                               next
[10:59:36.413]                             invokeRestart(restart)
[10:59:36.413]                             muffled <- TRUE
[10:59:36.413]                             break
[10:59:36.413]                           }
[10:59:36.413]                         }
[10:59:36.413]                       }
[10:59:36.413]                       invisible(muffled)
[10:59:36.413]                     }
[10:59:36.413]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.413]                   }
[10:59:36.413]                 }
[10:59:36.413]             }
[10:59:36.413]         }))
[10:59:36.413]     }, error = function(ex) {
[10:59:36.413]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.413]                 ...future.rng), started = ...future.startTime, 
[10:59:36.413]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.413]             version = "1.8"), class = "FutureResult")
[10:59:36.413]     }, finally = {
[10:59:36.413]         if (!identical(...future.workdir, getwd())) 
[10:59:36.413]             setwd(...future.workdir)
[10:59:36.413]         {
[10:59:36.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.413]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.413]             }
[10:59:36.413]             base::options(...future.oldOptions)
[10:59:36.413]             if (.Platform$OS.type == "windows") {
[10:59:36.413]                 old_names <- names(...future.oldEnvVars)
[10:59:36.413]                 envs <- base::Sys.getenv()
[10:59:36.413]                 names <- names(envs)
[10:59:36.413]                 common <- intersect(names, old_names)
[10:59:36.413]                 added <- setdiff(names, old_names)
[10:59:36.413]                 removed <- setdiff(old_names, names)
[10:59:36.413]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.413]                   envs[common]]
[10:59:36.413]                 NAMES <- toupper(changed)
[10:59:36.413]                 args <- list()
[10:59:36.413]                 for (kk in seq_along(NAMES)) {
[10:59:36.413]                   name <- changed[[kk]]
[10:59:36.413]                   NAME <- NAMES[[kk]]
[10:59:36.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.413]                     next
[10:59:36.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.413]                 }
[10:59:36.413]                 NAMES <- toupper(added)
[10:59:36.413]                 for (kk in seq_along(NAMES)) {
[10:59:36.413]                   name <- added[[kk]]
[10:59:36.413]                   NAME <- NAMES[[kk]]
[10:59:36.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.413]                     next
[10:59:36.413]                   args[[name]] <- ""
[10:59:36.413]                 }
[10:59:36.413]                 NAMES <- toupper(removed)
[10:59:36.413]                 for (kk in seq_along(NAMES)) {
[10:59:36.413]                   name <- removed[[kk]]
[10:59:36.413]                   NAME <- NAMES[[kk]]
[10:59:36.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.413]                     next
[10:59:36.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.413]                 }
[10:59:36.413]                 if (length(args) > 0) 
[10:59:36.413]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.413]             }
[10:59:36.413]             else {
[10:59:36.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.413]             }
[10:59:36.413]             {
[10:59:36.413]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.413]                   0L) {
[10:59:36.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.413]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.413]                   base::options(opts)
[10:59:36.413]                 }
[10:59:36.413]                 {
[10:59:36.413]                   {
[10:59:36.413]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.413]                     NULL
[10:59:36.413]                   }
[10:59:36.413]                   options(future.plan = NULL)
[10:59:36.413]                   if (is.na(NA_character_)) 
[10:59:36.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.413]                     .init = FALSE)
[10:59:36.413]                 }
[10:59:36.413]             }
[10:59:36.413]         }
[10:59:36.413]     })
[10:59:36.413]     if (TRUE) {
[10:59:36.413]         base::sink(type = "output", split = FALSE)
[10:59:36.413]         if (TRUE) {
[10:59:36.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.413]         }
[10:59:36.413]         else {
[10:59:36.413]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.413]         }
[10:59:36.413]         base::close(...future.stdout)
[10:59:36.413]         ...future.stdout <- NULL
[10:59:36.413]     }
[10:59:36.413]     ...future.result$conditions <- ...future.conditions
[10:59:36.413]     ...future.result$finished <- base::Sys.time()
[10:59:36.413]     ...future.result
[10:59:36.413] }
[10:59:36.415] Exporting 5 global objects (803 bytes) to cluster node #1 ...
[10:59:36.416] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:59:36.416] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:59:36.416] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:36.416] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.416] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ...
[10:59:36.417] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ... DONE
[10:59:36.417] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.417] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.417] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.418] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.418] Exporting 5 global objects (803 bytes) to cluster node #1 ... DONE
[10:59:36.418] MultisessionFuture started
[10:59:36.418] - Launch lazy future ... done
[10:59:36.418] run() for ‘MultisessionFuture’ ... done
[10:59:36.419] Created future:
[10:59:36.419] MultisessionFuture:
[10:59:36.419] Label: ‘future_mapply-1’
[10:59:36.419] Expression:
[10:59:36.419] {
[10:59:36.419]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.419]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.419]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.419]         on.exit(options(oopts), add = TRUE)
[10:59:36.419]     }
[10:59:36.419]     {
[10:59:36.419]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.419]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.419]         do.call(mapply, args = args)
[10:59:36.419]     }
[10:59:36.419] }
[10:59:36.419] Lazy evaluation: FALSE
[10:59:36.419] Asynchronous evaluation: TRUE
[10:59:36.419] Local evaluation: TRUE
[10:59:36.419] Environment: R_GlobalEnv
[10:59:36.419] Capture standard output: TRUE
[10:59:36.419] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.419] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.419] Packages: <none>
[10:59:36.419] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.419] Resolved: FALSE
[10:59:36.419] Value: <not collected>
[10:59:36.419] Conditions captured: <none>
[10:59:36.419] Early signaling: FALSE
[10:59:36.419] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.419] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.430] Chunk #1 of 1 ... DONE
[10:59:36.430] Launching 1 futures (chunks) ... DONE
[10:59:36.430] Resolving 1 futures (chunks) ...
[10:59:36.430] resolve() on list ...
[10:59:36.430]  recursive: 0
[10:59:36.430]  length: 1
[10:59:36.431] 
[10:59:36.460] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.460] - Validating connection of MultisessionFuture
[10:59:36.460] - received message: FutureResult
[10:59:36.460] - Received FutureResult
[10:59:36.460] - Erased future from FutureRegistry
[10:59:36.461] result() for ClusterFuture ...
[10:59:36.461] - result already collected: FutureResult
[10:59:36.461] result() for ClusterFuture ... done
[10:59:36.461] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.461] Future #1
[10:59:36.461] result() for ClusterFuture ...
[10:59:36.461] - result already collected: FutureResult
[10:59:36.461] result() for ClusterFuture ... done
[10:59:36.461] result() for ClusterFuture ...
[10:59:36.461] - result already collected: FutureResult
[10:59:36.461] result() for ClusterFuture ... done
[10:59:36.461] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.462] - nx: 1
[10:59:36.462] - relay: TRUE
[10:59:36.462] - stdout: TRUE
[10:59:36.462] - signal: TRUE
[10:59:36.462] - resignal: FALSE
[10:59:36.462] - force: TRUE
[10:59:36.462] - relayed: [n=1] FALSE
[10:59:36.462] - queued futures: [n=1] FALSE
[10:59:36.462]  - until=1
[10:59:36.462]  - relaying element #1
[10:59:36.462] result() for ClusterFuture ...
[10:59:36.462] - result already collected: FutureResult
[10:59:36.462] result() for ClusterFuture ... done
[10:59:36.463] result() for ClusterFuture ...
[10:59:36.463] - result already collected: FutureResult
[10:59:36.463] result() for ClusterFuture ... done
[10:59:36.463] result() for ClusterFuture ...
[10:59:36.463] - result already collected: FutureResult
[10:59:36.463] result() for ClusterFuture ... done
[10:59:36.463] result() for ClusterFuture ...
[10:59:36.463] - result already collected: FutureResult
[10:59:36.463] result() for ClusterFuture ... done
[10:59:36.463] - relayed: [n=1] TRUE
[10:59:36.463] - queued futures: [n=1] TRUE
[10:59:36.463] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.464]  length: 0 (resolved future 1)
[10:59:36.464] Relaying remaining futures
[10:59:36.464] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.464] - nx: 1
[10:59:36.464] - relay: TRUE
[10:59:36.464] - stdout: TRUE
[10:59:36.464] - signal: TRUE
[10:59:36.464] - resignal: FALSE
[10:59:36.464] - force: TRUE
[10:59:36.464] - relayed: [n=1] TRUE
[10:59:36.464] - queued futures: [n=1] TRUE
 - flush all
[10:59:36.464] - relayed: [n=1] TRUE
[10:59:36.465] - queued futures: [n=1] TRUE
[10:59:36.465] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.465] resolve() on list ... DONE
[10:59:36.465] result() for ClusterFuture ...
[10:59:36.465] - result already collected: FutureResult
[10:59:36.465] result() for ClusterFuture ... done
[10:59:36.465] result() for ClusterFuture ...
[10:59:36.465] - result already collected: FutureResult
[10:59:36.465] result() for ClusterFuture ... done
[10:59:36.465]  - Number of value chunks collected: 1
[10:59:36.465] Resolving 1 futures (chunks) ... DONE
[10:59:36.465] Reducing values from 1 chunks ...
[10:59:36.466]  - Number of values collected after concatenation: 1
[10:59:36.466]  - Number of values expected: 1
[10:59:36.466] Reducing values from 1 chunks ... DONE
[10:59:36.466] future_mapply() ... DONE
[10:59:36.466] future_mapply() ...
[10:59:36.467] Number of chunks: 1
[10:59:36.467] getGlobalsAndPackagesXApply() ...
[10:59:36.467]  - future.globals: TRUE
[10:59:36.467] getGlobalsAndPackages() ...
[10:59:36.468] Searching for globals...
[10:59:36.468] - globals found: [1] ‘FUN’
[10:59:36.469] Searching for globals ... DONE
[10:59:36.469] Resolving globals: FALSE
[10:59:36.469] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:36.469] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:36.469] - globals: [1] ‘FUN’
[10:59:36.469] 
[10:59:36.469] getGlobalsAndPackages() ... DONE
[10:59:36.470]  - globals found/used: [n=1] ‘FUN’
[10:59:36.470]  - needed namespaces: [n=0] 
[10:59:36.470] Finding globals ... DONE
[10:59:36.470] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.470] List of 2
[10:59:36.470]  $ ...future.FUN:function (x)  
[10:59:36.470]  $ MoreArgs     : list()
[10:59:36.470]  - attr(*, "where")=List of 2
[10:59:36.470]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.470]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.470]  - attr(*, "resolved")= logi FALSE
[10:59:36.470]  - attr(*, "total_size")= num NA
[10:59:36.472] Packages to be attached in all futures: [n=0] 
[10:59:36.472] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.473] Number of futures (= number of chunks): 1
[10:59:36.473] Launching 1 futures (chunks) ...
[10:59:36.473] Chunk #1 of 1 ...
[10:59:36.473]  - Finding globals in '...' for chunk #1 ...
[10:59:36.473] getGlobalsAndPackages() ...
[10:59:36.473] Searching for globals...
[10:59:36.473] 
[10:59:36.473] Searching for globals ... DONE
[10:59:36.474] - globals: [0] <none>
[10:59:36.474] getGlobalsAndPackages() ... DONE
[10:59:36.474]    + additional globals found: [n=0] 
[10:59:36.474]    + additional namespaces needed: [n=0] 
[10:59:36.474]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.474]  - seeds: <none>
[10:59:36.474]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.474] getGlobalsAndPackages() ...
[10:59:36.474] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.474] Resolving globals: FALSE
[10:59:36.475] The total size of the 5 globals is 370 bytes (370 bytes)
[10:59:36.475] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:59:36.475] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.475] 
[10:59:36.475] getGlobalsAndPackages() ... DONE
[10:59:36.476] run() for ‘Future’ ...
[10:59:36.476] - state: ‘created’
[10:59:36.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.489] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.490]   - Field: ‘node’
[10:59:36.490]   - Field: ‘label’
[10:59:36.490]   - Field: ‘local’
[10:59:36.490]   - Field: ‘owner’
[10:59:36.490]   - Field: ‘envir’
[10:59:36.490]   - Field: ‘workers’
[10:59:36.490]   - Field: ‘packages’
[10:59:36.490]   - Field: ‘gc’
[10:59:36.490]   - Field: ‘conditions’
[10:59:36.490]   - Field: ‘persistent’
[10:59:36.491]   - Field: ‘expr’
[10:59:36.491]   - Field: ‘uuid’
[10:59:36.491]   - Field: ‘seed’
[10:59:36.491]   - Field: ‘version’
[10:59:36.491]   - Field: ‘result’
[10:59:36.491]   - Field: ‘asynchronous’
[10:59:36.491]   - Field: ‘calls’
[10:59:36.491]   - Field: ‘globals’
[10:59:36.491]   - Field: ‘stdout’
[10:59:36.491]   - Field: ‘earlySignal’
[10:59:36.491]   - Field: ‘lazy’
[10:59:36.491]   - Field: ‘state’
[10:59:36.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.492] - Launch lazy future ...
[10:59:36.492] Packages needed by the future expression (n = 0): <none>
[10:59:36.492] Packages needed by future strategies (n = 0): <none>
[10:59:36.492] {
[10:59:36.492]     {
[10:59:36.492]         {
[10:59:36.492]             ...future.startTime <- base::Sys.time()
[10:59:36.492]             {
[10:59:36.492]                 {
[10:59:36.492]                   {
[10:59:36.492]                     {
[10:59:36.492]                       base::local({
[10:59:36.492]                         has_future <- base::requireNamespace("future", 
[10:59:36.492]                           quietly = TRUE)
[10:59:36.492]                         if (has_future) {
[10:59:36.492]                           ns <- base::getNamespace("future")
[10:59:36.492]                           version <- ns[[".package"]][["version"]]
[10:59:36.492]                           if (is.null(version)) 
[10:59:36.492]                             version <- utils::packageVersion("future")
[10:59:36.492]                         }
[10:59:36.492]                         else {
[10:59:36.492]                           version <- NULL
[10:59:36.492]                         }
[10:59:36.492]                         if (!has_future || version < "1.8.0") {
[10:59:36.492]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.492]                             "", base::R.version$version.string), 
[10:59:36.492]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.492]                               "release", "version")], collapse = " "), 
[10:59:36.492]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.492]                             info)
[10:59:36.492]                           info <- base::paste(info, collapse = "; ")
[10:59:36.492]                           if (!has_future) {
[10:59:36.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.492]                               info)
[10:59:36.492]                           }
[10:59:36.492]                           else {
[10:59:36.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.492]                               info, version)
[10:59:36.492]                           }
[10:59:36.492]                           base::stop(msg)
[10:59:36.492]                         }
[10:59:36.492]                       })
[10:59:36.492]                     }
[10:59:36.492]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.492]                     base::options(mc.cores = 1L)
[10:59:36.492]                   }
[10:59:36.492]                   ...future.strategy.old <- future::plan("list")
[10:59:36.492]                   options(future.plan = NULL)
[10:59:36.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.492]                 }
[10:59:36.492]                 ...future.workdir <- getwd()
[10:59:36.492]             }
[10:59:36.492]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.492]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.492]         }
[10:59:36.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.492]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:59:36.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.492]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.492]             base::names(...future.oldOptions))
[10:59:36.492]     }
[10:59:36.492]     if (FALSE) {
[10:59:36.492]     }
[10:59:36.492]     else {
[10:59:36.492]         if (TRUE) {
[10:59:36.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.492]                 open = "w")
[10:59:36.492]         }
[10:59:36.492]         else {
[10:59:36.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.492]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.492]         }
[10:59:36.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.492]             base::sink(type = "output", split = FALSE)
[10:59:36.492]             base::close(...future.stdout)
[10:59:36.492]         }, add = TRUE)
[10:59:36.492]     }
[10:59:36.492]     ...future.frame <- base::sys.nframe()
[10:59:36.492]     ...future.conditions <- base::list()
[10:59:36.492]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.492]     if (FALSE) {
[10:59:36.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.492]     }
[10:59:36.492]     ...future.result <- base::tryCatch({
[10:59:36.492]         base::withCallingHandlers({
[10:59:36.492]             ...future.value <- base::withVisible(base::local({
[10:59:36.492]                 ...future.makeSendCondition <- base::local({
[10:59:36.492]                   sendCondition <- NULL
[10:59:36.492]                   function(frame = 1L) {
[10:59:36.492]                     if (is.function(sendCondition)) 
[10:59:36.492]                       return(sendCondition)
[10:59:36.492]                     ns <- getNamespace("parallel")
[10:59:36.492]                     if (exists("sendData", mode = "function", 
[10:59:36.492]                       envir = ns)) {
[10:59:36.492]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.492]                         envir = ns)
[10:59:36.492]                       envir <- sys.frame(frame)
[10:59:36.492]                       master <- NULL
[10:59:36.492]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.492]                         !identical(envir, emptyenv())) {
[10:59:36.492]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.492]                           inherits = FALSE)) {
[10:59:36.492]                           master <- get("master", mode = "list", 
[10:59:36.492]                             envir = envir, inherits = FALSE)
[10:59:36.492]                           if (inherits(master, c("SOCKnode", 
[10:59:36.492]                             "SOCK0node"))) {
[10:59:36.492]                             sendCondition <<- function(cond) {
[10:59:36.492]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.492]                                 success = TRUE)
[10:59:36.492]                               parallel_sendData(master, data)
[10:59:36.492]                             }
[10:59:36.492]                             return(sendCondition)
[10:59:36.492]                           }
[10:59:36.492]                         }
[10:59:36.492]                         frame <- frame + 1L
[10:59:36.492]                         envir <- sys.frame(frame)
[10:59:36.492]                       }
[10:59:36.492]                     }
[10:59:36.492]                     sendCondition <<- function(cond) NULL
[10:59:36.492]                   }
[10:59:36.492]                 })
[10:59:36.492]                 withCallingHandlers({
[10:59:36.492]                   {
[10:59:36.492]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.492]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.492]                       ...future.globals.maxSize)) {
[10:59:36.492]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.492]                       on.exit(options(oopts), add = TRUE)
[10:59:36.492]                     }
[10:59:36.492]                     {
[10:59:36.492]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.492]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.492]                         USE.NAMES = FALSE)
[10:59:36.492]                       do.call(mapply, args = args)
[10:59:36.492]                     }
[10:59:36.492]                   }
[10:59:36.492]                 }, immediateCondition = function(cond) {
[10:59:36.492]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.492]                   sendCondition(cond)
[10:59:36.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.492]                   {
[10:59:36.492]                     inherits <- base::inherits
[10:59:36.492]                     invokeRestart <- base::invokeRestart
[10:59:36.492]                     is.null <- base::is.null
[10:59:36.492]                     muffled <- FALSE
[10:59:36.492]                     if (inherits(cond, "message")) {
[10:59:36.492]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.492]                       if (muffled) 
[10:59:36.492]                         invokeRestart("muffleMessage")
[10:59:36.492]                     }
[10:59:36.492]                     else if (inherits(cond, "warning")) {
[10:59:36.492]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.492]                       if (muffled) 
[10:59:36.492]                         invokeRestart("muffleWarning")
[10:59:36.492]                     }
[10:59:36.492]                     else if (inherits(cond, "condition")) {
[10:59:36.492]                       if (!is.null(pattern)) {
[10:59:36.492]                         computeRestarts <- base::computeRestarts
[10:59:36.492]                         grepl <- base::grepl
[10:59:36.492]                         restarts <- computeRestarts(cond)
[10:59:36.492]                         for (restart in restarts) {
[10:59:36.492]                           name <- restart$name
[10:59:36.492]                           if (is.null(name)) 
[10:59:36.492]                             next
[10:59:36.492]                           if (!grepl(pattern, name)) 
[10:59:36.492]                             next
[10:59:36.492]                           invokeRestart(restart)
[10:59:36.492]                           muffled <- TRUE
[10:59:36.492]                           break
[10:59:36.492]                         }
[10:59:36.492]                       }
[10:59:36.492]                     }
[10:59:36.492]                     invisible(muffled)
[10:59:36.492]                   }
[10:59:36.492]                   muffleCondition(cond)
[10:59:36.492]                 })
[10:59:36.492]             }))
[10:59:36.492]             future::FutureResult(value = ...future.value$value, 
[10:59:36.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.492]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.492]                     ...future.globalenv.names))
[10:59:36.492]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.492]         }, condition = base::local({
[10:59:36.492]             c <- base::c
[10:59:36.492]             inherits <- base::inherits
[10:59:36.492]             invokeRestart <- base::invokeRestart
[10:59:36.492]             length <- base::length
[10:59:36.492]             list <- base::list
[10:59:36.492]             seq.int <- base::seq.int
[10:59:36.492]             signalCondition <- base::signalCondition
[10:59:36.492]             sys.calls <- base::sys.calls
[10:59:36.492]             `[[` <- base::`[[`
[10:59:36.492]             `+` <- base::`+`
[10:59:36.492]             `<<-` <- base::`<<-`
[10:59:36.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.492]                   3L)]
[10:59:36.492]             }
[10:59:36.492]             function(cond) {
[10:59:36.492]                 is_error <- inherits(cond, "error")
[10:59:36.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.492]                   NULL)
[10:59:36.492]                 if (is_error) {
[10:59:36.492]                   sessionInformation <- function() {
[10:59:36.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.492]                       search = base::search(), system = base::Sys.info())
[10:59:36.492]                   }
[10:59:36.492]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.492]                     cond$call), session = sessionInformation(), 
[10:59:36.492]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.492]                   signalCondition(cond)
[10:59:36.492]                 }
[10:59:36.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.492]                 "immediateCondition"))) {
[10:59:36.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.492]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.492]                   if (TRUE && !signal) {
[10:59:36.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.492]                     {
[10:59:36.492]                       inherits <- base::inherits
[10:59:36.492]                       invokeRestart <- base::invokeRestart
[10:59:36.492]                       is.null <- base::is.null
[10:59:36.492]                       muffled <- FALSE
[10:59:36.492]                       if (inherits(cond, "message")) {
[10:59:36.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.492]                         if (muffled) 
[10:59:36.492]                           invokeRestart("muffleMessage")
[10:59:36.492]                       }
[10:59:36.492]                       else if (inherits(cond, "warning")) {
[10:59:36.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.492]                         if (muffled) 
[10:59:36.492]                           invokeRestart("muffleWarning")
[10:59:36.492]                       }
[10:59:36.492]                       else if (inherits(cond, "condition")) {
[10:59:36.492]                         if (!is.null(pattern)) {
[10:59:36.492]                           computeRestarts <- base::computeRestarts
[10:59:36.492]                           grepl <- base::grepl
[10:59:36.492]                           restarts <- computeRestarts(cond)
[10:59:36.492]                           for (restart in restarts) {
[10:59:36.492]                             name <- restart$name
[10:59:36.492]                             if (is.null(name)) 
[10:59:36.492]                               next
[10:59:36.492]                             if (!grepl(pattern, name)) 
[10:59:36.492]                               next
[10:59:36.492]                             invokeRestart(restart)
[10:59:36.492]                             muffled <- TRUE
[10:59:36.492]                             break
[10:59:36.492]                           }
[10:59:36.492]                         }
[10:59:36.492]                       }
[10:59:36.492]                       invisible(muffled)
[10:59:36.492]                     }
[10:59:36.492]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.492]                   }
[10:59:36.492]                 }
[10:59:36.492]                 else {
[10:59:36.492]                   if (TRUE) {
[10:59:36.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.492]                     {
[10:59:36.492]                       inherits <- base::inherits
[10:59:36.492]                       invokeRestart <- base::invokeRestart
[10:59:36.492]                       is.null <- base::is.null
[10:59:36.492]                       muffled <- FALSE
[10:59:36.492]                       if (inherits(cond, "message")) {
[10:59:36.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.492]                         if (muffled) 
[10:59:36.492]                           invokeRestart("muffleMessage")
[10:59:36.492]                       }
[10:59:36.492]                       else if (inherits(cond, "warning")) {
[10:59:36.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.492]                         if (muffled) 
[10:59:36.492]                           invokeRestart("muffleWarning")
[10:59:36.492]                       }
[10:59:36.492]                       else if (inherits(cond, "condition")) {
[10:59:36.492]                         if (!is.null(pattern)) {
[10:59:36.492]                           computeRestarts <- base::computeRestarts
[10:59:36.492]                           grepl <- base::grepl
[10:59:36.492]                           restarts <- computeRestarts(cond)
[10:59:36.492]                           for (restart in restarts) {
[10:59:36.492]                             name <- restart$name
[10:59:36.492]                             if (is.null(name)) 
[10:59:36.492]                               next
[10:59:36.492]                             if (!grepl(pattern, name)) 
[10:59:36.492]                               next
[10:59:36.492]                             invokeRestart(restart)
[10:59:36.492]                             muffled <- TRUE
[10:59:36.492]                             break
[10:59:36.492]                           }
[10:59:36.492]                         }
[10:59:36.492]                       }
[10:59:36.492]                       invisible(muffled)
[10:59:36.492]                     }
[10:59:36.492]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.492]                   }
[10:59:36.492]                 }
[10:59:36.492]             }
[10:59:36.492]         }))
[10:59:36.492]     }, error = function(ex) {
[10:59:36.492]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.492]                 ...future.rng), started = ...future.startTime, 
[10:59:36.492]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.492]             version = "1.8"), class = "FutureResult")
[10:59:36.492]     }, finally = {
[10:59:36.492]         if (!identical(...future.workdir, getwd())) 
[10:59:36.492]             setwd(...future.workdir)
[10:59:36.492]         {
[10:59:36.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.492]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.492]             }
[10:59:36.492]             base::options(...future.oldOptions)
[10:59:36.492]             if (.Platform$OS.type == "windows") {
[10:59:36.492]                 old_names <- names(...future.oldEnvVars)
[10:59:36.492]                 envs <- base::Sys.getenv()
[10:59:36.492]                 names <- names(envs)
[10:59:36.492]                 common <- intersect(names, old_names)
[10:59:36.492]                 added <- setdiff(names, old_names)
[10:59:36.492]                 removed <- setdiff(old_names, names)
[10:59:36.492]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.492]                   envs[common]]
[10:59:36.492]                 NAMES <- toupper(changed)
[10:59:36.492]                 args <- list()
[10:59:36.492]                 for (kk in seq_along(NAMES)) {
[10:59:36.492]                   name <- changed[[kk]]
[10:59:36.492]                   NAME <- NAMES[[kk]]
[10:59:36.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.492]                     next
[10:59:36.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.492]                 }
[10:59:36.492]                 NAMES <- toupper(added)
[10:59:36.492]                 for (kk in seq_along(NAMES)) {
[10:59:36.492]                   name <- added[[kk]]
[10:59:36.492]                   NAME <- NAMES[[kk]]
[10:59:36.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.492]                     next
[10:59:36.492]                   args[[name]] <- ""
[10:59:36.492]                 }
[10:59:36.492]                 NAMES <- toupper(removed)
[10:59:36.492]                 for (kk in seq_along(NAMES)) {
[10:59:36.492]                   name <- removed[[kk]]
[10:59:36.492]                   NAME <- NAMES[[kk]]
[10:59:36.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.492]                     next
[10:59:36.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.492]                 }
[10:59:36.492]                 if (length(args) > 0) 
[10:59:36.492]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.492]             }
[10:59:36.492]             else {
[10:59:36.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.492]             }
[10:59:36.492]             {
[10:59:36.492]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.492]                   0L) {
[10:59:36.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.492]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.492]                   base::options(opts)
[10:59:36.492]                 }
[10:59:36.492]                 {
[10:59:36.492]                   {
[10:59:36.492]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.492]                     NULL
[10:59:36.492]                   }
[10:59:36.492]                   options(future.plan = NULL)
[10:59:36.492]                   if (is.na(NA_character_)) 
[10:59:36.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.492]                     .init = FALSE)
[10:59:36.492]                 }
[10:59:36.492]             }
[10:59:36.492]         }
[10:59:36.492]     })
[10:59:36.492]     if (TRUE) {
[10:59:36.492]         base::sink(type = "output", split = FALSE)
[10:59:36.492]         if (TRUE) {
[10:59:36.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.492]         }
[10:59:36.492]         else {
[10:59:36.492]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.492]         }
[10:59:36.492]         base::close(...future.stdout)
[10:59:36.492]         ...future.stdout <- NULL
[10:59:36.492]     }
[10:59:36.492]     ...future.result$conditions <- ...future.conditions
[10:59:36.492]     ...future.result$finished <- base::Sys.time()
[10:59:36.492]     ...future.result
[10:59:36.492] }
[10:59:36.495] Exporting 5 global objects (807 bytes) to cluster node #1 ...
[10:59:36.495] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:59:36.495] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:59:36.496] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:59:36.496] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:59:36.496] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ...
[10:59:36.496] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ... DONE
[10:59:36.497] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.497] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.497] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.497] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.498] Exporting 5 global objects (807 bytes) to cluster node #1 ... DONE
[10:59:36.498] MultisessionFuture started
[10:59:36.498] - Launch lazy future ... done
[10:59:36.498] run() for ‘MultisessionFuture’ ... done
[10:59:36.498] Created future:
[10:59:36.498] MultisessionFuture:
[10:59:36.498] Label: ‘future_.mapply-1’
[10:59:36.498] Expression:
[10:59:36.498] {
[10:59:36.498]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.498]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.498]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.498]         on.exit(options(oopts), add = TRUE)
[10:59:36.498]     }
[10:59:36.498]     {
[10:59:36.498]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.498]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.498]         do.call(mapply, args = args)
[10:59:36.498]     }
[10:59:36.498] }
[10:59:36.498] Lazy evaluation: FALSE
[10:59:36.498] Asynchronous evaluation: TRUE
[10:59:36.498] Local evaluation: TRUE
[10:59:36.498] Environment: R_GlobalEnv
[10:59:36.498] Capture standard output: TRUE
[10:59:36.498] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.498] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.498] Packages: <none>
[10:59:36.498] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.498] Resolved: FALSE
[10:59:36.498] Value: <not collected>
[10:59:36.498] Conditions captured: <none>
[10:59:36.498] Early signaling: FALSE
[10:59:36.498] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.498] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.510] Chunk #1 of 1 ... DONE
[10:59:36.510] Launching 1 futures (chunks) ... DONE
[10:59:36.510] Resolving 1 futures (chunks) ...
[10:59:36.510] resolve() on list ...
[10:59:36.510]  recursive: 0
[10:59:36.510]  length: 1
[10:59:36.510] 
[10:59:36.540] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.541] - Validating connection of MultisessionFuture
[10:59:36.541] - received message: FutureResult
[10:59:36.541] - Received FutureResult
[10:59:36.541] - Erased future from FutureRegistry
[10:59:36.541] result() for ClusterFuture ...
[10:59:36.541] - result already collected: FutureResult
[10:59:36.541] result() for ClusterFuture ... done
[10:59:36.541] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.541] Future #1
[10:59:36.542] result() for ClusterFuture ...
[10:59:36.542] - result already collected: FutureResult
[10:59:36.542] result() for ClusterFuture ... done
[10:59:36.542] result() for ClusterFuture ...
[10:59:36.542] - result already collected: FutureResult
[10:59:36.542] result() for ClusterFuture ... done
[10:59:36.542] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.542] - nx: 1
[10:59:36.542] - relay: TRUE
[10:59:36.542] - stdout: TRUE
[10:59:36.542] - signal: TRUE
[10:59:36.542] - resignal: FALSE
[10:59:36.543] - force: TRUE
[10:59:36.543] - relayed: [n=1] FALSE
[10:59:36.543] - queued futures: [n=1] FALSE
[10:59:36.543]  - until=1
[10:59:36.543]  - relaying element #1
[10:59:36.543] result() for ClusterFuture ...
[10:59:36.543] - result already collected: FutureResult
[10:59:36.543] result() for ClusterFuture ... done
[10:59:36.543] result() for ClusterFuture ...
[10:59:36.543] - result already collected: FutureResult
[10:59:36.543] result() for ClusterFuture ... done
[10:59:36.543] result() for ClusterFuture ...
[10:59:36.544] - result already collected: FutureResult
[10:59:36.544] result() for ClusterFuture ... done
[10:59:36.544] result() for ClusterFuture ...
[10:59:36.544] - result already collected: FutureResult
[10:59:36.544] result() for ClusterFuture ... done
[10:59:36.544] - relayed: [n=1] TRUE
[10:59:36.544] - queued futures: [n=1] TRUE
[10:59:36.544] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.544]  length: 0 (resolved future 1)
[10:59:36.544] Relaying remaining futures
[10:59:36.544] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.544] - nx: 1
[10:59:36.545] - relay: TRUE
[10:59:36.545] - stdout: TRUE
[10:59:36.545] - signal: TRUE
[10:59:36.545] - resignal: FALSE
[10:59:36.545] - force: TRUE
[10:59:36.545] - relayed: [n=1] TRUE
[10:59:36.545] - queued futures: [n=1] TRUE
 - flush all
[10:59:36.545] - relayed: [n=1] TRUE
[10:59:36.545] - queued futures: [n=1] TRUE
[10:59:36.545] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.545] resolve() on list ... DONE
[10:59:36.546] result() for ClusterFuture ...
[10:59:36.546] - result already collected: FutureResult
[10:59:36.546] result() for ClusterFuture ... done
[10:59:36.546] result() for ClusterFuture ...
[10:59:36.546] - result already collected: FutureResult
[10:59:36.546] result() for ClusterFuture ... done
[10:59:36.546]  - Number of value chunks collected: 1
[10:59:36.546] Resolving 1 futures (chunks) ... DONE
[10:59:36.546] Reducing values from 1 chunks ...
[10:59:36.546]  - Number of values collected after concatenation: 1
[10:59:36.546]  - Number of values expected: 1
[10:59:36.546] Reducing values from 1 chunks ... DONE
[10:59:36.547] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:59:36.547] future_mapply() ...
[10:59:36.548] Number of chunks: 2
[10:59:36.548] getGlobalsAndPackagesXApply() ...
[10:59:36.548]  - future.globals: TRUE
[10:59:36.549] getGlobalsAndPackages() ...
[10:59:36.549] Searching for globals...
[10:59:36.550] - globals found: [1] ‘FUN’
[10:59:36.550] Searching for globals ... DONE
[10:59:36.550] Resolving globals: FALSE
[10:59:36.550] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:36.550] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:36.550] - globals: [1] ‘FUN’
[10:59:36.551] 
[10:59:36.551] getGlobalsAndPackages() ... DONE
[10:59:36.551]  - globals found/used: [n=1] ‘FUN’
[10:59:36.551]  - needed namespaces: [n=0] 
[10:59:36.551] Finding globals ... DONE
[10:59:36.551] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.551] List of 2
[10:59:36.551]  $ ...future.FUN:function (x, y)  
[10:59:36.551]  $ MoreArgs     :List of 1
[10:59:36.551]   ..$ y: int [1:2] 3 4
[10:59:36.551]  - attr(*, "where")=List of 2
[10:59:36.551]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.551]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.551]  - attr(*, "resolved")= logi FALSE
[10:59:36.551]  - attr(*, "total_size")= num NA
[10:59:36.554] Packages to be attached in all futures: [n=0] 
[10:59:36.554] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.554] Number of futures (= number of chunks): 2
[10:59:36.554] Launching 2 futures (chunks) ...
[10:59:36.554] Chunk #1 of 2 ...
[10:59:36.555]  - Finding globals in '...' for chunk #1 ...
[10:59:36.555] getGlobalsAndPackages() ...
[10:59:36.555] Searching for globals...
[10:59:36.555] 
[10:59:36.555] Searching for globals ... DONE
[10:59:36.555] - globals: [0] <none>
[10:59:36.555] getGlobalsAndPackages() ... DONE
[10:59:36.555]    + additional globals found: [n=0] 
[10:59:36.555]    + additional namespaces needed: [n=0] 
[10:59:36.555]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.556]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.556]  - seeds: <none>
[10:59:36.556]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.556] getGlobalsAndPackages() ...
[10:59:36.556] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.556] Resolving globals: FALSE
[10:59:36.556] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:36.557] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:36.557] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.557] 
[10:59:36.557] getGlobalsAndPackages() ... DONE
[10:59:36.557] run() for ‘Future’ ...
[10:59:36.557] - state: ‘created’
[10:59:36.558] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.574] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.574]   - Field: ‘node’
[10:59:36.574]   - Field: ‘label’
[10:59:36.574]   - Field: ‘local’
[10:59:36.574]   - Field: ‘owner’
[10:59:36.574]   - Field: ‘envir’
[10:59:36.574]   - Field: ‘workers’
[10:59:36.574]   - Field: ‘packages’
[10:59:36.575]   - Field: ‘gc’
[10:59:36.575]   - Field: ‘conditions’
[10:59:36.575]   - Field: ‘persistent’
[10:59:36.575]   - Field: ‘expr’
[10:59:36.575]   - Field: ‘uuid’
[10:59:36.575]   - Field: ‘seed’
[10:59:36.575]   - Field: ‘version’
[10:59:36.575]   - Field: ‘result’
[10:59:36.575]   - Field: ‘asynchronous’
[10:59:36.575]   - Field: ‘calls’
[10:59:36.575]   - Field: ‘globals’
[10:59:36.575]   - Field: ‘stdout’
[10:59:36.576]   - Field: ‘earlySignal’
[10:59:36.576]   - Field: ‘lazy’
[10:59:36.576]   - Field: ‘state’
[10:59:36.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.576] - Launch lazy future ...
[10:59:36.576] Packages needed by the future expression (n = 0): <none>
[10:59:36.576] Packages needed by future strategies (n = 0): <none>
[10:59:36.577] {
[10:59:36.577]     {
[10:59:36.577]         {
[10:59:36.577]             ...future.startTime <- base::Sys.time()
[10:59:36.577]             {
[10:59:36.577]                 {
[10:59:36.577]                   {
[10:59:36.577]                     {
[10:59:36.577]                       base::local({
[10:59:36.577]                         has_future <- base::requireNamespace("future", 
[10:59:36.577]                           quietly = TRUE)
[10:59:36.577]                         if (has_future) {
[10:59:36.577]                           ns <- base::getNamespace("future")
[10:59:36.577]                           version <- ns[[".package"]][["version"]]
[10:59:36.577]                           if (is.null(version)) 
[10:59:36.577]                             version <- utils::packageVersion("future")
[10:59:36.577]                         }
[10:59:36.577]                         else {
[10:59:36.577]                           version <- NULL
[10:59:36.577]                         }
[10:59:36.577]                         if (!has_future || version < "1.8.0") {
[10:59:36.577]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.577]                             "", base::R.version$version.string), 
[10:59:36.577]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.577]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.577]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.577]                               "release", "version")], collapse = " "), 
[10:59:36.577]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.577]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.577]                             info)
[10:59:36.577]                           info <- base::paste(info, collapse = "; ")
[10:59:36.577]                           if (!has_future) {
[10:59:36.577]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.577]                               info)
[10:59:36.577]                           }
[10:59:36.577]                           else {
[10:59:36.577]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.577]                               info, version)
[10:59:36.577]                           }
[10:59:36.577]                           base::stop(msg)
[10:59:36.577]                         }
[10:59:36.577]                       })
[10:59:36.577]                     }
[10:59:36.577]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.577]                     base::options(mc.cores = 1L)
[10:59:36.577]                   }
[10:59:36.577]                   ...future.strategy.old <- future::plan("list")
[10:59:36.577]                   options(future.plan = NULL)
[10:59:36.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.577]                 }
[10:59:36.577]                 ...future.workdir <- getwd()
[10:59:36.577]             }
[10:59:36.577]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.577]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.577]         }
[10:59:36.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.577]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.577]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.577]             base::names(...future.oldOptions))
[10:59:36.577]     }
[10:59:36.577]     if (FALSE) {
[10:59:36.577]     }
[10:59:36.577]     else {
[10:59:36.577]         if (TRUE) {
[10:59:36.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.577]                 open = "w")
[10:59:36.577]         }
[10:59:36.577]         else {
[10:59:36.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.577]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.577]         }
[10:59:36.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.577]             base::sink(type = "output", split = FALSE)
[10:59:36.577]             base::close(...future.stdout)
[10:59:36.577]         }, add = TRUE)
[10:59:36.577]     }
[10:59:36.577]     ...future.frame <- base::sys.nframe()
[10:59:36.577]     ...future.conditions <- base::list()
[10:59:36.577]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.577]     if (FALSE) {
[10:59:36.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.577]     }
[10:59:36.577]     ...future.result <- base::tryCatch({
[10:59:36.577]         base::withCallingHandlers({
[10:59:36.577]             ...future.value <- base::withVisible(base::local({
[10:59:36.577]                 ...future.makeSendCondition <- base::local({
[10:59:36.577]                   sendCondition <- NULL
[10:59:36.577]                   function(frame = 1L) {
[10:59:36.577]                     if (is.function(sendCondition)) 
[10:59:36.577]                       return(sendCondition)
[10:59:36.577]                     ns <- getNamespace("parallel")
[10:59:36.577]                     if (exists("sendData", mode = "function", 
[10:59:36.577]                       envir = ns)) {
[10:59:36.577]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.577]                         envir = ns)
[10:59:36.577]                       envir <- sys.frame(frame)
[10:59:36.577]                       master <- NULL
[10:59:36.577]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.577]                         !identical(envir, emptyenv())) {
[10:59:36.577]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.577]                           inherits = FALSE)) {
[10:59:36.577]                           master <- get("master", mode = "list", 
[10:59:36.577]                             envir = envir, inherits = FALSE)
[10:59:36.577]                           if (inherits(master, c("SOCKnode", 
[10:59:36.577]                             "SOCK0node"))) {
[10:59:36.577]                             sendCondition <<- function(cond) {
[10:59:36.577]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.577]                                 success = TRUE)
[10:59:36.577]                               parallel_sendData(master, data)
[10:59:36.577]                             }
[10:59:36.577]                             return(sendCondition)
[10:59:36.577]                           }
[10:59:36.577]                         }
[10:59:36.577]                         frame <- frame + 1L
[10:59:36.577]                         envir <- sys.frame(frame)
[10:59:36.577]                       }
[10:59:36.577]                     }
[10:59:36.577]                     sendCondition <<- function(cond) NULL
[10:59:36.577]                   }
[10:59:36.577]                 })
[10:59:36.577]                 withCallingHandlers({
[10:59:36.577]                   {
[10:59:36.577]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.577]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.577]                       ...future.globals.maxSize)) {
[10:59:36.577]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.577]                       on.exit(options(oopts), add = TRUE)
[10:59:36.577]                     }
[10:59:36.577]                     {
[10:59:36.577]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.577]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.577]                         USE.NAMES = FALSE)
[10:59:36.577]                       do.call(mapply, args = args)
[10:59:36.577]                     }
[10:59:36.577]                   }
[10:59:36.577]                 }, immediateCondition = function(cond) {
[10:59:36.577]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.577]                   sendCondition(cond)
[10:59:36.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.577]                   {
[10:59:36.577]                     inherits <- base::inherits
[10:59:36.577]                     invokeRestart <- base::invokeRestart
[10:59:36.577]                     is.null <- base::is.null
[10:59:36.577]                     muffled <- FALSE
[10:59:36.577]                     if (inherits(cond, "message")) {
[10:59:36.577]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.577]                       if (muffled) 
[10:59:36.577]                         invokeRestart("muffleMessage")
[10:59:36.577]                     }
[10:59:36.577]                     else if (inherits(cond, "warning")) {
[10:59:36.577]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.577]                       if (muffled) 
[10:59:36.577]                         invokeRestart("muffleWarning")
[10:59:36.577]                     }
[10:59:36.577]                     else if (inherits(cond, "condition")) {
[10:59:36.577]                       if (!is.null(pattern)) {
[10:59:36.577]                         computeRestarts <- base::computeRestarts
[10:59:36.577]                         grepl <- base::grepl
[10:59:36.577]                         restarts <- computeRestarts(cond)
[10:59:36.577]                         for (restart in restarts) {
[10:59:36.577]                           name <- restart$name
[10:59:36.577]                           if (is.null(name)) 
[10:59:36.577]                             next
[10:59:36.577]                           if (!grepl(pattern, name)) 
[10:59:36.577]                             next
[10:59:36.577]                           invokeRestart(restart)
[10:59:36.577]                           muffled <- TRUE
[10:59:36.577]                           break
[10:59:36.577]                         }
[10:59:36.577]                       }
[10:59:36.577]                     }
[10:59:36.577]                     invisible(muffled)
[10:59:36.577]                   }
[10:59:36.577]                   muffleCondition(cond)
[10:59:36.577]                 })
[10:59:36.577]             }))
[10:59:36.577]             future::FutureResult(value = ...future.value$value, 
[10:59:36.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.577]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.577]                     ...future.globalenv.names))
[10:59:36.577]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.577]         }, condition = base::local({
[10:59:36.577]             c <- base::c
[10:59:36.577]             inherits <- base::inherits
[10:59:36.577]             invokeRestart <- base::invokeRestart
[10:59:36.577]             length <- base::length
[10:59:36.577]             list <- base::list
[10:59:36.577]             seq.int <- base::seq.int
[10:59:36.577]             signalCondition <- base::signalCondition
[10:59:36.577]             sys.calls <- base::sys.calls
[10:59:36.577]             `[[` <- base::`[[`
[10:59:36.577]             `+` <- base::`+`
[10:59:36.577]             `<<-` <- base::`<<-`
[10:59:36.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.577]                   3L)]
[10:59:36.577]             }
[10:59:36.577]             function(cond) {
[10:59:36.577]                 is_error <- inherits(cond, "error")
[10:59:36.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.577]                   NULL)
[10:59:36.577]                 if (is_error) {
[10:59:36.577]                   sessionInformation <- function() {
[10:59:36.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.577]                       search = base::search(), system = base::Sys.info())
[10:59:36.577]                   }
[10:59:36.577]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.577]                     cond$call), session = sessionInformation(), 
[10:59:36.577]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.577]                   signalCondition(cond)
[10:59:36.577]                 }
[10:59:36.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.577]                 "immediateCondition"))) {
[10:59:36.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.577]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.577]                   if (TRUE && !signal) {
[10:59:36.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.577]                     {
[10:59:36.577]                       inherits <- base::inherits
[10:59:36.577]                       invokeRestart <- base::invokeRestart
[10:59:36.577]                       is.null <- base::is.null
[10:59:36.577]                       muffled <- FALSE
[10:59:36.577]                       if (inherits(cond, "message")) {
[10:59:36.577]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.577]                         if (muffled) 
[10:59:36.577]                           invokeRestart("muffleMessage")
[10:59:36.577]                       }
[10:59:36.577]                       else if (inherits(cond, "warning")) {
[10:59:36.577]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.577]                         if (muffled) 
[10:59:36.577]                           invokeRestart("muffleWarning")
[10:59:36.577]                       }
[10:59:36.577]                       else if (inherits(cond, "condition")) {
[10:59:36.577]                         if (!is.null(pattern)) {
[10:59:36.577]                           computeRestarts <- base::computeRestarts
[10:59:36.577]                           grepl <- base::grepl
[10:59:36.577]                           restarts <- computeRestarts(cond)
[10:59:36.577]                           for (restart in restarts) {
[10:59:36.577]                             name <- restart$name
[10:59:36.577]                             if (is.null(name)) 
[10:59:36.577]                               next
[10:59:36.577]                             if (!grepl(pattern, name)) 
[10:59:36.577]                               next
[10:59:36.577]                             invokeRestart(restart)
[10:59:36.577]                             muffled <- TRUE
[10:59:36.577]                             break
[10:59:36.577]                           }
[10:59:36.577]                         }
[10:59:36.577]                       }
[10:59:36.577]                       invisible(muffled)
[10:59:36.577]                     }
[10:59:36.577]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.577]                   }
[10:59:36.577]                 }
[10:59:36.577]                 else {
[10:59:36.577]                   if (TRUE) {
[10:59:36.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.577]                     {
[10:59:36.577]                       inherits <- base::inherits
[10:59:36.577]                       invokeRestart <- base::invokeRestart
[10:59:36.577]                       is.null <- base::is.null
[10:59:36.577]                       muffled <- FALSE
[10:59:36.577]                       if (inherits(cond, "message")) {
[10:59:36.577]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.577]                         if (muffled) 
[10:59:36.577]                           invokeRestart("muffleMessage")
[10:59:36.577]                       }
[10:59:36.577]                       else if (inherits(cond, "warning")) {
[10:59:36.577]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.577]                         if (muffled) 
[10:59:36.577]                           invokeRestart("muffleWarning")
[10:59:36.577]                       }
[10:59:36.577]                       else if (inherits(cond, "condition")) {
[10:59:36.577]                         if (!is.null(pattern)) {
[10:59:36.577]                           computeRestarts <- base::computeRestarts
[10:59:36.577]                           grepl <- base::grepl
[10:59:36.577]                           restarts <- computeRestarts(cond)
[10:59:36.577]                           for (restart in restarts) {
[10:59:36.577]                             name <- restart$name
[10:59:36.577]                             if (is.null(name)) 
[10:59:36.577]                               next
[10:59:36.577]                             if (!grepl(pattern, name)) 
[10:59:36.577]                               next
[10:59:36.577]                             invokeRestart(restart)
[10:59:36.577]                             muffled <- TRUE
[10:59:36.577]                             break
[10:59:36.577]                           }
[10:59:36.577]                         }
[10:59:36.577]                       }
[10:59:36.577]                       invisible(muffled)
[10:59:36.577]                     }
[10:59:36.577]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.577]                   }
[10:59:36.577]                 }
[10:59:36.577]             }
[10:59:36.577]         }))
[10:59:36.577]     }, error = function(ex) {
[10:59:36.577]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.577]                 ...future.rng), started = ...future.startTime, 
[10:59:36.577]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.577]             version = "1.8"), class = "FutureResult")
[10:59:36.577]     }, finally = {
[10:59:36.577]         if (!identical(...future.workdir, getwd())) 
[10:59:36.577]             setwd(...future.workdir)
[10:59:36.577]         {
[10:59:36.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.577]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.577]             }
[10:59:36.577]             base::options(...future.oldOptions)
[10:59:36.577]             if (.Platform$OS.type == "windows") {
[10:59:36.577]                 old_names <- names(...future.oldEnvVars)
[10:59:36.577]                 envs <- base::Sys.getenv()
[10:59:36.577]                 names <- names(envs)
[10:59:36.577]                 common <- intersect(names, old_names)
[10:59:36.577]                 added <- setdiff(names, old_names)
[10:59:36.577]                 removed <- setdiff(old_names, names)
[10:59:36.577]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.577]                   envs[common]]
[10:59:36.577]                 NAMES <- toupper(changed)
[10:59:36.577]                 args <- list()
[10:59:36.577]                 for (kk in seq_along(NAMES)) {
[10:59:36.577]                   name <- changed[[kk]]
[10:59:36.577]                   NAME <- NAMES[[kk]]
[10:59:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.577]                     next
[10:59:36.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.577]                 }
[10:59:36.577]                 NAMES <- toupper(added)
[10:59:36.577]                 for (kk in seq_along(NAMES)) {
[10:59:36.577]                   name <- added[[kk]]
[10:59:36.577]                   NAME <- NAMES[[kk]]
[10:59:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.577]                     next
[10:59:36.577]                   args[[name]] <- ""
[10:59:36.577]                 }
[10:59:36.577]                 NAMES <- toupper(removed)
[10:59:36.577]                 for (kk in seq_along(NAMES)) {
[10:59:36.577]                   name <- removed[[kk]]
[10:59:36.577]                   NAME <- NAMES[[kk]]
[10:59:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.577]                     next
[10:59:36.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.577]                 }
[10:59:36.577]                 if (length(args) > 0) 
[10:59:36.577]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.577]             }
[10:59:36.577]             else {
[10:59:36.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.577]             }
[10:59:36.577]             {
[10:59:36.577]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.577]                   0L) {
[10:59:36.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.577]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.577]                   base::options(opts)
[10:59:36.577]                 }
[10:59:36.577]                 {
[10:59:36.577]                   {
[10:59:36.577]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.577]                     NULL
[10:59:36.577]                   }
[10:59:36.577]                   options(future.plan = NULL)
[10:59:36.577]                   if (is.na(NA_character_)) 
[10:59:36.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.577]                     .init = FALSE)
[10:59:36.577]                 }
[10:59:36.577]             }
[10:59:36.577]         }
[10:59:36.577]     })
[10:59:36.577]     if (TRUE) {
[10:59:36.577]         base::sink(type = "output", split = FALSE)
[10:59:36.577]         if (TRUE) {
[10:59:36.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.577]         }
[10:59:36.577]         else {
[10:59:36.577]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.577]         }
[10:59:36.577]         base::close(...future.stdout)
[10:59:36.577]         ...future.stdout <- NULL
[10:59:36.577]     }
[10:59:36.577]     ...future.result$conditions <- ...future.conditions
[10:59:36.577]     ...future.result$finished <- base::Sys.time()
[10:59:36.577]     ...future.result
[10:59:36.577] }
[10:59:36.579] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[10:59:36.579] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[10:59:36.580] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[10:59:36.580] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[10:59:36.580] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[10:59:36.580] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[10:59:36.581] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[10:59:36.581] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.581] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.581] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.582] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.582] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[10:59:36.582] MultisessionFuture started
[10:59:36.582] - Launch lazy future ... done
[10:59:36.582] run() for ‘MultisessionFuture’ ... done
[10:59:36.583] Created future:
[10:59:36.583] MultisessionFuture:
[10:59:36.583] Label: ‘future_mapply-1’
[10:59:36.583] Expression:
[10:59:36.583] {
[10:59:36.583]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.583]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.583]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.583]         on.exit(options(oopts), add = TRUE)
[10:59:36.583]     }
[10:59:36.583]     {
[10:59:36.583]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.583]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.583]         do.call(mapply, args = args)
[10:59:36.583]     }
[10:59:36.583] }
[10:59:36.583] Lazy evaluation: FALSE
[10:59:36.583] Asynchronous evaluation: TRUE
[10:59:36.583] Local evaluation: TRUE
[10:59:36.583] Environment: R_GlobalEnv
[10:59:36.583] Capture standard output: TRUE
[10:59:36.583] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.583] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.583] Packages: <none>
[10:59:36.583] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.583] Resolved: FALSE
[10:59:36.583] Value: <not collected>
[10:59:36.583] Conditions captured: <none>
[10:59:36.583] Early signaling: FALSE
[10:59:36.583] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.583] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.594] Chunk #1 of 2 ... DONE
[10:59:36.594] Chunk #2 of 2 ...
[10:59:36.594]  - Finding globals in '...' for chunk #2 ...
[10:59:36.594] getGlobalsAndPackages() ...
[10:59:36.594] Searching for globals...
[10:59:36.595] 
[10:59:36.595] Searching for globals ... DONE
[10:59:36.595] - globals: [0] <none>
[10:59:36.595] getGlobalsAndPackages() ... DONE
[10:59:36.595]    + additional globals found: [n=0] 
[10:59:36.595]    + additional namespaces needed: [n=0] 
[10:59:36.595]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:36.595]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.595]  - seeds: <none>
[10:59:36.595]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.595] getGlobalsAndPackages() ...
[10:59:36.595] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.596] Resolving globals: FALSE
[10:59:36.596] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:36.596] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:36.596] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.597] 
[10:59:36.597] getGlobalsAndPackages() ... DONE
[10:59:36.597] run() for ‘Future’ ...
[10:59:36.597] - state: ‘created’
[10:59:36.597] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.611] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.611]   - Field: ‘node’
[10:59:36.611]   - Field: ‘label’
[10:59:36.611]   - Field: ‘local’
[10:59:36.611]   - Field: ‘owner’
[10:59:36.611]   - Field: ‘envir’
[10:59:36.612]   - Field: ‘workers’
[10:59:36.612]   - Field: ‘packages’
[10:59:36.612]   - Field: ‘gc’
[10:59:36.612]   - Field: ‘conditions’
[10:59:36.612]   - Field: ‘persistent’
[10:59:36.612]   - Field: ‘expr’
[10:59:36.612]   - Field: ‘uuid’
[10:59:36.612]   - Field: ‘seed’
[10:59:36.612]   - Field: ‘version’
[10:59:36.612]   - Field: ‘result’
[10:59:36.612]   - Field: ‘asynchronous’
[10:59:36.612]   - Field: ‘calls’
[10:59:36.613]   - Field: ‘globals’
[10:59:36.613]   - Field: ‘stdout’
[10:59:36.613]   - Field: ‘earlySignal’
[10:59:36.613]   - Field: ‘lazy’
[10:59:36.613]   - Field: ‘state’
[10:59:36.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.613] - Launch lazy future ...
[10:59:36.613] Packages needed by the future expression (n = 0): <none>
[10:59:36.613] Packages needed by future strategies (n = 0): <none>
[10:59:36.614] {
[10:59:36.614]     {
[10:59:36.614]         {
[10:59:36.614]             ...future.startTime <- base::Sys.time()
[10:59:36.614]             {
[10:59:36.614]                 {
[10:59:36.614]                   {
[10:59:36.614]                     {
[10:59:36.614]                       base::local({
[10:59:36.614]                         has_future <- base::requireNamespace("future", 
[10:59:36.614]                           quietly = TRUE)
[10:59:36.614]                         if (has_future) {
[10:59:36.614]                           ns <- base::getNamespace("future")
[10:59:36.614]                           version <- ns[[".package"]][["version"]]
[10:59:36.614]                           if (is.null(version)) 
[10:59:36.614]                             version <- utils::packageVersion("future")
[10:59:36.614]                         }
[10:59:36.614]                         else {
[10:59:36.614]                           version <- NULL
[10:59:36.614]                         }
[10:59:36.614]                         if (!has_future || version < "1.8.0") {
[10:59:36.614]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.614]                             "", base::R.version$version.string), 
[10:59:36.614]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.614]                               "release", "version")], collapse = " "), 
[10:59:36.614]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.614]                             info)
[10:59:36.614]                           info <- base::paste(info, collapse = "; ")
[10:59:36.614]                           if (!has_future) {
[10:59:36.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.614]                               info)
[10:59:36.614]                           }
[10:59:36.614]                           else {
[10:59:36.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.614]                               info, version)
[10:59:36.614]                           }
[10:59:36.614]                           base::stop(msg)
[10:59:36.614]                         }
[10:59:36.614]                       })
[10:59:36.614]                     }
[10:59:36.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.614]                     base::options(mc.cores = 1L)
[10:59:36.614]                   }
[10:59:36.614]                   ...future.strategy.old <- future::plan("list")
[10:59:36.614]                   options(future.plan = NULL)
[10:59:36.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.614]                 }
[10:59:36.614]                 ...future.workdir <- getwd()
[10:59:36.614]             }
[10:59:36.614]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.614]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.614]         }
[10:59:36.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.614]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.614]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.614]             base::names(...future.oldOptions))
[10:59:36.614]     }
[10:59:36.614]     if (FALSE) {
[10:59:36.614]     }
[10:59:36.614]     else {
[10:59:36.614]         if (TRUE) {
[10:59:36.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.614]                 open = "w")
[10:59:36.614]         }
[10:59:36.614]         else {
[10:59:36.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.614]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.614]         }
[10:59:36.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.614]             base::sink(type = "output", split = FALSE)
[10:59:36.614]             base::close(...future.stdout)
[10:59:36.614]         }, add = TRUE)
[10:59:36.614]     }
[10:59:36.614]     ...future.frame <- base::sys.nframe()
[10:59:36.614]     ...future.conditions <- base::list()
[10:59:36.614]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.614]     if (FALSE) {
[10:59:36.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.614]     }
[10:59:36.614]     ...future.result <- base::tryCatch({
[10:59:36.614]         base::withCallingHandlers({
[10:59:36.614]             ...future.value <- base::withVisible(base::local({
[10:59:36.614]                 ...future.makeSendCondition <- base::local({
[10:59:36.614]                   sendCondition <- NULL
[10:59:36.614]                   function(frame = 1L) {
[10:59:36.614]                     if (is.function(sendCondition)) 
[10:59:36.614]                       return(sendCondition)
[10:59:36.614]                     ns <- getNamespace("parallel")
[10:59:36.614]                     if (exists("sendData", mode = "function", 
[10:59:36.614]                       envir = ns)) {
[10:59:36.614]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.614]                         envir = ns)
[10:59:36.614]                       envir <- sys.frame(frame)
[10:59:36.614]                       master <- NULL
[10:59:36.614]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.614]                         !identical(envir, emptyenv())) {
[10:59:36.614]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.614]                           inherits = FALSE)) {
[10:59:36.614]                           master <- get("master", mode = "list", 
[10:59:36.614]                             envir = envir, inherits = FALSE)
[10:59:36.614]                           if (inherits(master, c("SOCKnode", 
[10:59:36.614]                             "SOCK0node"))) {
[10:59:36.614]                             sendCondition <<- function(cond) {
[10:59:36.614]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.614]                                 success = TRUE)
[10:59:36.614]                               parallel_sendData(master, data)
[10:59:36.614]                             }
[10:59:36.614]                             return(sendCondition)
[10:59:36.614]                           }
[10:59:36.614]                         }
[10:59:36.614]                         frame <- frame + 1L
[10:59:36.614]                         envir <- sys.frame(frame)
[10:59:36.614]                       }
[10:59:36.614]                     }
[10:59:36.614]                     sendCondition <<- function(cond) NULL
[10:59:36.614]                   }
[10:59:36.614]                 })
[10:59:36.614]                 withCallingHandlers({
[10:59:36.614]                   {
[10:59:36.614]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.614]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.614]                       ...future.globals.maxSize)) {
[10:59:36.614]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.614]                       on.exit(options(oopts), add = TRUE)
[10:59:36.614]                     }
[10:59:36.614]                     {
[10:59:36.614]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.614]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.614]                         USE.NAMES = FALSE)
[10:59:36.614]                       do.call(mapply, args = args)
[10:59:36.614]                     }
[10:59:36.614]                   }
[10:59:36.614]                 }, immediateCondition = function(cond) {
[10:59:36.614]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.614]                   sendCondition(cond)
[10:59:36.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.614]                   {
[10:59:36.614]                     inherits <- base::inherits
[10:59:36.614]                     invokeRestart <- base::invokeRestart
[10:59:36.614]                     is.null <- base::is.null
[10:59:36.614]                     muffled <- FALSE
[10:59:36.614]                     if (inherits(cond, "message")) {
[10:59:36.614]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.614]                       if (muffled) 
[10:59:36.614]                         invokeRestart("muffleMessage")
[10:59:36.614]                     }
[10:59:36.614]                     else if (inherits(cond, "warning")) {
[10:59:36.614]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.614]                       if (muffled) 
[10:59:36.614]                         invokeRestart("muffleWarning")
[10:59:36.614]                     }
[10:59:36.614]                     else if (inherits(cond, "condition")) {
[10:59:36.614]                       if (!is.null(pattern)) {
[10:59:36.614]                         computeRestarts <- base::computeRestarts
[10:59:36.614]                         grepl <- base::grepl
[10:59:36.614]                         restarts <- computeRestarts(cond)
[10:59:36.614]                         for (restart in restarts) {
[10:59:36.614]                           name <- restart$name
[10:59:36.614]                           if (is.null(name)) 
[10:59:36.614]                             next
[10:59:36.614]                           if (!grepl(pattern, name)) 
[10:59:36.614]                             next
[10:59:36.614]                           invokeRestart(restart)
[10:59:36.614]                           muffled <- TRUE
[10:59:36.614]                           break
[10:59:36.614]                         }
[10:59:36.614]                       }
[10:59:36.614]                     }
[10:59:36.614]                     invisible(muffled)
[10:59:36.614]                   }
[10:59:36.614]                   muffleCondition(cond)
[10:59:36.614]                 })
[10:59:36.614]             }))
[10:59:36.614]             future::FutureResult(value = ...future.value$value, 
[10:59:36.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.614]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.614]                     ...future.globalenv.names))
[10:59:36.614]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.614]         }, condition = base::local({
[10:59:36.614]             c <- base::c
[10:59:36.614]             inherits <- base::inherits
[10:59:36.614]             invokeRestart <- base::invokeRestart
[10:59:36.614]             length <- base::length
[10:59:36.614]             list <- base::list
[10:59:36.614]             seq.int <- base::seq.int
[10:59:36.614]             signalCondition <- base::signalCondition
[10:59:36.614]             sys.calls <- base::sys.calls
[10:59:36.614]             `[[` <- base::`[[`
[10:59:36.614]             `+` <- base::`+`
[10:59:36.614]             `<<-` <- base::`<<-`
[10:59:36.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.614]                   3L)]
[10:59:36.614]             }
[10:59:36.614]             function(cond) {
[10:59:36.614]                 is_error <- inherits(cond, "error")
[10:59:36.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.614]                   NULL)
[10:59:36.614]                 if (is_error) {
[10:59:36.614]                   sessionInformation <- function() {
[10:59:36.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.614]                       search = base::search(), system = base::Sys.info())
[10:59:36.614]                   }
[10:59:36.614]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.614]                     cond$call), session = sessionInformation(), 
[10:59:36.614]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.614]                   signalCondition(cond)
[10:59:36.614]                 }
[10:59:36.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.614]                 "immediateCondition"))) {
[10:59:36.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.614]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.614]                   if (TRUE && !signal) {
[10:59:36.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.614]                     {
[10:59:36.614]                       inherits <- base::inherits
[10:59:36.614]                       invokeRestart <- base::invokeRestart
[10:59:36.614]                       is.null <- base::is.null
[10:59:36.614]                       muffled <- FALSE
[10:59:36.614]                       if (inherits(cond, "message")) {
[10:59:36.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.614]                         if (muffled) 
[10:59:36.614]                           invokeRestart("muffleMessage")
[10:59:36.614]                       }
[10:59:36.614]                       else if (inherits(cond, "warning")) {
[10:59:36.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.614]                         if (muffled) 
[10:59:36.614]                           invokeRestart("muffleWarning")
[10:59:36.614]                       }
[10:59:36.614]                       else if (inherits(cond, "condition")) {
[10:59:36.614]                         if (!is.null(pattern)) {
[10:59:36.614]                           computeRestarts <- base::computeRestarts
[10:59:36.614]                           grepl <- base::grepl
[10:59:36.614]                           restarts <- computeRestarts(cond)
[10:59:36.614]                           for (restart in restarts) {
[10:59:36.614]                             name <- restart$name
[10:59:36.614]                             if (is.null(name)) 
[10:59:36.614]                               next
[10:59:36.614]                             if (!grepl(pattern, name)) 
[10:59:36.614]                               next
[10:59:36.614]                             invokeRestart(restart)
[10:59:36.614]                             muffled <- TRUE
[10:59:36.614]                             break
[10:59:36.614]                           }
[10:59:36.614]                         }
[10:59:36.614]                       }
[10:59:36.614]                       invisible(muffled)
[10:59:36.614]                     }
[10:59:36.614]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.614]                   }
[10:59:36.614]                 }
[10:59:36.614]                 else {
[10:59:36.614]                   if (TRUE) {
[10:59:36.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.614]                     {
[10:59:36.614]                       inherits <- base::inherits
[10:59:36.614]                       invokeRestart <- base::invokeRestart
[10:59:36.614]                       is.null <- base::is.null
[10:59:36.614]                       muffled <- FALSE
[10:59:36.614]                       if (inherits(cond, "message")) {
[10:59:36.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.614]                         if (muffled) 
[10:59:36.614]                           invokeRestart("muffleMessage")
[10:59:36.614]                       }
[10:59:36.614]                       else if (inherits(cond, "warning")) {
[10:59:36.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.614]                         if (muffled) 
[10:59:36.614]                           invokeRestart("muffleWarning")
[10:59:36.614]                       }
[10:59:36.614]                       else if (inherits(cond, "condition")) {
[10:59:36.614]                         if (!is.null(pattern)) {
[10:59:36.614]                           computeRestarts <- base::computeRestarts
[10:59:36.614]                           grepl <- base::grepl
[10:59:36.614]                           restarts <- computeRestarts(cond)
[10:59:36.614]                           for (restart in restarts) {
[10:59:36.614]                             name <- restart$name
[10:59:36.614]                             if (is.null(name)) 
[10:59:36.614]                               next
[10:59:36.614]                             if (!grepl(pattern, name)) 
[10:59:36.614]                               next
[10:59:36.614]                             invokeRestart(restart)
[10:59:36.614]                             muffled <- TRUE
[10:59:36.614]                             break
[10:59:36.614]                           }
[10:59:36.614]                         }
[10:59:36.614]                       }
[10:59:36.614]                       invisible(muffled)
[10:59:36.614]                     }
[10:59:36.614]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.614]                   }
[10:59:36.614]                 }
[10:59:36.614]             }
[10:59:36.614]         }))
[10:59:36.614]     }, error = function(ex) {
[10:59:36.614]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.614]                 ...future.rng), started = ...future.startTime, 
[10:59:36.614]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.614]             version = "1.8"), class = "FutureResult")
[10:59:36.614]     }, finally = {
[10:59:36.614]         if (!identical(...future.workdir, getwd())) 
[10:59:36.614]             setwd(...future.workdir)
[10:59:36.614]         {
[10:59:36.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.614]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.614]             }
[10:59:36.614]             base::options(...future.oldOptions)
[10:59:36.614]             if (.Platform$OS.type == "windows") {
[10:59:36.614]                 old_names <- names(...future.oldEnvVars)
[10:59:36.614]                 envs <- base::Sys.getenv()
[10:59:36.614]                 names <- names(envs)
[10:59:36.614]                 common <- intersect(names, old_names)
[10:59:36.614]                 added <- setdiff(names, old_names)
[10:59:36.614]                 removed <- setdiff(old_names, names)
[10:59:36.614]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.614]                   envs[common]]
[10:59:36.614]                 NAMES <- toupper(changed)
[10:59:36.614]                 args <- list()
[10:59:36.614]                 for (kk in seq_along(NAMES)) {
[10:59:36.614]                   name <- changed[[kk]]
[10:59:36.614]                   NAME <- NAMES[[kk]]
[10:59:36.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.614]                     next
[10:59:36.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.614]                 }
[10:59:36.614]                 NAMES <- toupper(added)
[10:59:36.614]                 for (kk in seq_along(NAMES)) {
[10:59:36.614]                   name <- added[[kk]]
[10:59:36.614]                   NAME <- NAMES[[kk]]
[10:59:36.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.614]                     next
[10:59:36.614]                   args[[name]] <- ""
[10:59:36.614]                 }
[10:59:36.614]                 NAMES <- toupper(removed)
[10:59:36.614]                 for (kk in seq_along(NAMES)) {
[10:59:36.614]                   name <- removed[[kk]]
[10:59:36.614]                   NAME <- NAMES[[kk]]
[10:59:36.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.614]                     next
[10:59:36.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.614]                 }
[10:59:36.614]                 if (length(args) > 0) 
[10:59:36.614]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.614]             }
[10:59:36.614]             else {
[10:59:36.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.614]             }
[10:59:36.614]             {
[10:59:36.614]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.614]                   0L) {
[10:59:36.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.614]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.614]                   base::options(opts)
[10:59:36.614]                 }
[10:59:36.614]                 {
[10:59:36.614]                   {
[10:59:36.614]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.614]                     NULL
[10:59:36.614]                   }
[10:59:36.614]                   options(future.plan = NULL)
[10:59:36.614]                   if (is.na(NA_character_)) 
[10:59:36.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.614]                     .init = FALSE)
[10:59:36.614]                 }
[10:59:36.614]             }
[10:59:36.614]         }
[10:59:36.614]     })
[10:59:36.614]     if (TRUE) {
[10:59:36.614]         base::sink(type = "output", split = FALSE)
[10:59:36.614]         if (TRUE) {
[10:59:36.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.614]         }
[10:59:36.614]         else {
[10:59:36.614]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.614]         }
[10:59:36.614]         base::close(...future.stdout)
[10:59:36.614]         ...future.stdout <- NULL
[10:59:36.614]     }
[10:59:36.614]     ...future.result$conditions <- ...future.conditions
[10:59:36.614]     ...future.result$finished <- base::Sys.time()
[10:59:36.614]     ...future.result
[10:59:36.614] }
[10:59:36.616] Exporting 5 global objects (1.05 KiB) to cluster node #2 ...
[10:59:36.617] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[10:59:36.617] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[10:59:36.617] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[10:59:36.617] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[10:59:36.618] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[10:59:36.618] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[10:59:36.618] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:36.618] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.619] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:36.619] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.619] Exporting 5 global objects (1.05 KiB) to cluster node #2 ... DONE
[10:59:36.619] MultisessionFuture started
[10:59:36.620] - Launch lazy future ... done
[10:59:36.620] run() for ‘MultisessionFuture’ ... done
[10:59:36.620] Created future:
[10:59:36.620] MultisessionFuture:
[10:59:36.620] Label: ‘future_mapply-2’
[10:59:36.620] Expression:
[10:59:36.620] {
[10:59:36.620]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.620]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.620]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.620]         on.exit(options(oopts), add = TRUE)
[10:59:36.620]     }
[10:59:36.620]     {
[10:59:36.620]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.620]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.620]         do.call(mapply, args = args)
[10:59:36.620]     }
[10:59:36.620] }
[10:59:36.620] Lazy evaluation: FALSE
[10:59:36.620] Asynchronous evaluation: TRUE
[10:59:36.620] Local evaluation: TRUE
[10:59:36.620] Environment: R_GlobalEnv
[10:59:36.620] Capture standard output: TRUE
[10:59:36.620] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.620] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.620] Packages: <none>
[10:59:36.620] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.620] Resolved: FALSE
[10:59:36.620] Value: <not collected>
[10:59:36.620] Conditions captured: <none>
[10:59:36.620] Early signaling: FALSE
[10:59:36.620] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.620] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.631] Chunk #2 of 2 ... DONE
[10:59:36.631] Launching 2 futures (chunks) ... DONE
[10:59:36.631] Resolving 2 futures (chunks) ...
[10:59:36.631] resolve() on list ...
[10:59:36.632]  recursive: 0
[10:59:36.632]  length: 2
[10:59:36.632] 
[10:59:36.632] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.632] - Validating connection of MultisessionFuture
[10:59:36.632] - received message: FutureResult
[10:59:36.633] - Received FutureResult
[10:59:36.633] - Erased future from FutureRegistry
[10:59:36.633] result() for ClusterFuture ...
[10:59:36.633] - result already collected: FutureResult
[10:59:36.633] result() for ClusterFuture ... done
[10:59:36.633] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.633] Future #1
[10:59:36.633] result() for ClusterFuture ...
[10:59:36.633] - result already collected: FutureResult
[10:59:36.633] result() for ClusterFuture ... done
[10:59:36.633] result() for ClusterFuture ...
[10:59:36.634] - result already collected: FutureResult
[10:59:36.634] result() for ClusterFuture ... done
[10:59:36.634] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.634] - nx: 2
[10:59:36.634] - relay: TRUE
[10:59:36.634] - stdout: TRUE
[10:59:36.634] - signal: TRUE
[10:59:36.634] - resignal: FALSE
[10:59:36.634] - force: TRUE
[10:59:36.634] - relayed: [n=2] FALSE, FALSE
[10:59:36.634] - queued futures: [n=2] FALSE, FALSE
[10:59:36.634]  - until=1
[10:59:36.635]  - relaying element #1
[10:59:36.635] result() for ClusterFuture ...
[10:59:36.635] - result already collected: FutureResult
[10:59:36.635] result() for ClusterFuture ... done
[10:59:36.635] result() for ClusterFuture ...
[10:59:36.635] - result already collected: FutureResult
[10:59:36.635] result() for ClusterFuture ... done
[10:59:36.635] result() for ClusterFuture ...
[10:59:36.635] - result already collected: FutureResult
[10:59:36.635] result() for ClusterFuture ... done
[10:59:36.635] result() for ClusterFuture ...
[10:59:36.635] - result already collected: FutureResult
[10:59:36.636] result() for ClusterFuture ... done
[10:59:36.636] - relayed: [n=2] TRUE, FALSE
[10:59:36.636] - queued futures: [n=2] TRUE, FALSE
[10:59:36.636] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.636]  length: 1 (resolved future 1)
[10:59:36.661] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.661] - Validating connection of MultisessionFuture
[10:59:36.662] - received message: FutureResult
[10:59:36.662] - Received FutureResult
[10:59:36.662] - Erased future from FutureRegistry
[10:59:36.662] result() for ClusterFuture ...
[10:59:36.662] - result already collected: FutureResult
[10:59:36.662] result() for ClusterFuture ... done
[10:59:36.662] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.662] Future #2
[10:59:36.662] result() for ClusterFuture ...
[10:59:36.662] - result already collected: FutureResult
[10:59:36.662] result() for ClusterFuture ... done
[10:59:36.662] result() for ClusterFuture ...
[10:59:36.663] - result already collected: FutureResult
[10:59:36.663] result() for ClusterFuture ... done
[10:59:36.663] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:36.663] - nx: 2
[10:59:36.663] - relay: TRUE
[10:59:36.663] - stdout: TRUE
[10:59:36.663] - signal: TRUE
[10:59:36.663] - resignal: FALSE
[10:59:36.663] - force: TRUE
[10:59:36.663] - relayed: [n=2] TRUE, FALSE
[10:59:36.663] - queued futures: [n=2] TRUE, FALSE
[10:59:36.663]  - until=2
[10:59:36.664]  - relaying element #2
[10:59:36.664] result() for ClusterFuture ...
[10:59:36.664] - result already collected: FutureResult
[10:59:36.664] result() for ClusterFuture ... done
[10:59:36.664] result() for ClusterFuture ...
[10:59:36.664] - result already collected: FutureResult
[10:59:36.664] result() for ClusterFuture ... done
[10:59:36.664] result() for ClusterFuture ...
[10:59:36.664] - result already collected: FutureResult
[10:59:36.664] result() for ClusterFuture ... done
[10:59:36.664] result() for ClusterFuture ...
[10:59:36.664] - result already collected: FutureResult
[10:59:36.665] result() for ClusterFuture ... done
[10:59:36.665] - relayed: [n=2] TRUE, TRUE
[10:59:36.665] - queued futures: [n=2] TRUE, TRUE
[10:59:36.665] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:36.665]  length: 0 (resolved future 2)
[10:59:36.665] Relaying remaining futures
[10:59:36.665] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.665] - nx: 2
[10:59:36.665] - relay: TRUE
[10:59:36.665] - stdout: TRUE
[10:59:36.665] - signal: TRUE
[10:59:36.665] - resignal: FALSE
[10:59:36.665] - force: TRUE
[10:59:36.666] - relayed: [n=2] TRUE, TRUE
[10:59:36.666] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:36.666] - relayed: [n=2] TRUE, TRUE
[10:59:36.666] - queued futures: [n=2] TRUE, TRUE
[10:59:36.666] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.666] resolve() on list ... DONE
[10:59:36.666] result() for ClusterFuture ...
[10:59:36.666] - result already collected: FutureResult
[10:59:36.666] result() for ClusterFuture ... done
[10:59:36.666] result() for ClusterFuture ...
[10:59:36.666] - result already collected: FutureResult
[10:59:36.666] result() for ClusterFuture ... done
[10:59:36.667] result() for ClusterFuture ...
[10:59:36.667] - result already collected: FutureResult
[10:59:36.667] result() for ClusterFuture ... done
[10:59:36.667] result() for ClusterFuture ...
[10:59:36.667] - result already collected: FutureResult
[10:59:36.667] result() for ClusterFuture ... done
[10:59:36.667]  - Number of value chunks collected: 2
[10:59:36.667] Resolving 2 futures (chunks) ... DONE
[10:59:36.667] Reducing values from 2 chunks ...
[10:59:36.667]  - Number of values collected after concatenation: 2
[10:59:36.667]  - Number of values expected: 2
[10:59:36.668] Reducing values from 2 chunks ... DONE
[10:59:36.668] future_mapply() ... DONE
[10:59:36.668] future_mapply() ...
[10:59:36.668] Generating random seeds ...
[10:59:36.668] Generating random seed streams for 2 elements ...
[10:59:36.668] Generating random seed streams for 2 elements ... DONE
[10:59:36.668] Generating random seeds ... DONE
[10:59:36.668] Will set RNG state on exit: 10407, -1353544584, 61963431, 979643426, -1689745763, -932569828, -1327431359
[10:59:36.670] Number of chunks: 2
[10:59:36.670] getGlobalsAndPackagesXApply() ...
[10:59:36.670]  - future.globals: TRUE
[10:59:36.670] getGlobalsAndPackages() ...
[10:59:36.670] Searching for globals...
[10:59:36.671] - globals found: [1] ‘FUN’
[10:59:36.671] Searching for globals ... DONE
[10:59:36.671] Resolving globals: FALSE
[10:59:36.671] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:36.672] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:36.672] - globals: [1] ‘FUN’
[10:59:36.672] 
[10:59:36.672] getGlobalsAndPackages() ... DONE
[10:59:36.672]  - globals found/used: [n=1] ‘FUN’
[10:59:36.672]  - needed namespaces: [n=0] 
[10:59:36.672] Finding globals ... DONE
[10:59:36.672] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.673] List of 2
[10:59:36.673]  $ ...future.FUN:function (x, y)  
[10:59:36.673]  $ MoreArgs     :List of 1
[10:59:36.673]   ..$ y: int [1:2] 3 4
[10:59:36.673]  - attr(*, "where")=List of 2
[10:59:36.673]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.673]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.673]  - attr(*, "resolved")= logi FALSE
[10:59:36.673]  - attr(*, "total_size")= num NA
[10:59:36.675] Packages to be attached in all futures: [n=0] 
[10:59:36.675] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.676] Number of futures (= number of chunks): 2
[10:59:36.676] Launching 2 futures (chunks) ...
[10:59:36.676] Chunk #1 of 2 ...
[10:59:36.676]  - Finding globals in '...' for chunk #1 ...
[10:59:36.676] getGlobalsAndPackages() ...
[10:59:36.676] Searching for globals...
[10:59:36.676] 
[10:59:36.676] Searching for globals ... DONE
[10:59:36.676] - globals: [0] <none>
[10:59:36.677] getGlobalsAndPackages() ... DONE
[10:59:36.677]    + additional globals found: [n=0] 
[10:59:36.677]    + additional namespaces needed: [n=0] 
[10:59:36.677]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.677]  - seeds: [1] <seeds>
[10:59:36.677]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.677] getGlobalsAndPackages() ...
[10:59:36.677] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.677] Resolving globals: FALSE
[10:59:36.678] The total size of the 5 globals is 696 bytes (696 bytes)
[10:59:36.678] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:36.678] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.678] 
[10:59:36.678] getGlobalsAndPackages() ... DONE
[10:59:36.679] run() for ‘Future’ ...
[10:59:36.679] - state: ‘created’
[10:59:36.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.692] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.693]   - Field: ‘node’
[10:59:36.693]   - Field: ‘label’
[10:59:36.693]   - Field: ‘local’
[10:59:36.693]   - Field: ‘owner’
[10:59:36.693]   - Field: ‘envir’
[10:59:36.693]   - Field: ‘workers’
[10:59:36.693]   - Field: ‘packages’
[10:59:36.693]   - Field: ‘gc’
[10:59:36.693]   - Field: ‘conditions’
[10:59:36.694]   - Field: ‘persistent’
[10:59:36.694]   - Field: ‘expr’
[10:59:36.694]   - Field: ‘uuid’
[10:59:36.694]   - Field: ‘seed’
[10:59:36.694]   - Field: ‘version’
[10:59:36.694]   - Field: ‘result’
[10:59:36.694]   - Field: ‘asynchronous’
[10:59:36.694]   - Field: ‘calls’
[10:59:36.694]   - Field: ‘globals’
[10:59:36.694]   - Field: ‘stdout’
[10:59:36.694]   - Field: ‘earlySignal’
[10:59:36.694]   - Field: ‘lazy’
[10:59:36.695]   - Field: ‘state’
[10:59:36.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.695] - Launch lazy future ...
[10:59:36.695] Packages needed by the future expression (n = 0): <none>
[10:59:36.695] Packages needed by future strategies (n = 0): <none>
[10:59:36.695] {
[10:59:36.695]     {
[10:59:36.695]         {
[10:59:36.695]             ...future.startTime <- base::Sys.time()
[10:59:36.695]             {
[10:59:36.695]                 {
[10:59:36.695]                   {
[10:59:36.695]                     {
[10:59:36.695]                       base::local({
[10:59:36.695]                         has_future <- base::requireNamespace("future", 
[10:59:36.695]                           quietly = TRUE)
[10:59:36.695]                         if (has_future) {
[10:59:36.695]                           ns <- base::getNamespace("future")
[10:59:36.695]                           version <- ns[[".package"]][["version"]]
[10:59:36.695]                           if (is.null(version)) 
[10:59:36.695]                             version <- utils::packageVersion("future")
[10:59:36.695]                         }
[10:59:36.695]                         else {
[10:59:36.695]                           version <- NULL
[10:59:36.695]                         }
[10:59:36.695]                         if (!has_future || version < "1.8.0") {
[10:59:36.695]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.695]                             "", base::R.version$version.string), 
[10:59:36.695]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.695]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.695]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.695]                               "release", "version")], collapse = " "), 
[10:59:36.695]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.695]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.695]                             info)
[10:59:36.695]                           info <- base::paste(info, collapse = "; ")
[10:59:36.695]                           if (!has_future) {
[10:59:36.695]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.695]                               info)
[10:59:36.695]                           }
[10:59:36.695]                           else {
[10:59:36.695]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.695]                               info, version)
[10:59:36.695]                           }
[10:59:36.695]                           base::stop(msg)
[10:59:36.695]                         }
[10:59:36.695]                       })
[10:59:36.695]                     }
[10:59:36.695]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.695]                     base::options(mc.cores = 1L)
[10:59:36.695]                   }
[10:59:36.695]                   ...future.strategy.old <- future::plan("list")
[10:59:36.695]                   options(future.plan = NULL)
[10:59:36.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.695]                 }
[10:59:36.695]                 ...future.workdir <- getwd()
[10:59:36.695]             }
[10:59:36.695]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.695]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.695]         }
[10:59:36.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.695]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.695]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.695]             base::names(...future.oldOptions))
[10:59:36.695]     }
[10:59:36.695]     if (FALSE) {
[10:59:36.695]     }
[10:59:36.695]     else {
[10:59:36.695]         if (TRUE) {
[10:59:36.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.695]                 open = "w")
[10:59:36.695]         }
[10:59:36.695]         else {
[10:59:36.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.695]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.695]         }
[10:59:36.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.695]             base::sink(type = "output", split = FALSE)
[10:59:36.695]             base::close(...future.stdout)
[10:59:36.695]         }, add = TRUE)
[10:59:36.695]     }
[10:59:36.695]     ...future.frame <- base::sys.nframe()
[10:59:36.695]     ...future.conditions <- base::list()
[10:59:36.695]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.695]     if (FALSE) {
[10:59:36.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.695]     }
[10:59:36.695]     ...future.result <- base::tryCatch({
[10:59:36.695]         base::withCallingHandlers({
[10:59:36.695]             ...future.value <- base::withVisible(base::local({
[10:59:36.695]                 ...future.makeSendCondition <- base::local({
[10:59:36.695]                   sendCondition <- NULL
[10:59:36.695]                   function(frame = 1L) {
[10:59:36.695]                     if (is.function(sendCondition)) 
[10:59:36.695]                       return(sendCondition)
[10:59:36.695]                     ns <- getNamespace("parallel")
[10:59:36.695]                     if (exists("sendData", mode = "function", 
[10:59:36.695]                       envir = ns)) {
[10:59:36.695]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.695]                         envir = ns)
[10:59:36.695]                       envir <- sys.frame(frame)
[10:59:36.695]                       master <- NULL
[10:59:36.695]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.695]                         !identical(envir, emptyenv())) {
[10:59:36.695]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.695]                           inherits = FALSE)) {
[10:59:36.695]                           master <- get("master", mode = "list", 
[10:59:36.695]                             envir = envir, inherits = FALSE)
[10:59:36.695]                           if (inherits(master, c("SOCKnode", 
[10:59:36.695]                             "SOCK0node"))) {
[10:59:36.695]                             sendCondition <<- function(cond) {
[10:59:36.695]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.695]                                 success = TRUE)
[10:59:36.695]                               parallel_sendData(master, data)
[10:59:36.695]                             }
[10:59:36.695]                             return(sendCondition)
[10:59:36.695]                           }
[10:59:36.695]                         }
[10:59:36.695]                         frame <- frame + 1L
[10:59:36.695]                         envir <- sys.frame(frame)
[10:59:36.695]                       }
[10:59:36.695]                     }
[10:59:36.695]                     sendCondition <<- function(cond) NULL
[10:59:36.695]                   }
[10:59:36.695]                 })
[10:59:36.695]                 withCallingHandlers({
[10:59:36.695]                   {
[10:59:36.695]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.695]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.695]                       ...future.globals.maxSize)) {
[10:59:36.695]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.695]                       on.exit(options(oopts), add = TRUE)
[10:59:36.695]                     }
[10:59:36.695]                     {
[10:59:36.695]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:36.695]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:36.695]                           envir = globalenv(), inherits = FALSE)
[10:59:36.695]                         ...future.FUN(...)
[10:59:36.695]                       }
[10:59:36.695]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:36.695]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:36.695]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.695]                         USE.NAMES = FALSE)
[10:59:36.695]                       do.call(mapply, args = args)
[10:59:36.695]                     }
[10:59:36.695]                   }
[10:59:36.695]                 }, immediateCondition = function(cond) {
[10:59:36.695]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.695]                   sendCondition(cond)
[10:59:36.695]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.695]                   {
[10:59:36.695]                     inherits <- base::inherits
[10:59:36.695]                     invokeRestart <- base::invokeRestart
[10:59:36.695]                     is.null <- base::is.null
[10:59:36.695]                     muffled <- FALSE
[10:59:36.695]                     if (inherits(cond, "message")) {
[10:59:36.695]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.695]                       if (muffled) 
[10:59:36.695]                         invokeRestart("muffleMessage")
[10:59:36.695]                     }
[10:59:36.695]                     else if (inherits(cond, "warning")) {
[10:59:36.695]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.695]                       if (muffled) 
[10:59:36.695]                         invokeRestart("muffleWarning")
[10:59:36.695]                     }
[10:59:36.695]                     else if (inherits(cond, "condition")) {
[10:59:36.695]                       if (!is.null(pattern)) {
[10:59:36.695]                         computeRestarts <- base::computeRestarts
[10:59:36.695]                         grepl <- base::grepl
[10:59:36.695]                         restarts <- computeRestarts(cond)
[10:59:36.695]                         for (restart in restarts) {
[10:59:36.695]                           name <- restart$name
[10:59:36.695]                           if (is.null(name)) 
[10:59:36.695]                             next
[10:59:36.695]                           if (!grepl(pattern, name)) 
[10:59:36.695]                             next
[10:59:36.695]                           invokeRestart(restart)
[10:59:36.695]                           muffled <- TRUE
[10:59:36.695]                           break
[10:59:36.695]                         }
[10:59:36.695]                       }
[10:59:36.695]                     }
[10:59:36.695]                     invisible(muffled)
[10:59:36.695]                   }
[10:59:36.695]                   muffleCondition(cond)
[10:59:36.695]                 })
[10:59:36.695]             }))
[10:59:36.695]             future::FutureResult(value = ...future.value$value, 
[10:59:36.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.695]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.695]                     ...future.globalenv.names))
[10:59:36.695]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.695]         }, condition = base::local({
[10:59:36.695]             c <- base::c
[10:59:36.695]             inherits <- base::inherits
[10:59:36.695]             invokeRestart <- base::invokeRestart
[10:59:36.695]             length <- base::length
[10:59:36.695]             list <- base::list
[10:59:36.695]             seq.int <- base::seq.int
[10:59:36.695]             signalCondition <- base::signalCondition
[10:59:36.695]             sys.calls <- base::sys.calls
[10:59:36.695]             `[[` <- base::`[[`
[10:59:36.695]             `+` <- base::`+`
[10:59:36.695]             `<<-` <- base::`<<-`
[10:59:36.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.695]                   3L)]
[10:59:36.695]             }
[10:59:36.695]             function(cond) {
[10:59:36.695]                 is_error <- inherits(cond, "error")
[10:59:36.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.695]                   NULL)
[10:59:36.695]                 if (is_error) {
[10:59:36.695]                   sessionInformation <- function() {
[10:59:36.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.695]                       search = base::search(), system = base::Sys.info())
[10:59:36.695]                   }
[10:59:36.695]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.695]                     cond$call), session = sessionInformation(), 
[10:59:36.695]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.695]                   signalCondition(cond)
[10:59:36.695]                 }
[10:59:36.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.695]                 "immediateCondition"))) {
[10:59:36.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.695]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.695]                   if (TRUE && !signal) {
[10:59:36.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.695]                     {
[10:59:36.695]                       inherits <- base::inherits
[10:59:36.695]                       invokeRestart <- base::invokeRestart
[10:59:36.695]                       is.null <- base::is.null
[10:59:36.695]                       muffled <- FALSE
[10:59:36.695]                       if (inherits(cond, "message")) {
[10:59:36.695]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.695]                         if (muffled) 
[10:59:36.695]                           invokeRestart("muffleMessage")
[10:59:36.695]                       }
[10:59:36.695]                       else if (inherits(cond, "warning")) {
[10:59:36.695]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.695]                         if (muffled) 
[10:59:36.695]                           invokeRestart("muffleWarning")
[10:59:36.695]                       }
[10:59:36.695]                       else if (inherits(cond, "condition")) {
[10:59:36.695]                         if (!is.null(pattern)) {
[10:59:36.695]                           computeRestarts <- base::computeRestarts
[10:59:36.695]                           grepl <- base::grepl
[10:59:36.695]                           restarts <- computeRestarts(cond)
[10:59:36.695]                           for (restart in restarts) {
[10:59:36.695]                             name <- restart$name
[10:59:36.695]                             if (is.null(name)) 
[10:59:36.695]                               next
[10:59:36.695]                             if (!grepl(pattern, name)) 
[10:59:36.695]                               next
[10:59:36.695]                             invokeRestart(restart)
[10:59:36.695]                             muffled <- TRUE
[10:59:36.695]                             break
[10:59:36.695]                           }
[10:59:36.695]                         }
[10:59:36.695]                       }
[10:59:36.695]                       invisible(muffled)
[10:59:36.695]                     }
[10:59:36.695]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.695]                   }
[10:59:36.695]                 }
[10:59:36.695]                 else {
[10:59:36.695]                   if (TRUE) {
[10:59:36.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.695]                     {
[10:59:36.695]                       inherits <- base::inherits
[10:59:36.695]                       invokeRestart <- base::invokeRestart
[10:59:36.695]                       is.null <- base::is.null
[10:59:36.695]                       muffled <- FALSE
[10:59:36.695]                       if (inherits(cond, "message")) {
[10:59:36.695]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.695]                         if (muffled) 
[10:59:36.695]                           invokeRestart("muffleMessage")
[10:59:36.695]                       }
[10:59:36.695]                       else if (inherits(cond, "warning")) {
[10:59:36.695]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.695]                         if (muffled) 
[10:59:36.695]                           invokeRestart("muffleWarning")
[10:59:36.695]                       }
[10:59:36.695]                       else if (inherits(cond, "condition")) {
[10:59:36.695]                         if (!is.null(pattern)) {
[10:59:36.695]                           computeRestarts <- base::computeRestarts
[10:59:36.695]                           grepl <- base::grepl
[10:59:36.695]                           restarts <- computeRestarts(cond)
[10:59:36.695]                           for (restart in restarts) {
[10:59:36.695]                             name <- restart$name
[10:59:36.695]                             if (is.null(name)) 
[10:59:36.695]                               next
[10:59:36.695]                             if (!grepl(pattern, name)) 
[10:59:36.695]                               next
[10:59:36.695]                             invokeRestart(restart)
[10:59:36.695]                             muffled <- TRUE
[10:59:36.695]                             break
[10:59:36.695]                           }
[10:59:36.695]                         }
[10:59:36.695]                       }
[10:59:36.695]                       invisible(muffled)
[10:59:36.695]                     }
[10:59:36.695]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.695]                   }
[10:59:36.695]                 }
[10:59:36.695]             }
[10:59:36.695]         }))
[10:59:36.695]     }, error = function(ex) {
[10:59:36.695]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.695]                 ...future.rng), started = ...future.startTime, 
[10:59:36.695]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.695]             version = "1.8"), class = "FutureResult")
[10:59:36.695]     }, finally = {
[10:59:36.695]         if (!identical(...future.workdir, getwd())) 
[10:59:36.695]             setwd(...future.workdir)
[10:59:36.695]         {
[10:59:36.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.695]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.695]             }
[10:59:36.695]             base::options(...future.oldOptions)
[10:59:36.695]             if (.Platform$OS.type == "windows") {
[10:59:36.695]                 old_names <- names(...future.oldEnvVars)
[10:59:36.695]                 envs <- base::Sys.getenv()
[10:59:36.695]                 names <- names(envs)
[10:59:36.695]                 common <- intersect(names, old_names)
[10:59:36.695]                 added <- setdiff(names, old_names)
[10:59:36.695]                 removed <- setdiff(old_names, names)
[10:59:36.695]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.695]                   envs[common]]
[10:59:36.695]                 NAMES <- toupper(changed)
[10:59:36.695]                 args <- list()
[10:59:36.695]                 for (kk in seq_along(NAMES)) {
[10:59:36.695]                   name <- changed[[kk]]
[10:59:36.695]                   NAME <- NAMES[[kk]]
[10:59:36.695]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.695]                     next
[10:59:36.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.695]                 }
[10:59:36.695]                 NAMES <- toupper(added)
[10:59:36.695]                 for (kk in seq_along(NAMES)) {
[10:59:36.695]                   name <- added[[kk]]
[10:59:36.695]                   NAME <- NAMES[[kk]]
[10:59:36.695]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.695]                     next
[10:59:36.695]                   args[[name]] <- ""
[10:59:36.695]                 }
[10:59:36.695]                 NAMES <- toupper(removed)
[10:59:36.695]                 for (kk in seq_along(NAMES)) {
[10:59:36.695]                   name <- removed[[kk]]
[10:59:36.695]                   NAME <- NAMES[[kk]]
[10:59:36.695]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.695]                     next
[10:59:36.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.695]                 }
[10:59:36.695]                 if (length(args) > 0) 
[10:59:36.695]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.695]             }
[10:59:36.695]             else {
[10:59:36.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.695]             }
[10:59:36.695]             {
[10:59:36.695]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.695]                   0L) {
[10:59:36.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.695]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.695]                   base::options(opts)
[10:59:36.695]                 }
[10:59:36.695]                 {
[10:59:36.695]                   {
[10:59:36.695]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.695]                     NULL
[10:59:36.695]                   }
[10:59:36.695]                   options(future.plan = NULL)
[10:59:36.695]                   if (is.na(NA_character_)) 
[10:59:36.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.695]                     .init = FALSE)
[10:59:36.695]                 }
[10:59:36.695]             }
[10:59:36.695]         }
[10:59:36.695]     })
[10:59:36.695]     if (TRUE) {
[10:59:36.695]         base::sink(type = "output", split = FALSE)
[10:59:36.695]         if (TRUE) {
[10:59:36.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.695]         }
[10:59:36.695]         else {
[10:59:36.695]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.695]         }
[10:59:36.695]         base::close(...future.stdout)
[10:59:36.695]         ...future.stdout <- NULL
[10:59:36.695]     }
[10:59:36.695]     ...future.result$conditions <- ...future.conditions
[10:59:36.695]     ...future.result$finished <- base::Sys.time()
[10:59:36.695]     ...future.result
[10:59:36.695] }
[10:59:36.698] Exporting 5 global objects (1.09 KiB) to cluster node #1 ...
[10:59:36.698] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[10:59:36.699] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[10:59:36.699] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[10:59:36.699] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[10:59:36.699] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[10:59:36.700] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[10:59:36.700] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ...
[10:59:36.700] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ... DONE
[10:59:36.700] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.701] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.701] Exporting 5 global objects (1.09 KiB) to cluster node #1 ... DONE
[10:59:36.701] MultisessionFuture started
[10:59:36.701] - Launch lazy future ... done
[10:59:36.701] run() for ‘MultisessionFuture’ ... done
[10:59:36.701] Created future:
[10:59:36.701] MultisessionFuture:
[10:59:36.701] Label: ‘future_mapply-1’
[10:59:36.701] Expression:
[10:59:36.701] {
[10:59:36.701]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.701]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.701]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.701]         on.exit(options(oopts), add = TRUE)
[10:59:36.701]     }
[10:59:36.701]     {
[10:59:36.701]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:36.701]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:36.701]                 inherits = FALSE)
[10:59:36.701]             ...future.FUN(...)
[10:59:36.701]         }
[10:59:36.701]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:36.701]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:36.701]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.701]         do.call(mapply, args = args)
[10:59:36.701]     }
[10:59:36.701] }
[10:59:36.701] Lazy evaluation: FALSE
[10:59:36.701] Asynchronous evaluation: TRUE
[10:59:36.701] Local evaluation: TRUE
[10:59:36.701] Environment: R_GlobalEnv
[10:59:36.701] Capture standard output: TRUE
[10:59:36.701] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.701] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.701] Packages: <none>
[10:59:36.701] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:36.701] Resolved: FALSE
[10:59:36.701] Value: <not collected>
[10:59:36.701] Conditions captured: <none>
[10:59:36.701] Early signaling: FALSE
[10:59:36.701] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.701] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.713] Chunk #1 of 2 ... DONE
[10:59:36.713] Chunk #2 of 2 ...
[10:59:36.713]  - Finding globals in '...' for chunk #2 ...
[10:59:36.713] getGlobalsAndPackages() ...
[10:59:36.713] Searching for globals...
[10:59:36.714] 
[10:59:36.714] Searching for globals ... DONE
[10:59:36.714] - globals: [0] <none>
[10:59:36.714] getGlobalsAndPackages() ... DONE
[10:59:36.714]    + additional globals found: [n=0] 
[10:59:36.714]    + additional namespaces needed: [n=0] 
[10:59:36.714]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:36.714]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.714]  - seeds: [1] <seeds>
[10:59:36.714]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.714] getGlobalsAndPackages() ...
[10:59:36.715] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.715] Resolving globals: FALSE
[10:59:36.715] The total size of the 5 globals is 696 bytes (696 bytes)
[10:59:36.715] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:36.716] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.716] 
[10:59:36.716] getGlobalsAndPackages() ... DONE
[10:59:36.716] run() for ‘Future’ ...
[10:59:36.716] - state: ‘created’
[10:59:36.716] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.730] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.730]   - Field: ‘node’
[10:59:36.730]   - Field: ‘label’
[10:59:36.730]   - Field: ‘local’
[10:59:36.730]   - Field: ‘owner’
[10:59:36.730]   - Field: ‘envir’
[10:59:36.730]   - Field: ‘workers’
[10:59:36.730]   - Field: ‘packages’
[10:59:36.731]   - Field: ‘gc’
[10:59:36.731]   - Field: ‘conditions’
[10:59:36.731]   - Field: ‘persistent’
[10:59:36.731]   - Field: ‘expr’
[10:59:36.731]   - Field: ‘uuid’
[10:59:36.731]   - Field: ‘seed’
[10:59:36.731]   - Field: ‘version’
[10:59:36.731]   - Field: ‘result’
[10:59:36.731]   - Field: ‘asynchronous’
[10:59:36.731]   - Field: ‘calls’
[10:59:36.731]   - Field: ‘globals’
[10:59:36.731]   - Field: ‘stdout’
[10:59:36.732]   - Field: ‘earlySignal’
[10:59:36.732]   - Field: ‘lazy’
[10:59:36.732]   - Field: ‘state’
[10:59:36.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.732] - Launch lazy future ...
[10:59:36.732] Packages needed by the future expression (n = 0): <none>
[10:59:36.732] Packages needed by future strategies (n = 0): <none>
[10:59:36.733] {
[10:59:36.733]     {
[10:59:36.733]         {
[10:59:36.733]             ...future.startTime <- base::Sys.time()
[10:59:36.733]             {
[10:59:36.733]                 {
[10:59:36.733]                   {
[10:59:36.733]                     {
[10:59:36.733]                       base::local({
[10:59:36.733]                         has_future <- base::requireNamespace("future", 
[10:59:36.733]                           quietly = TRUE)
[10:59:36.733]                         if (has_future) {
[10:59:36.733]                           ns <- base::getNamespace("future")
[10:59:36.733]                           version <- ns[[".package"]][["version"]]
[10:59:36.733]                           if (is.null(version)) 
[10:59:36.733]                             version <- utils::packageVersion("future")
[10:59:36.733]                         }
[10:59:36.733]                         else {
[10:59:36.733]                           version <- NULL
[10:59:36.733]                         }
[10:59:36.733]                         if (!has_future || version < "1.8.0") {
[10:59:36.733]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.733]                             "", base::R.version$version.string), 
[10:59:36.733]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.733]                               "release", "version")], collapse = " "), 
[10:59:36.733]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.733]                             info)
[10:59:36.733]                           info <- base::paste(info, collapse = "; ")
[10:59:36.733]                           if (!has_future) {
[10:59:36.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.733]                               info)
[10:59:36.733]                           }
[10:59:36.733]                           else {
[10:59:36.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.733]                               info, version)
[10:59:36.733]                           }
[10:59:36.733]                           base::stop(msg)
[10:59:36.733]                         }
[10:59:36.733]                       })
[10:59:36.733]                     }
[10:59:36.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.733]                     base::options(mc.cores = 1L)
[10:59:36.733]                   }
[10:59:36.733]                   ...future.strategy.old <- future::plan("list")
[10:59:36.733]                   options(future.plan = NULL)
[10:59:36.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.733]                 }
[10:59:36.733]                 ...future.workdir <- getwd()
[10:59:36.733]             }
[10:59:36.733]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.733]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.733]         }
[10:59:36.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.733]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.733]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.733]             base::names(...future.oldOptions))
[10:59:36.733]     }
[10:59:36.733]     if (FALSE) {
[10:59:36.733]     }
[10:59:36.733]     else {
[10:59:36.733]         if (TRUE) {
[10:59:36.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.733]                 open = "w")
[10:59:36.733]         }
[10:59:36.733]         else {
[10:59:36.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.733]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.733]         }
[10:59:36.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.733]             base::sink(type = "output", split = FALSE)
[10:59:36.733]             base::close(...future.stdout)
[10:59:36.733]         }, add = TRUE)
[10:59:36.733]     }
[10:59:36.733]     ...future.frame <- base::sys.nframe()
[10:59:36.733]     ...future.conditions <- base::list()
[10:59:36.733]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.733]     if (FALSE) {
[10:59:36.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.733]     }
[10:59:36.733]     ...future.result <- base::tryCatch({
[10:59:36.733]         base::withCallingHandlers({
[10:59:36.733]             ...future.value <- base::withVisible(base::local({
[10:59:36.733]                 ...future.makeSendCondition <- base::local({
[10:59:36.733]                   sendCondition <- NULL
[10:59:36.733]                   function(frame = 1L) {
[10:59:36.733]                     if (is.function(sendCondition)) 
[10:59:36.733]                       return(sendCondition)
[10:59:36.733]                     ns <- getNamespace("parallel")
[10:59:36.733]                     if (exists("sendData", mode = "function", 
[10:59:36.733]                       envir = ns)) {
[10:59:36.733]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.733]                         envir = ns)
[10:59:36.733]                       envir <- sys.frame(frame)
[10:59:36.733]                       master <- NULL
[10:59:36.733]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.733]                         !identical(envir, emptyenv())) {
[10:59:36.733]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.733]                           inherits = FALSE)) {
[10:59:36.733]                           master <- get("master", mode = "list", 
[10:59:36.733]                             envir = envir, inherits = FALSE)
[10:59:36.733]                           if (inherits(master, c("SOCKnode", 
[10:59:36.733]                             "SOCK0node"))) {
[10:59:36.733]                             sendCondition <<- function(cond) {
[10:59:36.733]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.733]                                 success = TRUE)
[10:59:36.733]                               parallel_sendData(master, data)
[10:59:36.733]                             }
[10:59:36.733]                             return(sendCondition)
[10:59:36.733]                           }
[10:59:36.733]                         }
[10:59:36.733]                         frame <- frame + 1L
[10:59:36.733]                         envir <- sys.frame(frame)
[10:59:36.733]                       }
[10:59:36.733]                     }
[10:59:36.733]                     sendCondition <<- function(cond) NULL
[10:59:36.733]                   }
[10:59:36.733]                 })
[10:59:36.733]                 withCallingHandlers({
[10:59:36.733]                   {
[10:59:36.733]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.733]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.733]                       ...future.globals.maxSize)) {
[10:59:36.733]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.733]                       on.exit(options(oopts), add = TRUE)
[10:59:36.733]                     }
[10:59:36.733]                     {
[10:59:36.733]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:36.733]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:36.733]                           envir = globalenv(), inherits = FALSE)
[10:59:36.733]                         ...future.FUN(...)
[10:59:36.733]                       }
[10:59:36.733]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:36.733]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:36.733]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.733]                         USE.NAMES = FALSE)
[10:59:36.733]                       do.call(mapply, args = args)
[10:59:36.733]                     }
[10:59:36.733]                   }
[10:59:36.733]                 }, immediateCondition = function(cond) {
[10:59:36.733]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.733]                   sendCondition(cond)
[10:59:36.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.733]                   {
[10:59:36.733]                     inherits <- base::inherits
[10:59:36.733]                     invokeRestart <- base::invokeRestart
[10:59:36.733]                     is.null <- base::is.null
[10:59:36.733]                     muffled <- FALSE
[10:59:36.733]                     if (inherits(cond, "message")) {
[10:59:36.733]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.733]                       if (muffled) 
[10:59:36.733]                         invokeRestart("muffleMessage")
[10:59:36.733]                     }
[10:59:36.733]                     else if (inherits(cond, "warning")) {
[10:59:36.733]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.733]                       if (muffled) 
[10:59:36.733]                         invokeRestart("muffleWarning")
[10:59:36.733]                     }
[10:59:36.733]                     else if (inherits(cond, "condition")) {
[10:59:36.733]                       if (!is.null(pattern)) {
[10:59:36.733]                         computeRestarts <- base::computeRestarts
[10:59:36.733]                         grepl <- base::grepl
[10:59:36.733]                         restarts <- computeRestarts(cond)
[10:59:36.733]                         for (restart in restarts) {
[10:59:36.733]                           name <- restart$name
[10:59:36.733]                           if (is.null(name)) 
[10:59:36.733]                             next
[10:59:36.733]                           if (!grepl(pattern, name)) 
[10:59:36.733]                             next
[10:59:36.733]                           invokeRestart(restart)
[10:59:36.733]                           muffled <- TRUE
[10:59:36.733]                           break
[10:59:36.733]                         }
[10:59:36.733]                       }
[10:59:36.733]                     }
[10:59:36.733]                     invisible(muffled)
[10:59:36.733]                   }
[10:59:36.733]                   muffleCondition(cond)
[10:59:36.733]                 })
[10:59:36.733]             }))
[10:59:36.733]             future::FutureResult(value = ...future.value$value, 
[10:59:36.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.733]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.733]                     ...future.globalenv.names))
[10:59:36.733]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.733]         }, condition = base::local({
[10:59:36.733]             c <- base::c
[10:59:36.733]             inherits <- base::inherits
[10:59:36.733]             invokeRestart <- base::invokeRestart
[10:59:36.733]             length <- base::length
[10:59:36.733]             list <- base::list
[10:59:36.733]             seq.int <- base::seq.int
[10:59:36.733]             signalCondition <- base::signalCondition
[10:59:36.733]             sys.calls <- base::sys.calls
[10:59:36.733]             `[[` <- base::`[[`
[10:59:36.733]             `+` <- base::`+`
[10:59:36.733]             `<<-` <- base::`<<-`
[10:59:36.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.733]                   3L)]
[10:59:36.733]             }
[10:59:36.733]             function(cond) {
[10:59:36.733]                 is_error <- inherits(cond, "error")
[10:59:36.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.733]                   NULL)
[10:59:36.733]                 if (is_error) {
[10:59:36.733]                   sessionInformation <- function() {
[10:59:36.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.733]                       search = base::search(), system = base::Sys.info())
[10:59:36.733]                   }
[10:59:36.733]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.733]                     cond$call), session = sessionInformation(), 
[10:59:36.733]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.733]                   signalCondition(cond)
[10:59:36.733]                 }
[10:59:36.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.733]                 "immediateCondition"))) {
[10:59:36.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.733]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.733]                   if (TRUE && !signal) {
[10:59:36.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.733]                     {
[10:59:36.733]                       inherits <- base::inherits
[10:59:36.733]                       invokeRestart <- base::invokeRestart
[10:59:36.733]                       is.null <- base::is.null
[10:59:36.733]                       muffled <- FALSE
[10:59:36.733]                       if (inherits(cond, "message")) {
[10:59:36.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.733]                         if (muffled) 
[10:59:36.733]                           invokeRestart("muffleMessage")
[10:59:36.733]                       }
[10:59:36.733]                       else if (inherits(cond, "warning")) {
[10:59:36.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.733]                         if (muffled) 
[10:59:36.733]                           invokeRestart("muffleWarning")
[10:59:36.733]                       }
[10:59:36.733]                       else if (inherits(cond, "condition")) {
[10:59:36.733]                         if (!is.null(pattern)) {
[10:59:36.733]                           computeRestarts <- base::computeRestarts
[10:59:36.733]                           grepl <- base::grepl
[10:59:36.733]                           restarts <- computeRestarts(cond)
[10:59:36.733]                           for (restart in restarts) {
[10:59:36.733]                             name <- restart$name
[10:59:36.733]                             if (is.null(name)) 
[10:59:36.733]                               next
[10:59:36.733]                             if (!grepl(pattern, name)) 
[10:59:36.733]                               next
[10:59:36.733]                             invokeRestart(restart)
[10:59:36.733]                             muffled <- TRUE
[10:59:36.733]                             break
[10:59:36.733]                           }
[10:59:36.733]                         }
[10:59:36.733]                       }
[10:59:36.733]                       invisible(muffled)
[10:59:36.733]                     }
[10:59:36.733]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.733]                   }
[10:59:36.733]                 }
[10:59:36.733]                 else {
[10:59:36.733]                   if (TRUE) {
[10:59:36.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.733]                     {
[10:59:36.733]                       inherits <- base::inherits
[10:59:36.733]                       invokeRestart <- base::invokeRestart
[10:59:36.733]                       is.null <- base::is.null
[10:59:36.733]                       muffled <- FALSE
[10:59:36.733]                       if (inherits(cond, "message")) {
[10:59:36.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.733]                         if (muffled) 
[10:59:36.733]                           invokeRestart("muffleMessage")
[10:59:36.733]                       }
[10:59:36.733]                       else if (inherits(cond, "warning")) {
[10:59:36.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.733]                         if (muffled) 
[10:59:36.733]                           invokeRestart("muffleWarning")
[10:59:36.733]                       }
[10:59:36.733]                       else if (inherits(cond, "condition")) {
[10:59:36.733]                         if (!is.null(pattern)) {
[10:59:36.733]                           computeRestarts <- base::computeRestarts
[10:59:36.733]                           grepl <- base::grepl
[10:59:36.733]                           restarts <- computeRestarts(cond)
[10:59:36.733]                           for (restart in restarts) {
[10:59:36.733]                             name <- restart$name
[10:59:36.733]                             if (is.null(name)) 
[10:59:36.733]                               next
[10:59:36.733]                             if (!grepl(pattern, name)) 
[10:59:36.733]                               next
[10:59:36.733]                             invokeRestart(restart)
[10:59:36.733]                             muffled <- TRUE
[10:59:36.733]                             break
[10:59:36.733]                           }
[10:59:36.733]                         }
[10:59:36.733]                       }
[10:59:36.733]                       invisible(muffled)
[10:59:36.733]                     }
[10:59:36.733]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.733]                   }
[10:59:36.733]                 }
[10:59:36.733]             }
[10:59:36.733]         }))
[10:59:36.733]     }, error = function(ex) {
[10:59:36.733]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.733]                 ...future.rng), started = ...future.startTime, 
[10:59:36.733]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.733]             version = "1.8"), class = "FutureResult")
[10:59:36.733]     }, finally = {
[10:59:36.733]         if (!identical(...future.workdir, getwd())) 
[10:59:36.733]             setwd(...future.workdir)
[10:59:36.733]         {
[10:59:36.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.733]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.733]             }
[10:59:36.733]             base::options(...future.oldOptions)
[10:59:36.733]             if (.Platform$OS.type == "windows") {
[10:59:36.733]                 old_names <- names(...future.oldEnvVars)
[10:59:36.733]                 envs <- base::Sys.getenv()
[10:59:36.733]                 names <- names(envs)
[10:59:36.733]                 common <- intersect(names, old_names)
[10:59:36.733]                 added <- setdiff(names, old_names)
[10:59:36.733]                 removed <- setdiff(old_names, names)
[10:59:36.733]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.733]                   envs[common]]
[10:59:36.733]                 NAMES <- toupper(changed)
[10:59:36.733]                 args <- list()
[10:59:36.733]                 for (kk in seq_along(NAMES)) {
[10:59:36.733]                   name <- changed[[kk]]
[10:59:36.733]                   NAME <- NAMES[[kk]]
[10:59:36.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.733]                     next
[10:59:36.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.733]                 }
[10:59:36.733]                 NAMES <- toupper(added)
[10:59:36.733]                 for (kk in seq_along(NAMES)) {
[10:59:36.733]                   name <- added[[kk]]
[10:59:36.733]                   NAME <- NAMES[[kk]]
[10:59:36.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.733]                     next
[10:59:36.733]                   args[[name]] <- ""
[10:59:36.733]                 }
[10:59:36.733]                 NAMES <- toupper(removed)
[10:59:36.733]                 for (kk in seq_along(NAMES)) {
[10:59:36.733]                   name <- removed[[kk]]
[10:59:36.733]                   NAME <- NAMES[[kk]]
[10:59:36.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.733]                     next
[10:59:36.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.733]                 }
[10:59:36.733]                 if (length(args) > 0) 
[10:59:36.733]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.733]             }
[10:59:36.733]             else {
[10:59:36.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.733]             }
[10:59:36.733]             {
[10:59:36.733]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.733]                   0L) {
[10:59:36.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.733]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.733]                   base::options(opts)
[10:59:36.733]                 }
[10:59:36.733]                 {
[10:59:36.733]                   {
[10:59:36.733]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.733]                     NULL
[10:59:36.733]                   }
[10:59:36.733]                   options(future.plan = NULL)
[10:59:36.733]                   if (is.na(NA_character_)) 
[10:59:36.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.733]                     .init = FALSE)
[10:59:36.733]                 }
[10:59:36.733]             }
[10:59:36.733]         }
[10:59:36.733]     })
[10:59:36.733]     if (TRUE) {
[10:59:36.733]         base::sink(type = "output", split = FALSE)
[10:59:36.733]         if (TRUE) {
[10:59:36.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.733]         }
[10:59:36.733]         else {
[10:59:36.733]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.733]         }
[10:59:36.733]         base::close(...future.stdout)
[10:59:36.733]         ...future.stdout <- NULL
[10:59:36.733]     }
[10:59:36.733]     ...future.result$conditions <- ...future.conditions
[10:59:36.733]     ...future.result$finished <- base::Sys.time()
[10:59:36.733]     ...future.result
[10:59:36.733] }
[10:59:36.735] Exporting 5 global objects (1.09 KiB) to cluster node #2 ...
[10:59:36.735] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[10:59:36.736] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[10:59:36.736] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[10:59:36.736] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[10:59:36.736] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[10:59:36.737] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[10:59:36.737] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ...
[10:59:36.737] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ... DONE
[10:59:36.737] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:36.738] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.738] Exporting 5 global objects (1.09 KiB) to cluster node #2 ... DONE
[10:59:36.738] MultisessionFuture started
[10:59:36.739] - Launch lazy future ... done
[10:59:36.739] run() for ‘MultisessionFuture’ ... done
[10:59:36.739] Created future:
[10:59:36.739] MultisessionFuture:
[10:59:36.739] Label: ‘future_mapply-2’
[10:59:36.739] Expression:
[10:59:36.739] {
[10:59:36.739]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.739]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.739]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.739]         on.exit(options(oopts), add = TRUE)
[10:59:36.739]     }
[10:59:36.739]     {
[10:59:36.739]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:36.739]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:36.739]                 inherits = FALSE)
[10:59:36.739]             ...future.FUN(...)
[10:59:36.739]         }
[10:59:36.739]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:36.739]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:36.739]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.739]         do.call(mapply, args = args)
[10:59:36.739]     }
[10:59:36.739] }
[10:59:36.739] Lazy evaluation: FALSE
[10:59:36.739] Asynchronous evaluation: TRUE
[10:59:36.739] Local evaluation: TRUE
[10:59:36.739] Environment: R_GlobalEnv
[10:59:36.739] Capture standard output: TRUE
[10:59:36.739] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.739] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.739] Packages: <none>
[10:59:36.739] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:36.739] Resolved: FALSE
[10:59:36.739] Value: <not collected>
[10:59:36.739] Conditions captured: <none>
[10:59:36.739] Early signaling: FALSE
[10:59:36.739] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.739] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.750] Chunk #2 of 2 ... DONE
[10:59:36.750] Launching 2 futures (chunks) ... DONE
[10:59:36.750] Resolving 2 futures (chunks) ...
[10:59:36.751] resolve() on list ...
[10:59:36.751]  recursive: 0
[10:59:36.751]  length: 2
[10:59:36.751] 
[10:59:36.751] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.751] - Validating connection of MultisessionFuture
[10:59:36.753] - received message: FutureResult
[10:59:36.754] - Received FutureResult
[10:59:36.754] - Erased future from FutureRegistry
[10:59:36.754] result() for ClusterFuture ...
[10:59:36.754] - result already collected: FutureResult
[10:59:36.754] result() for ClusterFuture ... done
[10:59:36.754] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.754] Future #1
[10:59:36.754] result() for ClusterFuture ...
[10:59:36.754] - result already collected: FutureResult
[10:59:36.754] result() for ClusterFuture ... done
[10:59:36.755] result() for ClusterFuture ...
[10:59:36.755] - result already collected: FutureResult
[10:59:36.755] result() for ClusterFuture ... done
[10:59:36.755] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.755] - nx: 2
[10:59:36.755] - relay: TRUE
[10:59:36.755] - stdout: TRUE
[10:59:36.755] - signal: TRUE
[10:59:36.755] - resignal: FALSE
[10:59:36.755] - force: TRUE
[10:59:36.755] - relayed: [n=2] FALSE, FALSE
[10:59:36.755] - queued futures: [n=2] FALSE, FALSE
[10:59:36.755]  - until=1
[10:59:36.756]  - relaying element #1
[10:59:36.756] result() for ClusterFuture ...
[10:59:36.756] - result already collected: FutureResult
[10:59:36.756] result() for ClusterFuture ... done
[10:59:36.756] result() for ClusterFuture ...
[10:59:36.756] - result already collected: FutureResult
[10:59:36.756] result() for ClusterFuture ... done
[10:59:36.756] result() for ClusterFuture ...
[10:59:36.756] - result already collected: FutureResult
[10:59:36.756] result() for ClusterFuture ... done
[10:59:36.756] result() for ClusterFuture ...
[10:59:36.756] - result already collected: FutureResult
[10:59:36.756] result() for ClusterFuture ... done
[10:59:36.757] - relayed: [n=2] TRUE, FALSE
[10:59:36.757] - queued futures: [n=2] TRUE, FALSE
[10:59:36.757] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.757]  length: 1 (resolved future 1)
[10:59:36.780] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.780] - Validating connection of MultisessionFuture
[10:59:36.780] - received message: FutureResult
[10:59:36.781] - Received FutureResult
[10:59:36.781] - Erased future from FutureRegistry
[10:59:36.781] result() for ClusterFuture ...
[10:59:36.781] - result already collected: FutureResult
[10:59:36.781] result() for ClusterFuture ... done
[10:59:36.781] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.781] Future #2
[10:59:36.781] result() for ClusterFuture ...
[10:59:36.781] - result already collected: FutureResult
[10:59:36.781] result() for ClusterFuture ... done
[10:59:36.781] result() for ClusterFuture ...
[10:59:36.782] - result already collected: FutureResult
[10:59:36.782] result() for ClusterFuture ... done
[10:59:36.782] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:36.782] - nx: 2
[10:59:36.782] - relay: TRUE
[10:59:36.782] - stdout: TRUE
[10:59:36.782] - signal: TRUE
[10:59:36.782] - resignal: FALSE
[10:59:36.782] - force: TRUE
[10:59:36.782] - relayed: [n=2] TRUE, FALSE
[10:59:36.782] - queued futures: [n=2] TRUE, FALSE
[10:59:36.782]  - until=2
[10:59:36.782]  - relaying element #2
[10:59:36.783] result() for ClusterFuture ...
[10:59:36.783] - result already collected: FutureResult
[10:59:36.783] result() for ClusterFuture ... done
[10:59:36.783] result() for ClusterFuture ...
[10:59:36.783] - result already collected: FutureResult
[10:59:36.783] result() for ClusterFuture ... done
[10:59:36.783] result() for ClusterFuture ...
[10:59:36.783] - result already collected: FutureResult
[10:59:36.783] result() for ClusterFuture ... done
[10:59:36.783] result() for ClusterFuture ...
[10:59:36.783] - result already collected: FutureResult
[10:59:36.783] result() for ClusterFuture ... done
[10:59:36.784] - relayed: [n=2] TRUE, TRUE
[10:59:36.784] - queued futures: [n=2] TRUE, TRUE
[10:59:36.784] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:36.784]  length: 0 (resolved future 2)
[10:59:36.784] Relaying remaining futures
[10:59:36.784] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.784] - nx: 2
[10:59:36.784] - relay: TRUE
[10:59:36.784] - stdout: TRUE
[10:59:36.784] - signal: TRUE
[10:59:36.784] - resignal: FALSE
[10:59:36.784] - force: TRUE
[10:59:36.784] - relayed: [n=2] TRUE, TRUE
[10:59:36.784] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:36.785] - relayed: [n=2] TRUE, TRUE
[10:59:36.785] - queued futures: [n=2] TRUE, TRUE
[10:59:36.785] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.785] resolve() on list ... DONE
[10:59:36.785] result() for ClusterFuture ...
[10:59:36.785] - result already collected: FutureResult
[10:59:36.785] result() for ClusterFuture ... done
[10:59:36.785] result() for ClusterFuture ...
[10:59:36.785] - result already collected: FutureResult
[10:59:36.785] result() for ClusterFuture ... done
[10:59:36.785] result() for ClusterFuture ...
[10:59:36.786] - result already collected: FutureResult
[10:59:36.786] result() for ClusterFuture ... done
[10:59:36.786] result() for ClusterFuture ...
[10:59:36.786] - result already collected: FutureResult
[10:59:36.786] result() for ClusterFuture ... done
[10:59:36.786]  - Number of value chunks collected: 2
[10:59:36.786] Resolving 2 futures (chunks) ... DONE
[10:59:36.786] Reducing values from 2 chunks ...
[10:59:36.786]  - Number of values collected after concatenation: 2
[10:59:36.786]  - Number of values expected: 2
[10:59:36.786] Reducing values from 2 chunks ... DONE
[10:59:36.786] future_mapply() ... DONE
[10:59:36.787] future_mapply() ...
[10:59:36.788] Number of chunks: 2
[10:59:36.788] getGlobalsAndPackagesXApply() ...
[10:59:36.788]  - future.globals: TRUE
[10:59:36.788] getGlobalsAndPackages() ...
[10:59:36.788] Searching for globals...
[10:59:36.789] - globals found: [1] ‘FUN’
[10:59:36.789] Searching for globals ... DONE
[10:59:36.789] Resolving globals: FALSE
[10:59:36.790] The total size of the 1 globals is 326 bytes (326 bytes)
[10:59:36.790] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:59:36.790] - globals: [1] ‘FUN’
[10:59:36.790] 
[10:59:36.790] getGlobalsAndPackages() ... DONE
[10:59:36.790]  - globals found/used: [n=1] ‘FUN’
[10:59:36.790]  - needed namespaces: [n=0] 
[10:59:36.791] Finding globals ... DONE
[10:59:36.791] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.791] List of 2
[10:59:36.791]  $ ...future.FUN:function (x, y)  
[10:59:36.791]  $ MoreArgs     :List of 1
[10:59:36.791]   ..$ y: int [1:2] 3 4
[10:59:36.791]  - attr(*, "where")=List of 2
[10:59:36.791]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.791]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.791]  - attr(*, "resolved")= logi FALSE
[10:59:36.791]  - attr(*, "total_size")= num NA
[10:59:36.793] Packages to be attached in all futures: [n=0] 
[10:59:36.794] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.794] Number of futures (= number of chunks): 2
[10:59:36.794] Launching 2 futures (chunks) ...
[10:59:36.794] Chunk #1 of 2 ...
[10:59:36.794]  - Finding globals in '...' for chunk #1 ...
[10:59:36.794] getGlobalsAndPackages() ...
[10:59:36.794] Searching for globals...
[10:59:36.794] 
[10:59:36.795] Searching for globals ... DONE
[10:59:36.795] - globals: [0] <none>
[10:59:36.795] getGlobalsAndPackages() ... DONE
[10:59:36.795]    + additional globals found: [n=0] 
[10:59:36.795]    + additional namespaces needed: [n=0] 
[10:59:36.795]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.795]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.795]  - seeds: <none>
[10:59:36.795]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.795] getGlobalsAndPackages() ...
[10:59:36.795] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.795] Resolving globals: FALSE
[10:59:36.796] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:36.796] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:36.796] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.796] 
[10:59:36.797] getGlobalsAndPackages() ... DONE
[10:59:36.797] run() for ‘Future’ ...
[10:59:36.797] - state: ‘created’
[10:59:36.797] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.811] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.812]   - Field: ‘node’
[10:59:36.812]   - Field: ‘label’
[10:59:36.812]   - Field: ‘local’
[10:59:36.812]   - Field: ‘owner’
[10:59:36.812]   - Field: ‘envir’
[10:59:36.812]   - Field: ‘workers’
[10:59:36.812]   - Field: ‘packages’
[10:59:36.812]   - Field: ‘gc’
[10:59:36.812]   - Field: ‘conditions’
[10:59:36.813]   - Field: ‘persistent’
[10:59:36.813]   - Field: ‘expr’
[10:59:36.813]   - Field: ‘uuid’
[10:59:36.813]   - Field: ‘seed’
[10:59:36.813]   - Field: ‘version’
[10:59:36.813]   - Field: ‘result’
[10:59:36.813]   - Field: ‘asynchronous’
[10:59:36.813]   - Field: ‘calls’
[10:59:36.813]   - Field: ‘globals’
[10:59:36.813]   - Field: ‘stdout’
[10:59:36.813]   - Field: ‘earlySignal’
[10:59:36.813]   - Field: ‘lazy’
[10:59:36.813]   - Field: ‘state’
[10:59:36.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.814] - Launch lazy future ...
[10:59:36.814] Packages needed by the future expression (n = 0): <none>
[10:59:36.814] Packages needed by future strategies (n = 0): <none>
[10:59:36.814] {
[10:59:36.814]     {
[10:59:36.814]         {
[10:59:36.814]             ...future.startTime <- base::Sys.time()
[10:59:36.814]             {
[10:59:36.814]                 {
[10:59:36.814]                   {
[10:59:36.814]                     {
[10:59:36.814]                       base::local({
[10:59:36.814]                         has_future <- base::requireNamespace("future", 
[10:59:36.814]                           quietly = TRUE)
[10:59:36.814]                         if (has_future) {
[10:59:36.814]                           ns <- base::getNamespace("future")
[10:59:36.814]                           version <- ns[[".package"]][["version"]]
[10:59:36.814]                           if (is.null(version)) 
[10:59:36.814]                             version <- utils::packageVersion("future")
[10:59:36.814]                         }
[10:59:36.814]                         else {
[10:59:36.814]                           version <- NULL
[10:59:36.814]                         }
[10:59:36.814]                         if (!has_future || version < "1.8.0") {
[10:59:36.814]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.814]                             "", base::R.version$version.string), 
[10:59:36.814]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.814]                               "release", "version")], collapse = " "), 
[10:59:36.814]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.814]                             info)
[10:59:36.814]                           info <- base::paste(info, collapse = "; ")
[10:59:36.814]                           if (!has_future) {
[10:59:36.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.814]                               info)
[10:59:36.814]                           }
[10:59:36.814]                           else {
[10:59:36.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.814]                               info, version)
[10:59:36.814]                           }
[10:59:36.814]                           base::stop(msg)
[10:59:36.814]                         }
[10:59:36.814]                       })
[10:59:36.814]                     }
[10:59:36.814]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.814]                     base::options(mc.cores = 1L)
[10:59:36.814]                   }
[10:59:36.814]                   ...future.strategy.old <- future::plan("list")
[10:59:36.814]                   options(future.plan = NULL)
[10:59:36.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.814]                 }
[10:59:36.814]                 ...future.workdir <- getwd()
[10:59:36.814]             }
[10:59:36.814]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.814]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.814]         }
[10:59:36.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.814]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.814]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.814]             base::names(...future.oldOptions))
[10:59:36.814]     }
[10:59:36.814]     if (FALSE) {
[10:59:36.814]     }
[10:59:36.814]     else {
[10:59:36.814]         if (TRUE) {
[10:59:36.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.814]                 open = "w")
[10:59:36.814]         }
[10:59:36.814]         else {
[10:59:36.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.814]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.814]         }
[10:59:36.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.814]             base::sink(type = "output", split = FALSE)
[10:59:36.814]             base::close(...future.stdout)
[10:59:36.814]         }, add = TRUE)
[10:59:36.814]     }
[10:59:36.814]     ...future.frame <- base::sys.nframe()
[10:59:36.814]     ...future.conditions <- base::list()
[10:59:36.814]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.814]     if (FALSE) {
[10:59:36.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.814]     }
[10:59:36.814]     ...future.result <- base::tryCatch({
[10:59:36.814]         base::withCallingHandlers({
[10:59:36.814]             ...future.value <- base::withVisible(base::local({
[10:59:36.814]                 ...future.makeSendCondition <- base::local({
[10:59:36.814]                   sendCondition <- NULL
[10:59:36.814]                   function(frame = 1L) {
[10:59:36.814]                     if (is.function(sendCondition)) 
[10:59:36.814]                       return(sendCondition)
[10:59:36.814]                     ns <- getNamespace("parallel")
[10:59:36.814]                     if (exists("sendData", mode = "function", 
[10:59:36.814]                       envir = ns)) {
[10:59:36.814]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.814]                         envir = ns)
[10:59:36.814]                       envir <- sys.frame(frame)
[10:59:36.814]                       master <- NULL
[10:59:36.814]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.814]                         !identical(envir, emptyenv())) {
[10:59:36.814]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.814]                           inherits = FALSE)) {
[10:59:36.814]                           master <- get("master", mode = "list", 
[10:59:36.814]                             envir = envir, inherits = FALSE)
[10:59:36.814]                           if (inherits(master, c("SOCKnode", 
[10:59:36.814]                             "SOCK0node"))) {
[10:59:36.814]                             sendCondition <<- function(cond) {
[10:59:36.814]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.814]                                 success = TRUE)
[10:59:36.814]                               parallel_sendData(master, data)
[10:59:36.814]                             }
[10:59:36.814]                             return(sendCondition)
[10:59:36.814]                           }
[10:59:36.814]                         }
[10:59:36.814]                         frame <- frame + 1L
[10:59:36.814]                         envir <- sys.frame(frame)
[10:59:36.814]                       }
[10:59:36.814]                     }
[10:59:36.814]                     sendCondition <<- function(cond) NULL
[10:59:36.814]                   }
[10:59:36.814]                 })
[10:59:36.814]                 withCallingHandlers({
[10:59:36.814]                   {
[10:59:36.814]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.814]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.814]                       ...future.globals.maxSize)) {
[10:59:36.814]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.814]                       on.exit(options(oopts), add = TRUE)
[10:59:36.814]                     }
[10:59:36.814]                     {
[10:59:36.814]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.814]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.814]                         USE.NAMES = FALSE)
[10:59:36.814]                       do.call(mapply, args = args)
[10:59:36.814]                     }
[10:59:36.814]                   }
[10:59:36.814]                 }, immediateCondition = function(cond) {
[10:59:36.814]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.814]                   sendCondition(cond)
[10:59:36.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.814]                   {
[10:59:36.814]                     inherits <- base::inherits
[10:59:36.814]                     invokeRestart <- base::invokeRestart
[10:59:36.814]                     is.null <- base::is.null
[10:59:36.814]                     muffled <- FALSE
[10:59:36.814]                     if (inherits(cond, "message")) {
[10:59:36.814]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.814]                       if (muffled) 
[10:59:36.814]                         invokeRestart("muffleMessage")
[10:59:36.814]                     }
[10:59:36.814]                     else if (inherits(cond, "warning")) {
[10:59:36.814]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.814]                       if (muffled) 
[10:59:36.814]                         invokeRestart("muffleWarning")
[10:59:36.814]                     }
[10:59:36.814]                     else if (inherits(cond, "condition")) {
[10:59:36.814]                       if (!is.null(pattern)) {
[10:59:36.814]                         computeRestarts <- base::computeRestarts
[10:59:36.814]                         grepl <- base::grepl
[10:59:36.814]                         restarts <- computeRestarts(cond)
[10:59:36.814]                         for (restart in restarts) {
[10:59:36.814]                           name <- restart$name
[10:59:36.814]                           if (is.null(name)) 
[10:59:36.814]                             next
[10:59:36.814]                           if (!grepl(pattern, name)) 
[10:59:36.814]                             next
[10:59:36.814]                           invokeRestart(restart)
[10:59:36.814]                           muffled <- TRUE
[10:59:36.814]                           break
[10:59:36.814]                         }
[10:59:36.814]                       }
[10:59:36.814]                     }
[10:59:36.814]                     invisible(muffled)
[10:59:36.814]                   }
[10:59:36.814]                   muffleCondition(cond)
[10:59:36.814]                 })
[10:59:36.814]             }))
[10:59:36.814]             future::FutureResult(value = ...future.value$value, 
[10:59:36.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.814]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.814]                     ...future.globalenv.names))
[10:59:36.814]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.814]         }, condition = base::local({
[10:59:36.814]             c <- base::c
[10:59:36.814]             inherits <- base::inherits
[10:59:36.814]             invokeRestart <- base::invokeRestart
[10:59:36.814]             length <- base::length
[10:59:36.814]             list <- base::list
[10:59:36.814]             seq.int <- base::seq.int
[10:59:36.814]             signalCondition <- base::signalCondition
[10:59:36.814]             sys.calls <- base::sys.calls
[10:59:36.814]             `[[` <- base::`[[`
[10:59:36.814]             `+` <- base::`+`
[10:59:36.814]             `<<-` <- base::`<<-`
[10:59:36.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.814]                   3L)]
[10:59:36.814]             }
[10:59:36.814]             function(cond) {
[10:59:36.814]                 is_error <- inherits(cond, "error")
[10:59:36.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.814]                   NULL)
[10:59:36.814]                 if (is_error) {
[10:59:36.814]                   sessionInformation <- function() {
[10:59:36.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.814]                       search = base::search(), system = base::Sys.info())
[10:59:36.814]                   }
[10:59:36.814]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.814]                     cond$call), session = sessionInformation(), 
[10:59:36.814]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.814]                   signalCondition(cond)
[10:59:36.814]                 }
[10:59:36.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.814]                 "immediateCondition"))) {
[10:59:36.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.814]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.814]                   if (TRUE && !signal) {
[10:59:36.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.814]                     {
[10:59:36.814]                       inherits <- base::inherits
[10:59:36.814]                       invokeRestart <- base::invokeRestart
[10:59:36.814]                       is.null <- base::is.null
[10:59:36.814]                       muffled <- FALSE
[10:59:36.814]                       if (inherits(cond, "message")) {
[10:59:36.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.814]                         if (muffled) 
[10:59:36.814]                           invokeRestart("muffleMessage")
[10:59:36.814]                       }
[10:59:36.814]                       else if (inherits(cond, "warning")) {
[10:59:36.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.814]                         if (muffled) 
[10:59:36.814]                           invokeRestart("muffleWarning")
[10:59:36.814]                       }
[10:59:36.814]                       else if (inherits(cond, "condition")) {
[10:59:36.814]                         if (!is.null(pattern)) {
[10:59:36.814]                           computeRestarts <- base::computeRestarts
[10:59:36.814]                           grepl <- base::grepl
[10:59:36.814]                           restarts <- computeRestarts(cond)
[10:59:36.814]                           for (restart in restarts) {
[10:59:36.814]                             name <- restart$name
[10:59:36.814]                             if (is.null(name)) 
[10:59:36.814]                               next
[10:59:36.814]                             if (!grepl(pattern, name)) 
[10:59:36.814]                               next
[10:59:36.814]                             invokeRestart(restart)
[10:59:36.814]                             muffled <- TRUE
[10:59:36.814]                             break
[10:59:36.814]                           }
[10:59:36.814]                         }
[10:59:36.814]                       }
[10:59:36.814]                       invisible(muffled)
[10:59:36.814]                     }
[10:59:36.814]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.814]                   }
[10:59:36.814]                 }
[10:59:36.814]                 else {
[10:59:36.814]                   if (TRUE) {
[10:59:36.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.814]                     {
[10:59:36.814]                       inherits <- base::inherits
[10:59:36.814]                       invokeRestart <- base::invokeRestart
[10:59:36.814]                       is.null <- base::is.null
[10:59:36.814]                       muffled <- FALSE
[10:59:36.814]                       if (inherits(cond, "message")) {
[10:59:36.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.814]                         if (muffled) 
[10:59:36.814]                           invokeRestart("muffleMessage")
[10:59:36.814]                       }
[10:59:36.814]                       else if (inherits(cond, "warning")) {
[10:59:36.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.814]                         if (muffled) 
[10:59:36.814]                           invokeRestart("muffleWarning")
[10:59:36.814]                       }
[10:59:36.814]                       else if (inherits(cond, "condition")) {
[10:59:36.814]                         if (!is.null(pattern)) {
[10:59:36.814]                           computeRestarts <- base::computeRestarts
[10:59:36.814]                           grepl <- base::grepl
[10:59:36.814]                           restarts <- computeRestarts(cond)
[10:59:36.814]                           for (restart in restarts) {
[10:59:36.814]                             name <- restart$name
[10:59:36.814]                             if (is.null(name)) 
[10:59:36.814]                               next
[10:59:36.814]                             if (!grepl(pattern, name)) 
[10:59:36.814]                               next
[10:59:36.814]                             invokeRestart(restart)
[10:59:36.814]                             muffled <- TRUE
[10:59:36.814]                             break
[10:59:36.814]                           }
[10:59:36.814]                         }
[10:59:36.814]                       }
[10:59:36.814]                       invisible(muffled)
[10:59:36.814]                     }
[10:59:36.814]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.814]                   }
[10:59:36.814]                 }
[10:59:36.814]             }
[10:59:36.814]         }))
[10:59:36.814]     }, error = function(ex) {
[10:59:36.814]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.814]                 ...future.rng), started = ...future.startTime, 
[10:59:36.814]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.814]             version = "1.8"), class = "FutureResult")
[10:59:36.814]     }, finally = {
[10:59:36.814]         if (!identical(...future.workdir, getwd())) 
[10:59:36.814]             setwd(...future.workdir)
[10:59:36.814]         {
[10:59:36.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.814]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.814]             }
[10:59:36.814]             base::options(...future.oldOptions)
[10:59:36.814]             if (.Platform$OS.type == "windows") {
[10:59:36.814]                 old_names <- names(...future.oldEnvVars)
[10:59:36.814]                 envs <- base::Sys.getenv()
[10:59:36.814]                 names <- names(envs)
[10:59:36.814]                 common <- intersect(names, old_names)
[10:59:36.814]                 added <- setdiff(names, old_names)
[10:59:36.814]                 removed <- setdiff(old_names, names)
[10:59:36.814]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.814]                   envs[common]]
[10:59:36.814]                 NAMES <- toupper(changed)
[10:59:36.814]                 args <- list()
[10:59:36.814]                 for (kk in seq_along(NAMES)) {
[10:59:36.814]                   name <- changed[[kk]]
[10:59:36.814]                   NAME <- NAMES[[kk]]
[10:59:36.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.814]                     next
[10:59:36.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.814]                 }
[10:59:36.814]                 NAMES <- toupper(added)
[10:59:36.814]                 for (kk in seq_along(NAMES)) {
[10:59:36.814]                   name <- added[[kk]]
[10:59:36.814]                   NAME <- NAMES[[kk]]
[10:59:36.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.814]                     next
[10:59:36.814]                   args[[name]] <- ""
[10:59:36.814]                 }
[10:59:36.814]                 NAMES <- toupper(removed)
[10:59:36.814]                 for (kk in seq_along(NAMES)) {
[10:59:36.814]                   name <- removed[[kk]]
[10:59:36.814]                   NAME <- NAMES[[kk]]
[10:59:36.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.814]                     next
[10:59:36.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.814]                 }
[10:59:36.814]                 if (length(args) > 0) 
[10:59:36.814]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.814]             }
[10:59:36.814]             else {
[10:59:36.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.814]             }
[10:59:36.814]             {
[10:59:36.814]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.814]                   0L) {
[10:59:36.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.814]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.814]                   base::options(opts)
[10:59:36.814]                 }
[10:59:36.814]                 {
[10:59:36.814]                   {
[10:59:36.814]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.814]                     NULL
[10:59:36.814]                   }
[10:59:36.814]                   options(future.plan = NULL)
[10:59:36.814]                   if (is.na(NA_character_)) 
[10:59:36.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.814]                     .init = FALSE)
[10:59:36.814]                 }
[10:59:36.814]             }
[10:59:36.814]         }
[10:59:36.814]     })
[10:59:36.814]     if (TRUE) {
[10:59:36.814]         base::sink(type = "output", split = FALSE)
[10:59:36.814]         if (TRUE) {
[10:59:36.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.814]         }
[10:59:36.814]         else {
[10:59:36.814]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.814]         }
[10:59:36.814]         base::close(...future.stdout)
[10:59:36.814]         ...future.stdout <- NULL
[10:59:36.814]     }
[10:59:36.814]     ...future.result$conditions <- ...future.conditions
[10:59:36.814]     ...future.result$finished <- base::Sys.time()
[10:59:36.814]     ...future.result
[10:59:36.814] }
[10:59:36.817] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[10:59:36.817] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[10:59:36.817] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[10:59:36.818] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[10:59:36.818] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[10:59:36.818] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[10:59:36.818] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[10:59:36.819] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.819] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.819] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.819] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.820] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[10:59:36.820] MultisessionFuture started
[10:59:36.820] - Launch lazy future ... done
[10:59:36.820] run() for ‘MultisessionFuture’ ... done
[10:59:36.820] Created future:
[10:59:36.820] MultisessionFuture:
[10:59:36.820] Label: ‘future_.mapply-1’
[10:59:36.820] Expression:
[10:59:36.820] {
[10:59:36.820]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.820]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.820]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.820]         on.exit(options(oopts), add = TRUE)
[10:59:36.820]     }
[10:59:36.820]     {
[10:59:36.820]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.820]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.820]         do.call(mapply, args = args)
[10:59:36.820]     }
[10:59:36.820] }
[10:59:36.820] Lazy evaluation: FALSE
[10:59:36.820] Asynchronous evaluation: TRUE
[10:59:36.820] Local evaluation: TRUE
[10:59:36.820] Environment: R_GlobalEnv
[10:59:36.820] Capture standard output: TRUE
[10:59:36.820] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.820] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.820] Packages: <none>
[10:59:36.820] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.820] Resolved: FALSE
[10:59:36.820] Value: <not collected>
[10:59:36.820] Conditions captured: <none>
[10:59:36.820] Early signaling: FALSE
[10:59:36.820] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.820] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.832] Chunk #1 of 2 ... DONE
[10:59:36.832] Chunk #2 of 2 ...
[10:59:36.832]  - Finding globals in '...' for chunk #2 ...
[10:59:36.832] getGlobalsAndPackages() ...
[10:59:36.832] Searching for globals...
[10:59:36.833] 
[10:59:36.833] Searching for globals ... DONE
[10:59:36.833] - globals: [0] <none>
[10:59:36.833] getGlobalsAndPackages() ... DONE
[10:59:36.833]    + additional globals found: [n=0] 
[10:59:36.833]    + additional namespaces needed: [n=0] 
[10:59:36.833]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:36.833]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.833]  - seeds: <none>
[10:59:36.833]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.833] getGlobalsAndPackages() ...
[10:59:36.833] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.834] Resolving globals: FALSE
[10:59:36.834] The total size of the 5 globals is 656 bytes (656 bytes)
[10:59:36.834] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:59:36.834] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.835] 
[10:59:36.835] getGlobalsAndPackages() ... DONE
[10:59:36.835] run() for ‘Future’ ...
[10:59:36.835] - state: ‘created’
[10:59:36.835] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.848] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.849]   - Field: ‘node’
[10:59:36.849]   - Field: ‘label’
[10:59:36.849]   - Field: ‘local’
[10:59:36.849]   - Field: ‘owner’
[10:59:36.849]   - Field: ‘envir’
[10:59:36.849]   - Field: ‘workers’
[10:59:36.849]   - Field: ‘packages’
[10:59:36.849]   - Field: ‘gc’
[10:59:36.849]   - Field: ‘conditions’
[10:59:36.849]   - Field: ‘persistent’
[10:59:36.850]   - Field: ‘expr’
[10:59:36.850]   - Field: ‘uuid’
[10:59:36.850]   - Field: ‘seed’
[10:59:36.850]   - Field: ‘version’
[10:59:36.850]   - Field: ‘result’
[10:59:36.850]   - Field: ‘asynchronous’
[10:59:36.850]   - Field: ‘calls’
[10:59:36.850]   - Field: ‘globals’
[10:59:36.850]   - Field: ‘stdout’
[10:59:36.850]   - Field: ‘earlySignal’
[10:59:36.850]   - Field: ‘lazy’
[10:59:36.850]   - Field: ‘state’
[10:59:36.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.851] - Launch lazy future ...
[10:59:36.851] Packages needed by the future expression (n = 0): <none>
[10:59:36.851] Packages needed by future strategies (n = 0): <none>
[10:59:36.851] {
[10:59:36.851]     {
[10:59:36.851]         {
[10:59:36.851]             ...future.startTime <- base::Sys.time()
[10:59:36.851]             {
[10:59:36.851]                 {
[10:59:36.851]                   {
[10:59:36.851]                     {
[10:59:36.851]                       base::local({
[10:59:36.851]                         has_future <- base::requireNamespace("future", 
[10:59:36.851]                           quietly = TRUE)
[10:59:36.851]                         if (has_future) {
[10:59:36.851]                           ns <- base::getNamespace("future")
[10:59:36.851]                           version <- ns[[".package"]][["version"]]
[10:59:36.851]                           if (is.null(version)) 
[10:59:36.851]                             version <- utils::packageVersion("future")
[10:59:36.851]                         }
[10:59:36.851]                         else {
[10:59:36.851]                           version <- NULL
[10:59:36.851]                         }
[10:59:36.851]                         if (!has_future || version < "1.8.0") {
[10:59:36.851]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.851]                             "", base::R.version$version.string), 
[10:59:36.851]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.851]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.851]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.851]                               "release", "version")], collapse = " "), 
[10:59:36.851]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.851]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.851]                             info)
[10:59:36.851]                           info <- base::paste(info, collapse = "; ")
[10:59:36.851]                           if (!has_future) {
[10:59:36.851]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.851]                               info)
[10:59:36.851]                           }
[10:59:36.851]                           else {
[10:59:36.851]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.851]                               info, version)
[10:59:36.851]                           }
[10:59:36.851]                           base::stop(msg)
[10:59:36.851]                         }
[10:59:36.851]                       })
[10:59:36.851]                     }
[10:59:36.851]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.851]                     base::options(mc.cores = 1L)
[10:59:36.851]                   }
[10:59:36.851]                   ...future.strategy.old <- future::plan("list")
[10:59:36.851]                   options(future.plan = NULL)
[10:59:36.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.851]                 }
[10:59:36.851]                 ...future.workdir <- getwd()
[10:59:36.851]             }
[10:59:36.851]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.851]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.851]         }
[10:59:36.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.851]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.851]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.851]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.851]             base::names(...future.oldOptions))
[10:59:36.851]     }
[10:59:36.851]     if (FALSE) {
[10:59:36.851]     }
[10:59:36.851]     else {
[10:59:36.851]         if (TRUE) {
[10:59:36.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.851]                 open = "w")
[10:59:36.851]         }
[10:59:36.851]         else {
[10:59:36.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.851]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.851]         }
[10:59:36.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.851]             base::sink(type = "output", split = FALSE)
[10:59:36.851]             base::close(...future.stdout)
[10:59:36.851]         }, add = TRUE)
[10:59:36.851]     }
[10:59:36.851]     ...future.frame <- base::sys.nframe()
[10:59:36.851]     ...future.conditions <- base::list()
[10:59:36.851]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.851]     if (FALSE) {
[10:59:36.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.851]     }
[10:59:36.851]     ...future.result <- base::tryCatch({
[10:59:36.851]         base::withCallingHandlers({
[10:59:36.851]             ...future.value <- base::withVisible(base::local({
[10:59:36.851]                 ...future.makeSendCondition <- base::local({
[10:59:36.851]                   sendCondition <- NULL
[10:59:36.851]                   function(frame = 1L) {
[10:59:36.851]                     if (is.function(sendCondition)) 
[10:59:36.851]                       return(sendCondition)
[10:59:36.851]                     ns <- getNamespace("parallel")
[10:59:36.851]                     if (exists("sendData", mode = "function", 
[10:59:36.851]                       envir = ns)) {
[10:59:36.851]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.851]                         envir = ns)
[10:59:36.851]                       envir <- sys.frame(frame)
[10:59:36.851]                       master <- NULL
[10:59:36.851]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.851]                         !identical(envir, emptyenv())) {
[10:59:36.851]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.851]                           inherits = FALSE)) {
[10:59:36.851]                           master <- get("master", mode = "list", 
[10:59:36.851]                             envir = envir, inherits = FALSE)
[10:59:36.851]                           if (inherits(master, c("SOCKnode", 
[10:59:36.851]                             "SOCK0node"))) {
[10:59:36.851]                             sendCondition <<- function(cond) {
[10:59:36.851]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.851]                                 success = TRUE)
[10:59:36.851]                               parallel_sendData(master, data)
[10:59:36.851]                             }
[10:59:36.851]                             return(sendCondition)
[10:59:36.851]                           }
[10:59:36.851]                         }
[10:59:36.851]                         frame <- frame + 1L
[10:59:36.851]                         envir <- sys.frame(frame)
[10:59:36.851]                       }
[10:59:36.851]                     }
[10:59:36.851]                     sendCondition <<- function(cond) NULL
[10:59:36.851]                   }
[10:59:36.851]                 })
[10:59:36.851]                 withCallingHandlers({
[10:59:36.851]                   {
[10:59:36.851]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.851]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.851]                       ...future.globals.maxSize)) {
[10:59:36.851]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.851]                       on.exit(options(oopts), add = TRUE)
[10:59:36.851]                     }
[10:59:36.851]                     {
[10:59:36.851]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.851]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.851]                         USE.NAMES = FALSE)
[10:59:36.851]                       do.call(mapply, args = args)
[10:59:36.851]                     }
[10:59:36.851]                   }
[10:59:36.851]                 }, immediateCondition = function(cond) {
[10:59:36.851]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.851]                   sendCondition(cond)
[10:59:36.851]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.851]                   {
[10:59:36.851]                     inherits <- base::inherits
[10:59:36.851]                     invokeRestart <- base::invokeRestart
[10:59:36.851]                     is.null <- base::is.null
[10:59:36.851]                     muffled <- FALSE
[10:59:36.851]                     if (inherits(cond, "message")) {
[10:59:36.851]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.851]                       if (muffled) 
[10:59:36.851]                         invokeRestart("muffleMessage")
[10:59:36.851]                     }
[10:59:36.851]                     else if (inherits(cond, "warning")) {
[10:59:36.851]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.851]                       if (muffled) 
[10:59:36.851]                         invokeRestart("muffleWarning")
[10:59:36.851]                     }
[10:59:36.851]                     else if (inherits(cond, "condition")) {
[10:59:36.851]                       if (!is.null(pattern)) {
[10:59:36.851]                         computeRestarts <- base::computeRestarts
[10:59:36.851]                         grepl <- base::grepl
[10:59:36.851]                         restarts <- computeRestarts(cond)
[10:59:36.851]                         for (restart in restarts) {
[10:59:36.851]                           name <- restart$name
[10:59:36.851]                           if (is.null(name)) 
[10:59:36.851]                             next
[10:59:36.851]                           if (!grepl(pattern, name)) 
[10:59:36.851]                             next
[10:59:36.851]                           invokeRestart(restart)
[10:59:36.851]                           muffled <- TRUE
[10:59:36.851]                           break
[10:59:36.851]                         }
[10:59:36.851]                       }
[10:59:36.851]                     }
[10:59:36.851]                     invisible(muffled)
[10:59:36.851]                   }
[10:59:36.851]                   muffleCondition(cond)
[10:59:36.851]                 })
[10:59:36.851]             }))
[10:59:36.851]             future::FutureResult(value = ...future.value$value, 
[10:59:36.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.851]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.851]                     ...future.globalenv.names))
[10:59:36.851]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.851]         }, condition = base::local({
[10:59:36.851]             c <- base::c
[10:59:36.851]             inherits <- base::inherits
[10:59:36.851]             invokeRestart <- base::invokeRestart
[10:59:36.851]             length <- base::length
[10:59:36.851]             list <- base::list
[10:59:36.851]             seq.int <- base::seq.int
[10:59:36.851]             signalCondition <- base::signalCondition
[10:59:36.851]             sys.calls <- base::sys.calls
[10:59:36.851]             `[[` <- base::`[[`
[10:59:36.851]             `+` <- base::`+`
[10:59:36.851]             `<<-` <- base::`<<-`
[10:59:36.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.851]                   3L)]
[10:59:36.851]             }
[10:59:36.851]             function(cond) {
[10:59:36.851]                 is_error <- inherits(cond, "error")
[10:59:36.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.851]                   NULL)
[10:59:36.851]                 if (is_error) {
[10:59:36.851]                   sessionInformation <- function() {
[10:59:36.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.851]                       search = base::search(), system = base::Sys.info())
[10:59:36.851]                   }
[10:59:36.851]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.851]                     cond$call), session = sessionInformation(), 
[10:59:36.851]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.851]                   signalCondition(cond)
[10:59:36.851]                 }
[10:59:36.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.851]                 "immediateCondition"))) {
[10:59:36.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.851]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.851]                   if (TRUE && !signal) {
[10:59:36.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.851]                     {
[10:59:36.851]                       inherits <- base::inherits
[10:59:36.851]                       invokeRestart <- base::invokeRestart
[10:59:36.851]                       is.null <- base::is.null
[10:59:36.851]                       muffled <- FALSE
[10:59:36.851]                       if (inherits(cond, "message")) {
[10:59:36.851]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.851]                         if (muffled) 
[10:59:36.851]                           invokeRestart("muffleMessage")
[10:59:36.851]                       }
[10:59:36.851]                       else if (inherits(cond, "warning")) {
[10:59:36.851]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.851]                         if (muffled) 
[10:59:36.851]                           invokeRestart("muffleWarning")
[10:59:36.851]                       }
[10:59:36.851]                       else if (inherits(cond, "condition")) {
[10:59:36.851]                         if (!is.null(pattern)) {
[10:59:36.851]                           computeRestarts <- base::computeRestarts
[10:59:36.851]                           grepl <- base::grepl
[10:59:36.851]                           restarts <- computeRestarts(cond)
[10:59:36.851]                           for (restart in restarts) {
[10:59:36.851]                             name <- restart$name
[10:59:36.851]                             if (is.null(name)) 
[10:59:36.851]                               next
[10:59:36.851]                             if (!grepl(pattern, name)) 
[10:59:36.851]                               next
[10:59:36.851]                             invokeRestart(restart)
[10:59:36.851]                             muffled <- TRUE
[10:59:36.851]                             break
[10:59:36.851]                           }
[10:59:36.851]                         }
[10:59:36.851]                       }
[10:59:36.851]                       invisible(muffled)
[10:59:36.851]                     }
[10:59:36.851]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.851]                   }
[10:59:36.851]                 }
[10:59:36.851]                 else {
[10:59:36.851]                   if (TRUE) {
[10:59:36.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.851]                     {
[10:59:36.851]                       inherits <- base::inherits
[10:59:36.851]                       invokeRestart <- base::invokeRestart
[10:59:36.851]                       is.null <- base::is.null
[10:59:36.851]                       muffled <- FALSE
[10:59:36.851]                       if (inherits(cond, "message")) {
[10:59:36.851]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.851]                         if (muffled) 
[10:59:36.851]                           invokeRestart("muffleMessage")
[10:59:36.851]                       }
[10:59:36.851]                       else if (inherits(cond, "warning")) {
[10:59:36.851]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.851]                         if (muffled) 
[10:59:36.851]                           invokeRestart("muffleWarning")
[10:59:36.851]                       }
[10:59:36.851]                       else if (inherits(cond, "condition")) {
[10:59:36.851]                         if (!is.null(pattern)) {
[10:59:36.851]                           computeRestarts <- base::computeRestarts
[10:59:36.851]                           grepl <- base::grepl
[10:59:36.851]                           restarts <- computeRestarts(cond)
[10:59:36.851]                           for (restart in restarts) {
[10:59:36.851]                             name <- restart$name
[10:59:36.851]                             if (is.null(name)) 
[10:59:36.851]                               next
[10:59:36.851]                             if (!grepl(pattern, name)) 
[10:59:36.851]                               next
[10:59:36.851]                             invokeRestart(restart)
[10:59:36.851]                             muffled <- TRUE
[10:59:36.851]                             break
[10:59:36.851]                           }
[10:59:36.851]                         }
[10:59:36.851]                       }
[10:59:36.851]                       invisible(muffled)
[10:59:36.851]                     }
[10:59:36.851]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.851]                   }
[10:59:36.851]                 }
[10:59:36.851]             }
[10:59:36.851]         }))
[10:59:36.851]     }, error = function(ex) {
[10:59:36.851]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.851]                 ...future.rng), started = ...future.startTime, 
[10:59:36.851]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.851]             version = "1.8"), class = "FutureResult")
[10:59:36.851]     }, finally = {
[10:59:36.851]         if (!identical(...future.workdir, getwd())) 
[10:59:36.851]             setwd(...future.workdir)
[10:59:36.851]         {
[10:59:36.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.851]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.851]             }
[10:59:36.851]             base::options(...future.oldOptions)
[10:59:36.851]             if (.Platform$OS.type == "windows") {
[10:59:36.851]                 old_names <- names(...future.oldEnvVars)
[10:59:36.851]                 envs <- base::Sys.getenv()
[10:59:36.851]                 names <- names(envs)
[10:59:36.851]                 common <- intersect(names, old_names)
[10:59:36.851]                 added <- setdiff(names, old_names)
[10:59:36.851]                 removed <- setdiff(old_names, names)
[10:59:36.851]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.851]                   envs[common]]
[10:59:36.851]                 NAMES <- toupper(changed)
[10:59:36.851]                 args <- list()
[10:59:36.851]                 for (kk in seq_along(NAMES)) {
[10:59:36.851]                   name <- changed[[kk]]
[10:59:36.851]                   NAME <- NAMES[[kk]]
[10:59:36.851]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.851]                     next
[10:59:36.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.851]                 }
[10:59:36.851]                 NAMES <- toupper(added)
[10:59:36.851]                 for (kk in seq_along(NAMES)) {
[10:59:36.851]                   name <- added[[kk]]
[10:59:36.851]                   NAME <- NAMES[[kk]]
[10:59:36.851]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.851]                     next
[10:59:36.851]                   args[[name]] <- ""
[10:59:36.851]                 }
[10:59:36.851]                 NAMES <- toupper(removed)
[10:59:36.851]                 for (kk in seq_along(NAMES)) {
[10:59:36.851]                   name <- removed[[kk]]
[10:59:36.851]                   NAME <- NAMES[[kk]]
[10:59:36.851]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.851]                     next
[10:59:36.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.851]                 }
[10:59:36.851]                 if (length(args) > 0) 
[10:59:36.851]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.851]             }
[10:59:36.851]             else {
[10:59:36.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.851]             }
[10:59:36.851]             {
[10:59:36.851]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.851]                   0L) {
[10:59:36.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.851]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.851]                   base::options(opts)
[10:59:36.851]                 }
[10:59:36.851]                 {
[10:59:36.851]                   {
[10:59:36.851]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.851]                     NULL
[10:59:36.851]                   }
[10:59:36.851]                   options(future.plan = NULL)
[10:59:36.851]                   if (is.na(NA_character_)) 
[10:59:36.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.851]                     .init = FALSE)
[10:59:36.851]                 }
[10:59:36.851]             }
[10:59:36.851]         }
[10:59:36.851]     })
[10:59:36.851]     if (TRUE) {
[10:59:36.851]         base::sink(type = "output", split = FALSE)
[10:59:36.851]         if (TRUE) {
[10:59:36.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.851]         }
[10:59:36.851]         else {
[10:59:36.851]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.851]         }
[10:59:36.851]         base::close(...future.stdout)
[10:59:36.851]         ...future.stdout <- NULL
[10:59:36.851]     }
[10:59:36.851]     ...future.result$conditions <- ...future.conditions
[10:59:36.851]     ...future.result$finished <- base::Sys.time()
[10:59:36.851]     ...future.result
[10:59:36.851] }
[10:59:36.854] Exporting 5 global objects (1.05 KiB) to cluster node #2 ...
[10:59:36.854] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[10:59:36.854] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[10:59:36.854] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[10:59:36.855] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[10:59:36.855] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[10:59:36.855] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[10:59:36.855] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:36.856] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.856] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:36.856] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.856] Exporting 5 global objects (1.05 KiB) to cluster node #2 ... DONE
[10:59:36.856] MultisessionFuture started
[10:59:36.857] - Launch lazy future ... done
[10:59:36.857] run() for ‘MultisessionFuture’ ... done
[10:59:36.857] Created future:
[10:59:36.857] MultisessionFuture:
[10:59:36.857] Label: ‘future_.mapply-2’
[10:59:36.857] Expression:
[10:59:36.857] {
[10:59:36.857]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.857]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.857]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.857]         on.exit(options(oopts), add = TRUE)
[10:59:36.857]     }
[10:59:36.857]     {
[10:59:36.857]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.857]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.857]         do.call(mapply, args = args)
[10:59:36.857]     }
[10:59:36.857] }
[10:59:36.857] Lazy evaluation: FALSE
[10:59:36.857] Asynchronous evaluation: TRUE
[10:59:36.857] Local evaluation: TRUE
[10:59:36.857] Environment: R_GlobalEnv
[10:59:36.857] Capture standard output: TRUE
[10:59:36.857] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.857] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.857] Packages: <none>
[10:59:36.857] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.857] Resolved: FALSE
[10:59:36.857] Value: <not collected>
[10:59:36.857] Conditions captured: <none>
[10:59:36.857] Early signaling: FALSE
[10:59:36.857] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.857] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.868] Chunk #2 of 2 ... DONE
[10:59:36.868] Launching 2 futures (chunks) ... DONE
[10:59:36.868] Resolving 2 futures (chunks) ...
[10:59:36.868] resolve() on list ...
[10:59:36.869]  recursive: 0
[10:59:36.869]  length: 2
[10:59:36.869] 
[10:59:36.869] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.869] - Validating connection of MultisessionFuture
[10:59:36.869] - received message: FutureResult
[10:59:36.870] - Received FutureResult
[10:59:36.870] - Erased future from FutureRegistry
[10:59:36.870] result() for ClusterFuture ...
[10:59:36.870] - result already collected: FutureResult
[10:59:36.870] result() for ClusterFuture ... done
[10:59:36.870] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.870] Future #1
[10:59:36.870] result() for ClusterFuture ...
[10:59:36.870] - result already collected: FutureResult
[10:59:36.870] result() for ClusterFuture ... done
[10:59:36.870] result() for ClusterFuture ...
[10:59:36.870] - result already collected: FutureResult
[10:59:36.871] result() for ClusterFuture ... done
[10:59:36.871] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.871] - nx: 2
[10:59:36.871] - relay: TRUE
[10:59:36.871] - stdout: TRUE
[10:59:36.871] - signal: TRUE
[10:59:36.871] - resignal: FALSE
[10:59:36.871] - force: TRUE
[10:59:36.871] - relayed: [n=2] FALSE, FALSE
[10:59:36.871] - queued futures: [n=2] FALSE, FALSE
[10:59:36.871]  - until=1
[10:59:36.871]  - relaying element #1
[10:59:36.872] result() for ClusterFuture ...
[10:59:36.872] - result already collected: FutureResult
[10:59:36.872] result() for ClusterFuture ... done
[10:59:36.872] result() for ClusterFuture ...
[10:59:36.872] - result already collected: FutureResult
[10:59:36.872] result() for ClusterFuture ... done
[10:59:36.872] result() for ClusterFuture ...
[10:59:36.872] - result already collected: FutureResult
[10:59:36.872] result() for ClusterFuture ... done
[10:59:36.872] result() for ClusterFuture ...
[10:59:36.872] - result already collected: FutureResult
[10:59:36.872] result() for ClusterFuture ... done
[10:59:36.873] - relayed: [n=2] TRUE, FALSE
[10:59:36.873] - queued futures: [n=2] TRUE, FALSE
[10:59:36.873] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.873]  length: 1 (resolved future 1)
[10:59:36.898] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.898] - Validating connection of MultisessionFuture
[10:59:36.898] - received message: FutureResult
[10:59:36.898] - Received FutureResult
[10:59:36.899] - Erased future from FutureRegistry
[10:59:36.899] result() for ClusterFuture ...
[10:59:36.899] - result already collected: FutureResult
[10:59:36.899] result() for ClusterFuture ... done
[10:59:36.899] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.899] Future #2
[10:59:36.899] result() for ClusterFuture ...
[10:59:36.899] - result already collected: FutureResult
[10:59:36.899] result() for ClusterFuture ... done
[10:59:36.899] result() for ClusterFuture ...
[10:59:36.899] - result already collected: FutureResult
[10:59:36.899] result() for ClusterFuture ... done
[10:59:36.900] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:36.900] - nx: 2
[10:59:36.900] - relay: TRUE
[10:59:36.900] - stdout: TRUE
[10:59:36.900] - signal: TRUE
[10:59:36.900] - resignal: FALSE
[10:59:36.900] - force: TRUE
[10:59:36.900] - relayed: [n=2] TRUE, FALSE
[10:59:36.900] - queued futures: [n=2] TRUE, FALSE
[10:59:36.900]  - until=2
[10:59:36.900]  - relaying element #2
[10:59:36.900] result() for ClusterFuture ...
[10:59:36.901] - result already collected: FutureResult
[10:59:36.901] result() for ClusterFuture ... done
[10:59:36.901] result() for ClusterFuture ...
[10:59:36.901] - result already collected: FutureResult
[10:59:36.901] result() for ClusterFuture ... done
[10:59:36.901] result() for ClusterFuture ...
[10:59:36.901] - result already collected: FutureResult
[10:59:36.901] result() for ClusterFuture ... done
[10:59:36.901] result() for ClusterFuture ...
[10:59:36.901] - result already collected: FutureResult
[10:59:36.901] result() for ClusterFuture ... done
[10:59:36.901] - relayed: [n=2] TRUE, TRUE
[10:59:36.902] - queued futures: [n=2] TRUE, TRUE
[10:59:36.902] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:36.902]  length: 0 (resolved future 2)
[10:59:36.902] Relaying remaining futures
[10:59:36.902] signalConditionsASAP(NULL, pos=0) ...
[10:59:36.902] - nx: 2
[10:59:36.902] - relay: TRUE
[10:59:36.902] - stdout: TRUE
[10:59:36.902] - signal: TRUE
[10:59:36.902] - resignal: FALSE
[10:59:36.902] - force: TRUE
[10:59:36.902] - relayed: [n=2] TRUE, TRUE
[10:59:36.902] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:36.903] - relayed: [n=2] TRUE, TRUE
[10:59:36.903] - queued futures: [n=2] TRUE, TRUE
[10:59:36.903] signalConditionsASAP(NULL, pos=0) ... done
[10:59:36.903] resolve() on list ... DONE
[10:59:36.903] result() for ClusterFuture ...
[10:59:36.903] - result already collected: FutureResult
[10:59:36.903] result() for ClusterFuture ... done
[10:59:36.903] result() for ClusterFuture ...
[10:59:36.903] - result already collected: FutureResult
[10:59:36.903] result() for ClusterFuture ... done
[10:59:36.903] result() for ClusterFuture ...
[10:59:36.904] - result already collected: FutureResult
[10:59:36.904] result() for ClusterFuture ... done
[10:59:36.904] result() for ClusterFuture ...
[10:59:36.904] - result already collected: FutureResult
[10:59:36.904] result() for ClusterFuture ... done
[10:59:36.904]  - Number of value chunks collected: 2
[10:59:36.904] Resolving 2 futures (chunks) ... DONE
[10:59:36.904] Reducing values from 2 chunks ...
[10:59:36.904]  - Number of values collected after concatenation: 2
[10:59:36.904]  - Number of values expected: 2
[10:59:36.904] Reducing values from 2 chunks ... DONE
[10:59:36.904] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:59:36.905] future_mapply() ...
[10:59:36.906] Number of chunks: 2
[10:59:36.906] getGlobalsAndPackagesXApply() ...
[10:59:36.906]  - future.globals: TRUE
[10:59:36.906] getGlobalsAndPackages() ...
[10:59:36.906] Searching for globals...
[10:59:36.907] - globals found: [1] ‘FUN’
[10:59:36.907] Searching for globals ... DONE
[10:59:36.907] Resolving globals: FALSE
[10:59:36.907] The total size of the 1 globals is 34 bytes (34 bytes)
[10:59:36.908] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:59:36.908] - globals: [1] ‘FUN’
[10:59:36.908] 
[10:59:36.908] getGlobalsAndPackages() ... DONE
[10:59:36.908]  - globals found/used: [n=1] ‘FUN’
[10:59:36.908]  - needed namespaces: [n=0] 
[10:59:36.908] Finding globals ... DONE
[10:59:36.908] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:36.909] List of 2
[10:59:36.909]  $ ...future.FUN:function (x, ...)  
[10:59:36.909]  $ MoreArgs     : NULL
[10:59:36.909]  - attr(*, "where")=List of 2
[10:59:36.909]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:36.909]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:36.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:36.909]  - attr(*, "resolved")= logi FALSE
[10:59:36.909]  - attr(*, "total_size")= num NA
[10:59:36.911] Packages to be attached in all futures: [n=0] 
[10:59:36.911] getGlobalsAndPackagesXApply() ... DONE
[10:59:36.911] Number of futures (= number of chunks): 2
[10:59:36.911] Launching 2 futures (chunks) ...
[10:59:36.911] Chunk #1 of 2 ...
[10:59:36.912]  - Finding globals in '...' for chunk #1 ...
[10:59:36.912] getGlobalsAndPackages() ...
[10:59:36.912] Searching for globals...
[10:59:36.912] 
[10:59:36.912] Searching for globals ... DONE
[10:59:36.912] - globals: [0] <none>
[10:59:36.912] getGlobalsAndPackages() ... DONE
[10:59:36.912]    + additional globals found: [n=0] 
[10:59:36.912]    + additional namespaces needed: [n=0] 
[10:59:36.912]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:36.913]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.913]  - seeds: <none>
[10:59:36.913]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.913] getGlobalsAndPackages() ...
[10:59:36.913] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.913] Resolving globals: FALSE
[10:59:36.913] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:36.914] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:36.914] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.914] 
[10:59:36.914] getGlobalsAndPackages() ... DONE
[10:59:36.914] run() for ‘Future’ ...
[10:59:36.914] - state: ‘created’
[10:59:36.915] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.930] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.930]   - Field: ‘node’
[10:59:36.931]   - Field: ‘label’
[10:59:36.931]   - Field: ‘local’
[10:59:36.931]   - Field: ‘owner’
[10:59:36.931]   - Field: ‘envir’
[10:59:36.931]   - Field: ‘workers’
[10:59:36.931]   - Field: ‘packages’
[10:59:36.931]   - Field: ‘gc’
[10:59:36.931]   - Field: ‘conditions’
[10:59:36.931]   - Field: ‘persistent’
[10:59:36.931]   - Field: ‘expr’
[10:59:36.931]   - Field: ‘uuid’
[10:59:36.931]   - Field: ‘seed’
[10:59:36.932]   - Field: ‘version’
[10:59:36.932]   - Field: ‘result’
[10:59:36.932]   - Field: ‘asynchronous’
[10:59:36.932]   - Field: ‘calls’
[10:59:36.932]   - Field: ‘globals’
[10:59:36.932]   - Field: ‘stdout’
[10:59:36.932]   - Field: ‘earlySignal’
[10:59:36.932]   - Field: ‘lazy’
[10:59:36.932]   - Field: ‘state’
[10:59:36.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.932] - Launch lazy future ...
[10:59:36.933] Packages needed by the future expression (n = 0): <none>
[10:59:36.933] Packages needed by future strategies (n = 0): <none>
[10:59:36.933] {
[10:59:36.933]     {
[10:59:36.933]         {
[10:59:36.933]             ...future.startTime <- base::Sys.time()
[10:59:36.933]             {
[10:59:36.933]                 {
[10:59:36.933]                   {
[10:59:36.933]                     {
[10:59:36.933]                       base::local({
[10:59:36.933]                         has_future <- base::requireNamespace("future", 
[10:59:36.933]                           quietly = TRUE)
[10:59:36.933]                         if (has_future) {
[10:59:36.933]                           ns <- base::getNamespace("future")
[10:59:36.933]                           version <- ns[[".package"]][["version"]]
[10:59:36.933]                           if (is.null(version)) 
[10:59:36.933]                             version <- utils::packageVersion("future")
[10:59:36.933]                         }
[10:59:36.933]                         else {
[10:59:36.933]                           version <- NULL
[10:59:36.933]                         }
[10:59:36.933]                         if (!has_future || version < "1.8.0") {
[10:59:36.933]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.933]                             "", base::R.version$version.string), 
[10:59:36.933]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.933]                               "release", "version")], collapse = " "), 
[10:59:36.933]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.933]                             info)
[10:59:36.933]                           info <- base::paste(info, collapse = "; ")
[10:59:36.933]                           if (!has_future) {
[10:59:36.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.933]                               info)
[10:59:36.933]                           }
[10:59:36.933]                           else {
[10:59:36.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.933]                               info, version)
[10:59:36.933]                           }
[10:59:36.933]                           base::stop(msg)
[10:59:36.933]                         }
[10:59:36.933]                       })
[10:59:36.933]                     }
[10:59:36.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.933]                     base::options(mc.cores = 1L)
[10:59:36.933]                   }
[10:59:36.933]                   ...future.strategy.old <- future::plan("list")
[10:59:36.933]                   options(future.plan = NULL)
[10:59:36.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.933]                 }
[10:59:36.933]                 ...future.workdir <- getwd()
[10:59:36.933]             }
[10:59:36.933]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.933]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.933]         }
[10:59:36.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.933]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.933]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.933]             base::names(...future.oldOptions))
[10:59:36.933]     }
[10:59:36.933]     if (FALSE) {
[10:59:36.933]     }
[10:59:36.933]     else {
[10:59:36.933]         if (TRUE) {
[10:59:36.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.933]                 open = "w")
[10:59:36.933]         }
[10:59:36.933]         else {
[10:59:36.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.933]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.933]         }
[10:59:36.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.933]             base::sink(type = "output", split = FALSE)
[10:59:36.933]             base::close(...future.stdout)
[10:59:36.933]         }, add = TRUE)
[10:59:36.933]     }
[10:59:36.933]     ...future.frame <- base::sys.nframe()
[10:59:36.933]     ...future.conditions <- base::list()
[10:59:36.933]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.933]     if (FALSE) {
[10:59:36.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.933]     }
[10:59:36.933]     ...future.result <- base::tryCatch({
[10:59:36.933]         base::withCallingHandlers({
[10:59:36.933]             ...future.value <- base::withVisible(base::local({
[10:59:36.933]                 ...future.makeSendCondition <- base::local({
[10:59:36.933]                   sendCondition <- NULL
[10:59:36.933]                   function(frame = 1L) {
[10:59:36.933]                     if (is.function(sendCondition)) 
[10:59:36.933]                       return(sendCondition)
[10:59:36.933]                     ns <- getNamespace("parallel")
[10:59:36.933]                     if (exists("sendData", mode = "function", 
[10:59:36.933]                       envir = ns)) {
[10:59:36.933]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.933]                         envir = ns)
[10:59:36.933]                       envir <- sys.frame(frame)
[10:59:36.933]                       master <- NULL
[10:59:36.933]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.933]                         !identical(envir, emptyenv())) {
[10:59:36.933]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.933]                           inherits = FALSE)) {
[10:59:36.933]                           master <- get("master", mode = "list", 
[10:59:36.933]                             envir = envir, inherits = FALSE)
[10:59:36.933]                           if (inherits(master, c("SOCKnode", 
[10:59:36.933]                             "SOCK0node"))) {
[10:59:36.933]                             sendCondition <<- function(cond) {
[10:59:36.933]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.933]                                 success = TRUE)
[10:59:36.933]                               parallel_sendData(master, data)
[10:59:36.933]                             }
[10:59:36.933]                             return(sendCondition)
[10:59:36.933]                           }
[10:59:36.933]                         }
[10:59:36.933]                         frame <- frame + 1L
[10:59:36.933]                         envir <- sys.frame(frame)
[10:59:36.933]                       }
[10:59:36.933]                     }
[10:59:36.933]                     sendCondition <<- function(cond) NULL
[10:59:36.933]                   }
[10:59:36.933]                 })
[10:59:36.933]                 withCallingHandlers({
[10:59:36.933]                   {
[10:59:36.933]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.933]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.933]                       ...future.globals.maxSize)) {
[10:59:36.933]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.933]                       on.exit(options(oopts), add = TRUE)
[10:59:36.933]                     }
[10:59:36.933]                     {
[10:59:36.933]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.933]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.933]                         USE.NAMES = FALSE)
[10:59:36.933]                       do.call(mapply, args = args)
[10:59:36.933]                     }
[10:59:36.933]                   }
[10:59:36.933]                 }, immediateCondition = function(cond) {
[10:59:36.933]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.933]                   sendCondition(cond)
[10:59:36.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.933]                   {
[10:59:36.933]                     inherits <- base::inherits
[10:59:36.933]                     invokeRestart <- base::invokeRestart
[10:59:36.933]                     is.null <- base::is.null
[10:59:36.933]                     muffled <- FALSE
[10:59:36.933]                     if (inherits(cond, "message")) {
[10:59:36.933]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.933]                       if (muffled) 
[10:59:36.933]                         invokeRestart("muffleMessage")
[10:59:36.933]                     }
[10:59:36.933]                     else if (inherits(cond, "warning")) {
[10:59:36.933]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.933]                       if (muffled) 
[10:59:36.933]                         invokeRestart("muffleWarning")
[10:59:36.933]                     }
[10:59:36.933]                     else if (inherits(cond, "condition")) {
[10:59:36.933]                       if (!is.null(pattern)) {
[10:59:36.933]                         computeRestarts <- base::computeRestarts
[10:59:36.933]                         grepl <- base::grepl
[10:59:36.933]                         restarts <- computeRestarts(cond)
[10:59:36.933]                         for (restart in restarts) {
[10:59:36.933]                           name <- restart$name
[10:59:36.933]                           if (is.null(name)) 
[10:59:36.933]                             next
[10:59:36.933]                           if (!grepl(pattern, name)) 
[10:59:36.933]                             next
[10:59:36.933]                           invokeRestart(restart)
[10:59:36.933]                           muffled <- TRUE
[10:59:36.933]                           break
[10:59:36.933]                         }
[10:59:36.933]                       }
[10:59:36.933]                     }
[10:59:36.933]                     invisible(muffled)
[10:59:36.933]                   }
[10:59:36.933]                   muffleCondition(cond)
[10:59:36.933]                 })
[10:59:36.933]             }))
[10:59:36.933]             future::FutureResult(value = ...future.value$value, 
[10:59:36.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.933]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.933]                     ...future.globalenv.names))
[10:59:36.933]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.933]         }, condition = base::local({
[10:59:36.933]             c <- base::c
[10:59:36.933]             inherits <- base::inherits
[10:59:36.933]             invokeRestart <- base::invokeRestart
[10:59:36.933]             length <- base::length
[10:59:36.933]             list <- base::list
[10:59:36.933]             seq.int <- base::seq.int
[10:59:36.933]             signalCondition <- base::signalCondition
[10:59:36.933]             sys.calls <- base::sys.calls
[10:59:36.933]             `[[` <- base::`[[`
[10:59:36.933]             `+` <- base::`+`
[10:59:36.933]             `<<-` <- base::`<<-`
[10:59:36.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.933]                   3L)]
[10:59:36.933]             }
[10:59:36.933]             function(cond) {
[10:59:36.933]                 is_error <- inherits(cond, "error")
[10:59:36.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.933]                   NULL)
[10:59:36.933]                 if (is_error) {
[10:59:36.933]                   sessionInformation <- function() {
[10:59:36.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.933]                       search = base::search(), system = base::Sys.info())
[10:59:36.933]                   }
[10:59:36.933]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.933]                     cond$call), session = sessionInformation(), 
[10:59:36.933]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.933]                   signalCondition(cond)
[10:59:36.933]                 }
[10:59:36.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.933]                 "immediateCondition"))) {
[10:59:36.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.933]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.933]                   if (TRUE && !signal) {
[10:59:36.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.933]                     {
[10:59:36.933]                       inherits <- base::inherits
[10:59:36.933]                       invokeRestart <- base::invokeRestart
[10:59:36.933]                       is.null <- base::is.null
[10:59:36.933]                       muffled <- FALSE
[10:59:36.933]                       if (inherits(cond, "message")) {
[10:59:36.933]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.933]                         if (muffled) 
[10:59:36.933]                           invokeRestart("muffleMessage")
[10:59:36.933]                       }
[10:59:36.933]                       else if (inherits(cond, "warning")) {
[10:59:36.933]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.933]                         if (muffled) 
[10:59:36.933]                           invokeRestart("muffleWarning")
[10:59:36.933]                       }
[10:59:36.933]                       else if (inherits(cond, "condition")) {
[10:59:36.933]                         if (!is.null(pattern)) {
[10:59:36.933]                           computeRestarts <- base::computeRestarts
[10:59:36.933]                           grepl <- base::grepl
[10:59:36.933]                           restarts <- computeRestarts(cond)
[10:59:36.933]                           for (restart in restarts) {
[10:59:36.933]                             name <- restart$name
[10:59:36.933]                             if (is.null(name)) 
[10:59:36.933]                               next
[10:59:36.933]                             if (!grepl(pattern, name)) 
[10:59:36.933]                               next
[10:59:36.933]                             invokeRestart(restart)
[10:59:36.933]                             muffled <- TRUE
[10:59:36.933]                             break
[10:59:36.933]                           }
[10:59:36.933]                         }
[10:59:36.933]                       }
[10:59:36.933]                       invisible(muffled)
[10:59:36.933]                     }
[10:59:36.933]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.933]                   }
[10:59:36.933]                 }
[10:59:36.933]                 else {
[10:59:36.933]                   if (TRUE) {
[10:59:36.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.933]                     {
[10:59:36.933]                       inherits <- base::inherits
[10:59:36.933]                       invokeRestart <- base::invokeRestart
[10:59:36.933]                       is.null <- base::is.null
[10:59:36.933]                       muffled <- FALSE
[10:59:36.933]                       if (inherits(cond, "message")) {
[10:59:36.933]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.933]                         if (muffled) 
[10:59:36.933]                           invokeRestart("muffleMessage")
[10:59:36.933]                       }
[10:59:36.933]                       else if (inherits(cond, "warning")) {
[10:59:36.933]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.933]                         if (muffled) 
[10:59:36.933]                           invokeRestart("muffleWarning")
[10:59:36.933]                       }
[10:59:36.933]                       else if (inherits(cond, "condition")) {
[10:59:36.933]                         if (!is.null(pattern)) {
[10:59:36.933]                           computeRestarts <- base::computeRestarts
[10:59:36.933]                           grepl <- base::grepl
[10:59:36.933]                           restarts <- computeRestarts(cond)
[10:59:36.933]                           for (restart in restarts) {
[10:59:36.933]                             name <- restart$name
[10:59:36.933]                             if (is.null(name)) 
[10:59:36.933]                               next
[10:59:36.933]                             if (!grepl(pattern, name)) 
[10:59:36.933]                               next
[10:59:36.933]                             invokeRestart(restart)
[10:59:36.933]                             muffled <- TRUE
[10:59:36.933]                             break
[10:59:36.933]                           }
[10:59:36.933]                         }
[10:59:36.933]                       }
[10:59:36.933]                       invisible(muffled)
[10:59:36.933]                     }
[10:59:36.933]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.933]                   }
[10:59:36.933]                 }
[10:59:36.933]             }
[10:59:36.933]         }))
[10:59:36.933]     }, error = function(ex) {
[10:59:36.933]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.933]                 ...future.rng), started = ...future.startTime, 
[10:59:36.933]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.933]             version = "1.8"), class = "FutureResult")
[10:59:36.933]     }, finally = {
[10:59:36.933]         if (!identical(...future.workdir, getwd())) 
[10:59:36.933]             setwd(...future.workdir)
[10:59:36.933]         {
[10:59:36.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.933]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.933]             }
[10:59:36.933]             base::options(...future.oldOptions)
[10:59:36.933]             if (.Platform$OS.type == "windows") {
[10:59:36.933]                 old_names <- names(...future.oldEnvVars)
[10:59:36.933]                 envs <- base::Sys.getenv()
[10:59:36.933]                 names <- names(envs)
[10:59:36.933]                 common <- intersect(names, old_names)
[10:59:36.933]                 added <- setdiff(names, old_names)
[10:59:36.933]                 removed <- setdiff(old_names, names)
[10:59:36.933]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.933]                   envs[common]]
[10:59:36.933]                 NAMES <- toupper(changed)
[10:59:36.933]                 args <- list()
[10:59:36.933]                 for (kk in seq_along(NAMES)) {
[10:59:36.933]                   name <- changed[[kk]]
[10:59:36.933]                   NAME <- NAMES[[kk]]
[10:59:36.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.933]                     next
[10:59:36.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.933]                 }
[10:59:36.933]                 NAMES <- toupper(added)
[10:59:36.933]                 for (kk in seq_along(NAMES)) {
[10:59:36.933]                   name <- added[[kk]]
[10:59:36.933]                   NAME <- NAMES[[kk]]
[10:59:36.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.933]                     next
[10:59:36.933]                   args[[name]] <- ""
[10:59:36.933]                 }
[10:59:36.933]                 NAMES <- toupper(removed)
[10:59:36.933]                 for (kk in seq_along(NAMES)) {
[10:59:36.933]                   name <- removed[[kk]]
[10:59:36.933]                   NAME <- NAMES[[kk]]
[10:59:36.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.933]                     next
[10:59:36.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.933]                 }
[10:59:36.933]                 if (length(args) > 0) 
[10:59:36.933]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.933]             }
[10:59:36.933]             else {
[10:59:36.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.933]             }
[10:59:36.933]             {
[10:59:36.933]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.933]                   0L) {
[10:59:36.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.933]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.933]                   base::options(opts)
[10:59:36.933]                 }
[10:59:36.933]                 {
[10:59:36.933]                   {
[10:59:36.933]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.933]                     NULL
[10:59:36.933]                   }
[10:59:36.933]                   options(future.plan = NULL)
[10:59:36.933]                   if (is.na(NA_character_)) 
[10:59:36.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.933]                     .init = FALSE)
[10:59:36.933]                 }
[10:59:36.933]             }
[10:59:36.933]         }
[10:59:36.933]     })
[10:59:36.933]     if (TRUE) {
[10:59:36.933]         base::sink(type = "output", split = FALSE)
[10:59:36.933]         if (TRUE) {
[10:59:36.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.933]         }
[10:59:36.933]         else {
[10:59:36.933]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.933]         }
[10:59:36.933]         base::close(...future.stdout)
[10:59:36.933]         ...future.stdout <- NULL
[10:59:36.933]     }
[10:59:36.933]     ...future.result$conditions <- ...future.conditions
[10:59:36.933]     ...future.result$finished <- base::Sys.time()
[10:59:36.933]     ...future.result
[10:59:36.933] }
[10:59:36.936] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[10:59:36.936] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:59:36.936] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:59:36.936] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:36.937] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.937] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[10:59:36.937] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[10:59:36.937] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:36.938] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.938] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:36.938] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:36.938] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[10:59:36.939] MultisessionFuture started
[10:59:36.939] - Launch lazy future ... done
[10:59:36.939] run() for ‘MultisessionFuture’ ... done
[10:59:36.939] Created future:
[10:59:36.939] MultisessionFuture:
[10:59:36.939] Label: ‘future_mapply-1’
[10:59:36.939] Expression:
[10:59:36.939] {
[10:59:36.939]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.939]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.939]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.939]         on.exit(options(oopts), add = TRUE)
[10:59:36.939]     }
[10:59:36.939]     {
[10:59:36.939]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.939]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.939]         do.call(mapply, args = args)
[10:59:36.939]     }
[10:59:36.939] }
[10:59:36.939] Lazy evaluation: FALSE
[10:59:36.939] Asynchronous evaluation: TRUE
[10:59:36.939] Local evaluation: TRUE
[10:59:36.939] Environment: R_GlobalEnv
[10:59:36.939] Capture standard output: TRUE
[10:59:36.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.939] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.939] Packages: <none>
[10:59:36.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.939] Resolved: FALSE
[10:59:36.939] Value: <not collected>
[10:59:36.939] Conditions captured: <none>
[10:59:36.939] Early signaling: FALSE
[10:59:36.939] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.939] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.950] Chunk #1 of 2 ... DONE
[10:59:36.950] Chunk #2 of 2 ...
[10:59:36.951]  - Finding globals in '...' for chunk #2 ...
[10:59:36.951] getGlobalsAndPackages() ...
[10:59:36.951] Searching for globals...
[10:59:36.951] 
[10:59:36.951] Searching for globals ... DONE
[10:59:36.951] - globals: [0] <none>
[10:59:36.951] getGlobalsAndPackages() ... DONE
[10:59:36.951]    + additional globals found: [n=0] 
[10:59:36.952]    + additional namespaces needed: [n=0] 
[10:59:36.952]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:36.952]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:36.952]  - seeds: <none>
[10:59:36.952]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.952] getGlobalsAndPackages() ...
[10:59:36.952] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.952] Resolving globals: FALSE
[10:59:36.952] The total size of the 5 globals is 210 bytes (210 bytes)
[10:59:36.953] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:36.953] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:36.953] 
[10:59:36.953] getGlobalsAndPackages() ... DONE
[10:59:36.953] run() for ‘Future’ ...
[10:59:36.954] - state: ‘created’
[10:59:36.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:36.968] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:36.968]   - Field: ‘node’
[10:59:36.968]   - Field: ‘label’
[10:59:36.968]   - Field: ‘local’
[10:59:36.968]   - Field: ‘owner’
[10:59:36.968]   - Field: ‘envir’
[10:59:36.968]   - Field: ‘workers’
[10:59:36.969]   - Field: ‘packages’
[10:59:36.969]   - Field: ‘gc’
[10:59:36.969]   - Field: ‘conditions’
[10:59:36.969]   - Field: ‘persistent’
[10:59:36.969]   - Field: ‘expr’
[10:59:36.969]   - Field: ‘uuid’
[10:59:36.969]   - Field: ‘seed’
[10:59:36.969]   - Field: ‘version’
[10:59:36.969]   - Field: ‘result’
[10:59:36.969]   - Field: ‘asynchronous’
[10:59:36.969]   - Field: ‘calls’
[10:59:36.969]   - Field: ‘globals’
[10:59:36.969]   - Field: ‘stdout’
[10:59:36.970]   - Field: ‘earlySignal’
[10:59:36.970]   - Field: ‘lazy’
[10:59:36.970]   - Field: ‘state’
[10:59:36.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:36.970] - Launch lazy future ...
[10:59:36.970] Packages needed by the future expression (n = 0): <none>
[10:59:36.970] Packages needed by future strategies (n = 0): <none>
[10:59:36.971] {
[10:59:36.971]     {
[10:59:36.971]         {
[10:59:36.971]             ...future.startTime <- base::Sys.time()
[10:59:36.971]             {
[10:59:36.971]                 {
[10:59:36.971]                   {
[10:59:36.971]                     {
[10:59:36.971]                       base::local({
[10:59:36.971]                         has_future <- base::requireNamespace("future", 
[10:59:36.971]                           quietly = TRUE)
[10:59:36.971]                         if (has_future) {
[10:59:36.971]                           ns <- base::getNamespace("future")
[10:59:36.971]                           version <- ns[[".package"]][["version"]]
[10:59:36.971]                           if (is.null(version)) 
[10:59:36.971]                             version <- utils::packageVersion("future")
[10:59:36.971]                         }
[10:59:36.971]                         else {
[10:59:36.971]                           version <- NULL
[10:59:36.971]                         }
[10:59:36.971]                         if (!has_future || version < "1.8.0") {
[10:59:36.971]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:36.971]                             "", base::R.version$version.string), 
[10:59:36.971]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:36.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:36.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:36.971]                               "release", "version")], collapse = " "), 
[10:59:36.971]                             hostname = base::Sys.info()[["nodename"]])
[10:59:36.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:36.971]                             info)
[10:59:36.971]                           info <- base::paste(info, collapse = "; ")
[10:59:36.971]                           if (!has_future) {
[10:59:36.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:36.971]                               info)
[10:59:36.971]                           }
[10:59:36.971]                           else {
[10:59:36.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:36.971]                               info, version)
[10:59:36.971]                           }
[10:59:36.971]                           base::stop(msg)
[10:59:36.971]                         }
[10:59:36.971]                       })
[10:59:36.971]                     }
[10:59:36.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:36.971]                     base::options(mc.cores = 1L)
[10:59:36.971]                   }
[10:59:36.971]                   ...future.strategy.old <- future::plan("list")
[10:59:36.971]                   options(future.plan = NULL)
[10:59:36.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:36.971]                 }
[10:59:36.971]                 ...future.workdir <- getwd()
[10:59:36.971]             }
[10:59:36.971]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:36.971]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:36.971]         }
[10:59:36.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:36.971]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:36.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:36.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:36.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:36.971]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:36.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:36.971]             base::names(...future.oldOptions))
[10:59:36.971]     }
[10:59:36.971]     if (FALSE) {
[10:59:36.971]     }
[10:59:36.971]     else {
[10:59:36.971]         if (TRUE) {
[10:59:36.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:36.971]                 open = "w")
[10:59:36.971]         }
[10:59:36.971]         else {
[10:59:36.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:36.971]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:36.971]         }
[10:59:36.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:36.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:36.971]             base::sink(type = "output", split = FALSE)
[10:59:36.971]             base::close(...future.stdout)
[10:59:36.971]         }, add = TRUE)
[10:59:36.971]     }
[10:59:36.971]     ...future.frame <- base::sys.nframe()
[10:59:36.971]     ...future.conditions <- base::list()
[10:59:36.971]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:36.971]     if (FALSE) {
[10:59:36.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:36.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:36.971]     }
[10:59:36.971]     ...future.result <- base::tryCatch({
[10:59:36.971]         base::withCallingHandlers({
[10:59:36.971]             ...future.value <- base::withVisible(base::local({
[10:59:36.971]                 ...future.makeSendCondition <- base::local({
[10:59:36.971]                   sendCondition <- NULL
[10:59:36.971]                   function(frame = 1L) {
[10:59:36.971]                     if (is.function(sendCondition)) 
[10:59:36.971]                       return(sendCondition)
[10:59:36.971]                     ns <- getNamespace("parallel")
[10:59:36.971]                     if (exists("sendData", mode = "function", 
[10:59:36.971]                       envir = ns)) {
[10:59:36.971]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:36.971]                         envir = ns)
[10:59:36.971]                       envir <- sys.frame(frame)
[10:59:36.971]                       master <- NULL
[10:59:36.971]                       while (!identical(envir, .GlobalEnv) && 
[10:59:36.971]                         !identical(envir, emptyenv())) {
[10:59:36.971]                         if (exists("master", mode = "list", envir = envir, 
[10:59:36.971]                           inherits = FALSE)) {
[10:59:36.971]                           master <- get("master", mode = "list", 
[10:59:36.971]                             envir = envir, inherits = FALSE)
[10:59:36.971]                           if (inherits(master, c("SOCKnode", 
[10:59:36.971]                             "SOCK0node"))) {
[10:59:36.971]                             sendCondition <<- function(cond) {
[10:59:36.971]                               data <- list(type = "VALUE", value = cond, 
[10:59:36.971]                                 success = TRUE)
[10:59:36.971]                               parallel_sendData(master, data)
[10:59:36.971]                             }
[10:59:36.971]                             return(sendCondition)
[10:59:36.971]                           }
[10:59:36.971]                         }
[10:59:36.971]                         frame <- frame + 1L
[10:59:36.971]                         envir <- sys.frame(frame)
[10:59:36.971]                       }
[10:59:36.971]                     }
[10:59:36.971]                     sendCondition <<- function(cond) NULL
[10:59:36.971]                   }
[10:59:36.971]                 })
[10:59:36.971]                 withCallingHandlers({
[10:59:36.971]                   {
[10:59:36.971]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.971]                     if (!identical(...future.globals.maxSize.org, 
[10:59:36.971]                       ...future.globals.maxSize)) {
[10:59:36.971]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.971]                       on.exit(options(oopts), add = TRUE)
[10:59:36.971]                     }
[10:59:36.971]                     {
[10:59:36.971]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.971]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:36.971]                         USE.NAMES = FALSE)
[10:59:36.971]                       do.call(mapply, args = args)
[10:59:36.971]                     }
[10:59:36.971]                   }
[10:59:36.971]                 }, immediateCondition = function(cond) {
[10:59:36.971]                   sendCondition <- ...future.makeSendCondition()
[10:59:36.971]                   sendCondition(cond)
[10:59:36.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.971]                   {
[10:59:36.971]                     inherits <- base::inherits
[10:59:36.971]                     invokeRestart <- base::invokeRestart
[10:59:36.971]                     is.null <- base::is.null
[10:59:36.971]                     muffled <- FALSE
[10:59:36.971]                     if (inherits(cond, "message")) {
[10:59:36.971]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:36.971]                       if (muffled) 
[10:59:36.971]                         invokeRestart("muffleMessage")
[10:59:36.971]                     }
[10:59:36.971]                     else if (inherits(cond, "warning")) {
[10:59:36.971]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:36.971]                       if (muffled) 
[10:59:36.971]                         invokeRestart("muffleWarning")
[10:59:36.971]                     }
[10:59:36.971]                     else if (inherits(cond, "condition")) {
[10:59:36.971]                       if (!is.null(pattern)) {
[10:59:36.971]                         computeRestarts <- base::computeRestarts
[10:59:36.971]                         grepl <- base::grepl
[10:59:36.971]                         restarts <- computeRestarts(cond)
[10:59:36.971]                         for (restart in restarts) {
[10:59:36.971]                           name <- restart$name
[10:59:36.971]                           if (is.null(name)) 
[10:59:36.971]                             next
[10:59:36.971]                           if (!grepl(pattern, name)) 
[10:59:36.971]                             next
[10:59:36.971]                           invokeRestart(restart)
[10:59:36.971]                           muffled <- TRUE
[10:59:36.971]                           break
[10:59:36.971]                         }
[10:59:36.971]                       }
[10:59:36.971]                     }
[10:59:36.971]                     invisible(muffled)
[10:59:36.971]                   }
[10:59:36.971]                   muffleCondition(cond)
[10:59:36.971]                 })
[10:59:36.971]             }))
[10:59:36.971]             future::FutureResult(value = ...future.value$value, 
[10:59:36.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.971]                   ...future.rng), globalenv = if (FALSE) 
[10:59:36.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:36.971]                     ...future.globalenv.names))
[10:59:36.971]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:36.971]         }, condition = base::local({
[10:59:36.971]             c <- base::c
[10:59:36.971]             inherits <- base::inherits
[10:59:36.971]             invokeRestart <- base::invokeRestart
[10:59:36.971]             length <- base::length
[10:59:36.971]             list <- base::list
[10:59:36.971]             seq.int <- base::seq.int
[10:59:36.971]             signalCondition <- base::signalCondition
[10:59:36.971]             sys.calls <- base::sys.calls
[10:59:36.971]             `[[` <- base::`[[`
[10:59:36.971]             `+` <- base::`+`
[10:59:36.971]             `<<-` <- base::`<<-`
[10:59:36.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:36.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:36.971]                   3L)]
[10:59:36.971]             }
[10:59:36.971]             function(cond) {
[10:59:36.971]                 is_error <- inherits(cond, "error")
[10:59:36.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:36.971]                   NULL)
[10:59:36.971]                 if (is_error) {
[10:59:36.971]                   sessionInformation <- function() {
[10:59:36.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:36.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:36.971]                       search = base::search(), system = base::Sys.info())
[10:59:36.971]                   }
[10:59:36.971]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:36.971]                     cond$call), session = sessionInformation(), 
[10:59:36.971]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:36.971]                   signalCondition(cond)
[10:59:36.971]                 }
[10:59:36.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:36.971]                 "immediateCondition"))) {
[10:59:36.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:36.971]                   ...future.conditions[[length(...future.conditions) + 
[10:59:36.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:36.971]                   if (TRUE && !signal) {
[10:59:36.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.971]                     {
[10:59:36.971]                       inherits <- base::inherits
[10:59:36.971]                       invokeRestart <- base::invokeRestart
[10:59:36.971]                       is.null <- base::is.null
[10:59:36.971]                       muffled <- FALSE
[10:59:36.971]                       if (inherits(cond, "message")) {
[10:59:36.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.971]                         if (muffled) 
[10:59:36.971]                           invokeRestart("muffleMessage")
[10:59:36.971]                       }
[10:59:36.971]                       else if (inherits(cond, "warning")) {
[10:59:36.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.971]                         if (muffled) 
[10:59:36.971]                           invokeRestart("muffleWarning")
[10:59:36.971]                       }
[10:59:36.971]                       else if (inherits(cond, "condition")) {
[10:59:36.971]                         if (!is.null(pattern)) {
[10:59:36.971]                           computeRestarts <- base::computeRestarts
[10:59:36.971]                           grepl <- base::grepl
[10:59:36.971]                           restarts <- computeRestarts(cond)
[10:59:36.971]                           for (restart in restarts) {
[10:59:36.971]                             name <- restart$name
[10:59:36.971]                             if (is.null(name)) 
[10:59:36.971]                               next
[10:59:36.971]                             if (!grepl(pattern, name)) 
[10:59:36.971]                               next
[10:59:36.971]                             invokeRestart(restart)
[10:59:36.971]                             muffled <- TRUE
[10:59:36.971]                             break
[10:59:36.971]                           }
[10:59:36.971]                         }
[10:59:36.971]                       }
[10:59:36.971]                       invisible(muffled)
[10:59:36.971]                     }
[10:59:36.971]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.971]                   }
[10:59:36.971]                 }
[10:59:36.971]                 else {
[10:59:36.971]                   if (TRUE) {
[10:59:36.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:36.971]                     {
[10:59:36.971]                       inherits <- base::inherits
[10:59:36.971]                       invokeRestart <- base::invokeRestart
[10:59:36.971]                       is.null <- base::is.null
[10:59:36.971]                       muffled <- FALSE
[10:59:36.971]                       if (inherits(cond, "message")) {
[10:59:36.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:36.971]                         if (muffled) 
[10:59:36.971]                           invokeRestart("muffleMessage")
[10:59:36.971]                       }
[10:59:36.971]                       else if (inherits(cond, "warning")) {
[10:59:36.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:36.971]                         if (muffled) 
[10:59:36.971]                           invokeRestart("muffleWarning")
[10:59:36.971]                       }
[10:59:36.971]                       else if (inherits(cond, "condition")) {
[10:59:36.971]                         if (!is.null(pattern)) {
[10:59:36.971]                           computeRestarts <- base::computeRestarts
[10:59:36.971]                           grepl <- base::grepl
[10:59:36.971]                           restarts <- computeRestarts(cond)
[10:59:36.971]                           for (restart in restarts) {
[10:59:36.971]                             name <- restart$name
[10:59:36.971]                             if (is.null(name)) 
[10:59:36.971]                               next
[10:59:36.971]                             if (!grepl(pattern, name)) 
[10:59:36.971]                               next
[10:59:36.971]                             invokeRestart(restart)
[10:59:36.971]                             muffled <- TRUE
[10:59:36.971]                             break
[10:59:36.971]                           }
[10:59:36.971]                         }
[10:59:36.971]                       }
[10:59:36.971]                       invisible(muffled)
[10:59:36.971]                     }
[10:59:36.971]                     muffleCondition(cond, pattern = "^muffle")
[10:59:36.971]                   }
[10:59:36.971]                 }
[10:59:36.971]             }
[10:59:36.971]         }))
[10:59:36.971]     }, error = function(ex) {
[10:59:36.971]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:36.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:36.971]                 ...future.rng), started = ...future.startTime, 
[10:59:36.971]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:36.971]             version = "1.8"), class = "FutureResult")
[10:59:36.971]     }, finally = {
[10:59:36.971]         if (!identical(...future.workdir, getwd())) 
[10:59:36.971]             setwd(...future.workdir)
[10:59:36.971]         {
[10:59:36.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:36.971]                 ...future.oldOptions$nwarnings <- NULL
[10:59:36.971]             }
[10:59:36.971]             base::options(...future.oldOptions)
[10:59:36.971]             if (.Platform$OS.type == "windows") {
[10:59:36.971]                 old_names <- names(...future.oldEnvVars)
[10:59:36.971]                 envs <- base::Sys.getenv()
[10:59:36.971]                 names <- names(envs)
[10:59:36.971]                 common <- intersect(names, old_names)
[10:59:36.971]                 added <- setdiff(names, old_names)
[10:59:36.971]                 removed <- setdiff(old_names, names)
[10:59:36.971]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:36.971]                   envs[common]]
[10:59:36.971]                 NAMES <- toupper(changed)
[10:59:36.971]                 args <- list()
[10:59:36.971]                 for (kk in seq_along(NAMES)) {
[10:59:36.971]                   name <- changed[[kk]]
[10:59:36.971]                   NAME <- NAMES[[kk]]
[10:59:36.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.971]                     next
[10:59:36.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.971]                 }
[10:59:36.971]                 NAMES <- toupper(added)
[10:59:36.971]                 for (kk in seq_along(NAMES)) {
[10:59:36.971]                   name <- added[[kk]]
[10:59:36.971]                   NAME <- NAMES[[kk]]
[10:59:36.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.971]                     next
[10:59:36.971]                   args[[name]] <- ""
[10:59:36.971]                 }
[10:59:36.971]                 NAMES <- toupper(removed)
[10:59:36.971]                 for (kk in seq_along(NAMES)) {
[10:59:36.971]                   name <- removed[[kk]]
[10:59:36.971]                   NAME <- NAMES[[kk]]
[10:59:36.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:36.971]                     next
[10:59:36.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:36.971]                 }
[10:59:36.971]                 if (length(args) > 0) 
[10:59:36.971]                   base::do.call(base::Sys.setenv, args = args)
[10:59:36.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:36.971]             }
[10:59:36.971]             else {
[10:59:36.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:36.971]             }
[10:59:36.971]             {
[10:59:36.971]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:36.971]                   0L) {
[10:59:36.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:36.971]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:36.971]                   base::options(opts)
[10:59:36.971]                 }
[10:59:36.971]                 {
[10:59:36.971]                   {
[10:59:36.971]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:36.971]                     NULL
[10:59:36.971]                   }
[10:59:36.971]                   options(future.plan = NULL)
[10:59:36.971]                   if (is.na(NA_character_)) 
[10:59:36.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:36.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:36.971]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:36.971]                     .init = FALSE)
[10:59:36.971]                 }
[10:59:36.971]             }
[10:59:36.971]         }
[10:59:36.971]     })
[10:59:36.971]     if (TRUE) {
[10:59:36.971]         base::sink(type = "output", split = FALSE)
[10:59:36.971]         if (TRUE) {
[10:59:36.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:36.971]         }
[10:59:36.971]         else {
[10:59:36.971]             ...future.result["stdout"] <- base::list(NULL)
[10:59:36.971]         }
[10:59:36.971]         base::close(...future.stdout)
[10:59:36.971]         ...future.stdout <- NULL
[10:59:36.971]     }
[10:59:36.971]     ...future.result$conditions <- ...future.conditions
[10:59:36.971]     ...future.result$finished <- base::Sys.time()
[10:59:36.971]     ...future.result
[10:59:36.971] }
[10:59:36.973] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[10:59:36.973] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:59:36.974] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:59:36.974] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:36.974] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.974] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[10:59:36.975] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[10:59:36.975] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:36.975] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.975] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:36.975] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:36.975] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[10:59:36.976] MultisessionFuture started
[10:59:36.976] - Launch lazy future ... done
[10:59:36.976] run() for ‘MultisessionFuture’ ... done
[10:59:36.976] Created future:
[10:59:36.976] MultisessionFuture:
[10:59:36.976] Label: ‘future_mapply-2’
[10:59:36.976] Expression:
[10:59:36.976] {
[10:59:36.976]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:36.976]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:36.976]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:36.976]         on.exit(options(oopts), add = TRUE)
[10:59:36.976]     }
[10:59:36.976]     {
[10:59:36.976]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:36.976]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:36.976]         do.call(mapply, args = args)
[10:59:36.976]     }
[10:59:36.976] }
[10:59:36.976] Lazy evaluation: FALSE
[10:59:36.976] Asynchronous evaluation: TRUE
[10:59:36.976] Local evaluation: TRUE
[10:59:36.976] Environment: R_GlobalEnv
[10:59:36.976] Capture standard output: TRUE
[10:59:36.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:36.976] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:36.976] Packages: <none>
[10:59:36.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:36.976] Resolved: FALSE
[10:59:36.976] Value: <not collected>
[10:59:36.976] Conditions captured: <none>
[10:59:36.976] Early signaling: FALSE
[10:59:36.976] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:36.976] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:36.987] Chunk #2 of 2 ... DONE
[10:59:36.987] Launching 2 futures (chunks) ... DONE
[10:59:36.988] Resolving 2 futures (chunks) ...
[10:59:36.988] resolve() on list ...
[10:59:36.988]  recursive: 0
[10:59:36.988]  length: 2
[10:59:36.988] 
[10:59:36.988] receiveMessageFromWorker() for ClusterFuture ...
[10:59:36.989] - Validating connection of MultisessionFuture
[10:59:36.989] - received message: FutureResult
[10:59:36.989] - Received FutureResult
[10:59:36.989] - Erased future from FutureRegistry
[10:59:36.989] result() for ClusterFuture ...
[10:59:36.989] - result already collected: FutureResult
[10:59:36.989] result() for ClusterFuture ... done
[10:59:36.989] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:36.989] Future #1
[10:59:36.989] result() for ClusterFuture ...
[10:59:36.989] - result already collected: FutureResult
[10:59:36.990] result() for ClusterFuture ... done
[10:59:36.990] result() for ClusterFuture ...
[10:59:36.990] - result already collected: FutureResult
[10:59:36.990] result() for ClusterFuture ... done
[10:59:36.990] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:36.990] - nx: 2
[10:59:36.990] - relay: TRUE
[10:59:36.990] - stdout: TRUE
[10:59:36.990] - signal: TRUE
[10:59:36.990] - resignal: FALSE
[10:59:36.990] - force: TRUE
[10:59:36.990] - relayed: [n=2] FALSE, FALSE
[10:59:36.990] - queued futures: [n=2] FALSE, FALSE
[10:59:36.991]  - until=1
[10:59:36.991]  - relaying element #1
[10:59:36.991] result() for ClusterFuture ...
[10:59:36.991] - result already collected: FutureResult
[10:59:36.991] result() for ClusterFuture ... done
[10:59:36.991] result() for ClusterFuture ...
[10:59:36.991] - result already collected: FutureResult
[10:59:36.991] result() for ClusterFuture ... done
[10:59:36.991] result() for ClusterFuture ...
[10:59:36.991] - result already collected: FutureResult
[10:59:36.991] result() for ClusterFuture ... done
[10:59:36.992] result() for ClusterFuture ...
[10:59:36.992] - result already collected: FutureResult
[10:59:36.992] result() for ClusterFuture ... done
[10:59:36.992] - relayed: [n=2] TRUE, FALSE
[10:59:36.992] - queued futures: [n=2] TRUE, FALSE
[10:59:36.992] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:36.992]  length: 1 (resolved future 1)
[10:59:37.018] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.018] - Validating connection of MultisessionFuture
[10:59:37.018] - received message: FutureResult
[10:59:37.019] - Received FutureResult
[10:59:37.019] - Erased future from FutureRegistry
[10:59:37.019] result() for ClusterFuture ...
[10:59:37.019] - result already collected: FutureResult
[10:59:37.019] result() for ClusterFuture ... done
[10:59:37.019] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.019] Future #2
[10:59:37.019] result() for ClusterFuture ...
[10:59:37.019] - result already collected: FutureResult
[10:59:37.019] result() for ClusterFuture ... done
[10:59:37.019] result() for ClusterFuture ...
[10:59:37.020] - result already collected: FutureResult
[10:59:37.020] result() for ClusterFuture ... done
[10:59:37.020] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:37.020] - nx: 2
[10:59:37.020] - relay: TRUE
[10:59:37.020] - stdout: TRUE
[10:59:37.020] - signal: TRUE
[10:59:37.020] - resignal: FALSE
[10:59:37.020] - force: TRUE
[10:59:37.020] - relayed: [n=2] TRUE, FALSE
[10:59:37.020] - queued futures: [n=2] TRUE, FALSE
[10:59:37.020]  - until=2
[10:59:37.021]  - relaying element #2
[10:59:37.021] result() for ClusterFuture ...
[10:59:37.021] - result already collected: FutureResult
[10:59:37.021] result() for ClusterFuture ... done
[10:59:37.021] result() for ClusterFuture ...
[10:59:37.021] - result already collected: FutureResult
[10:59:37.021] result() for ClusterFuture ... done
[10:59:37.021] result() for ClusterFuture ...
[10:59:37.021] - result already collected: FutureResult
[10:59:37.021] result() for ClusterFuture ... done
[10:59:37.021] result() for ClusterFuture ...
[10:59:37.021] - result already collected: FutureResult
[10:59:37.022] result() for ClusterFuture ... done
[10:59:37.022] - relayed: [n=2] TRUE, TRUE
[10:59:37.022] - queued futures: [n=2] TRUE, TRUE
[10:59:37.022] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:37.022]  length: 0 (resolved future 2)
[10:59:37.022] Relaying remaining futures
[10:59:37.022] signalConditionsASAP(NULL, pos=0) ...
[10:59:37.022] - nx: 2
[10:59:37.022] - relay: TRUE
[10:59:37.022] - stdout: TRUE
[10:59:37.022] - signal: TRUE
[10:59:37.022] - resignal: FALSE
[10:59:37.022] - force: TRUE
[10:59:37.023] - relayed: [n=2] TRUE, TRUE
[10:59:37.023] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:37.023] - relayed: [n=2] TRUE, TRUE
[10:59:37.023] - queued futures: [n=2] TRUE, TRUE
[10:59:37.023] signalConditionsASAP(NULL, pos=0) ... done
[10:59:37.023] resolve() on list ... DONE
[10:59:37.023] result() for ClusterFuture ...
[10:59:37.023] - result already collected: FutureResult
[10:59:37.023] result() for ClusterFuture ... done
[10:59:37.023] result() for ClusterFuture ...
[10:59:37.023] - result already collected: FutureResult
[10:59:37.023] result() for ClusterFuture ... done
[10:59:37.024] result() for ClusterFuture ...
[10:59:37.024] - result already collected: FutureResult
[10:59:37.024] result() for ClusterFuture ... done
[10:59:37.024] result() for ClusterFuture ...
[10:59:37.024] - result already collected: FutureResult
[10:59:37.024] result() for ClusterFuture ... done
[10:59:37.024]  - Number of value chunks collected: 2
[10:59:37.024] Resolving 2 futures (chunks) ... DONE
[10:59:37.024] Reducing values from 2 chunks ...
[10:59:37.024]  - Number of values collected after concatenation: 4
[10:59:37.024]  - Number of values expected: 4
[10:59:37.024] Reducing values from 2 chunks ... DONE
[10:59:37.025] future_mapply() ... DONE
- Parallel RNG ...
[10:59:37.025] future_mapply() ...
[10:59:37.025] Generating random seeds ...
[10:59:37.025] Generating random seed streams for 4 elements ...
[10:59:37.025] Generating random seed streams for 4 elements ... DONE
[10:59:37.025] Generating random seeds ... DONE
[10:59:37.025] Will set RNG state on exit: 10407, 979643426, -1627768305, -1576673873, -1327431359, -1555208757, -974965261
[10:59:37.027] Number of chunks: 2
[10:59:37.027] getGlobalsAndPackagesXApply() ...
[10:59:37.027]  - future.globals: TRUE
[10:59:37.027] getGlobalsAndPackages() ...
[10:59:37.027] Searching for globals...
[10:59:37.028] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:59:37.028] Searching for globals ... DONE
[10:59:37.028] Resolving globals: FALSE
[10:59:37.029] The total size of the 1 globals is 501 bytes (501 bytes)
[10:59:37.029] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:59:37.029] - globals: [1] ‘FUN’
[10:59:37.029] - packages: [1] ‘stats’
[10:59:37.029] getGlobalsAndPackages() ... DONE
[10:59:37.030]  - globals found/used: [n=1] ‘FUN’
[10:59:37.030]  - needed namespaces: [n=1] ‘stats’
[10:59:37.030] Finding globals ... DONE
[10:59:37.030] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:37.030] List of 2
[10:59:37.030]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:59:37.030]  $ MoreArgs     :List of 1
[10:59:37.030]   ..$ min: num 1
[10:59:37.030]  - attr(*, "where")=List of 2
[10:59:37.030]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:37.030]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:37.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:37.030]  - attr(*, "resolved")= logi FALSE
[10:59:37.030]  - attr(*, "total_size")= num NA
[10:59:37.033] Packages to be attached in all futures: [n=1] ‘stats’
[10:59:37.033] getGlobalsAndPackagesXApply() ... DONE
[10:59:37.033] Number of futures (= number of chunks): 2
[10:59:37.033] Launching 2 futures (chunks) ...
[10:59:37.033] Chunk #1 of 2 ...
[10:59:37.033]  - Finding globals in '...' for chunk #1 ...
[10:59:37.033] getGlobalsAndPackages() ...
[10:59:37.033] Searching for globals...
[10:59:37.034] 
[10:59:37.034] Searching for globals ... DONE
[10:59:37.034] - globals: [0] <none>
[10:59:37.034] getGlobalsAndPackages() ... DONE
[10:59:37.034]    + additional globals found: [n=0] 
[10:59:37.034]    + additional namespaces needed: [n=0] 
[10:59:37.034]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:37.034]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.034]  - seeds: [2] <seeds>
[10:59:37.035]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.035] getGlobalsAndPackages() ...
[10:59:37.035] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.035] Resolving globals: FALSE
[10:59:37.035] The total size of the 5 globals is 870 bytes (870 bytes)
[10:59:37.036] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:59:37.036] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.036] - packages: [1] ‘stats’
[10:59:37.036] getGlobalsAndPackages() ... DONE
[10:59:37.036] run() for ‘Future’ ...
[10:59:37.036] - state: ‘created’
[10:59:37.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.050] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.050]   - Field: ‘node’
[10:59:37.050]   - Field: ‘label’
[10:59:37.050]   - Field: ‘local’
[10:59:37.050]   - Field: ‘owner’
[10:59:37.050]   - Field: ‘envir’
[10:59:37.051]   - Field: ‘workers’
[10:59:37.051]   - Field: ‘packages’
[10:59:37.051]   - Field: ‘gc’
[10:59:37.051]   - Field: ‘conditions’
[10:59:37.051]   - Field: ‘persistent’
[10:59:37.051]   - Field: ‘expr’
[10:59:37.051]   - Field: ‘uuid’
[10:59:37.051]   - Field: ‘seed’
[10:59:37.051]   - Field: ‘version’
[10:59:37.051]   - Field: ‘result’
[10:59:37.051]   - Field: ‘asynchronous’
[10:59:37.052]   - Field: ‘calls’
[10:59:37.052]   - Field: ‘globals’
[10:59:37.052]   - Field: ‘stdout’
[10:59:37.052]   - Field: ‘earlySignal’
[10:59:37.052]   - Field: ‘lazy’
[10:59:37.052]   - Field: ‘state’
[10:59:37.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.052] - Launch lazy future ...
[10:59:37.052] Packages needed by the future expression (n = 1): ‘stats’
[10:59:37.053] Packages needed by future strategies (n = 0): <none>
[10:59:37.053] {
[10:59:37.053]     {
[10:59:37.053]         {
[10:59:37.053]             ...future.startTime <- base::Sys.time()
[10:59:37.053]             {
[10:59:37.053]                 {
[10:59:37.053]                   {
[10:59:37.053]                     {
[10:59:37.053]                       {
[10:59:37.053]                         base::local({
[10:59:37.053]                           has_future <- base::requireNamespace("future", 
[10:59:37.053]                             quietly = TRUE)
[10:59:37.053]                           if (has_future) {
[10:59:37.053]                             ns <- base::getNamespace("future")
[10:59:37.053]                             version <- ns[[".package"]][["version"]]
[10:59:37.053]                             if (is.null(version)) 
[10:59:37.053]                               version <- utils::packageVersion("future")
[10:59:37.053]                           }
[10:59:37.053]                           else {
[10:59:37.053]                             version <- NULL
[10:59:37.053]                           }
[10:59:37.053]                           if (!has_future || version < "1.8.0") {
[10:59:37.053]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.053]                               "", base::R.version$version.string), 
[10:59:37.053]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:37.053]                                 base::R.version$platform, 8 * 
[10:59:37.053]                                   base::.Machine$sizeof.pointer), 
[10:59:37.053]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.053]                                 "release", "version")], collapse = " "), 
[10:59:37.053]                               hostname = base::Sys.info()[["nodename"]])
[10:59:37.053]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.053]                               info)
[10:59:37.053]                             info <- base::paste(info, collapse = "; ")
[10:59:37.053]                             if (!has_future) {
[10:59:37.053]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.053]                                 info)
[10:59:37.053]                             }
[10:59:37.053]                             else {
[10:59:37.053]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.053]                                 info, version)
[10:59:37.053]                             }
[10:59:37.053]                             base::stop(msg)
[10:59:37.053]                           }
[10:59:37.053]                         })
[10:59:37.053]                       }
[10:59:37.053]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.053]                       base::options(mc.cores = 1L)
[10:59:37.053]                     }
[10:59:37.053]                     base::local({
[10:59:37.053]                       for (pkg in "stats") {
[10:59:37.053]                         base::loadNamespace(pkg)
[10:59:37.053]                         base::library(pkg, character.only = TRUE)
[10:59:37.053]                       }
[10:59:37.053]                     })
[10:59:37.053]                   }
[10:59:37.053]                   ...future.strategy.old <- future::plan("list")
[10:59:37.053]                   options(future.plan = NULL)
[10:59:37.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.053]                 }
[10:59:37.053]                 ...future.workdir <- getwd()
[10:59:37.053]             }
[10:59:37.053]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.053]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.053]         }
[10:59:37.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.053]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.053]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.053]             base::names(...future.oldOptions))
[10:59:37.053]     }
[10:59:37.053]     if (FALSE) {
[10:59:37.053]     }
[10:59:37.053]     else {
[10:59:37.053]         if (TRUE) {
[10:59:37.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.053]                 open = "w")
[10:59:37.053]         }
[10:59:37.053]         else {
[10:59:37.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.053]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.053]         }
[10:59:37.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.053]             base::sink(type = "output", split = FALSE)
[10:59:37.053]             base::close(...future.stdout)
[10:59:37.053]         }, add = TRUE)
[10:59:37.053]     }
[10:59:37.053]     ...future.frame <- base::sys.nframe()
[10:59:37.053]     ...future.conditions <- base::list()
[10:59:37.053]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.053]     if (FALSE) {
[10:59:37.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.053]     }
[10:59:37.053]     ...future.result <- base::tryCatch({
[10:59:37.053]         base::withCallingHandlers({
[10:59:37.053]             ...future.value <- base::withVisible(base::local({
[10:59:37.053]                 ...future.makeSendCondition <- base::local({
[10:59:37.053]                   sendCondition <- NULL
[10:59:37.053]                   function(frame = 1L) {
[10:59:37.053]                     if (is.function(sendCondition)) 
[10:59:37.053]                       return(sendCondition)
[10:59:37.053]                     ns <- getNamespace("parallel")
[10:59:37.053]                     if (exists("sendData", mode = "function", 
[10:59:37.053]                       envir = ns)) {
[10:59:37.053]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.053]                         envir = ns)
[10:59:37.053]                       envir <- sys.frame(frame)
[10:59:37.053]                       master <- NULL
[10:59:37.053]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.053]                         !identical(envir, emptyenv())) {
[10:59:37.053]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.053]                           inherits = FALSE)) {
[10:59:37.053]                           master <- get("master", mode = "list", 
[10:59:37.053]                             envir = envir, inherits = FALSE)
[10:59:37.053]                           if (inherits(master, c("SOCKnode", 
[10:59:37.053]                             "SOCK0node"))) {
[10:59:37.053]                             sendCondition <<- function(cond) {
[10:59:37.053]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.053]                                 success = TRUE)
[10:59:37.053]                               parallel_sendData(master, data)
[10:59:37.053]                             }
[10:59:37.053]                             return(sendCondition)
[10:59:37.053]                           }
[10:59:37.053]                         }
[10:59:37.053]                         frame <- frame + 1L
[10:59:37.053]                         envir <- sys.frame(frame)
[10:59:37.053]                       }
[10:59:37.053]                     }
[10:59:37.053]                     sendCondition <<- function(cond) NULL
[10:59:37.053]                   }
[10:59:37.053]                 })
[10:59:37.053]                 withCallingHandlers({
[10:59:37.053]                   {
[10:59:37.053]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.053]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.053]                       ...future.globals.maxSize)) {
[10:59:37.053]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.053]                       on.exit(options(oopts), add = TRUE)
[10:59:37.053]                     }
[10:59:37.053]                     {
[10:59:37.053]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:37.053]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:37.053]                           envir = globalenv(), inherits = FALSE)
[10:59:37.053]                         ...future.FUN(...)
[10:59:37.053]                       }
[10:59:37.053]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:37.053]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:37.053]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.053]                         USE.NAMES = FALSE)
[10:59:37.053]                       do.call(mapply, args = args)
[10:59:37.053]                     }
[10:59:37.053]                   }
[10:59:37.053]                 }, immediateCondition = function(cond) {
[10:59:37.053]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.053]                   sendCondition(cond)
[10:59:37.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.053]                   {
[10:59:37.053]                     inherits <- base::inherits
[10:59:37.053]                     invokeRestart <- base::invokeRestart
[10:59:37.053]                     is.null <- base::is.null
[10:59:37.053]                     muffled <- FALSE
[10:59:37.053]                     if (inherits(cond, "message")) {
[10:59:37.053]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.053]                       if (muffled) 
[10:59:37.053]                         invokeRestart("muffleMessage")
[10:59:37.053]                     }
[10:59:37.053]                     else if (inherits(cond, "warning")) {
[10:59:37.053]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.053]                       if (muffled) 
[10:59:37.053]                         invokeRestart("muffleWarning")
[10:59:37.053]                     }
[10:59:37.053]                     else if (inherits(cond, "condition")) {
[10:59:37.053]                       if (!is.null(pattern)) {
[10:59:37.053]                         computeRestarts <- base::computeRestarts
[10:59:37.053]                         grepl <- base::grepl
[10:59:37.053]                         restarts <- computeRestarts(cond)
[10:59:37.053]                         for (restart in restarts) {
[10:59:37.053]                           name <- restart$name
[10:59:37.053]                           if (is.null(name)) 
[10:59:37.053]                             next
[10:59:37.053]                           if (!grepl(pattern, name)) 
[10:59:37.053]                             next
[10:59:37.053]                           invokeRestart(restart)
[10:59:37.053]                           muffled <- TRUE
[10:59:37.053]                           break
[10:59:37.053]                         }
[10:59:37.053]                       }
[10:59:37.053]                     }
[10:59:37.053]                     invisible(muffled)
[10:59:37.053]                   }
[10:59:37.053]                   muffleCondition(cond)
[10:59:37.053]                 })
[10:59:37.053]             }))
[10:59:37.053]             future::FutureResult(value = ...future.value$value, 
[10:59:37.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.053]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.053]                     ...future.globalenv.names))
[10:59:37.053]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.053]         }, condition = base::local({
[10:59:37.053]             c <- base::c
[10:59:37.053]             inherits <- base::inherits
[10:59:37.053]             invokeRestart <- base::invokeRestart
[10:59:37.053]             length <- base::length
[10:59:37.053]             list <- base::list
[10:59:37.053]             seq.int <- base::seq.int
[10:59:37.053]             signalCondition <- base::signalCondition
[10:59:37.053]             sys.calls <- base::sys.calls
[10:59:37.053]             `[[` <- base::`[[`
[10:59:37.053]             `+` <- base::`+`
[10:59:37.053]             `<<-` <- base::`<<-`
[10:59:37.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.053]                   3L)]
[10:59:37.053]             }
[10:59:37.053]             function(cond) {
[10:59:37.053]                 is_error <- inherits(cond, "error")
[10:59:37.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.053]                   NULL)
[10:59:37.053]                 if (is_error) {
[10:59:37.053]                   sessionInformation <- function() {
[10:59:37.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.053]                       search = base::search(), system = base::Sys.info())
[10:59:37.053]                   }
[10:59:37.053]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.053]                     cond$call), session = sessionInformation(), 
[10:59:37.053]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.053]                   signalCondition(cond)
[10:59:37.053]                 }
[10:59:37.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.053]                 "immediateCondition"))) {
[10:59:37.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.053]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.053]                   if (TRUE && !signal) {
[10:59:37.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.053]                     {
[10:59:37.053]                       inherits <- base::inherits
[10:59:37.053]                       invokeRestart <- base::invokeRestart
[10:59:37.053]                       is.null <- base::is.null
[10:59:37.053]                       muffled <- FALSE
[10:59:37.053]                       if (inherits(cond, "message")) {
[10:59:37.053]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.053]                         if (muffled) 
[10:59:37.053]                           invokeRestart("muffleMessage")
[10:59:37.053]                       }
[10:59:37.053]                       else if (inherits(cond, "warning")) {
[10:59:37.053]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.053]                         if (muffled) 
[10:59:37.053]                           invokeRestart("muffleWarning")
[10:59:37.053]                       }
[10:59:37.053]                       else if (inherits(cond, "condition")) {
[10:59:37.053]                         if (!is.null(pattern)) {
[10:59:37.053]                           computeRestarts <- base::computeRestarts
[10:59:37.053]                           grepl <- base::grepl
[10:59:37.053]                           restarts <- computeRestarts(cond)
[10:59:37.053]                           for (restart in restarts) {
[10:59:37.053]                             name <- restart$name
[10:59:37.053]                             if (is.null(name)) 
[10:59:37.053]                               next
[10:59:37.053]                             if (!grepl(pattern, name)) 
[10:59:37.053]                               next
[10:59:37.053]                             invokeRestart(restart)
[10:59:37.053]                             muffled <- TRUE
[10:59:37.053]                             break
[10:59:37.053]                           }
[10:59:37.053]                         }
[10:59:37.053]                       }
[10:59:37.053]                       invisible(muffled)
[10:59:37.053]                     }
[10:59:37.053]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.053]                   }
[10:59:37.053]                 }
[10:59:37.053]                 else {
[10:59:37.053]                   if (TRUE) {
[10:59:37.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.053]                     {
[10:59:37.053]                       inherits <- base::inherits
[10:59:37.053]                       invokeRestart <- base::invokeRestart
[10:59:37.053]                       is.null <- base::is.null
[10:59:37.053]                       muffled <- FALSE
[10:59:37.053]                       if (inherits(cond, "message")) {
[10:59:37.053]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.053]                         if (muffled) 
[10:59:37.053]                           invokeRestart("muffleMessage")
[10:59:37.053]                       }
[10:59:37.053]                       else if (inherits(cond, "warning")) {
[10:59:37.053]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.053]                         if (muffled) 
[10:59:37.053]                           invokeRestart("muffleWarning")
[10:59:37.053]                       }
[10:59:37.053]                       else if (inherits(cond, "condition")) {
[10:59:37.053]                         if (!is.null(pattern)) {
[10:59:37.053]                           computeRestarts <- base::computeRestarts
[10:59:37.053]                           grepl <- base::grepl
[10:59:37.053]                           restarts <- computeRestarts(cond)
[10:59:37.053]                           for (restart in restarts) {
[10:59:37.053]                             name <- restart$name
[10:59:37.053]                             if (is.null(name)) 
[10:59:37.053]                               next
[10:59:37.053]                             if (!grepl(pattern, name)) 
[10:59:37.053]                               next
[10:59:37.053]                             invokeRestart(restart)
[10:59:37.053]                             muffled <- TRUE
[10:59:37.053]                             break
[10:59:37.053]                           }
[10:59:37.053]                         }
[10:59:37.053]                       }
[10:59:37.053]                       invisible(muffled)
[10:59:37.053]                     }
[10:59:37.053]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.053]                   }
[10:59:37.053]                 }
[10:59:37.053]             }
[10:59:37.053]         }))
[10:59:37.053]     }, error = function(ex) {
[10:59:37.053]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.053]                 ...future.rng), started = ...future.startTime, 
[10:59:37.053]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.053]             version = "1.8"), class = "FutureResult")
[10:59:37.053]     }, finally = {
[10:59:37.053]         if (!identical(...future.workdir, getwd())) 
[10:59:37.053]             setwd(...future.workdir)
[10:59:37.053]         {
[10:59:37.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.053]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.053]             }
[10:59:37.053]             base::options(...future.oldOptions)
[10:59:37.053]             if (.Platform$OS.type == "windows") {
[10:59:37.053]                 old_names <- names(...future.oldEnvVars)
[10:59:37.053]                 envs <- base::Sys.getenv()
[10:59:37.053]                 names <- names(envs)
[10:59:37.053]                 common <- intersect(names, old_names)
[10:59:37.053]                 added <- setdiff(names, old_names)
[10:59:37.053]                 removed <- setdiff(old_names, names)
[10:59:37.053]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.053]                   envs[common]]
[10:59:37.053]                 NAMES <- toupper(changed)
[10:59:37.053]                 args <- list()
[10:59:37.053]                 for (kk in seq_along(NAMES)) {
[10:59:37.053]                   name <- changed[[kk]]
[10:59:37.053]                   NAME <- NAMES[[kk]]
[10:59:37.053]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.053]                     next
[10:59:37.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.053]                 }
[10:59:37.053]                 NAMES <- toupper(added)
[10:59:37.053]                 for (kk in seq_along(NAMES)) {
[10:59:37.053]                   name <- added[[kk]]
[10:59:37.053]                   NAME <- NAMES[[kk]]
[10:59:37.053]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.053]                     next
[10:59:37.053]                   args[[name]] <- ""
[10:59:37.053]                 }
[10:59:37.053]                 NAMES <- toupper(removed)
[10:59:37.053]                 for (kk in seq_along(NAMES)) {
[10:59:37.053]                   name <- removed[[kk]]
[10:59:37.053]                   NAME <- NAMES[[kk]]
[10:59:37.053]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.053]                     next
[10:59:37.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.053]                 }
[10:59:37.053]                 if (length(args) > 0) 
[10:59:37.053]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.053]             }
[10:59:37.053]             else {
[10:59:37.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.053]             }
[10:59:37.053]             {
[10:59:37.053]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.053]                   0L) {
[10:59:37.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.053]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.053]                   base::options(opts)
[10:59:37.053]                 }
[10:59:37.053]                 {
[10:59:37.053]                   {
[10:59:37.053]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.053]                     NULL
[10:59:37.053]                   }
[10:59:37.053]                   options(future.plan = NULL)
[10:59:37.053]                   if (is.na(NA_character_)) 
[10:59:37.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.053]                     .init = FALSE)
[10:59:37.053]                 }
[10:59:37.053]             }
[10:59:37.053]         }
[10:59:37.053]     })
[10:59:37.053]     if (TRUE) {
[10:59:37.053]         base::sink(type = "output", split = FALSE)
[10:59:37.053]         if (TRUE) {
[10:59:37.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.053]         }
[10:59:37.053]         else {
[10:59:37.053]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.053]         }
[10:59:37.053]         base::close(...future.stdout)
[10:59:37.053]         ...future.stdout <- NULL
[10:59:37.053]     }
[10:59:37.053]     ...future.result$conditions <- ...future.conditions
[10:59:37.053]     ...future.result$finished <- base::Sys.time()
[10:59:37.053]     ...future.result
[10:59:37.053] }
[10:59:37.056] Exporting 5 global objects (1.26 KiB) to cluster node #1 ...
[10:59:37.056] Exporting ‘...future.FUN’ (501 bytes) to cluster node #1 ...
[10:59:37.056] Exporting ‘...future.FUN’ (501 bytes) to cluster node #1 ... DONE
[10:59:37.057] Exporting ‘MoreArgs’ (91 bytes) to cluster node #1 ...
[10:59:37.057] Exporting ‘MoreArgs’ (91 bytes) to cluster node #1 ... DONE
[10:59:37.057] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #1 ...
[10:59:37.057] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #1 ... DONE
[10:59:37.057] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #1 ...
[10:59:37.058] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #1 ... DONE
[10:59:37.058] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:37.058] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.058] Exporting 5 global objects (1.26 KiB) to cluster node #1 ... DONE
[10:59:37.059] MultisessionFuture started
[10:59:37.059] - Launch lazy future ... done
[10:59:37.059] run() for ‘MultisessionFuture’ ... done
[10:59:37.059] Created future:
[10:59:37.059] MultisessionFuture:
[10:59:37.059] Label: ‘future_mapply-1’
[10:59:37.059] Expression:
[10:59:37.059] {
[10:59:37.059]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.059]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.059]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.059]         on.exit(options(oopts), add = TRUE)
[10:59:37.059]     }
[10:59:37.059]     {
[10:59:37.059]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:37.059]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:37.059]                 inherits = FALSE)
[10:59:37.059]             ...future.FUN(...)
[10:59:37.059]         }
[10:59:37.059]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:37.059]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:37.059]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.059]         do.call(mapply, args = args)
[10:59:37.059]     }
[10:59:37.059] }
[10:59:37.059] Lazy evaluation: FALSE
[10:59:37.059] Asynchronous evaluation: TRUE
[10:59:37.059] Local evaluation: TRUE
[10:59:37.059] Environment: R_GlobalEnv
[10:59:37.059] Capture standard output: TRUE
[10:59:37.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.059] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.059] Packages: 1 packages (‘stats’)
[10:59:37.059] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:37.059] Resolved: FALSE
[10:59:37.059] Value: <not collected>
[10:59:37.059] Conditions captured: <none>
[10:59:37.059] Early signaling: FALSE
[10:59:37.059] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.059] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.071] Chunk #1 of 2 ... DONE
[10:59:37.071] Chunk #2 of 2 ...
[10:59:37.071]  - Finding globals in '...' for chunk #2 ...
[10:59:37.071] getGlobalsAndPackages() ...
[10:59:37.071] Searching for globals...
[10:59:37.071] 
[10:59:37.071] Searching for globals ... DONE
[10:59:37.072] - globals: [0] <none>
[10:59:37.072] getGlobalsAndPackages() ... DONE
[10:59:37.072]    + additional globals found: [n=0] 
[10:59:37.072]    + additional namespaces needed: [n=0] 
[10:59:37.072]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:37.072]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.072]  - seeds: [2] <seeds>
[10:59:37.072]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.072] getGlobalsAndPackages() ...
[10:59:37.072] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.072] Resolving globals: FALSE
[10:59:37.073] The total size of the 5 globals is 870 bytes (870 bytes)
[10:59:37.073] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:59:37.073] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.074] - packages: [1] ‘stats’
[10:59:37.074] getGlobalsAndPackages() ... DONE
[10:59:37.074] run() for ‘Future’ ...
[10:59:37.074] - state: ‘created’
[10:59:37.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.088] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.088]   - Field: ‘node’
[10:59:37.088]   - Field: ‘label’
[10:59:37.088]   - Field: ‘local’
[10:59:37.088]   - Field: ‘owner’
[10:59:37.088]   - Field: ‘envir’
[10:59:37.088]   - Field: ‘workers’
[10:59:37.088]   - Field: ‘packages’
[10:59:37.088]   - Field: ‘gc’
[10:59:37.089]   - Field: ‘conditions’
[10:59:37.089]   - Field: ‘persistent’
[10:59:37.089]   - Field: ‘expr’
[10:59:37.089]   - Field: ‘uuid’
[10:59:37.089]   - Field: ‘seed’
[10:59:37.089]   - Field: ‘version’
[10:59:37.089]   - Field: ‘result’
[10:59:37.089]   - Field: ‘asynchronous’
[10:59:37.089]   - Field: ‘calls’
[10:59:37.089]   - Field: ‘globals’
[10:59:37.089]   - Field: ‘stdout’
[10:59:37.089]   - Field: ‘earlySignal’
[10:59:37.090]   - Field: ‘lazy’
[10:59:37.090]   - Field: ‘state’
[10:59:37.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.090] - Launch lazy future ...
[10:59:37.090] Packages needed by the future expression (n = 1): ‘stats’
[10:59:37.090] Packages needed by future strategies (n = 0): <none>
[10:59:37.091] {
[10:59:37.091]     {
[10:59:37.091]         {
[10:59:37.091]             ...future.startTime <- base::Sys.time()
[10:59:37.091]             {
[10:59:37.091]                 {
[10:59:37.091]                   {
[10:59:37.091]                     {
[10:59:37.091]                       {
[10:59:37.091]                         base::local({
[10:59:37.091]                           has_future <- base::requireNamespace("future", 
[10:59:37.091]                             quietly = TRUE)
[10:59:37.091]                           if (has_future) {
[10:59:37.091]                             ns <- base::getNamespace("future")
[10:59:37.091]                             version <- ns[[".package"]][["version"]]
[10:59:37.091]                             if (is.null(version)) 
[10:59:37.091]                               version <- utils::packageVersion("future")
[10:59:37.091]                           }
[10:59:37.091]                           else {
[10:59:37.091]                             version <- NULL
[10:59:37.091]                           }
[10:59:37.091]                           if (!has_future || version < "1.8.0") {
[10:59:37.091]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.091]                               "", base::R.version$version.string), 
[10:59:37.091]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:37.091]                                 base::R.version$platform, 8 * 
[10:59:37.091]                                   base::.Machine$sizeof.pointer), 
[10:59:37.091]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.091]                                 "release", "version")], collapse = " "), 
[10:59:37.091]                               hostname = base::Sys.info()[["nodename"]])
[10:59:37.091]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.091]                               info)
[10:59:37.091]                             info <- base::paste(info, collapse = "; ")
[10:59:37.091]                             if (!has_future) {
[10:59:37.091]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.091]                                 info)
[10:59:37.091]                             }
[10:59:37.091]                             else {
[10:59:37.091]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.091]                                 info, version)
[10:59:37.091]                             }
[10:59:37.091]                             base::stop(msg)
[10:59:37.091]                           }
[10:59:37.091]                         })
[10:59:37.091]                       }
[10:59:37.091]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.091]                       base::options(mc.cores = 1L)
[10:59:37.091]                     }
[10:59:37.091]                     base::local({
[10:59:37.091]                       for (pkg in "stats") {
[10:59:37.091]                         base::loadNamespace(pkg)
[10:59:37.091]                         base::library(pkg, character.only = TRUE)
[10:59:37.091]                       }
[10:59:37.091]                     })
[10:59:37.091]                   }
[10:59:37.091]                   ...future.strategy.old <- future::plan("list")
[10:59:37.091]                   options(future.plan = NULL)
[10:59:37.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.091]                 }
[10:59:37.091]                 ...future.workdir <- getwd()
[10:59:37.091]             }
[10:59:37.091]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.091]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.091]         }
[10:59:37.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.091]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.091]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.091]             base::names(...future.oldOptions))
[10:59:37.091]     }
[10:59:37.091]     if (FALSE) {
[10:59:37.091]     }
[10:59:37.091]     else {
[10:59:37.091]         if (TRUE) {
[10:59:37.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.091]                 open = "w")
[10:59:37.091]         }
[10:59:37.091]         else {
[10:59:37.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.091]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.091]         }
[10:59:37.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.091]             base::sink(type = "output", split = FALSE)
[10:59:37.091]             base::close(...future.stdout)
[10:59:37.091]         }, add = TRUE)
[10:59:37.091]     }
[10:59:37.091]     ...future.frame <- base::sys.nframe()
[10:59:37.091]     ...future.conditions <- base::list()
[10:59:37.091]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.091]     if (FALSE) {
[10:59:37.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.091]     }
[10:59:37.091]     ...future.result <- base::tryCatch({
[10:59:37.091]         base::withCallingHandlers({
[10:59:37.091]             ...future.value <- base::withVisible(base::local({
[10:59:37.091]                 ...future.makeSendCondition <- base::local({
[10:59:37.091]                   sendCondition <- NULL
[10:59:37.091]                   function(frame = 1L) {
[10:59:37.091]                     if (is.function(sendCondition)) 
[10:59:37.091]                       return(sendCondition)
[10:59:37.091]                     ns <- getNamespace("parallel")
[10:59:37.091]                     if (exists("sendData", mode = "function", 
[10:59:37.091]                       envir = ns)) {
[10:59:37.091]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.091]                         envir = ns)
[10:59:37.091]                       envir <- sys.frame(frame)
[10:59:37.091]                       master <- NULL
[10:59:37.091]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.091]                         !identical(envir, emptyenv())) {
[10:59:37.091]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.091]                           inherits = FALSE)) {
[10:59:37.091]                           master <- get("master", mode = "list", 
[10:59:37.091]                             envir = envir, inherits = FALSE)
[10:59:37.091]                           if (inherits(master, c("SOCKnode", 
[10:59:37.091]                             "SOCK0node"))) {
[10:59:37.091]                             sendCondition <<- function(cond) {
[10:59:37.091]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.091]                                 success = TRUE)
[10:59:37.091]                               parallel_sendData(master, data)
[10:59:37.091]                             }
[10:59:37.091]                             return(sendCondition)
[10:59:37.091]                           }
[10:59:37.091]                         }
[10:59:37.091]                         frame <- frame + 1L
[10:59:37.091]                         envir <- sys.frame(frame)
[10:59:37.091]                       }
[10:59:37.091]                     }
[10:59:37.091]                     sendCondition <<- function(cond) NULL
[10:59:37.091]                   }
[10:59:37.091]                 })
[10:59:37.091]                 withCallingHandlers({
[10:59:37.091]                   {
[10:59:37.091]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.091]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.091]                       ...future.globals.maxSize)) {
[10:59:37.091]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.091]                       on.exit(options(oopts), add = TRUE)
[10:59:37.091]                     }
[10:59:37.091]                     {
[10:59:37.091]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:37.091]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:59:37.091]                           envir = globalenv(), inherits = FALSE)
[10:59:37.091]                         ...future.FUN(...)
[10:59:37.091]                       }
[10:59:37.091]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:37.091]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:37.091]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.091]                         USE.NAMES = FALSE)
[10:59:37.091]                       do.call(mapply, args = args)
[10:59:37.091]                     }
[10:59:37.091]                   }
[10:59:37.091]                 }, immediateCondition = function(cond) {
[10:59:37.091]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.091]                   sendCondition(cond)
[10:59:37.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.091]                   {
[10:59:37.091]                     inherits <- base::inherits
[10:59:37.091]                     invokeRestart <- base::invokeRestart
[10:59:37.091]                     is.null <- base::is.null
[10:59:37.091]                     muffled <- FALSE
[10:59:37.091]                     if (inherits(cond, "message")) {
[10:59:37.091]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.091]                       if (muffled) 
[10:59:37.091]                         invokeRestart("muffleMessage")
[10:59:37.091]                     }
[10:59:37.091]                     else if (inherits(cond, "warning")) {
[10:59:37.091]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.091]                       if (muffled) 
[10:59:37.091]                         invokeRestart("muffleWarning")
[10:59:37.091]                     }
[10:59:37.091]                     else if (inherits(cond, "condition")) {
[10:59:37.091]                       if (!is.null(pattern)) {
[10:59:37.091]                         computeRestarts <- base::computeRestarts
[10:59:37.091]                         grepl <- base::grepl
[10:59:37.091]                         restarts <- computeRestarts(cond)
[10:59:37.091]                         for (restart in restarts) {
[10:59:37.091]                           name <- restart$name
[10:59:37.091]                           if (is.null(name)) 
[10:59:37.091]                             next
[10:59:37.091]                           if (!grepl(pattern, name)) 
[10:59:37.091]                             next
[10:59:37.091]                           invokeRestart(restart)
[10:59:37.091]                           muffled <- TRUE
[10:59:37.091]                           break
[10:59:37.091]                         }
[10:59:37.091]                       }
[10:59:37.091]                     }
[10:59:37.091]                     invisible(muffled)
[10:59:37.091]                   }
[10:59:37.091]                   muffleCondition(cond)
[10:59:37.091]                 })
[10:59:37.091]             }))
[10:59:37.091]             future::FutureResult(value = ...future.value$value, 
[10:59:37.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.091]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.091]                     ...future.globalenv.names))
[10:59:37.091]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.091]         }, condition = base::local({
[10:59:37.091]             c <- base::c
[10:59:37.091]             inherits <- base::inherits
[10:59:37.091]             invokeRestart <- base::invokeRestart
[10:59:37.091]             length <- base::length
[10:59:37.091]             list <- base::list
[10:59:37.091]             seq.int <- base::seq.int
[10:59:37.091]             signalCondition <- base::signalCondition
[10:59:37.091]             sys.calls <- base::sys.calls
[10:59:37.091]             `[[` <- base::`[[`
[10:59:37.091]             `+` <- base::`+`
[10:59:37.091]             `<<-` <- base::`<<-`
[10:59:37.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.091]                   3L)]
[10:59:37.091]             }
[10:59:37.091]             function(cond) {
[10:59:37.091]                 is_error <- inherits(cond, "error")
[10:59:37.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.091]                   NULL)
[10:59:37.091]                 if (is_error) {
[10:59:37.091]                   sessionInformation <- function() {
[10:59:37.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.091]                       search = base::search(), system = base::Sys.info())
[10:59:37.091]                   }
[10:59:37.091]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.091]                     cond$call), session = sessionInformation(), 
[10:59:37.091]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.091]                   signalCondition(cond)
[10:59:37.091]                 }
[10:59:37.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.091]                 "immediateCondition"))) {
[10:59:37.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.091]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.091]                   if (TRUE && !signal) {
[10:59:37.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.091]                     {
[10:59:37.091]                       inherits <- base::inherits
[10:59:37.091]                       invokeRestart <- base::invokeRestart
[10:59:37.091]                       is.null <- base::is.null
[10:59:37.091]                       muffled <- FALSE
[10:59:37.091]                       if (inherits(cond, "message")) {
[10:59:37.091]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.091]                         if (muffled) 
[10:59:37.091]                           invokeRestart("muffleMessage")
[10:59:37.091]                       }
[10:59:37.091]                       else if (inherits(cond, "warning")) {
[10:59:37.091]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.091]                         if (muffled) 
[10:59:37.091]                           invokeRestart("muffleWarning")
[10:59:37.091]                       }
[10:59:37.091]                       else if (inherits(cond, "condition")) {
[10:59:37.091]                         if (!is.null(pattern)) {
[10:59:37.091]                           computeRestarts <- base::computeRestarts
[10:59:37.091]                           grepl <- base::grepl
[10:59:37.091]                           restarts <- computeRestarts(cond)
[10:59:37.091]                           for (restart in restarts) {
[10:59:37.091]                             name <- restart$name
[10:59:37.091]                             if (is.null(name)) 
[10:59:37.091]                               next
[10:59:37.091]                             if (!grepl(pattern, name)) 
[10:59:37.091]                               next
[10:59:37.091]                             invokeRestart(restart)
[10:59:37.091]                             muffled <- TRUE
[10:59:37.091]                             break
[10:59:37.091]                           }
[10:59:37.091]                         }
[10:59:37.091]                       }
[10:59:37.091]                       invisible(muffled)
[10:59:37.091]                     }
[10:59:37.091]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.091]                   }
[10:59:37.091]                 }
[10:59:37.091]                 else {
[10:59:37.091]                   if (TRUE) {
[10:59:37.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.091]                     {
[10:59:37.091]                       inherits <- base::inherits
[10:59:37.091]                       invokeRestart <- base::invokeRestart
[10:59:37.091]                       is.null <- base::is.null
[10:59:37.091]                       muffled <- FALSE
[10:59:37.091]                       if (inherits(cond, "message")) {
[10:59:37.091]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.091]                         if (muffled) 
[10:59:37.091]                           invokeRestart("muffleMessage")
[10:59:37.091]                       }
[10:59:37.091]                       else if (inherits(cond, "warning")) {
[10:59:37.091]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.091]                         if (muffled) 
[10:59:37.091]                           invokeRestart("muffleWarning")
[10:59:37.091]                       }
[10:59:37.091]                       else if (inherits(cond, "condition")) {
[10:59:37.091]                         if (!is.null(pattern)) {
[10:59:37.091]                           computeRestarts <- base::computeRestarts
[10:59:37.091]                           grepl <- base::grepl
[10:59:37.091]                           restarts <- computeRestarts(cond)
[10:59:37.091]                           for (restart in restarts) {
[10:59:37.091]                             name <- restart$name
[10:59:37.091]                             if (is.null(name)) 
[10:59:37.091]                               next
[10:59:37.091]                             if (!grepl(pattern, name)) 
[10:59:37.091]                               next
[10:59:37.091]                             invokeRestart(restart)
[10:59:37.091]                             muffled <- TRUE
[10:59:37.091]                             break
[10:59:37.091]                           }
[10:59:37.091]                         }
[10:59:37.091]                       }
[10:59:37.091]                       invisible(muffled)
[10:59:37.091]                     }
[10:59:37.091]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.091]                   }
[10:59:37.091]                 }
[10:59:37.091]             }
[10:59:37.091]         }))
[10:59:37.091]     }, error = function(ex) {
[10:59:37.091]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.091]                 ...future.rng), started = ...future.startTime, 
[10:59:37.091]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.091]             version = "1.8"), class = "FutureResult")
[10:59:37.091]     }, finally = {
[10:59:37.091]         if (!identical(...future.workdir, getwd())) 
[10:59:37.091]             setwd(...future.workdir)
[10:59:37.091]         {
[10:59:37.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.091]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.091]             }
[10:59:37.091]             base::options(...future.oldOptions)
[10:59:37.091]             if (.Platform$OS.type == "windows") {
[10:59:37.091]                 old_names <- names(...future.oldEnvVars)
[10:59:37.091]                 envs <- base::Sys.getenv()
[10:59:37.091]                 names <- names(envs)
[10:59:37.091]                 common <- intersect(names, old_names)
[10:59:37.091]                 added <- setdiff(names, old_names)
[10:59:37.091]                 removed <- setdiff(old_names, names)
[10:59:37.091]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.091]                   envs[common]]
[10:59:37.091]                 NAMES <- toupper(changed)
[10:59:37.091]                 args <- list()
[10:59:37.091]                 for (kk in seq_along(NAMES)) {
[10:59:37.091]                   name <- changed[[kk]]
[10:59:37.091]                   NAME <- NAMES[[kk]]
[10:59:37.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.091]                     next
[10:59:37.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.091]                 }
[10:59:37.091]                 NAMES <- toupper(added)
[10:59:37.091]                 for (kk in seq_along(NAMES)) {
[10:59:37.091]                   name <- added[[kk]]
[10:59:37.091]                   NAME <- NAMES[[kk]]
[10:59:37.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.091]                     next
[10:59:37.091]                   args[[name]] <- ""
[10:59:37.091]                 }
[10:59:37.091]                 NAMES <- toupper(removed)
[10:59:37.091]                 for (kk in seq_along(NAMES)) {
[10:59:37.091]                   name <- removed[[kk]]
[10:59:37.091]                   NAME <- NAMES[[kk]]
[10:59:37.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.091]                     next
[10:59:37.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.091]                 }
[10:59:37.091]                 if (length(args) > 0) 
[10:59:37.091]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.091]             }
[10:59:37.091]             else {
[10:59:37.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.091]             }
[10:59:37.091]             {
[10:59:37.091]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.091]                   0L) {
[10:59:37.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.091]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.091]                   base::options(opts)
[10:59:37.091]                 }
[10:59:37.091]                 {
[10:59:37.091]                   {
[10:59:37.091]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.091]                     NULL
[10:59:37.091]                   }
[10:59:37.091]                   options(future.plan = NULL)
[10:59:37.091]                   if (is.na(NA_character_)) 
[10:59:37.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.091]                     .init = FALSE)
[10:59:37.091]                 }
[10:59:37.091]             }
[10:59:37.091]         }
[10:59:37.091]     })
[10:59:37.091]     if (TRUE) {
[10:59:37.091]         base::sink(type = "output", split = FALSE)
[10:59:37.091]         if (TRUE) {
[10:59:37.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.091]         }
[10:59:37.091]         else {
[10:59:37.091]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.091]         }
[10:59:37.091]         base::close(...future.stdout)
[10:59:37.091]         ...future.stdout <- NULL
[10:59:37.091]     }
[10:59:37.091]     ...future.result$conditions <- ...future.conditions
[10:59:37.091]     ...future.result$finished <- base::Sys.time()
[10:59:37.091]     ...future.result
[10:59:37.091] }
[10:59:37.093] Exporting 5 global objects (1.26 KiB) to cluster node #2 ...
[10:59:37.094] Exporting ‘...future.FUN’ (501 bytes) to cluster node #2 ...
[10:59:37.094] Exporting ‘...future.FUN’ (501 bytes) to cluster node #2 ... DONE
[10:59:37.094] Exporting ‘MoreArgs’ (91 bytes) to cluster node #2 ...
[10:59:37.094] Exporting ‘MoreArgs’ (91 bytes) to cluster node #2 ... DONE
[10:59:37.095] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #2 ...
[10:59:37.095] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #2 ... DONE
[10:59:37.095] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #2 ...
[10:59:37.095] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #2 ... DONE
[10:59:37.096] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:37.096] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.096] Exporting 5 global objects (1.26 KiB) to cluster node #2 ... DONE
[10:59:37.097] MultisessionFuture started
[10:59:37.097] - Launch lazy future ... done
[10:59:37.097] run() for ‘MultisessionFuture’ ... done
[10:59:37.097] Created future:
[10:59:37.097] MultisessionFuture:
[10:59:37.097] Label: ‘future_mapply-2’
[10:59:37.097] Expression:
[10:59:37.097] {
[10:59:37.097]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.097]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.097]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.097]         on.exit(options(oopts), add = TRUE)
[10:59:37.097]     }
[10:59:37.097]     {
[10:59:37.097]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:59:37.097]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:59:37.097]                 inherits = FALSE)
[10:59:37.097]             ...future.FUN(...)
[10:59:37.097]         }
[10:59:37.097]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:59:37.097]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:59:37.097]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.097]         do.call(mapply, args = args)
[10:59:37.097]     }
[10:59:37.097] }
[10:59:37.097] Lazy evaluation: FALSE
[10:59:37.097] Asynchronous evaluation: TRUE
[10:59:37.097] Local evaluation: TRUE
[10:59:37.097] Environment: R_GlobalEnv
[10:59:37.097] Capture standard output: TRUE
[10:59:37.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.097] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.097] Packages: 1 packages (‘stats’)
[10:59:37.097] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:59:37.097] Resolved: FALSE
[10:59:37.097] Value: <not collected>
[10:59:37.097] Conditions captured: <none>
[10:59:37.097] Early signaling: FALSE
[10:59:37.097] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.097] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.111] Chunk #2 of 2 ... DONE
[10:59:37.111] Launching 2 futures (chunks) ... DONE
[10:59:37.111] Resolving 2 futures (chunks) ...
[10:59:37.111] resolve() on list ...
[10:59:37.111]  recursive: 0
[10:59:37.111]  length: 2
[10:59:37.111] 
[10:59:37.112] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.112] - Validating connection of MultisessionFuture
[10:59:37.112] - received message: FutureResult
[10:59:37.112] - Received FutureResult
[10:59:37.112] - Erased future from FutureRegistry
[10:59:37.112] result() for ClusterFuture ...
[10:59:37.112] - result already collected: FutureResult
[10:59:37.112] result() for ClusterFuture ... done
[10:59:37.112] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.113] Future #1
[10:59:37.113] result() for ClusterFuture ...
[10:59:37.113] - result already collected: FutureResult
[10:59:37.113] result() for ClusterFuture ... done
[10:59:37.113] result() for ClusterFuture ...
[10:59:37.113] - result already collected: FutureResult
[10:59:37.113] result() for ClusterFuture ... done
[10:59:37.113] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:37.113] - nx: 2
[10:59:37.113] - relay: TRUE
[10:59:37.113] - stdout: TRUE
[10:59:37.113] - signal: TRUE
[10:59:37.114] - resignal: FALSE
[10:59:37.114] - force: TRUE
[10:59:37.114] - relayed: [n=2] FALSE, FALSE
[10:59:37.114] - queued futures: [n=2] FALSE, FALSE
[10:59:37.114]  - until=1
[10:59:37.114]  - relaying element #1
[10:59:37.114] result() for ClusterFuture ...
[10:59:37.114] - result already collected: FutureResult
[10:59:37.114] result() for ClusterFuture ... done
[10:59:37.114] result() for ClusterFuture ...
[10:59:37.114] - result already collected: FutureResult
[10:59:37.114] result() for ClusterFuture ... done
[10:59:37.115] result() for ClusterFuture ...
[10:59:37.115] - result already collected: FutureResult
[10:59:37.115] result() for ClusterFuture ... done
[10:59:37.115] result() for ClusterFuture ...
[10:59:37.115] - result already collected: FutureResult
[10:59:37.115] result() for ClusterFuture ... done
[10:59:37.115] - relayed: [n=2] TRUE, FALSE
[10:59:37.115] - queued futures: [n=2] TRUE, FALSE
[10:59:37.115] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:37.115]  length: 1 (resolved future 1)
[10:59:37.138] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.139] - Validating connection of MultisessionFuture
[10:59:37.139] - received message: FutureResult
[10:59:37.139] - Received FutureResult
[10:59:37.139] - Erased future from FutureRegistry
[10:59:37.139] result() for ClusterFuture ...
[10:59:37.139] - result already collected: FutureResult
[10:59:37.139] result() for ClusterFuture ... done
[10:59:37.139] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.139] Future #2
[10:59:37.139] result() for ClusterFuture ...
[10:59:37.140] - result already collected: FutureResult
[10:59:37.140] result() for ClusterFuture ... done
[10:59:37.140] result() for ClusterFuture ...
[10:59:37.140] - result already collected: FutureResult
[10:59:37.140] result() for ClusterFuture ... done
[10:59:37.140] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:37.140] - nx: 2
[10:59:37.140] - relay: TRUE
[10:59:37.140] - stdout: TRUE
[10:59:37.140] - signal: TRUE
[10:59:37.140] - resignal: FALSE
[10:59:37.140] - force: TRUE
[10:59:37.140] - relayed: [n=2] TRUE, FALSE
[10:59:37.141] - queued futures: [n=2] TRUE, FALSE
[10:59:37.141]  - until=2
[10:59:37.141]  - relaying element #2
[10:59:37.141] result() for ClusterFuture ...
[10:59:37.141] - result already collected: FutureResult
[10:59:37.141] result() for ClusterFuture ... done
[10:59:37.141] result() for ClusterFuture ...
[10:59:37.141] - result already collected: FutureResult
[10:59:37.141] result() for ClusterFuture ... done
[10:59:37.141] result() for ClusterFuture ...
[10:59:37.141] - result already collected: FutureResult
[10:59:37.142] result() for ClusterFuture ... done
[10:59:37.142] result() for ClusterFuture ...
[10:59:37.142] - result already collected: FutureResult
[10:59:37.142] result() for ClusterFuture ... done
[10:59:37.142] - relayed: [n=2] TRUE, TRUE
[10:59:37.142] - queued futures: [n=2] TRUE, TRUE
[10:59:37.142] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:37.142]  length: 0 (resolved future 2)
[10:59:37.142] Relaying remaining futures
[10:59:37.142] signalConditionsASAP(NULL, pos=0) ...
[10:59:37.142] - nx: 2
[10:59:37.142] - relay: TRUE
[10:59:37.142] - stdout: TRUE
[10:59:37.143] - signal: TRUE
[10:59:37.143] - resignal: FALSE
[10:59:37.143] - force: TRUE
[10:59:37.143] - relayed: [n=2] TRUE, TRUE
[10:59:37.143] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:37.143] - relayed: [n=2] TRUE, TRUE
[10:59:37.143] - queued futures: [n=2] TRUE, TRUE
[10:59:37.143] signalConditionsASAP(NULL, pos=0) ... done
[10:59:37.143] resolve() on list ... DONE
[10:59:37.143] result() for ClusterFuture ...
[10:59:37.143] - result already collected: FutureResult
[10:59:37.143] result() for ClusterFuture ... done
[10:59:37.144] result() for ClusterFuture ...
[10:59:37.144] - result already collected: FutureResult
[10:59:37.144] result() for ClusterFuture ... done
[10:59:37.144] result() for ClusterFuture ...
[10:59:37.144] - result already collected: FutureResult
[10:59:37.144] result() for ClusterFuture ... done
[10:59:37.144] result() for ClusterFuture ...
[10:59:37.144] - result already collected: FutureResult
[10:59:37.144] result() for ClusterFuture ... done
[10:59:37.144]  - Number of value chunks collected: 2
[10:59:37.144] Resolving 2 futures (chunks) ... DONE
[10:59:37.144] Reducing values from 2 chunks ...
[10:59:37.144]  - Number of values collected after concatenation: 4
[10:59:37.145]  - Number of values expected: 4
[10:59:37.145] Reducing values from 2 chunks ... DONE
[10:59:37.145] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:59:37.145] future_mapply() ...
[10:59:37.147] Number of chunks: 2
[10:59:37.147] getGlobalsAndPackagesXApply() ...
[10:59:37.147]  - future.globals: TRUE
[10:59:37.147] getGlobalsAndPackages() ...
[10:59:37.147] Searching for globals...
[10:59:37.148] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:59:37.148] Searching for globals ... DONE
[10:59:37.148] Resolving globals: FALSE
[10:59:37.149] The total size of the 1 globals is 337 bytes (337 bytes)
[10:59:37.149] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[10:59:37.149] - globals: [1] ‘FUN’
[10:59:37.149] - packages: [1] ‘stats’
[10:59:37.149] getGlobalsAndPackages() ... DONE
[10:59:37.149]  - globals found/used: [n=1] ‘FUN’
[10:59:37.150]  - needed namespaces: [n=1] ‘stats’
[10:59:37.150] Finding globals ... DONE
[10:59:37.150] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:37.150] List of 2
[10:59:37.150]  $ ...future.FUN:function (x, w, ...)  
[10:59:37.150]  $ MoreArgs     : NULL
[10:59:37.150]  - attr(*, "where")=List of 2
[10:59:37.150]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:37.150]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:37.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:37.150]  - attr(*, "resolved")= logi FALSE
[10:59:37.150]  - attr(*, "total_size")= num NA
[10:59:37.152] Packages to be attached in all futures: [n=1] ‘stats’
[10:59:37.152] getGlobalsAndPackagesXApply() ... DONE
[10:59:37.153] Number of futures (= number of chunks): 2
[10:59:37.153] Launching 2 futures (chunks) ...
[10:59:37.153] Chunk #1 of 2 ...
[10:59:37.153]  - Finding globals in '...' for chunk #1 ...
[10:59:37.153] getGlobalsAndPackages() ...
[10:59:37.153] Searching for globals...
[10:59:37.153] 
[10:59:37.153] Searching for globals ... DONE
[10:59:37.153] - globals: [0] <none>
[10:59:37.154] getGlobalsAndPackages() ... DONE
[10:59:37.154]    + additional globals found: [n=0] 
[10:59:37.154]    + additional namespaces needed: [n=0] 
[10:59:37.154]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:37.154]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.154]  - seeds: <none>
[10:59:37.154]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.154] getGlobalsAndPackages() ...
[10:59:37.154] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.154] Resolving globals: FALSE
[10:59:37.155] The total size of the 5 globals is 817 bytes (817 bytes)
[10:59:37.155] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 817 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (399 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:37.155] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.155] - packages: [1] ‘stats’
[10:59:37.155] getGlobalsAndPackages() ... DONE
[10:59:37.156] run() for ‘Future’ ...
[10:59:37.156] - state: ‘created’
[10:59:37.156] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.171] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.172]   - Field: ‘node’
[10:59:37.172]   - Field: ‘label’
[10:59:37.172]   - Field: ‘local’
[10:59:37.172]   - Field: ‘owner’
[10:59:37.172]   - Field: ‘envir’
[10:59:37.172]   - Field: ‘workers’
[10:59:37.172]   - Field: ‘packages’
[10:59:37.172]   - Field: ‘gc’
[10:59:37.172]   - Field: ‘conditions’
[10:59:37.172]   - Field: ‘persistent’
[10:59:37.172]   - Field: ‘expr’
[10:59:37.173]   - Field: ‘uuid’
[10:59:37.173]   - Field: ‘seed’
[10:59:37.173]   - Field: ‘version’
[10:59:37.173]   - Field: ‘result’
[10:59:37.173]   - Field: ‘asynchronous’
[10:59:37.173]   - Field: ‘calls’
[10:59:37.173]   - Field: ‘globals’
[10:59:37.173]   - Field: ‘stdout’
[10:59:37.173]   - Field: ‘earlySignal’
[10:59:37.173]   - Field: ‘lazy’
[10:59:37.173]   - Field: ‘state’
[10:59:37.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.174] - Launch lazy future ...
[10:59:37.174] Packages needed by the future expression (n = 1): ‘stats’
[10:59:37.174] Packages needed by future strategies (n = 0): <none>
[10:59:37.174] {
[10:59:37.174]     {
[10:59:37.174]         {
[10:59:37.174]             ...future.startTime <- base::Sys.time()
[10:59:37.174]             {
[10:59:37.174]                 {
[10:59:37.174]                   {
[10:59:37.174]                     {
[10:59:37.174]                       {
[10:59:37.174]                         base::local({
[10:59:37.174]                           has_future <- base::requireNamespace("future", 
[10:59:37.174]                             quietly = TRUE)
[10:59:37.174]                           if (has_future) {
[10:59:37.174]                             ns <- base::getNamespace("future")
[10:59:37.174]                             version <- ns[[".package"]][["version"]]
[10:59:37.174]                             if (is.null(version)) 
[10:59:37.174]                               version <- utils::packageVersion("future")
[10:59:37.174]                           }
[10:59:37.174]                           else {
[10:59:37.174]                             version <- NULL
[10:59:37.174]                           }
[10:59:37.174]                           if (!has_future || version < "1.8.0") {
[10:59:37.174]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.174]                               "", base::R.version$version.string), 
[10:59:37.174]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:37.174]                                 base::R.version$platform, 8 * 
[10:59:37.174]                                   base::.Machine$sizeof.pointer), 
[10:59:37.174]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.174]                                 "release", "version")], collapse = " "), 
[10:59:37.174]                               hostname = base::Sys.info()[["nodename"]])
[10:59:37.174]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.174]                               info)
[10:59:37.174]                             info <- base::paste(info, collapse = "; ")
[10:59:37.174]                             if (!has_future) {
[10:59:37.174]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.174]                                 info)
[10:59:37.174]                             }
[10:59:37.174]                             else {
[10:59:37.174]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.174]                                 info, version)
[10:59:37.174]                             }
[10:59:37.174]                             base::stop(msg)
[10:59:37.174]                           }
[10:59:37.174]                         })
[10:59:37.174]                       }
[10:59:37.174]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.174]                       base::options(mc.cores = 1L)
[10:59:37.174]                     }
[10:59:37.174]                     base::local({
[10:59:37.174]                       for (pkg in "stats") {
[10:59:37.174]                         base::loadNamespace(pkg)
[10:59:37.174]                         base::library(pkg, character.only = TRUE)
[10:59:37.174]                       }
[10:59:37.174]                     })
[10:59:37.174]                   }
[10:59:37.174]                   ...future.strategy.old <- future::plan("list")
[10:59:37.174]                   options(future.plan = NULL)
[10:59:37.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.174]                 }
[10:59:37.174]                 ...future.workdir <- getwd()
[10:59:37.174]             }
[10:59:37.174]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.174]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.174]         }
[10:59:37.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.174]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.174]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.174]             base::names(...future.oldOptions))
[10:59:37.174]     }
[10:59:37.174]     if (FALSE) {
[10:59:37.174]     }
[10:59:37.174]     else {
[10:59:37.174]         if (TRUE) {
[10:59:37.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.174]                 open = "w")
[10:59:37.174]         }
[10:59:37.174]         else {
[10:59:37.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.174]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.174]         }
[10:59:37.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.174]             base::sink(type = "output", split = FALSE)
[10:59:37.174]             base::close(...future.stdout)
[10:59:37.174]         }, add = TRUE)
[10:59:37.174]     }
[10:59:37.174]     ...future.frame <- base::sys.nframe()
[10:59:37.174]     ...future.conditions <- base::list()
[10:59:37.174]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.174]     if (FALSE) {
[10:59:37.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.174]     }
[10:59:37.174]     ...future.result <- base::tryCatch({
[10:59:37.174]         base::withCallingHandlers({
[10:59:37.174]             ...future.value <- base::withVisible(base::local({
[10:59:37.174]                 ...future.makeSendCondition <- base::local({
[10:59:37.174]                   sendCondition <- NULL
[10:59:37.174]                   function(frame = 1L) {
[10:59:37.174]                     if (is.function(sendCondition)) 
[10:59:37.174]                       return(sendCondition)
[10:59:37.174]                     ns <- getNamespace("parallel")
[10:59:37.174]                     if (exists("sendData", mode = "function", 
[10:59:37.174]                       envir = ns)) {
[10:59:37.174]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.174]                         envir = ns)
[10:59:37.174]                       envir <- sys.frame(frame)
[10:59:37.174]                       master <- NULL
[10:59:37.174]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.174]                         !identical(envir, emptyenv())) {
[10:59:37.174]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.174]                           inherits = FALSE)) {
[10:59:37.174]                           master <- get("master", mode = "list", 
[10:59:37.174]                             envir = envir, inherits = FALSE)
[10:59:37.174]                           if (inherits(master, c("SOCKnode", 
[10:59:37.174]                             "SOCK0node"))) {
[10:59:37.174]                             sendCondition <<- function(cond) {
[10:59:37.174]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.174]                                 success = TRUE)
[10:59:37.174]                               parallel_sendData(master, data)
[10:59:37.174]                             }
[10:59:37.174]                             return(sendCondition)
[10:59:37.174]                           }
[10:59:37.174]                         }
[10:59:37.174]                         frame <- frame + 1L
[10:59:37.174]                         envir <- sys.frame(frame)
[10:59:37.174]                       }
[10:59:37.174]                     }
[10:59:37.174]                     sendCondition <<- function(cond) NULL
[10:59:37.174]                   }
[10:59:37.174]                 })
[10:59:37.174]                 withCallingHandlers({
[10:59:37.174]                   {
[10:59:37.174]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.174]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.174]                       ...future.globals.maxSize)) {
[10:59:37.174]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.174]                       on.exit(options(oopts), add = TRUE)
[10:59:37.174]                     }
[10:59:37.174]                     {
[10:59:37.174]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.174]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.174]                         USE.NAMES = FALSE)
[10:59:37.174]                       do.call(mapply, args = args)
[10:59:37.174]                     }
[10:59:37.174]                   }
[10:59:37.174]                 }, immediateCondition = function(cond) {
[10:59:37.174]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.174]                   sendCondition(cond)
[10:59:37.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.174]                   {
[10:59:37.174]                     inherits <- base::inherits
[10:59:37.174]                     invokeRestart <- base::invokeRestart
[10:59:37.174]                     is.null <- base::is.null
[10:59:37.174]                     muffled <- FALSE
[10:59:37.174]                     if (inherits(cond, "message")) {
[10:59:37.174]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.174]                       if (muffled) 
[10:59:37.174]                         invokeRestart("muffleMessage")
[10:59:37.174]                     }
[10:59:37.174]                     else if (inherits(cond, "warning")) {
[10:59:37.174]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.174]                       if (muffled) 
[10:59:37.174]                         invokeRestart("muffleWarning")
[10:59:37.174]                     }
[10:59:37.174]                     else if (inherits(cond, "condition")) {
[10:59:37.174]                       if (!is.null(pattern)) {
[10:59:37.174]                         computeRestarts <- base::computeRestarts
[10:59:37.174]                         grepl <- base::grepl
[10:59:37.174]                         restarts <- computeRestarts(cond)
[10:59:37.174]                         for (restart in restarts) {
[10:59:37.174]                           name <- restart$name
[10:59:37.174]                           if (is.null(name)) 
[10:59:37.174]                             next
[10:59:37.174]                           if (!grepl(pattern, name)) 
[10:59:37.174]                             next
[10:59:37.174]                           invokeRestart(restart)
[10:59:37.174]                           muffled <- TRUE
[10:59:37.174]                           break
[10:59:37.174]                         }
[10:59:37.174]                       }
[10:59:37.174]                     }
[10:59:37.174]                     invisible(muffled)
[10:59:37.174]                   }
[10:59:37.174]                   muffleCondition(cond)
[10:59:37.174]                 })
[10:59:37.174]             }))
[10:59:37.174]             future::FutureResult(value = ...future.value$value, 
[10:59:37.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.174]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.174]                     ...future.globalenv.names))
[10:59:37.174]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.174]         }, condition = base::local({
[10:59:37.174]             c <- base::c
[10:59:37.174]             inherits <- base::inherits
[10:59:37.174]             invokeRestart <- base::invokeRestart
[10:59:37.174]             length <- base::length
[10:59:37.174]             list <- base::list
[10:59:37.174]             seq.int <- base::seq.int
[10:59:37.174]             signalCondition <- base::signalCondition
[10:59:37.174]             sys.calls <- base::sys.calls
[10:59:37.174]             `[[` <- base::`[[`
[10:59:37.174]             `+` <- base::`+`
[10:59:37.174]             `<<-` <- base::`<<-`
[10:59:37.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.174]                   3L)]
[10:59:37.174]             }
[10:59:37.174]             function(cond) {
[10:59:37.174]                 is_error <- inherits(cond, "error")
[10:59:37.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.174]                   NULL)
[10:59:37.174]                 if (is_error) {
[10:59:37.174]                   sessionInformation <- function() {
[10:59:37.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.174]                       search = base::search(), system = base::Sys.info())
[10:59:37.174]                   }
[10:59:37.174]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.174]                     cond$call), session = sessionInformation(), 
[10:59:37.174]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.174]                   signalCondition(cond)
[10:59:37.174]                 }
[10:59:37.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.174]                 "immediateCondition"))) {
[10:59:37.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.174]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.174]                   if (TRUE && !signal) {
[10:59:37.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.174]                     {
[10:59:37.174]                       inherits <- base::inherits
[10:59:37.174]                       invokeRestart <- base::invokeRestart
[10:59:37.174]                       is.null <- base::is.null
[10:59:37.174]                       muffled <- FALSE
[10:59:37.174]                       if (inherits(cond, "message")) {
[10:59:37.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.174]                         if (muffled) 
[10:59:37.174]                           invokeRestart("muffleMessage")
[10:59:37.174]                       }
[10:59:37.174]                       else if (inherits(cond, "warning")) {
[10:59:37.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.174]                         if (muffled) 
[10:59:37.174]                           invokeRestart("muffleWarning")
[10:59:37.174]                       }
[10:59:37.174]                       else if (inherits(cond, "condition")) {
[10:59:37.174]                         if (!is.null(pattern)) {
[10:59:37.174]                           computeRestarts <- base::computeRestarts
[10:59:37.174]                           grepl <- base::grepl
[10:59:37.174]                           restarts <- computeRestarts(cond)
[10:59:37.174]                           for (restart in restarts) {
[10:59:37.174]                             name <- restart$name
[10:59:37.174]                             if (is.null(name)) 
[10:59:37.174]                               next
[10:59:37.174]                             if (!grepl(pattern, name)) 
[10:59:37.174]                               next
[10:59:37.174]                             invokeRestart(restart)
[10:59:37.174]                             muffled <- TRUE
[10:59:37.174]                             break
[10:59:37.174]                           }
[10:59:37.174]                         }
[10:59:37.174]                       }
[10:59:37.174]                       invisible(muffled)
[10:59:37.174]                     }
[10:59:37.174]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.174]                   }
[10:59:37.174]                 }
[10:59:37.174]                 else {
[10:59:37.174]                   if (TRUE) {
[10:59:37.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.174]                     {
[10:59:37.174]                       inherits <- base::inherits
[10:59:37.174]                       invokeRestart <- base::invokeRestart
[10:59:37.174]                       is.null <- base::is.null
[10:59:37.174]                       muffled <- FALSE
[10:59:37.174]                       if (inherits(cond, "message")) {
[10:59:37.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.174]                         if (muffled) 
[10:59:37.174]                           invokeRestart("muffleMessage")
[10:59:37.174]                       }
[10:59:37.174]                       else if (inherits(cond, "warning")) {
[10:59:37.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.174]                         if (muffled) 
[10:59:37.174]                           invokeRestart("muffleWarning")
[10:59:37.174]                       }
[10:59:37.174]                       else if (inherits(cond, "condition")) {
[10:59:37.174]                         if (!is.null(pattern)) {
[10:59:37.174]                           computeRestarts <- base::computeRestarts
[10:59:37.174]                           grepl <- base::grepl
[10:59:37.174]                           restarts <- computeRestarts(cond)
[10:59:37.174]                           for (restart in restarts) {
[10:59:37.174]                             name <- restart$name
[10:59:37.174]                             if (is.null(name)) 
[10:59:37.174]                               next
[10:59:37.174]                             if (!grepl(pattern, name)) 
[10:59:37.174]                               next
[10:59:37.174]                             invokeRestart(restart)
[10:59:37.174]                             muffled <- TRUE
[10:59:37.174]                             break
[10:59:37.174]                           }
[10:59:37.174]                         }
[10:59:37.174]                       }
[10:59:37.174]                       invisible(muffled)
[10:59:37.174]                     }
[10:59:37.174]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.174]                   }
[10:59:37.174]                 }
[10:59:37.174]             }
[10:59:37.174]         }))
[10:59:37.174]     }, error = function(ex) {
[10:59:37.174]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.174]                 ...future.rng), started = ...future.startTime, 
[10:59:37.174]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.174]             version = "1.8"), class = "FutureResult")
[10:59:37.174]     }, finally = {
[10:59:37.174]         if (!identical(...future.workdir, getwd())) 
[10:59:37.174]             setwd(...future.workdir)
[10:59:37.174]         {
[10:59:37.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.174]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.174]             }
[10:59:37.174]             base::options(...future.oldOptions)
[10:59:37.174]             if (.Platform$OS.type == "windows") {
[10:59:37.174]                 old_names <- names(...future.oldEnvVars)
[10:59:37.174]                 envs <- base::Sys.getenv()
[10:59:37.174]                 names <- names(envs)
[10:59:37.174]                 common <- intersect(names, old_names)
[10:59:37.174]                 added <- setdiff(names, old_names)
[10:59:37.174]                 removed <- setdiff(old_names, names)
[10:59:37.174]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.174]                   envs[common]]
[10:59:37.174]                 NAMES <- toupper(changed)
[10:59:37.174]                 args <- list()
[10:59:37.174]                 for (kk in seq_along(NAMES)) {
[10:59:37.174]                   name <- changed[[kk]]
[10:59:37.174]                   NAME <- NAMES[[kk]]
[10:59:37.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.174]                     next
[10:59:37.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.174]                 }
[10:59:37.174]                 NAMES <- toupper(added)
[10:59:37.174]                 for (kk in seq_along(NAMES)) {
[10:59:37.174]                   name <- added[[kk]]
[10:59:37.174]                   NAME <- NAMES[[kk]]
[10:59:37.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.174]                     next
[10:59:37.174]                   args[[name]] <- ""
[10:59:37.174]                 }
[10:59:37.174]                 NAMES <- toupper(removed)
[10:59:37.174]                 for (kk in seq_along(NAMES)) {
[10:59:37.174]                   name <- removed[[kk]]
[10:59:37.174]                   NAME <- NAMES[[kk]]
[10:59:37.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.174]                     next
[10:59:37.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.174]                 }
[10:59:37.174]                 if (length(args) > 0) 
[10:59:37.174]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.174]             }
[10:59:37.174]             else {
[10:59:37.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.174]             }
[10:59:37.174]             {
[10:59:37.174]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.174]                   0L) {
[10:59:37.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.174]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.174]                   base::options(opts)
[10:59:37.174]                 }
[10:59:37.174]                 {
[10:59:37.174]                   {
[10:59:37.174]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.174]                     NULL
[10:59:37.174]                   }
[10:59:37.174]                   options(future.plan = NULL)
[10:59:37.174]                   if (is.na(NA_character_)) 
[10:59:37.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.174]                     .init = FALSE)
[10:59:37.174]                 }
[10:59:37.174]             }
[10:59:37.174]         }
[10:59:37.174]     })
[10:59:37.174]     if (TRUE) {
[10:59:37.174]         base::sink(type = "output", split = FALSE)
[10:59:37.174]         if (TRUE) {
[10:59:37.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.174]         }
[10:59:37.174]         else {
[10:59:37.174]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.174]         }
[10:59:37.174]         base::close(...future.stdout)
[10:59:37.174]         ...future.stdout <- NULL
[10:59:37.174]     }
[10:59:37.174]     ...future.result$conditions <- ...future.conditions
[10:59:37.174]     ...future.result$finished <- base::Sys.time()
[10:59:37.174]     ...future.result
[10:59:37.174] }
[10:59:37.177] Exporting 5 global objects (1.24 KiB) to cluster node #1 ...
[10:59:37.177] Exporting ‘...future.FUN’ (337 bytes) to cluster node #1 ...
[10:59:37.178] Exporting ‘...future.FUN’ (337 bytes) to cluster node #1 ... DONE
[10:59:37.178] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:37.178] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.178] Exporting ‘...future.elements_ii’ (399 bytes) to cluster node #1 ...
[10:59:37.179] Exporting ‘...future.elements_ii’ (399 bytes) to cluster node #1 ... DONE
[10:59:37.179] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:37.179] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.179] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:37.180] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.180] Exporting 5 global objects (1.24 KiB) to cluster node #1 ... DONE
[10:59:37.180] MultisessionFuture started
[10:59:37.180] - Launch lazy future ... done
[10:59:37.181] run() for ‘MultisessionFuture’ ... done
[10:59:37.181] Created future:
[10:59:37.181] MultisessionFuture:
[10:59:37.181] Label: ‘future_Map-1’
[10:59:37.181] Expression:
[10:59:37.181] {
[10:59:37.181]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.181]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.181]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.181]         on.exit(options(oopts), add = TRUE)
[10:59:37.181]     }
[10:59:37.181]     {
[10:59:37.181]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.181]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.181]         do.call(mapply, args = args)
[10:59:37.181]     }
[10:59:37.181] }
[10:59:37.181] Lazy evaluation: FALSE
[10:59:37.181] Asynchronous evaluation: TRUE
[10:59:37.181] Local evaluation: TRUE
[10:59:37.181] Environment: R_GlobalEnv
[10:59:37.181] Capture standard output: TRUE
[10:59:37.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.181] Globals: 5 objects totaling 817 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 399 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.181] Packages: 1 packages (‘stats’)
[10:59:37.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:37.181] Resolved: FALSE
[10:59:37.181] Value: <not collected>
[10:59:37.181] Conditions captured: <none>
[10:59:37.181] Early signaling: FALSE
[10:59:37.181] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.181] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.192] Chunk #1 of 2 ... DONE
[10:59:37.192] Chunk #2 of 2 ...
[10:59:37.192]  - Finding globals in '...' for chunk #2 ...
[10:59:37.192] getGlobalsAndPackages() ...
[10:59:37.192] Searching for globals...
[10:59:37.193] 
[10:59:37.193] Searching for globals ... DONE
[10:59:37.193] - globals: [0] <none>
[10:59:37.193] getGlobalsAndPackages() ... DONE
[10:59:37.193]    + additional globals found: [n=0] 
[10:59:37.193]    + additional namespaces needed: [n=0] 
[10:59:37.193]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:37.193]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.193]  - seeds: <none>
[10:59:37.194]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.194] getGlobalsAndPackages() ...
[10:59:37.194] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.194] Resolving globals: FALSE
[10:59:37.194] The total size of the 5 globals is 993 bytes (993 bytes)
[10:59:37.195] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 993 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (575 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:37.195] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.195] - packages: [1] ‘stats’
[10:59:37.195] getGlobalsAndPackages() ... DONE
[10:59:37.195] run() for ‘Future’ ...
[10:59:37.195] - state: ‘created’
[10:59:37.195] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.209]   - Field: ‘node’
[10:59:37.209]   - Field: ‘label’
[10:59:37.209]   - Field: ‘local’
[10:59:37.210]   - Field: ‘owner’
[10:59:37.210]   - Field: ‘envir’
[10:59:37.210]   - Field: ‘workers’
[10:59:37.210]   - Field: ‘packages’
[10:59:37.210]   - Field: ‘gc’
[10:59:37.210]   - Field: ‘conditions’
[10:59:37.210]   - Field: ‘persistent’
[10:59:37.210]   - Field: ‘expr’
[10:59:37.210]   - Field: ‘uuid’
[10:59:37.210]   - Field: ‘seed’
[10:59:37.210]   - Field: ‘version’
[10:59:37.210]   - Field: ‘result’
[10:59:37.211]   - Field: ‘asynchronous’
[10:59:37.211]   - Field: ‘calls’
[10:59:37.211]   - Field: ‘globals’
[10:59:37.211]   - Field: ‘stdout’
[10:59:37.211]   - Field: ‘earlySignal’
[10:59:37.211]   - Field: ‘lazy’
[10:59:37.211]   - Field: ‘state’
[10:59:37.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.211] - Launch lazy future ...
[10:59:37.211] Packages needed by the future expression (n = 1): ‘stats’
[10:59:37.212] Packages needed by future strategies (n = 0): <none>
[10:59:37.212] {
[10:59:37.212]     {
[10:59:37.212]         {
[10:59:37.212]             ...future.startTime <- base::Sys.time()
[10:59:37.212]             {
[10:59:37.212]                 {
[10:59:37.212]                   {
[10:59:37.212]                     {
[10:59:37.212]                       {
[10:59:37.212]                         base::local({
[10:59:37.212]                           has_future <- base::requireNamespace("future", 
[10:59:37.212]                             quietly = TRUE)
[10:59:37.212]                           if (has_future) {
[10:59:37.212]                             ns <- base::getNamespace("future")
[10:59:37.212]                             version <- ns[[".package"]][["version"]]
[10:59:37.212]                             if (is.null(version)) 
[10:59:37.212]                               version <- utils::packageVersion("future")
[10:59:37.212]                           }
[10:59:37.212]                           else {
[10:59:37.212]                             version <- NULL
[10:59:37.212]                           }
[10:59:37.212]                           if (!has_future || version < "1.8.0") {
[10:59:37.212]                             info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.212]                               "", base::R.version$version.string), 
[10:59:37.212]                               platform = base::sprintf("%s (%s-bit)", 
[10:59:37.212]                                 base::R.version$platform, 8 * 
[10:59:37.212]                                   base::.Machine$sizeof.pointer), 
[10:59:37.212]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.212]                                 "release", "version")], collapse = " "), 
[10:59:37.212]                               hostname = base::Sys.info()[["nodename"]])
[10:59:37.212]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.212]                               info)
[10:59:37.212]                             info <- base::paste(info, collapse = "; ")
[10:59:37.212]                             if (!has_future) {
[10:59:37.212]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.212]                                 info)
[10:59:37.212]                             }
[10:59:37.212]                             else {
[10:59:37.212]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.212]                                 info, version)
[10:59:37.212]                             }
[10:59:37.212]                             base::stop(msg)
[10:59:37.212]                           }
[10:59:37.212]                         })
[10:59:37.212]                       }
[10:59:37.212]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.212]                       base::options(mc.cores = 1L)
[10:59:37.212]                     }
[10:59:37.212]                     base::local({
[10:59:37.212]                       for (pkg in "stats") {
[10:59:37.212]                         base::loadNamespace(pkg)
[10:59:37.212]                         base::library(pkg, character.only = TRUE)
[10:59:37.212]                       }
[10:59:37.212]                     })
[10:59:37.212]                   }
[10:59:37.212]                   ...future.strategy.old <- future::plan("list")
[10:59:37.212]                   options(future.plan = NULL)
[10:59:37.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.212]                 }
[10:59:37.212]                 ...future.workdir <- getwd()
[10:59:37.212]             }
[10:59:37.212]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.212]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.212]         }
[10:59:37.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.212]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.212]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.212]             base::names(...future.oldOptions))
[10:59:37.212]     }
[10:59:37.212]     if (FALSE) {
[10:59:37.212]     }
[10:59:37.212]     else {
[10:59:37.212]         if (TRUE) {
[10:59:37.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.212]                 open = "w")
[10:59:37.212]         }
[10:59:37.212]         else {
[10:59:37.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.212]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.212]         }
[10:59:37.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.212]             base::sink(type = "output", split = FALSE)
[10:59:37.212]             base::close(...future.stdout)
[10:59:37.212]         }, add = TRUE)
[10:59:37.212]     }
[10:59:37.212]     ...future.frame <- base::sys.nframe()
[10:59:37.212]     ...future.conditions <- base::list()
[10:59:37.212]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.212]     if (FALSE) {
[10:59:37.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.212]     }
[10:59:37.212]     ...future.result <- base::tryCatch({
[10:59:37.212]         base::withCallingHandlers({
[10:59:37.212]             ...future.value <- base::withVisible(base::local({
[10:59:37.212]                 ...future.makeSendCondition <- base::local({
[10:59:37.212]                   sendCondition <- NULL
[10:59:37.212]                   function(frame = 1L) {
[10:59:37.212]                     if (is.function(sendCondition)) 
[10:59:37.212]                       return(sendCondition)
[10:59:37.212]                     ns <- getNamespace("parallel")
[10:59:37.212]                     if (exists("sendData", mode = "function", 
[10:59:37.212]                       envir = ns)) {
[10:59:37.212]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.212]                         envir = ns)
[10:59:37.212]                       envir <- sys.frame(frame)
[10:59:37.212]                       master <- NULL
[10:59:37.212]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.212]                         !identical(envir, emptyenv())) {
[10:59:37.212]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.212]                           inherits = FALSE)) {
[10:59:37.212]                           master <- get("master", mode = "list", 
[10:59:37.212]                             envir = envir, inherits = FALSE)
[10:59:37.212]                           if (inherits(master, c("SOCKnode", 
[10:59:37.212]                             "SOCK0node"))) {
[10:59:37.212]                             sendCondition <<- function(cond) {
[10:59:37.212]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.212]                                 success = TRUE)
[10:59:37.212]                               parallel_sendData(master, data)
[10:59:37.212]                             }
[10:59:37.212]                             return(sendCondition)
[10:59:37.212]                           }
[10:59:37.212]                         }
[10:59:37.212]                         frame <- frame + 1L
[10:59:37.212]                         envir <- sys.frame(frame)
[10:59:37.212]                       }
[10:59:37.212]                     }
[10:59:37.212]                     sendCondition <<- function(cond) NULL
[10:59:37.212]                   }
[10:59:37.212]                 })
[10:59:37.212]                 withCallingHandlers({
[10:59:37.212]                   {
[10:59:37.212]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.212]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.212]                       ...future.globals.maxSize)) {
[10:59:37.212]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.212]                       on.exit(options(oopts), add = TRUE)
[10:59:37.212]                     }
[10:59:37.212]                     {
[10:59:37.212]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.212]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.212]                         USE.NAMES = FALSE)
[10:59:37.212]                       do.call(mapply, args = args)
[10:59:37.212]                     }
[10:59:37.212]                   }
[10:59:37.212]                 }, immediateCondition = function(cond) {
[10:59:37.212]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.212]                   sendCondition(cond)
[10:59:37.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.212]                   {
[10:59:37.212]                     inherits <- base::inherits
[10:59:37.212]                     invokeRestart <- base::invokeRestart
[10:59:37.212]                     is.null <- base::is.null
[10:59:37.212]                     muffled <- FALSE
[10:59:37.212]                     if (inherits(cond, "message")) {
[10:59:37.212]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.212]                       if (muffled) 
[10:59:37.212]                         invokeRestart("muffleMessage")
[10:59:37.212]                     }
[10:59:37.212]                     else if (inherits(cond, "warning")) {
[10:59:37.212]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.212]                       if (muffled) 
[10:59:37.212]                         invokeRestart("muffleWarning")
[10:59:37.212]                     }
[10:59:37.212]                     else if (inherits(cond, "condition")) {
[10:59:37.212]                       if (!is.null(pattern)) {
[10:59:37.212]                         computeRestarts <- base::computeRestarts
[10:59:37.212]                         grepl <- base::grepl
[10:59:37.212]                         restarts <- computeRestarts(cond)
[10:59:37.212]                         for (restart in restarts) {
[10:59:37.212]                           name <- restart$name
[10:59:37.212]                           if (is.null(name)) 
[10:59:37.212]                             next
[10:59:37.212]                           if (!grepl(pattern, name)) 
[10:59:37.212]                             next
[10:59:37.212]                           invokeRestart(restart)
[10:59:37.212]                           muffled <- TRUE
[10:59:37.212]                           break
[10:59:37.212]                         }
[10:59:37.212]                       }
[10:59:37.212]                     }
[10:59:37.212]                     invisible(muffled)
[10:59:37.212]                   }
[10:59:37.212]                   muffleCondition(cond)
[10:59:37.212]                 })
[10:59:37.212]             }))
[10:59:37.212]             future::FutureResult(value = ...future.value$value, 
[10:59:37.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.212]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.212]                     ...future.globalenv.names))
[10:59:37.212]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.212]         }, condition = base::local({
[10:59:37.212]             c <- base::c
[10:59:37.212]             inherits <- base::inherits
[10:59:37.212]             invokeRestart <- base::invokeRestart
[10:59:37.212]             length <- base::length
[10:59:37.212]             list <- base::list
[10:59:37.212]             seq.int <- base::seq.int
[10:59:37.212]             signalCondition <- base::signalCondition
[10:59:37.212]             sys.calls <- base::sys.calls
[10:59:37.212]             `[[` <- base::`[[`
[10:59:37.212]             `+` <- base::`+`
[10:59:37.212]             `<<-` <- base::`<<-`
[10:59:37.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.212]                   3L)]
[10:59:37.212]             }
[10:59:37.212]             function(cond) {
[10:59:37.212]                 is_error <- inherits(cond, "error")
[10:59:37.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.212]                   NULL)
[10:59:37.212]                 if (is_error) {
[10:59:37.212]                   sessionInformation <- function() {
[10:59:37.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.212]                       search = base::search(), system = base::Sys.info())
[10:59:37.212]                   }
[10:59:37.212]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.212]                     cond$call), session = sessionInformation(), 
[10:59:37.212]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.212]                   signalCondition(cond)
[10:59:37.212]                 }
[10:59:37.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.212]                 "immediateCondition"))) {
[10:59:37.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.212]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.212]                   if (TRUE && !signal) {
[10:59:37.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.212]                     {
[10:59:37.212]                       inherits <- base::inherits
[10:59:37.212]                       invokeRestart <- base::invokeRestart
[10:59:37.212]                       is.null <- base::is.null
[10:59:37.212]                       muffled <- FALSE
[10:59:37.212]                       if (inherits(cond, "message")) {
[10:59:37.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.212]                         if (muffled) 
[10:59:37.212]                           invokeRestart("muffleMessage")
[10:59:37.212]                       }
[10:59:37.212]                       else if (inherits(cond, "warning")) {
[10:59:37.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.212]                         if (muffled) 
[10:59:37.212]                           invokeRestart("muffleWarning")
[10:59:37.212]                       }
[10:59:37.212]                       else if (inherits(cond, "condition")) {
[10:59:37.212]                         if (!is.null(pattern)) {
[10:59:37.212]                           computeRestarts <- base::computeRestarts
[10:59:37.212]                           grepl <- base::grepl
[10:59:37.212]                           restarts <- computeRestarts(cond)
[10:59:37.212]                           for (restart in restarts) {
[10:59:37.212]                             name <- restart$name
[10:59:37.212]                             if (is.null(name)) 
[10:59:37.212]                               next
[10:59:37.212]                             if (!grepl(pattern, name)) 
[10:59:37.212]                               next
[10:59:37.212]                             invokeRestart(restart)
[10:59:37.212]                             muffled <- TRUE
[10:59:37.212]                             break
[10:59:37.212]                           }
[10:59:37.212]                         }
[10:59:37.212]                       }
[10:59:37.212]                       invisible(muffled)
[10:59:37.212]                     }
[10:59:37.212]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.212]                   }
[10:59:37.212]                 }
[10:59:37.212]                 else {
[10:59:37.212]                   if (TRUE) {
[10:59:37.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.212]                     {
[10:59:37.212]                       inherits <- base::inherits
[10:59:37.212]                       invokeRestart <- base::invokeRestart
[10:59:37.212]                       is.null <- base::is.null
[10:59:37.212]                       muffled <- FALSE
[10:59:37.212]                       if (inherits(cond, "message")) {
[10:59:37.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.212]                         if (muffled) 
[10:59:37.212]                           invokeRestart("muffleMessage")
[10:59:37.212]                       }
[10:59:37.212]                       else if (inherits(cond, "warning")) {
[10:59:37.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.212]                         if (muffled) 
[10:59:37.212]                           invokeRestart("muffleWarning")
[10:59:37.212]                       }
[10:59:37.212]                       else if (inherits(cond, "condition")) {
[10:59:37.212]                         if (!is.null(pattern)) {
[10:59:37.212]                           computeRestarts <- base::computeRestarts
[10:59:37.212]                           grepl <- base::grepl
[10:59:37.212]                           restarts <- computeRestarts(cond)
[10:59:37.212]                           for (restart in restarts) {
[10:59:37.212]                             name <- restart$name
[10:59:37.212]                             if (is.null(name)) 
[10:59:37.212]                               next
[10:59:37.212]                             if (!grepl(pattern, name)) 
[10:59:37.212]                               next
[10:59:37.212]                             invokeRestart(restart)
[10:59:37.212]                             muffled <- TRUE
[10:59:37.212]                             break
[10:59:37.212]                           }
[10:59:37.212]                         }
[10:59:37.212]                       }
[10:59:37.212]                       invisible(muffled)
[10:59:37.212]                     }
[10:59:37.212]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.212]                   }
[10:59:37.212]                 }
[10:59:37.212]             }
[10:59:37.212]         }))
[10:59:37.212]     }, error = function(ex) {
[10:59:37.212]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.212]                 ...future.rng), started = ...future.startTime, 
[10:59:37.212]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.212]             version = "1.8"), class = "FutureResult")
[10:59:37.212]     }, finally = {
[10:59:37.212]         if (!identical(...future.workdir, getwd())) 
[10:59:37.212]             setwd(...future.workdir)
[10:59:37.212]         {
[10:59:37.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.212]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.212]             }
[10:59:37.212]             base::options(...future.oldOptions)
[10:59:37.212]             if (.Platform$OS.type == "windows") {
[10:59:37.212]                 old_names <- names(...future.oldEnvVars)
[10:59:37.212]                 envs <- base::Sys.getenv()
[10:59:37.212]                 names <- names(envs)
[10:59:37.212]                 common <- intersect(names, old_names)
[10:59:37.212]                 added <- setdiff(names, old_names)
[10:59:37.212]                 removed <- setdiff(old_names, names)
[10:59:37.212]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.212]                   envs[common]]
[10:59:37.212]                 NAMES <- toupper(changed)
[10:59:37.212]                 args <- list()
[10:59:37.212]                 for (kk in seq_along(NAMES)) {
[10:59:37.212]                   name <- changed[[kk]]
[10:59:37.212]                   NAME <- NAMES[[kk]]
[10:59:37.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.212]                     next
[10:59:37.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.212]                 }
[10:59:37.212]                 NAMES <- toupper(added)
[10:59:37.212]                 for (kk in seq_along(NAMES)) {
[10:59:37.212]                   name <- added[[kk]]
[10:59:37.212]                   NAME <- NAMES[[kk]]
[10:59:37.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.212]                     next
[10:59:37.212]                   args[[name]] <- ""
[10:59:37.212]                 }
[10:59:37.212]                 NAMES <- toupper(removed)
[10:59:37.212]                 for (kk in seq_along(NAMES)) {
[10:59:37.212]                   name <- removed[[kk]]
[10:59:37.212]                   NAME <- NAMES[[kk]]
[10:59:37.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.212]                     next
[10:59:37.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.212]                 }
[10:59:37.212]                 if (length(args) > 0) 
[10:59:37.212]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.212]             }
[10:59:37.212]             else {
[10:59:37.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.212]             }
[10:59:37.212]             {
[10:59:37.212]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.212]                   0L) {
[10:59:37.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.212]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.212]                   base::options(opts)
[10:59:37.212]                 }
[10:59:37.212]                 {
[10:59:37.212]                   {
[10:59:37.212]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.212]                     NULL
[10:59:37.212]                   }
[10:59:37.212]                   options(future.plan = NULL)
[10:59:37.212]                   if (is.na(NA_character_)) 
[10:59:37.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.212]                     .init = FALSE)
[10:59:37.212]                 }
[10:59:37.212]             }
[10:59:37.212]         }
[10:59:37.212]     })
[10:59:37.212]     if (TRUE) {
[10:59:37.212]         base::sink(type = "output", split = FALSE)
[10:59:37.212]         if (TRUE) {
[10:59:37.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.212]         }
[10:59:37.212]         else {
[10:59:37.212]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.212]         }
[10:59:37.212]         base::close(...future.stdout)
[10:59:37.212]         ...future.stdout <- NULL
[10:59:37.212]     }
[10:59:37.212]     ...future.result$conditions <- ...future.conditions
[10:59:37.212]     ...future.result$finished <- base::Sys.time()
[10:59:37.212]     ...future.result
[10:59:37.212] }
[10:59:37.215] Exporting 5 global objects (1.41 KiB) to cluster node #2 ...
[10:59:37.215] Exporting ‘...future.FUN’ (337 bytes) to cluster node #2 ...
[10:59:37.215] Exporting ‘...future.FUN’ (337 bytes) to cluster node #2 ... DONE
[10:59:37.215] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:37.216] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.216] Exporting ‘...future.elements_ii’ (575 bytes) to cluster node #2 ...
[10:59:37.216] Exporting ‘...future.elements_ii’ (575 bytes) to cluster node #2 ... DONE
[10:59:37.216] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:37.217] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.217] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:37.217] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.217] Exporting 5 global objects (1.41 KiB) to cluster node #2 ... DONE
[10:59:37.218] MultisessionFuture started
[10:59:37.218] - Launch lazy future ... done
[10:59:37.218] run() for ‘MultisessionFuture’ ... done
[10:59:37.218] Created future:
[10:59:37.218] MultisessionFuture:
[10:59:37.218] Label: ‘future_Map-2’
[10:59:37.218] Expression:
[10:59:37.218] {
[10:59:37.218]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.218]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.218]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.218]         on.exit(options(oopts), add = TRUE)
[10:59:37.218]     }
[10:59:37.218]     {
[10:59:37.218]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.218]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.218]         do.call(mapply, args = args)
[10:59:37.218]     }
[10:59:37.218] }
[10:59:37.218] Lazy evaluation: FALSE
[10:59:37.218] Asynchronous evaluation: TRUE
[10:59:37.218] Local evaluation: TRUE
[10:59:37.218] Environment: R_GlobalEnv
[10:59:37.218] Capture standard output: TRUE
[10:59:37.218] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.218] Globals: 5 objects totaling 993 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 575 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.218] Packages: 1 packages (‘stats’)
[10:59:37.218] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:37.218] Resolved: FALSE
[10:59:37.218] Value: <not collected>
[10:59:37.218] Conditions captured: <none>
[10:59:37.218] Early signaling: FALSE
[10:59:37.218] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.218] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.229] Chunk #2 of 2 ... DONE
[10:59:37.230] Launching 2 futures (chunks) ... DONE
[10:59:37.230] Resolving 2 futures (chunks) ...
[10:59:37.230] resolve() on list ...
[10:59:37.230]  recursive: 0
[10:59:37.230]  length: 2
[10:59:37.230] 
[10:59:37.231] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.231] - Validating connection of MultisessionFuture
[10:59:37.231] - received message: FutureResult
[10:59:37.231] - Received FutureResult
[10:59:37.231] - Erased future from FutureRegistry
[10:59:37.231] result() for ClusterFuture ...
[10:59:37.231] - result already collected: FutureResult
[10:59:37.231] result() for ClusterFuture ... done
[10:59:37.231] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.231] Future #1
[10:59:37.232] result() for ClusterFuture ...
[10:59:37.232] - result already collected: FutureResult
[10:59:37.232] result() for ClusterFuture ... done
[10:59:37.232] result() for ClusterFuture ...
[10:59:37.232] - result already collected: FutureResult
[10:59:37.232] result() for ClusterFuture ... done
[10:59:37.232] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:37.232] - nx: 2
[10:59:37.232] - relay: TRUE
[10:59:37.232] - stdout: TRUE
[10:59:37.232] - signal: TRUE
[10:59:37.232] - resignal: FALSE
[10:59:37.233] - force: TRUE
[10:59:37.233] - relayed: [n=2] FALSE, FALSE
[10:59:37.233] - queued futures: [n=2] FALSE, FALSE
[10:59:37.233]  - until=1
[10:59:37.233]  - relaying element #1
[10:59:37.233] result() for ClusterFuture ...
[10:59:37.233] - result already collected: FutureResult
[10:59:37.233] result() for ClusterFuture ... done
[10:59:37.233] result() for ClusterFuture ...
[10:59:37.233] - result already collected: FutureResult
[10:59:37.233] result() for ClusterFuture ... done
[10:59:37.234] result() for ClusterFuture ...
[10:59:37.234] - result already collected: FutureResult
[10:59:37.234] result() for ClusterFuture ... done
[10:59:37.234] result() for ClusterFuture ...
[10:59:37.234] - result already collected: FutureResult
[10:59:37.234] result() for ClusterFuture ... done
[10:59:37.234] - relayed: [n=2] TRUE, FALSE
[10:59:37.234] - queued futures: [n=2] TRUE, FALSE
[10:59:37.234] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:37.234]  length: 1 (resolved future 1)
[10:59:37.260] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.260] - Validating connection of MultisessionFuture
[10:59:37.261] - received message: FutureResult
[10:59:37.261] - Received FutureResult
[10:59:37.261] - Erased future from FutureRegistry
[10:59:37.261] result() for ClusterFuture ...
[10:59:37.261] - result already collected: FutureResult
[10:59:37.261] result() for ClusterFuture ... done
[10:59:37.261] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.261] Future #2
[10:59:37.262] result() for ClusterFuture ...
[10:59:37.262] - result already collected: FutureResult
[10:59:37.262] result() for ClusterFuture ... done
[10:59:37.262] result() for ClusterFuture ...
[10:59:37.262] - result already collected: FutureResult
[10:59:37.262] result() for ClusterFuture ... done
[10:59:37.262] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:37.262] - nx: 2
[10:59:37.262] - relay: TRUE
[10:59:37.262] - stdout: TRUE
[10:59:37.262] - signal: TRUE
[10:59:37.262] - resignal: FALSE
[10:59:37.263] - force: TRUE
[10:59:37.263] - relayed: [n=2] TRUE, FALSE
[10:59:37.263] - queued futures: [n=2] TRUE, FALSE
[10:59:37.263]  - until=2
[10:59:37.263]  - relaying element #2
[10:59:37.263] result() for ClusterFuture ...
[10:59:37.263] - result already collected: FutureResult
[10:59:37.263] result() for ClusterFuture ... done
[10:59:37.263] result() for ClusterFuture ...
[10:59:37.263] - result already collected: FutureResult
[10:59:37.263] result() for ClusterFuture ... done
[10:59:37.263] result() for ClusterFuture ...
[10:59:37.264] - result already collected: FutureResult
[10:59:37.264] result() for ClusterFuture ... done
[10:59:37.264] result() for ClusterFuture ...
[10:59:37.264] - result already collected: FutureResult
[10:59:37.264] result() for ClusterFuture ... done
[10:59:37.264] - relayed: [n=2] TRUE, TRUE
[10:59:37.264] - queued futures: [n=2] TRUE, TRUE
[10:59:37.264] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:37.264]  length: 0 (resolved future 2)
[10:59:37.264] Relaying remaining futures
[10:59:37.264] signalConditionsASAP(NULL, pos=0) ...
[10:59:37.264] - nx: 2
[10:59:37.264] - relay: TRUE
[10:59:37.265] - stdout: TRUE
[10:59:37.265] - signal: TRUE
[10:59:37.265] - resignal: FALSE
[10:59:37.265] - force: TRUE
[10:59:37.265] - relayed: [n=2] TRUE, TRUE
[10:59:37.265] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:37.265] - relayed: [n=2] TRUE, TRUE
[10:59:37.265] - queued futures: [n=2] TRUE, TRUE
[10:59:37.265] signalConditionsASAP(NULL, pos=0) ... done
[10:59:37.265] resolve() on list ... DONE
[10:59:37.265] result() for ClusterFuture ...
[10:59:37.265] - result already collected: FutureResult
[10:59:37.266] result() for ClusterFuture ... done
[10:59:37.266] result() for ClusterFuture ...
[10:59:37.266] - result already collected: FutureResult
[10:59:37.266] result() for ClusterFuture ... done
[10:59:37.266] result() for ClusterFuture ...
[10:59:37.266] - result already collected: FutureResult
[10:59:37.266] result() for ClusterFuture ... done
[10:59:37.266] result() for ClusterFuture ...
[10:59:37.266] - result already collected: FutureResult
[10:59:37.266] result() for ClusterFuture ... done
[10:59:37.266]  - Number of value chunks collected: 2
[10:59:37.266] Resolving 2 futures (chunks) ... DONE
[10:59:37.267] Reducing values from 2 chunks ...
[10:59:37.267]  - Number of values collected after concatenation: 5
[10:59:37.267]  - Number of values expected: 5
[10:59:37.267] Reducing values from 2 chunks ... DONE
[10:59:37.267] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:59:37.268] future_mapply() ...
[10:59:37.270] Number of chunks: 2
[10:59:37.270] getGlobalsAndPackagesXApply() ...
[10:59:37.270]  - future.globals: TRUE
[10:59:37.270] getGlobalsAndPackages() ...
[10:59:37.270] Searching for globals...
[10:59:37.271] - globals found: [1] ‘FUN’
[10:59:37.271] Searching for globals ... DONE
[10:59:37.271] Resolving globals: FALSE
[10:59:37.271] The total size of the 1 globals is 32 bytes (32 bytes)
[10:59:37.272] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[10:59:37.272] - globals: [1] ‘FUN’
[10:59:37.272] 
[10:59:37.272] getGlobalsAndPackages() ... DONE
[10:59:37.272]  - globals found/used: [n=1] ‘FUN’
[10:59:37.272]  - needed namespaces: [n=0] 
[10:59:37.272] Finding globals ... DONE
[10:59:37.272] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:37.272] List of 2
[10:59:37.272]  $ ...future.FUN:function (e1, e2)  
[10:59:37.272]  $ MoreArgs     : NULL
[10:59:37.272]  - attr(*, "where")=List of 2
[10:59:37.272]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:37.272]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:37.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:37.272]  - attr(*, "resolved")= logi FALSE
[10:59:37.272]  - attr(*, "total_size")= num NA
[10:59:37.275] Packages to be attached in all futures: [n=0] 
[10:59:37.275] getGlobalsAndPackagesXApply() ... DONE
[10:59:37.275] Number of futures (= number of chunks): 2
[10:59:37.275] Launching 2 futures (chunks) ...
[10:59:37.275] Chunk #1 of 2 ...
[10:59:37.275]  - Finding globals in '...' for chunk #1 ...
[10:59:37.276] getGlobalsAndPackages() ...
[10:59:37.278] Searching for globals...
[10:59:37.278] 
[10:59:37.278] Searching for globals ... DONE
[10:59:37.278] - globals: [0] <none>
[10:59:37.278] getGlobalsAndPackages() ... DONE
[10:59:37.279]    + additional globals found: [n=0] 
[10:59:37.279]    + additional namespaces needed: [n=0] 
[10:59:37.279]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:37.279]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.279]  - seeds: <none>
[10:59:37.279]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.279] getGlobalsAndPackages() ...
[10:59:37.279] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.279] Resolving globals: FALSE
[10:59:37.280] The total size of the 5 globals is 188 bytes (188 bytes)
[10:59:37.280] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 188 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (75 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:37.280] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.280] 
[10:59:37.280] getGlobalsAndPackages() ... DONE
[10:59:37.281] run() for ‘Future’ ...
[10:59:37.281] - state: ‘created’
[10:59:37.281] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.295]   - Field: ‘node’
[10:59:37.295]   - Field: ‘label’
[10:59:37.295]   - Field: ‘local’
[10:59:37.295]   - Field: ‘owner’
[10:59:37.295]   - Field: ‘envir’
[10:59:37.295]   - Field: ‘workers’
[10:59:37.295]   - Field: ‘packages’
[10:59:37.295]   - Field: ‘gc’
[10:59:37.295]   - Field: ‘conditions’
[10:59:37.296]   - Field: ‘persistent’
[10:59:37.296]   - Field: ‘expr’
[10:59:37.296]   - Field: ‘uuid’
[10:59:37.296]   - Field: ‘seed’
[10:59:37.296]   - Field: ‘version’
[10:59:37.296]   - Field: ‘result’
[10:59:37.296]   - Field: ‘asynchronous’
[10:59:37.296]   - Field: ‘calls’
[10:59:37.296]   - Field: ‘globals’
[10:59:37.296]   - Field: ‘stdout’
[10:59:37.296]   - Field: ‘earlySignal’
[10:59:37.296]   - Field: ‘lazy’
[10:59:37.297]   - Field: ‘state’
[10:59:37.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.297] - Launch lazy future ...
[10:59:37.297] Packages needed by the future expression (n = 0): <none>
[10:59:37.297] Packages needed by future strategies (n = 0): <none>
[10:59:37.297] {
[10:59:37.297]     {
[10:59:37.297]         {
[10:59:37.297]             ...future.startTime <- base::Sys.time()
[10:59:37.297]             {
[10:59:37.297]                 {
[10:59:37.297]                   {
[10:59:37.297]                     {
[10:59:37.297]                       base::local({
[10:59:37.297]                         has_future <- base::requireNamespace("future", 
[10:59:37.297]                           quietly = TRUE)
[10:59:37.297]                         if (has_future) {
[10:59:37.297]                           ns <- base::getNamespace("future")
[10:59:37.297]                           version <- ns[[".package"]][["version"]]
[10:59:37.297]                           if (is.null(version)) 
[10:59:37.297]                             version <- utils::packageVersion("future")
[10:59:37.297]                         }
[10:59:37.297]                         else {
[10:59:37.297]                           version <- NULL
[10:59:37.297]                         }
[10:59:37.297]                         if (!has_future || version < "1.8.0") {
[10:59:37.297]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.297]                             "", base::R.version$version.string), 
[10:59:37.297]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:37.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:37.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.297]                               "release", "version")], collapse = " "), 
[10:59:37.297]                             hostname = base::Sys.info()[["nodename"]])
[10:59:37.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.297]                             info)
[10:59:37.297]                           info <- base::paste(info, collapse = "; ")
[10:59:37.297]                           if (!has_future) {
[10:59:37.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.297]                               info)
[10:59:37.297]                           }
[10:59:37.297]                           else {
[10:59:37.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.297]                               info, version)
[10:59:37.297]                           }
[10:59:37.297]                           base::stop(msg)
[10:59:37.297]                         }
[10:59:37.297]                       })
[10:59:37.297]                     }
[10:59:37.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.297]                     base::options(mc.cores = 1L)
[10:59:37.297]                   }
[10:59:37.297]                   ...future.strategy.old <- future::plan("list")
[10:59:37.297]                   options(future.plan = NULL)
[10:59:37.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.297]                 }
[10:59:37.297]                 ...future.workdir <- getwd()
[10:59:37.297]             }
[10:59:37.297]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.297]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.297]         }
[10:59:37.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.297]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.297]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.297]             base::names(...future.oldOptions))
[10:59:37.297]     }
[10:59:37.297]     if (FALSE) {
[10:59:37.297]     }
[10:59:37.297]     else {
[10:59:37.297]         if (TRUE) {
[10:59:37.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.297]                 open = "w")
[10:59:37.297]         }
[10:59:37.297]         else {
[10:59:37.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.297]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.297]         }
[10:59:37.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.297]             base::sink(type = "output", split = FALSE)
[10:59:37.297]             base::close(...future.stdout)
[10:59:37.297]         }, add = TRUE)
[10:59:37.297]     }
[10:59:37.297]     ...future.frame <- base::sys.nframe()
[10:59:37.297]     ...future.conditions <- base::list()
[10:59:37.297]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.297]     if (FALSE) {
[10:59:37.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.297]     }
[10:59:37.297]     ...future.result <- base::tryCatch({
[10:59:37.297]         base::withCallingHandlers({
[10:59:37.297]             ...future.value <- base::withVisible(base::local({
[10:59:37.297]                 ...future.makeSendCondition <- base::local({
[10:59:37.297]                   sendCondition <- NULL
[10:59:37.297]                   function(frame = 1L) {
[10:59:37.297]                     if (is.function(sendCondition)) 
[10:59:37.297]                       return(sendCondition)
[10:59:37.297]                     ns <- getNamespace("parallel")
[10:59:37.297]                     if (exists("sendData", mode = "function", 
[10:59:37.297]                       envir = ns)) {
[10:59:37.297]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.297]                         envir = ns)
[10:59:37.297]                       envir <- sys.frame(frame)
[10:59:37.297]                       master <- NULL
[10:59:37.297]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.297]                         !identical(envir, emptyenv())) {
[10:59:37.297]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.297]                           inherits = FALSE)) {
[10:59:37.297]                           master <- get("master", mode = "list", 
[10:59:37.297]                             envir = envir, inherits = FALSE)
[10:59:37.297]                           if (inherits(master, c("SOCKnode", 
[10:59:37.297]                             "SOCK0node"))) {
[10:59:37.297]                             sendCondition <<- function(cond) {
[10:59:37.297]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.297]                                 success = TRUE)
[10:59:37.297]                               parallel_sendData(master, data)
[10:59:37.297]                             }
[10:59:37.297]                             return(sendCondition)
[10:59:37.297]                           }
[10:59:37.297]                         }
[10:59:37.297]                         frame <- frame + 1L
[10:59:37.297]                         envir <- sys.frame(frame)
[10:59:37.297]                       }
[10:59:37.297]                     }
[10:59:37.297]                     sendCondition <<- function(cond) NULL
[10:59:37.297]                   }
[10:59:37.297]                 })
[10:59:37.297]                 withCallingHandlers({
[10:59:37.297]                   {
[10:59:37.297]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.297]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.297]                       ...future.globals.maxSize)) {
[10:59:37.297]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.297]                       on.exit(options(oopts), add = TRUE)
[10:59:37.297]                     }
[10:59:37.297]                     {
[10:59:37.297]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.297]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.297]                         USE.NAMES = FALSE)
[10:59:37.297]                       do.call(mapply, args = args)
[10:59:37.297]                     }
[10:59:37.297]                   }
[10:59:37.297]                 }, immediateCondition = function(cond) {
[10:59:37.297]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.297]                   sendCondition(cond)
[10:59:37.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.297]                   {
[10:59:37.297]                     inherits <- base::inherits
[10:59:37.297]                     invokeRestart <- base::invokeRestart
[10:59:37.297]                     is.null <- base::is.null
[10:59:37.297]                     muffled <- FALSE
[10:59:37.297]                     if (inherits(cond, "message")) {
[10:59:37.297]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.297]                       if (muffled) 
[10:59:37.297]                         invokeRestart("muffleMessage")
[10:59:37.297]                     }
[10:59:37.297]                     else if (inherits(cond, "warning")) {
[10:59:37.297]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.297]                       if (muffled) 
[10:59:37.297]                         invokeRestart("muffleWarning")
[10:59:37.297]                     }
[10:59:37.297]                     else if (inherits(cond, "condition")) {
[10:59:37.297]                       if (!is.null(pattern)) {
[10:59:37.297]                         computeRestarts <- base::computeRestarts
[10:59:37.297]                         grepl <- base::grepl
[10:59:37.297]                         restarts <- computeRestarts(cond)
[10:59:37.297]                         for (restart in restarts) {
[10:59:37.297]                           name <- restart$name
[10:59:37.297]                           if (is.null(name)) 
[10:59:37.297]                             next
[10:59:37.297]                           if (!grepl(pattern, name)) 
[10:59:37.297]                             next
[10:59:37.297]                           invokeRestart(restart)
[10:59:37.297]                           muffled <- TRUE
[10:59:37.297]                           break
[10:59:37.297]                         }
[10:59:37.297]                       }
[10:59:37.297]                     }
[10:59:37.297]                     invisible(muffled)
[10:59:37.297]                   }
[10:59:37.297]                   muffleCondition(cond)
[10:59:37.297]                 })
[10:59:37.297]             }))
[10:59:37.297]             future::FutureResult(value = ...future.value$value, 
[10:59:37.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.297]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.297]                     ...future.globalenv.names))
[10:59:37.297]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.297]         }, condition = base::local({
[10:59:37.297]             c <- base::c
[10:59:37.297]             inherits <- base::inherits
[10:59:37.297]             invokeRestart <- base::invokeRestart
[10:59:37.297]             length <- base::length
[10:59:37.297]             list <- base::list
[10:59:37.297]             seq.int <- base::seq.int
[10:59:37.297]             signalCondition <- base::signalCondition
[10:59:37.297]             sys.calls <- base::sys.calls
[10:59:37.297]             `[[` <- base::`[[`
[10:59:37.297]             `+` <- base::`+`
[10:59:37.297]             `<<-` <- base::`<<-`
[10:59:37.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.297]                   3L)]
[10:59:37.297]             }
[10:59:37.297]             function(cond) {
[10:59:37.297]                 is_error <- inherits(cond, "error")
[10:59:37.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.297]                   NULL)
[10:59:37.297]                 if (is_error) {
[10:59:37.297]                   sessionInformation <- function() {
[10:59:37.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.297]                       search = base::search(), system = base::Sys.info())
[10:59:37.297]                   }
[10:59:37.297]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.297]                     cond$call), session = sessionInformation(), 
[10:59:37.297]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.297]                   signalCondition(cond)
[10:59:37.297]                 }
[10:59:37.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.297]                 "immediateCondition"))) {
[10:59:37.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.297]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.297]                   if (TRUE && !signal) {
[10:59:37.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.297]                     {
[10:59:37.297]                       inherits <- base::inherits
[10:59:37.297]                       invokeRestart <- base::invokeRestart
[10:59:37.297]                       is.null <- base::is.null
[10:59:37.297]                       muffled <- FALSE
[10:59:37.297]                       if (inherits(cond, "message")) {
[10:59:37.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.297]                         if (muffled) 
[10:59:37.297]                           invokeRestart("muffleMessage")
[10:59:37.297]                       }
[10:59:37.297]                       else if (inherits(cond, "warning")) {
[10:59:37.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.297]                         if (muffled) 
[10:59:37.297]                           invokeRestart("muffleWarning")
[10:59:37.297]                       }
[10:59:37.297]                       else if (inherits(cond, "condition")) {
[10:59:37.297]                         if (!is.null(pattern)) {
[10:59:37.297]                           computeRestarts <- base::computeRestarts
[10:59:37.297]                           grepl <- base::grepl
[10:59:37.297]                           restarts <- computeRestarts(cond)
[10:59:37.297]                           for (restart in restarts) {
[10:59:37.297]                             name <- restart$name
[10:59:37.297]                             if (is.null(name)) 
[10:59:37.297]                               next
[10:59:37.297]                             if (!grepl(pattern, name)) 
[10:59:37.297]                               next
[10:59:37.297]                             invokeRestart(restart)
[10:59:37.297]                             muffled <- TRUE
[10:59:37.297]                             break
[10:59:37.297]                           }
[10:59:37.297]                         }
[10:59:37.297]                       }
[10:59:37.297]                       invisible(muffled)
[10:59:37.297]                     }
[10:59:37.297]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.297]                   }
[10:59:37.297]                 }
[10:59:37.297]                 else {
[10:59:37.297]                   if (TRUE) {
[10:59:37.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.297]                     {
[10:59:37.297]                       inherits <- base::inherits
[10:59:37.297]                       invokeRestart <- base::invokeRestart
[10:59:37.297]                       is.null <- base::is.null
[10:59:37.297]                       muffled <- FALSE
[10:59:37.297]                       if (inherits(cond, "message")) {
[10:59:37.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.297]                         if (muffled) 
[10:59:37.297]                           invokeRestart("muffleMessage")
[10:59:37.297]                       }
[10:59:37.297]                       else if (inherits(cond, "warning")) {
[10:59:37.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.297]                         if (muffled) 
[10:59:37.297]                           invokeRestart("muffleWarning")
[10:59:37.297]                       }
[10:59:37.297]                       else if (inherits(cond, "condition")) {
[10:59:37.297]                         if (!is.null(pattern)) {
[10:59:37.297]                           computeRestarts <- base::computeRestarts
[10:59:37.297]                           grepl <- base::grepl
[10:59:37.297]                           restarts <- computeRestarts(cond)
[10:59:37.297]                           for (restart in restarts) {
[10:59:37.297]                             name <- restart$name
[10:59:37.297]                             if (is.null(name)) 
[10:59:37.297]                               next
[10:59:37.297]                             if (!grepl(pattern, name)) 
[10:59:37.297]                               next
[10:59:37.297]                             invokeRestart(restart)
[10:59:37.297]                             muffled <- TRUE
[10:59:37.297]                             break
[10:59:37.297]                           }
[10:59:37.297]                         }
[10:59:37.297]                       }
[10:59:37.297]                       invisible(muffled)
[10:59:37.297]                     }
[10:59:37.297]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.297]                   }
[10:59:37.297]                 }
[10:59:37.297]             }
[10:59:37.297]         }))
[10:59:37.297]     }, error = function(ex) {
[10:59:37.297]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.297]                 ...future.rng), started = ...future.startTime, 
[10:59:37.297]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.297]             version = "1.8"), class = "FutureResult")
[10:59:37.297]     }, finally = {
[10:59:37.297]         if (!identical(...future.workdir, getwd())) 
[10:59:37.297]             setwd(...future.workdir)
[10:59:37.297]         {
[10:59:37.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.297]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.297]             }
[10:59:37.297]             base::options(...future.oldOptions)
[10:59:37.297]             if (.Platform$OS.type == "windows") {
[10:59:37.297]                 old_names <- names(...future.oldEnvVars)
[10:59:37.297]                 envs <- base::Sys.getenv()
[10:59:37.297]                 names <- names(envs)
[10:59:37.297]                 common <- intersect(names, old_names)
[10:59:37.297]                 added <- setdiff(names, old_names)
[10:59:37.297]                 removed <- setdiff(old_names, names)
[10:59:37.297]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.297]                   envs[common]]
[10:59:37.297]                 NAMES <- toupper(changed)
[10:59:37.297]                 args <- list()
[10:59:37.297]                 for (kk in seq_along(NAMES)) {
[10:59:37.297]                   name <- changed[[kk]]
[10:59:37.297]                   NAME <- NAMES[[kk]]
[10:59:37.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.297]                     next
[10:59:37.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.297]                 }
[10:59:37.297]                 NAMES <- toupper(added)
[10:59:37.297]                 for (kk in seq_along(NAMES)) {
[10:59:37.297]                   name <- added[[kk]]
[10:59:37.297]                   NAME <- NAMES[[kk]]
[10:59:37.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.297]                     next
[10:59:37.297]                   args[[name]] <- ""
[10:59:37.297]                 }
[10:59:37.297]                 NAMES <- toupper(removed)
[10:59:37.297]                 for (kk in seq_along(NAMES)) {
[10:59:37.297]                   name <- removed[[kk]]
[10:59:37.297]                   NAME <- NAMES[[kk]]
[10:59:37.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.297]                     next
[10:59:37.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.297]                 }
[10:59:37.297]                 if (length(args) > 0) 
[10:59:37.297]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.297]             }
[10:59:37.297]             else {
[10:59:37.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.297]             }
[10:59:37.297]             {
[10:59:37.297]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.297]                   0L) {
[10:59:37.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.297]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.297]                   base::options(opts)
[10:59:37.297]                 }
[10:59:37.297]                 {
[10:59:37.297]                   {
[10:59:37.297]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.297]                     NULL
[10:59:37.297]                   }
[10:59:37.297]                   options(future.plan = NULL)
[10:59:37.297]                   if (is.na(NA_character_)) 
[10:59:37.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.297]                     .init = FALSE)
[10:59:37.297]                 }
[10:59:37.297]             }
[10:59:37.297]         }
[10:59:37.297]     })
[10:59:37.297]     if (TRUE) {
[10:59:37.297]         base::sink(type = "output", split = FALSE)
[10:59:37.297]         if (TRUE) {
[10:59:37.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.297]         }
[10:59:37.297]         else {
[10:59:37.297]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.297]         }
[10:59:37.297]         base::close(...future.stdout)
[10:59:37.297]         ...future.stdout <- NULL
[10:59:37.297]     }
[10:59:37.297]     ...future.result$conditions <- ...future.conditions
[10:59:37.297]     ...future.result$finished <- base::Sys.time()
[10:59:37.297]     ...future.result
[10:59:37.297] }
[10:59:37.300] Exporting 5 global objects (651 bytes) to cluster node #1 ...
[10:59:37.300] Exporting ‘...future.FUN’ (32 bytes) to cluster node #1 ...
[10:59:37.301] Exporting ‘...future.FUN’ (32 bytes) to cluster node #1 ... DONE
[10:59:37.301] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:37.301] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.301] Exporting ‘...future.elements_ii’ (75 bytes) to cluster node #1 ...
[10:59:37.302] Exporting ‘...future.elements_ii’ (75 bytes) to cluster node #1 ... DONE
[10:59:37.302] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:37.302] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.302] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:37.303] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.303] Exporting 5 global objects (651 bytes) to cluster node #1 ... DONE
[10:59:37.303] MultisessionFuture started
[10:59:37.303] - Launch lazy future ... done
[10:59:37.303] run() for ‘MultisessionFuture’ ... done
[10:59:37.303] Created future:
[10:59:37.304] MultisessionFuture:
[10:59:37.304] Label: ‘future_Map-1’
[10:59:37.304] Expression:
[10:59:37.304] {
[10:59:37.304]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.304]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.304]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.304]         on.exit(options(oopts), add = TRUE)
[10:59:37.304]     }
[10:59:37.304]     {
[10:59:37.304]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.304]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.304]         do.call(mapply, args = args)
[10:59:37.304]     }
[10:59:37.304] }
[10:59:37.304] Lazy evaluation: FALSE
[10:59:37.304] Asynchronous evaluation: TRUE
[10:59:37.304] Local evaluation: TRUE
[10:59:37.304] Environment: R_GlobalEnv
[10:59:37.304] Capture standard output: TRUE
[10:59:37.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.304] Globals: 5 objects totaling 188 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 75 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.304] Packages: <none>
[10:59:37.304] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:37.304] Resolved: FALSE
[10:59:37.304] Value: <not collected>
[10:59:37.304] Conditions captured: <none>
[10:59:37.304] Early signaling: FALSE
[10:59:37.304] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.304] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.315] Chunk #1 of 2 ... DONE
[10:59:37.315] Chunk #2 of 2 ...
[10:59:37.315]  - Finding globals in '...' for chunk #2 ...
[10:59:37.315] getGlobalsAndPackages() ...
[10:59:37.315] Searching for globals...
[10:59:37.316] 
[10:59:37.316] Searching for globals ... DONE
[10:59:37.316] - globals: [0] <none>
[10:59:37.316] getGlobalsAndPackages() ... DONE
[10:59:37.316]    + additional globals found: [n=0] 
[10:59:37.316]    + additional namespaces needed: [n=0] 
[10:59:37.316]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:37.316]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.316]  - seeds: <none>
[10:59:37.316]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.317] getGlobalsAndPackages() ...
[10:59:37.317] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.317] Resolving globals: FALSE
[10:59:37.317] The total size of the 5 globals is 216 bytes (216 bytes)
[10:59:37.317] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 216 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (103 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:37.318] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.318] 
[10:59:37.318] getGlobalsAndPackages() ... DONE
[10:59:37.318] run() for ‘Future’ ...
[10:59:37.318] - state: ‘created’
[10:59:37.318] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.332] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.332]   - Field: ‘node’
[10:59:37.332]   - Field: ‘label’
[10:59:37.332]   - Field: ‘local’
[10:59:37.332]   - Field: ‘owner’
[10:59:37.333]   - Field: ‘envir’
[10:59:37.333]   - Field: ‘workers’
[10:59:37.333]   - Field: ‘packages’
[10:59:37.333]   - Field: ‘gc’
[10:59:37.333]   - Field: ‘conditions’
[10:59:37.333]   - Field: ‘persistent’
[10:59:37.333]   - Field: ‘expr’
[10:59:37.333]   - Field: ‘uuid’
[10:59:37.333]   - Field: ‘seed’
[10:59:37.333]   - Field: ‘version’
[10:59:37.333]   - Field: ‘result’
[10:59:37.333]   - Field: ‘asynchronous’
[10:59:37.333]   - Field: ‘calls’
[10:59:37.334]   - Field: ‘globals’
[10:59:37.334]   - Field: ‘stdout’
[10:59:37.334]   - Field: ‘earlySignal’
[10:59:37.334]   - Field: ‘lazy’
[10:59:37.334]   - Field: ‘state’
[10:59:37.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.334] - Launch lazy future ...
[10:59:37.334] Packages needed by the future expression (n = 0): <none>
[10:59:37.334] Packages needed by future strategies (n = 0): <none>
[10:59:37.335] {
[10:59:37.335]     {
[10:59:37.335]         {
[10:59:37.335]             ...future.startTime <- base::Sys.time()
[10:59:37.335]             {
[10:59:37.335]                 {
[10:59:37.335]                   {
[10:59:37.335]                     {
[10:59:37.335]                       base::local({
[10:59:37.335]                         has_future <- base::requireNamespace("future", 
[10:59:37.335]                           quietly = TRUE)
[10:59:37.335]                         if (has_future) {
[10:59:37.335]                           ns <- base::getNamespace("future")
[10:59:37.335]                           version <- ns[[".package"]][["version"]]
[10:59:37.335]                           if (is.null(version)) 
[10:59:37.335]                             version <- utils::packageVersion("future")
[10:59:37.335]                         }
[10:59:37.335]                         else {
[10:59:37.335]                           version <- NULL
[10:59:37.335]                         }
[10:59:37.335]                         if (!has_future || version < "1.8.0") {
[10:59:37.335]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.335]                             "", base::R.version$version.string), 
[10:59:37.335]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:37.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:37.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.335]                               "release", "version")], collapse = " "), 
[10:59:37.335]                             hostname = base::Sys.info()[["nodename"]])
[10:59:37.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.335]                             info)
[10:59:37.335]                           info <- base::paste(info, collapse = "; ")
[10:59:37.335]                           if (!has_future) {
[10:59:37.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.335]                               info)
[10:59:37.335]                           }
[10:59:37.335]                           else {
[10:59:37.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.335]                               info, version)
[10:59:37.335]                           }
[10:59:37.335]                           base::stop(msg)
[10:59:37.335]                         }
[10:59:37.335]                       })
[10:59:37.335]                     }
[10:59:37.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.335]                     base::options(mc.cores = 1L)
[10:59:37.335]                   }
[10:59:37.335]                   ...future.strategy.old <- future::plan("list")
[10:59:37.335]                   options(future.plan = NULL)
[10:59:37.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.335]                 }
[10:59:37.335]                 ...future.workdir <- getwd()
[10:59:37.335]             }
[10:59:37.335]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.335]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.335]         }
[10:59:37.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.335]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.335]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.335]             base::names(...future.oldOptions))
[10:59:37.335]     }
[10:59:37.335]     if (FALSE) {
[10:59:37.335]     }
[10:59:37.335]     else {
[10:59:37.335]         if (TRUE) {
[10:59:37.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.335]                 open = "w")
[10:59:37.335]         }
[10:59:37.335]         else {
[10:59:37.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.335]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.335]         }
[10:59:37.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.335]             base::sink(type = "output", split = FALSE)
[10:59:37.335]             base::close(...future.stdout)
[10:59:37.335]         }, add = TRUE)
[10:59:37.335]     }
[10:59:37.335]     ...future.frame <- base::sys.nframe()
[10:59:37.335]     ...future.conditions <- base::list()
[10:59:37.335]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.335]     if (FALSE) {
[10:59:37.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.335]     }
[10:59:37.335]     ...future.result <- base::tryCatch({
[10:59:37.335]         base::withCallingHandlers({
[10:59:37.335]             ...future.value <- base::withVisible(base::local({
[10:59:37.335]                 ...future.makeSendCondition <- base::local({
[10:59:37.335]                   sendCondition <- NULL
[10:59:37.335]                   function(frame = 1L) {
[10:59:37.335]                     if (is.function(sendCondition)) 
[10:59:37.335]                       return(sendCondition)
[10:59:37.335]                     ns <- getNamespace("parallel")
[10:59:37.335]                     if (exists("sendData", mode = "function", 
[10:59:37.335]                       envir = ns)) {
[10:59:37.335]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.335]                         envir = ns)
[10:59:37.335]                       envir <- sys.frame(frame)
[10:59:37.335]                       master <- NULL
[10:59:37.335]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.335]                         !identical(envir, emptyenv())) {
[10:59:37.335]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.335]                           inherits = FALSE)) {
[10:59:37.335]                           master <- get("master", mode = "list", 
[10:59:37.335]                             envir = envir, inherits = FALSE)
[10:59:37.335]                           if (inherits(master, c("SOCKnode", 
[10:59:37.335]                             "SOCK0node"))) {
[10:59:37.335]                             sendCondition <<- function(cond) {
[10:59:37.335]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.335]                                 success = TRUE)
[10:59:37.335]                               parallel_sendData(master, data)
[10:59:37.335]                             }
[10:59:37.335]                             return(sendCondition)
[10:59:37.335]                           }
[10:59:37.335]                         }
[10:59:37.335]                         frame <- frame + 1L
[10:59:37.335]                         envir <- sys.frame(frame)
[10:59:37.335]                       }
[10:59:37.335]                     }
[10:59:37.335]                     sendCondition <<- function(cond) NULL
[10:59:37.335]                   }
[10:59:37.335]                 })
[10:59:37.335]                 withCallingHandlers({
[10:59:37.335]                   {
[10:59:37.335]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.335]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.335]                       ...future.globals.maxSize)) {
[10:59:37.335]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.335]                       on.exit(options(oopts), add = TRUE)
[10:59:37.335]                     }
[10:59:37.335]                     {
[10:59:37.335]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.335]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.335]                         USE.NAMES = FALSE)
[10:59:37.335]                       do.call(mapply, args = args)
[10:59:37.335]                     }
[10:59:37.335]                   }
[10:59:37.335]                 }, immediateCondition = function(cond) {
[10:59:37.335]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.335]                   sendCondition(cond)
[10:59:37.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.335]                   {
[10:59:37.335]                     inherits <- base::inherits
[10:59:37.335]                     invokeRestart <- base::invokeRestart
[10:59:37.335]                     is.null <- base::is.null
[10:59:37.335]                     muffled <- FALSE
[10:59:37.335]                     if (inherits(cond, "message")) {
[10:59:37.335]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.335]                       if (muffled) 
[10:59:37.335]                         invokeRestart("muffleMessage")
[10:59:37.335]                     }
[10:59:37.335]                     else if (inherits(cond, "warning")) {
[10:59:37.335]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.335]                       if (muffled) 
[10:59:37.335]                         invokeRestart("muffleWarning")
[10:59:37.335]                     }
[10:59:37.335]                     else if (inherits(cond, "condition")) {
[10:59:37.335]                       if (!is.null(pattern)) {
[10:59:37.335]                         computeRestarts <- base::computeRestarts
[10:59:37.335]                         grepl <- base::grepl
[10:59:37.335]                         restarts <- computeRestarts(cond)
[10:59:37.335]                         for (restart in restarts) {
[10:59:37.335]                           name <- restart$name
[10:59:37.335]                           if (is.null(name)) 
[10:59:37.335]                             next
[10:59:37.335]                           if (!grepl(pattern, name)) 
[10:59:37.335]                             next
[10:59:37.335]                           invokeRestart(restart)
[10:59:37.335]                           muffled <- TRUE
[10:59:37.335]                           break
[10:59:37.335]                         }
[10:59:37.335]                       }
[10:59:37.335]                     }
[10:59:37.335]                     invisible(muffled)
[10:59:37.335]                   }
[10:59:37.335]                   muffleCondition(cond)
[10:59:37.335]                 })
[10:59:37.335]             }))
[10:59:37.335]             future::FutureResult(value = ...future.value$value, 
[10:59:37.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.335]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.335]                     ...future.globalenv.names))
[10:59:37.335]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.335]         }, condition = base::local({
[10:59:37.335]             c <- base::c
[10:59:37.335]             inherits <- base::inherits
[10:59:37.335]             invokeRestart <- base::invokeRestart
[10:59:37.335]             length <- base::length
[10:59:37.335]             list <- base::list
[10:59:37.335]             seq.int <- base::seq.int
[10:59:37.335]             signalCondition <- base::signalCondition
[10:59:37.335]             sys.calls <- base::sys.calls
[10:59:37.335]             `[[` <- base::`[[`
[10:59:37.335]             `+` <- base::`+`
[10:59:37.335]             `<<-` <- base::`<<-`
[10:59:37.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.335]                   3L)]
[10:59:37.335]             }
[10:59:37.335]             function(cond) {
[10:59:37.335]                 is_error <- inherits(cond, "error")
[10:59:37.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.335]                   NULL)
[10:59:37.335]                 if (is_error) {
[10:59:37.335]                   sessionInformation <- function() {
[10:59:37.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.335]                       search = base::search(), system = base::Sys.info())
[10:59:37.335]                   }
[10:59:37.335]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.335]                     cond$call), session = sessionInformation(), 
[10:59:37.335]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.335]                   signalCondition(cond)
[10:59:37.335]                 }
[10:59:37.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.335]                 "immediateCondition"))) {
[10:59:37.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.335]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.335]                   if (TRUE && !signal) {
[10:59:37.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.335]                     {
[10:59:37.335]                       inherits <- base::inherits
[10:59:37.335]                       invokeRestart <- base::invokeRestart
[10:59:37.335]                       is.null <- base::is.null
[10:59:37.335]                       muffled <- FALSE
[10:59:37.335]                       if (inherits(cond, "message")) {
[10:59:37.335]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.335]                         if (muffled) 
[10:59:37.335]                           invokeRestart("muffleMessage")
[10:59:37.335]                       }
[10:59:37.335]                       else if (inherits(cond, "warning")) {
[10:59:37.335]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.335]                         if (muffled) 
[10:59:37.335]                           invokeRestart("muffleWarning")
[10:59:37.335]                       }
[10:59:37.335]                       else if (inherits(cond, "condition")) {
[10:59:37.335]                         if (!is.null(pattern)) {
[10:59:37.335]                           computeRestarts <- base::computeRestarts
[10:59:37.335]                           grepl <- base::grepl
[10:59:37.335]                           restarts <- computeRestarts(cond)
[10:59:37.335]                           for (restart in restarts) {
[10:59:37.335]                             name <- restart$name
[10:59:37.335]                             if (is.null(name)) 
[10:59:37.335]                               next
[10:59:37.335]                             if (!grepl(pattern, name)) 
[10:59:37.335]                               next
[10:59:37.335]                             invokeRestart(restart)
[10:59:37.335]                             muffled <- TRUE
[10:59:37.335]                             break
[10:59:37.335]                           }
[10:59:37.335]                         }
[10:59:37.335]                       }
[10:59:37.335]                       invisible(muffled)
[10:59:37.335]                     }
[10:59:37.335]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.335]                   }
[10:59:37.335]                 }
[10:59:37.335]                 else {
[10:59:37.335]                   if (TRUE) {
[10:59:37.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.335]                     {
[10:59:37.335]                       inherits <- base::inherits
[10:59:37.335]                       invokeRestart <- base::invokeRestart
[10:59:37.335]                       is.null <- base::is.null
[10:59:37.335]                       muffled <- FALSE
[10:59:37.335]                       if (inherits(cond, "message")) {
[10:59:37.335]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.335]                         if (muffled) 
[10:59:37.335]                           invokeRestart("muffleMessage")
[10:59:37.335]                       }
[10:59:37.335]                       else if (inherits(cond, "warning")) {
[10:59:37.335]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.335]                         if (muffled) 
[10:59:37.335]                           invokeRestart("muffleWarning")
[10:59:37.335]                       }
[10:59:37.335]                       else if (inherits(cond, "condition")) {
[10:59:37.335]                         if (!is.null(pattern)) {
[10:59:37.335]                           computeRestarts <- base::computeRestarts
[10:59:37.335]                           grepl <- base::grepl
[10:59:37.335]                           restarts <- computeRestarts(cond)
[10:59:37.335]                           for (restart in restarts) {
[10:59:37.335]                             name <- restart$name
[10:59:37.335]                             if (is.null(name)) 
[10:59:37.335]                               next
[10:59:37.335]                             if (!grepl(pattern, name)) 
[10:59:37.335]                               next
[10:59:37.335]                             invokeRestart(restart)
[10:59:37.335]                             muffled <- TRUE
[10:59:37.335]                             break
[10:59:37.335]                           }
[10:59:37.335]                         }
[10:59:37.335]                       }
[10:59:37.335]                       invisible(muffled)
[10:59:37.335]                     }
[10:59:37.335]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.335]                   }
[10:59:37.335]                 }
[10:59:37.335]             }
[10:59:37.335]         }))
[10:59:37.335]     }, error = function(ex) {
[10:59:37.335]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.335]                 ...future.rng), started = ...future.startTime, 
[10:59:37.335]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.335]             version = "1.8"), class = "FutureResult")
[10:59:37.335]     }, finally = {
[10:59:37.335]         if (!identical(...future.workdir, getwd())) 
[10:59:37.335]             setwd(...future.workdir)
[10:59:37.335]         {
[10:59:37.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.335]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.335]             }
[10:59:37.335]             base::options(...future.oldOptions)
[10:59:37.335]             if (.Platform$OS.type == "windows") {
[10:59:37.335]                 old_names <- names(...future.oldEnvVars)
[10:59:37.335]                 envs <- base::Sys.getenv()
[10:59:37.335]                 names <- names(envs)
[10:59:37.335]                 common <- intersect(names, old_names)
[10:59:37.335]                 added <- setdiff(names, old_names)
[10:59:37.335]                 removed <- setdiff(old_names, names)
[10:59:37.335]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.335]                   envs[common]]
[10:59:37.335]                 NAMES <- toupper(changed)
[10:59:37.335]                 args <- list()
[10:59:37.335]                 for (kk in seq_along(NAMES)) {
[10:59:37.335]                   name <- changed[[kk]]
[10:59:37.335]                   NAME <- NAMES[[kk]]
[10:59:37.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.335]                     next
[10:59:37.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.335]                 }
[10:59:37.335]                 NAMES <- toupper(added)
[10:59:37.335]                 for (kk in seq_along(NAMES)) {
[10:59:37.335]                   name <- added[[kk]]
[10:59:37.335]                   NAME <- NAMES[[kk]]
[10:59:37.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.335]                     next
[10:59:37.335]                   args[[name]] <- ""
[10:59:37.335]                 }
[10:59:37.335]                 NAMES <- toupper(removed)
[10:59:37.335]                 for (kk in seq_along(NAMES)) {
[10:59:37.335]                   name <- removed[[kk]]
[10:59:37.335]                   NAME <- NAMES[[kk]]
[10:59:37.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.335]                     next
[10:59:37.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.335]                 }
[10:59:37.335]                 if (length(args) > 0) 
[10:59:37.335]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.335]             }
[10:59:37.335]             else {
[10:59:37.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.335]             }
[10:59:37.335]             {
[10:59:37.335]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.335]                   0L) {
[10:59:37.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.335]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.335]                   base::options(opts)
[10:59:37.335]                 }
[10:59:37.335]                 {
[10:59:37.335]                   {
[10:59:37.335]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.335]                     NULL
[10:59:37.335]                   }
[10:59:37.335]                   options(future.plan = NULL)
[10:59:37.335]                   if (is.na(NA_character_)) 
[10:59:37.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.335]                     .init = FALSE)
[10:59:37.335]                 }
[10:59:37.335]             }
[10:59:37.335]         }
[10:59:37.335]     })
[10:59:37.335]     if (TRUE) {
[10:59:37.335]         base::sink(type = "output", split = FALSE)
[10:59:37.335]         if (TRUE) {
[10:59:37.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.335]         }
[10:59:37.335]         else {
[10:59:37.335]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.335]         }
[10:59:37.335]         base::close(...future.stdout)
[10:59:37.335]         ...future.stdout <- NULL
[10:59:37.335]     }
[10:59:37.335]     ...future.result$conditions <- ...future.conditions
[10:59:37.335]     ...future.result$finished <- base::Sys.time()
[10:59:37.335]     ...future.result
[10:59:37.335] }
[10:59:37.337] Exporting 5 global objects (679 bytes) to cluster node #2 ...
[10:59:37.338] Exporting ‘...future.FUN’ (32 bytes) to cluster node #2 ...
[10:59:37.338] Exporting ‘...future.FUN’ (32 bytes) to cluster node #2 ... DONE
[10:59:37.338] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:37.338] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.339] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[10:59:37.339] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[10:59:37.339] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:37.339] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.340] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:37.340] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.340] Exporting 5 global objects (679 bytes) to cluster node #2 ... DONE
[10:59:37.340] MultisessionFuture started
[10:59:37.340] - Launch lazy future ... done
[10:59:37.341] run() for ‘MultisessionFuture’ ... done
[10:59:37.341] Created future:
[10:59:37.341] MultisessionFuture:
[10:59:37.341] Label: ‘future_Map-2’
[10:59:37.341] Expression:
[10:59:37.341] {
[10:59:37.341]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.341]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.341]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.341]         on.exit(options(oopts), add = TRUE)
[10:59:37.341]     }
[10:59:37.341]     {
[10:59:37.341]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.341]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.341]         do.call(mapply, args = args)
[10:59:37.341]     }
[10:59:37.341] }
[10:59:37.341] Lazy evaluation: FALSE
[10:59:37.341] Asynchronous evaluation: TRUE
[10:59:37.341] Local evaluation: TRUE
[10:59:37.341] Environment: R_GlobalEnv
[10:59:37.341] Capture standard output: TRUE
[10:59:37.341] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.341] Globals: 5 objects totaling 216 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.341] Packages: <none>
[10:59:37.341] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:37.341] Resolved: FALSE
[10:59:37.341] Value: <not collected>
[10:59:37.341] Conditions captured: <none>
[10:59:37.341] Early signaling: FALSE
[10:59:37.341] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.341] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.352] Chunk #2 of 2 ... DONE
[10:59:37.352] Launching 2 futures (chunks) ... DONE
[10:59:37.352] Resolving 2 futures (chunks) ...
[10:59:37.352] resolve() on list ...
[10:59:37.353]  recursive: 0
[10:59:37.353]  length: 2
[10:59:37.353] 
[10:59:37.353] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.353] - Validating connection of MultisessionFuture
[10:59:37.353] - received message: FutureResult
[10:59:37.354] - Received FutureResult
[10:59:37.354] - Erased future from FutureRegistry
[10:59:37.354] result() for ClusterFuture ...
[10:59:37.354] - result already collected: FutureResult
[10:59:37.354] result() for ClusterFuture ... done
[10:59:37.354] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.354] Future #1
[10:59:37.354] result() for ClusterFuture ...
[10:59:37.354] - result already collected: FutureResult
[10:59:37.354] result() for ClusterFuture ... done
[10:59:37.354] result() for ClusterFuture ...
[10:59:37.354] - result already collected: FutureResult
[10:59:37.355] result() for ClusterFuture ... done
[10:59:37.355] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:37.355] - nx: 2
[10:59:37.355] - relay: TRUE
[10:59:37.355] - stdout: TRUE
[10:59:37.355] - signal: TRUE
[10:59:37.355] - resignal: FALSE
[10:59:37.355] - force: TRUE
[10:59:37.355] - relayed: [n=2] FALSE, FALSE
[10:59:37.355] - queued futures: [n=2] FALSE, FALSE
[10:59:37.355]  - until=1
[10:59:37.355]  - relaying element #1
[10:59:37.356] result() for ClusterFuture ...
[10:59:37.356] - result already collected: FutureResult
[10:59:37.356] result() for ClusterFuture ... done
[10:59:37.356] result() for ClusterFuture ...
[10:59:37.356] - result already collected: FutureResult
[10:59:37.356] result() for ClusterFuture ... done
[10:59:37.356] result() for ClusterFuture ...
[10:59:37.356] - result already collected: FutureResult
[10:59:37.356] result() for ClusterFuture ... done
[10:59:37.356] result() for ClusterFuture ...
[10:59:37.356] - result already collected: FutureResult
[10:59:37.356] result() for ClusterFuture ... done
[10:59:37.357] - relayed: [n=2] TRUE, FALSE
[10:59:37.357] - queued futures: [n=2] TRUE, FALSE
[10:59:37.357] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:37.357]  length: 1 (resolved future 1)
[10:59:37.382] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.382] - Validating connection of MultisessionFuture
[10:59:37.382] - received message: FutureResult
[10:59:37.383] - Received FutureResult
[10:59:37.383] - Erased future from FutureRegistry
[10:59:37.383] result() for ClusterFuture ...
[10:59:37.383] - result already collected: FutureResult
[10:59:37.383] result() for ClusterFuture ... done
[10:59:37.383] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.383] Future #2
[10:59:37.383] result() for ClusterFuture ...
[10:59:37.383] - result already collected: FutureResult
[10:59:37.383] result() for ClusterFuture ... done
[10:59:37.383] result() for ClusterFuture ...
[10:59:37.383] - result already collected: FutureResult
[10:59:37.384] result() for ClusterFuture ... done
[10:59:37.384] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:37.384] - nx: 2
[10:59:37.384] - relay: TRUE
[10:59:37.384] - stdout: TRUE
[10:59:37.384] - signal: TRUE
[10:59:37.384] - resignal: FALSE
[10:59:37.384] - force: TRUE
[10:59:37.384] - relayed: [n=2] TRUE, FALSE
[10:59:37.384] - queued futures: [n=2] TRUE, FALSE
[10:59:37.384]  - until=2
[10:59:37.384]  - relaying element #2
[10:59:37.385] result() for ClusterFuture ...
[10:59:37.385] - result already collected: FutureResult
[10:59:37.385] result() for ClusterFuture ... done
[10:59:37.385] result() for ClusterFuture ...
[10:59:37.385] - result already collected: FutureResult
[10:59:37.385] result() for ClusterFuture ... done
[10:59:37.385] result() for ClusterFuture ...
[10:59:37.385] - result already collected: FutureResult
[10:59:37.385] result() for ClusterFuture ... done
[10:59:37.385] result() for ClusterFuture ...
[10:59:37.385] - result already collected: FutureResult
[10:59:37.385] result() for ClusterFuture ... done
[10:59:37.385] - relayed: [n=2] TRUE, TRUE
[10:59:37.386] - queued futures: [n=2] TRUE, TRUE
[10:59:37.386] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:37.386]  length: 0 (resolved future 2)
[10:59:37.386] Relaying remaining futures
[10:59:37.386] signalConditionsASAP(NULL, pos=0) ...
[10:59:37.386] - nx: 2
[10:59:37.386] - relay: TRUE
[10:59:37.386] - stdout: TRUE
[10:59:37.386] - signal: TRUE
[10:59:37.386] - resignal: FALSE
[10:59:37.386] - force: TRUE
[10:59:37.386] - relayed: [n=2] TRUE, TRUE
[10:59:37.386] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:37.387] - relayed: [n=2] TRUE, TRUE
[10:59:37.387] - queued futures: [n=2] TRUE, TRUE
[10:59:37.387] signalConditionsASAP(NULL, pos=0) ... done
[10:59:37.387] resolve() on list ... DONE
[10:59:37.387] result() for ClusterFuture ...
[10:59:37.387] - result already collected: FutureResult
[10:59:37.387] result() for ClusterFuture ... done
[10:59:37.387] result() for ClusterFuture ...
[10:59:37.387] - result already collected: FutureResult
[10:59:37.387] result() for ClusterFuture ... done
[10:59:37.387] result() for ClusterFuture ...
[10:59:37.388] - result already collected: FutureResult
[10:59:37.388] result() for ClusterFuture ... done
[10:59:37.388] result() for ClusterFuture ...
[10:59:37.388] - result already collected: FutureResult
[10:59:37.388] result() for ClusterFuture ... done
[10:59:37.388]  - Number of value chunks collected: 2
[10:59:37.388] Resolving 2 futures (chunks) ... DONE
[10:59:37.388] Reducing values from 2 chunks ...
[10:59:37.388]  - Number of values collected after concatenation: 3
[10:59:37.388]  - Number of values expected: 3
[10:59:37.388] Reducing values from 2 chunks ... DONE
[10:59:37.388] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:59:37.389] future_mapply() ...
[10:59:37.390] Number of chunks: 2
[10:59:37.390] getGlobalsAndPackagesXApply() ...
[10:59:37.390]  - future.globals: TRUE
[10:59:37.391] getGlobalsAndPackages() ...
[10:59:37.391] Searching for globals...
[10:59:37.392] - globals found: [1] ‘FUN’
[10:59:37.392] Searching for globals ... DONE
[10:59:37.392] Resolving globals: FALSE
[10:59:37.392] The total size of the 1 globals is 185 bytes (185 bytes)
[10:59:37.392] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:59:37.392] - globals: [1] ‘FUN’
[10:59:37.393] 
[10:59:37.393] getGlobalsAndPackages() ... DONE
[10:59:37.393]  - globals found/used: [n=1] ‘FUN’
[10:59:37.393]  - needed namespaces: [n=0] 
[10:59:37.393] Finding globals ... DONE
[10:59:37.393] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:59:37.393] List of 2
[10:59:37.393]  $ ...future.FUN:function (x)  
[10:59:37.393]  $ MoreArgs     : NULL
[10:59:37.393]  - attr(*, "where")=List of 2
[10:59:37.393]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:59:37.393]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:59:37.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:59:37.393]  - attr(*, "resolved")= logi FALSE
[10:59:37.393]  - attr(*, "total_size")= num NA
[10:59:37.396] Packages to be attached in all futures: [n=0] 
[10:59:37.396] getGlobalsAndPackagesXApply() ... DONE
[10:59:37.396] Number of futures (= number of chunks): 2
[10:59:37.396] Launching 2 futures (chunks) ...
[10:59:37.396] Chunk #1 of 2 ...
[10:59:37.396]  - Finding globals in '...' for chunk #1 ...
[10:59:37.396] getGlobalsAndPackages() ...
[10:59:37.396] Searching for globals...
[10:59:37.397] 
[10:59:37.397] Searching for globals ... DONE
[10:59:37.397] - globals: [0] <none>
[10:59:37.397] getGlobalsAndPackages() ... DONE
[10:59:37.397]    + additional globals found: [n=0] 
[10:59:37.397]    + additional namespaces needed: [n=0] 
[10:59:37.397]  - Finding globals in '...' for chunk #1 ... DONE
[10:59:37.397]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.397]  - seeds: <none>
[10:59:37.397]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.397] getGlobalsAndPackages() ...
[10:59:37.398] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.398] Resolving globals: FALSE
[10:59:37.398] The total size of the 5 globals is 363 bytes (363 bytes)
[10:59:37.398] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:37.399] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.399] 
[10:59:37.399] getGlobalsAndPackages() ... DONE
[10:59:37.399] run() for ‘Future’ ...
[10:59:37.399] - state: ‘created’
[10:59:37.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.413]   - Field: ‘node’
[10:59:37.413]   - Field: ‘label’
[10:59:37.413]   - Field: ‘local’
[10:59:37.413]   - Field: ‘owner’
[10:59:37.413]   - Field: ‘envir’
[10:59:37.413]   - Field: ‘workers’
[10:59:37.413]   - Field: ‘packages’
[10:59:37.414]   - Field: ‘gc’
[10:59:37.414]   - Field: ‘conditions’
[10:59:37.414]   - Field: ‘persistent’
[10:59:37.414]   - Field: ‘expr’
[10:59:37.414]   - Field: ‘uuid’
[10:59:37.414]   - Field: ‘seed’
[10:59:37.414]   - Field: ‘version’
[10:59:37.414]   - Field: ‘result’
[10:59:37.414]   - Field: ‘asynchronous’
[10:59:37.414]   - Field: ‘calls’
[10:59:37.414]   - Field: ‘globals’
[10:59:37.414]   - Field: ‘stdout’
[10:59:37.415]   - Field: ‘earlySignal’
[10:59:37.415]   - Field: ‘lazy’
[10:59:37.415]   - Field: ‘state’
[10:59:37.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.415] - Launch lazy future ...
[10:59:37.415] Packages needed by the future expression (n = 0): <none>
[10:59:37.415] Packages needed by future strategies (n = 0): <none>
[10:59:37.416] {
[10:59:37.416]     {
[10:59:37.416]         {
[10:59:37.416]             ...future.startTime <- base::Sys.time()
[10:59:37.416]             {
[10:59:37.416]                 {
[10:59:37.416]                   {
[10:59:37.416]                     {
[10:59:37.416]                       base::local({
[10:59:37.416]                         has_future <- base::requireNamespace("future", 
[10:59:37.416]                           quietly = TRUE)
[10:59:37.416]                         if (has_future) {
[10:59:37.416]                           ns <- base::getNamespace("future")
[10:59:37.416]                           version <- ns[[".package"]][["version"]]
[10:59:37.416]                           if (is.null(version)) 
[10:59:37.416]                             version <- utils::packageVersion("future")
[10:59:37.416]                         }
[10:59:37.416]                         else {
[10:59:37.416]                           version <- NULL
[10:59:37.416]                         }
[10:59:37.416]                         if (!has_future || version < "1.8.0") {
[10:59:37.416]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.416]                             "", base::R.version$version.string), 
[10:59:37.416]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:37.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:37.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.416]                               "release", "version")], collapse = " "), 
[10:59:37.416]                             hostname = base::Sys.info()[["nodename"]])
[10:59:37.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.416]                             info)
[10:59:37.416]                           info <- base::paste(info, collapse = "; ")
[10:59:37.416]                           if (!has_future) {
[10:59:37.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.416]                               info)
[10:59:37.416]                           }
[10:59:37.416]                           else {
[10:59:37.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.416]                               info, version)
[10:59:37.416]                           }
[10:59:37.416]                           base::stop(msg)
[10:59:37.416]                         }
[10:59:37.416]                       })
[10:59:37.416]                     }
[10:59:37.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.416]                     base::options(mc.cores = 1L)
[10:59:37.416]                   }
[10:59:37.416]                   ...future.strategy.old <- future::plan("list")
[10:59:37.416]                   options(future.plan = NULL)
[10:59:37.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.416]                 }
[10:59:37.416]                 ...future.workdir <- getwd()
[10:59:37.416]             }
[10:59:37.416]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.416]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.416]         }
[10:59:37.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.416]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.416]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.416]             base::names(...future.oldOptions))
[10:59:37.416]     }
[10:59:37.416]     if (FALSE) {
[10:59:37.416]     }
[10:59:37.416]     else {
[10:59:37.416]         if (TRUE) {
[10:59:37.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.416]                 open = "w")
[10:59:37.416]         }
[10:59:37.416]         else {
[10:59:37.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.416]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.416]         }
[10:59:37.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.416]             base::sink(type = "output", split = FALSE)
[10:59:37.416]             base::close(...future.stdout)
[10:59:37.416]         }, add = TRUE)
[10:59:37.416]     }
[10:59:37.416]     ...future.frame <- base::sys.nframe()
[10:59:37.416]     ...future.conditions <- base::list()
[10:59:37.416]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.416]     if (FALSE) {
[10:59:37.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.416]     }
[10:59:37.416]     ...future.result <- base::tryCatch({
[10:59:37.416]         base::withCallingHandlers({
[10:59:37.416]             ...future.value <- base::withVisible(base::local({
[10:59:37.416]                 ...future.makeSendCondition <- base::local({
[10:59:37.416]                   sendCondition <- NULL
[10:59:37.416]                   function(frame = 1L) {
[10:59:37.416]                     if (is.function(sendCondition)) 
[10:59:37.416]                       return(sendCondition)
[10:59:37.416]                     ns <- getNamespace("parallel")
[10:59:37.416]                     if (exists("sendData", mode = "function", 
[10:59:37.416]                       envir = ns)) {
[10:59:37.416]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.416]                         envir = ns)
[10:59:37.416]                       envir <- sys.frame(frame)
[10:59:37.416]                       master <- NULL
[10:59:37.416]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.416]                         !identical(envir, emptyenv())) {
[10:59:37.416]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.416]                           inherits = FALSE)) {
[10:59:37.416]                           master <- get("master", mode = "list", 
[10:59:37.416]                             envir = envir, inherits = FALSE)
[10:59:37.416]                           if (inherits(master, c("SOCKnode", 
[10:59:37.416]                             "SOCK0node"))) {
[10:59:37.416]                             sendCondition <<- function(cond) {
[10:59:37.416]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.416]                                 success = TRUE)
[10:59:37.416]                               parallel_sendData(master, data)
[10:59:37.416]                             }
[10:59:37.416]                             return(sendCondition)
[10:59:37.416]                           }
[10:59:37.416]                         }
[10:59:37.416]                         frame <- frame + 1L
[10:59:37.416]                         envir <- sys.frame(frame)
[10:59:37.416]                       }
[10:59:37.416]                     }
[10:59:37.416]                     sendCondition <<- function(cond) NULL
[10:59:37.416]                   }
[10:59:37.416]                 })
[10:59:37.416]                 withCallingHandlers({
[10:59:37.416]                   {
[10:59:37.416]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.416]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.416]                       ...future.globals.maxSize)) {
[10:59:37.416]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.416]                       on.exit(options(oopts), add = TRUE)
[10:59:37.416]                     }
[10:59:37.416]                     {
[10:59:37.416]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.416]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.416]                         USE.NAMES = FALSE)
[10:59:37.416]                       do.call(mapply, args = args)
[10:59:37.416]                     }
[10:59:37.416]                   }
[10:59:37.416]                 }, immediateCondition = function(cond) {
[10:59:37.416]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.416]                   sendCondition(cond)
[10:59:37.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.416]                   {
[10:59:37.416]                     inherits <- base::inherits
[10:59:37.416]                     invokeRestart <- base::invokeRestart
[10:59:37.416]                     is.null <- base::is.null
[10:59:37.416]                     muffled <- FALSE
[10:59:37.416]                     if (inherits(cond, "message")) {
[10:59:37.416]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.416]                       if (muffled) 
[10:59:37.416]                         invokeRestart("muffleMessage")
[10:59:37.416]                     }
[10:59:37.416]                     else if (inherits(cond, "warning")) {
[10:59:37.416]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.416]                       if (muffled) 
[10:59:37.416]                         invokeRestart("muffleWarning")
[10:59:37.416]                     }
[10:59:37.416]                     else if (inherits(cond, "condition")) {
[10:59:37.416]                       if (!is.null(pattern)) {
[10:59:37.416]                         computeRestarts <- base::computeRestarts
[10:59:37.416]                         grepl <- base::grepl
[10:59:37.416]                         restarts <- computeRestarts(cond)
[10:59:37.416]                         for (restart in restarts) {
[10:59:37.416]                           name <- restart$name
[10:59:37.416]                           if (is.null(name)) 
[10:59:37.416]                             next
[10:59:37.416]                           if (!grepl(pattern, name)) 
[10:59:37.416]                             next
[10:59:37.416]                           invokeRestart(restart)
[10:59:37.416]                           muffled <- TRUE
[10:59:37.416]                           break
[10:59:37.416]                         }
[10:59:37.416]                       }
[10:59:37.416]                     }
[10:59:37.416]                     invisible(muffled)
[10:59:37.416]                   }
[10:59:37.416]                   muffleCondition(cond)
[10:59:37.416]                 })
[10:59:37.416]             }))
[10:59:37.416]             future::FutureResult(value = ...future.value$value, 
[10:59:37.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.416]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.416]                     ...future.globalenv.names))
[10:59:37.416]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.416]         }, condition = base::local({
[10:59:37.416]             c <- base::c
[10:59:37.416]             inherits <- base::inherits
[10:59:37.416]             invokeRestart <- base::invokeRestart
[10:59:37.416]             length <- base::length
[10:59:37.416]             list <- base::list
[10:59:37.416]             seq.int <- base::seq.int
[10:59:37.416]             signalCondition <- base::signalCondition
[10:59:37.416]             sys.calls <- base::sys.calls
[10:59:37.416]             `[[` <- base::`[[`
[10:59:37.416]             `+` <- base::`+`
[10:59:37.416]             `<<-` <- base::`<<-`
[10:59:37.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.416]                   3L)]
[10:59:37.416]             }
[10:59:37.416]             function(cond) {
[10:59:37.416]                 is_error <- inherits(cond, "error")
[10:59:37.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.416]                   NULL)
[10:59:37.416]                 if (is_error) {
[10:59:37.416]                   sessionInformation <- function() {
[10:59:37.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.416]                       search = base::search(), system = base::Sys.info())
[10:59:37.416]                   }
[10:59:37.416]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.416]                     cond$call), session = sessionInformation(), 
[10:59:37.416]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.416]                   signalCondition(cond)
[10:59:37.416]                 }
[10:59:37.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.416]                 "immediateCondition"))) {
[10:59:37.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.416]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.416]                   if (TRUE && !signal) {
[10:59:37.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.416]                     {
[10:59:37.416]                       inherits <- base::inherits
[10:59:37.416]                       invokeRestart <- base::invokeRestart
[10:59:37.416]                       is.null <- base::is.null
[10:59:37.416]                       muffled <- FALSE
[10:59:37.416]                       if (inherits(cond, "message")) {
[10:59:37.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.416]                         if (muffled) 
[10:59:37.416]                           invokeRestart("muffleMessage")
[10:59:37.416]                       }
[10:59:37.416]                       else if (inherits(cond, "warning")) {
[10:59:37.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.416]                         if (muffled) 
[10:59:37.416]                           invokeRestart("muffleWarning")
[10:59:37.416]                       }
[10:59:37.416]                       else if (inherits(cond, "condition")) {
[10:59:37.416]                         if (!is.null(pattern)) {
[10:59:37.416]                           computeRestarts <- base::computeRestarts
[10:59:37.416]                           grepl <- base::grepl
[10:59:37.416]                           restarts <- computeRestarts(cond)
[10:59:37.416]                           for (restart in restarts) {
[10:59:37.416]                             name <- restart$name
[10:59:37.416]                             if (is.null(name)) 
[10:59:37.416]                               next
[10:59:37.416]                             if (!grepl(pattern, name)) 
[10:59:37.416]                               next
[10:59:37.416]                             invokeRestart(restart)
[10:59:37.416]                             muffled <- TRUE
[10:59:37.416]                             break
[10:59:37.416]                           }
[10:59:37.416]                         }
[10:59:37.416]                       }
[10:59:37.416]                       invisible(muffled)
[10:59:37.416]                     }
[10:59:37.416]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.416]                   }
[10:59:37.416]                 }
[10:59:37.416]                 else {
[10:59:37.416]                   if (TRUE) {
[10:59:37.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.416]                     {
[10:59:37.416]                       inherits <- base::inherits
[10:59:37.416]                       invokeRestart <- base::invokeRestart
[10:59:37.416]                       is.null <- base::is.null
[10:59:37.416]                       muffled <- FALSE
[10:59:37.416]                       if (inherits(cond, "message")) {
[10:59:37.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.416]                         if (muffled) 
[10:59:37.416]                           invokeRestart("muffleMessage")
[10:59:37.416]                       }
[10:59:37.416]                       else if (inherits(cond, "warning")) {
[10:59:37.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.416]                         if (muffled) 
[10:59:37.416]                           invokeRestart("muffleWarning")
[10:59:37.416]                       }
[10:59:37.416]                       else if (inherits(cond, "condition")) {
[10:59:37.416]                         if (!is.null(pattern)) {
[10:59:37.416]                           computeRestarts <- base::computeRestarts
[10:59:37.416]                           grepl <- base::grepl
[10:59:37.416]                           restarts <- computeRestarts(cond)
[10:59:37.416]                           for (restart in restarts) {
[10:59:37.416]                             name <- restart$name
[10:59:37.416]                             if (is.null(name)) 
[10:59:37.416]                               next
[10:59:37.416]                             if (!grepl(pattern, name)) 
[10:59:37.416]                               next
[10:59:37.416]                             invokeRestart(restart)
[10:59:37.416]                             muffled <- TRUE
[10:59:37.416]                             break
[10:59:37.416]                           }
[10:59:37.416]                         }
[10:59:37.416]                       }
[10:59:37.416]                       invisible(muffled)
[10:59:37.416]                     }
[10:59:37.416]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.416]                   }
[10:59:37.416]                 }
[10:59:37.416]             }
[10:59:37.416]         }))
[10:59:37.416]     }, error = function(ex) {
[10:59:37.416]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.416]                 ...future.rng), started = ...future.startTime, 
[10:59:37.416]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.416]             version = "1.8"), class = "FutureResult")
[10:59:37.416]     }, finally = {
[10:59:37.416]         if (!identical(...future.workdir, getwd())) 
[10:59:37.416]             setwd(...future.workdir)
[10:59:37.416]         {
[10:59:37.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.416]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.416]             }
[10:59:37.416]             base::options(...future.oldOptions)
[10:59:37.416]             if (.Platform$OS.type == "windows") {
[10:59:37.416]                 old_names <- names(...future.oldEnvVars)
[10:59:37.416]                 envs <- base::Sys.getenv()
[10:59:37.416]                 names <- names(envs)
[10:59:37.416]                 common <- intersect(names, old_names)
[10:59:37.416]                 added <- setdiff(names, old_names)
[10:59:37.416]                 removed <- setdiff(old_names, names)
[10:59:37.416]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.416]                   envs[common]]
[10:59:37.416]                 NAMES <- toupper(changed)
[10:59:37.416]                 args <- list()
[10:59:37.416]                 for (kk in seq_along(NAMES)) {
[10:59:37.416]                   name <- changed[[kk]]
[10:59:37.416]                   NAME <- NAMES[[kk]]
[10:59:37.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.416]                     next
[10:59:37.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.416]                 }
[10:59:37.416]                 NAMES <- toupper(added)
[10:59:37.416]                 for (kk in seq_along(NAMES)) {
[10:59:37.416]                   name <- added[[kk]]
[10:59:37.416]                   NAME <- NAMES[[kk]]
[10:59:37.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.416]                     next
[10:59:37.416]                   args[[name]] <- ""
[10:59:37.416]                 }
[10:59:37.416]                 NAMES <- toupper(removed)
[10:59:37.416]                 for (kk in seq_along(NAMES)) {
[10:59:37.416]                   name <- removed[[kk]]
[10:59:37.416]                   NAME <- NAMES[[kk]]
[10:59:37.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.416]                     next
[10:59:37.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.416]                 }
[10:59:37.416]                 if (length(args) > 0) 
[10:59:37.416]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.416]             }
[10:59:37.416]             else {
[10:59:37.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.416]             }
[10:59:37.416]             {
[10:59:37.416]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.416]                   0L) {
[10:59:37.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.416]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.416]                   base::options(opts)
[10:59:37.416]                 }
[10:59:37.416]                 {
[10:59:37.416]                   {
[10:59:37.416]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.416]                     NULL
[10:59:37.416]                   }
[10:59:37.416]                   options(future.plan = NULL)
[10:59:37.416]                   if (is.na(NA_character_)) 
[10:59:37.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.416]                     .init = FALSE)
[10:59:37.416]                 }
[10:59:37.416]             }
[10:59:37.416]         }
[10:59:37.416]     })
[10:59:37.416]     if (TRUE) {
[10:59:37.416]         base::sink(type = "output", split = FALSE)
[10:59:37.416]         if (TRUE) {
[10:59:37.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.416]         }
[10:59:37.416]         else {
[10:59:37.416]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.416]         }
[10:59:37.416]         base::close(...future.stdout)
[10:59:37.416]         ...future.stdout <- NULL
[10:59:37.416]     }
[10:59:37.416]     ...future.result$conditions <- ...future.conditions
[10:59:37.416]     ...future.result$finished <- base::Sys.time()
[10:59:37.416]     ...future.result
[10:59:37.416] }
[10:59:37.418] Exporting 5 global objects (800 bytes) to cluster node #1 ...
[10:59:37.418] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:59:37.419] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:59:37.419] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:59:37.419] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.420] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #1 ...
[10:59:37.420] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #1 ... DONE
[10:59:37.420] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:59:37.420] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.421] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:59:37.421] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:59:37.421] Exporting 5 global objects (800 bytes) to cluster node #1 ... DONE
[10:59:37.422] MultisessionFuture started
[10:59:37.422] - Launch lazy future ... done
[10:59:37.422] run() for ‘MultisessionFuture’ ... done
[10:59:37.422] Created future:
[10:59:37.422] MultisessionFuture:
[10:59:37.422] Label: ‘future_mapply-1’
[10:59:37.422] Expression:
[10:59:37.422] {
[10:59:37.422]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.422]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.422]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.422]         on.exit(options(oopts), add = TRUE)
[10:59:37.422]     }
[10:59:37.422]     {
[10:59:37.422]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.422]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.422]         do.call(mapply, args = args)
[10:59:37.422]     }
[10:59:37.422] }
[10:59:37.422] Lazy evaluation: FALSE
[10:59:37.422] Asynchronous evaluation: TRUE
[10:59:37.422] Local evaluation: TRUE
[10:59:37.422] Environment: R_GlobalEnv
[10:59:37.422] Capture standard output: TRUE
[10:59:37.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.422] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.422] Packages: <none>
[10:59:37.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:37.422] Resolved: FALSE
[10:59:37.422] Value: <not collected>
[10:59:37.422] Conditions captured: <none>
[10:59:37.422] Early signaling: FALSE
[10:59:37.422] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.433] Chunk #1 of 2 ... DONE
[10:59:37.433] Chunk #2 of 2 ...
[10:59:37.433]  - Finding globals in '...' for chunk #2 ...
[10:59:37.434] getGlobalsAndPackages() ...
[10:59:37.434] Searching for globals...
[10:59:37.434] 
[10:59:37.434] Searching for globals ... DONE
[10:59:37.434] - globals: [0] <none>
[10:59:37.434] getGlobalsAndPackages() ... DONE
[10:59:37.434]    + additional globals found: [n=0] 
[10:59:37.434]    + additional namespaces needed: [n=0] 
[10:59:37.434]  - Finding globals in '...' for chunk #2 ... DONE
[10:59:37.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:59:37.435]  - seeds: <none>
[10:59:37.435]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.435] getGlobalsAndPackages() ...
[10:59:37.435] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.435] Resolving globals: FALSE
[10:59:37.435] The total size of the 5 globals is 363 bytes (363 bytes)
[10:59:37.436] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:59:37.436] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:59:37.436] 
[10:59:37.436] getGlobalsAndPackages() ... DONE
[10:59:37.436] run() for ‘Future’ ...
[10:59:37.436] - state: ‘created’
[10:59:37.437] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:59:37.450] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:59:37.450]   - Field: ‘node’
[10:59:37.450]   - Field: ‘label’
[10:59:37.450]   - Field: ‘local’
[10:59:37.450]   - Field: ‘owner’
[10:59:37.450]   - Field: ‘envir’
[10:59:37.451]   - Field: ‘workers’
[10:59:37.451]   - Field: ‘packages’
[10:59:37.451]   - Field: ‘gc’
[10:59:37.451]   - Field: ‘conditions’
[10:59:37.451]   - Field: ‘persistent’
[10:59:37.451]   - Field: ‘expr’
[10:59:37.451]   - Field: ‘uuid’
[10:59:37.451]   - Field: ‘seed’
[10:59:37.451]   - Field: ‘version’
[10:59:37.451]   - Field: ‘result’
[10:59:37.451]   - Field: ‘asynchronous’
[10:59:37.451]   - Field: ‘calls’
[10:59:37.452]   - Field: ‘globals’
[10:59:37.452]   - Field: ‘stdout’
[10:59:37.452]   - Field: ‘earlySignal’
[10:59:37.452]   - Field: ‘lazy’
[10:59:37.452]   - Field: ‘state’
[10:59:37.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:59:37.452] - Launch lazy future ...
[10:59:37.452] Packages needed by the future expression (n = 0): <none>
[10:59:37.452] Packages needed by future strategies (n = 0): <none>
[10:59:37.453] {
[10:59:37.453]     {
[10:59:37.453]         {
[10:59:37.453]             ...future.startTime <- base::Sys.time()
[10:59:37.453]             {
[10:59:37.453]                 {
[10:59:37.453]                   {
[10:59:37.453]                     {
[10:59:37.453]                       base::local({
[10:59:37.453]                         has_future <- base::requireNamespace("future", 
[10:59:37.453]                           quietly = TRUE)
[10:59:37.453]                         if (has_future) {
[10:59:37.453]                           ns <- base::getNamespace("future")
[10:59:37.453]                           version <- ns[[".package"]][["version"]]
[10:59:37.453]                           if (is.null(version)) 
[10:59:37.453]                             version <- utils::packageVersion("future")
[10:59:37.453]                         }
[10:59:37.453]                         else {
[10:59:37.453]                           version <- NULL
[10:59:37.453]                         }
[10:59:37.453]                         if (!has_future || version < "1.8.0") {
[10:59:37.453]                           info <- base::c(r_version = base::gsub("R version ", 
[10:59:37.453]                             "", base::R.version$version.string), 
[10:59:37.453]                             platform = base::sprintf("%s (%s-bit)", 
[10:59:37.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:59:37.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:59:37.453]                               "release", "version")], collapse = " "), 
[10:59:37.453]                             hostname = base::Sys.info()[["nodename"]])
[10:59:37.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:59:37.453]                             info)
[10:59:37.453]                           info <- base::paste(info, collapse = "; ")
[10:59:37.453]                           if (!has_future) {
[10:59:37.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:59:37.453]                               info)
[10:59:37.453]                           }
[10:59:37.453]                           else {
[10:59:37.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:59:37.453]                               info, version)
[10:59:37.453]                           }
[10:59:37.453]                           base::stop(msg)
[10:59:37.453]                         }
[10:59:37.453]                       })
[10:59:37.453]                     }
[10:59:37.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:59:37.453]                     base::options(mc.cores = 1L)
[10:59:37.453]                   }
[10:59:37.453]                   ...future.strategy.old <- future::plan("list")
[10:59:37.453]                   options(future.plan = NULL)
[10:59:37.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:59:37.453]                 }
[10:59:37.453]                 ...future.workdir <- getwd()
[10:59:37.453]             }
[10:59:37.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:59:37.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:59:37.453]         }
[10:59:37.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:59:37.453]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:59:37.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:59:37.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:59:37.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:59:37.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:59:37.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:59:37.453]             base::names(...future.oldOptions))
[10:59:37.453]     }
[10:59:37.453]     if (FALSE) {
[10:59:37.453]     }
[10:59:37.453]     else {
[10:59:37.453]         if (TRUE) {
[10:59:37.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:59:37.453]                 open = "w")
[10:59:37.453]         }
[10:59:37.453]         else {
[10:59:37.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:59:37.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:59:37.453]         }
[10:59:37.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:59:37.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:59:37.453]             base::sink(type = "output", split = FALSE)
[10:59:37.453]             base::close(...future.stdout)
[10:59:37.453]         }, add = TRUE)
[10:59:37.453]     }
[10:59:37.453]     ...future.frame <- base::sys.nframe()
[10:59:37.453]     ...future.conditions <- base::list()
[10:59:37.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:59:37.453]     if (FALSE) {
[10:59:37.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:59:37.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:59:37.453]     }
[10:59:37.453]     ...future.result <- base::tryCatch({
[10:59:37.453]         base::withCallingHandlers({
[10:59:37.453]             ...future.value <- base::withVisible(base::local({
[10:59:37.453]                 ...future.makeSendCondition <- base::local({
[10:59:37.453]                   sendCondition <- NULL
[10:59:37.453]                   function(frame = 1L) {
[10:59:37.453]                     if (is.function(sendCondition)) 
[10:59:37.453]                       return(sendCondition)
[10:59:37.453]                     ns <- getNamespace("parallel")
[10:59:37.453]                     if (exists("sendData", mode = "function", 
[10:59:37.453]                       envir = ns)) {
[10:59:37.453]                       parallel_sendData <- get("sendData", mode = "function", 
[10:59:37.453]                         envir = ns)
[10:59:37.453]                       envir <- sys.frame(frame)
[10:59:37.453]                       master <- NULL
[10:59:37.453]                       while (!identical(envir, .GlobalEnv) && 
[10:59:37.453]                         !identical(envir, emptyenv())) {
[10:59:37.453]                         if (exists("master", mode = "list", envir = envir, 
[10:59:37.453]                           inherits = FALSE)) {
[10:59:37.453]                           master <- get("master", mode = "list", 
[10:59:37.453]                             envir = envir, inherits = FALSE)
[10:59:37.453]                           if (inherits(master, c("SOCKnode", 
[10:59:37.453]                             "SOCK0node"))) {
[10:59:37.453]                             sendCondition <<- function(cond) {
[10:59:37.453]                               data <- list(type = "VALUE", value = cond, 
[10:59:37.453]                                 success = TRUE)
[10:59:37.453]                               parallel_sendData(master, data)
[10:59:37.453]                             }
[10:59:37.453]                             return(sendCondition)
[10:59:37.453]                           }
[10:59:37.453]                         }
[10:59:37.453]                         frame <- frame + 1L
[10:59:37.453]                         envir <- sys.frame(frame)
[10:59:37.453]                       }
[10:59:37.453]                     }
[10:59:37.453]                     sendCondition <<- function(cond) NULL
[10:59:37.453]                   }
[10:59:37.453]                 })
[10:59:37.453]                 withCallingHandlers({
[10:59:37.453]                   {
[10:59:37.453]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.453]                     if (!identical(...future.globals.maxSize.org, 
[10:59:37.453]                       ...future.globals.maxSize)) {
[10:59:37.453]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.453]                       on.exit(options(oopts), add = TRUE)
[10:59:37.453]                     }
[10:59:37.453]                     {
[10:59:37.453]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.453]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:59:37.453]                         USE.NAMES = FALSE)
[10:59:37.453]                       do.call(mapply, args = args)
[10:59:37.453]                     }
[10:59:37.453]                   }
[10:59:37.453]                 }, immediateCondition = function(cond) {
[10:59:37.453]                   sendCondition <- ...future.makeSendCondition()
[10:59:37.453]                   sendCondition(cond)
[10:59:37.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.453]                   {
[10:59:37.453]                     inherits <- base::inherits
[10:59:37.453]                     invokeRestart <- base::invokeRestart
[10:59:37.453]                     is.null <- base::is.null
[10:59:37.453]                     muffled <- FALSE
[10:59:37.453]                     if (inherits(cond, "message")) {
[10:59:37.453]                       muffled <- grepl(pattern, "muffleMessage")
[10:59:37.453]                       if (muffled) 
[10:59:37.453]                         invokeRestart("muffleMessage")
[10:59:37.453]                     }
[10:59:37.453]                     else if (inherits(cond, "warning")) {
[10:59:37.453]                       muffled <- grepl(pattern, "muffleWarning")
[10:59:37.453]                       if (muffled) 
[10:59:37.453]                         invokeRestart("muffleWarning")
[10:59:37.453]                     }
[10:59:37.453]                     else if (inherits(cond, "condition")) {
[10:59:37.453]                       if (!is.null(pattern)) {
[10:59:37.453]                         computeRestarts <- base::computeRestarts
[10:59:37.453]                         grepl <- base::grepl
[10:59:37.453]                         restarts <- computeRestarts(cond)
[10:59:37.453]                         for (restart in restarts) {
[10:59:37.453]                           name <- restart$name
[10:59:37.453]                           if (is.null(name)) 
[10:59:37.453]                             next
[10:59:37.453]                           if (!grepl(pattern, name)) 
[10:59:37.453]                             next
[10:59:37.453]                           invokeRestart(restart)
[10:59:37.453]                           muffled <- TRUE
[10:59:37.453]                           break
[10:59:37.453]                         }
[10:59:37.453]                       }
[10:59:37.453]                     }
[10:59:37.453]                     invisible(muffled)
[10:59:37.453]                   }
[10:59:37.453]                   muffleCondition(cond)
[10:59:37.453]                 })
[10:59:37.453]             }))
[10:59:37.453]             future::FutureResult(value = ...future.value$value, 
[10:59:37.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.453]                   ...future.rng), globalenv = if (FALSE) 
[10:59:37.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:59:37.453]                     ...future.globalenv.names))
[10:59:37.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:59:37.453]         }, condition = base::local({
[10:59:37.453]             c <- base::c
[10:59:37.453]             inherits <- base::inherits
[10:59:37.453]             invokeRestart <- base::invokeRestart
[10:59:37.453]             length <- base::length
[10:59:37.453]             list <- base::list
[10:59:37.453]             seq.int <- base::seq.int
[10:59:37.453]             signalCondition <- base::signalCondition
[10:59:37.453]             sys.calls <- base::sys.calls
[10:59:37.453]             `[[` <- base::`[[`
[10:59:37.453]             `+` <- base::`+`
[10:59:37.453]             `<<-` <- base::`<<-`
[10:59:37.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:59:37.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:59:37.453]                   3L)]
[10:59:37.453]             }
[10:59:37.453]             function(cond) {
[10:59:37.453]                 is_error <- inherits(cond, "error")
[10:59:37.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:59:37.453]                   NULL)
[10:59:37.453]                 if (is_error) {
[10:59:37.453]                   sessionInformation <- function() {
[10:59:37.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:59:37.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:59:37.453]                       search = base::search(), system = base::Sys.info())
[10:59:37.453]                   }
[10:59:37.453]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:59:37.453]                     cond$call), session = sessionInformation(), 
[10:59:37.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:59:37.453]                   signalCondition(cond)
[10:59:37.453]                 }
[10:59:37.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:59:37.453]                 "immediateCondition"))) {
[10:59:37.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:59:37.453]                   ...future.conditions[[length(...future.conditions) + 
[10:59:37.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:59:37.453]                   if (TRUE && !signal) {
[10:59:37.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.453]                     {
[10:59:37.453]                       inherits <- base::inherits
[10:59:37.453]                       invokeRestart <- base::invokeRestart
[10:59:37.453]                       is.null <- base::is.null
[10:59:37.453]                       muffled <- FALSE
[10:59:37.453]                       if (inherits(cond, "message")) {
[10:59:37.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.453]                         if (muffled) 
[10:59:37.453]                           invokeRestart("muffleMessage")
[10:59:37.453]                       }
[10:59:37.453]                       else if (inherits(cond, "warning")) {
[10:59:37.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.453]                         if (muffled) 
[10:59:37.453]                           invokeRestart("muffleWarning")
[10:59:37.453]                       }
[10:59:37.453]                       else if (inherits(cond, "condition")) {
[10:59:37.453]                         if (!is.null(pattern)) {
[10:59:37.453]                           computeRestarts <- base::computeRestarts
[10:59:37.453]                           grepl <- base::grepl
[10:59:37.453]                           restarts <- computeRestarts(cond)
[10:59:37.453]                           for (restart in restarts) {
[10:59:37.453]                             name <- restart$name
[10:59:37.453]                             if (is.null(name)) 
[10:59:37.453]                               next
[10:59:37.453]                             if (!grepl(pattern, name)) 
[10:59:37.453]                               next
[10:59:37.453]                             invokeRestart(restart)
[10:59:37.453]                             muffled <- TRUE
[10:59:37.453]                             break
[10:59:37.453]                           }
[10:59:37.453]                         }
[10:59:37.453]                       }
[10:59:37.453]                       invisible(muffled)
[10:59:37.453]                     }
[10:59:37.453]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.453]                   }
[10:59:37.453]                 }
[10:59:37.453]                 else {
[10:59:37.453]                   if (TRUE) {
[10:59:37.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:59:37.453]                     {
[10:59:37.453]                       inherits <- base::inherits
[10:59:37.453]                       invokeRestart <- base::invokeRestart
[10:59:37.453]                       is.null <- base::is.null
[10:59:37.453]                       muffled <- FALSE
[10:59:37.453]                       if (inherits(cond, "message")) {
[10:59:37.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:59:37.453]                         if (muffled) 
[10:59:37.453]                           invokeRestart("muffleMessage")
[10:59:37.453]                       }
[10:59:37.453]                       else if (inherits(cond, "warning")) {
[10:59:37.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:59:37.453]                         if (muffled) 
[10:59:37.453]                           invokeRestart("muffleWarning")
[10:59:37.453]                       }
[10:59:37.453]                       else if (inherits(cond, "condition")) {
[10:59:37.453]                         if (!is.null(pattern)) {
[10:59:37.453]                           computeRestarts <- base::computeRestarts
[10:59:37.453]                           grepl <- base::grepl
[10:59:37.453]                           restarts <- computeRestarts(cond)
[10:59:37.453]                           for (restart in restarts) {
[10:59:37.453]                             name <- restart$name
[10:59:37.453]                             if (is.null(name)) 
[10:59:37.453]                               next
[10:59:37.453]                             if (!grepl(pattern, name)) 
[10:59:37.453]                               next
[10:59:37.453]                             invokeRestart(restart)
[10:59:37.453]                             muffled <- TRUE
[10:59:37.453]                             break
[10:59:37.453]                           }
[10:59:37.453]                         }
[10:59:37.453]                       }
[10:59:37.453]                       invisible(muffled)
[10:59:37.453]                     }
[10:59:37.453]                     muffleCondition(cond, pattern = "^muffle")
[10:59:37.453]                   }
[10:59:37.453]                 }
[10:59:37.453]             }
[10:59:37.453]         }))
[10:59:37.453]     }, error = function(ex) {
[10:59:37.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:59:37.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:59:37.453]                 ...future.rng), started = ...future.startTime, 
[10:59:37.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:59:37.453]             version = "1.8"), class = "FutureResult")
[10:59:37.453]     }, finally = {
[10:59:37.453]         if (!identical(...future.workdir, getwd())) 
[10:59:37.453]             setwd(...future.workdir)
[10:59:37.453]         {
[10:59:37.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:59:37.453]                 ...future.oldOptions$nwarnings <- NULL
[10:59:37.453]             }
[10:59:37.453]             base::options(...future.oldOptions)
[10:59:37.453]             if (.Platform$OS.type == "windows") {
[10:59:37.453]                 old_names <- names(...future.oldEnvVars)
[10:59:37.453]                 envs <- base::Sys.getenv()
[10:59:37.453]                 names <- names(envs)
[10:59:37.453]                 common <- intersect(names, old_names)
[10:59:37.453]                 added <- setdiff(names, old_names)
[10:59:37.453]                 removed <- setdiff(old_names, names)
[10:59:37.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:59:37.453]                   envs[common]]
[10:59:37.453]                 NAMES <- toupper(changed)
[10:59:37.453]                 args <- list()
[10:59:37.453]                 for (kk in seq_along(NAMES)) {
[10:59:37.453]                   name <- changed[[kk]]
[10:59:37.453]                   NAME <- NAMES[[kk]]
[10:59:37.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.453]                     next
[10:59:37.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.453]                 }
[10:59:37.453]                 NAMES <- toupper(added)
[10:59:37.453]                 for (kk in seq_along(NAMES)) {
[10:59:37.453]                   name <- added[[kk]]
[10:59:37.453]                   NAME <- NAMES[[kk]]
[10:59:37.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.453]                     next
[10:59:37.453]                   args[[name]] <- ""
[10:59:37.453]                 }
[10:59:37.453]                 NAMES <- toupper(removed)
[10:59:37.453]                 for (kk in seq_along(NAMES)) {
[10:59:37.453]                   name <- removed[[kk]]
[10:59:37.453]                   NAME <- NAMES[[kk]]
[10:59:37.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:59:37.453]                     next
[10:59:37.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:59:37.453]                 }
[10:59:37.453]                 if (length(args) > 0) 
[10:59:37.453]                   base::do.call(base::Sys.setenv, args = args)
[10:59:37.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:59:37.453]             }
[10:59:37.453]             else {
[10:59:37.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:59:37.453]             }
[10:59:37.453]             {
[10:59:37.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:59:37.453]                   0L) {
[10:59:37.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:59:37.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:59:37.453]                   base::options(opts)
[10:59:37.453]                 }
[10:59:37.453]                 {
[10:59:37.453]                   {
[10:59:37.453]                     base::options(mc.cores = ...future.mc.cores.old)
[10:59:37.453]                     NULL
[10:59:37.453]                   }
[10:59:37.453]                   options(future.plan = NULL)
[10:59:37.453]                   if (is.na(NA_character_)) 
[10:59:37.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:59:37.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:59:37.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:59:37.453]                     .init = FALSE)
[10:59:37.453]                 }
[10:59:37.453]             }
[10:59:37.453]         }
[10:59:37.453]     })
[10:59:37.453]     if (TRUE) {
[10:59:37.453]         base::sink(type = "output", split = FALSE)
[10:59:37.453]         if (TRUE) {
[10:59:37.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:59:37.453]         }
[10:59:37.453]         else {
[10:59:37.453]             ...future.result["stdout"] <- base::list(NULL)
[10:59:37.453]         }
[10:59:37.453]         base::close(...future.stdout)
[10:59:37.453]         ...future.stdout <- NULL
[10:59:37.453]     }
[10:59:37.453]     ...future.result$conditions <- ...future.conditions
[10:59:37.453]     ...future.result$finished <- base::Sys.time()
[10:59:37.453]     ...future.result
[10:59:37.453] }
[10:59:37.455] Exporting 5 global objects (800 bytes) to cluster node #2 ...
[10:59:37.458] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:59:37.458] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:59:37.458] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:59:37.459] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.459] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #2 ...
[10:59:37.459] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #2 ... DONE
[10:59:37.459] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:59:37.460] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.460] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:59:37.460] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:59:37.460] Exporting 5 global objects (800 bytes) to cluster node #2 ... DONE
[10:59:37.461] MultisessionFuture started
[10:59:37.461] - Launch lazy future ... done
[10:59:37.461] run() for ‘MultisessionFuture’ ... done
[10:59:37.461] Created future:
[10:59:37.461] MultisessionFuture:
[10:59:37.461] Label: ‘future_mapply-2’
[10:59:37.461] Expression:
[10:59:37.461] {
[10:59:37.461]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:59:37.461]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:59:37.461]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:59:37.461]         on.exit(options(oopts), add = TRUE)
[10:59:37.461]     }
[10:59:37.461]     {
[10:59:37.461]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:59:37.461]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:59:37.461]         do.call(mapply, args = args)
[10:59:37.461]     }
[10:59:37.461] }
[10:59:37.461] Lazy evaluation: FALSE
[10:59:37.461] Asynchronous evaluation: TRUE
[10:59:37.461] Local evaluation: TRUE
[10:59:37.461] Environment: R_GlobalEnv
[10:59:37.461] Capture standard output: TRUE
[10:59:37.461] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:59:37.461] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:59:37.461] Packages: <none>
[10:59:37.461] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:59:37.461] Resolved: FALSE
[10:59:37.461] Value: <not collected>
[10:59:37.461] Conditions captured: <none>
[10:59:37.461] Early signaling: FALSE
[10:59:37.461] Owner process: a874f05b-d1ac-d546-0db1-66e49bb5025b
[10:59:37.461] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:59:37.473] Chunk #2 of 2 ... DONE
[10:59:37.473] Launching 2 futures (chunks) ... DONE
[10:59:37.473] Resolving 2 futures (chunks) ...
[10:59:37.473] resolve() on list ...
[10:59:37.473]  recursive: 0
[10:59:37.473]  length: 2
[10:59:37.474] 
[10:59:37.474] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.474] - Validating connection of MultisessionFuture
[10:59:37.474] - received message: FutureResult
[10:59:37.474] - Received FutureResult
[10:59:37.475] - Erased future from FutureRegistry
[10:59:37.475] result() for ClusterFuture ...
[10:59:37.475] - result already collected: FutureResult
[10:59:37.475] result() for ClusterFuture ... done
[10:59:37.475] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.475] Future #1
[10:59:37.475] result() for ClusterFuture ...
[10:59:37.475] - result already collected: FutureResult
[10:59:37.475] result() for ClusterFuture ... done
[10:59:37.475] result() for ClusterFuture ...
[10:59:37.475] - result already collected: FutureResult
[10:59:37.475] result() for ClusterFuture ... done
[10:59:37.476] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:59:37.476] - nx: 2
[10:59:37.476] - relay: TRUE
[10:59:37.476] - stdout: TRUE
[10:59:37.476] - signal: TRUE
[10:59:37.476] - resignal: FALSE
[10:59:37.476] - force: TRUE
[10:59:37.476] - relayed: [n=2] FALSE, FALSE
[10:59:37.476] - queued futures: [n=2] FALSE, FALSE
[10:59:37.476]  - until=1
[10:59:37.476]  - relaying element #1
[10:59:37.476] result() for ClusterFuture ...
[10:59:37.476] - result already collected: FutureResult
[10:59:37.477] result() for ClusterFuture ... done
[10:59:37.477] result() for ClusterFuture ...
[10:59:37.477] - result already collected: FutureResult
[10:59:37.477] result() for ClusterFuture ... done
[10:59:37.477] result() for ClusterFuture ...
[10:59:37.477] - result already collected: FutureResult
[10:59:37.477] result() for ClusterFuture ... done
[10:59:37.477] result() for ClusterFuture ...
[10:59:37.477] - result already collected: FutureResult
[10:59:37.477] result() for ClusterFuture ... done
[10:59:37.477] - relayed: [n=2] TRUE, FALSE
[10:59:37.477] - queued futures: [n=2] TRUE, FALSE
[10:59:37.477] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:59:37.478]  length: 1 (resolved future 1)
[10:59:37.503] receiveMessageFromWorker() for ClusterFuture ...
[10:59:37.503] - Validating connection of MultisessionFuture
[10:59:37.503] - received message: FutureResult
[10:59:37.504] - Received FutureResult
[10:59:37.504] - Erased future from FutureRegistry
[10:59:37.504] result() for ClusterFuture ...
[10:59:37.504] - result already collected: FutureResult
[10:59:37.504] result() for ClusterFuture ... done
[10:59:37.504] receiveMessageFromWorker() for ClusterFuture ... done
[10:59:37.504] Future #2
[10:59:37.504] result() for ClusterFuture ...
[10:59:37.504] - result already collected: FutureResult
[10:59:37.504] result() for ClusterFuture ... done
[10:59:37.504] result() for ClusterFuture ...
[10:59:37.505] - result already collected: FutureResult
[10:59:37.505] result() for ClusterFuture ... done
[10:59:37.505] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:59:37.505] - nx: 2
[10:59:37.505] - relay: TRUE
[10:59:37.505] - stdout: TRUE
[10:59:37.505] - signal: TRUE
[10:59:37.505] - resignal: FALSE
[10:59:37.505] - force: TRUE
[10:59:37.505] - relayed: [n=2] TRUE, FALSE
[10:59:37.505] - queued futures: [n=2] TRUE, FALSE
[10:59:37.505]  - until=2
[10:59:37.505]  - relaying element #2
[10:59:37.506] result() for ClusterFuture ...
[10:59:37.506] - result already collected: FutureResult
[10:59:37.506] result() for ClusterFuture ... done
[10:59:37.506] result() for ClusterFuture ...
[10:59:37.506] - result already collected: FutureResult
[10:59:37.506] result() for ClusterFuture ... done
[10:59:37.506] result() for ClusterFuture ...
[10:59:37.506] - result already collected: FutureResult
[10:59:37.506] result() for ClusterFuture ... done
[10:59:37.506] result() for ClusterFuture ...
[10:59:37.506] - result already collected: FutureResult
[10:59:37.506] result() for ClusterFuture ... done
[10:59:37.507] - relayed: [n=2] TRUE, TRUE
[10:59:37.507] - queued futures: [n=2] TRUE, TRUE
[10:59:37.507] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:59:37.507]  length: 0 (resolved future 2)
[10:59:37.507] Relaying remaining futures
[10:59:37.507] signalConditionsASAP(NULL, pos=0) ...
[10:59:37.507] - nx: 2
[10:59:37.507] - relay: TRUE
[10:59:37.507] - stdout: TRUE
[10:59:37.507] - signal: TRUE
[10:59:37.507] - resignal: FALSE
[10:59:37.507] - force: TRUE
[10:59:37.507] - relayed: [n=2] TRUE, TRUE
[10:59:37.508] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:59:37.508] - relayed: [n=2] TRUE, TRUE
[10:59:37.508] - queued futures: [n=2] TRUE, TRUE
[10:59:37.508] signalConditionsASAP(NULL, pos=0) ... done
[10:59:37.508] resolve() on list ... DONE
[10:59:37.508] result() for ClusterFuture ...
[10:59:37.508] - result already collected: FutureResult
[10:59:37.508] result() for ClusterFuture ... done
[10:59:37.508] result() for ClusterFuture ...
[10:59:37.508] - result already collected: FutureResult
[10:59:37.508] result() for ClusterFuture ... done
[10:59:37.508] result() for ClusterFuture ...
[10:59:37.509] - result already collected: FutureResult
[10:59:37.509] result() for ClusterFuture ... done
[10:59:37.509] result() for ClusterFuture ...
[10:59:37.509] - result already collected: FutureResult
[10:59:37.509] result() for ClusterFuture ... done
[10:59:37.509]  - Number of value chunks collected: 2
[10:59:37.509] Resolving 2 futures (chunks) ... DONE
[10:59:37.509] Reducing values from 2 chunks ...
[10:59:37.509]  - Number of values collected after concatenation: 2
[10:59:37.509]  - Number of values expected: 2
[10:59:37.509] Reducing values from 2 chunks ... DONE
[10:59:37.509] future_mapply() ... DONE
[10:59:37.510] plan(): Setting new future strategy stack:
[10:59:37.510] List of future strategies:
[10:59:37.510] 1. sequential:
[10:59:37.510]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:37.510]    - tweaked: FALSE
[10:59:37.510]    - call: plan(sequential)
[10:59:37.511] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[10:59:37.512] plan(): Setting new future strategy stack:
[10:59:37.512] List of future strategies:
[10:59:37.512] 1. FutureStrategy:
[10:59:37.512]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:59:37.512]    - tweaked: FALSE
[10:59:37.512]    - call: future::plan(oplan)
[10:59:37.513] plan(): nbrOfWorkers() = 1
> 
