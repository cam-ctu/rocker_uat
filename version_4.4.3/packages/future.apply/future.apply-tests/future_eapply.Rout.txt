
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:58:46.163] plan(): Setting new future strategy stack:
[10:58:46.163] List of future strategies:
[10:58:46.163] 1. sequential:
[10:58:46.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.163]    - tweaked: FALSE
[10:58:46.163]    - call: future::plan("sequential")
[10:58:46.177] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:58:46.204] plan(): Setting new future strategy stack:
[10:58:46.204] List of future strategies:
[10:58:46.204] 1. sequential:
[10:58:46.204]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.204]    - tweaked: FALSE
[10:58:46.204]    - call: plan(strategy)
[10:58:46.216] plan(): nbrOfWorkers() = 1
[10:58:46.217] future_lapply() ...
[10:58:46.220] Number of chunks: 1
[10:58:46.220] getGlobalsAndPackagesXApply() ...
[10:58:46.221]  - future.globals: TRUE
[10:58:46.221] getGlobalsAndPackages() ...
[10:58:46.221] Searching for globals...
[10:58:46.223] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.223] Searching for globals ... DONE
[10:58:46.223] Resolving globals: FALSE
[10:58:46.224] The total size of the 1 globals is 273 bytes (273 bytes)
[10:58:46.225] The total size of the 1 globals exported for future expression (‘FUN()’) is 273 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (273 bytes of class ‘function’)
[10:58:46.225] - globals: [1] ‘FUN’
[10:58:46.225] 
[10:58:46.225] getGlobalsAndPackages() ... DONE
[10:58:46.225]  - globals found/used: [n=1] ‘FUN’
[10:58:46.225]  - needed namespaces: [n=0] 
[10:58:46.225] Finding globals ... DONE
[10:58:46.225]  - use_args: TRUE
[10:58:46.225]  - Getting '...' globals ...
[10:58:46.226] resolve() on list ...
[10:58:46.226]  recursive: 0
[10:58:46.226]  length: 1
[10:58:46.226]  elements: ‘...’
[10:58:46.227]  length: 0 (resolved future 1)
[10:58:46.227] resolve() on list ... DONE
[10:58:46.227]    - '...' content: [n=0] 
[10:58:46.227] List of 1
[10:58:46.227]  $ ...: list()
[10:58:46.227]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.227]  - attr(*, "where")=List of 1
[10:58:46.227]   ..$ ...:<environment: 0x55f489304de0> 
[10:58:46.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.227]  - attr(*, "resolved")= logi TRUE
[10:58:46.227]  - attr(*, "total_size")= num NA
[10:58:46.231]  - Getting '...' globals ... DONE
[10:58:46.231] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.231] List of 2
[10:58:46.231]  $ ...future.FUN:function (x, ...)  
[10:58:46.231]  $ ...          : list()
[10:58:46.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.231]  - attr(*, "where")=List of 2
[10:58:46.231]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.231]   ..$ ...          :<environment: 0x55f489304de0> 
[10:58:46.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.231]  - attr(*, "resolved")= logi FALSE
[10:58:46.231]  - attr(*, "total_size")= num 5249
[10:58:46.234] Packages to be attached in all futures: [n=0] 
[10:58:46.234] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.234] Number of futures (= number of chunks): 1
[10:58:46.234] Launching 1 futures (chunks) ...
[10:58:46.234] Chunk #1 of 1 ...
[10:58:46.235]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.235] getGlobalsAndPackages() ...
[10:58:46.235] Searching for globals...
[10:58:46.235] 
[10:58:46.235] Searching for globals ... DONE
[10:58:46.235] - globals: [0] <none>
[10:58:46.235] getGlobalsAndPackages() ... DONE
[10:58:46.235]    + additional globals found: [n=0] 
[10:58:46.235]    + additional namespaces needed: [n=0] 
[10:58:46.236]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.236]  - seeds: <none>
[10:58:46.236]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.236] getGlobalsAndPackages() ...
[10:58:46.236] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.236] Resolving globals: FALSE
[10:58:46.236] Tweak future expression to call with '...' arguments ...
[10:58:46.236] {
[10:58:46.236]     do.call(function(...) {
[10:58:46.236]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.236]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.236]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.236]             on.exit(options(oopts), add = TRUE)
[10:58:46.236]         }
[10:58:46.236]         {
[10:58:46.236]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.236]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.236]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.236]             })
[10:58:46.236]         }
[10:58:46.236]     }, args = future.call.arguments)
[10:58:46.236] }
[10:58:46.237] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.237] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.237] 
[10:58:46.237] getGlobalsAndPackages() ... DONE
[10:58:46.238] run() for ‘Future’ ...
[10:58:46.238] - state: ‘created’
[10:58:46.238] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:46.238] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:46.239]   - Field: ‘label’
[10:58:46.239]   - Field: ‘local’
[10:58:46.239]   - Field: ‘owner’
[10:58:46.239]   - Field: ‘envir’
[10:58:46.239]   - Field: ‘packages’
[10:58:46.239]   - Field: ‘gc’
[10:58:46.239]   - Field: ‘conditions’
[10:58:46.239]   - Field: ‘expr’
[10:58:46.239]   - Field: ‘uuid’
[10:58:46.239]   - Field: ‘seed’
[10:58:46.239]   - Field: ‘version’
[10:58:46.239]   - Field: ‘result’
[10:58:46.240]   - Field: ‘asynchronous’
[10:58:46.240]   - Field: ‘calls’
[10:58:46.240]   - Field: ‘globals’
[10:58:46.240]   - Field: ‘stdout’
[10:58:46.240]   - Field: ‘earlySignal’
[10:58:46.242]   - Field: ‘lazy’
[10:58:46.242]   - Field: ‘state’
[10:58:46.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:46.243] - Launch lazy future ...
[10:58:46.243] Packages needed by the future expression (n = 0): <none>
[10:58:46.243] Packages needed by future strategies (n = 0): <none>
[10:58:46.244] {
[10:58:46.244]     {
[10:58:46.244]         {
[10:58:46.244]             ...future.startTime <- base::Sys.time()
[10:58:46.244]             {
[10:58:46.244]                 {
[10:58:46.244]                   {
[10:58:46.244]                     base::local({
[10:58:46.244]                       has_future <- base::requireNamespace("future", 
[10:58:46.244]                         quietly = TRUE)
[10:58:46.244]                       if (has_future) {
[10:58:46.244]                         ns <- base::getNamespace("future")
[10:58:46.244]                         version <- ns[[".package"]][["version"]]
[10:58:46.244]                         if (is.null(version)) 
[10:58:46.244]                           version <- utils::packageVersion("future")
[10:58:46.244]                       }
[10:58:46.244]                       else {
[10:58:46.244]                         version <- NULL
[10:58:46.244]                       }
[10:58:46.244]                       if (!has_future || version < "1.8.0") {
[10:58:46.244]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.244]                           "", base::R.version$version.string), 
[10:58:46.244]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:46.244]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:46.244]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.244]                             "release", "version")], collapse = " "), 
[10:58:46.244]                           hostname = base::Sys.info()[["nodename"]])
[10:58:46.244]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.244]                           info)
[10:58:46.244]                         info <- base::paste(info, collapse = "; ")
[10:58:46.244]                         if (!has_future) {
[10:58:46.244]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.244]                             info)
[10:58:46.244]                         }
[10:58:46.244]                         else {
[10:58:46.244]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.244]                             info, version)
[10:58:46.244]                         }
[10:58:46.244]                         base::stop(msg)
[10:58:46.244]                       }
[10:58:46.244]                     })
[10:58:46.244]                   }
[10:58:46.244]                   ...future.strategy.old <- future::plan("list")
[10:58:46.244]                   options(future.plan = NULL)
[10:58:46.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.244]                 }
[10:58:46.244]                 ...future.workdir <- getwd()
[10:58:46.244]             }
[10:58:46.244]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.244]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.244]         }
[10:58:46.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:46.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.244]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.244]             base::names(...future.oldOptions))
[10:58:46.244]     }
[10:58:46.244]     if (FALSE) {
[10:58:46.244]     }
[10:58:46.244]     else {
[10:58:46.244]         if (TRUE) {
[10:58:46.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.244]                 open = "w")
[10:58:46.244]         }
[10:58:46.244]         else {
[10:58:46.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.244]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.244]         }
[10:58:46.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.244]             base::sink(type = "output", split = FALSE)
[10:58:46.244]             base::close(...future.stdout)
[10:58:46.244]         }, add = TRUE)
[10:58:46.244]     }
[10:58:46.244]     ...future.frame <- base::sys.nframe()
[10:58:46.244]     ...future.conditions <- base::list()
[10:58:46.244]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.244]     if (FALSE) {
[10:58:46.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.244]     }
[10:58:46.244]     ...future.result <- base::tryCatch({
[10:58:46.244]         base::withCallingHandlers({
[10:58:46.244]             ...future.value <- base::withVisible(base::local({
[10:58:46.244]                 do.call(function(...) {
[10:58:46.244]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.244]                   if (!identical(...future.globals.maxSize.org, 
[10:58:46.244]                     ...future.globals.maxSize)) {
[10:58:46.244]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.244]                     on.exit(options(oopts), add = TRUE)
[10:58:46.244]                   }
[10:58:46.244]                   {
[10:58:46.244]                     lapply(seq_along(...future.elements_ii), 
[10:58:46.244]                       FUN = function(jj) {
[10:58:46.244]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.244]                         ...future.FUN(...future.X_jj, ...)
[10:58:46.244]                       })
[10:58:46.244]                   }
[10:58:46.244]                 }, args = future.call.arguments)
[10:58:46.244]             }))
[10:58:46.244]             future::FutureResult(value = ...future.value$value, 
[10:58:46.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.244]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.244]                     ...future.globalenv.names))
[10:58:46.244]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.244]         }, condition = base::local({
[10:58:46.244]             c <- base::c
[10:58:46.244]             inherits <- base::inherits
[10:58:46.244]             invokeRestart <- base::invokeRestart
[10:58:46.244]             length <- base::length
[10:58:46.244]             list <- base::list
[10:58:46.244]             seq.int <- base::seq.int
[10:58:46.244]             signalCondition <- base::signalCondition
[10:58:46.244]             sys.calls <- base::sys.calls
[10:58:46.244]             `[[` <- base::`[[`
[10:58:46.244]             `+` <- base::`+`
[10:58:46.244]             `<<-` <- base::`<<-`
[10:58:46.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.244]                   3L)]
[10:58:46.244]             }
[10:58:46.244]             function(cond) {
[10:58:46.244]                 is_error <- inherits(cond, "error")
[10:58:46.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.244]                   NULL)
[10:58:46.244]                 if (is_error) {
[10:58:46.244]                   sessionInformation <- function() {
[10:58:46.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.244]                       search = base::search(), system = base::Sys.info())
[10:58:46.244]                   }
[10:58:46.244]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.244]                     cond$call), session = sessionInformation(), 
[10:58:46.244]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.244]                   signalCondition(cond)
[10:58:46.244]                 }
[10:58:46.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.244]                 "immediateCondition"))) {
[10:58:46.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.244]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.244]                   if (TRUE && !signal) {
[10:58:46.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.244]                     {
[10:58:46.244]                       inherits <- base::inherits
[10:58:46.244]                       invokeRestart <- base::invokeRestart
[10:58:46.244]                       is.null <- base::is.null
[10:58:46.244]                       muffled <- FALSE
[10:58:46.244]                       if (inherits(cond, "message")) {
[10:58:46.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.244]                         if (muffled) 
[10:58:46.244]                           invokeRestart("muffleMessage")
[10:58:46.244]                       }
[10:58:46.244]                       else if (inherits(cond, "warning")) {
[10:58:46.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.244]                         if (muffled) 
[10:58:46.244]                           invokeRestart("muffleWarning")
[10:58:46.244]                       }
[10:58:46.244]                       else if (inherits(cond, "condition")) {
[10:58:46.244]                         if (!is.null(pattern)) {
[10:58:46.244]                           computeRestarts <- base::computeRestarts
[10:58:46.244]                           grepl <- base::grepl
[10:58:46.244]                           restarts <- computeRestarts(cond)
[10:58:46.244]                           for (restart in restarts) {
[10:58:46.244]                             name <- restart$name
[10:58:46.244]                             if (is.null(name)) 
[10:58:46.244]                               next
[10:58:46.244]                             if (!grepl(pattern, name)) 
[10:58:46.244]                               next
[10:58:46.244]                             invokeRestart(restart)
[10:58:46.244]                             muffled <- TRUE
[10:58:46.244]                             break
[10:58:46.244]                           }
[10:58:46.244]                         }
[10:58:46.244]                       }
[10:58:46.244]                       invisible(muffled)
[10:58:46.244]                     }
[10:58:46.244]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.244]                   }
[10:58:46.244]                 }
[10:58:46.244]                 else {
[10:58:46.244]                   if (TRUE) {
[10:58:46.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.244]                     {
[10:58:46.244]                       inherits <- base::inherits
[10:58:46.244]                       invokeRestart <- base::invokeRestart
[10:58:46.244]                       is.null <- base::is.null
[10:58:46.244]                       muffled <- FALSE
[10:58:46.244]                       if (inherits(cond, "message")) {
[10:58:46.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.244]                         if (muffled) 
[10:58:46.244]                           invokeRestart("muffleMessage")
[10:58:46.244]                       }
[10:58:46.244]                       else if (inherits(cond, "warning")) {
[10:58:46.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.244]                         if (muffled) 
[10:58:46.244]                           invokeRestart("muffleWarning")
[10:58:46.244]                       }
[10:58:46.244]                       else if (inherits(cond, "condition")) {
[10:58:46.244]                         if (!is.null(pattern)) {
[10:58:46.244]                           computeRestarts <- base::computeRestarts
[10:58:46.244]                           grepl <- base::grepl
[10:58:46.244]                           restarts <- computeRestarts(cond)
[10:58:46.244]                           for (restart in restarts) {
[10:58:46.244]                             name <- restart$name
[10:58:46.244]                             if (is.null(name)) 
[10:58:46.244]                               next
[10:58:46.244]                             if (!grepl(pattern, name)) 
[10:58:46.244]                               next
[10:58:46.244]                             invokeRestart(restart)
[10:58:46.244]                             muffled <- TRUE
[10:58:46.244]                             break
[10:58:46.244]                           }
[10:58:46.244]                         }
[10:58:46.244]                       }
[10:58:46.244]                       invisible(muffled)
[10:58:46.244]                     }
[10:58:46.244]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.244]                   }
[10:58:46.244]                 }
[10:58:46.244]             }
[10:58:46.244]         }))
[10:58:46.244]     }, error = function(ex) {
[10:58:46.244]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.244]                 ...future.rng), started = ...future.startTime, 
[10:58:46.244]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.244]             version = "1.8"), class = "FutureResult")
[10:58:46.244]     }, finally = {
[10:58:46.244]         if (!identical(...future.workdir, getwd())) 
[10:58:46.244]             setwd(...future.workdir)
[10:58:46.244]         {
[10:58:46.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.244]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.244]             }
[10:58:46.244]             base::options(...future.oldOptions)
[10:58:46.244]             if (.Platform$OS.type == "windows") {
[10:58:46.244]                 old_names <- names(...future.oldEnvVars)
[10:58:46.244]                 envs <- base::Sys.getenv()
[10:58:46.244]                 names <- names(envs)
[10:58:46.244]                 common <- intersect(names, old_names)
[10:58:46.244]                 added <- setdiff(names, old_names)
[10:58:46.244]                 removed <- setdiff(old_names, names)
[10:58:46.244]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.244]                   envs[common]]
[10:58:46.244]                 NAMES <- toupper(changed)
[10:58:46.244]                 args <- list()
[10:58:46.244]                 for (kk in seq_along(NAMES)) {
[10:58:46.244]                   name <- changed[[kk]]
[10:58:46.244]                   NAME <- NAMES[[kk]]
[10:58:46.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.244]                     next
[10:58:46.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.244]                 }
[10:58:46.244]                 NAMES <- toupper(added)
[10:58:46.244]                 for (kk in seq_along(NAMES)) {
[10:58:46.244]                   name <- added[[kk]]
[10:58:46.244]                   NAME <- NAMES[[kk]]
[10:58:46.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.244]                     next
[10:58:46.244]                   args[[name]] <- ""
[10:58:46.244]                 }
[10:58:46.244]                 NAMES <- toupper(removed)
[10:58:46.244]                 for (kk in seq_along(NAMES)) {
[10:58:46.244]                   name <- removed[[kk]]
[10:58:46.244]                   NAME <- NAMES[[kk]]
[10:58:46.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.244]                     next
[10:58:46.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.244]                 }
[10:58:46.244]                 if (length(args) > 0) 
[10:58:46.244]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.244]             }
[10:58:46.244]             else {
[10:58:46.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.244]             }
[10:58:46.244]             {
[10:58:46.244]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.244]                   0L) {
[10:58:46.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.244]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.244]                   base::options(opts)
[10:58:46.244]                 }
[10:58:46.244]                 {
[10:58:46.244]                   {
[10:58:46.244]                     NULL
[10:58:46.244]                     RNGkind("Mersenne-Twister")
[10:58:46.244]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:46.244]                       inherits = FALSE)
[10:58:46.244]                   }
[10:58:46.244]                   options(future.plan = NULL)
[10:58:46.244]                   if (is.na(NA_character_)) 
[10:58:46.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.244]                     .init = FALSE)
[10:58:46.244]                 }
[10:58:46.244]             }
[10:58:46.244]         }
[10:58:46.244]     })
[10:58:46.244]     if (TRUE) {
[10:58:46.244]         base::sink(type = "output", split = FALSE)
[10:58:46.244]         if (TRUE) {
[10:58:46.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.244]         }
[10:58:46.244]         else {
[10:58:46.244]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.244]         }
[10:58:46.244]         base::close(...future.stdout)
[10:58:46.244]         ...future.stdout <- NULL
[10:58:46.244]     }
[10:58:46.244]     ...future.result$conditions <- ...future.conditions
[10:58:46.244]     ...future.result$finished <- base::Sys.time()
[10:58:46.244]     ...future.result
[10:58:46.244] }
[10:58:46.246] assign_globals() ...
[10:58:46.246] List of 5
[10:58:46.246]  $ ...future.FUN            :function (x, ...)  
[10:58:46.246]  $ future.call.arguments    : list()
[10:58:46.246]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.246]  $ ...future.elements_ii    :List of 3
[10:58:46.246]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.246]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.246]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.246]  $ ...future.seeds_ii       : NULL
[10:58:46.246]  $ ...future.globals.maxSize: NULL
[10:58:46.246]  - attr(*, "where")=List of 5
[10:58:46.246]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.246]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.246]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.246]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.246]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.246]  - attr(*, "resolved")= logi FALSE
[10:58:46.246]  - attr(*, "total_size")= num 5249
[10:58:46.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.246]  - attr(*, "already-done")= logi TRUE
[10:58:46.251] - copied ‘...future.FUN’ to environment
[10:58:46.251] - copied ‘future.call.arguments’ to environment
[10:58:46.251] - copied ‘...future.elements_ii’ to environment
[10:58:46.252] - copied ‘...future.seeds_ii’ to environment
[10:58:46.252] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.252] assign_globals() ... done
[10:58:46.252] plan(): Setting new future strategy stack:
[10:58:46.252] List of future strategies:
[10:58:46.252] 1. sequential:
[10:58:46.252]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.252]    - tweaked: FALSE
[10:58:46.252]    - call: NULL
[10:58:46.253] plan(): nbrOfWorkers() = 1
[10:58:46.254] plan(): Setting new future strategy stack:
[10:58:46.254] List of future strategies:
[10:58:46.254] 1. sequential:
[10:58:46.254]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.254]    - tweaked: FALSE
[10:58:46.254]    - call: plan(strategy)
[10:58:46.254] plan(): nbrOfWorkers() = 1
[10:58:46.254] SequentialFuture started (and completed)
[10:58:46.255] - Launch lazy future ... done
[10:58:46.255] run() for ‘SequentialFuture’ ... done
[10:58:46.255] Created future:
[10:58:46.255] SequentialFuture:
[10:58:46.255] Label: ‘future_eapply-1’
[10:58:46.255] Expression:
[10:58:46.255] {
[10:58:46.255]     do.call(function(...) {
[10:58:46.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.255]             on.exit(options(oopts), add = TRUE)
[10:58:46.255]         }
[10:58:46.255]         {
[10:58:46.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.255]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.255]             })
[10:58:46.255]         }
[10:58:46.255]     }, args = future.call.arguments)
[10:58:46.255] }
[10:58:46.255] Lazy evaluation: FALSE
[10:58:46.255] Asynchronous evaluation: FALSE
[10:58:46.255] Local evaluation: TRUE
[10:58:46.255] Environment: R_GlobalEnv
[10:58:46.255] Capture standard output: TRUE
[10:58:46.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.255] Globals: 5 objects totaling 653 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 229 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.255] Packages: <none>
[10:58:46.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.255] Resolved: TRUE
[10:58:46.255] Value: 79 bytes of class ‘list’
[10:58:46.255] Early signaling: FALSE
[10:58:46.255] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.255] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.256] Chunk #1 of 1 ... DONE
[10:58:46.256] Launching 1 futures (chunks) ... DONE
[10:58:46.257] Resolving 1 futures (chunks) ...
[10:58:46.257] resolve() on list ...
[10:58:46.257]  recursive: 0
[10:58:46.257]  length: 1
[10:58:46.257] 
[10:58:46.257] resolved() for ‘SequentialFuture’ ...
[10:58:46.257] - state: ‘finished’
[10:58:46.257] - run: TRUE
[10:58:46.257] - result: ‘FutureResult’
[10:58:46.258] resolved() for ‘SequentialFuture’ ... done
[10:58:46.258] Future #1
[10:58:46.258] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:46.258] - nx: 1
[10:58:46.258] - relay: TRUE
[10:58:46.258] - stdout: TRUE
[10:58:46.258] - signal: TRUE
[10:58:46.258] - resignal: FALSE
[10:58:46.258] - force: TRUE
[10:58:46.259] - relayed: [n=1] FALSE
[10:58:46.259] - queued futures: [n=1] FALSE
[10:58:46.259]  - until=1
[10:58:46.259]  - relaying element #1
[10:58:46.259] - relayed: [n=1] TRUE
[10:58:46.259] - queued futures: [n=1] TRUE
[10:58:46.259] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:46.259]  length: 0 (resolved future 1)
[10:58:46.259] Relaying remaining futures
[10:58:46.260] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.260] - nx: 1
[10:58:46.260] - relay: TRUE
[10:58:46.260] - stdout: TRUE
[10:58:46.260] - signal: TRUE
[10:58:46.260] - resignal: FALSE
[10:58:46.260] - force: TRUE
[10:58:46.260] - relayed: [n=1] TRUE
[10:58:46.260] - queued futures: [n=1] TRUE
 - flush all
[10:58:46.260] - relayed: [n=1] TRUE
[10:58:46.260] - queued futures: [n=1] TRUE
[10:58:46.260] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.261] resolve() on list ... DONE
[10:58:46.261]  - Number of value chunks collected: 1
[10:58:46.261] Resolving 1 futures (chunks) ... DONE
[10:58:46.261] Reducing values from 1 chunks ...
[10:58:46.261]  - Number of values collected after concatenation: 3
[10:58:46.261]  - Number of values expected: 3
[10:58:46.261] Reducing values from 1 chunks ... DONE
[10:58:46.261] future_lapply() ... DONE
[10:58:46.263] future_lapply() ...
[10:58:46.263] Number of chunks: 1
[10:58:46.264] getGlobalsAndPackagesXApply() ...
[10:58:46.264]  - future.globals: TRUE
[10:58:46.264] getGlobalsAndPackages() ...
[10:58:46.264] Searching for globals...
[10:58:46.265] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.265] Searching for globals ... DONE
[10:58:46.265] Resolving globals: FALSE
[10:58:46.265] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:46.266] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:46.266] - globals: [1] ‘FUN’
[10:58:46.266] - packages: [1] ‘stats’
[10:58:46.266] getGlobalsAndPackages() ... DONE
[10:58:46.266]  - globals found/used: [n=1] ‘FUN’
[10:58:46.266]  - needed namespaces: [n=1] ‘stats’
[10:58:46.266] Finding globals ... DONE
[10:58:46.266]  - use_args: TRUE
[10:58:46.267]  - Getting '...' globals ...
[10:58:46.267] resolve() on list ...
[10:58:46.267]  recursive: 0
[10:58:46.267]  length: 1
[10:58:46.267]  elements: ‘...’
[10:58:46.267]  length: 0 (resolved future 1)
[10:58:46.267] resolve() on list ... DONE
[10:58:46.267]    - '...' content: [n=1] ‘probs’
[10:58:46.267] List of 1
[10:58:46.267]  $ ...:List of 1
[10:58:46.267]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:46.267]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.267]  - attr(*, "where")=List of 1
[10:58:46.267]   ..$ ...:<environment: 0x55f48b2b1b10> 
[10:58:46.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.267]  - attr(*, "resolved")= logi TRUE
[10:58:46.267]  - attr(*, "total_size")= num NA
[10:58:46.272]  - Getting '...' globals ... DONE
[10:58:46.272] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.272] List of 2
[10:58:46.272]  $ ...future.FUN:function (x, ...)  
[10:58:46.272]  $ ...          :List of 1
[10:58:46.272]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:46.272]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.272]  - attr(*, "where")=List of 2
[10:58:46.272]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.272]   ..$ ...          :<environment: 0x55f48b2b1b10> 
[10:58:46.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.272]  - attr(*, "resolved")= logi FALSE
[10:58:46.272]  - attr(*, "total_size")= num 6525
[10:58:46.275] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:46.275] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.276] Number of futures (= number of chunks): 1
[10:58:46.276] Launching 1 futures (chunks) ...
[10:58:46.276] Chunk #1 of 1 ...
[10:58:46.276]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.276] getGlobalsAndPackages() ...
[10:58:46.276] Searching for globals...
[10:58:46.276] 
[10:58:46.276] Searching for globals ... DONE
[10:58:46.277] - globals: [0] <none>
[10:58:46.277] getGlobalsAndPackages() ... DONE
[10:58:46.277]    + additional globals found: [n=0] 
[10:58:46.277]    + additional namespaces needed: [n=0] 
[10:58:46.277]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.277]  - seeds: <none>
[10:58:46.277]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.277] getGlobalsAndPackages() ...
[10:58:46.277] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.277] Resolving globals: FALSE
[10:58:46.277] Tweak future expression to call with '...' arguments ...
[10:58:46.278] {
[10:58:46.278]     do.call(function(...) {
[10:58:46.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.278]             on.exit(options(oopts), add = TRUE)
[10:58:46.278]         }
[10:58:46.278]         {
[10:58:46.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.278]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.278]             })
[10:58:46.278]         }
[10:58:46.278]     }, args = future.call.arguments)
[10:58:46.278] }
[10:58:46.278] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.278] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.278] - packages: [1] ‘stats’
[10:58:46.278] getGlobalsAndPackages() ... DONE
[10:58:46.279] run() for ‘Future’ ...
[10:58:46.279] - state: ‘created’
[10:58:46.279] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:46.279] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:46.279]   - Field: ‘label’
[10:58:46.279]   - Field: ‘local’
[10:58:46.280]   - Field: ‘owner’
[10:58:46.280]   - Field: ‘envir’
[10:58:46.280]   - Field: ‘packages’
[10:58:46.280]   - Field: ‘gc’
[10:58:46.280]   - Field: ‘conditions’
[10:58:46.280]   - Field: ‘expr’
[10:58:46.280]   - Field: ‘uuid’
[10:58:46.280]   - Field: ‘seed’
[10:58:46.280]   - Field: ‘version’
[10:58:46.280]   - Field: ‘result’
[10:58:46.280]   - Field: ‘asynchronous’
[10:58:46.280]   - Field: ‘calls’
[10:58:46.281]   - Field: ‘globals’
[10:58:46.281]   - Field: ‘stdout’
[10:58:46.281]   - Field: ‘earlySignal’
[10:58:46.281]   - Field: ‘lazy’
[10:58:46.281]   - Field: ‘state’
[10:58:46.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:46.281] - Launch lazy future ...
[10:58:46.281] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.281] Packages needed by future strategies (n = 0): <none>
[10:58:46.282] {
[10:58:46.282]     {
[10:58:46.282]         {
[10:58:46.282]             ...future.startTime <- base::Sys.time()
[10:58:46.282]             {
[10:58:46.282]                 {
[10:58:46.282]                   {
[10:58:46.282]                     {
[10:58:46.282]                       base::local({
[10:58:46.282]                         has_future <- base::requireNamespace("future", 
[10:58:46.282]                           quietly = TRUE)
[10:58:46.282]                         if (has_future) {
[10:58:46.282]                           ns <- base::getNamespace("future")
[10:58:46.282]                           version <- ns[[".package"]][["version"]]
[10:58:46.282]                           if (is.null(version)) 
[10:58:46.282]                             version <- utils::packageVersion("future")
[10:58:46.282]                         }
[10:58:46.282]                         else {
[10:58:46.282]                           version <- NULL
[10:58:46.282]                         }
[10:58:46.282]                         if (!has_future || version < "1.8.0") {
[10:58:46.282]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.282]                             "", base::R.version$version.string), 
[10:58:46.282]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:46.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:46.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.282]                               "release", "version")], collapse = " "), 
[10:58:46.282]                             hostname = base::Sys.info()[["nodename"]])
[10:58:46.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.282]                             info)
[10:58:46.282]                           info <- base::paste(info, collapse = "; ")
[10:58:46.282]                           if (!has_future) {
[10:58:46.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.282]                               info)
[10:58:46.282]                           }
[10:58:46.282]                           else {
[10:58:46.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.282]                               info, version)
[10:58:46.282]                           }
[10:58:46.282]                           base::stop(msg)
[10:58:46.282]                         }
[10:58:46.282]                       })
[10:58:46.282]                     }
[10:58:46.282]                     base::local({
[10:58:46.282]                       for (pkg in "stats") {
[10:58:46.282]                         base::loadNamespace(pkg)
[10:58:46.282]                         base::library(pkg, character.only = TRUE)
[10:58:46.282]                       }
[10:58:46.282]                     })
[10:58:46.282]                   }
[10:58:46.282]                   ...future.strategy.old <- future::plan("list")
[10:58:46.282]                   options(future.plan = NULL)
[10:58:46.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.282]                 }
[10:58:46.282]                 ...future.workdir <- getwd()
[10:58:46.282]             }
[10:58:46.282]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.282]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.282]         }
[10:58:46.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.282]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:46.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.282]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.282]             base::names(...future.oldOptions))
[10:58:46.282]     }
[10:58:46.282]     if (FALSE) {
[10:58:46.282]     }
[10:58:46.282]     else {
[10:58:46.282]         if (TRUE) {
[10:58:46.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.282]                 open = "w")
[10:58:46.282]         }
[10:58:46.282]         else {
[10:58:46.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.282]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.282]         }
[10:58:46.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.282]             base::sink(type = "output", split = FALSE)
[10:58:46.282]             base::close(...future.stdout)
[10:58:46.282]         }, add = TRUE)
[10:58:46.282]     }
[10:58:46.282]     ...future.frame <- base::sys.nframe()
[10:58:46.282]     ...future.conditions <- base::list()
[10:58:46.282]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.282]     if (FALSE) {
[10:58:46.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.282]     }
[10:58:46.282]     ...future.result <- base::tryCatch({
[10:58:46.282]         base::withCallingHandlers({
[10:58:46.282]             ...future.value <- base::withVisible(base::local({
[10:58:46.282]                 do.call(function(...) {
[10:58:46.282]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.282]                   if (!identical(...future.globals.maxSize.org, 
[10:58:46.282]                     ...future.globals.maxSize)) {
[10:58:46.282]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.282]                     on.exit(options(oopts), add = TRUE)
[10:58:46.282]                   }
[10:58:46.282]                   {
[10:58:46.282]                     lapply(seq_along(...future.elements_ii), 
[10:58:46.282]                       FUN = function(jj) {
[10:58:46.282]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.282]                         ...future.FUN(...future.X_jj, ...)
[10:58:46.282]                       })
[10:58:46.282]                   }
[10:58:46.282]                 }, args = future.call.arguments)
[10:58:46.282]             }))
[10:58:46.282]             future::FutureResult(value = ...future.value$value, 
[10:58:46.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.282]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.282]                     ...future.globalenv.names))
[10:58:46.282]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.282]         }, condition = base::local({
[10:58:46.282]             c <- base::c
[10:58:46.282]             inherits <- base::inherits
[10:58:46.282]             invokeRestart <- base::invokeRestart
[10:58:46.282]             length <- base::length
[10:58:46.282]             list <- base::list
[10:58:46.282]             seq.int <- base::seq.int
[10:58:46.282]             signalCondition <- base::signalCondition
[10:58:46.282]             sys.calls <- base::sys.calls
[10:58:46.282]             `[[` <- base::`[[`
[10:58:46.282]             `+` <- base::`+`
[10:58:46.282]             `<<-` <- base::`<<-`
[10:58:46.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.282]                   3L)]
[10:58:46.282]             }
[10:58:46.282]             function(cond) {
[10:58:46.282]                 is_error <- inherits(cond, "error")
[10:58:46.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.282]                   NULL)
[10:58:46.282]                 if (is_error) {
[10:58:46.282]                   sessionInformation <- function() {
[10:58:46.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.282]                       search = base::search(), system = base::Sys.info())
[10:58:46.282]                   }
[10:58:46.282]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.282]                     cond$call), session = sessionInformation(), 
[10:58:46.282]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.282]                   signalCondition(cond)
[10:58:46.282]                 }
[10:58:46.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.282]                 "immediateCondition"))) {
[10:58:46.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.282]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.282]                   if (TRUE && !signal) {
[10:58:46.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.282]                     {
[10:58:46.282]                       inherits <- base::inherits
[10:58:46.282]                       invokeRestart <- base::invokeRestart
[10:58:46.282]                       is.null <- base::is.null
[10:58:46.282]                       muffled <- FALSE
[10:58:46.282]                       if (inherits(cond, "message")) {
[10:58:46.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.282]                         if (muffled) 
[10:58:46.282]                           invokeRestart("muffleMessage")
[10:58:46.282]                       }
[10:58:46.282]                       else if (inherits(cond, "warning")) {
[10:58:46.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.282]                         if (muffled) 
[10:58:46.282]                           invokeRestart("muffleWarning")
[10:58:46.282]                       }
[10:58:46.282]                       else if (inherits(cond, "condition")) {
[10:58:46.282]                         if (!is.null(pattern)) {
[10:58:46.282]                           computeRestarts <- base::computeRestarts
[10:58:46.282]                           grepl <- base::grepl
[10:58:46.282]                           restarts <- computeRestarts(cond)
[10:58:46.282]                           for (restart in restarts) {
[10:58:46.282]                             name <- restart$name
[10:58:46.282]                             if (is.null(name)) 
[10:58:46.282]                               next
[10:58:46.282]                             if (!grepl(pattern, name)) 
[10:58:46.282]                               next
[10:58:46.282]                             invokeRestart(restart)
[10:58:46.282]                             muffled <- TRUE
[10:58:46.282]                             break
[10:58:46.282]                           }
[10:58:46.282]                         }
[10:58:46.282]                       }
[10:58:46.282]                       invisible(muffled)
[10:58:46.282]                     }
[10:58:46.282]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.282]                   }
[10:58:46.282]                 }
[10:58:46.282]                 else {
[10:58:46.282]                   if (TRUE) {
[10:58:46.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.282]                     {
[10:58:46.282]                       inherits <- base::inherits
[10:58:46.282]                       invokeRestart <- base::invokeRestart
[10:58:46.282]                       is.null <- base::is.null
[10:58:46.282]                       muffled <- FALSE
[10:58:46.282]                       if (inherits(cond, "message")) {
[10:58:46.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.282]                         if (muffled) 
[10:58:46.282]                           invokeRestart("muffleMessage")
[10:58:46.282]                       }
[10:58:46.282]                       else if (inherits(cond, "warning")) {
[10:58:46.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.282]                         if (muffled) 
[10:58:46.282]                           invokeRestart("muffleWarning")
[10:58:46.282]                       }
[10:58:46.282]                       else if (inherits(cond, "condition")) {
[10:58:46.282]                         if (!is.null(pattern)) {
[10:58:46.282]                           computeRestarts <- base::computeRestarts
[10:58:46.282]                           grepl <- base::grepl
[10:58:46.282]                           restarts <- computeRestarts(cond)
[10:58:46.282]                           for (restart in restarts) {
[10:58:46.282]                             name <- restart$name
[10:58:46.282]                             if (is.null(name)) 
[10:58:46.282]                               next
[10:58:46.282]                             if (!grepl(pattern, name)) 
[10:58:46.282]                               next
[10:58:46.282]                             invokeRestart(restart)
[10:58:46.282]                             muffled <- TRUE
[10:58:46.282]                             break
[10:58:46.282]                           }
[10:58:46.282]                         }
[10:58:46.282]                       }
[10:58:46.282]                       invisible(muffled)
[10:58:46.282]                     }
[10:58:46.282]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.282]                   }
[10:58:46.282]                 }
[10:58:46.282]             }
[10:58:46.282]         }))
[10:58:46.282]     }, error = function(ex) {
[10:58:46.282]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.282]                 ...future.rng), started = ...future.startTime, 
[10:58:46.282]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.282]             version = "1.8"), class = "FutureResult")
[10:58:46.282]     }, finally = {
[10:58:46.282]         if (!identical(...future.workdir, getwd())) 
[10:58:46.282]             setwd(...future.workdir)
[10:58:46.282]         {
[10:58:46.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.282]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.282]             }
[10:58:46.282]             base::options(...future.oldOptions)
[10:58:46.282]             if (.Platform$OS.type == "windows") {
[10:58:46.282]                 old_names <- names(...future.oldEnvVars)
[10:58:46.282]                 envs <- base::Sys.getenv()
[10:58:46.282]                 names <- names(envs)
[10:58:46.282]                 common <- intersect(names, old_names)
[10:58:46.282]                 added <- setdiff(names, old_names)
[10:58:46.282]                 removed <- setdiff(old_names, names)
[10:58:46.282]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.282]                   envs[common]]
[10:58:46.282]                 NAMES <- toupper(changed)
[10:58:46.282]                 args <- list()
[10:58:46.282]                 for (kk in seq_along(NAMES)) {
[10:58:46.282]                   name <- changed[[kk]]
[10:58:46.282]                   NAME <- NAMES[[kk]]
[10:58:46.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.282]                     next
[10:58:46.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.282]                 }
[10:58:46.282]                 NAMES <- toupper(added)
[10:58:46.282]                 for (kk in seq_along(NAMES)) {
[10:58:46.282]                   name <- added[[kk]]
[10:58:46.282]                   NAME <- NAMES[[kk]]
[10:58:46.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.282]                     next
[10:58:46.282]                   args[[name]] <- ""
[10:58:46.282]                 }
[10:58:46.282]                 NAMES <- toupper(removed)
[10:58:46.282]                 for (kk in seq_along(NAMES)) {
[10:58:46.282]                   name <- removed[[kk]]
[10:58:46.282]                   NAME <- NAMES[[kk]]
[10:58:46.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.282]                     next
[10:58:46.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.282]                 }
[10:58:46.282]                 if (length(args) > 0) 
[10:58:46.282]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.282]             }
[10:58:46.282]             else {
[10:58:46.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.282]             }
[10:58:46.282]             {
[10:58:46.282]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.282]                   0L) {
[10:58:46.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.282]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.282]                   base::options(opts)
[10:58:46.282]                 }
[10:58:46.282]                 {
[10:58:46.282]                   {
[10:58:46.282]                     NULL
[10:58:46.282]                     RNGkind("Mersenne-Twister")
[10:58:46.282]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:46.282]                       inherits = FALSE)
[10:58:46.282]                   }
[10:58:46.282]                   options(future.plan = NULL)
[10:58:46.282]                   if (is.na(NA_character_)) 
[10:58:46.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.282]                     .init = FALSE)
[10:58:46.282]                 }
[10:58:46.282]             }
[10:58:46.282]         }
[10:58:46.282]     })
[10:58:46.282]     if (TRUE) {
[10:58:46.282]         base::sink(type = "output", split = FALSE)
[10:58:46.282]         if (TRUE) {
[10:58:46.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.282]         }
[10:58:46.282]         else {
[10:58:46.282]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.282]         }
[10:58:46.282]         base::close(...future.stdout)
[10:58:46.282]         ...future.stdout <- NULL
[10:58:46.282]     }
[10:58:46.282]     ...future.result$conditions <- ...future.conditions
[10:58:46.282]     ...future.result$finished <- base::Sys.time()
[10:58:46.282]     ...future.result
[10:58:46.282] }
[10:58:46.284] assign_globals() ...
[10:58:46.284] List of 5
[10:58:46.284]  $ ...future.FUN            :function (x, ...)  
[10:58:46.284]  $ future.call.arguments    :List of 1
[10:58:46.284]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:46.284]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.284]  $ ...future.elements_ii    :List of 3
[10:58:46.284]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.284]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.284]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.284]  $ ...future.seeds_ii       : NULL
[10:58:46.284]  $ ...future.globals.maxSize: NULL
[10:58:46.284]  - attr(*, "where")=List of 5
[10:58:46.284]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.284]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.284]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.284]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.284]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.284]  - attr(*, "resolved")= logi FALSE
[10:58:46.284]  - attr(*, "total_size")= num 6525
[10:58:46.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.284]  - attr(*, "already-done")= logi TRUE
[10:58:46.289] - copied ‘...future.FUN’ to environment
[10:58:46.289] - copied ‘future.call.arguments’ to environment
[10:58:46.289] - copied ‘...future.elements_ii’ to environment
[10:58:46.289] - copied ‘...future.seeds_ii’ to environment
[10:58:46.290] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.290] assign_globals() ... done
[10:58:46.290] plan(): Setting new future strategy stack:
[10:58:46.290] List of future strategies:
[10:58:46.290] 1. sequential:
[10:58:46.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.290]    - tweaked: FALSE
[10:58:46.290]    - call: NULL
[10:58:46.291] plan(): nbrOfWorkers() = 1
[10:58:46.292] plan(): Setting new future strategy stack:
[10:58:46.292] List of future strategies:
[10:58:46.292] 1. sequential:
[10:58:46.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.292]    - tweaked: FALSE
[10:58:46.292]    - call: plan(strategy)
[10:58:46.292] plan(): nbrOfWorkers() = 1
[10:58:46.292] SequentialFuture started (and completed)
[10:58:46.292] - Launch lazy future ... done
[10:58:46.293] run() for ‘SequentialFuture’ ... done
[10:58:46.293] Created future:
[10:58:46.293] SequentialFuture:
[10:58:46.293] Label: ‘future_eapply-1’
[10:58:46.293] Expression:
[10:58:46.293] {
[10:58:46.293]     do.call(function(...) {
[10:58:46.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.293]             on.exit(options(oopts), add = TRUE)
[10:58:46.293]         }
[10:58:46.293]         {
[10:58:46.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.293]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.293]             })
[10:58:46.293]         }
[10:58:46.293]     }, args = future.call.arguments)
[10:58:46.293] }
[10:58:46.293] Lazy evaluation: FALSE
[10:58:46.293] Asynchronous evaluation: FALSE
[10:58:46.293] Local evaluation: TRUE
[10:58:46.293] Environment: R_GlobalEnv
[10:58:46.293] Capture standard output: TRUE
[10:58:46.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.293] Globals: 5 objects totaling 832 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 296 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.293] Packages: 1 packages (‘stats’)
[10:58:46.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.293] Resolved: TRUE
[10:58:46.293] Value: 299 bytes of class ‘list’
[10:58:46.293] Early signaling: FALSE
[10:58:46.293] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.293] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.294] Chunk #1 of 1 ... DONE
[10:58:46.294] Launching 1 futures (chunks) ... DONE
[10:58:46.294] Resolving 1 futures (chunks) ...
[10:58:46.294] resolve() on list ...
[10:58:46.294]  recursive: 0
[10:58:46.294]  length: 1
[10:58:46.294] 
[10:58:46.294] resolved() for ‘SequentialFuture’ ...
[10:58:46.294] - state: ‘finished’
[10:58:46.294] - run: TRUE
[10:58:46.294] - result: ‘FutureResult’
[10:58:46.295] resolved() for ‘SequentialFuture’ ... done
[10:58:46.295] Future #1
[10:58:46.295] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:46.295] - nx: 1
[10:58:46.295] - relay: TRUE
[10:58:46.295] - stdout: TRUE
[10:58:46.295] - signal: TRUE
[10:58:46.295] - resignal: FALSE
[10:58:46.295] - force: TRUE
[10:58:46.295] - relayed: [n=1] FALSE
[10:58:46.295] - queued futures: [n=1] FALSE
[10:58:46.295]  - until=1
[10:58:46.296]  - relaying element #1
[10:58:46.297] - relayed: [n=1] TRUE
[10:58:46.297] - queued futures: [n=1] TRUE
[10:58:46.297] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:46.297]  length: 0 (resolved future 1)
[10:58:46.297] Relaying remaining futures
[10:58:46.298] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.298] - nx: 1
[10:58:46.298] - relay: TRUE
[10:58:46.298] - stdout: TRUE
[10:58:46.298] - signal: TRUE
[10:58:46.298] - resignal: FALSE
[10:58:46.298] - force: TRUE
[10:58:46.298] - relayed: [n=1] TRUE
[10:58:46.298] - queued futures: [n=1] TRUE
 - flush all
[10:58:46.298] - relayed: [n=1] TRUE
[10:58:46.298] - queued futures: [n=1] TRUE
[10:58:46.299] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.299] resolve() on list ... DONE
[10:58:46.299]  - Number of value chunks collected: 1
[10:58:46.299] Resolving 1 futures (chunks) ... DONE
[10:58:46.299] Reducing values from 1 chunks ...
[10:58:46.299]  - Number of values collected after concatenation: 3
[10:58:46.299]  - Number of values expected: 3
[10:58:46.299] Reducing values from 1 chunks ... DONE
[10:58:46.299] future_lapply() ... DONE
[10:58:46.300] future_lapply() ...
[10:58:46.301] Number of chunks: 1
[10:58:46.301] getGlobalsAndPackagesXApply() ...
[10:58:46.301]  - future.globals: TRUE
[10:58:46.301] getGlobalsAndPackages() ...
[10:58:46.301] Searching for globals...
[10:58:46.302] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.302] Searching for globals ... DONE
[10:58:46.303] Resolving globals: FALSE
[10:58:46.303] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:46.303] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:46.303] - globals: [1] ‘FUN’
[10:58:46.303] - packages: [1] ‘stats’
[10:58:46.304] getGlobalsAndPackages() ... DONE
[10:58:46.304]  - globals found/used: [n=1] ‘FUN’
[10:58:46.304]  - needed namespaces: [n=1] ‘stats’
[10:58:46.304] Finding globals ... DONE
[10:58:46.304]  - use_args: TRUE
[10:58:46.304]  - Getting '...' globals ...
[10:58:46.304] resolve() on list ...
[10:58:46.304]  recursive: 0
[10:58:46.305]  length: 1
[10:58:46.305]  elements: ‘...’
[10:58:46.305]  length: 0 (resolved future 1)
[10:58:46.305] resolve() on list ... DONE
[10:58:46.305]    - '...' content: [n=0] 
[10:58:46.305] List of 1
[10:58:46.305]  $ ...: list()
[10:58:46.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.305]  - attr(*, "where")=List of 1
[10:58:46.305]   ..$ ...:<environment: 0x55f48970ceb0> 
[10:58:46.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.305]  - attr(*, "resolved")= logi TRUE
[10:58:46.305]  - attr(*, "total_size")= num NA
[10:58:46.307]  - Getting '...' globals ... DONE
[10:58:46.308] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.308] List of 2
[10:58:46.308]  $ ...future.FUN:function (x, ...)  
[10:58:46.308]  $ ...          : list()
[10:58:46.308]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.308]  - attr(*, "where")=List of 2
[10:58:46.308]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.308]   ..$ ...          :<environment: 0x55f48970ceb0> 
[10:58:46.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.308]  - attr(*, "resolved")= logi FALSE
[10:58:46.308]  - attr(*, "total_size")= num 5433
[10:58:46.310] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:46.310] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.311] Number of futures (= number of chunks): 1
[10:58:46.311] Launching 1 futures (chunks) ...
[10:58:46.311] Chunk #1 of 1 ...
[10:58:46.311]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.311] getGlobalsAndPackages() ...
[10:58:46.311] Searching for globals...
[10:58:46.311] 
[10:58:46.311] Searching for globals ... DONE
[10:58:46.311] - globals: [0] <none>
[10:58:46.312] getGlobalsAndPackages() ... DONE
[10:58:46.312]    + additional globals found: [n=0] 
[10:58:46.312]    + additional namespaces needed: [n=0] 
[10:58:46.312]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.312]  - seeds: <none>
[10:58:46.312]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.312] getGlobalsAndPackages() ...
[10:58:46.312] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.312] Resolving globals: FALSE
[10:58:46.312] Tweak future expression to call with '...' arguments ...
[10:58:46.313] {
[10:58:46.313]     do.call(function(...) {
[10:58:46.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.313]             on.exit(options(oopts), add = TRUE)
[10:58:46.313]         }
[10:58:46.313]         {
[10:58:46.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.313]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.313]             })
[10:58:46.313]         }
[10:58:46.313]     }, args = future.call.arguments)
[10:58:46.313] }
[10:58:46.313] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.313] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.313] - packages: [1] ‘stats’
[10:58:46.313] getGlobalsAndPackages() ... DONE
[10:58:46.314] run() for ‘Future’ ...
[10:58:46.314] - state: ‘created’
[10:58:46.314] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:46.314] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:46.314]   - Field: ‘label’
[10:58:46.314]   - Field: ‘local’
[10:58:46.315]   - Field: ‘owner’
[10:58:46.315]   - Field: ‘envir’
[10:58:46.315]   - Field: ‘packages’
[10:58:46.315]   - Field: ‘gc’
[10:58:46.315]   - Field: ‘conditions’
[10:58:46.315]   - Field: ‘expr’
[10:58:46.315]   - Field: ‘uuid’
[10:58:46.315]   - Field: ‘seed’
[10:58:46.315]   - Field: ‘version’
[10:58:46.315]   - Field: ‘result’
[10:58:46.315]   - Field: ‘asynchronous’
[10:58:46.315]   - Field: ‘calls’
[10:58:46.316]   - Field: ‘globals’
[10:58:46.316]   - Field: ‘stdout’
[10:58:46.316]   - Field: ‘earlySignal’
[10:58:46.316]   - Field: ‘lazy’
[10:58:46.316]   - Field: ‘state’
[10:58:46.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:46.316] - Launch lazy future ...
[10:58:46.316] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.316] Packages needed by future strategies (n = 0): <none>
[10:58:46.317] {
[10:58:46.317]     {
[10:58:46.317]         {
[10:58:46.317]             ...future.startTime <- base::Sys.time()
[10:58:46.317]             {
[10:58:46.317]                 {
[10:58:46.317]                   {
[10:58:46.317]                     {
[10:58:46.317]                       base::local({
[10:58:46.317]                         has_future <- base::requireNamespace("future", 
[10:58:46.317]                           quietly = TRUE)
[10:58:46.317]                         if (has_future) {
[10:58:46.317]                           ns <- base::getNamespace("future")
[10:58:46.317]                           version <- ns[[".package"]][["version"]]
[10:58:46.317]                           if (is.null(version)) 
[10:58:46.317]                             version <- utils::packageVersion("future")
[10:58:46.317]                         }
[10:58:46.317]                         else {
[10:58:46.317]                           version <- NULL
[10:58:46.317]                         }
[10:58:46.317]                         if (!has_future || version < "1.8.0") {
[10:58:46.317]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.317]                             "", base::R.version$version.string), 
[10:58:46.317]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:46.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:46.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.317]                               "release", "version")], collapse = " "), 
[10:58:46.317]                             hostname = base::Sys.info()[["nodename"]])
[10:58:46.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.317]                             info)
[10:58:46.317]                           info <- base::paste(info, collapse = "; ")
[10:58:46.317]                           if (!has_future) {
[10:58:46.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.317]                               info)
[10:58:46.317]                           }
[10:58:46.317]                           else {
[10:58:46.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.317]                               info, version)
[10:58:46.317]                           }
[10:58:46.317]                           base::stop(msg)
[10:58:46.317]                         }
[10:58:46.317]                       })
[10:58:46.317]                     }
[10:58:46.317]                     base::local({
[10:58:46.317]                       for (pkg in "stats") {
[10:58:46.317]                         base::loadNamespace(pkg)
[10:58:46.317]                         base::library(pkg, character.only = TRUE)
[10:58:46.317]                       }
[10:58:46.317]                     })
[10:58:46.317]                   }
[10:58:46.317]                   ...future.strategy.old <- future::plan("list")
[10:58:46.317]                   options(future.plan = NULL)
[10:58:46.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.317]                 }
[10:58:46.317]                 ...future.workdir <- getwd()
[10:58:46.317]             }
[10:58:46.317]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.317]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.317]         }
[10:58:46.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:46.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.317]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.317]             base::names(...future.oldOptions))
[10:58:46.317]     }
[10:58:46.317]     if (FALSE) {
[10:58:46.317]     }
[10:58:46.317]     else {
[10:58:46.317]         if (TRUE) {
[10:58:46.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.317]                 open = "w")
[10:58:46.317]         }
[10:58:46.317]         else {
[10:58:46.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.317]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.317]         }
[10:58:46.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.317]             base::sink(type = "output", split = FALSE)
[10:58:46.317]             base::close(...future.stdout)
[10:58:46.317]         }, add = TRUE)
[10:58:46.317]     }
[10:58:46.317]     ...future.frame <- base::sys.nframe()
[10:58:46.317]     ...future.conditions <- base::list()
[10:58:46.317]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.317]     if (FALSE) {
[10:58:46.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.317]     }
[10:58:46.317]     ...future.result <- base::tryCatch({
[10:58:46.317]         base::withCallingHandlers({
[10:58:46.317]             ...future.value <- base::withVisible(base::local({
[10:58:46.317]                 do.call(function(...) {
[10:58:46.317]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.317]                   if (!identical(...future.globals.maxSize.org, 
[10:58:46.317]                     ...future.globals.maxSize)) {
[10:58:46.317]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.317]                     on.exit(options(oopts), add = TRUE)
[10:58:46.317]                   }
[10:58:46.317]                   {
[10:58:46.317]                     lapply(seq_along(...future.elements_ii), 
[10:58:46.317]                       FUN = function(jj) {
[10:58:46.317]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.317]                         ...future.FUN(...future.X_jj, ...)
[10:58:46.317]                       })
[10:58:46.317]                   }
[10:58:46.317]                 }, args = future.call.arguments)
[10:58:46.317]             }))
[10:58:46.317]             future::FutureResult(value = ...future.value$value, 
[10:58:46.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.317]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.317]                     ...future.globalenv.names))
[10:58:46.317]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.317]         }, condition = base::local({
[10:58:46.317]             c <- base::c
[10:58:46.317]             inherits <- base::inherits
[10:58:46.317]             invokeRestart <- base::invokeRestart
[10:58:46.317]             length <- base::length
[10:58:46.317]             list <- base::list
[10:58:46.317]             seq.int <- base::seq.int
[10:58:46.317]             signalCondition <- base::signalCondition
[10:58:46.317]             sys.calls <- base::sys.calls
[10:58:46.317]             `[[` <- base::`[[`
[10:58:46.317]             `+` <- base::`+`
[10:58:46.317]             `<<-` <- base::`<<-`
[10:58:46.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.317]                   3L)]
[10:58:46.317]             }
[10:58:46.317]             function(cond) {
[10:58:46.317]                 is_error <- inherits(cond, "error")
[10:58:46.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.317]                   NULL)
[10:58:46.317]                 if (is_error) {
[10:58:46.317]                   sessionInformation <- function() {
[10:58:46.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.317]                       search = base::search(), system = base::Sys.info())
[10:58:46.317]                   }
[10:58:46.317]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.317]                     cond$call), session = sessionInformation(), 
[10:58:46.317]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.317]                   signalCondition(cond)
[10:58:46.317]                 }
[10:58:46.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.317]                 "immediateCondition"))) {
[10:58:46.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.317]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.317]                   if (TRUE && !signal) {
[10:58:46.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.317]                     {
[10:58:46.317]                       inherits <- base::inherits
[10:58:46.317]                       invokeRestart <- base::invokeRestart
[10:58:46.317]                       is.null <- base::is.null
[10:58:46.317]                       muffled <- FALSE
[10:58:46.317]                       if (inherits(cond, "message")) {
[10:58:46.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.317]                         if (muffled) 
[10:58:46.317]                           invokeRestart("muffleMessage")
[10:58:46.317]                       }
[10:58:46.317]                       else if (inherits(cond, "warning")) {
[10:58:46.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.317]                         if (muffled) 
[10:58:46.317]                           invokeRestart("muffleWarning")
[10:58:46.317]                       }
[10:58:46.317]                       else if (inherits(cond, "condition")) {
[10:58:46.317]                         if (!is.null(pattern)) {
[10:58:46.317]                           computeRestarts <- base::computeRestarts
[10:58:46.317]                           grepl <- base::grepl
[10:58:46.317]                           restarts <- computeRestarts(cond)
[10:58:46.317]                           for (restart in restarts) {
[10:58:46.317]                             name <- restart$name
[10:58:46.317]                             if (is.null(name)) 
[10:58:46.317]                               next
[10:58:46.317]                             if (!grepl(pattern, name)) 
[10:58:46.317]                               next
[10:58:46.317]                             invokeRestart(restart)
[10:58:46.317]                             muffled <- TRUE
[10:58:46.317]                             break
[10:58:46.317]                           }
[10:58:46.317]                         }
[10:58:46.317]                       }
[10:58:46.317]                       invisible(muffled)
[10:58:46.317]                     }
[10:58:46.317]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.317]                   }
[10:58:46.317]                 }
[10:58:46.317]                 else {
[10:58:46.317]                   if (TRUE) {
[10:58:46.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.317]                     {
[10:58:46.317]                       inherits <- base::inherits
[10:58:46.317]                       invokeRestart <- base::invokeRestart
[10:58:46.317]                       is.null <- base::is.null
[10:58:46.317]                       muffled <- FALSE
[10:58:46.317]                       if (inherits(cond, "message")) {
[10:58:46.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.317]                         if (muffled) 
[10:58:46.317]                           invokeRestart("muffleMessage")
[10:58:46.317]                       }
[10:58:46.317]                       else if (inherits(cond, "warning")) {
[10:58:46.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.317]                         if (muffled) 
[10:58:46.317]                           invokeRestart("muffleWarning")
[10:58:46.317]                       }
[10:58:46.317]                       else if (inherits(cond, "condition")) {
[10:58:46.317]                         if (!is.null(pattern)) {
[10:58:46.317]                           computeRestarts <- base::computeRestarts
[10:58:46.317]                           grepl <- base::grepl
[10:58:46.317]                           restarts <- computeRestarts(cond)
[10:58:46.317]                           for (restart in restarts) {
[10:58:46.317]                             name <- restart$name
[10:58:46.317]                             if (is.null(name)) 
[10:58:46.317]                               next
[10:58:46.317]                             if (!grepl(pattern, name)) 
[10:58:46.317]                               next
[10:58:46.317]                             invokeRestart(restart)
[10:58:46.317]                             muffled <- TRUE
[10:58:46.317]                             break
[10:58:46.317]                           }
[10:58:46.317]                         }
[10:58:46.317]                       }
[10:58:46.317]                       invisible(muffled)
[10:58:46.317]                     }
[10:58:46.317]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.317]                   }
[10:58:46.317]                 }
[10:58:46.317]             }
[10:58:46.317]         }))
[10:58:46.317]     }, error = function(ex) {
[10:58:46.317]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.317]                 ...future.rng), started = ...future.startTime, 
[10:58:46.317]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.317]             version = "1.8"), class = "FutureResult")
[10:58:46.317]     }, finally = {
[10:58:46.317]         if (!identical(...future.workdir, getwd())) 
[10:58:46.317]             setwd(...future.workdir)
[10:58:46.317]         {
[10:58:46.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.317]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.317]             }
[10:58:46.317]             base::options(...future.oldOptions)
[10:58:46.317]             if (.Platform$OS.type == "windows") {
[10:58:46.317]                 old_names <- names(...future.oldEnvVars)
[10:58:46.317]                 envs <- base::Sys.getenv()
[10:58:46.317]                 names <- names(envs)
[10:58:46.317]                 common <- intersect(names, old_names)
[10:58:46.317]                 added <- setdiff(names, old_names)
[10:58:46.317]                 removed <- setdiff(old_names, names)
[10:58:46.317]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.317]                   envs[common]]
[10:58:46.317]                 NAMES <- toupper(changed)
[10:58:46.317]                 args <- list()
[10:58:46.317]                 for (kk in seq_along(NAMES)) {
[10:58:46.317]                   name <- changed[[kk]]
[10:58:46.317]                   NAME <- NAMES[[kk]]
[10:58:46.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.317]                     next
[10:58:46.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.317]                 }
[10:58:46.317]                 NAMES <- toupper(added)
[10:58:46.317]                 for (kk in seq_along(NAMES)) {
[10:58:46.317]                   name <- added[[kk]]
[10:58:46.317]                   NAME <- NAMES[[kk]]
[10:58:46.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.317]                     next
[10:58:46.317]                   args[[name]] <- ""
[10:58:46.317]                 }
[10:58:46.317]                 NAMES <- toupper(removed)
[10:58:46.317]                 for (kk in seq_along(NAMES)) {
[10:58:46.317]                   name <- removed[[kk]]
[10:58:46.317]                   NAME <- NAMES[[kk]]
[10:58:46.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.317]                     next
[10:58:46.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.317]                 }
[10:58:46.317]                 if (length(args) > 0) 
[10:58:46.317]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.317]             }
[10:58:46.317]             else {
[10:58:46.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.317]             }
[10:58:46.317]             {
[10:58:46.317]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.317]                   0L) {
[10:58:46.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.317]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.317]                   base::options(opts)
[10:58:46.317]                 }
[10:58:46.317]                 {
[10:58:46.317]                   {
[10:58:46.317]                     NULL
[10:58:46.317]                     RNGkind("Mersenne-Twister")
[10:58:46.317]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:46.317]                       inherits = FALSE)
[10:58:46.317]                   }
[10:58:46.317]                   options(future.plan = NULL)
[10:58:46.317]                   if (is.na(NA_character_)) 
[10:58:46.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.317]                     .init = FALSE)
[10:58:46.317]                 }
[10:58:46.317]             }
[10:58:46.317]         }
[10:58:46.317]     })
[10:58:46.317]     if (TRUE) {
[10:58:46.317]         base::sink(type = "output", split = FALSE)
[10:58:46.317]         if (TRUE) {
[10:58:46.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.317]         }
[10:58:46.317]         else {
[10:58:46.317]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.317]         }
[10:58:46.317]         base::close(...future.stdout)
[10:58:46.317]         ...future.stdout <- NULL
[10:58:46.317]     }
[10:58:46.317]     ...future.result$conditions <- ...future.conditions
[10:58:46.317]     ...future.result$finished <- base::Sys.time()
[10:58:46.317]     ...future.result
[10:58:46.317] }
[10:58:46.319] assign_globals() ...
[10:58:46.319] List of 5
[10:58:46.319]  $ ...future.FUN            :function (x, ...)  
[10:58:46.319]  $ future.call.arguments    : list()
[10:58:46.319]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.319]  $ ...future.elements_ii    :List of 3
[10:58:46.319]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.319]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.319]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.319]  $ ...future.seeds_ii       : NULL
[10:58:46.319]  $ ...future.globals.maxSize: NULL
[10:58:46.319]  - attr(*, "where")=List of 5
[10:58:46.319]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.319]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.319]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.319]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.319]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.319]  - attr(*, "resolved")= logi FALSE
[10:58:46.319]  - attr(*, "total_size")= num 5433
[10:58:46.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.319]  - attr(*, "already-done")= logi TRUE
[10:58:46.326] - copied ‘...future.FUN’ to environment
[10:58:46.326] - copied ‘future.call.arguments’ to environment
[10:58:46.326] - copied ‘...future.elements_ii’ to environment
[10:58:46.326] - copied ‘...future.seeds_ii’ to environment
[10:58:46.326] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.326] assign_globals() ... done
[10:58:46.327] plan(): Setting new future strategy stack:
[10:58:46.327] List of future strategies:
[10:58:46.327] 1. sequential:
[10:58:46.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.327]    - tweaked: FALSE
[10:58:46.327]    - call: NULL
[10:58:46.327] plan(): nbrOfWorkers() = 1
[10:58:46.328] plan(): Setting new future strategy stack:
[10:58:46.328] List of future strategies:
[10:58:46.328] 1. sequential:
[10:58:46.328]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.328]    - tweaked: FALSE
[10:58:46.328]    - call: plan(strategy)
[10:58:46.329] plan(): nbrOfWorkers() = 1
[10:58:46.329] SequentialFuture started (and completed)
[10:58:46.329] - Launch lazy future ... done
[10:58:46.329] run() for ‘SequentialFuture’ ... done
[10:58:46.329] Created future:
[10:58:46.329] SequentialFuture:
[10:58:46.329] Label: ‘future_eapply-1’
[10:58:46.329] Expression:
[10:58:46.329] {
[10:58:46.329]     do.call(function(...) {
[10:58:46.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.329]             on.exit(options(oopts), add = TRUE)
[10:58:46.329]         }
[10:58:46.329]         {
[10:58:46.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.329]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.329]             })
[10:58:46.329]         }
[10:58:46.329]     }, args = future.call.arguments)
[10:58:46.329] }
[10:58:46.329] Lazy evaluation: FALSE
[10:58:46.329] Asynchronous evaluation: FALSE
[10:58:46.329] Local evaluation: TRUE
[10:58:46.329] Environment: R_GlobalEnv
[10:58:46.329] Capture standard output: TRUE
[10:58:46.329] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.329] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 296 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.329] Packages: 1 packages (‘stats’)
[10:58:46.329] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.329] Resolved: TRUE
[10:58:46.329] Value: 413 bytes of class ‘list’
[10:58:46.329] Early signaling: FALSE
[10:58:46.329] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.329] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.330] Chunk #1 of 1 ... DONE
[10:58:46.330] Launching 1 futures (chunks) ... DONE
[10:58:46.330] Resolving 1 futures (chunks) ...
[10:58:46.331] resolve() on list ...
[10:58:46.331]  recursive: 0
[10:58:46.331]  length: 1
[10:58:46.331] 
[10:58:46.331] resolved() for ‘SequentialFuture’ ...
[10:58:46.331] - state: ‘finished’
[10:58:46.331] - run: TRUE
[10:58:46.331] - result: ‘FutureResult’
[10:58:46.331] resolved() for ‘SequentialFuture’ ... done
[10:58:46.331] Future #1
[10:58:46.332] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:46.332] - nx: 1
[10:58:46.332] - relay: TRUE
[10:58:46.332] - stdout: TRUE
[10:58:46.332] - signal: TRUE
[10:58:46.332] - resignal: FALSE
[10:58:46.332] - force: TRUE
[10:58:46.332] - relayed: [n=1] FALSE
[10:58:46.332] - queued futures: [n=1] FALSE
[10:58:46.332]  - until=1
[10:58:46.332]  - relaying element #1
[10:58:46.333] - relayed: [n=1] TRUE
[10:58:46.333] - queued futures: [n=1] TRUE
[10:58:46.333] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:46.333]  length: 0 (resolved future 1)
[10:58:46.333] Relaying remaining futures
[10:58:46.333] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.333] - nx: 1
[10:58:46.333] - relay: TRUE
[10:58:46.333] - stdout: TRUE
[10:58:46.333] - signal: TRUE
[10:58:46.333] - resignal: FALSE
[10:58:46.334] - force: TRUE
[10:58:46.334] - relayed: [n=1] TRUE
[10:58:46.334] - queued futures: [n=1] TRUE
 - flush all
[10:58:46.334] - relayed: [n=1] TRUE
[10:58:46.334] - queued futures: [n=1] TRUE
[10:58:46.334] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.334] resolve() on list ... DONE
[10:58:46.334]  - Number of value chunks collected: 1
[10:58:46.334] Resolving 1 futures (chunks) ... DONE
[10:58:46.334] Reducing values from 1 chunks ...
[10:58:46.334]  - Number of values collected after concatenation: 3
[10:58:46.335]  - Number of values expected: 3
[10:58:46.335] Reducing values from 1 chunks ... DONE
[10:58:46.335] future_lapply() ... DONE
[10:58:46.335] future_lapply() ...
[10:58:46.335] Number of chunks: 1
[10:58:46.336] getGlobalsAndPackagesXApply() ...
[10:58:46.336]  - future.globals: TRUE
[10:58:46.336] getGlobalsAndPackages() ...
[10:58:46.336] Searching for globals...
[10:58:46.337] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.337] Searching for globals ... DONE
[10:58:46.337] Resolving globals: FALSE
[10:58:46.337] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:46.338] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:46.338] - globals: [1] ‘FUN’
[10:58:46.338] - packages: [1] ‘stats’
[10:58:46.338] getGlobalsAndPackages() ... DONE
[10:58:46.338]  - globals found/used: [n=1] ‘FUN’
[10:58:46.338]  - needed namespaces: [n=1] ‘stats’
[10:58:46.338] Finding globals ... DONE
[10:58:46.338]  - use_args: TRUE
[10:58:46.339]  - Getting '...' globals ...
[10:58:46.339] resolve() on list ...
[10:58:46.339]  recursive: 0
[10:58:46.339]  length: 1
[10:58:46.339]  elements: ‘...’
[10:58:46.339]  length: 0 (resolved future 1)
[10:58:46.339] resolve() on list ... DONE
[10:58:46.339]    - '...' content: [n=0] 
[10:58:46.340] List of 1
[10:58:46.340]  $ ...: list()
[10:58:46.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.340]  - attr(*, "where")=List of 1
[10:58:46.340]   ..$ ...:<environment: 0x55f48afcece8> 
[10:58:46.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.340]  - attr(*, "resolved")= logi TRUE
[10:58:46.340]  - attr(*, "total_size")= num NA
[10:58:46.342]  - Getting '...' globals ... DONE
[10:58:46.342] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.342] List of 2
[10:58:46.342]  $ ...future.FUN:function (x, ...)  
[10:58:46.342]  $ ...          : list()
[10:58:46.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.342]  - attr(*, "where")=List of 2
[10:58:46.342]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.342]   ..$ ...          :<environment: 0x55f48afcece8> 
[10:58:46.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.342]  - attr(*, "resolved")= logi FALSE
[10:58:46.342]  - attr(*, "total_size")= num 5437
[10:58:46.345] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:46.345] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.345] Number of futures (= number of chunks): 1
[10:58:46.346] Launching 1 futures (chunks) ...
[10:58:46.347] Chunk #1 of 1 ...
[10:58:46.347]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.347] getGlobalsAndPackages() ...
[10:58:46.347] Searching for globals...
[10:58:46.347] 
[10:58:46.347] Searching for globals ... DONE
[10:58:46.347] - globals: [0] <none>
[10:58:46.347] getGlobalsAndPackages() ... DONE
[10:58:46.347]    + additional globals found: [n=0] 
[10:58:46.348]    + additional namespaces needed: [n=0] 
[10:58:46.348]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.348]  - seeds: <none>
[10:58:46.348]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.348] getGlobalsAndPackages() ...
[10:58:46.348] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.348] Resolving globals: FALSE
[10:58:46.348] Tweak future expression to call with '...' arguments ...
[10:58:46.348] {
[10:58:46.348]     do.call(function(...) {
[10:58:46.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.348]             on.exit(options(oopts), add = TRUE)
[10:58:46.348]         }
[10:58:46.348]         {
[10:58:46.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.348]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.348]             })
[10:58:46.348]         }
[10:58:46.348]     }, args = future.call.arguments)
[10:58:46.348] }
[10:58:46.349] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.349] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.349] - packages: [1] ‘stats’
[10:58:46.349] getGlobalsAndPackages() ... DONE
[10:58:46.349] run() for ‘Future’ ...
[10:58:46.350] - state: ‘created’
[10:58:46.350] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:46.350] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:46.350]   - Field: ‘label’
[10:58:46.350]   - Field: ‘local’
[10:58:46.350]   - Field: ‘owner’
[10:58:46.350]   - Field: ‘envir’
[10:58:46.350]   - Field: ‘packages’
[10:58:46.351]   - Field: ‘gc’
[10:58:46.351]   - Field: ‘conditions’
[10:58:46.351]   - Field: ‘expr’
[10:58:46.351]   - Field: ‘uuid’
[10:58:46.351]   - Field: ‘seed’
[10:58:46.351]   - Field: ‘version’
[10:58:46.351]   - Field: ‘result’
[10:58:46.351]   - Field: ‘asynchronous’
[10:58:46.351]   - Field: ‘calls’
[10:58:46.351]   - Field: ‘globals’
[10:58:46.351]   - Field: ‘stdout’
[10:58:46.352]   - Field: ‘earlySignal’
[10:58:46.352]   - Field: ‘lazy’
[10:58:46.352]   - Field: ‘state’
[10:58:46.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:46.352] - Launch lazy future ...
[10:58:46.352] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.352] Packages needed by future strategies (n = 0): <none>
[10:58:46.353] {
[10:58:46.353]     {
[10:58:46.353]         {
[10:58:46.353]             ...future.startTime <- base::Sys.time()
[10:58:46.353]             {
[10:58:46.353]                 {
[10:58:46.353]                   {
[10:58:46.353]                     {
[10:58:46.353]                       base::local({
[10:58:46.353]                         has_future <- base::requireNamespace("future", 
[10:58:46.353]                           quietly = TRUE)
[10:58:46.353]                         if (has_future) {
[10:58:46.353]                           ns <- base::getNamespace("future")
[10:58:46.353]                           version <- ns[[".package"]][["version"]]
[10:58:46.353]                           if (is.null(version)) 
[10:58:46.353]                             version <- utils::packageVersion("future")
[10:58:46.353]                         }
[10:58:46.353]                         else {
[10:58:46.353]                           version <- NULL
[10:58:46.353]                         }
[10:58:46.353]                         if (!has_future || version < "1.8.0") {
[10:58:46.353]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.353]                             "", base::R.version$version.string), 
[10:58:46.353]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:46.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:46.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.353]                               "release", "version")], collapse = " "), 
[10:58:46.353]                             hostname = base::Sys.info()[["nodename"]])
[10:58:46.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.353]                             info)
[10:58:46.353]                           info <- base::paste(info, collapse = "; ")
[10:58:46.353]                           if (!has_future) {
[10:58:46.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.353]                               info)
[10:58:46.353]                           }
[10:58:46.353]                           else {
[10:58:46.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.353]                               info, version)
[10:58:46.353]                           }
[10:58:46.353]                           base::stop(msg)
[10:58:46.353]                         }
[10:58:46.353]                       })
[10:58:46.353]                     }
[10:58:46.353]                     base::local({
[10:58:46.353]                       for (pkg in "stats") {
[10:58:46.353]                         base::loadNamespace(pkg)
[10:58:46.353]                         base::library(pkg, character.only = TRUE)
[10:58:46.353]                       }
[10:58:46.353]                     })
[10:58:46.353]                   }
[10:58:46.353]                   ...future.strategy.old <- future::plan("list")
[10:58:46.353]                   options(future.plan = NULL)
[10:58:46.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.353]                 }
[10:58:46.353]                 ...future.workdir <- getwd()
[10:58:46.353]             }
[10:58:46.353]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.353]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.353]         }
[10:58:46.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:46.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.353]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.353]             base::names(...future.oldOptions))
[10:58:46.353]     }
[10:58:46.353]     if (FALSE) {
[10:58:46.353]     }
[10:58:46.353]     else {
[10:58:46.353]         if (TRUE) {
[10:58:46.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.353]                 open = "w")
[10:58:46.353]         }
[10:58:46.353]         else {
[10:58:46.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.353]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.353]         }
[10:58:46.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.353]             base::sink(type = "output", split = FALSE)
[10:58:46.353]             base::close(...future.stdout)
[10:58:46.353]         }, add = TRUE)
[10:58:46.353]     }
[10:58:46.353]     ...future.frame <- base::sys.nframe()
[10:58:46.353]     ...future.conditions <- base::list()
[10:58:46.353]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.353]     if (FALSE) {
[10:58:46.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.353]     }
[10:58:46.353]     ...future.result <- base::tryCatch({
[10:58:46.353]         base::withCallingHandlers({
[10:58:46.353]             ...future.value <- base::withVisible(base::local({
[10:58:46.353]                 do.call(function(...) {
[10:58:46.353]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.353]                   if (!identical(...future.globals.maxSize.org, 
[10:58:46.353]                     ...future.globals.maxSize)) {
[10:58:46.353]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.353]                     on.exit(options(oopts), add = TRUE)
[10:58:46.353]                   }
[10:58:46.353]                   {
[10:58:46.353]                     lapply(seq_along(...future.elements_ii), 
[10:58:46.353]                       FUN = function(jj) {
[10:58:46.353]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.353]                         ...future.FUN(...future.X_jj, ...)
[10:58:46.353]                       })
[10:58:46.353]                   }
[10:58:46.353]                 }, args = future.call.arguments)
[10:58:46.353]             }))
[10:58:46.353]             future::FutureResult(value = ...future.value$value, 
[10:58:46.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.353]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.353]                     ...future.globalenv.names))
[10:58:46.353]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.353]         }, condition = base::local({
[10:58:46.353]             c <- base::c
[10:58:46.353]             inherits <- base::inherits
[10:58:46.353]             invokeRestart <- base::invokeRestart
[10:58:46.353]             length <- base::length
[10:58:46.353]             list <- base::list
[10:58:46.353]             seq.int <- base::seq.int
[10:58:46.353]             signalCondition <- base::signalCondition
[10:58:46.353]             sys.calls <- base::sys.calls
[10:58:46.353]             `[[` <- base::`[[`
[10:58:46.353]             `+` <- base::`+`
[10:58:46.353]             `<<-` <- base::`<<-`
[10:58:46.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.353]                   3L)]
[10:58:46.353]             }
[10:58:46.353]             function(cond) {
[10:58:46.353]                 is_error <- inherits(cond, "error")
[10:58:46.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.353]                   NULL)
[10:58:46.353]                 if (is_error) {
[10:58:46.353]                   sessionInformation <- function() {
[10:58:46.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.353]                       search = base::search(), system = base::Sys.info())
[10:58:46.353]                   }
[10:58:46.353]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.353]                     cond$call), session = sessionInformation(), 
[10:58:46.353]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.353]                   signalCondition(cond)
[10:58:46.353]                 }
[10:58:46.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.353]                 "immediateCondition"))) {
[10:58:46.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.353]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.353]                   if (TRUE && !signal) {
[10:58:46.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.353]                     {
[10:58:46.353]                       inherits <- base::inherits
[10:58:46.353]                       invokeRestart <- base::invokeRestart
[10:58:46.353]                       is.null <- base::is.null
[10:58:46.353]                       muffled <- FALSE
[10:58:46.353]                       if (inherits(cond, "message")) {
[10:58:46.353]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.353]                         if (muffled) 
[10:58:46.353]                           invokeRestart("muffleMessage")
[10:58:46.353]                       }
[10:58:46.353]                       else if (inherits(cond, "warning")) {
[10:58:46.353]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.353]                         if (muffled) 
[10:58:46.353]                           invokeRestart("muffleWarning")
[10:58:46.353]                       }
[10:58:46.353]                       else if (inherits(cond, "condition")) {
[10:58:46.353]                         if (!is.null(pattern)) {
[10:58:46.353]                           computeRestarts <- base::computeRestarts
[10:58:46.353]                           grepl <- base::grepl
[10:58:46.353]                           restarts <- computeRestarts(cond)
[10:58:46.353]                           for (restart in restarts) {
[10:58:46.353]                             name <- restart$name
[10:58:46.353]                             if (is.null(name)) 
[10:58:46.353]                               next
[10:58:46.353]                             if (!grepl(pattern, name)) 
[10:58:46.353]                               next
[10:58:46.353]                             invokeRestart(restart)
[10:58:46.353]                             muffled <- TRUE
[10:58:46.353]                             break
[10:58:46.353]                           }
[10:58:46.353]                         }
[10:58:46.353]                       }
[10:58:46.353]                       invisible(muffled)
[10:58:46.353]                     }
[10:58:46.353]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.353]                   }
[10:58:46.353]                 }
[10:58:46.353]                 else {
[10:58:46.353]                   if (TRUE) {
[10:58:46.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.353]                     {
[10:58:46.353]                       inherits <- base::inherits
[10:58:46.353]                       invokeRestart <- base::invokeRestart
[10:58:46.353]                       is.null <- base::is.null
[10:58:46.353]                       muffled <- FALSE
[10:58:46.353]                       if (inherits(cond, "message")) {
[10:58:46.353]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.353]                         if (muffled) 
[10:58:46.353]                           invokeRestart("muffleMessage")
[10:58:46.353]                       }
[10:58:46.353]                       else if (inherits(cond, "warning")) {
[10:58:46.353]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.353]                         if (muffled) 
[10:58:46.353]                           invokeRestart("muffleWarning")
[10:58:46.353]                       }
[10:58:46.353]                       else if (inherits(cond, "condition")) {
[10:58:46.353]                         if (!is.null(pattern)) {
[10:58:46.353]                           computeRestarts <- base::computeRestarts
[10:58:46.353]                           grepl <- base::grepl
[10:58:46.353]                           restarts <- computeRestarts(cond)
[10:58:46.353]                           for (restart in restarts) {
[10:58:46.353]                             name <- restart$name
[10:58:46.353]                             if (is.null(name)) 
[10:58:46.353]                               next
[10:58:46.353]                             if (!grepl(pattern, name)) 
[10:58:46.353]                               next
[10:58:46.353]                             invokeRestart(restart)
[10:58:46.353]                             muffled <- TRUE
[10:58:46.353]                             break
[10:58:46.353]                           }
[10:58:46.353]                         }
[10:58:46.353]                       }
[10:58:46.353]                       invisible(muffled)
[10:58:46.353]                     }
[10:58:46.353]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.353]                   }
[10:58:46.353]                 }
[10:58:46.353]             }
[10:58:46.353]         }))
[10:58:46.353]     }, error = function(ex) {
[10:58:46.353]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.353]                 ...future.rng), started = ...future.startTime, 
[10:58:46.353]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.353]             version = "1.8"), class = "FutureResult")
[10:58:46.353]     }, finally = {
[10:58:46.353]         if (!identical(...future.workdir, getwd())) 
[10:58:46.353]             setwd(...future.workdir)
[10:58:46.353]         {
[10:58:46.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.353]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.353]             }
[10:58:46.353]             base::options(...future.oldOptions)
[10:58:46.353]             if (.Platform$OS.type == "windows") {
[10:58:46.353]                 old_names <- names(...future.oldEnvVars)
[10:58:46.353]                 envs <- base::Sys.getenv()
[10:58:46.353]                 names <- names(envs)
[10:58:46.353]                 common <- intersect(names, old_names)
[10:58:46.353]                 added <- setdiff(names, old_names)
[10:58:46.353]                 removed <- setdiff(old_names, names)
[10:58:46.353]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.353]                   envs[common]]
[10:58:46.353]                 NAMES <- toupper(changed)
[10:58:46.353]                 args <- list()
[10:58:46.353]                 for (kk in seq_along(NAMES)) {
[10:58:46.353]                   name <- changed[[kk]]
[10:58:46.353]                   NAME <- NAMES[[kk]]
[10:58:46.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.353]                     next
[10:58:46.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.353]                 }
[10:58:46.353]                 NAMES <- toupper(added)
[10:58:46.353]                 for (kk in seq_along(NAMES)) {
[10:58:46.353]                   name <- added[[kk]]
[10:58:46.353]                   NAME <- NAMES[[kk]]
[10:58:46.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.353]                     next
[10:58:46.353]                   args[[name]] <- ""
[10:58:46.353]                 }
[10:58:46.353]                 NAMES <- toupper(removed)
[10:58:46.353]                 for (kk in seq_along(NAMES)) {
[10:58:46.353]                   name <- removed[[kk]]
[10:58:46.353]                   NAME <- NAMES[[kk]]
[10:58:46.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.353]                     next
[10:58:46.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.353]                 }
[10:58:46.353]                 if (length(args) > 0) 
[10:58:46.353]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.353]             }
[10:58:46.353]             else {
[10:58:46.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.353]             }
[10:58:46.353]             {
[10:58:46.353]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.353]                   0L) {
[10:58:46.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.353]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.353]                   base::options(opts)
[10:58:46.353]                 }
[10:58:46.353]                 {
[10:58:46.353]                   {
[10:58:46.353]                     NULL
[10:58:46.353]                     RNGkind("Mersenne-Twister")
[10:58:46.353]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:46.353]                       inherits = FALSE)
[10:58:46.353]                   }
[10:58:46.353]                   options(future.plan = NULL)
[10:58:46.353]                   if (is.na(NA_character_)) 
[10:58:46.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.353]                     .init = FALSE)
[10:58:46.353]                 }
[10:58:46.353]             }
[10:58:46.353]         }
[10:58:46.353]     })
[10:58:46.353]     if (TRUE) {
[10:58:46.353]         base::sink(type = "output", split = FALSE)
[10:58:46.353]         if (TRUE) {
[10:58:46.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.353]         }
[10:58:46.353]         else {
[10:58:46.353]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.353]         }
[10:58:46.353]         base::close(...future.stdout)
[10:58:46.353]         ...future.stdout <- NULL
[10:58:46.353]     }
[10:58:46.353]     ...future.result$conditions <- ...future.conditions
[10:58:46.353]     ...future.result$finished <- base::Sys.time()
[10:58:46.353]     ...future.result
[10:58:46.353] }
[10:58:46.354] assign_globals() ...
[10:58:46.355] List of 5
[10:58:46.355]  $ ...future.FUN            :function (x, ...)  
[10:58:46.355]  $ future.call.arguments    : list()
[10:58:46.355]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.355]  $ ...future.elements_ii    :List of 3
[10:58:46.355]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.355]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.355]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.355]  $ ...future.seeds_ii       : NULL
[10:58:46.355]  $ ...future.globals.maxSize: NULL
[10:58:46.355]  - attr(*, "where")=List of 5
[10:58:46.355]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.355]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.355]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.355]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.355]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.355]  - attr(*, "resolved")= logi FALSE
[10:58:46.355]  - attr(*, "total_size")= num 5437
[10:58:46.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.355]  - attr(*, "already-done")= logi TRUE
[10:58:46.360] - copied ‘...future.FUN’ to environment
[10:58:46.360] - copied ‘future.call.arguments’ to environment
[10:58:46.360] - copied ‘...future.elements_ii’ to environment
[10:58:46.360] - copied ‘...future.seeds_ii’ to environment
[10:58:46.360] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.360] assign_globals() ... done
[10:58:46.360] plan(): Setting new future strategy stack:
[10:58:46.361] List of future strategies:
[10:58:46.361] 1. sequential:
[10:58:46.361]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.361]    - tweaked: FALSE
[10:58:46.361]    - call: NULL
[10:58:46.361] plan(): nbrOfWorkers() = 1
[10:58:46.362] plan(): Setting new future strategy stack:
[10:58:46.362] List of future strategies:
[10:58:46.362] 1. sequential:
[10:58:46.362]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.362]    - tweaked: FALSE
[10:58:46.362]    - call: plan(strategy)
[10:58:46.363] plan(): nbrOfWorkers() = 1
[10:58:46.363] SequentialFuture started (and completed)
[10:58:46.363] - Launch lazy future ... done
[10:58:46.363] run() for ‘SequentialFuture’ ... done
[10:58:46.363] Created future:
[10:58:46.363] SequentialFuture:
[10:58:46.363] Label: ‘future_eapply-1’
[10:58:46.363] Expression:
[10:58:46.363] {
[10:58:46.363]     do.call(function(...) {
[10:58:46.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.363]             on.exit(options(oopts), add = TRUE)
[10:58:46.363]         }
[10:58:46.363]         {
[10:58:46.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.363]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.363]             })
[10:58:46.363]         }
[10:58:46.363]     }, args = future.call.arguments)
[10:58:46.363] }
[10:58:46.363] Lazy evaluation: FALSE
[10:58:46.363] Asynchronous evaluation: FALSE
[10:58:46.363] Local evaluation: TRUE
[10:58:46.363] Environment: R_GlobalEnv
[10:58:46.363] Capture standard output: TRUE
[10:58:46.363] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.363] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 296 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.363] Packages: 1 packages (‘stats’)
[10:58:46.363] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.363] Resolved: TRUE
[10:58:46.363] Value: 413 bytes of class ‘list’
[10:58:46.363] Early signaling: FALSE
[10:58:46.363] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.363] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:46.364] Chunk #1 of 1 ... DONE
[10:58:46.364] Launching 1 futures (chunks) ... DONE
[10:58:46.364] Resolving 1 futures (chunks) ...
[10:58:46.364] resolve() on list ...
[10:58:46.364]  recursive: 0
[10:58:46.365]  length: 1
[10:58:46.365] 
[10:58:46.365] resolved() for ‘SequentialFuture’ ...
[10:58:46.365] - state: ‘finished’
[10:58:46.365] - run: TRUE
[10:58:46.365] - result: ‘FutureResult’
[10:58:46.365] resolved() for ‘SequentialFuture’ ... done
[10:58:46.365] Future #1
[10:58:46.365] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:46.365] - nx: 1
[10:58:46.366] - relay: TRUE
[10:58:46.366] - stdout: TRUE
[10:58:46.366] - signal: TRUE
[10:58:46.366] - resignal: FALSE
[10:58:46.366] - force: TRUE
[10:58:46.366] - relayed: [n=1] FALSE
[10:58:46.366] - queued futures: [n=1] FALSE
[10:58:46.366]  - until=1
[10:58:46.366]  - relaying element #1
[10:58:46.366] - relayed: [n=1] TRUE
[10:58:46.366] - queued futures: [n=1] TRUE
[10:58:46.367] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:46.367]  length: 0 (resolved future 1)
[10:58:46.367] Relaying remaining futures
[10:58:46.367] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.367] - nx: 1
[10:58:46.367] - relay: TRUE
[10:58:46.367] - stdout: TRUE
[10:58:46.367] - signal: TRUE
[10:58:46.367] - resignal: FALSE
[10:58:46.367] - force: TRUE
[10:58:46.367] - relayed: [n=1] TRUE
[10:58:46.367] - queued futures: [n=1] TRUE
 - flush all
[10:58:46.368] - relayed: [n=1] TRUE
[10:58:46.368] - queued futures: [n=1] TRUE
[10:58:46.368] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.368] resolve() on list ... DONE
[10:58:46.368]  - Number of value chunks collected: 1
[10:58:46.368] Resolving 1 futures (chunks) ... DONE
[10:58:46.368] Reducing values from 1 chunks ...
[10:58:46.368]  - Number of values collected after concatenation: 3
[10:58:46.368]  - Number of values expected: 3
[10:58:46.368] Reducing values from 1 chunks ... DONE
[10:58:46.368] future_lapply() ... DONE
[10:58:46.369] plan(): Setting new future strategy stack:
[10:58:46.369] List of future strategies:
[10:58:46.369] 1. sequential:
[10:58:46.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.369]    - tweaked: FALSE
[10:58:46.369]    - call: plan(sequential)
[10:58:46.369] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:58:46.371] plan(): Setting new future strategy stack:
[10:58:46.371] List of future strategies:
[10:58:46.371] 1. multicore:
[10:58:46.371]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.371]    - tweaked: FALSE
[10:58:46.371]    - call: plan(strategy)
[10:58:46.373] plan(): nbrOfWorkers() = 2
[10:58:46.373] future_lapply() ...
[10:58:46.375] Number of chunks: 2
[10:58:46.375] getGlobalsAndPackagesXApply() ...
[10:58:46.375]  - future.globals: TRUE
[10:58:46.375] getGlobalsAndPackages() ...
[10:58:46.376] Searching for globals...
[10:58:46.377] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.377] Searching for globals ... DONE
[10:58:46.377] Resolving globals: FALSE
[10:58:46.377] The total size of the 1 globals is 273 bytes (273 bytes)
[10:58:46.377] The total size of the 1 globals exported for future expression (‘FUN()’) is 273 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (273 bytes of class ‘function’)
[10:58:46.378] - globals: [1] ‘FUN’
[10:58:46.378] 
[10:58:46.378] getGlobalsAndPackages() ... DONE
[10:58:46.378]  - globals found/used: [n=1] ‘FUN’
[10:58:46.378]  - needed namespaces: [n=0] 
[10:58:46.378] Finding globals ... DONE
[10:58:46.378]  - use_args: TRUE
[10:58:46.378]  - Getting '...' globals ...
[10:58:46.378] resolve() on list ...
[10:58:46.379]  recursive: 0
[10:58:46.379]  length: 1
[10:58:46.379]  elements: ‘...’
[10:58:46.379]  length: 0 (resolved future 1)
[10:58:46.379] resolve() on list ... DONE
[10:58:46.379]    - '...' content: [n=0] 
[10:58:46.379] List of 1
[10:58:46.379]  $ ...: list()
[10:58:46.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.379]  - attr(*, "where")=List of 1
[10:58:46.379]   ..$ ...:<environment: 0x55f489c56a80> 
[10:58:46.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.379]  - attr(*, "resolved")= logi TRUE
[10:58:46.379]  - attr(*, "total_size")= num NA
[10:58:46.382]  - Getting '...' globals ... DONE
[10:58:46.382] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.382] List of 2
[10:58:46.382]  $ ...future.FUN:function (x, ...)  
[10:58:46.382]  $ ...          : list()
[10:58:46.382]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.382]  - attr(*, "where")=List of 2
[10:58:46.382]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.382]   ..$ ...          :<environment: 0x55f489c56a80> 
[10:58:46.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.382]  - attr(*, "resolved")= logi FALSE
[10:58:46.382]  - attr(*, "total_size")= num 5249
[10:58:46.384] Packages to be attached in all futures: [n=0] 
[10:58:46.385] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.385] Number of futures (= number of chunks): 2
[10:58:46.385] Launching 2 futures (chunks) ...
[10:58:46.385] Chunk #1 of 2 ...
[10:58:46.385]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.385] getGlobalsAndPackages() ...
[10:58:46.385] Searching for globals...
[10:58:46.386] 
[10:58:46.386] Searching for globals ... DONE
[10:58:46.386] - globals: [0] <none>
[10:58:46.386] getGlobalsAndPackages() ... DONE
[10:58:46.386]    + additional globals found: [n=0] 
[10:58:46.386]    + additional namespaces needed: [n=0] 
[10:58:46.386]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.386]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.386]  - seeds: <none>
[10:58:46.386]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.386] getGlobalsAndPackages() ...
[10:58:46.387] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.387] Resolving globals: FALSE
[10:58:46.387] Tweak future expression to call with '...' arguments ...
[10:58:46.387] {
[10:58:46.387]     do.call(function(...) {
[10:58:46.387]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.387]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.387]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.387]             on.exit(options(oopts), add = TRUE)
[10:58:46.387]         }
[10:58:46.387]         {
[10:58:46.387]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.387]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.387]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.387]             })
[10:58:46.387]         }
[10:58:46.387]     }, args = future.call.arguments)
[10:58:46.387] }
[10:58:46.387] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.387] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.388] 
[10:58:46.388] getGlobalsAndPackages() ... DONE
[10:58:46.388] run() for ‘Future’ ...
[10:58:46.388] - state: ‘created’
[10:58:46.388] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.390]   - Field: ‘label’
[10:58:46.390]   - Field: ‘local’
[10:58:46.390]   - Field: ‘owner’
[10:58:46.390]   - Field: ‘envir’
[10:58:46.391]   - Field: ‘workers’
[10:58:46.391]   - Field: ‘packages’
[10:58:46.391]   - Field: ‘gc’
[10:58:46.391]   - Field: ‘job’
[10:58:46.391]   - Field: ‘conditions’
[10:58:46.391]   - Field: ‘expr’
[10:58:46.391]   - Field: ‘uuid’
[10:58:46.391]   - Field: ‘seed’
[10:58:46.391]   - Field: ‘version’
[10:58:46.391]   - Field: ‘result’
[10:58:46.391]   - Field: ‘asynchronous’
[10:58:46.391]   - Field: ‘calls’
[10:58:46.392]   - Field: ‘globals’
[10:58:46.392]   - Field: ‘stdout’
[10:58:46.392]   - Field: ‘earlySignal’
[10:58:46.392]   - Field: ‘lazy’
[10:58:46.392]   - Field: ‘state’
[10:58:46.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.392] - Launch lazy future ...
[10:58:46.393] Packages needed by the future expression (n = 0): <none>
[10:58:46.393] Packages needed by future strategies (n = 0): <none>
[10:58:46.394] {
[10:58:46.394]     {
[10:58:46.394]         {
[10:58:46.394]             ...future.startTime <- base::Sys.time()
[10:58:46.394]             {
[10:58:46.394]                 {
[10:58:46.394]                   {
[10:58:46.394]                     {
[10:58:46.394]                       base::local({
[10:58:46.394]                         has_future <- base::requireNamespace("future", 
[10:58:46.394]                           quietly = TRUE)
[10:58:46.394]                         if (has_future) {
[10:58:46.394]                           ns <- base::getNamespace("future")
[10:58:46.394]                           version <- ns[[".package"]][["version"]]
[10:58:46.394]                           if (is.null(version)) 
[10:58:46.394]                             version <- utils::packageVersion("future")
[10:58:46.394]                         }
[10:58:46.394]                         else {
[10:58:46.394]                           version <- NULL
[10:58:46.394]                         }
[10:58:46.394]                         if (!has_future || version < "1.8.0") {
[10:58:46.394]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.394]                             "", base::R.version$version.string), 
[10:58:46.394]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:46.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:46.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.394]                               "release", "version")], collapse = " "), 
[10:58:46.394]                             hostname = base::Sys.info()[["nodename"]])
[10:58:46.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.394]                             info)
[10:58:46.394]                           info <- base::paste(info, collapse = "; ")
[10:58:46.394]                           if (!has_future) {
[10:58:46.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.394]                               info)
[10:58:46.394]                           }
[10:58:46.394]                           else {
[10:58:46.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.394]                               info, version)
[10:58:46.394]                           }
[10:58:46.394]                           base::stop(msg)
[10:58:46.394]                         }
[10:58:46.394]                       })
[10:58:46.394]                     }
[10:58:46.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.394]                     base::options(mc.cores = 1L)
[10:58:46.394]                   }
[10:58:46.394]                   ...future.strategy.old <- future::plan("list")
[10:58:46.394]                   options(future.plan = NULL)
[10:58:46.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.394]                 }
[10:58:46.394]                 ...future.workdir <- getwd()
[10:58:46.394]             }
[10:58:46.394]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.394]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.394]         }
[10:58:46.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.394]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.394]             base::names(...future.oldOptions))
[10:58:46.394]     }
[10:58:46.394]     if (FALSE) {
[10:58:46.394]     }
[10:58:46.394]     else {
[10:58:46.394]         if (TRUE) {
[10:58:46.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.394]                 open = "w")
[10:58:46.394]         }
[10:58:46.394]         else {
[10:58:46.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.394]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.394]         }
[10:58:46.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.394]             base::sink(type = "output", split = FALSE)
[10:58:46.394]             base::close(...future.stdout)
[10:58:46.394]         }, add = TRUE)
[10:58:46.394]     }
[10:58:46.394]     ...future.frame <- base::sys.nframe()
[10:58:46.394]     ...future.conditions <- base::list()
[10:58:46.394]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.394]     if (FALSE) {
[10:58:46.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.394]     }
[10:58:46.394]     ...future.result <- base::tryCatch({
[10:58:46.394]         base::withCallingHandlers({
[10:58:46.394]             ...future.value <- base::withVisible(base::local({
[10:58:46.394]                 withCallingHandlers({
[10:58:46.394]                   {
[10:58:46.394]                     do.call(function(...) {
[10:58:46.394]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.394]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.394]                         ...future.globals.maxSize)) {
[10:58:46.394]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.394]                         on.exit(options(oopts), add = TRUE)
[10:58:46.394]                       }
[10:58:46.394]                       {
[10:58:46.394]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.394]                           FUN = function(jj) {
[10:58:46.394]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.394]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.394]                           })
[10:58:46.394]                       }
[10:58:46.394]                     }, args = future.call.arguments)
[10:58:46.394]                   }
[10:58:46.394]                 }, immediateCondition = function(cond) {
[10:58:46.394]                   save_rds <- function (object, pathname, ...) 
[10:58:46.394]                   {
[10:58:46.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.394]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.394]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.394]                         fi_tmp[["mtime"]])
[10:58:46.394]                     }
[10:58:46.394]                     tryCatch({
[10:58:46.394]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.394]                     }, error = function(ex) {
[10:58:46.394]                       msg <- conditionMessage(ex)
[10:58:46.394]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.394]                         fi_tmp[["mtime"]], msg)
[10:58:46.394]                       ex$message <- msg
[10:58:46.394]                       stop(ex)
[10:58:46.394]                     })
[10:58:46.394]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.394]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.394]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.394]                       fi <- file.info(pathname)
[10:58:46.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.394]                         fi[["size"]], fi[["mtime"]])
[10:58:46.394]                       stop(msg)
[10:58:46.394]                     }
[10:58:46.394]                     invisible(pathname)
[10:58:46.394]                   }
[10:58:46.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.394]                     rootPath = tempdir()) 
[10:58:46.394]                   {
[10:58:46.394]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.394]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.394]                       tmpdir = path, fileext = ".rds")
[10:58:46.394]                     save_rds(obj, file)
[10:58:46.394]                   }
[10:58:46.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.394]                   {
[10:58:46.394]                     inherits <- base::inherits
[10:58:46.394]                     invokeRestart <- base::invokeRestart
[10:58:46.394]                     is.null <- base::is.null
[10:58:46.394]                     muffled <- FALSE
[10:58:46.394]                     if (inherits(cond, "message")) {
[10:58:46.394]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.394]                       if (muffled) 
[10:58:46.394]                         invokeRestart("muffleMessage")
[10:58:46.394]                     }
[10:58:46.394]                     else if (inherits(cond, "warning")) {
[10:58:46.394]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.394]                       if (muffled) 
[10:58:46.394]                         invokeRestart("muffleWarning")
[10:58:46.394]                     }
[10:58:46.394]                     else if (inherits(cond, "condition")) {
[10:58:46.394]                       if (!is.null(pattern)) {
[10:58:46.394]                         computeRestarts <- base::computeRestarts
[10:58:46.394]                         grepl <- base::grepl
[10:58:46.394]                         restarts <- computeRestarts(cond)
[10:58:46.394]                         for (restart in restarts) {
[10:58:46.394]                           name <- restart$name
[10:58:46.394]                           if (is.null(name)) 
[10:58:46.394]                             next
[10:58:46.394]                           if (!grepl(pattern, name)) 
[10:58:46.394]                             next
[10:58:46.394]                           invokeRestart(restart)
[10:58:46.394]                           muffled <- TRUE
[10:58:46.394]                           break
[10:58:46.394]                         }
[10:58:46.394]                       }
[10:58:46.394]                     }
[10:58:46.394]                     invisible(muffled)
[10:58:46.394]                   }
[10:58:46.394]                   muffleCondition(cond)
[10:58:46.394]                 })
[10:58:46.394]             }))
[10:58:46.394]             future::FutureResult(value = ...future.value$value, 
[10:58:46.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.394]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.394]                     ...future.globalenv.names))
[10:58:46.394]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.394]         }, condition = base::local({
[10:58:46.394]             c <- base::c
[10:58:46.394]             inherits <- base::inherits
[10:58:46.394]             invokeRestart <- base::invokeRestart
[10:58:46.394]             length <- base::length
[10:58:46.394]             list <- base::list
[10:58:46.394]             seq.int <- base::seq.int
[10:58:46.394]             signalCondition <- base::signalCondition
[10:58:46.394]             sys.calls <- base::sys.calls
[10:58:46.394]             `[[` <- base::`[[`
[10:58:46.394]             `+` <- base::`+`
[10:58:46.394]             `<<-` <- base::`<<-`
[10:58:46.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.394]                   3L)]
[10:58:46.394]             }
[10:58:46.394]             function(cond) {
[10:58:46.394]                 is_error <- inherits(cond, "error")
[10:58:46.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.394]                   NULL)
[10:58:46.394]                 if (is_error) {
[10:58:46.394]                   sessionInformation <- function() {
[10:58:46.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.394]                       search = base::search(), system = base::Sys.info())
[10:58:46.394]                   }
[10:58:46.394]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.394]                     cond$call), session = sessionInformation(), 
[10:58:46.394]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.394]                   signalCondition(cond)
[10:58:46.394]                 }
[10:58:46.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.394]                 "immediateCondition"))) {
[10:58:46.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.394]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.394]                   if (TRUE && !signal) {
[10:58:46.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.394]                     {
[10:58:46.394]                       inherits <- base::inherits
[10:58:46.394]                       invokeRestart <- base::invokeRestart
[10:58:46.394]                       is.null <- base::is.null
[10:58:46.394]                       muffled <- FALSE
[10:58:46.394]                       if (inherits(cond, "message")) {
[10:58:46.394]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.394]                         if (muffled) 
[10:58:46.394]                           invokeRestart("muffleMessage")
[10:58:46.394]                       }
[10:58:46.394]                       else if (inherits(cond, "warning")) {
[10:58:46.394]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.394]                         if (muffled) 
[10:58:46.394]                           invokeRestart("muffleWarning")
[10:58:46.394]                       }
[10:58:46.394]                       else if (inherits(cond, "condition")) {
[10:58:46.394]                         if (!is.null(pattern)) {
[10:58:46.394]                           computeRestarts <- base::computeRestarts
[10:58:46.394]                           grepl <- base::grepl
[10:58:46.394]                           restarts <- computeRestarts(cond)
[10:58:46.394]                           for (restart in restarts) {
[10:58:46.394]                             name <- restart$name
[10:58:46.394]                             if (is.null(name)) 
[10:58:46.394]                               next
[10:58:46.394]                             if (!grepl(pattern, name)) 
[10:58:46.394]                               next
[10:58:46.394]                             invokeRestart(restart)
[10:58:46.394]                             muffled <- TRUE
[10:58:46.394]                             break
[10:58:46.394]                           }
[10:58:46.394]                         }
[10:58:46.394]                       }
[10:58:46.394]                       invisible(muffled)
[10:58:46.394]                     }
[10:58:46.394]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.394]                   }
[10:58:46.394]                 }
[10:58:46.394]                 else {
[10:58:46.394]                   if (TRUE) {
[10:58:46.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.394]                     {
[10:58:46.394]                       inherits <- base::inherits
[10:58:46.394]                       invokeRestart <- base::invokeRestart
[10:58:46.394]                       is.null <- base::is.null
[10:58:46.394]                       muffled <- FALSE
[10:58:46.394]                       if (inherits(cond, "message")) {
[10:58:46.394]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.394]                         if (muffled) 
[10:58:46.394]                           invokeRestart("muffleMessage")
[10:58:46.394]                       }
[10:58:46.394]                       else if (inherits(cond, "warning")) {
[10:58:46.394]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.394]                         if (muffled) 
[10:58:46.394]                           invokeRestart("muffleWarning")
[10:58:46.394]                       }
[10:58:46.394]                       else if (inherits(cond, "condition")) {
[10:58:46.394]                         if (!is.null(pattern)) {
[10:58:46.394]                           computeRestarts <- base::computeRestarts
[10:58:46.394]                           grepl <- base::grepl
[10:58:46.394]                           restarts <- computeRestarts(cond)
[10:58:46.394]                           for (restart in restarts) {
[10:58:46.394]                             name <- restart$name
[10:58:46.394]                             if (is.null(name)) 
[10:58:46.394]                               next
[10:58:46.394]                             if (!grepl(pattern, name)) 
[10:58:46.394]                               next
[10:58:46.394]                             invokeRestart(restart)
[10:58:46.394]                             muffled <- TRUE
[10:58:46.394]                             break
[10:58:46.394]                           }
[10:58:46.394]                         }
[10:58:46.394]                       }
[10:58:46.394]                       invisible(muffled)
[10:58:46.394]                     }
[10:58:46.394]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.394]                   }
[10:58:46.394]                 }
[10:58:46.394]             }
[10:58:46.394]         }))
[10:58:46.394]     }, error = function(ex) {
[10:58:46.394]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.394]                 ...future.rng), started = ...future.startTime, 
[10:58:46.394]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.394]             version = "1.8"), class = "FutureResult")
[10:58:46.394]     }, finally = {
[10:58:46.394]         if (!identical(...future.workdir, getwd())) 
[10:58:46.394]             setwd(...future.workdir)
[10:58:46.394]         {
[10:58:46.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.394]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.394]             }
[10:58:46.394]             base::options(...future.oldOptions)
[10:58:46.394]             if (.Platform$OS.type == "windows") {
[10:58:46.394]                 old_names <- names(...future.oldEnvVars)
[10:58:46.394]                 envs <- base::Sys.getenv()
[10:58:46.394]                 names <- names(envs)
[10:58:46.394]                 common <- intersect(names, old_names)
[10:58:46.394]                 added <- setdiff(names, old_names)
[10:58:46.394]                 removed <- setdiff(old_names, names)
[10:58:46.394]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.394]                   envs[common]]
[10:58:46.394]                 NAMES <- toupper(changed)
[10:58:46.394]                 args <- list()
[10:58:46.394]                 for (kk in seq_along(NAMES)) {
[10:58:46.394]                   name <- changed[[kk]]
[10:58:46.394]                   NAME <- NAMES[[kk]]
[10:58:46.394]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.394]                     next
[10:58:46.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.394]                 }
[10:58:46.394]                 NAMES <- toupper(added)
[10:58:46.394]                 for (kk in seq_along(NAMES)) {
[10:58:46.394]                   name <- added[[kk]]
[10:58:46.394]                   NAME <- NAMES[[kk]]
[10:58:46.394]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.394]                     next
[10:58:46.394]                   args[[name]] <- ""
[10:58:46.394]                 }
[10:58:46.394]                 NAMES <- toupper(removed)
[10:58:46.394]                 for (kk in seq_along(NAMES)) {
[10:58:46.394]                   name <- removed[[kk]]
[10:58:46.394]                   NAME <- NAMES[[kk]]
[10:58:46.394]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.394]                     next
[10:58:46.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.394]                 }
[10:58:46.394]                 if (length(args) > 0) 
[10:58:46.394]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.394]             }
[10:58:46.394]             else {
[10:58:46.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.394]             }
[10:58:46.394]             {
[10:58:46.394]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.394]                   0L) {
[10:58:46.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.394]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.394]                   base::options(opts)
[10:58:46.394]                 }
[10:58:46.394]                 {
[10:58:46.394]                   {
[10:58:46.394]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.394]                     NULL
[10:58:46.394]                   }
[10:58:46.394]                   options(future.plan = NULL)
[10:58:46.394]                   if (is.na(NA_character_)) 
[10:58:46.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.394]                     .init = FALSE)
[10:58:46.394]                 }
[10:58:46.394]             }
[10:58:46.394]         }
[10:58:46.394]     })
[10:58:46.394]     if (TRUE) {
[10:58:46.394]         base::sink(type = "output", split = FALSE)
[10:58:46.394]         if (TRUE) {
[10:58:46.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.394]         }
[10:58:46.394]         else {
[10:58:46.394]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.394]         }
[10:58:46.394]         base::close(...future.stdout)
[10:58:46.394]         ...future.stdout <- NULL
[10:58:46.394]     }
[10:58:46.394]     ...future.result$conditions <- ...future.conditions
[10:58:46.394]     ...future.result$finished <- base::Sys.time()
[10:58:46.394]     ...future.result
[10:58:46.394] }
[10:58:46.396] assign_globals() ...
[10:58:46.396] List of 5
[10:58:46.396]  $ ...future.FUN            :function (x, ...)  
[10:58:46.396]  $ future.call.arguments    : list()
[10:58:46.396]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.396]  $ ...future.elements_ii    :List of 1
[10:58:46.396]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.396]  $ ...future.seeds_ii       : NULL
[10:58:46.396]  $ ...future.globals.maxSize: NULL
[10:58:46.396]  - attr(*, "where")=List of 5
[10:58:46.396]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.396]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.396]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.396]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.396]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.396]  - attr(*, "resolved")= logi FALSE
[10:58:46.396]  - attr(*, "total_size")= num 5249
[10:58:46.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.396]  - attr(*, "already-done")= logi TRUE
[10:58:46.403] - copied ‘...future.FUN’ to environment
[10:58:46.403] - copied ‘future.call.arguments’ to environment
[10:58:46.403] - copied ‘...future.elements_ii’ to environment
[10:58:46.403] - copied ‘...future.seeds_ii’ to environment
[10:58:46.403] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.403] assign_globals() ... done
[10:58:46.403] requestCore(): workers = 2
[10:58:46.407] MulticoreFuture started
[10:58:46.407] - Launch lazy future ... done
[10:58:46.407] plan(): Setting new future strategy stack:
[10:58:46.407] run() for ‘MulticoreFuture’ ... done
[10:58:46.408] Created future:
[10:58:46.407] List of future strategies:
[10:58:46.407] 1. sequential:
[10:58:46.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.407]    - tweaked: FALSE
[10:58:46.407]    - call: NULL
[10:58:46.409] plan(): nbrOfWorkers() = 1
[10:58:46.411] plan(): Setting new future strategy stack:
[10:58:46.411] List of future strategies:
[10:58:46.411] 1. multicore:
[10:58:46.411]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.411]    - tweaked: FALSE
[10:58:46.411]    - call: plan(strategy)
[10:58:46.414] plan(): nbrOfWorkers() = 2
[10:58:46.408] MulticoreFuture:
[10:58:46.408] Label: ‘future_eapply-1’
[10:58:46.408] Expression:
[10:58:46.408] {
[10:58:46.408]     do.call(function(...) {
[10:58:46.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.408]             on.exit(options(oopts), add = TRUE)
[10:58:46.408]         }
[10:58:46.408]         {
[10:58:46.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.408]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.408]             })
[10:58:46.408]         }
[10:58:46.408]     }, args = future.call.arguments)
[10:58:46.408] }
[10:58:46.408] Lazy evaluation: FALSE
[10:58:46.408] Asynchronous evaluation: TRUE
[10:58:46.408] Local evaluation: TRUE
[10:58:46.408] Environment: R_GlobalEnv
[10:58:46.408] Capture standard output: TRUE
[10:58:46.408] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.408] Globals: 5 objects totaling 479 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.408] Packages: <none>
[10:58:46.408] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.408] Resolved: TRUE
[10:58:46.408] Value: <not collected>
[10:58:46.408] Conditions captured: <none>
[10:58:46.408] Early signaling: FALSE
[10:58:46.408] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.408] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.415] Chunk #1 of 2 ... DONE
[10:58:46.416] Chunk #2 of 2 ...
[10:58:46.416]  - Finding globals in 'X' for chunk #2 ...
[10:58:46.416] getGlobalsAndPackages() ...
[10:58:46.416] Searching for globals...
[10:58:46.417] 
[10:58:46.417] Searching for globals ... DONE
[10:58:46.417] - globals: [0] <none>
[10:58:46.417] getGlobalsAndPackages() ... DONE
[10:58:46.417]    + additional globals found: [n=0] 
[10:58:46.417]    + additional namespaces needed: [n=0] 
[10:58:46.417]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:46.417]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.418]  - seeds: <none>
[10:58:46.418]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.418] getGlobalsAndPackages() ...
[10:58:46.418] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.418] Resolving globals: FALSE
[10:58:46.418] Tweak future expression to call with '...' arguments ...
[10:58:46.419] {
[10:58:46.419]     do.call(function(...) {
[10:58:46.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.419]             on.exit(options(oopts), add = TRUE)
[10:58:46.419]         }
[10:58:46.419]         {
[10:58:46.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.419]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.419]             })
[10:58:46.419]         }
[10:58:46.419]     }, args = future.call.arguments)
[10:58:46.419] }
[10:58:46.419] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.420] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.420] 
[10:58:46.420] getGlobalsAndPackages() ... DONE
[10:58:46.420] run() for ‘Future’ ...
[10:58:46.421] - state: ‘created’
[10:58:46.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.423] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.424]   - Field: ‘label’
[10:58:46.424]   - Field: ‘local’
[10:58:46.424]   - Field: ‘owner’
[10:58:46.424]   - Field: ‘envir’
[10:58:46.424]   - Field: ‘workers’
[10:58:46.424]   - Field: ‘packages’
[10:58:46.425]   - Field: ‘gc’
[10:58:46.425]   - Field: ‘job’
[10:58:46.425]   - Field: ‘conditions’
[10:58:46.425]   - Field: ‘expr’
[10:58:46.425]   - Field: ‘uuid’
[10:58:46.425]   - Field: ‘seed’
[10:58:46.425]   - Field: ‘version’
[10:58:46.426]   - Field: ‘result’
[10:58:46.426]   - Field: ‘asynchronous’
[10:58:46.426]   - Field: ‘calls’
[10:58:46.426]   - Field: ‘globals’
[10:58:46.426]   - Field: ‘stdout’
[10:58:46.426]   - Field: ‘earlySignal’
[10:58:46.426]   - Field: ‘lazy’
[10:58:46.426]   - Field: ‘state’
[10:58:46.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.427] - Launch lazy future ...
[10:58:46.427] Packages needed by the future expression (n = 0): <none>
[10:58:46.427] Packages needed by future strategies (n = 0): <none>
[10:58:46.428] {
[10:58:46.428]     {
[10:58:46.428]         {
[10:58:46.428]             ...future.startTime <- base::Sys.time()
[10:58:46.428]             {
[10:58:46.428]                 {
[10:58:46.428]                   {
[10:58:46.428]                     {
[10:58:46.428]                       base::local({
[10:58:46.428]                         has_future <- base::requireNamespace("future", 
[10:58:46.428]                           quietly = TRUE)
[10:58:46.428]                         if (has_future) {
[10:58:46.428]                           ns <- base::getNamespace("future")
[10:58:46.428]                           version <- ns[[".package"]][["version"]]
[10:58:46.428]                           if (is.null(version)) 
[10:58:46.428]                             version <- utils::packageVersion("future")
[10:58:46.428]                         }
[10:58:46.428]                         else {
[10:58:46.428]                           version <- NULL
[10:58:46.428]                         }
[10:58:46.428]                         if (!has_future || version < "1.8.0") {
[10:58:46.428]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.428]                             "", base::R.version$version.string), 
[10:58:46.428]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:46.428]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:46.428]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.428]                               "release", "version")], collapse = " "), 
[10:58:46.428]                             hostname = base::Sys.info()[["nodename"]])
[10:58:46.428]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.428]                             info)
[10:58:46.428]                           info <- base::paste(info, collapse = "; ")
[10:58:46.428]                           if (!has_future) {
[10:58:46.428]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.428]                               info)
[10:58:46.428]                           }
[10:58:46.428]                           else {
[10:58:46.428]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.428]                               info, version)
[10:58:46.428]                           }
[10:58:46.428]                           base::stop(msg)
[10:58:46.428]                         }
[10:58:46.428]                       })
[10:58:46.428]                     }
[10:58:46.428]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.428]                     base::options(mc.cores = 1L)
[10:58:46.428]                   }
[10:58:46.428]                   ...future.strategy.old <- future::plan("list")
[10:58:46.428]                   options(future.plan = NULL)
[10:58:46.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.428]                 }
[10:58:46.428]                 ...future.workdir <- getwd()
[10:58:46.428]             }
[10:58:46.428]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.428]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.428]         }
[10:58:46.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.428]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.428]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.428]             base::names(...future.oldOptions))
[10:58:46.428]     }
[10:58:46.428]     if (FALSE) {
[10:58:46.428]     }
[10:58:46.428]     else {
[10:58:46.428]         if (TRUE) {
[10:58:46.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.428]                 open = "w")
[10:58:46.428]         }
[10:58:46.428]         else {
[10:58:46.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.428]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.428]         }
[10:58:46.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.428]             base::sink(type = "output", split = FALSE)
[10:58:46.428]             base::close(...future.stdout)
[10:58:46.428]         }, add = TRUE)
[10:58:46.428]     }
[10:58:46.428]     ...future.frame <- base::sys.nframe()
[10:58:46.428]     ...future.conditions <- base::list()
[10:58:46.428]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.428]     if (FALSE) {
[10:58:46.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.428]     }
[10:58:46.428]     ...future.result <- base::tryCatch({
[10:58:46.428]         base::withCallingHandlers({
[10:58:46.428]             ...future.value <- base::withVisible(base::local({
[10:58:46.428]                 withCallingHandlers({
[10:58:46.428]                   {
[10:58:46.428]                     do.call(function(...) {
[10:58:46.428]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.428]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.428]                         ...future.globals.maxSize)) {
[10:58:46.428]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.428]                         on.exit(options(oopts), add = TRUE)
[10:58:46.428]                       }
[10:58:46.428]                       {
[10:58:46.428]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.428]                           FUN = function(jj) {
[10:58:46.428]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.428]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.428]                           })
[10:58:46.428]                       }
[10:58:46.428]                     }, args = future.call.arguments)
[10:58:46.428]                   }
[10:58:46.428]                 }, immediateCondition = function(cond) {
[10:58:46.428]                   save_rds <- function (object, pathname, ...) 
[10:58:46.428]                   {
[10:58:46.428]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.428]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.428]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.428]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.428]                         fi_tmp[["mtime"]])
[10:58:46.428]                     }
[10:58:46.428]                     tryCatch({
[10:58:46.428]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.428]                     }, error = function(ex) {
[10:58:46.428]                       msg <- conditionMessage(ex)
[10:58:46.428]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.428]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.428]                         fi_tmp[["mtime"]], msg)
[10:58:46.428]                       ex$message <- msg
[10:58:46.428]                       stop(ex)
[10:58:46.428]                     })
[10:58:46.428]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.428]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.428]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.428]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.428]                       fi <- file.info(pathname)
[10:58:46.428]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.428]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.428]                         fi[["size"]], fi[["mtime"]])
[10:58:46.428]                       stop(msg)
[10:58:46.428]                     }
[10:58:46.428]                     invisible(pathname)
[10:58:46.428]                   }
[10:58:46.428]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.428]                     rootPath = tempdir()) 
[10:58:46.428]                   {
[10:58:46.428]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.428]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.428]                       tmpdir = path, fileext = ".rds")
[10:58:46.428]                     save_rds(obj, file)
[10:58:46.428]                   }
[10:58:46.428]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.428]                   {
[10:58:46.428]                     inherits <- base::inherits
[10:58:46.428]                     invokeRestart <- base::invokeRestart
[10:58:46.428]                     is.null <- base::is.null
[10:58:46.428]                     muffled <- FALSE
[10:58:46.428]                     if (inherits(cond, "message")) {
[10:58:46.428]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.428]                       if (muffled) 
[10:58:46.428]                         invokeRestart("muffleMessage")
[10:58:46.428]                     }
[10:58:46.428]                     else if (inherits(cond, "warning")) {
[10:58:46.428]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.428]                       if (muffled) 
[10:58:46.428]                         invokeRestart("muffleWarning")
[10:58:46.428]                     }
[10:58:46.428]                     else if (inherits(cond, "condition")) {
[10:58:46.428]                       if (!is.null(pattern)) {
[10:58:46.428]                         computeRestarts <- base::computeRestarts
[10:58:46.428]                         grepl <- base::grepl
[10:58:46.428]                         restarts <- computeRestarts(cond)
[10:58:46.428]                         for (restart in restarts) {
[10:58:46.428]                           name <- restart$name
[10:58:46.428]                           if (is.null(name)) 
[10:58:46.428]                             next
[10:58:46.428]                           if (!grepl(pattern, name)) 
[10:58:46.428]                             next
[10:58:46.428]                           invokeRestart(restart)
[10:58:46.428]                           muffled <- TRUE
[10:58:46.428]                           break
[10:58:46.428]                         }
[10:58:46.428]                       }
[10:58:46.428]                     }
[10:58:46.428]                     invisible(muffled)
[10:58:46.428]                   }
[10:58:46.428]                   muffleCondition(cond)
[10:58:46.428]                 })
[10:58:46.428]             }))
[10:58:46.428]             future::FutureResult(value = ...future.value$value, 
[10:58:46.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.428]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.428]                     ...future.globalenv.names))
[10:58:46.428]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.428]         }, condition = base::local({
[10:58:46.428]             c <- base::c
[10:58:46.428]             inherits <- base::inherits
[10:58:46.428]             invokeRestart <- base::invokeRestart
[10:58:46.428]             length <- base::length
[10:58:46.428]             list <- base::list
[10:58:46.428]             seq.int <- base::seq.int
[10:58:46.428]             signalCondition <- base::signalCondition
[10:58:46.428]             sys.calls <- base::sys.calls
[10:58:46.428]             `[[` <- base::`[[`
[10:58:46.428]             `+` <- base::`+`
[10:58:46.428]             `<<-` <- base::`<<-`
[10:58:46.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.428]                   3L)]
[10:58:46.428]             }
[10:58:46.428]             function(cond) {
[10:58:46.428]                 is_error <- inherits(cond, "error")
[10:58:46.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.428]                   NULL)
[10:58:46.428]                 if (is_error) {
[10:58:46.428]                   sessionInformation <- function() {
[10:58:46.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.428]                       search = base::search(), system = base::Sys.info())
[10:58:46.428]                   }
[10:58:46.428]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.428]                     cond$call), session = sessionInformation(), 
[10:58:46.428]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.428]                   signalCondition(cond)
[10:58:46.428]                 }
[10:58:46.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.428]                 "immediateCondition"))) {
[10:58:46.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.428]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.428]                   if (TRUE && !signal) {
[10:58:46.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.428]                     {
[10:58:46.428]                       inherits <- base::inherits
[10:58:46.428]                       invokeRestart <- base::invokeRestart
[10:58:46.428]                       is.null <- base::is.null
[10:58:46.428]                       muffled <- FALSE
[10:58:46.428]                       if (inherits(cond, "message")) {
[10:58:46.428]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.428]                         if (muffled) 
[10:58:46.428]                           invokeRestart("muffleMessage")
[10:58:46.428]                       }
[10:58:46.428]                       else if (inherits(cond, "warning")) {
[10:58:46.428]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.428]                         if (muffled) 
[10:58:46.428]                           invokeRestart("muffleWarning")
[10:58:46.428]                       }
[10:58:46.428]                       else if (inherits(cond, "condition")) {
[10:58:46.428]                         if (!is.null(pattern)) {
[10:58:46.428]                           computeRestarts <- base::computeRestarts
[10:58:46.428]                           grepl <- base::grepl
[10:58:46.428]                           restarts <- computeRestarts(cond)
[10:58:46.428]                           for (restart in restarts) {
[10:58:46.428]                             name <- restart$name
[10:58:46.428]                             if (is.null(name)) 
[10:58:46.428]                               next
[10:58:46.428]                             if (!grepl(pattern, name)) 
[10:58:46.428]                               next
[10:58:46.428]                             invokeRestart(restart)
[10:58:46.428]                             muffled <- TRUE
[10:58:46.428]                             break
[10:58:46.428]                           }
[10:58:46.428]                         }
[10:58:46.428]                       }
[10:58:46.428]                       invisible(muffled)
[10:58:46.428]                     }
[10:58:46.428]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.428]                   }
[10:58:46.428]                 }
[10:58:46.428]                 else {
[10:58:46.428]                   if (TRUE) {
[10:58:46.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.428]                     {
[10:58:46.428]                       inherits <- base::inherits
[10:58:46.428]                       invokeRestart <- base::invokeRestart
[10:58:46.428]                       is.null <- base::is.null
[10:58:46.428]                       muffled <- FALSE
[10:58:46.428]                       if (inherits(cond, "message")) {
[10:58:46.428]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.428]                         if (muffled) 
[10:58:46.428]                           invokeRestart("muffleMessage")
[10:58:46.428]                       }
[10:58:46.428]                       else if (inherits(cond, "warning")) {
[10:58:46.428]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.428]                         if (muffled) 
[10:58:46.428]                           invokeRestart("muffleWarning")
[10:58:46.428]                       }
[10:58:46.428]                       else if (inherits(cond, "condition")) {
[10:58:46.428]                         if (!is.null(pattern)) {
[10:58:46.428]                           computeRestarts <- base::computeRestarts
[10:58:46.428]                           grepl <- base::grepl
[10:58:46.428]                           restarts <- computeRestarts(cond)
[10:58:46.428]                           for (restart in restarts) {
[10:58:46.428]                             name <- restart$name
[10:58:46.428]                             if (is.null(name)) 
[10:58:46.428]                               next
[10:58:46.428]                             if (!grepl(pattern, name)) 
[10:58:46.428]                               next
[10:58:46.428]                             invokeRestart(restart)
[10:58:46.428]                             muffled <- TRUE
[10:58:46.428]                             break
[10:58:46.428]                           }
[10:58:46.428]                         }
[10:58:46.428]                       }
[10:58:46.428]                       invisible(muffled)
[10:58:46.428]                     }
[10:58:46.428]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.428]                   }
[10:58:46.428]                 }
[10:58:46.428]             }
[10:58:46.428]         }))
[10:58:46.428]     }, error = function(ex) {
[10:58:46.428]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.428]                 ...future.rng), started = ...future.startTime, 
[10:58:46.428]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.428]             version = "1.8"), class = "FutureResult")
[10:58:46.428]     }, finally = {
[10:58:46.428]         if (!identical(...future.workdir, getwd())) 
[10:58:46.428]             setwd(...future.workdir)
[10:58:46.428]         {
[10:58:46.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.428]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.428]             }
[10:58:46.428]             base::options(...future.oldOptions)
[10:58:46.428]             if (.Platform$OS.type == "windows") {
[10:58:46.428]                 old_names <- names(...future.oldEnvVars)
[10:58:46.428]                 envs <- base::Sys.getenv()
[10:58:46.428]                 names <- names(envs)
[10:58:46.428]                 common <- intersect(names, old_names)
[10:58:46.428]                 added <- setdiff(names, old_names)
[10:58:46.428]                 removed <- setdiff(old_names, names)
[10:58:46.428]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.428]                   envs[common]]
[10:58:46.428]                 NAMES <- toupper(changed)
[10:58:46.428]                 args <- list()
[10:58:46.428]                 for (kk in seq_along(NAMES)) {
[10:58:46.428]                   name <- changed[[kk]]
[10:58:46.428]                   NAME <- NAMES[[kk]]
[10:58:46.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.428]                     next
[10:58:46.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.428]                 }
[10:58:46.428]                 NAMES <- toupper(added)
[10:58:46.428]                 for (kk in seq_along(NAMES)) {
[10:58:46.428]                   name <- added[[kk]]
[10:58:46.428]                   NAME <- NAMES[[kk]]
[10:58:46.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.428]                     next
[10:58:46.428]                   args[[name]] <- ""
[10:58:46.428]                 }
[10:58:46.428]                 NAMES <- toupper(removed)
[10:58:46.428]                 for (kk in seq_along(NAMES)) {
[10:58:46.428]                   name <- removed[[kk]]
[10:58:46.428]                   NAME <- NAMES[[kk]]
[10:58:46.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.428]                     next
[10:58:46.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.428]                 }
[10:58:46.428]                 if (length(args) > 0) 
[10:58:46.428]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.428]             }
[10:58:46.428]             else {
[10:58:46.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.428]             }
[10:58:46.428]             {
[10:58:46.428]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.428]                   0L) {
[10:58:46.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.428]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.428]                   base::options(opts)
[10:58:46.428]                 }
[10:58:46.428]                 {
[10:58:46.428]                   {
[10:58:46.428]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.428]                     NULL
[10:58:46.428]                   }
[10:58:46.428]                   options(future.plan = NULL)
[10:58:46.428]                   if (is.na(NA_character_)) 
[10:58:46.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.428]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.428]                     .init = FALSE)
[10:58:46.428]                 }
[10:58:46.428]             }
[10:58:46.428]         }
[10:58:46.428]     })
[10:58:46.428]     if (TRUE) {
[10:58:46.428]         base::sink(type = "output", split = FALSE)
[10:58:46.428]         if (TRUE) {
[10:58:46.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.428]         }
[10:58:46.428]         else {
[10:58:46.428]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.428]         }
[10:58:46.428]         base::close(...future.stdout)
[10:58:46.428]         ...future.stdout <- NULL
[10:58:46.428]     }
[10:58:46.428]     ...future.result$conditions <- ...future.conditions
[10:58:46.428]     ...future.result$finished <- base::Sys.time()
[10:58:46.428]     ...future.result
[10:58:46.428] }
[10:58:46.431] assign_globals() ...
[10:58:46.432] List of 5
[10:58:46.432]  $ ...future.FUN            :function (x, ...)  
[10:58:46.432]  $ future.call.arguments    : list()
[10:58:46.432]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.432]  $ ...future.elements_ii    :List of 2
[10:58:46.432]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.432]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.432]  $ ...future.seeds_ii       : NULL
[10:58:46.432]  $ ...future.globals.maxSize: NULL
[10:58:46.432]  - attr(*, "where")=List of 5
[10:58:46.432]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.432]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.432]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.432]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.432]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.432]  - attr(*, "resolved")= logi FALSE
[10:58:46.432]  - attr(*, "total_size")= num 5249
[10:58:46.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.432]  - attr(*, "already-done")= logi TRUE
[10:58:46.439] - copied ‘...future.FUN’ to environment
[10:58:46.439] - copied ‘future.call.arguments’ to environment
[10:58:46.439] - copied ‘...future.elements_ii’ to environment
[10:58:46.439] - copied ‘...future.seeds_ii’ to environment
[10:58:46.439] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.439] assign_globals() ... done
[10:58:46.439] requestCore(): workers = 2
[10:58:46.448] MulticoreFuture started
[10:58:46.448] - Launch lazy future ... done
[10:58:46.448] run() for ‘MulticoreFuture’ ... done
[10:58:46.449] Created future:
[10:58:46.449] plan(): Setting new future strategy stack:
[10:58:46.449] List of future strategies:
[10:58:46.449] 1. sequential:
[10:58:46.449]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.449]    - tweaked: FALSE
[10:58:46.449]    - call: NULL
[10:58:46.450] plan(): nbrOfWorkers() = 1
[10:58:46.452] plan(): Setting new future strategy stack:
[10:58:46.453] List of future strategies:
[10:58:46.453] 1. multicore:
[10:58:46.453]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.453]    - tweaked: FALSE
[10:58:46.453]    - call: plan(strategy)
[10:58:46.456] plan(): nbrOfWorkers() = 2
[10:58:46.449] MulticoreFuture:
[10:58:46.449] Label: ‘future_eapply-2’
[10:58:46.449] Expression:
[10:58:46.449] {
[10:58:46.449]     do.call(function(...) {
[10:58:46.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.449]             on.exit(options(oopts), add = TRUE)
[10:58:46.449]         }
[10:58:46.449]         {
[10:58:46.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.449]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.449]             })
[10:58:46.449]         }
[10:58:46.449]     }, args = future.call.arguments)
[10:58:46.449] }
[10:58:46.449] Lazy evaluation: FALSE
[10:58:46.449] Asynchronous evaluation: TRUE
[10:58:46.449] Local evaluation: TRUE
[10:58:46.449] Environment: R_GlobalEnv
[10:58:46.449] Capture standard output: TRUE
[10:58:46.449] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.449] Globals: 5 objects totaling 629 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 205 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.449] Packages: <none>
[10:58:46.449] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.449] Resolved: TRUE
[10:58:46.449] Value: <not collected>
[10:58:46.449] Conditions captured: <none>
[10:58:46.449] Early signaling: FALSE
[10:58:46.449] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.449] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.457] Chunk #2 of 2 ... DONE
[10:58:46.457] Launching 2 futures (chunks) ... DONE
[10:58:46.458] Resolving 2 futures (chunks) ...
[10:58:46.458] resolve() on list ...
[10:58:46.458]  recursive: 0
[10:58:46.458]  length: 2
[10:58:46.458] 
[10:58:46.459] Future #1
[10:58:46.459] result() for MulticoreFuture ...
[10:58:46.461] result() for MulticoreFuture ...
[10:58:46.461] result() for MulticoreFuture ... done
[10:58:46.462] result() for MulticoreFuture ... done
[10:58:46.462] result() for MulticoreFuture ...
[10:58:46.462] result() for MulticoreFuture ... done
[10:58:46.462] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:46.462] - nx: 2
[10:58:46.462] - relay: TRUE
[10:58:46.462] - stdout: TRUE
[10:58:46.463] - signal: TRUE
[10:58:46.463] - resignal: FALSE
[10:58:46.463] - force: TRUE
[10:58:46.463] - relayed: [n=2] FALSE, FALSE
[10:58:46.463] - queued futures: [n=2] FALSE, FALSE
[10:58:46.463]  - until=1
[10:58:46.463]  - relaying element #1
[10:58:46.464] result() for MulticoreFuture ...
[10:58:46.464] result() for MulticoreFuture ... done
[10:58:46.464] result() for MulticoreFuture ...
[10:58:46.464] result() for MulticoreFuture ... done
[10:58:46.464] result() for MulticoreFuture ...
[10:58:46.464] result() for MulticoreFuture ... done
[10:58:46.465] result() for MulticoreFuture ...
[10:58:46.465] result() for MulticoreFuture ... done
[10:58:46.465] - relayed: [n=2] TRUE, FALSE
[10:58:46.465] - queued futures: [n=2] TRUE, FALSE
[10:58:46.465] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:46.465]  length: 1 (resolved future 1)
[10:58:46.466] Future #2
[10:58:46.466] result() for MulticoreFuture ...
[10:58:46.466] result() for MulticoreFuture ...
[10:58:46.467] result() for MulticoreFuture ... done
[10:58:46.467] result() for MulticoreFuture ... done
[10:58:46.467] result() for MulticoreFuture ...
[10:58:46.467] result() for MulticoreFuture ... done
[10:58:46.467] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:46.467] - nx: 2
[10:58:46.467] - relay: TRUE
[10:58:46.467] - stdout: TRUE
[10:58:46.468] - signal: TRUE
[10:58:46.468] - resignal: FALSE
[10:58:46.468] - force: TRUE
[10:58:46.468] - relayed: [n=2] TRUE, FALSE
[10:58:46.468] - queued futures: [n=2] TRUE, FALSE
[10:58:46.468]  - until=2
[10:58:46.468]  - relaying element #2
[10:58:46.468] result() for MulticoreFuture ...
[10:58:46.468] result() for MulticoreFuture ... done
[10:58:46.469] result() for MulticoreFuture ...
[10:58:46.469] result() for MulticoreFuture ... done
[10:58:46.469] result() for MulticoreFuture ...
[10:58:46.469] result() for MulticoreFuture ... done
[10:58:46.469] result() for MulticoreFuture ...
[10:58:46.469] result() for MulticoreFuture ... done
[10:58:46.469] - relayed: [n=2] TRUE, TRUE
[10:58:46.469] - queued futures: [n=2] TRUE, TRUE
[10:58:46.470] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:46.470]  length: 0 (resolved future 2)
[10:58:46.470] Relaying remaining futures
[10:58:46.470] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.470] - nx: 2
[10:58:46.470] - relay: TRUE
[10:58:46.470] - stdout: TRUE
[10:58:46.470] - signal: TRUE
[10:58:46.470] - resignal: FALSE
[10:58:46.470] - force: TRUE
[10:58:46.471] - relayed: [n=2] TRUE, TRUE
[10:58:46.471] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:46.471] - relayed: [n=2] TRUE, TRUE
[10:58:46.471] - queued futures: [n=2] TRUE, TRUE
[10:58:46.471] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.471] resolve() on list ... DONE
[10:58:46.471] result() for MulticoreFuture ...
[10:58:46.471] result() for MulticoreFuture ... done
[10:58:46.471] result() for MulticoreFuture ...
[10:58:46.472] result() for MulticoreFuture ... done
[10:58:46.472] result() for MulticoreFuture ...
[10:58:46.472] result() for MulticoreFuture ... done
[10:58:46.472] result() for MulticoreFuture ...
[10:58:46.472] result() for MulticoreFuture ... done
[10:58:46.472]  - Number of value chunks collected: 2
[10:58:46.472] Resolving 2 futures (chunks) ... DONE
[10:58:46.472] Reducing values from 2 chunks ...
[10:58:46.472]  - Number of values collected after concatenation: 3
[10:58:46.473]  - Number of values expected: 3
[10:58:46.473] Reducing values from 2 chunks ... DONE
[10:58:46.473] future_lapply() ... DONE
[10:58:46.474] future_lapply() ...
[10:58:46.476] Number of chunks: 2
[10:58:46.476] getGlobalsAndPackagesXApply() ...
[10:58:46.476]  - future.globals: TRUE
[10:58:46.476] getGlobalsAndPackages() ...
[10:58:46.476] Searching for globals...
[10:58:46.478] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.478] Searching for globals ... DONE
[10:58:46.478] Resolving globals: FALSE
[10:58:46.478] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:46.479] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:46.479] - globals: [1] ‘FUN’
[10:58:46.479] - packages: [1] ‘stats’
[10:58:46.479] getGlobalsAndPackages() ... DONE
[10:58:46.479]  - globals found/used: [n=1] ‘FUN’
[10:58:46.479]  - needed namespaces: [n=1] ‘stats’
[10:58:46.480] Finding globals ... DONE
[10:58:46.480]  - use_args: TRUE
[10:58:46.480]  - Getting '...' globals ...
[10:58:46.480] resolve() on list ...
[10:58:46.480]  recursive: 0
[10:58:46.480]  length: 1
[10:58:46.480]  elements: ‘...’
[10:58:46.481]  length: 0 (resolved future 1)
[10:58:46.481] resolve() on list ... DONE
[10:58:46.481]    - '...' content: [n=1] ‘probs’
[10:58:46.481] List of 1
[10:58:46.481]  $ ...:List of 1
[10:58:46.481]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:46.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.481]  - attr(*, "where")=List of 1
[10:58:46.481]   ..$ ...:<environment: 0x55f48b128c58> 
[10:58:46.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.481]  - attr(*, "resolved")= logi TRUE
[10:58:46.481]  - attr(*, "total_size")= num NA
[10:58:46.486]  - Getting '...' globals ... DONE
[10:58:46.486] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.486] List of 2
[10:58:46.486]  $ ...future.FUN:function (x, ...)  
[10:58:46.486]  $ ...          :List of 1
[10:58:46.486]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:46.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.486]  - attr(*, "where")=List of 2
[10:58:46.486]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.486]   ..$ ...          :<environment: 0x55f48b128c58> 
[10:58:46.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.486]  - attr(*, "resolved")= logi FALSE
[10:58:46.486]  - attr(*, "total_size")= num 6525
[10:58:46.489] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:46.490] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.490] Number of futures (= number of chunks): 2
[10:58:46.490] Launching 2 futures (chunks) ...
[10:58:46.490] Chunk #1 of 2 ...
[10:58:46.490]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.490] getGlobalsAndPackages() ...
[10:58:46.490] Searching for globals...
[10:58:46.490] 
[10:58:46.491] Searching for globals ... DONE
[10:58:46.491] - globals: [0] <none>
[10:58:46.491] getGlobalsAndPackages() ... DONE
[10:58:46.491]    + additional globals found: [n=0] 
[10:58:46.491]    + additional namespaces needed: [n=0] 
[10:58:46.491]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.491]  - seeds: <none>
[10:58:46.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.491] getGlobalsAndPackages() ...
[10:58:46.491] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.492] Resolving globals: FALSE
[10:58:46.492] Tweak future expression to call with '...' arguments ...
[10:58:46.492] {
[10:58:46.492]     do.call(function(...) {
[10:58:46.492]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.492]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.492]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.492]             on.exit(options(oopts), add = TRUE)
[10:58:46.492]         }
[10:58:46.492]         {
[10:58:46.492]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.492]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.492]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.492]             })
[10:58:46.492]         }
[10:58:46.492]     }, args = future.call.arguments)
[10:58:46.492] }
[10:58:46.492] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.492] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.492] - packages: [1] ‘stats’
[10:58:46.493] getGlobalsAndPackages() ... DONE
[10:58:46.493] run() for ‘Future’ ...
[10:58:46.493] - state: ‘created’
[10:58:46.493] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.495] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.495]   - Field: ‘label’
[10:58:46.495]   - Field: ‘local’
[10:58:46.495]   - Field: ‘owner’
[10:58:46.495]   - Field: ‘envir’
[10:58:46.495]   - Field: ‘workers’
[10:58:46.495]   - Field: ‘packages’
[10:58:46.495]   - Field: ‘gc’
[10:58:46.496]   - Field: ‘job’
[10:58:46.496]   - Field: ‘conditions’
[10:58:46.496]   - Field: ‘expr’
[10:58:46.496]   - Field: ‘uuid’
[10:58:46.496]   - Field: ‘seed’
[10:58:46.496]   - Field: ‘version’
[10:58:46.496]   - Field: ‘result’
[10:58:46.496]   - Field: ‘asynchronous’
[10:58:46.496]   - Field: ‘calls’
[10:58:46.496]   - Field: ‘globals’
[10:58:46.496]   - Field: ‘stdout’
[10:58:46.496]   - Field: ‘earlySignal’
[10:58:46.497]   - Field: ‘lazy’
[10:58:46.497]   - Field: ‘state’
[10:58:46.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.497] - Launch lazy future ...
[10:58:46.497] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.497] Packages needed by future strategies (n = 0): <none>
[10:58:46.498] {
[10:58:46.498]     {
[10:58:46.498]         {
[10:58:46.498]             ...future.startTime <- base::Sys.time()
[10:58:46.498]             {
[10:58:46.498]                 {
[10:58:46.498]                   {
[10:58:46.498]                     {
[10:58:46.498]                       {
[10:58:46.498]                         base::local({
[10:58:46.498]                           has_future <- base::requireNamespace("future", 
[10:58:46.498]                             quietly = TRUE)
[10:58:46.498]                           if (has_future) {
[10:58:46.498]                             ns <- base::getNamespace("future")
[10:58:46.498]                             version <- ns[[".package"]][["version"]]
[10:58:46.498]                             if (is.null(version)) 
[10:58:46.498]                               version <- utils::packageVersion("future")
[10:58:46.498]                           }
[10:58:46.498]                           else {
[10:58:46.498]                             version <- NULL
[10:58:46.498]                           }
[10:58:46.498]                           if (!has_future || version < "1.8.0") {
[10:58:46.498]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.498]                               "", base::R.version$version.string), 
[10:58:46.498]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:46.498]                                 base::R.version$platform, 8 * 
[10:58:46.498]                                   base::.Machine$sizeof.pointer), 
[10:58:46.498]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.498]                                 "release", "version")], collapse = " "), 
[10:58:46.498]                               hostname = base::Sys.info()[["nodename"]])
[10:58:46.498]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.498]                               info)
[10:58:46.498]                             info <- base::paste(info, collapse = "; ")
[10:58:46.498]                             if (!has_future) {
[10:58:46.498]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.498]                                 info)
[10:58:46.498]                             }
[10:58:46.498]                             else {
[10:58:46.498]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.498]                                 info, version)
[10:58:46.498]                             }
[10:58:46.498]                             base::stop(msg)
[10:58:46.498]                           }
[10:58:46.498]                         })
[10:58:46.498]                       }
[10:58:46.498]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.498]                       base::options(mc.cores = 1L)
[10:58:46.498]                     }
[10:58:46.498]                     base::local({
[10:58:46.498]                       for (pkg in "stats") {
[10:58:46.498]                         base::loadNamespace(pkg)
[10:58:46.498]                         base::library(pkg, character.only = TRUE)
[10:58:46.498]                       }
[10:58:46.498]                     })
[10:58:46.498]                   }
[10:58:46.498]                   ...future.strategy.old <- future::plan("list")
[10:58:46.498]                   options(future.plan = NULL)
[10:58:46.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.498]                 }
[10:58:46.498]                 ...future.workdir <- getwd()
[10:58:46.498]             }
[10:58:46.498]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.498]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.498]         }
[10:58:46.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.498]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.498]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.498]             base::names(...future.oldOptions))
[10:58:46.498]     }
[10:58:46.498]     if (FALSE) {
[10:58:46.498]     }
[10:58:46.498]     else {
[10:58:46.498]         if (TRUE) {
[10:58:46.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.498]                 open = "w")
[10:58:46.498]         }
[10:58:46.498]         else {
[10:58:46.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.498]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.498]         }
[10:58:46.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.498]             base::sink(type = "output", split = FALSE)
[10:58:46.498]             base::close(...future.stdout)
[10:58:46.498]         }, add = TRUE)
[10:58:46.498]     }
[10:58:46.498]     ...future.frame <- base::sys.nframe()
[10:58:46.498]     ...future.conditions <- base::list()
[10:58:46.498]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.498]     if (FALSE) {
[10:58:46.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.498]     }
[10:58:46.498]     ...future.result <- base::tryCatch({
[10:58:46.498]         base::withCallingHandlers({
[10:58:46.498]             ...future.value <- base::withVisible(base::local({
[10:58:46.498]                 withCallingHandlers({
[10:58:46.498]                   {
[10:58:46.498]                     do.call(function(...) {
[10:58:46.498]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.498]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.498]                         ...future.globals.maxSize)) {
[10:58:46.498]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.498]                         on.exit(options(oopts), add = TRUE)
[10:58:46.498]                       }
[10:58:46.498]                       {
[10:58:46.498]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.498]                           FUN = function(jj) {
[10:58:46.498]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.498]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.498]                           })
[10:58:46.498]                       }
[10:58:46.498]                     }, args = future.call.arguments)
[10:58:46.498]                   }
[10:58:46.498]                 }, immediateCondition = function(cond) {
[10:58:46.498]                   save_rds <- function (object, pathname, ...) 
[10:58:46.498]                   {
[10:58:46.498]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.498]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.498]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.498]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.498]                         fi_tmp[["mtime"]])
[10:58:46.498]                     }
[10:58:46.498]                     tryCatch({
[10:58:46.498]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.498]                     }, error = function(ex) {
[10:58:46.498]                       msg <- conditionMessage(ex)
[10:58:46.498]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.498]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.498]                         fi_tmp[["mtime"]], msg)
[10:58:46.498]                       ex$message <- msg
[10:58:46.498]                       stop(ex)
[10:58:46.498]                     })
[10:58:46.498]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.498]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.498]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.498]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.498]                       fi <- file.info(pathname)
[10:58:46.498]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.498]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.498]                         fi[["size"]], fi[["mtime"]])
[10:58:46.498]                       stop(msg)
[10:58:46.498]                     }
[10:58:46.498]                     invisible(pathname)
[10:58:46.498]                   }
[10:58:46.498]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.498]                     rootPath = tempdir()) 
[10:58:46.498]                   {
[10:58:46.498]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.498]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.498]                       tmpdir = path, fileext = ".rds")
[10:58:46.498]                     save_rds(obj, file)
[10:58:46.498]                   }
[10:58:46.498]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.498]                   {
[10:58:46.498]                     inherits <- base::inherits
[10:58:46.498]                     invokeRestart <- base::invokeRestart
[10:58:46.498]                     is.null <- base::is.null
[10:58:46.498]                     muffled <- FALSE
[10:58:46.498]                     if (inherits(cond, "message")) {
[10:58:46.498]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.498]                       if (muffled) 
[10:58:46.498]                         invokeRestart("muffleMessage")
[10:58:46.498]                     }
[10:58:46.498]                     else if (inherits(cond, "warning")) {
[10:58:46.498]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.498]                       if (muffled) 
[10:58:46.498]                         invokeRestart("muffleWarning")
[10:58:46.498]                     }
[10:58:46.498]                     else if (inherits(cond, "condition")) {
[10:58:46.498]                       if (!is.null(pattern)) {
[10:58:46.498]                         computeRestarts <- base::computeRestarts
[10:58:46.498]                         grepl <- base::grepl
[10:58:46.498]                         restarts <- computeRestarts(cond)
[10:58:46.498]                         for (restart in restarts) {
[10:58:46.498]                           name <- restart$name
[10:58:46.498]                           if (is.null(name)) 
[10:58:46.498]                             next
[10:58:46.498]                           if (!grepl(pattern, name)) 
[10:58:46.498]                             next
[10:58:46.498]                           invokeRestart(restart)
[10:58:46.498]                           muffled <- TRUE
[10:58:46.498]                           break
[10:58:46.498]                         }
[10:58:46.498]                       }
[10:58:46.498]                     }
[10:58:46.498]                     invisible(muffled)
[10:58:46.498]                   }
[10:58:46.498]                   muffleCondition(cond)
[10:58:46.498]                 })
[10:58:46.498]             }))
[10:58:46.498]             future::FutureResult(value = ...future.value$value, 
[10:58:46.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.498]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.498]                     ...future.globalenv.names))
[10:58:46.498]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.498]         }, condition = base::local({
[10:58:46.498]             c <- base::c
[10:58:46.498]             inherits <- base::inherits
[10:58:46.498]             invokeRestart <- base::invokeRestart
[10:58:46.498]             length <- base::length
[10:58:46.498]             list <- base::list
[10:58:46.498]             seq.int <- base::seq.int
[10:58:46.498]             signalCondition <- base::signalCondition
[10:58:46.498]             sys.calls <- base::sys.calls
[10:58:46.498]             `[[` <- base::`[[`
[10:58:46.498]             `+` <- base::`+`
[10:58:46.498]             `<<-` <- base::`<<-`
[10:58:46.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.498]                   3L)]
[10:58:46.498]             }
[10:58:46.498]             function(cond) {
[10:58:46.498]                 is_error <- inherits(cond, "error")
[10:58:46.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.498]                   NULL)
[10:58:46.498]                 if (is_error) {
[10:58:46.498]                   sessionInformation <- function() {
[10:58:46.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.498]                       search = base::search(), system = base::Sys.info())
[10:58:46.498]                   }
[10:58:46.498]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.498]                     cond$call), session = sessionInformation(), 
[10:58:46.498]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.498]                   signalCondition(cond)
[10:58:46.498]                 }
[10:58:46.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.498]                 "immediateCondition"))) {
[10:58:46.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.498]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.498]                   if (TRUE && !signal) {
[10:58:46.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.498]                     {
[10:58:46.498]                       inherits <- base::inherits
[10:58:46.498]                       invokeRestart <- base::invokeRestart
[10:58:46.498]                       is.null <- base::is.null
[10:58:46.498]                       muffled <- FALSE
[10:58:46.498]                       if (inherits(cond, "message")) {
[10:58:46.498]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.498]                         if (muffled) 
[10:58:46.498]                           invokeRestart("muffleMessage")
[10:58:46.498]                       }
[10:58:46.498]                       else if (inherits(cond, "warning")) {
[10:58:46.498]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.498]                         if (muffled) 
[10:58:46.498]                           invokeRestart("muffleWarning")
[10:58:46.498]                       }
[10:58:46.498]                       else if (inherits(cond, "condition")) {
[10:58:46.498]                         if (!is.null(pattern)) {
[10:58:46.498]                           computeRestarts <- base::computeRestarts
[10:58:46.498]                           grepl <- base::grepl
[10:58:46.498]                           restarts <- computeRestarts(cond)
[10:58:46.498]                           for (restart in restarts) {
[10:58:46.498]                             name <- restart$name
[10:58:46.498]                             if (is.null(name)) 
[10:58:46.498]                               next
[10:58:46.498]                             if (!grepl(pattern, name)) 
[10:58:46.498]                               next
[10:58:46.498]                             invokeRestart(restart)
[10:58:46.498]                             muffled <- TRUE
[10:58:46.498]                             break
[10:58:46.498]                           }
[10:58:46.498]                         }
[10:58:46.498]                       }
[10:58:46.498]                       invisible(muffled)
[10:58:46.498]                     }
[10:58:46.498]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.498]                   }
[10:58:46.498]                 }
[10:58:46.498]                 else {
[10:58:46.498]                   if (TRUE) {
[10:58:46.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.498]                     {
[10:58:46.498]                       inherits <- base::inherits
[10:58:46.498]                       invokeRestart <- base::invokeRestart
[10:58:46.498]                       is.null <- base::is.null
[10:58:46.498]                       muffled <- FALSE
[10:58:46.498]                       if (inherits(cond, "message")) {
[10:58:46.498]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.498]                         if (muffled) 
[10:58:46.498]                           invokeRestart("muffleMessage")
[10:58:46.498]                       }
[10:58:46.498]                       else if (inherits(cond, "warning")) {
[10:58:46.498]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.498]                         if (muffled) 
[10:58:46.498]                           invokeRestart("muffleWarning")
[10:58:46.498]                       }
[10:58:46.498]                       else if (inherits(cond, "condition")) {
[10:58:46.498]                         if (!is.null(pattern)) {
[10:58:46.498]                           computeRestarts <- base::computeRestarts
[10:58:46.498]                           grepl <- base::grepl
[10:58:46.498]                           restarts <- computeRestarts(cond)
[10:58:46.498]                           for (restart in restarts) {
[10:58:46.498]                             name <- restart$name
[10:58:46.498]                             if (is.null(name)) 
[10:58:46.498]                               next
[10:58:46.498]                             if (!grepl(pattern, name)) 
[10:58:46.498]                               next
[10:58:46.498]                             invokeRestart(restart)
[10:58:46.498]                             muffled <- TRUE
[10:58:46.498]                             break
[10:58:46.498]                           }
[10:58:46.498]                         }
[10:58:46.498]                       }
[10:58:46.498]                       invisible(muffled)
[10:58:46.498]                     }
[10:58:46.498]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.498]                   }
[10:58:46.498]                 }
[10:58:46.498]             }
[10:58:46.498]         }))
[10:58:46.498]     }, error = function(ex) {
[10:58:46.498]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.498]                 ...future.rng), started = ...future.startTime, 
[10:58:46.498]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.498]             version = "1.8"), class = "FutureResult")
[10:58:46.498]     }, finally = {
[10:58:46.498]         if (!identical(...future.workdir, getwd())) 
[10:58:46.498]             setwd(...future.workdir)
[10:58:46.498]         {
[10:58:46.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.498]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.498]             }
[10:58:46.498]             base::options(...future.oldOptions)
[10:58:46.498]             if (.Platform$OS.type == "windows") {
[10:58:46.498]                 old_names <- names(...future.oldEnvVars)
[10:58:46.498]                 envs <- base::Sys.getenv()
[10:58:46.498]                 names <- names(envs)
[10:58:46.498]                 common <- intersect(names, old_names)
[10:58:46.498]                 added <- setdiff(names, old_names)
[10:58:46.498]                 removed <- setdiff(old_names, names)
[10:58:46.498]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.498]                   envs[common]]
[10:58:46.498]                 NAMES <- toupper(changed)
[10:58:46.498]                 args <- list()
[10:58:46.498]                 for (kk in seq_along(NAMES)) {
[10:58:46.498]                   name <- changed[[kk]]
[10:58:46.498]                   NAME <- NAMES[[kk]]
[10:58:46.498]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.498]                     next
[10:58:46.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.498]                 }
[10:58:46.498]                 NAMES <- toupper(added)
[10:58:46.498]                 for (kk in seq_along(NAMES)) {
[10:58:46.498]                   name <- added[[kk]]
[10:58:46.498]                   NAME <- NAMES[[kk]]
[10:58:46.498]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.498]                     next
[10:58:46.498]                   args[[name]] <- ""
[10:58:46.498]                 }
[10:58:46.498]                 NAMES <- toupper(removed)
[10:58:46.498]                 for (kk in seq_along(NAMES)) {
[10:58:46.498]                   name <- removed[[kk]]
[10:58:46.498]                   NAME <- NAMES[[kk]]
[10:58:46.498]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.498]                     next
[10:58:46.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.498]                 }
[10:58:46.498]                 if (length(args) > 0) 
[10:58:46.498]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.498]             }
[10:58:46.498]             else {
[10:58:46.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.498]             }
[10:58:46.498]             {
[10:58:46.498]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.498]                   0L) {
[10:58:46.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.498]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.498]                   base::options(opts)
[10:58:46.498]                 }
[10:58:46.498]                 {
[10:58:46.498]                   {
[10:58:46.498]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.498]                     NULL
[10:58:46.498]                   }
[10:58:46.498]                   options(future.plan = NULL)
[10:58:46.498]                   if (is.na(NA_character_)) 
[10:58:46.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.498]                     .init = FALSE)
[10:58:46.498]                 }
[10:58:46.498]             }
[10:58:46.498]         }
[10:58:46.498]     })
[10:58:46.498]     if (TRUE) {
[10:58:46.498]         base::sink(type = "output", split = FALSE)
[10:58:46.498]         if (TRUE) {
[10:58:46.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.498]         }
[10:58:46.498]         else {
[10:58:46.498]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.498]         }
[10:58:46.498]         base::close(...future.stdout)
[10:58:46.498]         ...future.stdout <- NULL
[10:58:46.498]     }
[10:58:46.498]     ...future.result$conditions <- ...future.conditions
[10:58:46.498]     ...future.result$finished <- base::Sys.time()
[10:58:46.498]     ...future.result
[10:58:46.498] }
[10:58:46.500] assign_globals() ...
[10:58:46.500] List of 5
[10:58:46.500]  $ ...future.FUN            :function (x, ...)  
[10:58:46.500]  $ future.call.arguments    :List of 1
[10:58:46.500]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:46.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.500]  $ ...future.elements_ii    :List of 1
[10:58:46.500]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.500]  $ ...future.seeds_ii       : NULL
[10:58:46.500]  $ ...future.globals.maxSize: NULL
[10:58:46.500]  - attr(*, "where")=List of 5
[10:58:46.500]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.500]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.500]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.500]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.500]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.500]  - attr(*, "resolved")= logi FALSE
[10:58:46.500]  - attr(*, "total_size")= num 6525
[10:58:46.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.500]  - attr(*, "already-done")= logi TRUE
[10:58:46.505] - copied ‘...future.FUN’ to environment
[10:58:46.505] - copied ‘future.call.arguments’ to environment
[10:58:46.505] - copied ‘...future.elements_ii’ to environment
[10:58:46.505] - copied ‘...future.seeds_ii’ to environment
[10:58:46.506] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.506] assign_globals() ... done
[10:58:46.506] requestCore(): workers = 2
[10:58:46.508] MulticoreFuture started
[10:58:46.508] - Launch lazy future ... done
[10:58:46.508] run() for ‘MulticoreFuture’ ... done
[10:58:46.508] Created future:
[10:58:46.509] plan(): Setting new future strategy stack:
[10:58:46.509] List of future strategies:
[10:58:46.509] 1. sequential:
[10:58:46.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.509]    - tweaked: FALSE
[10:58:46.509]    - call: NULL
[10:58:46.510] plan(): nbrOfWorkers() = 1
[10:58:46.512] plan(): Setting new future strategy stack:
[10:58:46.512] List of future strategies:
[10:58:46.512] 1. multicore:
[10:58:46.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.512]    - tweaked: FALSE
[10:58:46.512]    - call: plan(strategy)
[10:58:46.518] plan(): nbrOfWorkers() = 2
[10:58:46.509] MulticoreFuture:
[10:58:46.509] Label: ‘future_eapply-1’
[10:58:46.509] Expression:
[10:58:46.509] {
[10:58:46.509]     do.call(function(...) {
[10:58:46.509]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.509]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.509]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.509]             on.exit(options(oopts), add = TRUE)
[10:58:46.509]         }
[10:58:46.509]         {
[10:58:46.509]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.509]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.509]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.509]             })
[10:58:46.509]         }
[10:58:46.509]     }, args = future.call.arguments)
[10:58:46.509] }
[10:58:46.509] Lazy evaluation: FALSE
[10:58:46.509] Asynchronous evaluation: TRUE
[10:58:46.509] Local evaluation: TRUE
[10:58:46.509] Environment: R_GlobalEnv
[10:58:46.509] Capture standard output: TRUE
[10:58:46.509] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.509] Globals: 5 objects totaling 637 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.509] Packages: 1 packages (‘stats’)
[10:58:46.509] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.509] Resolved: TRUE
[10:58:46.509] Value: <not collected>
[10:58:46.509] Conditions captured: <none>
[10:58:46.509] Early signaling: FALSE
[10:58:46.509] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.509] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.519] Chunk #1 of 2 ... DONE
[10:58:46.520] Chunk #2 of 2 ...
[10:58:46.520]  - Finding globals in 'X' for chunk #2 ...
[10:58:46.520] getGlobalsAndPackages() ...
[10:58:46.520] Searching for globals...
[10:58:46.520] 
[10:58:46.521] Searching for globals ... DONE
[10:58:46.521] - globals: [0] <none>
[10:58:46.523] getGlobalsAndPackages() ... DONE
[10:58:46.523]    + additional globals found: [n=0] 
[10:58:46.523]    + additional namespaces needed: [n=0] 
[10:58:46.523]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:46.523]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.523]  - seeds: <none>
[10:58:46.523]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.524] getGlobalsAndPackages() ...
[10:58:46.524] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.524] Resolving globals: FALSE
[10:58:46.524] Tweak future expression to call with '...' arguments ...
[10:58:46.524] {
[10:58:46.524]     do.call(function(...) {
[10:58:46.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.524]             on.exit(options(oopts), add = TRUE)
[10:58:46.524]         }
[10:58:46.524]         {
[10:58:46.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.524]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.524]             })
[10:58:46.524]         }
[10:58:46.524]     }, args = future.call.arguments)
[10:58:46.524] }
[10:58:46.525] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.526] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.526] - packages: [1] ‘stats’
[10:58:46.526] getGlobalsAndPackages() ... DONE
[10:58:46.527] run() for ‘Future’ ...
[10:58:46.527] - state: ‘created’
[10:58:46.527] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.530]   - Field: ‘label’
[10:58:46.531]   - Field: ‘local’
[10:58:46.531]   - Field: ‘owner’
[10:58:46.531]   - Field: ‘envir’
[10:58:46.531]   - Field: ‘workers’
[10:58:46.531]   - Field: ‘packages’
[10:58:46.531]   - Field: ‘gc’
[10:58:46.531]   - Field: ‘job’
[10:58:46.532]   - Field: ‘conditions’
[10:58:46.532]   - Field: ‘expr’
[10:58:46.532]   - Field: ‘uuid’
[10:58:46.532]   - Field: ‘seed’
[10:58:46.532]   - Field: ‘version’
[10:58:46.532]   - Field: ‘result’
[10:58:46.532]   - Field: ‘asynchronous’
[10:58:46.533]   - Field: ‘calls’
[10:58:46.533]   - Field: ‘globals’
[10:58:46.533]   - Field: ‘stdout’
[10:58:46.533]   - Field: ‘earlySignal’
[10:58:46.533]   - Field: ‘lazy’
[10:58:46.533]   - Field: ‘state’
[10:58:46.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.534] - Launch lazy future ...
[10:58:46.534] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.534] Packages needed by future strategies (n = 0): <none>
[10:58:46.535] {
[10:58:46.535]     {
[10:58:46.535]         {
[10:58:46.535]             ...future.startTime <- base::Sys.time()
[10:58:46.535]             {
[10:58:46.535]                 {
[10:58:46.535]                   {
[10:58:46.535]                     {
[10:58:46.535]                       {
[10:58:46.535]                         base::local({
[10:58:46.535]                           has_future <- base::requireNamespace("future", 
[10:58:46.535]                             quietly = TRUE)
[10:58:46.535]                           if (has_future) {
[10:58:46.535]                             ns <- base::getNamespace("future")
[10:58:46.535]                             version <- ns[[".package"]][["version"]]
[10:58:46.535]                             if (is.null(version)) 
[10:58:46.535]                               version <- utils::packageVersion("future")
[10:58:46.535]                           }
[10:58:46.535]                           else {
[10:58:46.535]                             version <- NULL
[10:58:46.535]                           }
[10:58:46.535]                           if (!has_future || version < "1.8.0") {
[10:58:46.535]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.535]                               "", base::R.version$version.string), 
[10:58:46.535]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:46.535]                                 base::R.version$platform, 8 * 
[10:58:46.535]                                   base::.Machine$sizeof.pointer), 
[10:58:46.535]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.535]                                 "release", "version")], collapse = " "), 
[10:58:46.535]                               hostname = base::Sys.info()[["nodename"]])
[10:58:46.535]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.535]                               info)
[10:58:46.535]                             info <- base::paste(info, collapse = "; ")
[10:58:46.535]                             if (!has_future) {
[10:58:46.535]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.535]                                 info)
[10:58:46.535]                             }
[10:58:46.535]                             else {
[10:58:46.535]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.535]                                 info, version)
[10:58:46.535]                             }
[10:58:46.535]                             base::stop(msg)
[10:58:46.535]                           }
[10:58:46.535]                         })
[10:58:46.535]                       }
[10:58:46.535]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.535]                       base::options(mc.cores = 1L)
[10:58:46.535]                     }
[10:58:46.535]                     base::local({
[10:58:46.535]                       for (pkg in "stats") {
[10:58:46.535]                         base::loadNamespace(pkg)
[10:58:46.535]                         base::library(pkg, character.only = TRUE)
[10:58:46.535]                       }
[10:58:46.535]                     })
[10:58:46.535]                   }
[10:58:46.535]                   ...future.strategy.old <- future::plan("list")
[10:58:46.535]                   options(future.plan = NULL)
[10:58:46.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.535]                 }
[10:58:46.535]                 ...future.workdir <- getwd()
[10:58:46.535]             }
[10:58:46.535]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.535]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.535]         }
[10:58:46.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.535]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.535]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.535]             base::names(...future.oldOptions))
[10:58:46.535]     }
[10:58:46.535]     if (FALSE) {
[10:58:46.535]     }
[10:58:46.535]     else {
[10:58:46.535]         if (TRUE) {
[10:58:46.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.535]                 open = "w")
[10:58:46.535]         }
[10:58:46.535]         else {
[10:58:46.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.535]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.535]         }
[10:58:46.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.535]             base::sink(type = "output", split = FALSE)
[10:58:46.535]             base::close(...future.stdout)
[10:58:46.535]         }, add = TRUE)
[10:58:46.535]     }
[10:58:46.535]     ...future.frame <- base::sys.nframe()
[10:58:46.535]     ...future.conditions <- base::list()
[10:58:46.535]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.535]     if (FALSE) {
[10:58:46.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.535]     }
[10:58:46.535]     ...future.result <- base::tryCatch({
[10:58:46.535]         base::withCallingHandlers({
[10:58:46.535]             ...future.value <- base::withVisible(base::local({
[10:58:46.535]                 withCallingHandlers({
[10:58:46.535]                   {
[10:58:46.535]                     do.call(function(...) {
[10:58:46.535]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.535]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.535]                         ...future.globals.maxSize)) {
[10:58:46.535]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.535]                         on.exit(options(oopts), add = TRUE)
[10:58:46.535]                       }
[10:58:46.535]                       {
[10:58:46.535]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.535]                           FUN = function(jj) {
[10:58:46.535]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.535]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.535]                           })
[10:58:46.535]                       }
[10:58:46.535]                     }, args = future.call.arguments)
[10:58:46.535]                   }
[10:58:46.535]                 }, immediateCondition = function(cond) {
[10:58:46.535]                   save_rds <- function (object, pathname, ...) 
[10:58:46.535]                   {
[10:58:46.535]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.535]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.535]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.535]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.535]                         fi_tmp[["mtime"]])
[10:58:46.535]                     }
[10:58:46.535]                     tryCatch({
[10:58:46.535]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.535]                     }, error = function(ex) {
[10:58:46.535]                       msg <- conditionMessage(ex)
[10:58:46.535]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.535]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.535]                         fi_tmp[["mtime"]], msg)
[10:58:46.535]                       ex$message <- msg
[10:58:46.535]                       stop(ex)
[10:58:46.535]                     })
[10:58:46.535]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.535]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.535]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.535]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.535]                       fi <- file.info(pathname)
[10:58:46.535]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.535]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.535]                         fi[["size"]], fi[["mtime"]])
[10:58:46.535]                       stop(msg)
[10:58:46.535]                     }
[10:58:46.535]                     invisible(pathname)
[10:58:46.535]                   }
[10:58:46.535]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.535]                     rootPath = tempdir()) 
[10:58:46.535]                   {
[10:58:46.535]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.535]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.535]                       tmpdir = path, fileext = ".rds")
[10:58:46.535]                     save_rds(obj, file)
[10:58:46.535]                   }
[10:58:46.535]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.535]                   {
[10:58:46.535]                     inherits <- base::inherits
[10:58:46.535]                     invokeRestart <- base::invokeRestart
[10:58:46.535]                     is.null <- base::is.null
[10:58:46.535]                     muffled <- FALSE
[10:58:46.535]                     if (inherits(cond, "message")) {
[10:58:46.535]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.535]                       if (muffled) 
[10:58:46.535]                         invokeRestart("muffleMessage")
[10:58:46.535]                     }
[10:58:46.535]                     else if (inherits(cond, "warning")) {
[10:58:46.535]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.535]                       if (muffled) 
[10:58:46.535]                         invokeRestart("muffleWarning")
[10:58:46.535]                     }
[10:58:46.535]                     else if (inherits(cond, "condition")) {
[10:58:46.535]                       if (!is.null(pattern)) {
[10:58:46.535]                         computeRestarts <- base::computeRestarts
[10:58:46.535]                         grepl <- base::grepl
[10:58:46.535]                         restarts <- computeRestarts(cond)
[10:58:46.535]                         for (restart in restarts) {
[10:58:46.535]                           name <- restart$name
[10:58:46.535]                           if (is.null(name)) 
[10:58:46.535]                             next
[10:58:46.535]                           if (!grepl(pattern, name)) 
[10:58:46.535]                             next
[10:58:46.535]                           invokeRestart(restart)
[10:58:46.535]                           muffled <- TRUE
[10:58:46.535]                           break
[10:58:46.535]                         }
[10:58:46.535]                       }
[10:58:46.535]                     }
[10:58:46.535]                     invisible(muffled)
[10:58:46.535]                   }
[10:58:46.535]                   muffleCondition(cond)
[10:58:46.535]                 })
[10:58:46.535]             }))
[10:58:46.535]             future::FutureResult(value = ...future.value$value, 
[10:58:46.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.535]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.535]                     ...future.globalenv.names))
[10:58:46.535]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.535]         }, condition = base::local({
[10:58:46.535]             c <- base::c
[10:58:46.535]             inherits <- base::inherits
[10:58:46.535]             invokeRestart <- base::invokeRestart
[10:58:46.535]             length <- base::length
[10:58:46.535]             list <- base::list
[10:58:46.535]             seq.int <- base::seq.int
[10:58:46.535]             signalCondition <- base::signalCondition
[10:58:46.535]             sys.calls <- base::sys.calls
[10:58:46.535]             `[[` <- base::`[[`
[10:58:46.535]             `+` <- base::`+`
[10:58:46.535]             `<<-` <- base::`<<-`
[10:58:46.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.535]                   3L)]
[10:58:46.535]             }
[10:58:46.535]             function(cond) {
[10:58:46.535]                 is_error <- inherits(cond, "error")
[10:58:46.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.535]                   NULL)
[10:58:46.535]                 if (is_error) {
[10:58:46.535]                   sessionInformation <- function() {
[10:58:46.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.535]                       search = base::search(), system = base::Sys.info())
[10:58:46.535]                   }
[10:58:46.535]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.535]                     cond$call), session = sessionInformation(), 
[10:58:46.535]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.535]                   signalCondition(cond)
[10:58:46.535]                 }
[10:58:46.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.535]                 "immediateCondition"))) {
[10:58:46.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.535]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.535]                   if (TRUE && !signal) {
[10:58:46.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.535]                     {
[10:58:46.535]                       inherits <- base::inherits
[10:58:46.535]                       invokeRestart <- base::invokeRestart
[10:58:46.535]                       is.null <- base::is.null
[10:58:46.535]                       muffled <- FALSE
[10:58:46.535]                       if (inherits(cond, "message")) {
[10:58:46.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.535]                         if (muffled) 
[10:58:46.535]                           invokeRestart("muffleMessage")
[10:58:46.535]                       }
[10:58:46.535]                       else if (inherits(cond, "warning")) {
[10:58:46.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.535]                         if (muffled) 
[10:58:46.535]                           invokeRestart("muffleWarning")
[10:58:46.535]                       }
[10:58:46.535]                       else if (inherits(cond, "condition")) {
[10:58:46.535]                         if (!is.null(pattern)) {
[10:58:46.535]                           computeRestarts <- base::computeRestarts
[10:58:46.535]                           grepl <- base::grepl
[10:58:46.535]                           restarts <- computeRestarts(cond)
[10:58:46.535]                           for (restart in restarts) {
[10:58:46.535]                             name <- restart$name
[10:58:46.535]                             if (is.null(name)) 
[10:58:46.535]                               next
[10:58:46.535]                             if (!grepl(pattern, name)) 
[10:58:46.535]                               next
[10:58:46.535]                             invokeRestart(restart)
[10:58:46.535]                             muffled <- TRUE
[10:58:46.535]                             break
[10:58:46.535]                           }
[10:58:46.535]                         }
[10:58:46.535]                       }
[10:58:46.535]                       invisible(muffled)
[10:58:46.535]                     }
[10:58:46.535]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.535]                   }
[10:58:46.535]                 }
[10:58:46.535]                 else {
[10:58:46.535]                   if (TRUE) {
[10:58:46.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.535]                     {
[10:58:46.535]                       inherits <- base::inherits
[10:58:46.535]                       invokeRestart <- base::invokeRestart
[10:58:46.535]                       is.null <- base::is.null
[10:58:46.535]                       muffled <- FALSE
[10:58:46.535]                       if (inherits(cond, "message")) {
[10:58:46.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.535]                         if (muffled) 
[10:58:46.535]                           invokeRestart("muffleMessage")
[10:58:46.535]                       }
[10:58:46.535]                       else if (inherits(cond, "warning")) {
[10:58:46.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.535]                         if (muffled) 
[10:58:46.535]                           invokeRestart("muffleWarning")
[10:58:46.535]                       }
[10:58:46.535]                       else if (inherits(cond, "condition")) {
[10:58:46.535]                         if (!is.null(pattern)) {
[10:58:46.535]                           computeRestarts <- base::computeRestarts
[10:58:46.535]                           grepl <- base::grepl
[10:58:46.535]                           restarts <- computeRestarts(cond)
[10:58:46.535]                           for (restart in restarts) {
[10:58:46.535]                             name <- restart$name
[10:58:46.535]                             if (is.null(name)) 
[10:58:46.535]                               next
[10:58:46.535]                             if (!grepl(pattern, name)) 
[10:58:46.535]                               next
[10:58:46.535]                             invokeRestart(restart)
[10:58:46.535]                             muffled <- TRUE
[10:58:46.535]                             break
[10:58:46.535]                           }
[10:58:46.535]                         }
[10:58:46.535]                       }
[10:58:46.535]                       invisible(muffled)
[10:58:46.535]                     }
[10:58:46.535]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.535]                   }
[10:58:46.535]                 }
[10:58:46.535]             }
[10:58:46.535]         }))
[10:58:46.535]     }, error = function(ex) {
[10:58:46.535]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.535]                 ...future.rng), started = ...future.startTime, 
[10:58:46.535]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.535]             version = "1.8"), class = "FutureResult")
[10:58:46.535]     }, finally = {
[10:58:46.535]         if (!identical(...future.workdir, getwd())) 
[10:58:46.535]             setwd(...future.workdir)
[10:58:46.535]         {
[10:58:46.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.535]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.535]             }
[10:58:46.535]             base::options(...future.oldOptions)
[10:58:46.535]             if (.Platform$OS.type == "windows") {
[10:58:46.535]                 old_names <- names(...future.oldEnvVars)
[10:58:46.535]                 envs <- base::Sys.getenv()
[10:58:46.535]                 names <- names(envs)
[10:58:46.535]                 common <- intersect(names, old_names)
[10:58:46.535]                 added <- setdiff(names, old_names)
[10:58:46.535]                 removed <- setdiff(old_names, names)
[10:58:46.535]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.535]                   envs[common]]
[10:58:46.535]                 NAMES <- toupper(changed)
[10:58:46.535]                 args <- list()
[10:58:46.535]                 for (kk in seq_along(NAMES)) {
[10:58:46.535]                   name <- changed[[kk]]
[10:58:46.535]                   NAME <- NAMES[[kk]]
[10:58:46.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.535]                     next
[10:58:46.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.535]                 }
[10:58:46.535]                 NAMES <- toupper(added)
[10:58:46.535]                 for (kk in seq_along(NAMES)) {
[10:58:46.535]                   name <- added[[kk]]
[10:58:46.535]                   NAME <- NAMES[[kk]]
[10:58:46.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.535]                     next
[10:58:46.535]                   args[[name]] <- ""
[10:58:46.535]                 }
[10:58:46.535]                 NAMES <- toupper(removed)
[10:58:46.535]                 for (kk in seq_along(NAMES)) {
[10:58:46.535]                   name <- removed[[kk]]
[10:58:46.535]                   NAME <- NAMES[[kk]]
[10:58:46.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.535]                     next
[10:58:46.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.535]                 }
[10:58:46.535]                 if (length(args) > 0) 
[10:58:46.535]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.535]             }
[10:58:46.535]             else {
[10:58:46.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.535]             }
[10:58:46.535]             {
[10:58:46.535]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.535]                   0L) {
[10:58:46.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.535]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.535]                   base::options(opts)
[10:58:46.535]                 }
[10:58:46.535]                 {
[10:58:46.535]                   {
[10:58:46.535]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.535]                     NULL
[10:58:46.535]                   }
[10:58:46.535]                   options(future.plan = NULL)
[10:58:46.535]                   if (is.na(NA_character_)) 
[10:58:46.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.535]                     .init = FALSE)
[10:58:46.535]                 }
[10:58:46.535]             }
[10:58:46.535]         }
[10:58:46.535]     })
[10:58:46.535]     if (TRUE) {
[10:58:46.535]         base::sink(type = "output", split = FALSE)
[10:58:46.535]         if (TRUE) {
[10:58:46.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.535]         }
[10:58:46.535]         else {
[10:58:46.535]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.535]         }
[10:58:46.535]         base::close(...future.stdout)
[10:58:46.535]         ...future.stdout <- NULL
[10:58:46.535]     }
[10:58:46.535]     ...future.result$conditions <- ...future.conditions
[10:58:46.535]     ...future.result$finished <- base::Sys.time()
[10:58:46.535]     ...future.result
[10:58:46.535] }
[10:58:46.538] assign_globals() ...
[10:58:46.538] List of 5
[10:58:46.538]  $ ...future.FUN            :function (x, ...)  
[10:58:46.538]  $ future.call.arguments    :List of 1
[10:58:46.538]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:46.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.538]  $ ...future.elements_ii    :List of 2
[10:58:46.538]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.538]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.538]  $ ...future.seeds_ii       : NULL
[10:58:46.538]  $ ...future.globals.maxSize: NULL
[10:58:46.538]  - attr(*, "where")=List of 5
[10:58:46.538]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.538]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.538]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.538]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.538]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.538]  - attr(*, "resolved")= logi FALSE
[10:58:46.538]  - attr(*, "total_size")= num 6525
[10:58:46.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.538]  - attr(*, "already-done")= logi TRUE
[10:58:46.546] - copied ‘...future.FUN’ to environment
[10:58:46.546] - copied ‘future.call.arguments’ to environment
[10:58:46.546] - copied ‘...future.elements_ii’ to environment
[10:58:46.547] - copied ‘...future.seeds_ii’ to environment
[10:58:46.547] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.547] assign_globals() ... done
[10:58:46.547] requestCore(): workers = 2
[10:58:46.549] MulticoreFuture started
[10:58:46.550] - Launch lazy future ... done
[10:58:46.550] run() for ‘MulticoreFuture’ ... done
[10:58:46.550] Created future:
[10:58:46.551] plan(): Setting new future strategy stack:
[10:58:46.551] List of future strategies:
[10:58:46.551] 1. sequential:
[10:58:46.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.551]    - tweaked: FALSE
[10:58:46.551]    - call: NULL
[10:58:46.552] plan(): nbrOfWorkers() = 1
[10:58:46.556] plan(): Setting new future strategy stack:
[10:58:46.556] List of future strategies:
[10:58:46.556] 1. multicore:
[10:58:46.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.556]    - tweaked: FALSE
[10:58:46.556]    - call: plan(strategy)
[10:58:46.560] plan(): nbrOfWorkers() = 2
[10:58:46.550] MulticoreFuture:
[10:58:46.550] Label: ‘future_eapply-2’
[10:58:46.550] Expression:
[10:58:46.550] {
[10:58:46.550]     do.call(function(...) {
[10:58:46.550]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.550]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.550]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.550]             on.exit(options(oopts), add = TRUE)
[10:58:46.550]         }
[10:58:46.550]         {
[10:58:46.550]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.550]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.550]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.550]             })
[10:58:46.550]         }
[10:58:46.550]     }, args = future.call.arguments)
[10:58:46.550] }
[10:58:46.550] Lazy evaluation: FALSE
[10:58:46.550] Asynchronous evaluation: TRUE
[10:58:46.550] Local evaluation: TRUE
[10:58:46.550] Environment: R_GlobalEnv
[10:58:46.550] Capture standard output: TRUE
[10:58:46.550] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.550] Globals: 5 objects totaling 795 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.550] Packages: 1 packages (‘stats’)
[10:58:46.550] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.550] Resolved: TRUE
[10:58:46.550] Value: <not collected>
[10:58:46.550] Conditions captured: <none>
[10:58:46.550] Early signaling: FALSE
[10:58:46.550] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.550] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.561] Chunk #2 of 2 ... DONE
[10:58:46.561] Launching 2 futures (chunks) ... DONE
[10:58:46.562] Resolving 2 futures (chunks) ...
[10:58:46.562] resolve() on list ...
[10:58:46.562]  recursive: 0
[10:58:46.562]  length: 2
[10:58:46.562] 
[10:58:46.563] Future #1
[10:58:46.563] result() for MulticoreFuture ...
[10:58:46.564] result() for MulticoreFuture ...
[10:58:46.564] result() for MulticoreFuture ... done
[10:58:46.564] result() for MulticoreFuture ... done
[10:58:46.564] result() for MulticoreFuture ...
[10:58:46.564] result() for MulticoreFuture ... done
[10:58:46.564] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:46.565] - nx: 2
[10:58:46.565] - relay: TRUE
[10:58:46.565] - stdout: TRUE
[10:58:46.565] - signal: TRUE
[10:58:46.565] - resignal: FALSE
[10:58:46.565] - force: TRUE
[10:58:46.565] - relayed: [n=2] FALSE, FALSE
[10:58:46.565] - queued futures: [n=2] FALSE, FALSE
[10:58:46.566]  - until=1
[10:58:46.566]  - relaying element #1
[10:58:46.566] result() for MulticoreFuture ...
[10:58:46.566] result() for MulticoreFuture ... done
[10:58:46.566] result() for MulticoreFuture ...
[10:58:46.566] result() for MulticoreFuture ... done
[10:58:46.566] result() for MulticoreFuture ...
[10:58:46.567] result() for MulticoreFuture ... done
[10:58:46.567] result() for MulticoreFuture ...
[10:58:46.567] result() for MulticoreFuture ... done
[10:58:46.567] - relayed: [n=2] TRUE, FALSE
[10:58:46.567] - queued futures: [n=2] TRUE, FALSE
[10:58:46.567] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:46.567]  length: 1 (resolved future 1)
[10:58:46.568] Future #2
[10:58:46.568] result() for MulticoreFuture ...
[10:58:46.569] result() for MulticoreFuture ...
[10:58:46.569] result() for MulticoreFuture ... done
[10:58:46.569] result() for MulticoreFuture ... done
[10:58:46.569] result() for MulticoreFuture ...
[10:58:46.569] result() for MulticoreFuture ... done
[10:58:46.569] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:46.569] - nx: 2
[10:58:46.570] - relay: TRUE
[10:58:46.570] - stdout: TRUE
[10:58:46.570] - signal: TRUE
[10:58:46.570] - resignal: FALSE
[10:58:46.570] - force: TRUE
[10:58:46.570] - relayed: [n=2] TRUE, FALSE
[10:58:46.570] - queued futures: [n=2] TRUE, FALSE
[10:58:46.570]  - until=2
[10:58:46.573]  - relaying element #2
[10:58:46.573] result() for MulticoreFuture ...
[10:58:46.573] result() for MulticoreFuture ... done
[10:58:46.573] result() for MulticoreFuture ...
[10:58:46.573] result() for MulticoreFuture ... done
[10:58:46.573] result() for MulticoreFuture ...
[10:58:46.574] result() for MulticoreFuture ... done
[10:58:46.574] result() for MulticoreFuture ...
[10:58:46.574] result() for MulticoreFuture ... done
[10:58:46.574] - relayed: [n=2] TRUE, TRUE
[10:58:46.574] - queued futures: [n=2] TRUE, TRUE
[10:58:46.574] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:46.574]  length: 0 (resolved future 2)
[10:58:46.575] Relaying remaining futures
[10:58:46.575] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.575] - nx: 2
[10:58:46.575] - relay: TRUE
[10:58:46.575] - stdout: TRUE
[10:58:46.575] - signal: TRUE
[10:58:46.575] - resignal: FALSE
[10:58:46.575] - force: TRUE
[10:58:46.575] - relayed: [n=2] TRUE, TRUE
[10:58:46.576] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:46.576] - relayed: [n=2] TRUE, TRUE
[10:58:46.576] - queued futures: [n=2] TRUE, TRUE
[10:58:46.576] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.576] resolve() on list ... DONE
[10:58:46.576] result() for MulticoreFuture ...
[10:58:46.576] result() for MulticoreFuture ... done
[10:58:46.576] result() for MulticoreFuture ...
[10:58:46.577] result() for MulticoreFuture ... done
[10:58:46.577] result() for MulticoreFuture ...
[10:58:46.577] result() for MulticoreFuture ... done
[10:58:46.577] result() for MulticoreFuture ...
[10:58:46.577] result() for MulticoreFuture ... done
[10:58:46.577]  - Number of value chunks collected: 2
[10:58:46.577] Resolving 2 futures (chunks) ... DONE
[10:58:46.577] Reducing values from 2 chunks ...
[10:58:46.578]  - Number of values collected after concatenation: 3
[10:58:46.578]  - Number of values expected: 3
[10:58:46.578] Reducing values from 2 chunks ... DONE
[10:58:46.578] future_lapply() ... DONE
[10:58:46.579] future_lapply() ...
[10:58:46.582] Number of chunks: 2
[10:58:46.582] getGlobalsAndPackagesXApply() ...
[10:58:46.582]  - future.globals: TRUE
[10:58:46.582] getGlobalsAndPackages() ...
[10:58:46.582] Searching for globals...
[10:58:46.584] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.584] Searching for globals ... DONE
[10:58:46.584] Resolving globals: FALSE
[10:58:46.584] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:46.585] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:46.585] - globals: [1] ‘FUN’
[10:58:46.585] - packages: [1] ‘stats’
[10:58:46.585] getGlobalsAndPackages() ... DONE
[10:58:46.585]  - globals found/used: [n=1] ‘FUN’
[10:58:46.585]  - needed namespaces: [n=1] ‘stats’
[10:58:46.585] Finding globals ... DONE
[10:58:46.586]  - use_args: TRUE
[10:58:46.586]  - Getting '...' globals ...
[10:58:46.586] resolve() on list ...
[10:58:46.586]  recursive: 0
[10:58:46.586]  length: 1
[10:58:46.586]  elements: ‘...’
[10:58:46.587]  length: 0 (resolved future 1)
[10:58:46.587] resolve() on list ... DONE
[10:58:46.587]    - '...' content: [n=0] 
[10:58:46.587] List of 1
[10:58:46.587]  $ ...: list()
[10:58:46.587]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.587]  - attr(*, "where")=List of 1
[10:58:46.587]   ..$ ...:<environment: 0x55f488d77cb0> 
[10:58:46.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.587]  - attr(*, "resolved")= logi TRUE
[10:58:46.587]  - attr(*, "total_size")= num NA
[10:58:46.590]  - Getting '...' globals ... DONE
[10:58:46.590] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.590] List of 2
[10:58:46.590]  $ ...future.FUN:function (x, ...)  
[10:58:46.590]  $ ...          : list()
[10:58:46.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.590]  - attr(*, "where")=List of 2
[10:58:46.590]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.590]   ..$ ...          :<environment: 0x55f488d77cb0> 
[10:58:46.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.590]  - attr(*, "resolved")= logi FALSE
[10:58:46.590]  - attr(*, "total_size")= num 5433
[10:58:46.593] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:46.593] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.593] Number of futures (= number of chunks): 2
[10:58:46.593] Launching 2 futures (chunks) ...
[10:58:46.593] Chunk #1 of 2 ...
[10:58:46.594]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.594] getGlobalsAndPackages() ...
[10:58:46.594] Searching for globals...
[10:58:46.594] 
[10:58:46.594] Searching for globals ... DONE
[10:58:46.594] - globals: [0] <none>
[10:58:46.594] getGlobalsAndPackages() ... DONE
[10:58:46.594]    + additional globals found: [n=0] 
[10:58:46.594]    + additional namespaces needed: [n=0] 
[10:58:46.594]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.595]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.595]  - seeds: <none>
[10:58:46.595]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.595] getGlobalsAndPackages() ...
[10:58:46.595] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.595] Resolving globals: FALSE
[10:58:46.595] Tweak future expression to call with '...' arguments ...
[10:58:46.595] {
[10:58:46.595]     do.call(function(...) {
[10:58:46.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.595]             on.exit(options(oopts), add = TRUE)
[10:58:46.595]         }
[10:58:46.595]         {
[10:58:46.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.595]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.595]             })
[10:58:46.595]         }
[10:58:46.595]     }, args = future.call.arguments)
[10:58:46.595] }
[10:58:46.595] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.596] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.596] - packages: [1] ‘stats’
[10:58:46.596] getGlobalsAndPackages() ... DONE
[10:58:46.596] run() for ‘Future’ ...
[10:58:46.597] - state: ‘created’
[10:58:46.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.600] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.600]   - Field: ‘label’
[10:58:46.600]   - Field: ‘local’
[10:58:46.600]   - Field: ‘owner’
[10:58:46.600]   - Field: ‘envir’
[10:58:46.601]   - Field: ‘workers’
[10:58:46.601]   - Field: ‘packages’
[10:58:46.601]   - Field: ‘gc’
[10:58:46.601]   - Field: ‘job’
[10:58:46.601]   - Field: ‘conditions’
[10:58:46.601]   - Field: ‘expr’
[10:58:46.601]   - Field: ‘uuid’
[10:58:46.601]   - Field: ‘seed’
[10:58:46.601]   - Field: ‘version’
[10:58:46.601]   - Field: ‘result’
[10:58:46.602]   - Field: ‘asynchronous’
[10:58:46.602]   - Field: ‘calls’
[10:58:46.602]   - Field: ‘globals’
[10:58:46.602]   - Field: ‘stdout’
[10:58:46.602]   - Field: ‘earlySignal’
[10:58:46.602]   - Field: ‘lazy’
[10:58:46.602]   - Field: ‘state’
[10:58:46.602] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.602] - Launch lazy future ...
[10:58:46.603] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.603] Packages needed by future strategies (n = 0): <none>
[10:58:46.603] {
[10:58:46.603]     {
[10:58:46.603]         {
[10:58:46.603]             ...future.startTime <- base::Sys.time()
[10:58:46.603]             {
[10:58:46.603]                 {
[10:58:46.603]                   {
[10:58:46.603]                     {
[10:58:46.603]                       {
[10:58:46.603]                         base::local({
[10:58:46.603]                           has_future <- base::requireNamespace("future", 
[10:58:46.603]                             quietly = TRUE)
[10:58:46.603]                           if (has_future) {
[10:58:46.603]                             ns <- base::getNamespace("future")
[10:58:46.603]                             version <- ns[[".package"]][["version"]]
[10:58:46.603]                             if (is.null(version)) 
[10:58:46.603]                               version <- utils::packageVersion("future")
[10:58:46.603]                           }
[10:58:46.603]                           else {
[10:58:46.603]                             version <- NULL
[10:58:46.603]                           }
[10:58:46.603]                           if (!has_future || version < "1.8.0") {
[10:58:46.603]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.603]                               "", base::R.version$version.string), 
[10:58:46.603]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:46.603]                                 base::R.version$platform, 8 * 
[10:58:46.603]                                   base::.Machine$sizeof.pointer), 
[10:58:46.603]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.603]                                 "release", "version")], collapse = " "), 
[10:58:46.603]                               hostname = base::Sys.info()[["nodename"]])
[10:58:46.603]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.603]                               info)
[10:58:46.603]                             info <- base::paste(info, collapse = "; ")
[10:58:46.603]                             if (!has_future) {
[10:58:46.603]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.603]                                 info)
[10:58:46.603]                             }
[10:58:46.603]                             else {
[10:58:46.603]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.603]                                 info, version)
[10:58:46.603]                             }
[10:58:46.603]                             base::stop(msg)
[10:58:46.603]                           }
[10:58:46.603]                         })
[10:58:46.603]                       }
[10:58:46.603]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.603]                       base::options(mc.cores = 1L)
[10:58:46.603]                     }
[10:58:46.603]                     base::local({
[10:58:46.603]                       for (pkg in "stats") {
[10:58:46.603]                         base::loadNamespace(pkg)
[10:58:46.603]                         base::library(pkg, character.only = TRUE)
[10:58:46.603]                       }
[10:58:46.603]                     })
[10:58:46.603]                   }
[10:58:46.603]                   ...future.strategy.old <- future::plan("list")
[10:58:46.603]                   options(future.plan = NULL)
[10:58:46.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.603]                 }
[10:58:46.603]                 ...future.workdir <- getwd()
[10:58:46.603]             }
[10:58:46.603]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.603]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.603]         }
[10:58:46.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.603]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.603]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.603]             base::names(...future.oldOptions))
[10:58:46.603]     }
[10:58:46.603]     if (FALSE) {
[10:58:46.603]     }
[10:58:46.603]     else {
[10:58:46.603]         if (TRUE) {
[10:58:46.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.603]                 open = "w")
[10:58:46.603]         }
[10:58:46.603]         else {
[10:58:46.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.603]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.603]         }
[10:58:46.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.603]             base::sink(type = "output", split = FALSE)
[10:58:46.603]             base::close(...future.stdout)
[10:58:46.603]         }, add = TRUE)
[10:58:46.603]     }
[10:58:46.603]     ...future.frame <- base::sys.nframe()
[10:58:46.603]     ...future.conditions <- base::list()
[10:58:46.603]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.603]     if (FALSE) {
[10:58:46.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.603]     }
[10:58:46.603]     ...future.result <- base::tryCatch({
[10:58:46.603]         base::withCallingHandlers({
[10:58:46.603]             ...future.value <- base::withVisible(base::local({
[10:58:46.603]                 withCallingHandlers({
[10:58:46.603]                   {
[10:58:46.603]                     do.call(function(...) {
[10:58:46.603]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.603]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.603]                         ...future.globals.maxSize)) {
[10:58:46.603]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.603]                         on.exit(options(oopts), add = TRUE)
[10:58:46.603]                       }
[10:58:46.603]                       {
[10:58:46.603]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.603]                           FUN = function(jj) {
[10:58:46.603]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.603]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.603]                           })
[10:58:46.603]                       }
[10:58:46.603]                     }, args = future.call.arguments)
[10:58:46.603]                   }
[10:58:46.603]                 }, immediateCondition = function(cond) {
[10:58:46.603]                   save_rds <- function (object, pathname, ...) 
[10:58:46.603]                   {
[10:58:46.603]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.603]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.603]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.603]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.603]                         fi_tmp[["mtime"]])
[10:58:46.603]                     }
[10:58:46.603]                     tryCatch({
[10:58:46.603]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.603]                     }, error = function(ex) {
[10:58:46.603]                       msg <- conditionMessage(ex)
[10:58:46.603]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.603]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.603]                         fi_tmp[["mtime"]], msg)
[10:58:46.603]                       ex$message <- msg
[10:58:46.603]                       stop(ex)
[10:58:46.603]                     })
[10:58:46.603]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.603]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.603]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.603]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.603]                       fi <- file.info(pathname)
[10:58:46.603]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.603]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.603]                         fi[["size"]], fi[["mtime"]])
[10:58:46.603]                       stop(msg)
[10:58:46.603]                     }
[10:58:46.603]                     invisible(pathname)
[10:58:46.603]                   }
[10:58:46.603]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.603]                     rootPath = tempdir()) 
[10:58:46.603]                   {
[10:58:46.603]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.603]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.603]                       tmpdir = path, fileext = ".rds")
[10:58:46.603]                     save_rds(obj, file)
[10:58:46.603]                   }
[10:58:46.603]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.603]                   {
[10:58:46.603]                     inherits <- base::inherits
[10:58:46.603]                     invokeRestart <- base::invokeRestart
[10:58:46.603]                     is.null <- base::is.null
[10:58:46.603]                     muffled <- FALSE
[10:58:46.603]                     if (inherits(cond, "message")) {
[10:58:46.603]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.603]                       if (muffled) 
[10:58:46.603]                         invokeRestart("muffleMessage")
[10:58:46.603]                     }
[10:58:46.603]                     else if (inherits(cond, "warning")) {
[10:58:46.603]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.603]                       if (muffled) 
[10:58:46.603]                         invokeRestart("muffleWarning")
[10:58:46.603]                     }
[10:58:46.603]                     else if (inherits(cond, "condition")) {
[10:58:46.603]                       if (!is.null(pattern)) {
[10:58:46.603]                         computeRestarts <- base::computeRestarts
[10:58:46.603]                         grepl <- base::grepl
[10:58:46.603]                         restarts <- computeRestarts(cond)
[10:58:46.603]                         for (restart in restarts) {
[10:58:46.603]                           name <- restart$name
[10:58:46.603]                           if (is.null(name)) 
[10:58:46.603]                             next
[10:58:46.603]                           if (!grepl(pattern, name)) 
[10:58:46.603]                             next
[10:58:46.603]                           invokeRestart(restart)
[10:58:46.603]                           muffled <- TRUE
[10:58:46.603]                           break
[10:58:46.603]                         }
[10:58:46.603]                       }
[10:58:46.603]                     }
[10:58:46.603]                     invisible(muffled)
[10:58:46.603]                   }
[10:58:46.603]                   muffleCondition(cond)
[10:58:46.603]                 })
[10:58:46.603]             }))
[10:58:46.603]             future::FutureResult(value = ...future.value$value, 
[10:58:46.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.603]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.603]                     ...future.globalenv.names))
[10:58:46.603]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.603]         }, condition = base::local({
[10:58:46.603]             c <- base::c
[10:58:46.603]             inherits <- base::inherits
[10:58:46.603]             invokeRestart <- base::invokeRestart
[10:58:46.603]             length <- base::length
[10:58:46.603]             list <- base::list
[10:58:46.603]             seq.int <- base::seq.int
[10:58:46.603]             signalCondition <- base::signalCondition
[10:58:46.603]             sys.calls <- base::sys.calls
[10:58:46.603]             `[[` <- base::`[[`
[10:58:46.603]             `+` <- base::`+`
[10:58:46.603]             `<<-` <- base::`<<-`
[10:58:46.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.603]                   3L)]
[10:58:46.603]             }
[10:58:46.603]             function(cond) {
[10:58:46.603]                 is_error <- inherits(cond, "error")
[10:58:46.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.603]                   NULL)
[10:58:46.603]                 if (is_error) {
[10:58:46.603]                   sessionInformation <- function() {
[10:58:46.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.603]                       search = base::search(), system = base::Sys.info())
[10:58:46.603]                   }
[10:58:46.603]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.603]                     cond$call), session = sessionInformation(), 
[10:58:46.603]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.603]                   signalCondition(cond)
[10:58:46.603]                 }
[10:58:46.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.603]                 "immediateCondition"))) {
[10:58:46.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.603]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.603]                   if (TRUE && !signal) {
[10:58:46.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.603]                     {
[10:58:46.603]                       inherits <- base::inherits
[10:58:46.603]                       invokeRestart <- base::invokeRestart
[10:58:46.603]                       is.null <- base::is.null
[10:58:46.603]                       muffled <- FALSE
[10:58:46.603]                       if (inherits(cond, "message")) {
[10:58:46.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.603]                         if (muffled) 
[10:58:46.603]                           invokeRestart("muffleMessage")
[10:58:46.603]                       }
[10:58:46.603]                       else if (inherits(cond, "warning")) {
[10:58:46.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.603]                         if (muffled) 
[10:58:46.603]                           invokeRestart("muffleWarning")
[10:58:46.603]                       }
[10:58:46.603]                       else if (inherits(cond, "condition")) {
[10:58:46.603]                         if (!is.null(pattern)) {
[10:58:46.603]                           computeRestarts <- base::computeRestarts
[10:58:46.603]                           grepl <- base::grepl
[10:58:46.603]                           restarts <- computeRestarts(cond)
[10:58:46.603]                           for (restart in restarts) {
[10:58:46.603]                             name <- restart$name
[10:58:46.603]                             if (is.null(name)) 
[10:58:46.603]                               next
[10:58:46.603]                             if (!grepl(pattern, name)) 
[10:58:46.603]                               next
[10:58:46.603]                             invokeRestart(restart)
[10:58:46.603]                             muffled <- TRUE
[10:58:46.603]                             break
[10:58:46.603]                           }
[10:58:46.603]                         }
[10:58:46.603]                       }
[10:58:46.603]                       invisible(muffled)
[10:58:46.603]                     }
[10:58:46.603]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.603]                   }
[10:58:46.603]                 }
[10:58:46.603]                 else {
[10:58:46.603]                   if (TRUE) {
[10:58:46.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.603]                     {
[10:58:46.603]                       inherits <- base::inherits
[10:58:46.603]                       invokeRestart <- base::invokeRestart
[10:58:46.603]                       is.null <- base::is.null
[10:58:46.603]                       muffled <- FALSE
[10:58:46.603]                       if (inherits(cond, "message")) {
[10:58:46.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.603]                         if (muffled) 
[10:58:46.603]                           invokeRestart("muffleMessage")
[10:58:46.603]                       }
[10:58:46.603]                       else if (inherits(cond, "warning")) {
[10:58:46.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.603]                         if (muffled) 
[10:58:46.603]                           invokeRestart("muffleWarning")
[10:58:46.603]                       }
[10:58:46.603]                       else if (inherits(cond, "condition")) {
[10:58:46.603]                         if (!is.null(pattern)) {
[10:58:46.603]                           computeRestarts <- base::computeRestarts
[10:58:46.603]                           grepl <- base::grepl
[10:58:46.603]                           restarts <- computeRestarts(cond)
[10:58:46.603]                           for (restart in restarts) {
[10:58:46.603]                             name <- restart$name
[10:58:46.603]                             if (is.null(name)) 
[10:58:46.603]                               next
[10:58:46.603]                             if (!grepl(pattern, name)) 
[10:58:46.603]                               next
[10:58:46.603]                             invokeRestart(restart)
[10:58:46.603]                             muffled <- TRUE
[10:58:46.603]                             break
[10:58:46.603]                           }
[10:58:46.603]                         }
[10:58:46.603]                       }
[10:58:46.603]                       invisible(muffled)
[10:58:46.603]                     }
[10:58:46.603]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.603]                   }
[10:58:46.603]                 }
[10:58:46.603]             }
[10:58:46.603]         }))
[10:58:46.603]     }, error = function(ex) {
[10:58:46.603]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.603]                 ...future.rng), started = ...future.startTime, 
[10:58:46.603]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.603]             version = "1.8"), class = "FutureResult")
[10:58:46.603]     }, finally = {
[10:58:46.603]         if (!identical(...future.workdir, getwd())) 
[10:58:46.603]             setwd(...future.workdir)
[10:58:46.603]         {
[10:58:46.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.603]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.603]             }
[10:58:46.603]             base::options(...future.oldOptions)
[10:58:46.603]             if (.Platform$OS.type == "windows") {
[10:58:46.603]                 old_names <- names(...future.oldEnvVars)
[10:58:46.603]                 envs <- base::Sys.getenv()
[10:58:46.603]                 names <- names(envs)
[10:58:46.603]                 common <- intersect(names, old_names)
[10:58:46.603]                 added <- setdiff(names, old_names)
[10:58:46.603]                 removed <- setdiff(old_names, names)
[10:58:46.603]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.603]                   envs[common]]
[10:58:46.603]                 NAMES <- toupper(changed)
[10:58:46.603]                 args <- list()
[10:58:46.603]                 for (kk in seq_along(NAMES)) {
[10:58:46.603]                   name <- changed[[kk]]
[10:58:46.603]                   NAME <- NAMES[[kk]]
[10:58:46.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.603]                     next
[10:58:46.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.603]                 }
[10:58:46.603]                 NAMES <- toupper(added)
[10:58:46.603]                 for (kk in seq_along(NAMES)) {
[10:58:46.603]                   name <- added[[kk]]
[10:58:46.603]                   NAME <- NAMES[[kk]]
[10:58:46.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.603]                     next
[10:58:46.603]                   args[[name]] <- ""
[10:58:46.603]                 }
[10:58:46.603]                 NAMES <- toupper(removed)
[10:58:46.603]                 for (kk in seq_along(NAMES)) {
[10:58:46.603]                   name <- removed[[kk]]
[10:58:46.603]                   NAME <- NAMES[[kk]]
[10:58:46.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.603]                     next
[10:58:46.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.603]                 }
[10:58:46.603]                 if (length(args) > 0) 
[10:58:46.603]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.603]             }
[10:58:46.603]             else {
[10:58:46.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.603]             }
[10:58:46.603]             {
[10:58:46.603]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.603]                   0L) {
[10:58:46.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.603]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.603]                   base::options(opts)
[10:58:46.603]                 }
[10:58:46.603]                 {
[10:58:46.603]                   {
[10:58:46.603]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.603]                     NULL
[10:58:46.603]                   }
[10:58:46.603]                   options(future.plan = NULL)
[10:58:46.603]                   if (is.na(NA_character_)) 
[10:58:46.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.603]                     .init = FALSE)
[10:58:46.603]                 }
[10:58:46.603]             }
[10:58:46.603]         }
[10:58:46.603]     })
[10:58:46.603]     if (TRUE) {
[10:58:46.603]         base::sink(type = "output", split = FALSE)
[10:58:46.603]         if (TRUE) {
[10:58:46.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.603]         }
[10:58:46.603]         else {
[10:58:46.603]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.603]         }
[10:58:46.603]         base::close(...future.stdout)
[10:58:46.603]         ...future.stdout <- NULL
[10:58:46.603]     }
[10:58:46.603]     ...future.result$conditions <- ...future.conditions
[10:58:46.603]     ...future.result$finished <- base::Sys.time()
[10:58:46.603]     ...future.result
[10:58:46.603] }
[10:58:46.606] assign_globals() ...
[10:58:46.606] List of 5
[10:58:46.606]  $ ...future.FUN            :function (x, ...)  
[10:58:46.606]  $ future.call.arguments    : list()
[10:58:46.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.606]  $ ...future.elements_ii    :List of 1
[10:58:46.606]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.606]  $ ...future.seeds_ii       : NULL
[10:58:46.606]  $ ...future.globals.maxSize: NULL
[10:58:46.606]  - attr(*, "where")=List of 5
[10:58:46.606]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.606]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.606]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.606]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.606]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.606]  - attr(*, "resolved")= logi FALSE
[10:58:46.606]  - attr(*, "total_size")= num 5433
[10:58:46.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.606]  - attr(*, "already-done")= logi TRUE
[10:58:46.610] - copied ‘...future.FUN’ to environment
[10:58:46.611] - copied ‘future.call.arguments’ to environment
[10:58:46.611] - copied ‘...future.elements_ii’ to environment
[10:58:46.611] - copied ‘...future.seeds_ii’ to environment
[10:58:46.611] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.611] assign_globals() ... done
[10:58:46.611] requestCore(): workers = 2
[10:58:46.613] MulticoreFuture started
[10:58:46.614] - Launch lazy future ... done
[10:58:46.614] run() for ‘MulticoreFuture’ ... done
[10:58:46.614] Created future:
[10:58:46.614] plan(): Setting new future strategy stack:
[10:58:46.615] List of future strategies:
[10:58:46.615] 1. sequential:
[10:58:46.615]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.615]    - tweaked: FALSE
[10:58:46.615]    - call: NULL
[10:58:46.616] plan(): nbrOfWorkers() = 1
[10:58:46.618] plan(): Setting new future strategy stack:
[10:58:46.618] List of future strategies:
[10:58:46.618] 1. multicore:
[10:58:46.618]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.618]    - tweaked: FALSE
[10:58:46.618]    - call: plan(strategy)
[10:58:46.621] plan(): nbrOfWorkers() = 2
[10:58:46.614] MulticoreFuture:
[10:58:46.614] Label: ‘future_eapply-1’
[10:58:46.614] Expression:
[10:58:46.614] {
[10:58:46.614]     do.call(function(...) {
[10:58:46.614]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.614]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.614]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.614]             on.exit(options(oopts), add = TRUE)
[10:58:46.614]         }
[10:58:46.614]         {
[10:58:46.614]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.614]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.614]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.614]             })
[10:58:46.614]         }
[10:58:46.614]     }, args = future.call.arguments)
[10:58:46.614] }
[10:58:46.614] Lazy evaluation: FALSE
[10:58:46.614] Asynchronous evaluation: TRUE
[10:58:46.614] Local evaluation: TRUE
[10:58:46.614] Environment: R_GlobalEnv
[10:58:46.614] Capture standard output: TRUE
[10:58:46.614] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.614] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.614] Packages: 1 packages (‘stats’)
[10:58:46.614] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.614] Resolved: TRUE
[10:58:46.614] Value: <not collected>
[10:58:46.614] Conditions captured: <none>
[10:58:46.614] Early signaling: FALSE
[10:58:46.614] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.614] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.622] Chunk #1 of 2 ... DONE
[10:58:46.622] Chunk #2 of 2 ...
[10:58:46.623]  - Finding globals in 'X' for chunk #2 ...
[10:58:46.623] getGlobalsAndPackages() ...
[10:58:46.623] Searching for globals...
[10:58:46.623] 
[10:58:46.624] Searching for globals ... DONE
[10:58:46.624] - globals: [0] <none>
[10:58:46.624] getGlobalsAndPackages() ... DONE
[10:58:46.624]    + additional globals found: [n=0] 
[10:58:46.624]    + additional namespaces needed: [n=0] 
[10:58:46.624]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:46.624]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.624]  - seeds: <none>
[10:58:46.624]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.625] getGlobalsAndPackages() ...
[10:58:46.625] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.625] Resolving globals: FALSE
[10:58:46.625] Tweak future expression to call with '...' arguments ...
[10:58:46.625] {
[10:58:46.625]     do.call(function(...) {
[10:58:46.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.625]             on.exit(options(oopts), add = TRUE)
[10:58:46.625]         }
[10:58:46.625]         {
[10:58:46.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.625]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.625]             })
[10:58:46.625]         }
[10:58:46.625]     }, args = future.call.arguments)
[10:58:46.625] }
[10:58:46.626] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.626] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.627] - packages: [1] ‘stats’
[10:58:46.627] getGlobalsAndPackages() ... DONE
[10:58:46.627] run() for ‘Future’ ...
[10:58:46.627] - state: ‘created’
[10:58:46.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.630] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.630] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.630]   - Field: ‘label’
[10:58:46.631]   - Field: ‘local’
[10:58:46.631]   - Field: ‘owner’
[10:58:46.631]   - Field: ‘envir’
[10:58:46.631]   - Field: ‘workers’
[10:58:46.631]   - Field: ‘packages’
[10:58:46.631]   - Field: ‘gc’
[10:58:46.631]   - Field: ‘job’
[10:58:46.632]   - Field: ‘conditions’
[10:58:46.632]   - Field: ‘expr’
[10:58:46.632]   - Field: ‘uuid’
[10:58:46.632]   - Field: ‘seed’
[10:58:46.632]   - Field: ‘version’
[10:58:46.632]   - Field: ‘result’
[10:58:46.632]   - Field: ‘asynchronous’
[10:58:46.632]   - Field: ‘calls’
[10:58:46.633]   - Field: ‘globals’
[10:58:46.633]   - Field: ‘stdout’
[10:58:46.633]   - Field: ‘earlySignal’
[10:58:46.633]   - Field: ‘lazy’
[10:58:46.633]   - Field: ‘state’
[10:58:46.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.633] - Launch lazy future ...
[10:58:46.634] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.634] Packages needed by future strategies (n = 0): <none>
[10:58:46.635] {
[10:58:46.635]     {
[10:58:46.635]         {
[10:58:46.635]             ...future.startTime <- base::Sys.time()
[10:58:46.635]             {
[10:58:46.635]                 {
[10:58:46.635]                   {
[10:58:46.635]                     {
[10:58:46.635]                       {
[10:58:46.635]                         base::local({
[10:58:46.635]                           has_future <- base::requireNamespace("future", 
[10:58:46.635]                             quietly = TRUE)
[10:58:46.635]                           if (has_future) {
[10:58:46.635]                             ns <- base::getNamespace("future")
[10:58:46.635]                             version <- ns[[".package"]][["version"]]
[10:58:46.635]                             if (is.null(version)) 
[10:58:46.635]                               version <- utils::packageVersion("future")
[10:58:46.635]                           }
[10:58:46.635]                           else {
[10:58:46.635]                             version <- NULL
[10:58:46.635]                           }
[10:58:46.635]                           if (!has_future || version < "1.8.0") {
[10:58:46.635]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.635]                               "", base::R.version$version.string), 
[10:58:46.635]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:46.635]                                 base::R.version$platform, 8 * 
[10:58:46.635]                                   base::.Machine$sizeof.pointer), 
[10:58:46.635]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.635]                                 "release", "version")], collapse = " "), 
[10:58:46.635]                               hostname = base::Sys.info()[["nodename"]])
[10:58:46.635]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.635]                               info)
[10:58:46.635]                             info <- base::paste(info, collapse = "; ")
[10:58:46.635]                             if (!has_future) {
[10:58:46.635]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.635]                                 info)
[10:58:46.635]                             }
[10:58:46.635]                             else {
[10:58:46.635]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.635]                                 info, version)
[10:58:46.635]                             }
[10:58:46.635]                             base::stop(msg)
[10:58:46.635]                           }
[10:58:46.635]                         })
[10:58:46.635]                       }
[10:58:46.635]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.635]                       base::options(mc.cores = 1L)
[10:58:46.635]                     }
[10:58:46.635]                     base::local({
[10:58:46.635]                       for (pkg in "stats") {
[10:58:46.635]                         base::loadNamespace(pkg)
[10:58:46.635]                         base::library(pkg, character.only = TRUE)
[10:58:46.635]                       }
[10:58:46.635]                     })
[10:58:46.635]                   }
[10:58:46.635]                   ...future.strategy.old <- future::plan("list")
[10:58:46.635]                   options(future.plan = NULL)
[10:58:46.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.635]                 }
[10:58:46.635]                 ...future.workdir <- getwd()
[10:58:46.635]             }
[10:58:46.635]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.635]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.635]         }
[10:58:46.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.635]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.635]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.635]             base::names(...future.oldOptions))
[10:58:46.635]     }
[10:58:46.635]     if (FALSE) {
[10:58:46.635]     }
[10:58:46.635]     else {
[10:58:46.635]         if (TRUE) {
[10:58:46.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.635]                 open = "w")
[10:58:46.635]         }
[10:58:46.635]         else {
[10:58:46.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.635]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.635]         }
[10:58:46.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.635]             base::sink(type = "output", split = FALSE)
[10:58:46.635]             base::close(...future.stdout)
[10:58:46.635]         }, add = TRUE)
[10:58:46.635]     }
[10:58:46.635]     ...future.frame <- base::sys.nframe()
[10:58:46.635]     ...future.conditions <- base::list()
[10:58:46.635]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.635]     if (FALSE) {
[10:58:46.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.635]     }
[10:58:46.635]     ...future.result <- base::tryCatch({
[10:58:46.635]         base::withCallingHandlers({
[10:58:46.635]             ...future.value <- base::withVisible(base::local({
[10:58:46.635]                 withCallingHandlers({
[10:58:46.635]                   {
[10:58:46.635]                     do.call(function(...) {
[10:58:46.635]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.635]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.635]                         ...future.globals.maxSize)) {
[10:58:46.635]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.635]                         on.exit(options(oopts), add = TRUE)
[10:58:46.635]                       }
[10:58:46.635]                       {
[10:58:46.635]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.635]                           FUN = function(jj) {
[10:58:46.635]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.635]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.635]                           })
[10:58:46.635]                       }
[10:58:46.635]                     }, args = future.call.arguments)
[10:58:46.635]                   }
[10:58:46.635]                 }, immediateCondition = function(cond) {
[10:58:46.635]                   save_rds <- function (object, pathname, ...) 
[10:58:46.635]                   {
[10:58:46.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.635]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.635]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.635]                         fi_tmp[["mtime"]])
[10:58:46.635]                     }
[10:58:46.635]                     tryCatch({
[10:58:46.635]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.635]                     }, error = function(ex) {
[10:58:46.635]                       msg <- conditionMessage(ex)
[10:58:46.635]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.635]                         fi_tmp[["mtime"]], msg)
[10:58:46.635]                       ex$message <- msg
[10:58:46.635]                       stop(ex)
[10:58:46.635]                     })
[10:58:46.635]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.635]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.635]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.635]                       fi <- file.info(pathname)
[10:58:46.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.635]                         fi[["size"]], fi[["mtime"]])
[10:58:46.635]                       stop(msg)
[10:58:46.635]                     }
[10:58:46.635]                     invisible(pathname)
[10:58:46.635]                   }
[10:58:46.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.635]                     rootPath = tempdir()) 
[10:58:46.635]                   {
[10:58:46.635]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.635]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.635]                       tmpdir = path, fileext = ".rds")
[10:58:46.635]                     save_rds(obj, file)
[10:58:46.635]                   }
[10:58:46.635]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.635]                   {
[10:58:46.635]                     inherits <- base::inherits
[10:58:46.635]                     invokeRestart <- base::invokeRestart
[10:58:46.635]                     is.null <- base::is.null
[10:58:46.635]                     muffled <- FALSE
[10:58:46.635]                     if (inherits(cond, "message")) {
[10:58:46.635]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.635]                       if (muffled) 
[10:58:46.635]                         invokeRestart("muffleMessage")
[10:58:46.635]                     }
[10:58:46.635]                     else if (inherits(cond, "warning")) {
[10:58:46.635]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.635]                       if (muffled) 
[10:58:46.635]                         invokeRestart("muffleWarning")
[10:58:46.635]                     }
[10:58:46.635]                     else if (inherits(cond, "condition")) {
[10:58:46.635]                       if (!is.null(pattern)) {
[10:58:46.635]                         computeRestarts <- base::computeRestarts
[10:58:46.635]                         grepl <- base::grepl
[10:58:46.635]                         restarts <- computeRestarts(cond)
[10:58:46.635]                         for (restart in restarts) {
[10:58:46.635]                           name <- restart$name
[10:58:46.635]                           if (is.null(name)) 
[10:58:46.635]                             next
[10:58:46.635]                           if (!grepl(pattern, name)) 
[10:58:46.635]                             next
[10:58:46.635]                           invokeRestart(restart)
[10:58:46.635]                           muffled <- TRUE
[10:58:46.635]                           break
[10:58:46.635]                         }
[10:58:46.635]                       }
[10:58:46.635]                     }
[10:58:46.635]                     invisible(muffled)
[10:58:46.635]                   }
[10:58:46.635]                   muffleCondition(cond)
[10:58:46.635]                 })
[10:58:46.635]             }))
[10:58:46.635]             future::FutureResult(value = ...future.value$value, 
[10:58:46.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.635]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.635]                     ...future.globalenv.names))
[10:58:46.635]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.635]         }, condition = base::local({
[10:58:46.635]             c <- base::c
[10:58:46.635]             inherits <- base::inherits
[10:58:46.635]             invokeRestart <- base::invokeRestart
[10:58:46.635]             length <- base::length
[10:58:46.635]             list <- base::list
[10:58:46.635]             seq.int <- base::seq.int
[10:58:46.635]             signalCondition <- base::signalCondition
[10:58:46.635]             sys.calls <- base::sys.calls
[10:58:46.635]             `[[` <- base::`[[`
[10:58:46.635]             `+` <- base::`+`
[10:58:46.635]             `<<-` <- base::`<<-`
[10:58:46.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.635]                   3L)]
[10:58:46.635]             }
[10:58:46.635]             function(cond) {
[10:58:46.635]                 is_error <- inherits(cond, "error")
[10:58:46.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.635]                   NULL)
[10:58:46.635]                 if (is_error) {
[10:58:46.635]                   sessionInformation <- function() {
[10:58:46.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.635]                       search = base::search(), system = base::Sys.info())
[10:58:46.635]                   }
[10:58:46.635]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.635]                     cond$call), session = sessionInformation(), 
[10:58:46.635]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.635]                   signalCondition(cond)
[10:58:46.635]                 }
[10:58:46.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.635]                 "immediateCondition"))) {
[10:58:46.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.635]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.635]                   if (TRUE && !signal) {
[10:58:46.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.635]                     {
[10:58:46.635]                       inherits <- base::inherits
[10:58:46.635]                       invokeRestart <- base::invokeRestart
[10:58:46.635]                       is.null <- base::is.null
[10:58:46.635]                       muffled <- FALSE
[10:58:46.635]                       if (inherits(cond, "message")) {
[10:58:46.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.635]                         if (muffled) 
[10:58:46.635]                           invokeRestart("muffleMessage")
[10:58:46.635]                       }
[10:58:46.635]                       else if (inherits(cond, "warning")) {
[10:58:46.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.635]                         if (muffled) 
[10:58:46.635]                           invokeRestart("muffleWarning")
[10:58:46.635]                       }
[10:58:46.635]                       else if (inherits(cond, "condition")) {
[10:58:46.635]                         if (!is.null(pattern)) {
[10:58:46.635]                           computeRestarts <- base::computeRestarts
[10:58:46.635]                           grepl <- base::grepl
[10:58:46.635]                           restarts <- computeRestarts(cond)
[10:58:46.635]                           for (restart in restarts) {
[10:58:46.635]                             name <- restart$name
[10:58:46.635]                             if (is.null(name)) 
[10:58:46.635]                               next
[10:58:46.635]                             if (!grepl(pattern, name)) 
[10:58:46.635]                               next
[10:58:46.635]                             invokeRestart(restart)
[10:58:46.635]                             muffled <- TRUE
[10:58:46.635]                             break
[10:58:46.635]                           }
[10:58:46.635]                         }
[10:58:46.635]                       }
[10:58:46.635]                       invisible(muffled)
[10:58:46.635]                     }
[10:58:46.635]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.635]                   }
[10:58:46.635]                 }
[10:58:46.635]                 else {
[10:58:46.635]                   if (TRUE) {
[10:58:46.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.635]                     {
[10:58:46.635]                       inherits <- base::inherits
[10:58:46.635]                       invokeRestart <- base::invokeRestart
[10:58:46.635]                       is.null <- base::is.null
[10:58:46.635]                       muffled <- FALSE
[10:58:46.635]                       if (inherits(cond, "message")) {
[10:58:46.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.635]                         if (muffled) 
[10:58:46.635]                           invokeRestart("muffleMessage")
[10:58:46.635]                       }
[10:58:46.635]                       else if (inherits(cond, "warning")) {
[10:58:46.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.635]                         if (muffled) 
[10:58:46.635]                           invokeRestart("muffleWarning")
[10:58:46.635]                       }
[10:58:46.635]                       else if (inherits(cond, "condition")) {
[10:58:46.635]                         if (!is.null(pattern)) {
[10:58:46.635]                           computeRestarts <- base::computeRestarts
[10:58:46.635]                           grepl <- base::grepl
[10:58:46.635]                           restarts <- computeRestarts(cond)
[10:58:46.635]                           for (restart in restarts) {
[10:58:46.635]                             name <- restart$name
[10:58:46.635]                             if (is.null(name)) 
[10:58:46.635]                               next
[10:58:46.635]                             if (!grepl(pattern, name)) 
[10:58:46.635]                               next
[10:58:46.635]                             invokeRestart(restart)
[10:58:46.635]                             muffled <- TRUE
[10:58:46.635]                             break
[10:58:46.635]                           }
[10:58:46.635]                         }
[10:58:46.635]                       }
[10:58:46.635]                       invisible(muffled)
[10:58:46.635]                     }
[10:58:46.635]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.635]                   }
[10:58:46.635]                 }
[10:58:46.635]             }
[10:58:46.635]         }))
[10:58:46.635]     }, error = function(ex) {
[10:58:46.635]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.635]                 ...future.rng), started = ...future.startTime, 
[10:58:46.635]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.635]             version = "1.8"), class = "FutureResult")
[10:58:46.635]     }, finally = {
[10:58:46.635]         if (!identical(...future.workdir, getwd())) 
[10:58:46.635]             setwd(...future.workdir)
[10:58:46.635]         {
[10:58:46.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.635]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.635]             }
[10:58:46.635]             base::options(...future.oldOptions)
[10:58:46.635]             if (.Platform$OS.type == "windows") {
[10:58:46.635]                 old_names <- names(...future.oldEnvVars)
[10:58:46.635]                 envs <- base::Sys.getenv()
[10:58:46.635]                 names <- names(envs)
[10:58:46.635]                 common <- intersect(names, old_names)
[10:58:46.635]                 added <- setdiff(names, old_names)
[10:58:46.635]                 removed <- setdiff(old_names, names)
[10:58:46.635]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.635]                   envs[common]]
[10:58:46.635]                 NAMES <- toupper(changed)
[10:58:46.635]                 args <- list()
[10:58:46.635]                 for (kk in seq_along(NAMES)) {
[10:58:46.635]                   name <- changed[[kk]]
[10:58:46.635]                   NAME <- NAMES[[kk]]
[10:58:46.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.635]                     next
[10:58:46.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.635]                 }
[10:58:46.635]                 NAMES <- toupper(added)
[10:58:46.635]                 for (kk in seq_along(NAMES)) {
[10:58:46.635]                   name <- added[[kk]]
[10:58:46.635]                   NAME <- NAMES[[kk]]
[10:58:46.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.635]                     next
[10:58:46.635]                   args[[name]] <- ""
[10:58:46.635]                 }
[10:58:46.635]                 NAMES <- toupper(removed)
[10:58:46.635]                 for (kk in seq_along(NAMES)) {
[10:58:46.635]                   name <- removed[[kk]]
[10:58:46.635]                   NAME <- NAMES[[kk]]
[10:58:46.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.635]                     next
[10:58:46.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.635]                 }
[10:58:46.635]                 if (length(args) > 0) 
[10:58:46.635]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.635]             }
[10:58:46.635]             else {
[10:58:46.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.635]             }
[10:58:46.635]             {
[10:58:46.635]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.635]                   0L) {
[10:58:46.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.635]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.635]                   base::options(opts)
[10:58:46.635]                 }
[10:58:46.635]                 {
[10:58:46.635]                   {
[10:58:46.635]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.635]                     NULL
[10:58:46.635]                   }
[10:58:46.635]                   options(future.plan = NULL)
[10:58:46.635]                   if (is.na(NA_character_)) 
[10:58:46.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.635]                     .init = FALSE)
[10:58:46.635]                 }
[10:58:46.635]             }
[10:58:46.635]         }
[10:58:46.635]     })
[10:58:46.635]     if (TRUE) {
[10:58:46.635]         base::sink(type = "output", split = FALSE)
[10:58:46.635]         if (TRUE) {
[10:58:46.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.635]         }
[10:58:46.635]         else {
[10:58:46.635]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.635]         }
[10:58:46.635]         base::close(...future.stdout)
[10:58:46.635]         ...future.stdout <- NULL
[10:58:46.635]     }
[10:58:46.635]     ...future.result$conditions <- ...future.conditions
[10:58:46.635]     ...future.result$finished <- base::Sys.time()
[10:58:46.635]     ...future.result
[10:58:46.635] }
[10:58:46.638] assign_globals() ...
[10:58:46.638] List of 5
[10:58:46.638]  $ ...future.FUN            :function (x, ...)  
[10:58:46.638]  $ future.call.arguments    : list()
[10:58:46.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.638]  $ ...future.elements_ii    :List of 2
[10:58:46.638]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.638]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.638]  $ ...future.seeds_ii       : NULL
[10:58:46.638]  $ ...future.globals.maxSize: NULL
[10:58:46.638]  - attr(*, "where")=List of 5
[10:58:46.638]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.638]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.638]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.638]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.638]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.638]  - attr(*, "resolved")= logi FALSE
[10:58:46.638]  - attr(*, "total_size")= num 5433
[10:58:46.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.638]  - attr(*, "already-done")= logi TRUE
[10:58:46.649] - copied ‘...future.FUN’ to environment
[10:58:46.649] - copied ‘future.call.arguments’ to environment
[10:58:46.649] - copied ‘...future.elements_ii’ to environment
[10:58:46.650] - copied ‘...future.seeds_ii’ to environment
[10:58:46.650] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.650] assign_globals() ... done
[10:58:46.650] requestCore(): workers = 2
[10:58:46.652] MulticoreFuture started
[10:58:46.653] - Launch lazy future ... done
[10:58:46.653] run() for ‘MulticoreFuture’ ... done
[10:58:46.653] Created future:
[10:58:46.654] plan(): Setting new future strategy stack:
[10:58:46.654] List of future strategies:
[10:58:46.654] 1. sequential:
[10:58:46.654]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.654]    - tweaked: FALSE
[10:58:46.654]    - call: NULL
[10:58:46.655] plan(): nbrOfWorkers() = 1
[10:58:46.658] plan(): Setting new future strategy stack:
[10:58:46.658] List of future strategies:
[10:58:46.658] 1. multicore:
[10:58:46.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.658]    - tweaked: FALSE
[10:58:46.658]    - call: plan(strategy)
[10:58:46.661] plan(): nbrOfWorkers() = 2
[10:58:46.653] MulticoreFuture:
[10:58:46.653] Label: ‘future_eapply-2’
[10:58:46.653] Expression:
[10:58:46.653] {
[10:58:46.653]     do.call(function(...) {
[10:58:46.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.653]             on.exit(options(oopts), add = TRUE)
[10:58:46.653]         }
[10:58:46.653]         {
[10:58:46.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.653]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.653]             })
[10:58:46.653]         }
[10:58:46.653]     }, args = future.call.arguments)
[10:58:46.653] }
[10:58:46.653] Lazy evaluation: FALSE
[10:58:46.653] Asynchronous evaluation: TRUE
[10:58:46.653] Local evaluation: TRUE
[10:58:46.653] Environment: R_GlobalEnv
[10:58:46.653] Capture standard output: TRUE
[10:58:46.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.653] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.653] Packages: 1 packages (‘stats’)
[10:58:46.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.653] Resolved: TRUE
[10:58:46.653] Value: <not collected>
[10:58:46.653] Conditions captured: <none>
[10:58:46.653] Early signaling: FALSE
[10:58:46.653] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.653] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.662] Chunk #2 of 2 ... DONE
[10:58:46.662] Launching 2 futures (chunks) ... DONE
[10:58:46.662] Resolving 2 futures (chunks) ...
[10:58:46.663] resolve() on list ...
[10:58:46.663]  recursive: 0
[10:58:46.663]  length: 2
[10:58:46.663] 
[10:58:46.663] Future #1
[10:58:46.664] result() for MulticoreFuture ...
[10:58:46.664] result() for MulticoreFuture ...
[10:58:46.665] result() for MulticoreFuture ... done
[10:58:46.665] result() for MulticoreFuture ... done
[10:58:46.665] result() for MulticoreFuture ...
[10:58:46.665] result() for MulticoreFuture ... done
[10:58:46.665] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:46.665] - nx: 2
[10:58:46.665] - relay: TRUE
[10:58:46.666] - stdout: TRUE
[10:58:46.666] - signal: TRUE
[10:58:46.666] - resignal: FALSE
[10:58:46.666] - force: TRUE
[10:58:46.666] - relayed: [n=2] FALSE, FALSE
[10:58:46.666] - queued futures: [n=2] FALSE, FALSE
[10:58:46.666]  - until=1
[10:58:46.667]  - relaying element #1
[10:58:46.667] result() for MulticoreFuture ...
[10:58:46.667] result() for MulticoreFuture ... done
[10:58:46.667] result() for MulticoreFuture ...
[10:58:46.667] result() for MulticoreFuture ... done
[10:58:46.667] result() for MulticoreFuture ...
[10:58:46.667] result() for MulticoreFuture ... done
[10:58:46.668] result() for MulticoreFuture ...
[10:58:46.668] result() for MulticoreFuture ... done
[10:58:46.668] - relayed: [n=2] TRUE, FALSE
[10:58:46.668] - queued futures: [n=2] TRUE, FALSE
[10:58:46.668] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:46.668]  length: 1 (resolved future 1)
[10:58:46.669] Future #2
[10:58:46.669] result() for MulticoreFuture ...
[10:58:46.669] result() for MulticoreFuture ...
[10:58:46.670] result() for MulticoreFuture ... done
[10:58:46.670] result() for MulticoreFuture ... done
[10:58:46.670] result() for MulticoreFuture ...
[10:58:46.670] result() for MulticoreFuture ... done
[10:58:46.670] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:46.670] - nx: 2
[10:58:46.670] - relay: TRUE
[10:58:46.671] - stdout: TRUE
[10:58:46.671] - signal: TRUE
[10:58:46.671] - resignal: FALSE
[10:58:46.671] - force: TRUE
[10:58:46.671] - relayed: [n=2] TRUE, FALSE
[10:58:46.671] - queued futures: [n=2] TRUE, FALSE
[10:58:46.671]  - until=2
[10:58:46.671]  - relaying element #2
[10:58:46.671] result() for MulticoreFuture ...
[10:58:46.672] result() for MulticoreFuture ... done
[10:58:46.672] result() for MulticoreFuture ...
[10:58:46.672] result() for MulticoreFuture ... done
[10:58:46.672] result() for MulticoreFuture ...
[10:58:46.672] result() for MulticoreFuture ... done
[10:58:46.672] result() for MulticoreFuture ...
[10:58:46.672] result() for MulticoreFuture ... done
[10:58:46.672] - relayed: [n=2] TRUE, TRUE
[10:58:46.672] - queued futures: [n=2] TRUE, TRUE
[10:58:46.673] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:46.673]  length: 0 (resolved future 2)
[10:58:46.673] Relaying remaining futures
[10:58:46.673] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.673] - nx: 2
[10:58:46.673] - relay: TRUE
[10:58:46.673] - stdout: TRUE
[10:58:46.673] - signal: TRUE
[10:58:46.673] - resignal: FALSE
[10:58:46.674] - force: TRUE
[10:58:46.674] - relayed: [n=2] TRUE, TRUE
[10:58:46.674] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:46.674] - relayed: [n=2] TRUE, TRUE
[10:58:46.674] - queued futures: [n=2] TRUE, TRUE
[10:58:46.674] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.674] resolve() on list ... DONE
[10:58:46.674] result() for MulticoreFuture ...
[10:58:46.674] result() for MulticoreFuture ... done
[10:58:46.675] result() for MulticoreFuture ...
[10:58:46.675] result() for MulticoreFuture ... done
[10:58:46.675] result() for MulticoreFuture ...
[10:58:46.675] result() for MulticoreFuture ... done
[10:58:46.675] result() for MulticoreFuture ...
[10:58:46.675] result() for MulticoreFuture ... done
[10:58:46.675]  - Number of value chunks collected: 2
[10:58:46.675] Resolving 2 futures (chunks) ... DONE
[10:58:46.675] Reducing values from 2 chunks ...
[10:58:46.676]  - Number of values collected after concatenation: 3
[10:58:46.676]  - Number of values expected: 3
[10:58:46.676] Reducing values from 2 chunks ... DONE
[10:58:46.676] future_lapply() ... DONE
[10:58:46.676] future_lapply() ...
[10:58:46.679] Number of chunks: 2
[10:58:46.679] getGlobalsAndPackagesXApply() ...
[10:58:46.679]  - future.globals: TRUE
[10:58:46.679] getGlobalsAndPackages() ...
[10:58:46.679] Searching for globals...
[10:58:46.680] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:46.681] Searching for globals ... DONE
[10:58:46.681] Resolving globals: FALSE
[10:58:46.681] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:46.682] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:46.682] - globals: [1] ‘FUN’
[10:58:46.682] - packages: [1] ‘stats’
[10:58:46.682] getGlobalsAndPackages() ... DONE
[10:58:46.682]  - globals found/used: [n=1] ‘FUN’
[10:58:46.682]  - needed namespaces: [n=1] ‘stats’
[10:58:46.682] Finding globals ... DONE
[10:58:46.684]  - use_args: TRUE
[10:58:46.684]  - Getting '...' globals ...
[10:58:46.685] resolve() on list ...
[10:58:46.685]  recursive: 0
[10:58:46.685]  length: 1
[10:58:46.685]  elements: ‘...’
[10:58:46.685]  length: 0 (resolved future 1)
[10:58:46.685] resolve() on list ... DONE
[10:58:46.685]    - '...' content: [n=0] 
[10:58:46.686] List of 1
[10:58:46.686]  $ ...: list()
[10:58:46.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.686]  - attr(*, "where")=List of 1
[10:58:46.686]   ..$ ...:<environment: 0x55f48b354968> 
[10:58:46.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.686]  - attr(*, "resolved")= logi TRUE
[10:58:46.686]  - attr(*, "total_size")= num NA
[10:58:46.689]  - Getting '...' globals ... DONE
[10:58:46.689] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:46.689] List of 2
[10:58:46.689]  $ ...future.FUN:function (x, ...)  
[10:58:46.689]  $ ...          : list()
[10:58:46.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.689]  - attr(*, "where")=List of 2
[10:58:46.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:46.689]   ..$ ...          :<environment: 0x55f48b354968> 
[10:58:46.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.689]  - attr(*, "resolved")= logi FALSE
[10:58:46.689]  - attr(*, "total_size")= num 5437
[10:58:46.692] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:46.692] getGlobalsAndPackagesXApply() ... DONE
[10:58:46.692] Number of futures (= number of chunks): 2
[10:58:46.692] Launching 2 futures (chunks) ...
[10:58:46.692] Chunk #1 of 2 ...
[10:58:46.692]  - Finding globals in 'X' for chunk #1 ...
[10:58:46.693] getGlobalsAndPackages() ...
[10:58:46.693] Searching for globals...
[10:58:46.693] 
[10:58:46.693] Searching for globals ... DONE
[10:58:46.693] - globals: [0] <none>
[10:58:46.693] getGlobalsAndPackages() ... DONE
[10:58:46.693]    + additional globals found: [n=0] 
[10:58:46.693]    + additional namespaces needed: [n=0] 
[10:58:46.693]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:46.693]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.694]  - seeds: <none>
[10:58:46.694]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.694] getGlobalsAndPackages() ...
[10:58:46.694] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.694] Resolving globals: FALSE
[10:58:46.694] Tweak future expression to call with '...' arguments ...
[10:58:46.694] {
[10:58:46.694]     do.call(function(...) {
[10:58:46.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.694]             on.exit(options(oopts), add = TRUE)
[10:58:46.694]         }
[10:58:46.694]         {
[10:58:46.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.694]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.694]             })
[10:58:46.694]         }
[10:58:46.694]     }, args = future.call.arguments)
[10:58:46.694] }
[10:58:46.694] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.695] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.695] - packages: [1] ‘stats’
[10:58:46.695] getGlobalsAndPackages() ... DONE
[10:58:46.695] run() for ‘Future’ ...
[10:58:46.695] - state: ‘created’
[10:58:46.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.697] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.697]   - Field: ‘label’
[10:58:46.697]   - Field: ‘local’
[10:58:46.698]   - Field: ‘owner’
[10:58:46.698]   - Field: ‘envir’
[10:58:46.698]   - Field: ‘workers’
[10:58:46.698]   - Field: ‘packages’
[10:58:46.698]   - Field: ‘gc’
[10:58:46.698]   - Field: ‘job’
[10:58:46.698]   - Field: ‘conditions’
[10:58:46.698]   - Field: ‘expr’
[10:58:46.698]   - Field: ‘uuid’
[10:58:46.698]   - Field: ‘seed’
[10:58:46.698]   - Field: ‘version’
[10:58:46.699]   - Field: ‘result’
[10:58:46.699]   - Field: ‘asynchronous’
[10:58:46.699]   - Field: ‘calls’
[10:58:46.699]   - Field: ‘globals’
[10:58:46.699]   - Field: ‘stdout’
[10:58:46.699]   - Field: ‘earlySignal’
[10:58:46.699]   - Field: ‘lazy’
[10:58:46.699]   - Field: ‘state’
[10:58:46.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.699] - Launch lazy future ...
[10:58:46.700] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.700] Packages needed by future strategies (n = 0): <none>
[10:58:46.700] {
[10:58:46.700]     {
[10:58:46.700]         {
[10:58:46.700]             ...future.startTime <- base::Sys.time()
[10:58:46.700]             {
[10:58:46.700]                 {
[10:58:46.700]                   {
[10:58:46.700]                     {
[10:58:46.700]                       {
[10:58:46.700]                         base::local({
[10:58:46.700]                           has_future <- base::requireNamespace("future", 
[10:58:46.700]                             quietly = TRUE)
[10:58:46.700]                           if (has_future) {
[10:58:46.700]                             ns <- base::getNamespace("future")
[10:58:46.700]                             version <- ns[[".package"]][["version"]]
[10:58:46.700]                             if (is.null(version)) 
[10:58:46.700]                               version <- utils::packageVersion("future")
[10:58:46.700]                           }
[10:58:46.700]                           else {
[10:58:46.700]                             version <- NULL
[10:58:46.700]                           }
[10:58:46.700]                           if (!has_future || version < "1.8.0") {
[10:58:46.700]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.700]                               "", base::R.version$version.string), 
[10:58:46.700]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:46.700]                                 base::R.version$platform, 8 * 
[10:58:46.700]                                   base::.Machine$sizeof.pointer), 
[10:58:46.700]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.700]                                 "release", "version")], collapse = " "), 
[10:58:46.700]                               hostname = base::Sys.info()[["nodename"]])
[10:58:46.700]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.700]                               info)
[10:58:46.700]                             info <- base::paste(info, collapse = "; ")
[10:58:46.700]                             if (!has_future) {
[10:58:46.700]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.700]                                 info)
[10:58:46.700]                             }
[10:58:46.700]                             else {
[10:58:46.700]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.700]                                 info, version)
[10:58:46.700]                             }
[10:58:46.700]                             base::stop(msg)
[10:58:46.700]                           }
[10:58:46.700]                         })
[10:58:46.700]                       }
[10:58:46.700]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.700]                       base::options(mc.cores = 1L)
[10:58:46.700]                     }
[10:58:46.700]                     base::local({
[10:58:46.700]                       for (pkg in "stats") {
[10:58:46.700]                         base::loadNamespace(pkg)
[10:58:46.700]                         base::library(pkg, character.only = TRUE)
[10:58:46.700]                       }
[10:58:46.700]                     })
[10:58:46.700]                   }
[10:58:46.700]                   ...future.strategy.old <- future::plan("list")
[10:58:46.700]                   options(future.plan = NULL)
[10:58:46.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.700]                 }
[10:58:46.700]                 ...future.workdir <- getwd()
[10:58:46.700]             }
[10:58:46.700]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.700]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.700]         }
[10:58:46.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.700]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.700]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.700]             base::names(...future.oldOptions))
[10:58:46.700]     }
[10:58:46.700]     if (FALSE) {
[10:58:46.700]     }
[10:58:46.700]     else {
[10:58:46.700]         if (TRUE) {
[10:58:46.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.700]                 open = "w")
[10:58:46.700]         }
[10:58:46.700]         else {
[10:58:46.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.700]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.700]         }
[10:58:46.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.700]             base::sink(type = "output", split = FALSE)
[10:58:46.700]             base::close(...future.stdout)
[10:58:46.700]         }, add = TRUE)
[10:58:46.700]     }
[10:58:46.700]     ...future.frame <- base::sys.nframe()
[10:58:46.700]     ...future.conditions <- base::list()
[10:58:46.700]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.700]     if (FALSE) {
[10:58:46.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.700]     }
[10:58:46.700]     ...future.result <- base::tryCatch({
[10:58:46.700]         base::withCallingHandlers({
[10:58:46.700]             ...future.value <- base::withVisible(base::local({
[10:58:46.700]                 withCallingHandlers({
[10:58:46.700]                   {
[10:58:46.700]                     do.call(function(...) {
[10:58:46.700]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.700]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.700]                         ...future.globals.maxSize)) {
[10:58:46.700]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.700]                         on.exit(options(oopts), add = TRUE)
[10:58:46.700]                       }
[10:58:46.700]                       {
[10:58:46.700]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.700]                           FUN = function(jj) {
[10:58:46.700]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.700]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.700]                           })
[10:58:46.700]                       }
[10:58:46.700]                     }, args = future.call.arguments)
[10:58:46.700]                   }
[10:58:46.700]                 }, immediateCondition = function(cond) {
[10:58:46.700]                   save_rds <- function (object, pathname, ...) 
[10:58:46.700]                   {
[10:58:46.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.700]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.700]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.700]                         fi_tmp[["mtime"]])
[10:58:46.700]                     }
[10:58:46.700]                     tryCatch({
[10:58:46.700]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.700]                     }, error = function(ex) {
[10:58:46.700]                       msg <- conditionMessage(ex)
[10:58:46.700]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.700]                         fi_tmp[["mtime"]], msg)
[10:58:46.700]                       ex$message <- msg
[10:58:46.700]                       stop(ex)
[10:58:46.700]                     })
[10:58:46.700]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.700]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.700]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.700]                       fi <- file.info(pathname)
[10:58:46.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.700]                         fi[["size"]], fi[["mtime"]])
[10:58:46.700]                       stop(msg)
[10:58:46.700]                     }
[10:58:46.700]                     invisible(pathname)
[10:58:46.700]                   }
[10:58:46.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.700]                     rootPath = tempdir()) 
[10:58:46.700]                   {
[10:58:46.700]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.700]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.700]                       tmpdir = path, fileext = ".rds")
[10:58:46.700]                     save_rds(obj, file)
[10:58:46.700]                   }
[10:58:46.700]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.700]                   {
[10:58:46.700]                     inherits <- base::inherits
[10:58:46.700]                     invokeRestart <- base::invokeRestart
[10:58:46.700]                     is.null <- base::is.null
[10:58:46.700]                     muffled <- FALSE
[10:58:46.700]                     if (inherits(cond, "message")) {
[10:58:46.700]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.700]                       if (muffled) 
[10:58:46.700]                         invokeRestart("muffleMessage")
[10:58:46.700]                     }
[10:58:46.700]                     else if (inherits(cond, "warning")) {
[10:58:46.700]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.700]                       if (muffled) 
[10:58:46.700]                         invokeRestart("muffleWarning")
[10:58:46.700]                     }
[10:58:46.700]                     else if (inherits(cond, "condition")) {
[10:58:46.700]                       if (!is.null(pattern)) {
[10:58:46.700]                         computeRestarts <- base::computeRestarts
[10:58:46.700]                         grepl <- base::grepl
[10:58:46.700]                         restarts <- computeRestarts(cond)
[10:58:46.700]                         for (restart in restarts) {
[10:58:46.700]                           name <- restart$name
[10:58:46.700]                           if (is.null(name)) 
[10:58:46.700]                             next
[10:58:46.700]                           if (!grepl(pattern, name)) 
[10:58:46.700]                             next
[10:58:46.700]                           invokeRestart(restart)
[10:58:46.700]                           muffled <- TRUE
[10:58:46.700]                           break
[10:58:46.700]                         }
[10:58:46.700]                       }
[10:58:46.700]                     }
[10:58:46.700]                     invisible(muffled)
[10:58:46.700]                   }
[10:58:46.700]                   muffleCondition(cond)
[10:58:46.700]                 })
[10:58:46.700]             }))
[10:58:46.700]             future::FutureResult(value = ...future.value$value, 
[10:58:46.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.700]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.700]                     ...future.globalenv.names))
[10:58:46.700]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.700]         }, condition = base::local({
[10:58:46.700]             c <- base::c
[10:58:46.700]             inherits <- base::inherits
[10:58:46.700]             invokeRestart <- base::invokeRestart
[10:58:46.700]             length <- base::length
[10:58:46.700]             list <- base::list
[10:58:46.700]             seq.int <- base::seq.int
[10:58:46.700]             signalCondition <- base::signalCondition
[10:58:46.700]             sys.calls <- base::sys.calls
[10:58:46.700]             `[[` <- base::`[[`
[10:58:46.700]             `+` <- base::`+`
[10:58:46.700]             `<<-` <- base::`<<-`
[10:58:46.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.700]                   3L)]
[10:58:46.700]             }
[10:58:46.700]             function(cond) {
[10:58:46.700]                 is_error <- inherits(cond, "error")
[10:58:46.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.700]                   NULL)
[10:58:46.700]                 if (is_error) {
[10:58:46.700]                   sessionInformation <- function() {
[10:58:46.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.700]                       search = base::search(), system = base::Sys.info())
[10:58:46.700]                   }
[10:58:46.700]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.700]                     cond$call), session = sessionInformation(), 
[10:58:46.700]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.700]                   signalCondition(cond)
[10:58:46.700]                 }
[10:58:46.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.700]                 "immediateCondition"))) {
[10:58:46.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.700]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.700]                   if (TRUE && !signal) {
[10:58:46.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.700]                     {
[10:58:46.700]                       inherits <- base::inherits
[10:58:46.700]                       invokeRestart <- base::invokeRestart
[10:58:46.700]                       is.null <- base::is.null
[10:58:46.700]                       muffled <- FALSE
[10:58:46.700]                       if (inherits(cond, "message")) {
[10:58:46.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.700]                         if (muffled) 
[10:58:46.700]                           invokeRestart("muffleMessage")
[10:58:46.700]                       }
[10:58:46.700]                       else if (inherits(cond, "warning")) {
[10:58:46.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.700]                         if (muffled) 
[10:58:46.700]                           invokeRestart("muffleWarning")
[10:58:46.700]                       }
[10:58:46.700]                       else if (inherits(cond, "condition")) {
[10:58:46.700]                         if (!is.null(pattern)) {
[10:58:46.700]                           computeRestarts <- base::computeRestarts
[10:58:46.700]                           grepl <- base::grepl
[10:58:46.700]                           restarts <- computeRestarts(cond)
[10:58:46.700]                           for (restart in restarts) {
[10:58:46.700]                             name <- restart$name
[10:58:46.700]                             if (is.null(name)) 
[10:58:46.700]                               next
[10:58:46.700]                             if (!grepl(pattern, name)) 
[10:58:46.700]                               next
[10:58:46.700]                             invokeRestart(restart)
[10:58:46.700]                             muffled <- TRUE
[10:58:46.700]                             break
[10:58:46.700]                           }
[10:58:46.700]                         }
[10:58:46.700]                       }
[10:58:46.700]                       invisible(muffled)
[10:58:46.700]                     }
[10:58:46.700]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.700]                   }
[10:58:46.700]                 }
[10:58:46.700]                 else {
[10:58:46.700]                   if (TRUE) {
[10:58:46.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.700]                     {
[10:58:46.700]                       inherits <- base::inherits
[10:58:46.700]                       invokeRestart <- base::invokeRestart
[10:58:46.700]                       is.null <- base::is.null
[10:58:46.700]                       muffled <- FALSE
[10:58:46.700]                       if (inherits(cond, "message")) {
[10:58:46.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.700]                         if (muffled) 
[10:58:46.700]                           invokeRestart("muffleMessage")
[10:58:46.700]                       }
[10:58:46.700]                       else if (inherits(cond, "warning")) {
[10:58:46.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.700]                         if (muffled) 
[10:58:46.700]                           invokeRestart("muffleWarning")
[10:58:46.700]                       }
[10:58:46.700]                       else if (inherits(cond, "condition")) {
[10:58:46.700]                         if (!is.null(pattern)) {
[10:58:46.700]                           computeRestarts <- base::computeRestarts
[10:58:46.700]                           grepl <- base::grepl
[10:58:46.700]                           restarts <- computeRestarts(cond)
[10:58:46.700]                           for (restart in restarts) {
[10:58:46.700]                             name <- restart$name
[10:58:46.700]                             if (is.null(name)) 
[10:58:46.700]                               next
[10:58:46.700]                             if (!grepl(pattern, name)) 
[10:58:46.700]                               next
[10:58:46.700]                             invokeRestart(restart)
[10:58:46.700]                             muffled <- TRUE
[10:58:46.700]                             break
[10:58:46.700]                           }
[10:58:46.700]                         }
[10:58:46.700]                       }
[10:58:46.700]                       invisible(muffled)
[10:58:46.700]                     }
[10:58:46.700]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.700]                   }
[10:58:46.700]                 }
[10:58:46.700]             }
[10:58:46.700]         }))
[10:58:46.700]     }, error = function(ex) {
[10:58:46.700]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.700]                 ...future.rng), started = ...future.startTime, 
[10:58:46.700]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.700]             version = "1.8"), class = "FutureResult")
[10:58:46.700]     }, finally = {
[10:58:46.700]         if (!identical(...future.workdir, getwd())) 
[10:58:46.700]             setwd(...future.workdir)
[10:58:46.700]         {
[10:58:46.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.700]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.700]             }
[10:58:46.700]             base::options(...future.oldOptions)
[10:58:46.700]             if (.Platform$OS.type == "windows") {
[10:58:46.700]                 old_names <- names(...future.oldEnvVars)
[10:58:46.700]                 envs <- base::Sys.getenv()
[10:58:46.700]                 names <- names(envs)
[10:58:46.700]                 common <- intersect(names, old_names)
[10:58:46.700]                 added <- setdiff(names, old_names)
[10:58:46.700]                 removed <- setdiff(old_names, names)
[10:58:46.700]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.700]                   envs[common]]
[10:58:46.700]                 NAMES <- toupper(changed)
[10:58:46.700]                 args <- list()
[10:58:46.700]                 for (kk in seq_along(NAMES)) {
[10:58:46.700]                   name <- changed[[kk]]
[10:58:46.700]                   NAME <- NAMES[[kk]]
[10:58:46.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.700]                     next
[10:58:46.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.700]                 }
[10:58:46.700]                 NAMES <- toupper(added)
[10:58:46.700]                 for (kk in seq_along(NAMES)) {
[10:58:46.700]                   name <- added[[kk]]
[10:58:46.700]                   NAME <- NAMES[[kk]]
[10:58:46.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.700]                     next
[10:58:46.700]                   args[[name]] <- ""
[10:58:46.700]                 }
[10:58:46.700]                 NAMES <- toupper(removed)
[10:58:46.700]                 for (kk in seq_along(NAMES)) {
[10:58:46.700]                   name <- removed[[kk]]
[10:58:46.700]                   NAME <- NAMES[[kk]]
[10:58:46.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.700]                     next
[10:58:46.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.700]                 }
[10:58:46.700]                 if (length(args) > 0) 
[10:58:46.700]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.700]             }
[10:58:46.700]             else {
[10:58:46.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.700]             }
[10:58:46.700]             {
[10:58:46.700]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.700]                   0L) {
[10:58:46.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.700]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.700]                   base::options(opts)
[10:58:46.700]                 }
[10:58:46.700]                 {
[10:58:46.700]                   {
[10:58:46.700]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.700]                     NULL
[10:58:46.700]                   }
[10:58:46.700]                   options(future.plan = NULL)
[10:58:46.700]                   if (is.na(NA_character_)) 
[10:58:46.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.700]                     .init = FALSE)
[10:58:46.700]                 }
[10:58:46.700]             }
[10:58:46.700]         }
[10:58:46.700]     })
[10:58:46.700]     if (TRUE) {
[10:58:46.700]         base::sink(type = "output", split = FALSE)
[10:58:46.700]         if (TRUE) {
[10:58:46.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.700]         }
[10:58:46.700]         else {
[10:58:46.700]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.700]         }
[10:58:46.700]         base::close(...future.stdout)
[10:58:46.700]         ...future.stdout <- NULL
[10:58:46.700]     }
[10:58:46.700]     ...future.result$conditions <- ...future.conditions
[10:58:46.700]     ...future.result$finished <- base::Sys.time()
[10:58:46.700]     ...future.result
[10:58:46.700] }
[10:58:46.703] assign_globals() ...
[10:58:46.703] List of 5
[10:58:46.703]  $ ...future.FUN            :function (x, ...)  
[10:58:46.703]  $ future.call.arguments    : list()
[10:58:46.703]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.703]  $ ...future.elements_ii    :List of 1
[10:58:46.703]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:58:46.703]  $ ...future.seeds_ii       : NULL
[10:58:46.703]  $ ...future.globals.maxSize: NULL
[10:58:46.703]  - attr(*, "where")=List of 5
[10:58:46.703]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.703]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.703]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.703]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.703]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.703]  - attr(*, "resolved")= logi FALSE
[10:58:46.703]  - attr(*, "total_size")= num 5437
[10:58:46.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.703]  - attr(*, "already-done")= logi TRUE
[10:58:46.709] - copied ‘...future.FUN’ to environment
[10:58:46.709] - copied ‘future.call.arguments’ to environment
[10:58:46.709] - copied ‘...future.elements_ii’ to environment
[10:58:46.709] - copied ‘...future.seeds_ii’ to environment
[10:58:46.709] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.709] assign_globals() ... done
[10:58:46.709] requestCore(): workers = 2
[10:58:46.712] MulticoreFuture started
[10:58:46.712] - Launch lazy future ... done
[10:58:46.712] run() for ‘MulticoreFuture’ ... done
[10:58:46.713] Created future:
[10:58:46.713] plan(): Setting new future strategy stack:
[10:58:46.713] List of future strategies:
[10:58:46.713] 1. sequential:
[10:58:46.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.713]    - tweaked: FALSE
[10:58:46.713]    - call: NULL
[10:58:46.714] plan(): nbrOfWorkers() = 1
[10:58:46.717] plan(): Setting new future strategy stack:
[10:58:46.717] List of future strategies:
[10:58:46.717] 1. multicore:
[10:58:46.717]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.717]    - tweaked: FALSE
[10:58:46.717]    - call: plan(strategy)
[10:58:46.721] plan(): nbrOfWorkers() = 2
[10:58:46.713] MulticoreFuture:
[10:58:46.713] Label: ‘future_eapply-1’
[10:58:46.713] Expression:
[10:58:46.713] {
[10:58:46.713]     do.call(function(...) {
[10:58:46.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.713]             on.exit(options(oopts), add = TRUE)
[10:58:46.713]         }
[10:58:46.713]         {
[10:58:46.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.713]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.713]             })
[10:58:46.713]         }
[10:58:46.713]     }, args = future.call.arguments)
[10:58:46.713] }
[10:58:46.713] Lazy evaluation: FALSE
[10:58:46.713] Asynchronous evaluation: TRUE
[10:58:46.713] Local evaluation: TRUE
[10:58:46.713] Environment: R_GlobalEnv
[10:58:46.713] Capture standard output: TRUE
[10:58:46.713] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.713] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.713] Packages: 1 packages (‘stats’)
[10:58:46.713] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.713] Resolved: TRUE
[10:58:46.713] Value: <not collected>
[10:58:46.713] Conditions captured: <none>
[10:58:46.713] Early signaling: FALSE
[10:58:46.713] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.713] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.722] Chunk #1 of 2 ... DONE
[10:58:46.722] Chunk #2 of 2 ...
[10:58:46.722]  - Finding globals in 'X' for chunk #2 ...
[10:58:46.722] getGlobalsAndPackages() ...
[10:58:46.722] Searching for globals...
[10:58:46.723] 
[10:58:46.723] Searching for globals ... DONE
[10:58:46.723] - globals: [0] <none>
[10:58:46.723] getGlobalsAndPackages() ... DONE
[10:58:46.724]    + additional globals found: [n=0] 
[10:58:46.724]    + additional namespaces needed: [n=0] 
[10:58:46.724]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:46.724]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:46.724]  - seeds: <none>
[10:58:46.724]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.724] getGlobalsAndPackages() ...
[10:58:46.725] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.725] Resolving globals: FALSE
[10:58:46.725] Tweak future expression to call with '...' arguments ...
[10:58:46.725] {
[10:58:46.725]     do.call(function(...) {
[10:58:46.725]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.725]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.725]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.725]             on.exit(options(oopts), add = TRUE)
[10:58:46.725]         }
[10:58:46.725]         {
[10:58:46.725]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.725]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.725]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.725]             })
[10:58:46.725]         }
[10:58:46.725]     }, args = future.call.arguments)
[10:58:46.725] }
[10:58:46.725] Tweak future expression to call with '...' arguments ... DONE
[10:58:46.726] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:46.726] - packages: [1] ‘stats’
[10:58:46.727] getGlobalsAndPackages() ... DONE
[10:58:46.727] run() for ‘Future’ ...
[10:58:46.727] - state: ‘created’
[10:58:46.727] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:46.730] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:46.730]   - Field: ‘label’
[10:58:46.731]   - Field: ‘local’
[10:58:46.731]   - Field: ‘owner’
[10:58:46.731]   - Field: ‘envir’
[10:58:46.731]   - Field: ‘workers’
[10:58:46.731]   - Field: ‘packages’
[10:58:46.731]   - Field: ‘gc’
[10:58:46.731]   - Field: ‘job’
[10:58:46.732]   - Field: ‘conditions’
[10:58:46.732]   - Field: ‘expr’
[10:58:46.732]   - Field: ‘uuid’
[10:58:46.732]   - Field: ‘seed’
[10:58:46.732]   - Field: ‘version’
[10:58:46.732]   - Field: ‘result’
[10:58:46.732]   - Field: ‘asynchronous’
[10:58:46.732]   - Field: ‘calls’
[10:58:46.733]   - Field: ‘globals’
[10:58:46.733]   - Field: ‘stdout’
[10:58:46.733]   - Field: ‘earlySignal’
[10:58:46.733]   - Field: ‘lazy’
[10:58:46.733]   - Field: ‘state’
[10:58:46.733] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:46.733] - Launch lazy future ...
[10:58:46.734] Packages needed by the future expression (n = 1): ‘stats’
[10:58:46.734] Packages needed by future strategies (n = 0): <none>
[10:58:46.735] {
[10:58:46.735]     {
[10:58:46.735]         {
[10:58:46.735]             ...future.startTime <- base::Sys.time()
[10:58:46.735]             {
[10:58:46.735]                 {
[10:58:46.735]                   {
[10:58:46.735]                     {
[10:58:46.735]                       {
[10:58:46.735]                         base::local({
[10:58:46.735]                           has_future <- base::requireNamespace("future", 
[10:58:46.735]                             quietly = TRUE)
[10:58:46.735]                           if (has_future) {
[10:58:46.735]                             ns <- base::getNamespace("future")
[10:58:46.735]                             version <- ns[[".package"]][["version"]]
[10:58:46.735]                             if (is.null(version)) 
[10:58:46.735]                               version <- utils::packageVersion("future")
[10:58:46.735]                           }
[10:58:46.735]                           else {
[10:58:46.735]                             version <- NULL
[10:58:46.735]                           }
[10:58:46.735]                           if (!has_future || version < "1.8.0") {
[10:58:46.735]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:46.735]                               "", base::R.version$version.string), 
[10:58:46.735]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:46.735]                                 base::R.version$platform, 8 * 
[10:58:46.735]                                   base::.Machine$sizeof.pointer), 
[10:58:46.735]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:46.735]                                 "release", "version")], collapse = " "), 
[10:58:46.735]                               hostname = base::Sys.info()[["nodename"]])
[10:58:46.735]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:46.735]                               info)
[10:58:46.735]                             info <- base::paste(info, collapse = "; ")
[10:58:46.735]                             if (!has_future) {
[10:58:46.735]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:46.735]                                 info)
[10:58:46.735]                             }
[10:58:46.735]                             else {
[10:58:46.735]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:46.735]                                 info, version)
[10:58:46.735]                             }
[10:58:46.735]                             base::stop(msg)
[10:58:46.735]                           }
[10:58:46.735]                         })
[10:58:46.735]                       }
[10:58:46.735]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:46.735]                       base::options(mc.cores = 1L)
[10:58:46.735]                     }
[10:58:46.735]                     base::local({
[10:58:46.735]                       for (pkg in "stats") {
[10:58:46.735]                         base::loadNamespace(pkg)
[10:58:46.735]                         base::library(pkg, character.only = TRUE)
[10:58:46.735]                       }
[10:58:46.735]                     })
[10:58:46.735]                   }
[10:58:46.735]                   ...future.strategy.old <- future::plan("list")
[10:58:46.735]                   options(future.plan = NULL)
[10:58:46.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:46.735]                 }
[10:58:46.735]                 ...future.workdir <- getwd()
[10:58:46.735]             }
[10:58:46.735]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:46.735]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:46.735]         }
[10:58:46.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:46.735]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:46.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:46.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:46.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:46.735]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:46.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:46.735]             base::names(...future.oldOptions))
[10:58:46.735]     }
[10:58:46.735]     if (FALSE) {
[10:58:46.735]     }
[10:58:46.735]     else {
[10:58:46.735]         if (TRUE) {
[10:58:46.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:46.735]                 open = "w")
[10:58:46.735]         }
[10:58:46.735]         else {
[10:58:46.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:46.735]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:46.735]         }
[10:58:46.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:46.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:46.735]             base::sink(type = "output", split = FALSE)
[10:58:46.735]             base::close(...future.stdout)
[10:58:46.735]         }, add = TRUE)
[10:58:46.735]     }
[10:58:46.735]     ...future.frame <- base::sys.nframe()
[10:58:46.735]     ...future.conditions <- base::list()
[10:58:46.735]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:46.735]     if (FALSE) {
[10:58:46.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:46.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:46.735]     }
[10:58:46.735]     ...future.result <- base::tryCatch({
[10:58:46.735]         base::withCallingHandlers({
[10:58:46.735]             ...future.value <- base::withVisible(base::local({
[10:58:46.735]                 withCallingHandlers({
[10:58:46.735]                   {
[10:58:46.735]                     do.call(function(...) {
[10:58:46.735]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.735]                       if (!identical(...future.globals.maxSize.org, 
[10:58:46.735]                         ...future.globals.maxSize)) {
[10:58:46.735]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.735]                         on.exit(options(oopts), add = TRUE)
[10:58:46.735]                       }
[10:58:46.735]                       {
[10:58:46.735]                         lapply(seq_along(...future.elements_ii), 
[10:58:46.735]                           FUN = function(jj) {
[10:58:46.735]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.735]                             ...future.FUN(...future.X_jj, ...)
[10:58:46.735]                           })
[10:58:46.735]                       }
[10:58:46.735]                     }, args = future.call.arguments)
[10:58:46.735]                   }
[10:58:46.735]                 }, immediateCondition = function(cond) {
[10:58:46.735]                   save_rds <- function (object, pathname, ...) 
[10:58:46.735]                   {
[10:58:46.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:46.735]                     if (file_test("-f", pathname_tmp)) {
[10:58:46.735]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:46.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.735]                         fi_tmp[["mtime"]])
[10:58:46.735]                     }
[10:58:46.735]                     tryCatch({
[10:58:46.735]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:46.735]                     }, error = function(ex) {
[10:58:46.735]                       msg <- conditionMessage(ex)
[10:58:46.735]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:46.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.735]                         fi_tmp[["mtime"]], msg)
[10:58:46.735]                       ex$message <- msg
[10:58:46.735]                       stop(ex)
[10:58:46.735]                     })
[10:58:46.735]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:46.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:46.735]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:46.735]                       fi_tmp <- file.info(pathname_tmp)
[10:58:46.735]                       fi <- file.info(pathname)
[10:58:46.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:46.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:46.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:46.735]                         fi[["size"]], fi[["mtime"]])
[10:58:46.735]                       stop(msg)
[10:58:46.735]                     }
[10:58:46.735]                     invisible(pathname)
[10:58:46.735]                   }
[10:58:46.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:46.735]                     rootPath = tempdir()) 
[10:58:46.735]                   {
[10:58:46.735]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:46.735]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:46.735]                       tmpdir = path, fileext = ".rds")
[10:58:46.735]                     save_rds(obj, file)
[10:58:46.735]                   }
[10:58:46.735]                   saveImmediateCondition(cond, path = "/tmp/RtmpGIBupT/.future/immediateConditions")
[10:58:46.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.735]                   {
[10:58:46.735]                     inherits <- base::inherits
[10:58:46.735]                     invokeRestart <- base::invokeRestart
[10:58:46.735]                     is.null <- base::is.null
[10:58:46.735]                     muffled <- FALSE
[10:58:46.735]                     if (inherits(cond, "message")) {
[10:58:46.735]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:46.735]                       if (muffled) 
[10:58:46.735]                         invokeRestart("muffleMessage")
[10:58:46.735]                     }
[10:58:46.735]                     else if (inherits(cond, "warning")) {
[10:58:46.735]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:46.735]                       if (muffled) 
[10:58:46.735]                         invokeRestart("muffleWarning")
[10:58:46.735]                     }
[10:58:46.735]                     else if (inherits(cond, "condition")) {
[10:58:46.735]                       if (!is.null(pattern)) {
[10:58:46.735]                         computeRestarts <- base::computeRestarts
[10:58:46.735]                         grepl <- base::grepl
[10:58:46.735]                         restarts <- computeRestarts(cond)
[10:58:46.735]                         for (restart in restarts) {
[10:58:46.735]                           name <- restart$name
[10:58:46.735]                           if (is.null(name)) 
[10:58:46.735]                             next
[10:58:46.735]                           if (!grepl(pattern, name)) 
[10:58:46.735]                             next
[10:58:46.735]                           invokeRestart(restart)
[10:58:46.735]                           muffled <- TRUE
[10:58:46.735]                           break
[10:58:46.735]                         }
[10:58:46.735]                       }
[10:58:46.735]                     }
[10:58:46.735]                     invisible(muffled)
[10:58:46.735]                   }
[10:58:46.735]                   muffleCondition(cond)
[10:58:46.735]                 })
[10:58:46.735]             }))
[10:58:46.735]             future::FutureResult(value = ...future.value$value, 
[10:58:46.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.735]                   ...future.rng), globalenv = if (FALSE) 
[10:58:46.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:46.735]                     ...future.globalenv.names))
[10:58:46.735]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:46.735]         }, condition = base::local({
[10:58:46.735]             c <- base::c
[10:58:46.735]             inherits <- base::inherits
[10:58:46.735]             invokeRestart <- base::invokeRestart
[10:58:46.735]             length <- base::length
[10:58:46.735]             list <- base::list
[10:58:46.735]             seq.int <- base::seq.int
[10:58:46.735]             signalCondition <- base::signalCondition
[10:58:46.735]             sys.calls <- base::sys.calls
[10:58:46.735]             `[[` <- base::`[[`
[10:58:46.735]             `+` <- base::`+`
[10:58:46.735]             `<<-` <- base::`<<-`
[10:58:46.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:46.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:46.735]                   3L)]
[10:58:46.735]             }
[10:58:46.735]             function(cond) {
[10:58:46.735]                 is_error <- inherits(cond, "error")
[10:58:46.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:46.735]                   NULL)
[10:58:46.735]                 if (is_error) {
[10:58:46.735]                   sessionInformation <- function() {
[10:58:46.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:46.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:46.735]                       search = base::search(), system = base::Sys.info())
[10:58:46.735]                   }
[10:58:46.735]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:46.735]                     cond$call), session = sessionInformation(), 
[10:58:46.735]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:46.735]                   signalCondition(cond)
[10:58:46.735]                 }
[10:58:46.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:46.735]                 "immediateCondition"))) {
[10:58:46.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:46.735]                   ...future.conditions[[length(...future.conditions) + 
[10:58:46.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:46.735]                   if (TRUE && !signal) {
[10:58:46.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.735]                     {
[10:58:46.735]                       inherits <- base::inherits
[10:58:46.735]                       invokeRestart <- base::invokeRestart
[10:58:46.735]                       is.null <- base::is.null
[10:58:46.735]                       muffled <- FALSE
[10:58:46.735]                       if (inherits(cond, "message")) {
[10:58:46.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.735]                         if (muffled) 
[10:58:46.735]                           invokeRestart("muffleMessage")
[10:58:46.735]                       }
[10:58:46.735]                       else if (inherits(cond, "warning")) {
[10:58:46.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.735]                         if (muffled) 
[10:58:46.735]                           invokeRestart("muffleWarning")
[10:58:46.735]                       }
[10:58:46.735]                       else if (inherits(cond, "condition")) {
[10:58:46.735]                         if (!is.null(pattern)) {
[10:58:46.735]                           computeRestarts <- base::computeRestarts
[10:58:46.735]                           grepl <- base::grepl
[10:58:46.735]                           restarts <- computeRestarts(cond)
[10:58:46.735]                           for (restart in restarts) {
[10:58:46.735]                             name <- restart$name
[10:58:46.735]                             if (is.null(name)) 
[10:58:46.735]                               next
[10:58:46.735]                             if (!grepl(pattern, name)) 
[10:58:46.735]                               next
[10:58:46.735]                             invokeRestart(restart)
[10:58:46.735]                             muffled <- TRUE
[10:58:46.735]                             break
[10:58:46.735]                           }
[10:58:46.735]                         }
[10:58:46.735]                       }
[10:58:46.735]                       invisible(muffled)
[10:58:46.735]                     }
[10:58:46.735]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.735]                   }
[10:58:46.735]                 }
[10:58:46.735]                 else {
[10:58:46.735]                   if (TRUE) {
[10:58:46.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:46.735]                     {
[10:58:46.735]                       inherits <- base::inherits
[10:58:46.735]                       invokeRestart <- base::invokeRestart
[10:58:46.735]                       is.null <- base::is.null
[10:58:46.735]                       muffled <- FALSE
[10:58:46.735]                       if (inherits(cond, "message")) {
[10:58:46.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:46.735]                         if (muffled) 
[10:58:46.735]                           invokeRestart("muffleMessage")
[10:58:46.735]                       }
[10:58:46.735]                       else if (inherits(cond, "warning")) {
[10:58:46.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:46.735]                         if (muffled) 
[10:58:46.735]                           invokeRestart("muffleWarning")
[10:58:46.735]                       }
[10:58:46.735]                       else if (inherits(cond, "condition")) {
[10:58:46.735]                         if (!is.null(pattern)) {
[10:58:46.735]                           computeRestarts <- base::computeRestarts
[10:58:46.735]                           grepl <- base::grepl
[10:58:46.735]                           restarts <- computeRestarts(cond)
[10:58:46.735]                           for (restart in restarts) {
[10:58:46.735]                             name <- restart$name
[10:58:46.735]                             if (is.null(name)) 
[10:58:46.735]                               next
[10:58:46.735]                             if (!grepl(pattern, name)) 
[10:58:46.735]                               next
[10:58:46.735]                             invokeRestart(restart)
[10:58:46.735]                             muffled <- TRUE
[10:58:46.735]                             break
[10:58:46.735]                           }
[10:58:46.735]                         }
[10:58:46.735]                       }
[10:58:46.735]                       invisible(muffled)
[10:58:46.735]                     }
[10:58:46.735]                     muffleCondition(cond, pattern = "^muffle")
[10:58:46.735]                   }
[10:58:46.735]                 }
[10:58:46.735]             }
[10:58:46.735]         }))
[10:58:46.735]     }, error = function(ex) {
[10:58:46.735]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:46.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:46.735]                 ...future.rng), started = ...future.startTime, 
[10:58:46.735]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:46.735]             version = "1.8"), class = "FutureResult")
[10:58:46.735]     }, finally = {
[10:58:46.735]         if (!identical(...future.workdir, getwd())) 
[10:58:46.735]             setwd(...future.workdir)
[10:58:46.735]         {
[10:58:46.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:46.735]                 ...future.oldOptions$nwarnings <- NULL
[10:58:46.735]             }
[10:58:46.735]             base::options(...future.oldOptions)
[10:58:46.735]             if (.Platform$OS.type == "windows") {
[10:58:46.735]                 old_names <- names(...future.oldEnvVars)
[10:58:46.735]                 envs <- base::Sys.getenv()
[10:58:46.735]                 names <- names(envs)
[10:58:46.735]                 common <- intersect(names, old_names)
[10:58:46.735]                 added <- setdiff(names, old_names)
[10:58:46.735]                 removed <- setdiff(old_names, names)
[10:58:46.735]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:46.735]                   envs[common]]
[10:58:46.735]                 NAMES <- toupper(changed)
[10:58:46.735]                 args <- list()
[10:58:46.735]                 for (kk in seq_along(NAMES)) {
[10:58:46.735]                   name <- changed[[kk]]
[10:58:46.735]                   NAME <- NAMES[[kk]]
[10:58:46.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.735]                     next
[10:58:46.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.735]                 }
[10:58:46.735]                 NAMES <- toupper(added)
[10:58:46.735]                 for (kk in seq_along(NAMES)) {
[10:58:46.735]                   name <- added[[kk]]
[10:58:46.735]                   NAME <- NAMES[[kk]]
[10:58:46.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.735]                     next
[10:58:46.735]                   args[[name]] <- ""
[10:58:46.735]                 }
[10:58:46.735]                 NAMES <- toupper(removed)
[10:58:46.735]                 for (kk in seq_along(NAMES)) {
[10:58:46.735]                   name <- removed[[kk]]
[10:58:46.735]                   NAME <- NAMES[[kk]]
[10:58:46.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:46.735]                     next
[10:58:46.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:46.735]                 }
[10:58:46.735]                 if (length(args) > 0) 
[10:58:46.735]                   base::do.call(base::Sys.setenv, args = args)
[10:58:46.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:46.735]             }
[10:58:46.735]             else {
[10:58:46.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:46.735]             }
[10:58:46.735]             {
[10:58:46.735]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:46.735]                   0L) {
[10:58:46.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:46.735]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:46.735]                   base::options(opts)
[10:58:46.735]                 }
[10:58:46.735]                 {
[10:58:46.735]                   {
[10:58:46.735]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:46.735]                     NULL
[10:58:46.735]                   }
[10:58:46.735]                   options(future.plan = NULL)
[10:58:46.735]                   if (is.na(NA_character_)) 
[10:58:46.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:46.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:46.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:46.735]                     .init = FALSE)
[10:58:46.735]                 }
[10:58:46.735]             }
[10:58:46.735]         }
[10:58:46.735]     })
[10:58:46.735]     if (TRUE) {
[10:58:46.735]         base::sink(type = "output", split = FALSE)
[10:58:46.735]         if (TRUE) {
[10:58:46.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:46.735]         }
[10:58:46.735]         else {
[10:58:46.735]             ...future.result["stdout"] <- base::list(NULL)
[10:58:46.735]         }
[10:58:46.735]         base::close(...future.stdout)
[10:58:46.735]         ...future.stdout <- NULL
[10:58:46.735]     }
[10:58:46.735]     ...future.result$conditions <- ...future.conditions
[10:58:46.735]     ...future.result$finished <- base::Sys.time()
[10:58:46.735]     ...future.result
[10:58:46.735] }
[10:58:46.738] assign_globals() ...
[10:58:46.739] List of 5
[10:58:46.739]  $ ...future.FUN            :function (x, ...)  
[10:58:46.739]  $ future.call.arguments    : list()
[10:58:46.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:46.739]  $ ...future.elements_ii    :List of 2
[10:58:46.739]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:58:46.739]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:58:46.739]  $ ...future.seeds_ii       : NULL
[10:58:46.739]  $ ...future.globals.maxSize: NULL
[10:58:46.739]  - attr(*, "where")=List of 5
[10:58:46.739]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:46.739]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:46.739]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:46.739]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:46.739]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:46.739]  - attr(*, "resolved")= logi FALSE
[10:58:46.739]  - attr(*, "total_size")= num 5437
[10:58:46.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:46.739]  - attr(*, "already-done")= logi TRUE
[10:58:46.746] - copied ‘...future.FUN’ to environment
[10:58:46.746] - copied ‘future.call.arguments’ to environment
[10:58:46.746] - copied ‘...future.elements_ii’ to environment
[10:58:46.746] - copied ‘...future.seeds_ii’ to environment
[10:58:46.747] - copied ‘...future.globals.maxSize’ to environment
[10:58:46.747] assign_globals() ... done
[10:58:46.747] requestCore(): workers = 2
[10:58:46.749] MulticoreFuture started
[10:58:46.750] - Launch lazy future ... done
[10:58:46.750] run() for ‘MulticoreFuture’ ... done
[10:58:46.750] Created future:
[10:58:46.751] plan(): Setting new future strategy stack:
[10:58:46.751] List of future strategies:
[10:58:46.751] 1. sequential:
[10:58:46.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.751]    - tweaked: FALSE
[10:58:46.751]    - call: NULL
[10:58:46.752] plan(): nbrOfWorkers() = 1
[10:58:46.755] plan(): Setting new future strategy stack:
[10:58:46.755] List of future strategies:
[10:58:46.755] 1. multicore:
[10:58:46.755]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:46.755]    - tweaked: FALSE
[10:58:46.755]    - call: plan(strategy)
[10:58:46.758] plan(): nbrOfWorkers() = 2
[10:58:46.750] MulticoreFuture:
[10:58:46.750] Label: ‘future_eapply-2’
[10:58:46.750] Expression:
[10:58:46.750] {
[10:58:46.750]     do.call(function(...) {
[10:58:46.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:46.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:46.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:46.750]             on.exit(options(oopts), add = TRUE)
[10:58:46.750]         }
[10:58:46.750]         {
[10:58:46.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:46.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:46.750]                 ...future.FUN(...future.X_jj, ...)
[10:58:46.750]             })
[10:58:46.750]         }
[10:58:46.750]     }, args = future.call.arguments)
[10:58:46.750] }
[10:58:46.750] Lazy evaluation: FALSE
[10:58:46.750] Asynchronous evaluation: TRUE
[10:58:46.750] Local evaluation: TRUE
[10:58:46.750] Environment: R_GlobalEnv
[10:58:46.750] Capture standard output: TRUE
[10:58:46.750] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:46.750] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:46.750] Packages: 1 packages (‘stats’)
[10:58:46.750] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:46.750] Resolved: TRUE
[10:58:46.750] Value: <not collected>
[10:58:46.750] Conditions captured: <none>
[10:58:46.750] Early signaling: FALSE
[10:58:46.750] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:46.750] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:46.759] Chunk #2 of 2 ... DONE
[10:58:46.759] Launching 2 futures (chunks) ... DONE
[10:58:46.759] Resolving 2 futures (chunks) ...
[10:58:46.759] resolve() on list ...
[10:58:46.760]  recursive: 0
[10:58:46.760]  length: 2
[10:58:46.760] 
[10:58:46.760] Future #1
[10:58:46.760] result() for MulticoreFuture ...
[10:58:46.761] result() for MulticoreFuture ...
[10:58:46.761] result() for MulticoreFuture ... done
[10:58:46.762] result() for MulticoreFuture ... done
[10:58:46.762] result() for MulticoreFuture ...
[10:58:46.762] result() for MulticoreFuture ... done
[10:58:46.762] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:46.762] - nx: 2
[10:58:46.762] - relay: TRUE
[10:58:46.762] - stdout: TRUE
[10:58:46.762] - signal: TRUE
[10:58:46.763] - resignal: FALSE
[10:58:46.763] - force: TRUE
[10:58:46.763] - relayed: [n=2] FALSE, FALSE
[10:58:46.763] - queued futures: [n=2] FALSE, FALSE
[10:58:46.763]  - until=1
[10:58:46.766]  - relaying element #1
[10:58:46.767] result() for MulticoreFuture ...
[10:58:46.767] result() for MulticoreFuture ... done
[10:58:46.767] result() for MulticoreFuture ...
[10:58:46.767] result() for MulticoreFuture ... done
[10:58:46.767] result() for MulticoreFuture ...
[10:58:46.767] result() for MulticoreFuture ... done
[10:58:46.768] result() for MulticoreFuture ...
[10:58:46.768] result() for MulticoreFuture ... done
[10:58:46.768] - relayed: [n=2] TRUE, FALSE
[10:58:46.768] - queued futures: [n=2] TRUE, FALSE
[10:58:46.768] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:46.769]  length: 1 (resolved future 1)
[10:58:46.769] Future #2
[10:58:46.769] result() for MulticoreFuture ...
[10:58:46.770] result() for MulticoreFuture ...
[10:58:46.770] result() for MulticoreFuture ... done
[10:58:46.770] result() for MulticoreFuture ... done
[10:58:46.770] result() for MulticoreFuture ...
[10:58:46.771] result() for MulticoreFuture ... done
[10:58:46.771] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:46.771] - nx: 2
[10:58:46.771] - relay: TRUE
[10:58:46.771] - stdout: TRUE
[10:58:46.771] - signal: TRUE
[10:58:46.771] - resignal: FALSE
[10:58:46.772] - force: TRUE
[10:58:46.772] - relayed: [n=2] TRUE, FALSE
[10:58:46.772] - queued futures: [n=2] TRUE, FALSE
[10:58:46.772]  - until=2
[10:58:46.772]  - relaying element #2
[10:58:46.772] result() for MulticoreFuture ...
[10:58:46.772] result() for MulticoreFuture ... done
[10:58:46.772] result() for MulticoreFuture ...
[10:58:46.773] result() for MulticoreFuture ... done
[10:58:46.773] result() for MulticoreFuture ...
[10:58:46.773] result() for MulticoreFuture ... done
[10:58:46.773] result() for MulticoreFuture ...
[10:58:46.773] result() for MulticoreFuture ... done
[10:58:46.773] - relayed: [n=2] TRUE, TRUE
[10:58:46.773] - queued futures: [n=2] TRUE, TRUE
[10:58:46.773] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:46.773]  length: 0 (resolved future 2)
[10:58:46.774] Relaying remaining futures
[10:58:46.774] signalConditionsASAP(NULL, pos=0) ...
[10:58:46.774] - nx: 2
[10:58:46.774] - relay: TRUE
[10:58:46.774] - stdout: TRUE
[10:58:46.774] - signal: TRUE
[10:58:46.774] - resignal: FALSE
[10:58:46.774] - force: TRUE
[10:58:46.774] - relayed: [n=2] TRUE, TRUE
[10:58:46.774] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:46.775] - relayed: [n=2] TRUE, TRUE
[10:58:46.775] - queued futures: [n=2] TRUE, TRUE
[10:58:46.775] signalConditionsASAP(NULL, pos=0) ... done
[10:58:46.775] resolve() on list ... DONE
[10:58:46.775] result() for MulticoreFuture ...
[10:58:46.775] result() for MulticoreFuture ... done
[10:58:46.775] result() for MulticoreFuture ...
[10:58:46.775] result() for MulticoreFuture ... done
[10:58:46.776] result() for MulticoreFuture ...
[10:58:46.776] result() for MulticoreFuture ... done
[10:58:46.776] result() for MulticoreFuture ...
[10:58:46.776] result() for MulticoreFuture ... done
[10:58:46.776]  - Number of value chunks collected: 2
[10:58:46.776] Resolving 2 futures (chunks) ... DONE
[10:58:46.776] Reducing values from 2 chunks ...
[10:58:46.776]  - Number of values collected after concatenation: 3
[10:58:46.776]  - Number of values expected: 3
[10:58:46.777] Reducing values from 2 chunks ... DONE
[10:58:46.777] future_lapply() ... DONE
[10:58:46.777] plan(): Setting new future strategy stack:
[10:58:46.777] List of future strategies:
[10:58:46.777] 1. sequential:
[10:58:46.777]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:46.777]    - tweaked: FALSE
[10:58:46.777]    - call: plan(sequential)
[10:58:46.778] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:58:46.778] plan(): Setting new future strategy stack:
[10:58:46.779] List of future strategies:
[10:58:46.779] 1. multisession:
[10:58:46.779]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:46.779]    - tweaked: FALSE
[10:58:46.779]    - call: plan(strategy)
[10:58:46.779] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:58:46.779] multisession:
[10:58:46.779] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:46.779] - tweaked: FALSE
[10:58:46.779] - call: plan(strategy)
[10:58:46.783] getGlobalsAndPackages() ...
[10:58:46.783] Not searching for globals
[10:58:46.784] - globals: [0] <none>
[10:58:46.784] getGlobalsAndPackages() ... DONE
[10:58:47.264] Packages needed by the future expression (n = 0): <none>
[10:58:47.264] Packages needed by future strategies (n = 0): <none>
[10:58:47.265] {
[10:58:47.265]     {
[10:58:47.265]         {
[10:58:47.265]             ...future.startTime <- base::Sys.time()
[10:58:47.265]             {
[10:58:47.265]                 {
[10:58:47.265]                   {
[10:58:47.265]                     {
[10:58:47.265]                       base::local({
[10:58:47.265]                         has_future <- base::requireNamespace("future", 
[10:58:47.265]                           quietly = TRUE)
[10:58:47.265]                         if (has_future) {
[10:58:47.265]                           ns <- base::getNamespace("future")
[10:58:47.265]                           version <- ns[[".package"]][["version"]]
[10:58:47.265]                           if (is.null(version)) 
[10:58:47.265]                             version <- utils::packageVersion("future")
[10:58:47.265]                         }
[10:58:47.265]                         else {
[10:58:47.265]                           version <- NULL
[10:58:47.265]                         }
[10:58:47.265]                         if (!has_future || version < "1.8.0") {
[10:58:47.265]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.265]                             "", base::R.version$version.string), 
[10:58:47.265]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:47.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:47.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.265]                               "release", "version")], collapse = " "), 
[10:58:47.265]                             hostname = base::Sys.info()[["nodename"]])
[10:58:47.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.265]                             info)
[10:58:47.265]                           info <- base::paste(info, collapse = "; ")
[10:58:47.265]                           if (!has_future) {
[10:58:47.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.265]                               info)
[10:58:47.265]                           }
[10:58:47.265]                           else {
[10:58:47.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.265]                               info, version)
[10:58:47.265]                           }
[10:58:47.265]                           base::stop(msg)
[10:58:47.265]                         }
[10:58:47.265]                       })
[10:58:47.265]                     }
[10:58:47.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.265]                     base::options(mc.cores = 1L)
[10:58:47.265]                   }
[10:58:47.265]                   ...future.strategy.old <- future::plan("list")
[10:58:47.265]                   options(future.plan = NULL)
[10:58:47.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.265]                 }
[10:58:47.265]                 ...future.workdir <- getwd()
[10:58:47.265]             }
[10:58:47.265]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.265]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.265]         }
[10:58:47.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:47.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.265]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.265]             base::names(...future.oldOptions))
[10:58:47.265]     }
[10:58:47.265]     if (FALSE) {
[10:58:47.265]     }
[10:58:47.265]     else {
[10:58:47.265]         if (TRUE) {
[10:58:47.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.265]                 open = "w")
[10:58:47.265]         }
[10:58:47.265]         else {
[10:58:47.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.265]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.265]         }
[10:58:47.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.265]             base::sink(type = "output", split = FALSE)
[10:58:47.265]             base::close(...future.stdout)
[10:58:47.265]         }, add = TRUE)
[10:58:47.265]     }
[10:58:47.265]     ...future.frame <- base::sys.nframe()
[10:58:47.265]     ...future.conditions <- base::list()
[10:58:47.265]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.265]     if (FALSE) {
[10:58:47.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.265]     }
[10:58:47.265]     ...future.result <- base::tryCatch({
[10:58:47.265]         base::withCallingHandlers({
[10:58:47.265]             ...future.value <- base::withVisible(base::local({
[10:58:47.265]                 ...future.makeSendCondition <- base::local({
[10:58:47.265]                   sendCondition <- NULL
[10:58:47.265]                   function(frame = 1L) {
[10:58:47.265]                     if (is.function(sendCondition)) 
[10:58:47.265]                       return(sendCondition)
[10:58:47.265]                     ns <- getNamespace("parallel")
[10:58:47.265]                     if (exists("sendData", mode = "function", 
[10:58:47.265]                       envir = ns)) {
[10:58:47.265]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.265]                         envir = ns)
[10:58:47.265]                       envir <- sys.frame(frame)
[10:58:47.265]                       master <- NULL
[10:58:47.265]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.265]                         !identical(envir, emptyenv())) {
[10:58:47.265]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.265]                           inherits = FALSE)) {
[10:58:47.265]                           master <- get("master", mode = "list", 
[10:58:47.265]                             envir = envir, inherits = FALSE)
[10:58:47.265]                           if (inherits(master, c("SOCKnode", 
[10:58:47.265]                             "SOCK0node"))) {
[10:58:47.265]                             sendCondition <<- function(cond) {
[10:58:47.265]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.265]                                 success = TRUE)
[10:58:47.265]                               parallel_sendData(master, data)
[10:58:47.265]                             }
[10:58:47.265]                             return(sendCondition)
[10:58:47.265]                           }
[10:58:47.265]                         }
[10:58:47.265]                         frame <- frame + 1L
[10:58:47.265]                         envir <- sys.frame(frame)
[10:58:47.265]                       }
[10:58:47.265]                     }
[10:58:47.265]                     sendCondition <<- function(cond) NULL
[10:58:47.265]                   }
[10:58:47.265]                 })
[10:58:47.265]                 withCallingHandlers({
[10:58:47.265]                   NA
[10:58:47.265]                 }, immediateCondition = function(cond) {
[10:58:47.265]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.265]                   sendCondition(cond)
[10:58:47.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.265]                   {
[10:58:47.265]                     inherits <- base::inherits
[10:58:47.265]                     invokeRestart <- base::invokeRestart
[10:58:47.265]                     is.null <- base::is.null
[10:58:47.265]                     muffled <- FALSE
[10:58:47.265]                     if (inherits(cond, "message")) {
[10:58:47.265]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.265]                       if (muffled) 
[10:58:47.265]                         invokeRestart("muffleMessage")
[10:58:47.265]                     }
[10:58:47.265]                     else if (inherits(cond, "warning")) {
[10:58:47.265]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.265]                       if (muffled) 
[10:58:47.265]                         invokeRestart("muffleWarning")
[10:58:47.265]                     }
[10:58:47.265]                     else if (inherits(cond, "condition")) {
[10:58:47.265]                       if (!is.null(pattern)) {
[10:58:47.265]                         computeRestarts <- base::computeRestarts
[10:58:47.265]                         grepl <- base::grepl
[10:58:47.265]                         restarts <- computeRestarts(cond)
[10:58:47.265]                         for (restart in restarts) {
[10:58:47.265]                           name <- restart$name
[10:58:47.265]                           if (is.null(name)) 
[10:58:47.265]                             next
[10:58:47.265]                           if (!grepl(pattern, name)) 
[10:58:47.265]                             next
[10:58:47.265]                           invokeRestart(restart)
[10:58:47.265]                           muffled <- TRUE
[10:58:47.265]                           break
[10:58:47.265]                         }
[10:58:47.265]                       }
[10:58:47.265]                     }
[10:58:47.265]                     invisible(muffled)
[10:58:47.265]                   }
[10:58:47.265]                   muffleCondition(cond)
[10:58:47.265]                 })
[10:58:47.265]             }))
[10:58:47.265]             future::FutureResult(value = ...future.value$value, 
[10:58:47.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.265]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.265]                     ...future.globalenv.names))
[10:58:47.265]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.265]         }, condition = base::local({
[10:58:47.265]             c <- base::c
[10:58:47.265]             inherits <- base::inherits
[10:58:47.265]             invokeRestart <- base::invokeRestart
[10:58:47.265]             length <- base::length
[10:58:47.265]             list <- base::list
[10:58:47.265]             seq.int <- base::seq.int
[10:58:47.265]             signalCondition <- base::signalCondition
[10:58:47.265]             sys.calls <- base::sys.calls
[10:58:47.265]             `[[` <- base::`[[`
[10:58:47.265]             `+` <- base::`+`
[10:58:47.265]             `<<-` <- base::`<<-`
[10:58:47.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.265]                   3L)]
[10:58:47.265]             }
[10:58:47.265]             function(cond) {
[10:58:47.265]                 is_error <- inherits(cond, "error")
[10:58:47.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.265]                   NULL)
[10:58:47.265]                 if (is_error) {
[10:58:47.265]                   sessionInformation <- function() {
[10:58:47.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.265]                       search = base::search(), system = base::Sys.info())
[10:58:47.265]                   }
[10:58:47.265]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.265]                     cond$call), session = sessionInformation(), 
[10:58:47.265]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.265]                   signalCondition(cond)
[10:58:47.265]                 }
[10:58:47.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.265]                 "immediateCondition"))) {
[10:58:47.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.265]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.265]                   if (TRUE && !signal) {
[10:58:47.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.265]                     {
[10:58:47.265]                       inherits <- base::inherits
[10:58:47.265]                       invokeRestart <- base::invokeRestart
[10:58:47.265]                       is.null <- base::is.null
[10:58:47.265]                       muffled <- FALSE
[10:58:47.265]                       if (inherits(cond, "message")) {
[10:58:47.265]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.265]                         if (muffled) 
[10:58:47.265]                           invokeRestart("muffleMessage")
[10:58:47.265]                       }
[10:58:47.265]                       else if (inherits(cond, "warning")) {
[10:58:47.265]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.265]                         if (muffled) 
[10:58:47.265]                           invokeRestart("muffleWarning")
[10:58:47.265]                       }
[10:58:47.265]                       else if (inherits(cond, "condition")) {
[10:58:47.265]                         if (!is.null(pattern)) {
[10:58:47.265]                           computeRestarts <- base::computeRestarts
[10:58:47.265]                           grepl <- base::grepl
[10:58:47.265]                           restarts <- computeRestarts(cond)
[10:58:47.265]                           for (restart in restarts) {
[10:58:47.265]                             name <- restart$name
[10:58:47.265]                             if (is.null(name)) 
[10:58:47.265]                               next
[10:58:47.265]                             if (!grepl(pattern, name)) 
[10:58:47.265]                               next
[10:58:47.265]                             invokeRestart(restart)
[10:58:47.265]                             muffled <- TRUE
[10:58:47.265]                             break
[10:58:47.265]                           }
[10:58:47.265]                         }
[10:58:47.265]                       }
[10:58:47.265]                       invisible(muffled)
[10:58:47.265]                     }
[10:58:47.265]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.265]                   }
[10:58:47.265]                 }
[10:58:47.265]                 else {
[10:58:47.265]                   if (TRUE) {
[10:58:47.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.265]                     {
[10:58:47.265]                       inherits <- base::inherits
[10:58:47.265]                       invokeRestart <- base::invokeRestart
[10:58:47.265]                       is.null <- base::is.null
[10:58:47.265]                       muffled <- FALSE
[10:58:47.265]                       if (inherits(cond, "message")) {
[10:58:47.265]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.265]                         if (muffled) 
[10:58:47.265]                           invokeRestart("muffleMessage")
[10:58:47.265]                       }
[10:58:47.265]                       else if (inherits(cond, "warning")) {
[10:58:47.265]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.265]                         if (muffled) 
[10:58:47.265]                           invokeRestart("muffleWarning")
[10:58:47.265]                       }
[10:58:47.265]                       else if (inherits(cond, "condition")) {
[10:58:47.265]                         if (!is.null(pattern)) {
[10:58:47.265]                           computeRestarts <- base::computeRestarts
[10:58:47.265]                           grepl <- base::grepl
[10:58:47.265]                           restarts <- computeRestarts(cond)
[10:58:47.265]                           for (restart in restarts) {
[10:58:47.265]                             name <- restart$name
[10:58:47.265]                             if (is.null(name)) 
[10:58:47.265]                               next
[10:58:47.265]                             if (!grepl(pattern, name)) 
[10:58:47.265]                               next
[10:58:47.265]                             invokeRestart(restart)
[10:58:47.265]                             muffled <- TRUE
[10:58:47.265]                             break
[10:58:47.265]                           }
[10:58:47.265]                         }
[10:58:47.265]                       }
[10:58:47.265]                       invisible(muffled)
[10:58:47.265]                     }
[10:58:47.265]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.265]                   }
[10:58:47.265]                 }
[10:58:47.265]             }
[10:58:47.265]         }))
[10:58:47.265]     }, error = function(ex) {
[10:58:47.265]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.265]                 ...future.rng), started = ...future.startTime, 
[10:58:47.265]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.265]             version = "1.8"), class = "FutureResult")
[10:58:47.265]     }, finally = {
[10:58:47.265]         if (!identical(...future.workdir, getwd())) 
[10:58:47.265]             setwd(...future.workdir)
[10:58:47.265]         {
[10:58:47.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.265]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.265]             }
[10:58:47.265]             base::options(...future.oldOptions)
[10:58:47.265]             if (.Platform$OS.type == "windows") {
[10:58:47.265]                 old_names <- names(...future.oldEnvVars)
[10:58:47.265]                 envs <- base::Sys.getenv()
[10:58:47.265]                 names <- names(envs)
[10:58:47.265]                 common <- intersect(names, old_names)
[10:58:47.265]                 added <- setdiff(names, old_names)
[10:58:47.265]                 removed <- setdiff(old_names, names)
[10:58:47.265]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.265]                   envs[common]]
[10:58:47.265]                 NAMES <- toupper(changed)
[10:58:47.265]                 args <- list()
[10:58:47.265]                 for (kk in seq_along(NAMES)) {
[10:58:47.265]                   name <- changed[[kk]]
[10:58:47.265]                   NAME <- NAMES[[kk]]
[10:58:47.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.265]                     next
[10:58:47.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.265]                 }
[10:58:47.265]                 NAMES <- toupper(added)
[10:58:47.265]                 for (kk in seq_along(NAMES)) {
[10:58:47.265]                   name <- added[[kk]]
[10:58:47.265]                   NAME <- NAMES[[kk]]
[10:58:47.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.265]                     next
[10:58:47.265]                   args[[name]] <- ""
[10:58:47.265]                 }
[10:58:47.265]                 NAMES <- toupper(removed)
[10:58:47.265]                 for (kk in seq_along(NAMES)) {
[10:58:47.265]                   name <- removed[[kk]]
[10:58:47.265]                   NAME <- NAMES[[kk]]
[10:58:47.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.265]                     next
[10:58:47.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.265]                 }
[10:58:47.265]                 if (length(args) > 0) 
[10:58:47.265]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.265]             }
[10:58:47.265]             else {
[10:58:47.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.265]             }
[10:58:47.265]             {
[10:58:47.265]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.265]                   0L) {
[10:58:47.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.265]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.265]                   base::options(opts)
[10:58:47.265]                 }
[10:58:47.265]                 {
[10:58:47.265]                   {
[10:58:47.265]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.265]                     NULL
[10:58:47.265]                   }
[10:58:47.265]                   options(future.plan = NULL)
[10:58:47.265]                   if (is.na(NA_character_)) 
[10:58:47.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.265]                     .init = FALSE)
[10:58:47.265]                 }
[10:58:47.265]             }
[10:58:47.265]         }
[10:58:47.265]     })
[10:58:47.265]     if (TRUE) {
[10:58:47.265]         base::sink(type = "output", split = FALSE)
[10:58:47.265]         if (TRUE) {
[10:58:47.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.265]         }
[10:58:47.265]         else {
[10:58:47.265]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.265]         }
[10:58:47.265]         base::close(...future.stdout)
[10:58:47.265]         ...future.stdout <- NULL
[10:58:47.265]     }
[10:58:47.265]     ...future.result$conditions <- ...future.conditions
[10:58:47.265]     ...future.result$finished <- base::Sys.time()
[10:58:47.265]     ...future.result
[10:58:47.265] }
[10:58:47.317] MultisessionFuture started
[10:58:47.318] result() for ClusterFuture ...
[10:58:47.318] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.319] - Validating connection of MultisessionFuture
[10:58:47.349] - received message: FutureResult
[10:58:47.349] - Received FutureResult
[10:58:47.349] - Erased future from FutureRegistry
[10:58:47.349] result() for ClusterFuture ...
[10:58:47.350] - result already collected: FutureResult
[10:58:47.350] result() for ClusterFuture ... done
[10:58:47.350] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.350] result() for ClusterFuture ... done
[10:58:47.350] result() for ClusterFuture ...
[10:58:47.350] - result already collected: FutureResult
[10:58:47.350] result() for ClusterFuture ... done
[10:58:47.350] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:58:47.352] plan(): nbrOfWorkers() = 2
[10:58:47.352] future_lapply() ...
[10:58:47.354] Number of chunks: 2
[10:58:47.354] getGlobalsAndPackagesXApply() ...
[10:58:47.354]  - future.globals: TRUE
[10:58:47.354] getGlobalsAndPackages() ...
[10:58:47.354] Searching for globals...
[10:58:47.355] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:47.355] Searching for globals ... DONE
[10:58:47.356] Resolving globals: FALSE
[10:58:47.356] The total size of the 1 globals is 273 bytes (273 bytes)
[10:58:47.356] The total size of the 1 globals exported for future expression (‘FUN()’) is 273 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (273 bytes of class ‘function’)
[10:58:47.356] - globals: [1] ‘FUN’
[10:58:47.356] 
[10:58:47.357] getGlobalsAndPackages() ... DONE
[10:58:47.357]  - globals found/used: [n=1] ‘FUN’
[10:58:47.357]  - needed namespaces: [n=0] 
[10:58:47.357] Finding globals ... DONE
[10:58:47.357]  - use_args: TRUE
[10:58:47.357]  - Getting '...' globals ...
[10:58:47.357] resolve() on list ...
[10:58:47.357]  recursive: 0
[10:58:47.357]  length: 1
[10:58:47.358]  elements: ‘...’
[10:58:47.358]  length: 0 (resolved future 1)
[10:58:47.358] resolve() on list ... DONE
[10:58:47.358]    - '...' content: [n=0] 
[10:58:47.358] List of 1
[10:58:47.358]  $ ...: list()
[10:58:47.358]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.358]  - attr(*, "where")=List of 1
[10:58:47.358]   ..$ ...:<environment: 0x55f48b35ceb8> 
[10:58:47.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.358]  - attr(*, "resolved")= logi TRUE
[10:58:47.358]  - attr(*, "total_size")= num NA
[10:58:47.360]  - Getting '...' globals ... DONE
[10:58:47.361] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:47.361] List of 2
[10:58:47.361]  $ ...future.FUN:function (x, ...)  
[10:58:47.361]  $ ...          : list()
[10:58:47.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.361]  - attr(*, "where")=List of 2
[10:58:47.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:47.361]   ..$ ...          :<environment: 0x55f48b35ceb8> 
[10:58:47.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.361]  - attr(*, "resolved")= logi FALSE
[10:58:47.361]  - attr(*, "total_size")= num 5249
[10:58:47.363] Packages to be attached in all futures: [n=0] 
[10:58:47.363] getGlobalsAndPackagesXApply() ... DONE
[10:58:47.364] Number of futures (= number of chunks): 2
[10:58:47.364] Launching 2 futures (chunks) ...
[10:58:47.364] Chunk #1 of 2 ...
[10:58:47.364]  - Finding globals in 'X' for chunk #1 ...
[10:58:47.364] getGlobalsAndPackages() ...
[10:58:47.364] Searching for globals...
[10:58:47.364] 
[10:58:47.364] Searching for globals ... DONE
[10:58:47.364] - globals: [0] <none>
[10:58:47.365] getGlobalsAndPackages() ... DONE
[10:58:47.365]    + additional globals found: [n=0] 
[10:58:47.365]    + additional namespaces needed: [n=0] 
[10:58:47.365]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:47.365]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.365]  - seeds: <none>
[10:58:47.365]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.365] getGlobalsAndPackages() ...
[10:58:47.365] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.365] Resolving globals: FALSE
[10:58:47.365] Tweak future expression to call with '...' arguments ...
[10:58:47.366] {
[10:58:47.366]     do.call(function(...) {
[10:58:47.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.366]             on.exit(options(oopts), add = TRUE)
[10:58:47.366]         }
[10:58:47.366]         {
[10:58:47.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.366]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.366]             })
[10:58:47.366]         }
[10:58:47.366]     }, args = future.call.arguments)
[10:58:47.366] }
[10:58:47.366] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.366] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.366] 
[10:58:47.366] getGlobalsAndPackages() ... DONE
[10:58:47.367] run() for ‘Future’ ...
[10:58:47.367] - state: ‘created’
[10:58:47.367] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.381] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.382]   - Field: ‘node’
[10:58:47.382]   - Field: ‘label’
[10:58:47.382]   - Field: ‘local’
[10:58:47.382]   - Field: ‘owner’
[10:58:47.382]   - Field: ‘envir’
[10:58:47.382]   - Field: ‘workers’
[10:58:47.382]   - Field: ‘packages’
[10:58:47.382]   - Field: ‘gc’
[10:58:47.382]   - Field: ‘conditions’
[10:58:47.382]   - Field: ‘persistent’
[10:58:47.383]   - Field: ‘expr’
[10:58:47.383]   - Field: ‘uuid’
[10:58:47.383]   - Field: ‘seed’
[10:58:47.383]   - Field: ‘version’
[10:58:47.383]   - Field: ‘result’
[10:58:47.383]   - Field: ‘asynchronous’
[10:58:47.383]   - Field: ‘calls’
[10:58:47.383]   - Field: ‘globals’
[10:58:47.383]   - Field: ‘stdout’
[10:58:47.384]   - Field: ‘earlySignal’
[10:58:47.384]   - Field: ‘lazy’
[10:58:47.384]   - Field: ‘state’
[10:58:47.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.384] - Launch lazy future ...
[10:58:47.384] Packages needed by the future expression (n = 0): <none>
[10:58:47.384] Packages needed by future strategies (n = 0): <none>
[10:58:47.385] {
[10:58:47.385]     {
[10:58:47.385]         {
[10:58:47.385]             ...future.startTime <- base::Sys.time()
[10:58:47.385]             {
[10:58:47.385]                 {
[10:58:47.385]                   {
[10:58:47.385]                     {
[10:58:47.385]                       base::local({
[10:58:47.385]                         has_future <- base::requireNamespace("future", 
[10:58:47.385]                           quietly = TRUE)
[10:58:47.385]                         if (has_future) {
[10:58:47.385]                           ns <- base::getNamespace("future")
[10:58:47.385]                           version <- ns[[".package"]][["version"]]
[10:58:47.385]                           if (is.null(version)) 
[10:58:47.385]                             version <- utils::packageVersion("future")
[10:58:47.385]                         }
[10:58:47.385]                         else {
[10:58:47.385]                           version <- NULL
[10:58:47.385]                         }
[10:58:47.385]                         if (!has_future || version < "1.8.0") {
[10:58:47.385]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.385]                             "", base::R.version$version.string), 
[10:58:47.385]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:47.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:47.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.385]                               "release", "version")], collapse = " "), 
[10:58:47.385]                             hostname = base::Sys.info()[["nodename"]])
[10:58:47.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.385]                             info)
[10:58:47.385]                           info <- base::paste(info, collapse = "; ")
[10:58:47.385]                           if (!has_future) {
[10:58:47.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.385]                               info)
[10:58:47.385]                           }
[10:58:47.385]                           else {
[10:58:47.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.385]                               info, version)
[10:58:47.385]                           }
[10:58:47.385]                           base::stop(msg)
[10:58:47.385]                         }
[10:58:47.385]                       })
[10:58:47.385]                     }
[10:58:47.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.385]                     base::options(mc.cores = 1L)
[10:58:47.385]                   }
[10:58:47.385]                   ...future.strategy.old <- future::plan("list")
[10:58:47.385]                   options(future.plan = NULL)
[10:58:47.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.385]                 }
[10:58:47.385]                 ...future.workdir <- getwd()
[10:58:47.385]             }
[10:58:47.385]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.385]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.385]         }
[10:58:47.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.385]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.385]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.385]             base::names(...future.oldOptions))
[10:58:47.385]     }
[10:58:47.385]     if (FALSE) {
[10:58:47.385]     }
[10:58:47.385]     else {
[10:58:47.385]         if (TRUE) {
[10:58:47.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.385]                 open = "w")
[10:58:47.385]         }
[10:58:47.385]         else {
[10:58:47.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.385]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.385]         }
[10:58:47.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.385]             base::sink(type = "output", split = FALSE)
[10:58:47.385]             base::close(...future.stdout)
[10:58:47.385]         }, add = TRUE)
[10:58:47.385]     }
[10:58:47.385]     ...future.frame <- base::sys.nframe()
[10:58:47.385]     ...future.conditions <- base::list()
[10:58:47.385]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.385]     if (FALSE) {
[10:58:47.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.385]     }
[10:58:47.385]     ...future.result <- base::tryCatch({
[10:58:47.385]         base::withCallingHandlers({
[10:58:47.385]             ...future.value <- base::withVisible(base::local({
[10:58:47.385]                 ...future.makeSendCondition <- base::local({
[10:58:47.385]                   sendCondition <- NULL
[10:58:47.385]                   function(frame = 1L) {
[10:58:47.385]                     if (is.function(sendCondition)) 
[10:58:47.385]                       return(sendCondition)
[10:58:47.385]                     ns <- getNamespace("parallel")
[10:58:47.385]                     if (exists("sendData", mode = "function", 
[10:58:47.385]                       envir = ns)) {
[10:58:47.385]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.385]                         envir = ns)
[10:58:47.385]                       envir <- sys.frame(frame)
[10:58:47.385]                       master <- NULL
[10:58:47.385]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.385]                         !identical(envir, emptyenv())) {
[10:58:47.385]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.385]                           inherits = FALSE)) {
[10:58:47.385]                           master <- get("master", mode = "list", 
[10:58:47.385]                             envir = envir, inherits = FALSE)
[10:58:47.385]                           if (inherits(master, c("SOCKnode", 
[10:58:47.385]                             "SOCK0node"))) {
[10:58:47.385]                             sendCondition <<- function(cond) {
[10:58:47.385]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.385]                                 success = TRUE)
[10:58:47.385]                               parallel_sendData(master, data)
[10:58:47.385]                             }
[10:58:47.385]                             return(sendCondition)
[10:58:47.385]                           }
[10:58:47.385]                         }
[10:58:47.385]                         frame <- frame + 1L
[10:58:47.385]                         envir <- sys.frame(frame)
[10:58:47.385]                       }
[10:58:47.385]                     }
[10:58:47.385]                     sendCondition <<- function(cond) NULL
[10:58:47.385]                   }
[10:58:47.385]                 })
[10:58:47.385]                 withCallingHandlers({
[10:58:47.385]                   {
[10:58:47.385]                     do.call(function(...) {
[10:58:47.385]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.385]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.385]                         ...future.globals.maxSize)) {
[10:58:47.385]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.385]                         on.exit(options(oopts), add = TRUE)
[10:58:47.385]                       }
[10:58:47.385]                       {
[10:58:47.385]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.385]                           FUN = function(jj) {
[10:58:47.385]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.385]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.385]                           })
[10:58:47.385]                       }
[10:58:47.385]                     }, args = future.call.arguments)
[10:58:47.385]                   }
[10:58:47.385]                 }, immediateCondition = function(cond) {
[10:58:47.385]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.385]                   sendCondition(cond)
[10:58:47.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.385]                   {
[10:58:47.385]                     inherits <- base::inherits
[10:58:47.385]                     invokeRestart <- base::invokeRestart
[10:58:47.385]                     is.null <- base::is.null
[10:58:47.385]                     muffled <- FALSE
[10:58:47.385]                     if (inherits(cond, "message")) {
[10:58:47.385]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.385]                       if (muffled) 
[10:58:47.385]                         invokeRestart("muffleMessage")
[10:58:47.385]                     }
[10:58:47.385]                     else if (inherits(cond, "warning")) {
[10:58:47.385]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.385]                       if (muffled) 
[10:58:47.385]                         invokeRestart("muffleWarning")
[10:58:47.385]                     }
[10:58:47.385]                     else if (inherits(cond, "condition")) {
[10:58:47.385]                       if (!is.null(pattern)) {
[10:58:47.385]                         computeRestarts <- base::computeRestarts
[10:58:47.385]                         grepl <- base::grepl
[10:58:47.385]                         restarts <- computeRestarts(cond)
[10:58:47.385]                         for (restart in restarts) {
[10:58:47.385]                           name <- restart$name
[10:58:47.385]                           if (is.null(name)) 
[10:58:47.385]                             next
[10:58:47.385]                           if (!grepl(pattern, name)) 
[10:58:47.385]                             next
[10:58:47.385]                           invokeRestart(restart)
[10:58:47.385]                           muffled <- TRUE
[10:58:47.385]                           break
[10:58:47.385]                         }
[10:58:47.385]                       }
[10:58:47.385]                     }
[10:58:47.385]                     invisible(muffled)
[10:58:47.385]                   }
[10:58:47.385]                   muffleCondition(cond)
[10:58:47.385]                 })
[10:58:47.385]             }))
[10:58:47.385]             future::FutureResult(value = ...future.value$value, 
[10:58:47.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.385]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.385]                     ...future.globalenv.names))
[10:58:47.385]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.385]         }, condition = base::local({
[10:58:47.385]             c <- base::c
[10:58:47.385]             inherits <- base::inherits
[10:58:47.385]             invokeRestart <- base::invokeRestart
[10:58:47.385]             length <- base::length
[10:58:47.385]             list <- base::list
[10:58:47.385]             seq.int <- base::seq.int
[10:58:47.385]             signalCondition <- base::signalCondition
[10:58:47.385]             sys.calls <- base::sys.calls
[10:58:47.385]             `[[` <- base::`[[`
[10:58:47.385]             `+` <- base::`+`
[10:58:47.385]             `<<-` <- base::`<<-`
[10:58:47.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.385]                   3L)]
[10:58:47.385]             }
[10:58:47.385]             function(cond) {
[10:58:47.385]                 is_error <- inherits(cond, "error")
[10:58:47.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.385]                   NULL)
[10:58:47.385]                 if (is_error) {
[10:58:47.385]                   sessionInformation <- function() {
[10:58:47.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.385]                       search = base::search(), system = base::Sys.info())
[10:58:47.385]                   }
[10:58:47.385]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.385]                     cond$call), session = sessionInformation(), 
[10:58:47.385]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.385]                   signalCondition(cond)
[10:58:47.385]                 }
[10:58:47.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.385]                 "immediateCondition"))) {
[10:58:47.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.385]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.385]                   if (TRUE && !signal) {
[10:58:47.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.385]                     {
[10:58:47.385]                       inherits <- base::inherits
[10:58:47.385]                       invokeRestart <- base::invokeRestart
[10:58:47.385]                       is.null <- base::is.null
[10:58:47.385]                       muffled <- FALSE
[10:58:47.385]                       if (inherits(cond, "message")) {
[10:58:47.385]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.385]                         if (muffled) 
[10:58:47.385]                           invokeRestart("muffleMessage")
[10:58:47.385]                       }
[10:58:47.385]                       else if (inherits(cond, "warning")) {
[10:58:47.385]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.385]                         if (muffled) 
[10:58:47.385]                           invokeRestart("muffleWarning")
[10:58:47.385]                       }
[10:58:47.385]                       else if (inherits(cond, "condition")) {
[10:58:47.385]                         if (!is.null(pattern)) {
[10:58:47.385]                           computeRestarts <- base::computeRestarts
[10:58:47.385]                           grepl <- base::grepl
[10:58:47.385]                           restarts <- computeRestarts(cond)
[10:58:47.385]                           for (restart in restarts) {
[10:58:47.385]                             name <- restart$name
[10:58:47.385]                             if (is.null(name)) 
[10:58:47.385]                               next
[10:58:47.385]                             if (!grepl(pattern, name)) 
[10:58:47.385]                               next
[10:58:47.385]                             invokeRestart(restart)
[10:58:47.385]                             muffled <- TRUE
[10:58:47.385]                             break
[10:58:47.385]                           }
[10:58:47.385]                         }
[10:58:47.385]                       }
[10:58:47.385]                       invisible(muffled)
[10:58:47.385]                     }
[10:58:47.385]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.385]                   }
[10:58:47.385]                 }
[10:58:47.385]                 else {
[10:58:47.385]                   if (TRUE) {
[10:58:47.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.385]                     {
[10:58:47.385]                       inherits <- base::inherits
[10:58:47.385]                       invokeRestart <- base::invokeRestart
[10:58:47.385]                       is.null <- base::is.null
[10:58:47.385]                       muffled <- FALSE
[10:58:47.385]                       if (inherits(cond, "message")) {
[10:58:47.385]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.385]                         if (muffled) 
[10:58:47.385]                           invokeRestart("muffleMessage")
[10:58:47.385]                       }
[10:58:47.385]                       else if (inherits(cond, "warning")) {
[10:58:47.385]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.385]                         if (muffled) 
[10:58:47.385]                           invokeRestart("muffleWarning")
[10:58:47.385]                       }
[10:58:47.385]                       else if (inherits(cond, "condition")) {
[10:58:47.385]                         if (!is.null(pattern)) {
[10:58:47.385]                           computeRestarts <- base::computeRestarts
[10:58:47.385]                           grepl <- base::grepl
[10:58:47.385]                           restarts <- computeRestarts(cond)
[10:58:47.385]                           for (restart in restarts) {
[10:58:47.385]                             name <- restart$name
[10:58:47.385]                             if (is.null(name)) 
[10:58:47.385]                               next
[10:58:47.385]                             if (!grepl(pattern, name)) 
[10:58:47.385]                               next
[10:58:47.385]                             invokeRestart(restart)
[10:58:47.385]                             muffled <- TRUE
[10:58:47.385]                             break
[10:58:47.385]                           }
[10:58:47.385]                         }
[10:58:47.385]                       }
[10:58:47.385]                       invisible(muffled)
[10:58:47.385]                     }
[10:58:47.385]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.385]                   }
[10:58:47.385]                 }
[10:58:47.385]             }
[10:58:47.385]         }))
[10:58:47.385]     }, error = function(ex) {
[10:58:47.385]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.385]                 ...future.rng), started = ...future.startTime, 
[10:58:47.385]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.385]             version = "1.8"), class = "FutureResult")
[10:58:47.385]     }, finally = {
[10:58:47.385]         if (!identical(...future.workdir, getwd())) 
[10:58:47.385]             setwd(...future.workdir)
[10:58:47.385]         {
[10:58:47.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.385]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.385]             }
[10:58:47.385]             base::options(...future.oldOptions)
[10:58:47.385]             if (.Platform$OS.type == "windows") {
[10:58:47.385]                 old_names <- names(...future.oldEnvVars)
[10:58:47.385]                 envs <- base::Sys.getenv()
[10:58:47.385]                 names <- names(envs)
[10:58:47.385]                 common <- intersect(names, old_names)
[10:58:47.385]                 added <- setdiff(names, old_names)
[10:58:47.385]                 removed <- setdiff(old_names, names)
[10:58:47.385]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.385]                   envs[common]]
[10:58:47.385]                 NAMES <- toupper(changed)
[10:58:47.385]                 args <- list()
[10:58:47.385]                 for (kk in seq_along(NAMES)) {
[10:58:47.385]                   name <- changed[[kk]]
[10:58:47.385]                   NAME <- NAMES[[kk]]
[10:58:47.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.385]                     next
[10:58:47.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.385]                 }
[10:58:47.385]                 NAMES <- toupper(added)
[10:58:47.385]                 for (kk in seq_along(NAMES)) {
[10:58:47.385]                   name <- added[[kk]]
[10:58:47.385]                   NAME <- NAMES[[kk]]
[10:58:47.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.385]                     next
[10:58:47.385]                   args[[name]] <- ""
[10:58:47.385]                 }
[10:58:47.385]                 NAMES <- toupper(removed)
[10:58:47.385]                 for (kk in seq_along(NAMES)) {
[10:58:47.385]                   name <- removed[[kk]]
[10:58:47.385]                   NAME <- NAMES[[kk]]
[10:58:47.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.385]                     next
[10:58:47.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.385]                 }
[10:58:47.385]                 if (length(args) > 0) 
[10:58:47.385]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.385]             }
[10:58:47.385]             else {
[10:58:47.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.385]             }
[10:58:47.385]             {
[10:58:47.385]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.385]                   0L) {
[10:58:47.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.385]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.385]                   base::options(opts)
[10:58:47.385]                 }
[10:58:47.385]                 {
[10:58:47.385]                   {
[10:58:47.385]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.385]                     NULL
[10:58:47.385]                   }
[10:58:47.385]                   options(future.plan = NULL)
[10:58:47.385]                   if (is.na(NA_character_)) 
[10:58:47.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.385]                     .init = FALSE)
[10:58:47.385]                 }
[10:58:47.385]             }
[10:58:47.385]         }
[10:58:47.385]     })
[10:58:47.385]     if (TRUE) {
[10:58:47.385]         base::sink(type = "output", split = FALSE)
[10:58:47.385]         if (TRUE) {
[10:58:47.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.385]         }
[10:58:47.385]         else {
[10:58:47.385]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.385]         }
[10:58:47.385]         base::close(...future.stdout)
[10:58:47.385]         ...future.stdout <- NULL
[10:58:47.385]     }
[10:58:47.385]     ...future.result$conditions <- ...future.conditions
[10:58:47.385]     ...future.result$finished <- base::Sys.time()
[10:58:47.385]     ...future.result
[10:58:47.385] }
[10:58:47.388] Exporting 5 global objects (942 bytes) to cluster node #1 ...
[10:58:47.388] Exporting ‘...future.FUN’ (273 bytes) to cluster node #1 ...
[10:58:47.389] Exporting ‘...future.FUN’ (273 bytes) to cluster node #1 ... DONE
[10:58:47.389] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:47.390] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:47.390] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #1 ...
[10:58:47.390] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #1 ... DONE
[10:58:47.390] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:47.391] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.391] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:47.391] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.392] Exporting 5 global objects (942 bytes) to cluster node #1 ... DONE
[10:58:47.392] MultisessionFuture started
[10:58:47.392] - Launch lazy future ... done
[10:58:47.392] run() for ‘MultisessionFuture’ ... done
[10:58:47.393] Created future:
[10:58:47.393] MultisessionFuture:
[10:58:47.393] Label: ‘future_eapply-1’
[10:58:47.393] Expression:
[10:58:47.393] {
[10:58:47.393]     do.call(function(...) {
[10:58:47.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.393]             on.exit(options(oopts), add = TRUE)
[10:58:47.393]         }
[10:58:47.393]         {
[10:58:47.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.393]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.393]             })
[10:58:47.393]         }
[10:58:47.393]     }, args = future.call.arguments)
[10:58:47.393] }
[10:58:47.393] Lazy evaluation: FALSE
[10:58:47.393] Asynchronous evaluation: TRUE
[10:58:47.393] Local evaluation: TRUE
[10:58:47.393] Environment: R_GlobalEnv
[10:58:47.393] Capture standard output: TRUE
[10:58:47.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.393] Globals: 5 objects totaling 479 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.393] Packages: <none>
[10:58:47.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.393] Resolved: FALSE
[10:58:47.393] Value: <not collected>
[10:58:47.393] Conditions captured: <none>
[10:58:47.393] Early signaling: FALSE
[10:58:47.393] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.393] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.405] Chunk #1 of 2 ... DONE
[10:58:47.405] Chunk #2 of 2 ...
[10:58:47.405]  - Finding globals in 'X' for chunk #2 ...
[10:58:47.405] getGlobalsAndPackages() ...
[10:58:47.405] Searching for globals...
[10:58:47.405] 
[10:58:47.406] Searching for globals ... DONE
[10:58:47.406] - globals: [0] <none>
[10:58:47.406] getGlobalsAndPackages() ... DONE
[10:58:47.406]    + additional globals found: [n=0] 
[10:58:47.406]    + additional namespaces needed: [n=0] 
[10:58:47.406]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:47.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.406]  - seeds: <none>
[10:58:47.406]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.407] getGlobalsAndPackages() ...
[10:58:47.407] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.407] Resolving globals: FALSE
[10:58:47.407] Tweak future expression to call with '...' arguments ...
[10:58:47.407] {
[10:58:47.407]     do.call(function(...) {
[10:58:47.407]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.407]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.407]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.407]             on.exit(options(oopts), add = TRUE)
[10:58:47.407]         }
[10:58:47.407]         {
[10:58:47.407]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.407]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.407]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.407]             })
[10:58:47.407]         }
[10:58:47.407]     }, args = future.call.arguments)
[10:58:47.407] }
[10:58:47.407] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.408] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.408] 
[10:58:47.408] getGlobalsAndPackages() ... DONE
[10:58:47.408] run() for ‘Future’ ...
[10:58:47.409] - state: ‘created’
[10:58:47.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.424]   - Field: ‘node’
[10:58:47.424]   - Field: ‘label’
[10:58:47.424]   - Field: ‘local’
[10:58:47.424]   - Field: ‘owner’
[10:58:47.424]   - Field: ‘envir’
[10:58:47.424]   - Field: ‘workers’
[10:58:47.424]   - Field: ‘packages’
[10:58:47.424]   - Field: ‘gc’
[10:58:47.424]   - Field: ‘conditions’
[10:58:47.425]   - Field: ‘persistent’
[10:58:47.425]   - Field: ‘expr’
[10:58:47.425]   - Field: ‘uuid’
[10:58:47.425]   - Field: ‘seed’
[10:58:47.425]   - Field: ‘version’
[10:58:47.425]   - Field: ‘result’
[10:58:47.425]   - Field: ‘asynchronous’
[10:58:47.425]   - Field: ‘calls’
[10:58:47.425]   - Field: ‘globals’
[10:58:47.426]   - Field: ‘stdout’
[10:58:47.426]   - Field: ‘earlySignal’
[10:58:47.426]   - Field: ‘lazy’
[10:58:47.426]   - Field: ‘state’
[10:58:47.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.426] - Launch lazy future ...
[10:58:47.426] Packages needed by the future expression (n = 0): <none>
[10:58:47.427] Packages needed by future strategies (n = 0): <none>
[10:58:47.427] {
[10:58:47.427]     {
[10:58:47.427]         {
[10:58:47.427]             ...future.startTime <- base::Sys.time()
[10:58:47.427]             {
[10:58:47.427]                 {
[10:58:47.427]                   {
[10:58:47.427]                     {
[10:58:47.427]                       base::local({
[10:58:47.427]                         has_future <- base::requireNamespace("future", 
[10:58:47.427]                           quietly = TRUE)
[10:58:47.427]                         if (has_future) {
[10:58:47.427]                           ns <- base::getNamespace("future")
[10:58:47.427]                           version <- ns[[".package"]][["version"]]
[10:58:47.427]                           if (is.null(version)) 
[10:58:47.427]                             version <- utils::packageVersion("future")
[10:58:47.427]                         }
[10:58:47.427]                         else {
[10:58:47.427]                           version <- NULL
[10:58:47.427]                         }
[10:58:47.427]                         if (!has_future || version < "1.8.0") {
[10:58:47.427]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.427]                             "", base::R.version$version.string), 
[10:58:47.427]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:47.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:47.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.427]                               "release", "version")], collapse = " "), 
[10:58:47.427]                             hostname = base::Sys.info()[["nodename"]])
[10:58:47.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.427]                             info)
[10:58:47.427]                           info <- base::paste(info, collapse = "; ")
[10:58:47.427]                           if (!has_future) {
[10:58:47.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.427]                               info)
[10:58:47.427]                           }
[10:58:47.427]                           else {
[10:58:47.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.427]                               info, version)
[10:58:47.427]                           }
[10:58:47.427]                           base::stop(msg)
[10:58:47.427]                         }
[10:58:47.427]                       })
[10:58:47.427]                     }
[10:58:47.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.427]                     base::options(mc.cores = 1L)
[10:58:47.427]                   }
[10:58:47.427]                   ...future.strategy.old <- future::plan("list")
[10:58:47.427]                   options(future.plan = NULL)
[10:58:47.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.427]                 }
[10:58:47.427]                 ...future.workdir <- getwd()
[10:58:47.427]             }
[10:58:47.427]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.427]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.427]         }
[10:58:47.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.427]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.427]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.427]             base::names(...future.oldOptions))
[10:58:47.427]     }
[10:58:47.427]     if (FALSE) {
[10:58:47.427]     }
[10:58:47.427]     else {
[10:58:47.427]         if (TRUE) {
[10:58:47.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.427]                 open = "w")
[10:58:47.427]         }
[10:58:47.427]         else {
[10:58:47.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.427]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.427]         }
[10:58:47.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.427]             base::sink(type = "output", split = FALSE)
[10:58:47.427]             base::close(...future.stdout)
[10:58:47.427]         }, add = TRUE)
[10:58:47.427]     }
[10:58:47.427]     ...future.frame <- base::sys.nframe()
[10:58:47.427]     ...future.conditions <- base::list()
[10:58:47.427]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.427]     if (FALSE) {
[10:58:47.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.427]     }
[10:58:47.427]     ...future.result <- base::tryCatch({
[10:58:47.427]         base::withCallingHandlers({
[10:58:47.427]             ...future.value <- base::withVisible(base::local({
[10:58:47.427]                 ...future.makeSendCondition <- base::local({
[10:58:47.427]                   sendCondition <- NULL
[10:58:47.427]                   function(frame = 1L) {
[10:58:47.427]                     if (is.function(sendCondition)) 
[10:58:47.427]                       return(sendCondition)
[10:58:47.427]                     ns <- getNamespace("parallel")
[10:58:47.427]                     if (exists("sendData", mode = "function", 
[10:58:47.427]                       envir = ns)) {
[10:58:47.427]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.427]                         envir = ns)
[10:58:47.427]                       envir <- sys.frame(frame)
[10:58:47.427]                       master <- NULL
[10:58:47.427]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.427]                         !identical(envir, emptyenv())) {
[10:58:47.427]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.427]                           inherits = FALSE)) {
[10:58:47.427]                           master <- get("master", mode = "list", 
[10:58:47.427]                             envir = envir, inherits = FALSE)
[10:58:47.427]                           if (inherits(master, c("SOCKnode", 
[10:58:47.427]                             "SOCK0node"))) {
[10:58:47.427]                             sendCondition <<- function(cond) {
[10:58:47.427]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.427]                                 success = TRUE)
[10:58:47.427]                               parallel_sendData(master, data)
[10:58:47.427]                             }
[10:58:47.427]                             return(sendCondition)
[10:58:47.427]                           }
[10:58:47.427]                         }
[10:58:47.427]                         frame <- frame + 1L
[10:58:47.427]                         envir <- sys.frame(frame)
[10:58:47.427]                       }
[10:58:47.427]                     }
[10:58:47.427]                     sendCondition <<- function(cond) NULL
[10:58:47.427]                   }
[10:58:47.427]                 })
[10:58:47.427]                 withCallingHandlers({
[10:58:47.427]                   {
[10:58:47.427]                     do.call(function(...) {
[10:58:47.427]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.427]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.427]                         ...future.globals.maxSize)) {
[10:58:47.427]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.427]                         on.exit(options(oopts), add = TRUE)
[10:58:47.427]                       }
[10:58:47.427]                       {
[10:58:47.427]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.427]                           FUN = function(jj) {
[10:58:47.427]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.427]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.427]                           })
[10:58:47.427]                       }
[10:58:47.427]                     }, args = future.call.arguments)
[10:58:47.427]                   }
[10:58:47.427]                 }, immediateCondition = function(cond) {
[10:58:47.427]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.427]                   sendCondition(cond)
[10:58:47.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.427]                   {
[10:58:47.427]                     inherits <- base::inherits
[10:58:47.427]                     invokeRestart <- base::invokeRestart
[10:58:47.427]                     is.null <- base::is.null
[10:58:47.427]                     muffled <- FALSE
[10:58:47.427]                     if (inherits(cond, "message")) {
[10:58:47.427]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.427]                       if (muffled) 
[10:58:47.427]                         invokeRestart("muffleMessage")
[10:58:47.427]                     }
[10:58:47.427]                     else if (inherits(cond, "warning")) {
[10:58:47.427]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.427]                       if (muffled) 
[10:58:47.427]                         invokeRestart("muffleWarning")
[10:58:47.427]                     }
[10:58:47.427]                     else if (inherits(cond, "condition")) {
[10:58:47.427]                       if (!is.null(pattern)) {
[10:58:47.427]                         computeRestarts <- base::computeRestarts
[10:58:47.427]                         grepl <- base::grepl
[10:58:47.427]                         restarts <- computeRestarts(cond)
[10:58:47.427]                         for (restart in restarts) {
[10:58:47.427]                           name <- restart$name
[10:58:47.427]                           if (is.null(name)) 
[10:58:47.427]                             next
[10:58:47.427]                           if (!grepl(pattern, name)) 
[10:58:47.427]                             next
[10:58:47.427]                           invokeRestart(restart)
[10:58:47.427]                           muffled <- TRUE
[10:58:47.427]                           break
[10:58:47.427]                         }
[10:58:47.427]                       }
[10:58:47.427]                     }
[10:58:47.427]                     invisible(muffled)
[10:58:47.427]                   }
[10:58:47.427]                   muffleCondition(cond)
[10:58:47.427]                 })
[10:58:47.427]             }))
[10:58:47.427]             future::FutureResult(value = ...future.value$value, 
[10:58:47.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.427]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.427]                     ...future.globalenv.names))
[10:58:47.427]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.427]         }, condition = base::local({
[10:58:47.427]             c <- base::c
[10:58:47.427]             inherits <- base::inherits
[10:58:47.427]             invokeRestart <- base::invokeRestart
[10:58:47.427]             length <- base::length
[10:58:47.427]             list <- base::list
[10:58:47.427]             seq.int <- base::seq.int
[10:58:47.427]             signalCondition <- base::signalCondition
[10:58:47.427]             sys.calls <- base::sys.calls
[10:58:47.427]             `[[` <- base::`[[`
[10:58:47.427]             `+` <- base::`+`
[10:58:47.427]             `<<-` <- base::`<<-`
[10:58:47.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.427]                   3L)]
[10:58:47.427]             }
[10:58:47.427]             function(cond) {
[10:58:47.427]                 is_error <- inherits(cond, "error")
[10:58:47.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.427]                   NULL)
[10:58:47.427]                 if (is_error) {
[10:58:47.427]                   sessionInformation <- function() {
[10:58:47.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.427]                       search = base::search(), system = base::Sys.info())
[10:58:47.427]                   }
[10:58:47.427]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.427]                     cond$call), session = sessionInformation(), 
[10:58:47.427]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.427]                   signalCondition(cond)
[10:58:47.427]                 }
[10:58:47.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.427]                 "immediateCondition"))) {
[10:58:47.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.427]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.427]                   if (TRUE && !signal) {
[10:58:47.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.427]                     {
[10:58:47.427]                       inherits <- base::inherits
[10:58:47.427]                       invokeRestart <- base::invokeRestart
[10:58:47.427]                       is.null <- base::is.null
[10:58:47.427]                       muffled <- FALSE
[10:58:47.427]                       if (inherits(cond, "message")) {
[10:58:47.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.427]                         if (muffled) 
[10:58:47.427]                           invokeRestart("muffleMessage")
[10:58:47.427]                       }
[10:58:47.427]                       else if (inherits(cond, "warning")) {
[10:58:47.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.427]                         if (muffled) 
[10:58:47.427]                           invokeRestart("muffleWarning")
[10:58:47.427]                       }
[10:58:47.427]                       else if (inherits(cond, "condition")) {
[10:58:47.427]                         if (!is.null(pattern)) {
[10:58:47.427]                           computeRestarts <- base::computeRestarts
[10:58:47.427]                           grepl <- base::grepl
[10:58:47.427]                           restarts <- computeRestarts(cond)
[10:58:47.427]                           for (restart in restarts) {
[10:58:47.427]                             name <- restart$name
[10:58:47.427]                             if (is.null(name)) 
[10:58:47.427]                               next
[10:58:47.427]                             if (!grepl(pattern, name)) 
[10:58:47.427]                               next
[10:58:47.427]                             invokeRestart(restart)
[10:58:47.427]                             muffled <- TRUE
[10:58:47.427]                             break
[10:58:47.427]                           }
[10:58:47.427]                         }
[10:58:47.427]                       }
[10:58:47.427]                       invisible(muffled)
[10:58:47.427]                     }
[10:58:47.427]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.427]                   }
[10:58:47.427]                 }
[10:58:47.427]                 else {
[10:58:47.427]                   if (TRUE) {
[10:58:47.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.427]                     {
[10:58:47.427]                       inherits <- base::inherits
[10:58:47.427]                       invokeRestart <- base::invokeRestart
[10:58:47.427]                       is.null <- base::is.null
[10:58:47.427]                       muffled <- FALSE
[10:58:47.427]                       if (inherits(cond, "message")) {
[10:58:47.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.427]                         if (muffled) 
[10:58:47.427]                           invokeRestart("muffleMessage")
[10:58:47.427]                       }
[10:58:47.427]                       else if (inherits(cond, "warning")) {
[10:58:47.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.427]                         if (muffled) 
[10:58:47.427]                           invokeRestart("muffleWarning")
[10:58:47.427]                       }
[10:58:47.427]                       else if (inherits(cond, "condition")) {
[10:58:47.427]                         if (!is.null(pattern)) {
[10:58:47.427]                           computeRestarts <- base::computeRestarts
[10:58:47.427]                           grepl <- base::grepl
[10:58:47.427]                           restarts <- computeRestarts(cond)
[10:58:47.427]                           for (restart in restarts) {
[10:58:47.427]                             name <- restart$name
[10:58:47.427]                             if (is.null(name)) 
[10:58:47.427]                               next
[10:58:47.427]                             if (!grepl(pattern, name)) 
[10:58:47.427]                               next
[10:58:47.427]                             invokeRestart(restart)
[10:58:47.427]                             muffled <- TRUE
[10:58:47.427]                             break
[10:58:47.427]                           }
[10:58:47.427]                         }
[10:58:47.427]                       }
[10:58:47.427]                       invisible(muffled)
[10:58:47.427]                     }
[10:58:47.427]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.427]                   }
[10:58:47.427]                 }
[10:58:47.427]             }
[10:58:47.427]         }))
[10:58:47.427]     }, error = function(ex) {
[10:58:47.427]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.427]                 ...future.rng), started = ...future.startTime, 
[10:58:47.427]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.427]             version = "1.8"), class = "FutureResult")
[10:58:47.427]     }, finally = {
[10:58:47.427]         if (!identical(...future.workdir, getwd())) 
[10:58:47.427]             setwd(...future.workdir)
[10:58:47.427]         {
[10:58:47.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.427]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.427]             }
[10:58:47.427]             base::options(...future.oldOptions)
[10:58:47.427]             if (.Platform$OS.type == "windows") {
[10:58:47.427]                 old_names <- names(...future.oldEnvVars)
[10:58:47.427]                 envs <- base::Sys.getenv()
[10:58:47.427]                 names <- names(envs)
[10:58:47.427]                 common <- intersect(names, old_names)
[10:58:47.427]                 added <- setdiff(names, old_names)
[10:58:47.427]                 removed <- setdiff(old_names, names)
[10:58:47.427]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.427]                   envs[common]]
[10:58:47.427]                 NAMES <- toupper(changed)
[10:58:47.427]                 args <- list()
[10:58:47.427]                 for (kk in seq_along(NAMES)) {
[10:58:47.427]                   name <- changed[[kk]]
[10:58:47.427]                   NAME <- NAMES[[kk]]
[10:58:47.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.427]                     next
[10:58:47.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.427]                 }
[10:58:47.427]                 NAMES <- toupper(added)
[10:58:47.427]                 for (kk in seq_along(NAMES)) {
[10:58:47.427]                   name <- added[[kk]]
[10:58:47.427]                   NAME <- NAMES[[kk]]
[10:58:47.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.427]                     next
[10:58:47.427]                   args[[name]] <- ""
[10:58:47.427]                 }
[10:58:47.427]                 NAMES <- toupper(removed)
[10:58:47.427]                 for (kk in seq_along(NAMES)) {
[10:58:47.427]                   name <- removed[[kk]]
[10:58:47.427]                   NAME <- NAMES[[kk]]
[10:58:47.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.427]                     next
[10:58:47.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.427]                 }
[10:58:47.427]                 if (length(args) > 0) 
[10:58:47.427]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.427]             }
[10:58:47.427]             else {
[10:58:47.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.427]             }
[10:58:47.427]             {
[10:58:47.427]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.427]                   0L) {
[10:58:47.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.427]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.427]                   base::options(opts)
[10:58:47.427]                 }
[10:58:47.427]                 {
[10:58:47.427]                   {
[10:58:47.427]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.427]                     NULL
[10:58:47.427]                   }
[10:58:47.427]                   options(future.plan = NULL)
[10:58:47.427]                   if (is.na(NA_character_)) 
[10:58:47.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.427]                     .init = FALSE)
[10:58:47.427]                 }
[10:58:47.427]             }
[10:58:47.427]         }
[10:58:47.427]     })
[10:58:47.427]     if (TRUE) {
[10:58:47.427]         base::sink(type = "output", split = FALSE)
[10:58:47.427]         if (TRUE) {
[10:58:47.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.427]         }
[10:58:47.427]         else {
[10:58:47.427]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.427]         }
[10:58:47.427]         base::close(...future.stdout)
[10:58:47.427]         ...future.stdout <- NULL
[10:58:47.427]     }
[10:58:47.427]     ...future.result$conditions <- ...future.conditions
[10:58:47.427]     ...future.result$finished <- base::Sys.time()
[10:58:47.427]     ...future.result
[10:58:47.427] }
[10:58:47.481] Exporting 5 global objects (1.07 KiB) to cluster node #2 ...
[10:58:47.481] Exporting ‘...future.FUN’ (273 bytes) to cluster node #2 ...
[10:58:47.482] Exporting ‘...future.FUN’ (273 bytes) to cluster node #2 ... DONE
[10:58:47.482] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:47.482] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:47.482] Exporting ‘...future.elements_ii’ (205 bytes) to cluster node #2 ...
[10:58:47.483] Exporting ‘...future.elements_ii’ (205 bytes) to cluster node #2 ... DONE
[10:58:47.483] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:47.483] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.483] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:47.484] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.484] Exporting 5 global objects (1.07 KiB) to cluster node #2 ... DONE
[10:58:47.484] MultisessionFuture started
[10:58:47.484] - Launch lazy future ... done
[10:58:47.485] run() for ‘MultisessionFuture’ ... done
[10:58:47.485] Created future:
[10:58:47.485] MultisessionFuture:
[10:58:47.485] Label: ‘future_eapply-2’
[10:58:47.485] Expression:
[10:58:47.485] {
[10:58:47.485]     do.call(function(...) {
[10:58:47.485]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.485]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.485]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.485]             on.exit(options(oopts), add = TRUE)
[10:58:47.485]         }
[10:58:47.485]         {
[10:58:47.485]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.485]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.485]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.485]             })
[10:58:47.485]         }
[10:58:47.485]     }, args = future.call.arguments)
[10:58:47.485] }
[10:58:47.485] Lazy evaluation: FALSE
[10:58:47.485] Asynchronous evaluation: TRUE
[10:58:47.485] Local evaluation: TRUE
[10:58:47.485] Environment: R_GlobalEnv
[10:58:47.485] Capture standard output: TRUE
[10:58:47.485] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.485] Globals: 5 objects totaling 629 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 205 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.485] Packages: <none>
[10:58:47.485] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.485] Resolved: FALSE
[10:58:47.485] Value: <not collected>
[10:58:47.485] Conditions captured: <none>
[10:58:47.485] Early signaling: FALSE
[10:58:47.485] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.485] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.497] Chunk #2 of 2 ... DONE
[10:58:47.497] Launching 2 futures (chunks) ... DONE
[10:58:47.497] Resolving 2 futures (chunks) ...
[10:58:47.497] resolve() on list ...
[10:58:47.497]  recursive: 0
[10:58:47.497]  length: 2
[10:58:47.497] 
[10:58:47.498] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.498] - Validating connection of MultisessionFuture
[10:58:47.498] - received message: FutureResult
[10:58:47.498] - Received FutureResult
[10:58:47.499] - Erased future from FutureRegistry
[10:58:47.499] result() for ClusterFuture ...
[10:58:47.499] - result already collected: FutureResult
[10:58:47.499] result() for ClusterFuture ... done
[10:58:47.499] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.499] Future #1
[10:58:47.499] result() for ClusterFuture ...
[10:58:47.499] - result already collected: FutureResult
[10:58:47.499] result() for ClusterFuture ... done
[10:58:47.500] result() for ClusterFuture ...
[10:58:47.500] - result already collected: FutureResult
[10:58:47.500] result() for ClusterFuture ... done
[10:58:47.500] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:47.500] - nx: 2
[10:58:47.500] - relay: TRUE
[10:58:47.500] - stdout: TRUE
[10:58:47.500] - signal: TRUE
[10:58:47.500] - resignal: FALSE
[10:58:47.500] - force: TRUE
[10:58:47.501] - relayed: [n=2] FALSE, FALSE
[10:58:47.501] - queued futures: [n=2] FALSE, FALSE
[10:58:47.501]  - until=1
[10:58:47.501]  - relaying element #1
[10:58:47.501] result() for ClusterFuture ...
[10:58:47.501] - result already collected: FutureResult
[10:58:47.501] result() for ClusterFuture ... done
[10:58:47.501] result() for ClusterFuture ...
[10:58:47.501] - result already collected: FutureResult
[10:58:47.502] result() for ClusterFuture ... done
[10:58:47.502] result() for ClusterFuture ...
[10:58:47.502] - result already collected: FutureResult
[10:58:47.502] result() for ClusterFuture ... done
[10:58:47.502] result() for ClusterFuture ...
[10:58:47.502] - result already collected: FutureResult
[10:58:47.502] result() for ClusterFuture ... done
[10:58:47.502] - relayed: [n=2] TRUE, FALSE
[10:58:47.502] - queued futures: [n=2] TRUE, FALSE
[10:58:47.503] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:47.503]  length: 1 (resolved future 1)
[10:58:47.565] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.566] - Validating connection of MultisessionFuture
[10:58:47.566] - received message: FutureResult
[10:58:47.566] - Received FutureResult
[10:58:47.566] - Erased future from FutureRegistry
[10:58:47.566] result() for ClusterFuture ...
[10:58:47.566] - result already collected: FutureResult
[10:58:47.567] result() for ClusterFuture ... done
[10:58:47.567] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.567] Future #2
[10:58:47.567] result() for ClusterFuture ...
[10:58:47.567] - result already collected: FutureResult
[10:58:47.567] result() for ClusterFuture ... done
[10:58:47.567] result() for ClusterFuture ...
[10:58:47.567] - result already collected: FutureResult
[10:58:47.567] result() for ClusterFuture ... done
[10:58:47.568] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:47.568] - nx: 2
[10:58:47.568] - relay: TRUE
[10:58:47.568] - stdout: TRUE
[10:58:47.568] - signal: TRUE
[10:58:47.568] - resignal: FALSE
[10:58:47.568] - force: TRUE
[10:58:47.568] - relayed: [n=2] TRUE, FALSE
[10:58:47.568] - queued futures: [n=2] TRUE, FALSE
[10:58:47.568]  - until=2
[10:58:47.569]  - relaying element #2
[10:58:47.569] result() for ClusterFuture ...
[10:58:47.569] - result already collected: FutureResult
[10:58:47.569] result() for ClusterFuture ... done
[10:58:47.569] result() for ClusterFuture ...
[10:58:47.569] - result already collected: FutureResult
[10:58:47.569] result() for ClusterFuture ... done
[10:58:47.569] result() for ClusterFuture ...
[10:58:47.569] - result already collected: FutureResult
[10:58:47.570] result() for ClusterFuture ... done
[10:58:47.570] result() for ClusterFuture ...
[10:58:47.570] - result already collected: FutureResult
[10:58:47.570] result() for ClusterFuture ... done
[10:58:47.570] - relayed: [n=2] TRUE, TRUE
[10:58:47.570] - queued futures: [n=2] TRUE, TRUE
[10:58:47.570] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:47.570]  length: 0 (resolved future 2)
[10:58:47.570] Relaying remaining futures
[10:58:47.571] signalConditionsASAP(NULL, pos=0) ...
[10:58:47.571] - nx: 2
[10:58:47.571] - relay: TRUE
[10:58:47.571] - stdout: TRUE
[10:58:47.571] - signal: TRUE
[10:58:47.571] - resignal: FALSE
[10:58:47.571] - force: TRUE
[10:58:47.571] - relayed: [n=2] TRUE, TRUE
[10:58:47.571] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:47.572] - relayed: [n=2] TRUE, TRUE
[10:58:47.572] - queued futures: [n=2] TRUE, TRUE
[10:58:47.572] signalConditionsASAP(NULL, pos=0) ... done
[10:58:47.572] resolve() on list ... DONE
[10:58:47.572] result() for ClusterFuture ...
[10:58:47.572] - result already collected: FutureResult
[10:58:47.572] result() for ClusterFuture ... done
[10:58:47.572] result() for ClusterFuture ...
[10:58:47.572] - result already collected: FutureResult
[10:58:47.572] result() for ClusterFuture ... done
[10:58:47.573] result() for ClusterFuture ...
[10:58:47.573] - result already collected: FutureResult
[10:58:47.573] result() for ClusterFuture ... done
[10:58:47.573] result() for ClusterFuture ...
[10:58:47.573] - result already collected: FutureResult
[10:58:47.573] result() for ClusterFuture ... done
[10:58:47.573]  - Number of value chunks collected: 2
[10:58:47.573] Resolving 2 futures (chunks) ... DONE
[10:58:47.573] Reducing values from 2 chunks ...
[10:58:47.574]  - Number of values collected after concatenation: 3
[10:58:47.574]  - Number of values expected: 3
[10:58:47.574] Reducing values from 2 chunks ... DONE
[10:58:47.574] future_lapply() ... DONE
[10:58:47.575] future_lapply() ...
[10:58:47.577] Number of chunks: 2
[10:58:47.577] getGlobalsAndPackagesXApply() ...
[10:58:47.577]  - future.globals: TRUE
[10:58:47.577] getGlobalsAndPackages() ...
[10:58:47.577] Searching for globals...
[10:58:47.579] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:47.579] Searching for globals ... DONE
[10:58:47.579] Resolving globals: FALSE
[10:58:47.579] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:47.580] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:47.580] - globals: [1] ‘FUN’
[10:58:47.580] - packages: [1] ‘stats’
[10:58:47.580] getGlobalsAndPackages() ... DONE
[10:58:47.580]  - globals found/used: [n=1] ‘FUN’
[10:58:47.581]  - needed namespaces: [n=1] ‘stats’
[10:58:47.581] Finding globals ... DONE
[10:58:47.581]  - use_args: TRUE
[10:58:47.581]  - Getting '...' globals ...
[10:58:47.581] resolve() on list ...
[10:58:47.581]  recursive: 0
[10:58:47.581]  length: 1
[10:58:47.582]  elements: ‘...’
[10:58:47.582]  length: 0 (resolved future 1)
[10:58:47.582] resolve() on list ... DONE
[10:58:47.582]    - '...' content: [n=1] ‘probs’
[10:58:47.582] List of 1
[10:58:47.582]  $ ...:List of 1
[10:58:47.582]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:47.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.582]  - attr(*, "where")=List of 1
[10:58:47.582]   ..$ ...:<environment: 0x55f48d4028c0> 
[10:58:47.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.582]  - attr(*, "resolved")= logi TRUE
[10:58:47.582]  - attr(*, "total_size")= num NA
[10:58:47.586]  - Getting '...' globals ... DONE
[10:58:47.586] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:47.586] List of 2
[10:58:47.586]  $ ...future.FUN:function (x, ...)  
[10:58:47.586]  $ ...          :List of 1
[10:58:47.586]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:58:47.586]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.586]  - attr(*, "where")=List of 2
[10:58:47.586]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:47.586]   ..$ ...          :<environment: 0x55f48d4028c0> 
[10:58:47.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.586]  - attr(*, "resolved")= logi FALSE
[10:58:47.586]  - attr(*, "total_size")= num 6525
[10:58:47.590] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:47.590] getGlobalsAndPackagesXApply() ... DONE
[10:58:47.590] Number of futures (= number of chunks): 2
[10:58:47.590] Launching 2 futures (chunks) ...
[10:58:47.590] Chunk #1 of 2 ...
[10:58:47.590]  - Finding globals in 'X' for chunk #1 ...
[10:58:47.591] getGlobalsAndPackages() ...
[10:58:47.591] Searching for globals...
[10:58:47.591] 
[10:58:47.591] Searching for globals ... DONE
[10:58:47.591] - globals: [0] <none>
[10:58:47.591] getGlobalsAndPackages() ... DONE
[10:58:47.591]    + additional globals found: [n=0] 
[10:58:47.591]    + additional namespaces needed: [n=0] 
[10:58:47.592]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:47.592]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.592]  - seeds: <none>
[10:58:47.592]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.592] getGlobalsAndPackages() ...
[10:58:47.594] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.594] Resolving globals: FALSE
[10:58:47.594] Tweak future expression to call with '...' arguments ...
[10:58:47.595] {
[10:58:47.595]     do.call(function(...) {
[10:58:47.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.595]             on.exit(options(oopts), add = TRUE)
[10:58:47.595]         }
[10:58:47.595]         {
[10:58:47.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.595]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.595]             })
[10:58:47.595]         }
[10:58:47.595]     }, args = future.call.arguments)
[10:58:47.595] }
[10:58:47.595] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.595] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.595] - packages: [1] ‘stats’
[10:58:47.595] getGlobalsAndPackages() ... DONE
[10:58:47.596] run() for ‘Future’ ...
[10:58:47.596] - state: ‘created’
[10:58:47.596] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.610]   - Field: ‘node’
[10:58:47.610]   - Field: ‘label’
[10:58:47.610]   - Field: ‘local’
[10:58:47.610]   - Field: ‘owner’
[10:58:47.610]   - Field: ‘envir’
[10:58:47.611]   - Field: ‘workers’
[10:58:47.611]   - Field: ‘packages’
[10:58:47.611]   - Field: ‘gc’
[10:58:47.611]   - Field: ‘conditions’
[10:58:47.611]   - Field: ‘persistent’
[10:58:47.611]   - Field: ‘expr’
[10:58:47.611]   - Field: ‘uuid’
[10:58:47.611]   - Field: ‘seed’
[10:58:47.611]   - Field: ‘version’
[10:58:47.611]   - Field: ‘result’
[10:58:47.611]   - Field: ‘asynchronous’
[10:58:47.612]   - Field: ‘calls’
[10:58:47.612]   - Field: ‘globals’
[10:58:47.612]   - Field: ‘stdout’
[10:58:47.612]   - Field: ‘earlySignal’
[10:58:47.612]   - Field: ‘lazy’
[10:58:47.612]   - Field: ‘state’
[10:58:47.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.612] - Launch lazy future ...
[10:58:47.612] Packages needed by the future expression (n = 1): ‘stats’
[10:58:47.612] Packages needed by future strategies (n = 0): <none>
[10:58:47.613] {
[10:58:47.613]     {
[10:58:47.613]         {
[10:58:47.613]             ...future.startTime <- base::Sys.time()
[10:58:47.613]             {
[10:58:47.613]                 {
[10:58:47.613]                   {
[10:58:47.613]                     {
[10:58:47.613]                       {
[10:58:47.613]                         base::local({
[10:58:47.613]                           has_future <- base::requireNamespace("future", 
[10:58:47.613]                             quietly = TRUE)
[10:58:47.613]                           if (has_future) {
[10:58:47.613]                             ns <- base::getNamespace("future")
[10:58:47.613]                             version <- ns[[".package"]][["version"]]
[10:58:47.613]                             if (is.null(version)) 
[10:58:47.613]                               version <- utils::packageVersion("future")
[10:58:47.613]                           }
[10:58:47.613]                           else {
[10:58:47.613]                             version <- NULL
[10:58:47.613]                           }
[10:58:47.613]                           if (!has_future || version < "1.8.0") {
[10:58:47.613]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.613]                               "", base::R.version$version.string), 
[10:58:47.613]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:47.613]                                 base::R.version$platform, 8 * 
[10:58:47.613]                                   base::.Machine$sizeof.pointer), 
[10:58:47.613]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.613]                                 "release", "version")], collapse = " "), 
[10:58:47.613]                               hostname = base::Sys.info()[["nodename"]])
[10:58:47.613]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.613]                               info)
[10:58:47.613]                             info <- base::paste(info, collapse = "; ")
[10:58:47.613]                             if (!has_future) {
[10:58:47.613]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.613]                                 info)
[10:58:47.613]                             }
[10:58:47.613]                             else {
[10:58:47.613]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.613]                                 info, version)
[10:58:47.613]                             }
[10:58:47.613]                             base::stop(msg)
[10:58:47.613]                           }
[10:58:47.613]                         })
[10:58:47.613]                       }
[10:58:47.613]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.613]                       base::options(mc.cores = 1L)
[10:58:47.613]                     }
[10:58:47.613]                     base::local({
[10:58:47.613]                       for (pkg in "stats") {
[10:58:47.613]                         base::loadNamespace(pkg)
[10:58:47.613]                         base::library(pkg, character.only = TRUE)
[10:58:47.613]                       }
[10:58:47.613]                     })
[10:58:47.613]                   }
[10:58:47.613]                   ...future.strategy.old <- future::plan("list")
[10:58:47.613]                   options(future.plan = NULL)
[10:58:47.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.613]                 }
[10:58:47.613]                 ...future.workdir <- getwd()
[10:58:47.613]             }
[10:58:47.613]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.613]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.613]         }
[10:58:47.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.613]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.613]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.613]             base::names(...future.oldOptions))
[10:58:47.613]     }
[10:58:47.613]     if (FALSE) {
[10:58:47.613]     }
[10:58:47.613]     else {
[10:58:47.613]         if (TRUE) {
[10:58:47.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.613]                 open = "w")
[10:58:47.613]         }
[10:58:47.613]         else {
[10:58:47.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.613]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.613]         }
[10:58:47.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.613]             base::sink(type = "output", split = FALSE)
[10:58:47.613]             base::close(...future.stdout)
[10:58:47.613]         }, add = TRUE)
[10:58:47.613]     }
[10:58:47.613]     ...future.frame <- base::sys.nframe()
[10:58:47.613]     ...future.conditions <- base::list()
[10:58:47.613]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.613]     if (FALSE) {
[10:58:47.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.613]     }
[10:58:47.613]     ...future.result <- base::tryCatch({
[10:58:47.613]         base::withCallingHandlers({
[10:58:47.613]             ...future.value <- base::withVisible(base::local({
[10:58:47.613]                 ...future.makeSendCondition <- base::local({
[10:58:47.613]                   sendCondition <- NULL
[10:58:47.613]                   function(frame = 1L) {
[10:58:47.613]                     if (is.function(sendCondition)) 
[10:58:47.613]                       return(sendCondition)
[10:58:47.613]                     ns <- getNamespace("parallel")
[10:58:47.613]                     if (exists("sendData", mode = "function", 
[10:58:47.613]                       envir = ns)) {
[10:58:47.613]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.613]                         envir = ns)
[10:58:47.613]                       envir <- sys.frame(frame)
[10:58:47.613]                       master <- NULL
[10:58:47.613]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.613]                         !identical(envir, emptyenv())) {
[10:58:47.613]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.613]                           inherits = FALSE)) {
[10:58:47.613]                           master <- get("master", mode = "list", 
[10:58:47.613]                             envir = envir, inherits = FALSE)
[10:58:47.613]                           if (inherits(master, c("SOCKnode", 
[10:58:47.613]                             "SOCK0node"))) {
[10:58:47.613]                             sendCondition <<- function(cond) {
[10:58:47.613]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.613]                                 success = TRUE)
[10:58:47.613]                               parallel_sendData(master, data)
[10:58:47.613]                             }
[10:58:47.613]                             return(sendCondition)
[10:58:47.613]                           }
[10:58:47.613]                         }
[10:58:47.613]                         frame <- frame + 1L
[10:58:47.613]                         envir <- sys.frame(frame)
[10:58:47.613]                       }
[10:58:47.613]                     }
[10:58:47.613]                     sendCondition <<- function(cond) NULL
[10:58:47.613]                   }
[10:58:47.613]                 })
[10:58:47.613]                 withCallingHandlers({
[10:58:47.613]                   {
[10:58:47.613]                     do.call(function(...) {
[10:58:47.613]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.613]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.613]                         ...future.globals.maxSize)) {
[10:58:47.613]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.613]                         on.exit(options(oopts), add = TRUE)
[10:58:47.613]                       }
[10:58:47.613]                       {
[10:58:47.613]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.613]                           FUN = function(jj) {
[10:58:47.613]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.613]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.613]                           })
[10:58:47.613]                       }
[10:58:47.613]                     }, args = future.call.arguments)
[10:58:47.613]                   }
[10:58:47.613]                 }, immediateCondition = function(cond) {
[10:58:47.613]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.613]                   sendCondition(cond)
[10:58:47.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.613]                   {
[10:58:47.613]                     inherits <- base::inherits
[10:58:47.613]                     invokeRestart <- base::invokeRestart
[10:58:47.613]                     is.null <- base::is.null
[10:58:47.613]                     muffled <- FALSE
[10:58:47.613]                     if (inherits(cond, "message")) {
[10:58:47.613]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.613]                       if (muffled) 
[10:58:47.613]                         invokeRestart("muffleMessage")
[10:58:47.613]                     }
[10:58:47.613]                     else if (inherits(cond, "warning")) {
[10:58:47.613]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.613]                       if (muffled) 
[10:58:47.613]                         invokeRestart("muffleWarning")
[10:58:47.613]                     }
[10:58:47.613]                     else if (inherits(cond, "condition")) {
[10:58:47.613]                       if (!is.null(pattern)) {
[10:58:47.613]                         computeRestarts <- base::computeRestarts
[10:58:47.613]                         grepl <- base::grepl
[10:58:47.613]                         restarts <- computeRestarts(cond)
[10:58:47.613]                         for (restart in restarts) {
[10:58:47.613]                           name <- restart$name
[10:58:47.613]                           if (is.null(name)) 
[10:58:47.613]                             next
[10:58:47.613]                           if (!grepl(pattern, name)) 
[10:58:47.613]                             next
[10:58:47.613]                           invokeRestart(restart)
[10:58:47.613]                           muffled <- TRUE
[10:58:47.613]                           break
[10:58:47.613]                         }
[10:58:47.613]                       }
[10:58:47.613]                     }
[10:58:47.613]                     invisible(muffled)
[10:58:47.613]                   }
[10:58:47.613]                   muffleCondition(cond)
[10:58:47.613]                 })
[10:58:47.613]             }))
[10:58:47.613]             future::FutureResult(value = ...future.value$value, 
[10:58:47.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.613]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.613]                     ...future.globalenv.names))
[10:58:47.613]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.613]         }, condition = base::local({
[10:58:47.613]             c <- base::c
[10:58:47.613]             inherits <- base::inherits
[10:58:47.613]             invokeRestart <- base::invokeRestart
[10:58:47.613]             length <- base::length
[10:58:47.613]             list <- base::list
[10:58:47.613]             seq.int <- base::seq.int
[10:58:47.613]             signalCondition <- base::signalCondition
[10:58:47.613]             sys.calls <- base::sys.calls
[10:58:47.613]             `[[` <- base::`[[`
[10:58:47.613]             `+` <- base::`+`
[10:58:47.613]             `<<-` <- base::`<<-`
[10:58:47.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.613]                   3L)]
[10:58:47.613]             }
[10:58:47.613]             function(cond) {
[10:58:47.613]                 is_error <- inherits(cond, "error")
[10:58:47.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.613]                   NULL)
[10:58:47.613]                 if (is_error) {
[10:58:47.613]                   sessionInformation <- function() {
[10:58:47.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.613]                       search = base::search(), system = base::Sys.info())
[10:58:47.613]                   }
[10:58:47.613]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.613]                     cond$call), session = sessionInformation(), 
[10:58:47.613]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.613]                   signalCondition(cond)
[10:58:47.613]                 }
[10:58:47.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.613]                 "immediateCondition"))) {
[10:58:47.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.613]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.613]                   if (TRUE && !signal) {
[10:58:47.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.613]                     {
[10:58:47.613]                       inherits <- base::inherits
[10:58:47.613]                       invokeRestart <- base::invokeRestart
[10:58:47.613]                       is.null <- base::is.null
[10:58:47.613]                       muffled <- FALSE
[10:58:47.613]                       if (inherits(cond, "message")) {
[10:58:47.613]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.613]                         if (muffled) 
[10:58:47.613]                           invokeRestart("muffleMessage")
[10:58:47.613]                       }
[10:58:47.613]                       else if (inherits(cond, "warning")) {
[10:58:47.613]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.613]                         if (muffled) 
[10:58:47.613]                           invokeRestart("muffleWarning")
[10:58:47.613]                       }
[10:58:47.613]                       else if (inherits(cond, "condition")) {
[10:58:47.613]                         if (!is.null(pattern)) {
[10:58:47.613]                           computeRestarts <- base::computeRestarts
[10:58:47.613]                           grepl <- base::grepl
[10:58:47.613]                           restarts <- computeRestarts(cond)
[10:58:47.613]                           for (restart in restarts) {
[10:58:47.613]                             name <- restart$name
[10:58:47.613]                             if (is.null(name)) 
[10:58:47.613]                               next
[10:58:47.613]                             if (!grepl(pattern, name)) 
[10:58:47.613]                               next
[10:58:47.613]                             invokeRestart(restart)
[10:58:47.613]                             muffled <- TRUE
[10:58:47.613]                             break
[10:58:47.613]                           }
[10:58:47.613]                         }
[10:58:47.613]                       }
[10:58:47.613]                       invisible(muffled)
[10:58:47.613]                     }
[10:58:47.613]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.613]                   }
[10:58:47.613]                 }
[10:58:47.613]                 else {
[10:58:47.613]                   if (TRUE) {
[10:58:47.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.613]                     {
[10:58:47.613]                       inherits <- base::inherits
[10:58:47.613]                       invokeRestart <- base::invokeRestart
[10:58:47.613]                       is.null <- base::is.null
[10:58:47.613]                       muffled <- FALSE
[10:58:47.613]                       if (inherits(cond, "message")) {
[10:58:47.613]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.613]                         if (muffled) 
[10:58:47.613]                           invokeRestart("muffleMessage")
[10:58:47.613]                       }
[10:58:47.613]                       else if (inherits(cond, "warning")) {
[10:58:47.613]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.613]                         if (muffled) 
[10:58:47.613]                           invokeRestart("muffleWarning")
[10:58:47.613]                       }
[10:58:47.613]                       else if (inherits(cond, "condition")) {
[10:58:47.613]                         if (!is.null(pattern)) {
[10:58:47.613]                           computeRestarts <- base::computeRestarts
[10:58:47.613]                           grepl <- base::grepl
[10:58:47.613]                           restarts <- computeRestarts(cond)
[10:58:47.613]                           for (restart in restarts) {
[10:58:47.613]                             name <- restart$name
[10:58:47.613]                             if (is.null(name)) 
[10:58:47.613]                               next
[10:58:47.613]                             if (!grepl(pattern, name)) 
[10:58:47.613]                               next
[10:58:47.613]                             invokeRestart(restart)
[10:58:47.613]                             muffled <- TRUE
[10:58:47.613]                             break
[10:58:47.613]                           }
[10:58:47.613]                         }
[10:58:47.613]                       }
[10:58:47.613]                       invisible(muffled)
[10:58:47.613]                     }
[10:58:47.613]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.613]                   }
[10:58:47.613]                 }
[10:58:47.613]             }
[10:58:47.613]         }))
[10:58:47.613]     }, error = function(ex) {
[10:58:47.613]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.613]                 ...future.rng), started = ...future.startTime, 
[10:58:47.613]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.613]             version = "1.8"), class = "FutureResult")
[10:58:47.613]     }, finally = {
[10:58:47.613]         if (!identical(...future.workdir, getwd())) 
[10:58:47.613]             setwd(...future.workdir)
[10:58:47.613]         {
[10:58:47.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.613]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.613]             }
[10:58:47.613]             base::options(...future.oldOptions)
[10:58:47.613]             if (.Platform$OS.type == "windows") {
[10:58:47.613]                 old_names <- names(...future.oldEnvVars)
[10:58:47.613]                 envs <- base::Sys.getenv()
[10:58:47.613]                 names <- names(envs)
[10:58:47.613]                 common <- intersect(names, old_names)
[10:58:47.613]                 added <- setdiff(names, old_names)
[10:58:47.613]                 removed <- setdiff(old_names, names)
[10:58:47.613]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.613]                   envs[common]]
[10:58:47.613]                 NAMES <- toupper(changed)
[10:58:47.613]                 args <- list()
[10:58:47.613]                 for (kk in seq_along(NAMES)) {
[10:58:47.613]                   name <- changed[[kk]]
[10:58:47.613]                   NAME <- NAMES[[kk]]
[10:58:47.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.613]                     next
[10:58:47.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.613]                 }
[10:58:47.613]                 NAMES <- toupper(added)
[10:58:47.613]                 for (kk in seq_along(NAMES)) {
[10:58:47.613]                   name <- added[[kk]]
[10:58:47.613]                   NAME <- NAMES[[kk]]
[10:58:47.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.613]                     next
[10:58:47.613]                   args[[name]] <- ""
[10:58:47.613]                 }
[10:58:47.613]                 NAMES <- toupper(removed)
[10:58:47.613]                 for (kk in seq_along(NAMES)) {
[10:58:47.613]                   name <- removed[[kk]]
[10:58:47.613]                   NAME <- NAMES[[kk]]
[10:58:47.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.613]                     next
[10:58:47.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.613]                 }
[10:58:47.613]                 if (length(args) > 0) 
[10:58:47.613]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.613]             }
[10:58:47.613]             else {
[10:58:47.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.613]             }
[10:58:47.613]             {
[10:58:47.613]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.613]                   0L) {
[10:58:47.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.613]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.613]                   base::options(opts)
[10:58:47.613]                 }
[10:58:47.613]                 {
[10:58:47.613]                   {
[10:58:47.613]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.613]                     NULL
[10:58:47.613]                   }
[10:58:47.613]                   options(future.plan = NULL)
[10:58:47.613]                   if (is.na(NA_character_)) 
[10:58:47.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.613]                     .init = FALSE)
[10:58:47.613]                 }
[10:58:47.613]             }
[10:58:47.613]         }
[10:58:47.613]     })
[10:58:47.613]     if (TRUE) {
[10:58:47.613]         base::sink(type = "output", split = FALSE)
[10:58:47.613]         if (TRUE) {
[10:58:47.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.613]         }
[10:58:47.613]         else {
[10:58:47.613]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.613]         }
[10:58:47.613]         base::close(...future.stdout)
[10:58:47.613]         ...future.stdout <- NULL
[10:58:47.613]     }
[10:58:47.613]     ...future.result$conditions <- ...future.conditions
[10:58:47.613]     ...future.result$finished <- base::Sys.time()
[10:58:47.613]     ...future.result
[10:58:47.613] }
[10:58:47.616] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[10:58:47.616] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:58:47.616] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:58:47.617] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #1 ...
[10:58:47.617] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #1 ... DONE
[10:58:47.617] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ...
[10:58:47.617] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ... DONE
[10:58:47.618] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:47.618] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.618] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:47.618] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.619] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[10:58:47.619] MultisessionFuture started
[10:58:47.619] - Launch lazy future ... done
[10:58:47.619] run() for ‘MultisessionFuture’ ... done
[10:58:47.619] Created future:
[10:58:47.619] MultisessionFuture:
[10:58:47.619] Label: ‘future_eapply-1’
[10:58:47.619] Expression:
[10:58:47.619] {
[10:58:47.619]     do.call(function(...) {
[10:58:47.619]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.619]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.619]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.619]             on.exit(options(oopts), add = TRUE)
[10:58:47.619]         }
[10:58:47.619]         {
[10:58:47.619]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.619]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.619]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.619]             })
[10:58:47.619]         }
[10:58:47.619]     }, args = future.call.arguments)
[10:58:47.619] }
[10:58:47.619] Lazy evaluation: FALSE
[10:58:47.619] Asynchronous evaluation: TRUE
[10:58:47.619] Local evaluation: TRUE
[10:58:47.619] Environment: R_GlobalEnv
[10:58:47.619] Capture standard output: TRUE
[10:58:47.619] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.619] Globals: 5 objects totaling 637 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.619] Packages: 1 packages (‘stats’)
[10:58:47.619] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.619] Resolved: FALSE
[10:58:47.619] Value: <not collected>
[10:58:47.619] Conditions captured: <none>
[10:58:47.619] Early signaling: FALSE
[10:58:47.619] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.619] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.631] Chunk #1 of 2 ... DONE
[10:58:47.631] Chunk #2 of 2 ...
[10:58:47.631]  - Finding globals in 'X' for chunk #2 ...
[10:58:47.631] getGlobalsAndPackages() ...
[10:58:47.631] Searching for globals...
[10:58:47.632] 
[10:58:47.632] Searching for globals ... DONE
[10:58:47.632] - globals: [0] <none>
[10:58:47.632] getGlobalsAndPackages() ... DONE
[10:58:47.632]    + additional globals found: [n=0] 
[10:58:47.632]    + additional namespaces needed: [n=0] 
[10:58:47.632]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:47.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.632]  - seeds: <none>
[10:58:47.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.632] getGlobalsAndPackages() ...
[10:58:47.633] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.633] Resolving globals: FALSE
[10:58:47.633] Tweak future expression to call with '...' arguments ...
[10:58:47.633] {
[10:58:47.633]     do.call(function(...) {
[10:58:47.633]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.633]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.633]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.633]             on.exit(options(oopts), add = TRUE)
[10:58:47.633]         }
[10:58:47.633]         {
[10:58:47.633]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.633]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.633]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.633]             })
[10:58:47.633]         }
[10:58:47.633]     }, args = future.call.arguments)
[10:58:47.633] }
[10:58:47.633] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.633] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.634] - packages: [1] ‘stats’
[10:58:47.634] getGlobalsAndPackages() ... DONE
[10:58:47.634] run() for ‘Future’ ...
[10:58:47.634] - state: ‘created’
[10:58:47.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.649] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.649]   - Field: ‘node’
[10:58:47.650]   - Field: ‘label’
[10:58:47.650]   - Field: ‘local’
[10:58:47.650]   - Field: ‘owner’
[10:58:47.650]   - Field: ‘envir’
[10:58:47.650]   - Field: ‘workers’
[10:58:47.650]   - Field: ‘packages’
[10:58:47.650]   - Field: ‘gc’
[10:58:47.650]   - Field: ‘conditions’
[10:58:47.650]   - Field: ‘persistent’
[10:58:47.650]   - Field: ‘expr’
[10:58:47.650]   - Field: ‘uuid’
[10:58:47.651]   - Field: ‘seed’
[10:58:47.651]   - Field: ‘version’
[10:58:47.651]   - Field: ‘result’
[10:58:47.651]   - Field: ‘asynchronous’
[10:58:47.651]   - Field: ‘calls’
[10:58:47.651]   - Field: ‘globals’
[10:58:47.651]   - Field: ‘stdout’
[10:58:47.651]   - Field: ‘earlySignal’
[10:58:47.651]   - Field: ‘lazy’
[10:58:47.651]   - Field: ‘state’
[10:58:47.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.651] - Launch lazy future ...
[10:58:47.652] Packages needed by the future expression (n = 1): ‘stats’
[10:58:47.652] Packages needed by future strategies (n = 0): <none>
[10:58:47.652] {
[10:58:47.652]     {
[10:58:47.652]         {
[10:58:47.652]             ...future.startTime <- base::Sys.time()
[10:58:47.652]             {
[10:58:47.652]                 {
[10:58:47.652]                   {
[10:58:47.652]                     {
[10:58:47.652]                       {
[10:58:47.652]                         base::local({
[10:58:47.652]                           has_future <- base::requireNamespace("future", 
[10:58:47.652]                             quietly = TRUE)
[10:58:47.652]                           if (has_future) {
[10:58:47.652]                             ns <- base::getNamespace("future")
[10:58:47.652]                             version <- ns[[".package"]][["version"]]
[10:58:47.652]                             if (is.null(version)) 
[10:58:47.652]                               version <- utils::packageVersion("future")
[10:58:47.652]                           }
[10:58:47.652]                           else {
[10:58:47.652]                             version <- NULL
[10:58:47.652]                           }
[10:58:47.652]                           if (!has_future || version < "1.8.0") {
[10:58:47.652]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.652]                               "", base::R.version$version.string), 
[10:58:47.652]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:47.652]                                 base::R.version$platform, 8 * 
[10:58:47.652]                                   base::.Machine$sizeof.pointer), 
[10:58:47.652]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.652]                                 "release", "version")], collapse = " "), 
[10:58:47.652]                               hostname = base::Sys.info()[["nodename"]])
[10:58:47.652]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.652]                               info)
[10:58:47.652]                             info <- base::paste(info, collapse = "; ")
[10:58:47.652]                             if (!has_future) {
[10:58:47.652]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.652]                                 info)
[10:58:47.652]                             }
[10:58:47.652]                             else {
[10:58:47.652]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.652]                                 info, version)
[10:58:47.652]                             }
[10:58:47.652]                             base::stop(msg)
[10:58:47.652]                           }
[10:58:47.652]                         })
[10:58:47.652]                       }
[10:58:47.652]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.652]                       base::options(mc.cores = 1L)
[10:58:47.652]                     }
[10:58:47.652]                     base::local({
[10:58:47.652]                       for (pkg in "stats") {
[10:58:47.652]                         base::loadNamespace(pkg)
[10:58:47.652]                         base::library(pkg, character.only = TRUE)
[10:58:47.652]                       }
[10:58:47.652]                     })
[10:58:47.652]                   }
[10:58:47.652]                   ...future.strategy.old <- future::plan("list")
[10:58:47.652]                   options(future.plan = NULL)
[10:58:47.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.652]                 }
[10:58:47.652]                 ...future.workdir <- getwd()
[10:58:47.652]             }
[10:58:47.652]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.652]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.652]         }
[10:58:47.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.652]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.652]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.652]             base::names(...future.oldOptions))
[10:58:47.652]     }
[10:58:47.652]     if (FALSE) {
[10:58:47.652]     }
[10:58:47.652]     else {
[10:58:47.652]         if (TRUE) {
[10:58:47.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.652]                 open = "w")
[10:58:47.652]         }
[10:58:47.652]         else {
[10:58:47.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.652]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.652]         }
[10:58:47.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.652]             base::sink(type = "output", split = FALSE)
[10:58:47.652]             base::close(...future.stdout)
[10:58:47.652]         }, add = TRUE)
[10:58:47.652]     }
[10:58:47.652]     ...future.frame <- base::sys.nframe()
[10:58:47.652]     ...future.conditions <- base::list()
[10:58:47.652]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.652]     if (FALSE) {
[10:58:47.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.652]     }
[10:58:47.652]     ...future.result <- base::tryCatch({
[10:58:47.652]         base::withCallingHandlers({
[10:58:47.652]             ...future.value <- base::withVisible(base::local({
[10:58:47.652]                 ...future.makeSendCondition <- base::local({
[10:58:47.652]                   sendCondition <- NULL
[10:58:47.652]                   function(frame = 1L) {
[10:58:47.652]                     if (is.function(sendCondition)) 
[10:58:47.652]                       return(sendCondition)
[10:58:47.652]                     ns <- getNamespace("parallel")
[10:58:47.652]                     if (exists("sendData", mode = "function", 
[10:58:47.652]                       envir = ns)) {
[10:58:47.652]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.652]                         envir = ns)
[10:58:47.652]                       envir <- sys.frame(frame)
[10:58:47.652]                       master <- NULL
[10:58:47.652]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.652]                         !identical(envir, emptyenv())) {
[10:58:47.652]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.652]                           inherits = FALSE)) {
[10:58:47.652]                           master <- get("master", mode = "list", 
[10:58:47.652]                             envir = envir, inherits = FALSE)
[10:58:47.652]                           if (inherits(master, c("SOCKnode", 
[10:58:47.652]                             "SOCK0node"))) {
[10:58:47.652]                             sendCondition <<- function(cond) {
[10:58:47.652]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.652]                                 success = TRUE)
[10:58:47.652]                               parallel_sendData(master, data)
[10:58:47.652]                             }
[10:58:47.652]                             return(sendCondition)
[10:58:47.652]                           }
[10:58:47.652]                         }
[10:58:47.652]                         frame <- frame + 1L
[10:58:47.652]                         envir <- sys.frame(frame)
[10:58:47.652]                       }
[10:58:47.652]                     }
[10:58:47.652]                     sendCondition <<- function(cond) NULL
[10:58:47.652]                   }
[10:58:47.652]                 })
[10:58:47.652]                 withCallingHandlers({
[10:58:47.652]                   {
[10:58:47.652]                     do.call(function(...) {
[10:58:47.652]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.652]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.652]                         ...future.globals.maxSize)) {
[10:58:47.652]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.652]                         on.exit(options(oopts), add = TRUE)
[10:58:47.652]                       }
[10:58:47.652]                       {
[10:58:47.652]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.652]                           FUN = function(jj) {
[10:58:47.652]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.652]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.652]                           })
[10:58:47.652]                       }
[10:58:47.652]                     }, args = future.call.arguments)
[10:58:47.652]                   }
[10:58:47.652]                 }, immediateCondition = function(cond) {
[10:58:47.652]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.652]                   sendCondition(cond)
[10:58:47.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.652]                   {
[10:58:47.652]                     inherits <- base::inherits
[10:58:47.652]                     invokeRestart <- base::invokeRestart
[10:58:47.652]                     is.null <- base::is.null
[10:58:47.652]                     muffled <- FALSE
[10:58:47.652]                     if (inherits(cond, "message")) {
[10:58:47.652]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.652]                       if (muffled) 
[10:58:47.652]                         invokeRestart("muffleMessage")
[10:58:47.652]                     }
[10:58:47.652]                     else if (inherits(cond, "warning")) {
[10:58:47.652]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.652]                       if (muffled) 
[10:58:47.652]                         invokeRestart("muffleWarning")
[10:58:47.652]                     }
[10:58:47.652]                     else if (inherits(cond, "condition")) {
[10:58:47.652]                       if (!is.null(pattern)) {
[10:58:47.652]                         computeRestarts <- base::computeRestarts
[10:58:47.652]                         grepl <- base::grepl
[10:58:47.652]                         restarts <- computeRestarts(cond)
[10:58:47.652]                         for (restart in restarts) {
[10:58:47.652]                           name <- restart$name
[10:58:47.652]                           if (is.null(name)) 
[10:58:47.652]                             next
[10:58:47.652]                           if (!grepl(pattern, name)) 
[10:58:47.652]                             next
[10:58:47.652]                           invokeRestart(restart)
[10:58:47.652]                           muffled <- TRUE
[10:58:47.652]                           break
[10:58:47.652]                         }
[10:58:47.652]                       }
[10:58:47.652]                     }
[10:58:47.652]                     invisible(muffled)
[10:58:47.652]                   }
[10:58:47.652]                   muffleCondition(cond)
[10:58:47.652]                 })
[10:58:47.652]             }))
[10:58:47.652]             future::FutureResult(value = ...future.value$value, 
[10:58:47.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.652]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.652]                     ...future.globalenv.names))
[10:58:47.652]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.652]         }, condition = base::local({
[10:58:47.652]             c <- base::c
[10:58:47.652]             inherits <- base::inherits
[10:58:47.652]             invokeRestart <- base::invokeRestart
[10:58:47.652]             length <- base::length
[10:58:47.652]             list <- base::list
[10:58:47.652]             seq.int <- base::seq.int
[10:58:47.652]             signalCondition <- base::signalCondition
[10:58:47.652]             sys.calls <- base::sys.calls
[10:58:47.652]             `[[` <- base::`[[`
[10:58:47.652]             `+` <- base::`+`
[10:58:47.652]             `<<-` <- base::`<<-`
[10:58:47.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.652]                   3L)]
[10:58:47.652]             }
[10:58:47.652]             function(cond) {
[10:58:47.652]                 is_error <- inherits(cond, "error")
[10:58:47.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.652]                   NULL)
[10:58:47.652]                 if (is_error) {
[10:58:47.652]                   sessionInformation <- function() {
[10:58:47.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.652]                       search = base::search(), system = base::Sys.info())
[10:58:47.652]                   }
[10:58:47.652]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.652]                     cond$call), session = sessionInformation(), 
[10:58:47.652]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.652]                   signalCondition(cond)
[10:58:47.652]                 }
[10:58:47.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.652]                 "immediateCondition"))) {
[10:58:47.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.652]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.652]                   if (TRUE && !signal) {
[10:58:47.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.652]                     {
[10:58:47.652]                       inherits <- base::inherits
[10:58:47.652]                       invokeRestart <- base::invokeRestart
[10:58:47.652]                       is.null <- base::is.null
[10:58:47.652]                       muffled <- FALSE
[10:58:47.652]                       if (inherits(cond, "message")) {
[10:58:47.652]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.652]                         if (muffled) 
[10:58:47.652]                           invokeRestart("muffleMessage")
[10:58:47.652]                       }
[10:58:47.652]                       else if (inherits(cond, "warning")) {
[10:58:47.652]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.652]                         if (muffled) 
[10:58:47.652]                           invokeRestart("muffleWarning")
[10:58:47.652]                       }
[10:58:47.652]                       else if (inherits(cond, "condition")) {
[10:58:47.652]                         if (!is.null(pattern)) {
[10:58:47.652]                           computeRestarts <- base::computeRestarts
[10:58:47.652]                           grepl <- base::grepl
[10:58:47.652]                           restarts <- computeRestarts(cond)
[10:58:47.652]                           for (restart in restarts) {
[10:58:47.652]                             name <- restart$name
[10:58:47.652]                             if (is.null(name)) 
[10:58:47.652]                               next
[10:58:47.652]                             if (!grepl(pattern, name)) 
[10:58:47.652]                               next
[10:58:47.652]                             invokeRestart(restart)
[10:58:47.652]                             muffled <- TRUE
[10:58:47.652]                             break
[10:58:47.652]                           }
[10:58:47.652]                         }
[10:58:47.652]                       }
[10:58:47.652]                       invisible(muffled)
[10:58:47.652]                     }
[10:58:47.652]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.652]                   }
[10:58:47.652]                 }
[10:58:47.652]                 else {
[10:58:47.652]                   if (TRUE) {
[10:58:47.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.652]                     {
[10:58:47.652]                       inherits <- base::inherits
[10:58:47.652]                       invokeRestart <- base::invokeRestart
[10:58:47.652]                       is.null <- base::is.null
[10:58:47.652]                       muffled <- FALSE
[10:58:47.652]                       if (inherits(cond, "message")) {
[10:58:47.652]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.652]                         if (muffled) 
[10:58:47.652]                           invokeRestart("muffleMessage")
[10:58:47.652]                       }
[10:58:47.652]                       else if (inherits(cond, "warning")) {
[10:58:47.652]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.652]                         if (muffled) 
[10:58:47.652]                           invokeRestart("muffleWarning")
[10:58:47.652]                       }
[10:58:47.652]                       else if (inherits(cond, "condition")) {
[10:58:47.652]                         if (!is.null(pattern)) {
[10:58:47.652]                           computeRestarts <- base::computeRestarts
[10:58:47.652]                           grepl <- base::grepl
[10:58:47.652]                           restarts <- computeRestarts(cond)
[10:58:47.652]                           for (restart in restarts) {
[10:58:47.652]                             name <- restart$name
[10:58:47.652]                             if (is.null(name)) 
[10:58:47.652]                               next
[10:58:47.652]                             if (!grepl(pattern, name)) 
[10:58:47.652]                               next
[10:58:47.652]                             invokeRestart(restart)
[10:58:47.652]                             muffled <- TRUE
[10:58:47.652]                             break
[10:58:47.652]                           }
[10:58:47.652]                         }
[10:58:47.652]                       }
[10:58:47.652]                       invisible(muffled)
[10:58:47.652]                     }
[10:58:47.652]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.652]                   }
[10:58:47.652]                 }
[10:58:47.652]             }
[10:58:47.652]         }))
[10:58:47.652]     }, error = function(ex) {
[10:58:47.652]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.652]                 ...future.rng), started = ...future.startTime, 
[10:58:47.652]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.652]             version = "1.8"), class = "FutureResult")
[10:58:47.652]     }, finally = {
[10:58:47.652]         if (!identical(...future.workdir, getwd())) 
[10:58:47.652]             setwd(...future.workdir)
[10:58:47.652]         {
[10:58:47.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.652]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.652]             }
[10:58:47.652]             base::options(...future.oldOptions)
[10:58:47.652]             if (.Platform$OS.type == "windows") {
[10:58:47.652]                 old_names <- names(...future.oldEnvVars)
[10:58:47.652]                 envs <- base::Sys.getenv()
[10:58:47.652]                 names <- names(envs)
[10:58:47.652]                 common <- intersect(names, old_names)
[10:58:47.652]                 added <- setdiff(names, old_names)
[10:58:47.652]                 removed <- setdiff(old_names, names)
[10:58:47.652]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.652]                   envs[common]]
[10:58:47.652]                 NAMES <- toupper(changed)
[10:58:47.652]                 args <- list()
[10:58:47.652]                 for (kk in seq_along(NAMES)) {
[10:58:47.652]                   name <- changed[[kk]]
[10:58:47.652]                   NAME <- NAMES[[kk]]
[10:58:47.652]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.652]                     next
[10:58:47.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.652]                 }
[10:58:47.652]                 NAMES <- toupper(added)
[10:58:47.652]                 for (kk in seq_along(NAMES)) {
[10:58:47.652]                   name <- added[[kk]]
[10:58:47.652]                   NAME <- NAMES[[kk]]
[10:58:47.652]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.652]                     next
[10:58:47.652]                   args[[name]] <- ""
[10:58:47.652]                 }
[10:58:47.652]                 NAMES <- toupper(removed)
[10:58:47.652]                 for (kk in seq_along(NAMES)) {
[10:58:47.652]                   name <- removed[[kk]]
[10:58:47.652]                   NAME <- NAMES[[kk]]
[10:58:47.652]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.652]                     next
[10:58:47.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.652]                 }
[10:58:47.652]                 if (length(args) > 0) 
[10:58:47.652]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.652]             }
[10:58:47.652]             else {
[10:58:47.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.652]             }
[10:58:47.652]             {
[10:58:47.652]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.652]                   0L) {
[10:58:47.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.652]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.652]                   base::options(opts)
[10:58:47.652]                 }
[10:58:47.652]                 {
[10:58:47.652]                   {
[10:58:47.652]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.652]                     NULL
[10:58:47.652]                   }
[10:58:47.652]                   options(future.plan = NULL)
[10:58:47.652]                   if (is.na(NA_character_)) 
[10:58:47.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.652]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.652]                     .init = FALSE)
[10:58:47.652]                 }
[10:58:47.652]             }
[10:58:47.652]         }
[10:58:47.652]     })
[10:58:47.652]     if (TRUE) {
[10:58:47.652]         base::sink(type = "output", split = FALSE)
[10:58:47.652]         if (TRUE) {
[10:58:47.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.652]         }
[10:58:47.652]         else {
[10:58:47.652]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.652]         }
[10:58:47.652]         base::close(...future.stdout)
[10:58:47.652]         ...future.stdout <- NULL
[10:58:47.652]     }
[10:58:47.652]     ...future.result$conditions <- ...future.conditions
[10:58:47.652]     ...future.result$finished <- base::Sys.time()
[10:58:47.652]     ...future.result
[10:58:47.652] }
[10:58:47.655] Exporting 5 global objects (1.20 KiB) to cluster node #2 ...
[10:58:47.655] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:58:47.656] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:58:47.656] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #2 ...
[10:58:47.656] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #2 ... DONE
[10:58:47.656] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ...
[10:58:47.657] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ... DONE
[10:58:47.657] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:47.657] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.657] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:47.657] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.657] Exporting 5 global objects (1.20 KiB) to cluster node #2 ... DONE
[10:58:47.658] MultisessionFuture started
[10:58:47.658] - Launch lazy future ... done
[10:58:47.658] run() for ‘MultisessionFuture’ ... done
[10:58:47.658] Created future:
[10:58:47.658] MultisessionFuture:
[10:58:47.658] Label: ‘future_eapply-2’
[10:58:47.658] Expression:
[10:58:47.658] {
[10:58:47.658]     do.call(function(...) {
[10:58:47.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.658]             on.exit(options(oopts), add = TRUE)
[10:58:47.658]         }
[10:58:47.658]         {
[10:58:47.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.658]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.658]             })
[10:58:47.658]         }
[10:58:47.658]     }, args = future.call.arguments)
[10:58:47.658] }
[10:58:47.658] Lazy evaluation: FALSE
[10:58:47.658] Asynchronous evaluation: TRUE
[10:58:47.658] Local evaluation: TRUE
[10:58:47.658] Environment: R_GlobalEnv
[10:58:47.658] Capture standard output: TRUE
[10:58:47.658] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.658] Globals: 5 objects totaling 795 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.658] Packages: 1 packages (‘stats’)
[10:58:47.658] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.658] Resolved: FALSE
[10:58:47.658] Value: <not collected>
[10:58:47.658] Conditions captured: <none>
[10:58:47.658] Early signaling: FALSE
[10:58:47.658] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.658] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.670] Chunk #2 of 2 ... DONE
[10:58:47.670] Launching 2 futures (chunks) ... DONE
[10:58:47.670] Resolving 2 futures (chunks) ...
[10:58:47.670] resolve() on list ...
[10:58:47.670]  recursive: 0
[10:58:47.670]  length: 2
[10:58:47.670] 
[10:58:47.671] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.671] - Validating connection of MultisessionFuture
[10:58:47.671] - received message: FutureResult
[10:58:47.671] - Received FutureResult
[10:58:47.671] - Erased future from FutureRegistry
[10:58:47.671] result() for ClusterFuture ...
[10:58:47.672] - result already collected: FutureResult
[10:58:47.672] result() for ClusterFuture ... done
[10:58:47.672] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.672] Future #1
[10:58:47.672] result() for ClusterFuture ...
[10:58:47.672] - result already collected: FutureResult
[10:58:47.672] result() for ClusterFuture ... done
[10:58:47.672] result() for ClusterFuture ...
[10:58:47.672] - result already collected: FutureResult
[10:58:47.672] result() for ClusterFuture ... done
[10:58:47.672] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:47.673] - nx: 2
[10:58:47.673] - relay: TRUE
[10:58:47.673] - stdout: TRUE
[10:58:47.673] - signal: TRUE
[10:58:47.673] - resignal: FALSE
[10:58:47.673] - force: TRUE
[10:58:47.673] - relayed: [n=2] FALSE, FALSE
[10:58:47.673] - queued futures: [n=2] FALSE, FALSE
[10:58:47.673]  - until=1
[10:58:47.673]  - relaying element #1
[10:58:47.673] result() for ClusterFuture ...
[10:58:47.673] - result already collected: FutureResult
[10:58:47.673] result() for ClusterFuture ... done
[10:58:47.674] result() for ClusterFuture ...
[10:58:47.674] - result already collected: FutureResult
[10:58:47.674] result() for ClusterFuture ... done
[10:58:47.674] result() for ClusterFuture ...
[10:58:47.674] - result already collected: FutureResult
[10:58:47.674] result() for ClusterFuture ... done
[10:58:47.674] result() for ClusterFuture ...
[10:58:47.674] - result already collected: FutureResult
[10:58:47.674] result() for ClusterFuture ... done
[10:58:47.674] - relayed: [n=2] TRUE, FALSE
[10:58:47.674] - queued futures: [n=2] TRUE, FALSE
[10:58:47.674] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:47.675]  length: 1 (resolved future 1)
[10:58:47.705] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.705] - Validating connection of MultisessionFuture
[10:58:47.706] - received message: FutureResult
[10:58:47.706] - Received FutureResult
[10:58:47.706] - Erased future from FutureRegistry
[10:58:47.706] result() for ClusterFuture ...
[10:58:47.706] - result already collected: FutureResult
[10:58:47.706] result() for ClusterFuture ... done
[10:58:47.706] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.706] Future #2
[10:58:47.706] result() for ClusterFuture ...
[10:58:47.707] - result already collected: FutureResult
[10:58:47.707] result() for ClusterFuture ... done
[10:58:47.707] result() for ClusterFuture ...
[10:58:47.707] - result already collected: FutureResult
[10:58:47.707] result() for ClusterFuture ... done
[10:58:47.707] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:47.707] - nx: 2
[10:58:47.707] - relay: TRUE
[10:58:47.707] - stdout: TRUE
[10:58:47.707] - signal: TRUE
[10:58:47.707] - resignal: FALSE
[10:58:47.707] - force: TRUE
[10:58:47.708] - relayed: [n=2] TRUE, FALSE
[10:58:47.708] - queued futures: [n=2] TRUE, FALSE
[10:58:47.708]  - until=2
[10:58:47.708]  - relaying element #2
[10:58:47.708] result() for ClusterFuture ...
[10:58:47.708] - result already collected: FutureResult
[10:58:47.708] result() for ClusterFuture ... done
[10:58:47.708] result() for ClusterFuture ...
[10:58:47.708] - result already collected: FutureResult
[10:58:47.708] result() for ClusterFuture ... done
[10:58:47.708] result() for ClusterFuture ...
[10:58:47.708] - result already collected: FutureResult
[10:58:47.709] result() for ClusterFuture ... done
[10:58:47.709] result() for ClusterFuture ...
[10:58:47.709] - result already collected: FutureResult
[10:58:47.709] result() for ClusterFuture ... done
[10:58:47.709] - relayed: [n=2] TRUE, TRUE
[10:58:47.709] - queued futures: [n=2] TRUE, TRUE
[10:58:47.709] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:47.709]  length: 0 (resolved future 2)
[10:58:47.709] Relaying remaining futures
[10:58:47.709] signalConditionsASAP(NULL, pos=0) ...
[10:58:47.709] - nx: 2
[10:58:47.709] - relay: TRUE
[10:58:47.710] - stdout: TRUE
[10:58:47.710] - signal: TRUE
[10:58:47.710] - resignal: FALSE
[10:58:47.710] - force: TRUE
[10:58:47.710] - relayed: [n=2] TRUE, TRUE
[10:58:47.710] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:47.710] - relayed: [n=2] TRUE, TRUE
[10:58:47.710] - queued futures: [n=2] TRUE, TRUE
[10:58:47.710] signalConditionsASAP(NULL, pos=0) ... done
[10:58:47.710] resolve() on list ... DONE
[10:58:47.710] result() for ClusterFuture ...
[10:58:47.710] - result already collected: FutureResult
[10:58:47.711] result() for ClusterFuture ... done
[10:58:47.711] result() for ClusterFuture ...
[10:58:47.711] - result already collected: FutureResult
[10:58:47.711] result() for ClusterFuture ... done
[10:58:47.711] result() for ClusterFuture ...
[10:58:47.711] - result already collected: FutureResult
[10:58:47.711] result() for ClusterFuture ... done
[10:58:47.711] result() for ClusterFuture ...
[10:58:47.711] - result already collected: FutureResult
[10:58:47.711] result() for ClusterFuture ... done
[10:58:47.711]  - Number of value chunks collected: 2
[10:58:47.711] Resolving 2 futures (chunks) ... DONE
[10:58:47.712] Reducing values from 2 chunks ...
[10:58:47.712]  - Number of values collected after concatenation: 3
[10:58:47.712]  - Number of values expected: 3
[10:58:47.712] Reducing values from 2 chunks ... DONE
[10:58:47.712] future_lapply() ... DONE
[10:58:47.713] future_lapply() ...
[10:58:47.715] Number of chunks: 2
[10:58:47.715] getGlobalsAndPackagesXApply() ...
[10:58:47.715]  - future.globals: TRUE
[10:58:47.715] getGlobalsAndPackages() ...
[10:58:47.715] Searching for globals...
[10:58:47.716] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:47.716] Searching for globals ... DONE
[10:58:47.716] Resolving globals: FALSE
[10:58:47.717] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:47.717] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:47.717] - globals: [1] ‘FUN’
[10:58:47.717] - packages: [1] ‘stats’
[10:58:47.717] getGlobalsAndPackages() ... DONE
[10:58:47.718]  - globals found/used: [n=1] ‘FUN’
[10:58:47.718]  - needed namespaces: [n=1] ‘stats’
[10:58:47.718] Finding globals ... DONE
[10:58:47.718]  - use_args: TRUE
[10:58:47.718]  - Getting '...' globals ...
[10:58:47.718] resolve() on list ...
[10:58:47.718]  recursive: 0
[10:58:47.718]  length: 1
[10:58:47.718]  elements: ‘...’
[10:58:47.719]  length: 0 (resolved future 1)
[10:58:47.719] resolve() on list ... DONE
[10:58:47.719]    - '...' content: [n=0] 
[10:58:47.719] List of 1
[10:58:47.719]  $ ...: list()
[10:58:47.719]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.719]  - attr(*, "where")=List of 1
[10:58:47.719]   ..$ ...:<environment: 0x55f48c84f898> 
[10:58:47.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.719]  - attr(*, "resolved")= logi TRUE
[10:58:47.719]  - attr(*, "total_size")= num NA
[10:58:47.721]  - Getting '...' globals ... DONE
[10:58:47.721] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:47.721] List of 2
[10:58:47.721]  $ ...future.FUN:function (x, ...)  
[10:58:47.721]  $ ...          : list()
[10:58:47.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.721]  - attr(*, "where")=List of 2
[10:58:47.721]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:47.721]   ..$ ...          :<environment: 0x55f48c84f898> 
[10:58:47.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.721]  - attr(*, "resolved")= logi FALSE
[10:58:47.721]  - attr(*, "total_size")= num 5433
[10:58:47.724] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:47.724] getGlobalsAndPackagesXApply() ... DONE
[10:58:47.724] Number of futures (= number of chunks): 2
[10:58:47.725] Launching 2 futures (chunks) ...
[10:58:47.725] Chunk #1 of 2 ...
[10:58:47.725]  - Finding globals in 'X' for chunk #1 ...
[10:58:47.725] getGlobalsAndPackages() ...
[10:58:47.725] Searching for globals...
[10:58:47.725] 
[10:58:47.725] Searching for globals ... DONE
[10:58:47.725] - globals: [0] <none>
[10:58:47.725] getGlobalsAndPackages() ... DONE
[10:58:47.725]    + additional globals found: [n=0] 
[10:58:47.726]    + additional namespaces needed: [n=0] 
[10:58:47.726]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:47.726]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.726]  - seeds: <none>
[10:58:47.726]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.726] getGlobalsAndPackages() ...
[10:58:47.726] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.726] Resolving globals: FALSE
[10:58:47.726] Tweak future expression to call with '...' arguments ...
[10:58:47.726] {
[10:58:47.726]     do.call(function(...) {
[10:58:47.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.726]             on.exit(options(oopts), add = TRUE)
[10:58:47.726]         }
[10:58:47.726]         {
[10:58:47.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.726]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.726]             })
[10:58:47.726]         }
[10:58:47.726]     }, args = future.call.arguments)
[10:58:47.726] }
[10:58:47.727] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.727] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.727] - packages: [1] ‘stats’
[10:58:47.727] getGlobalsAndPackages() ... DONE
[10:58:47.728] run() for ‘Future’ ...
[10:58:47.728] - state: ‘created’
[10:58:47.728] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.741] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.742]   - Field: ‘node’
[10:58:47.742]   - Field: ‘label’
[10:58:47.742]   - Field: ‘local’
[10:58:47.742]   - Field: ‘owner’
[10:58:47.742]   - Field: ‘envir’
[10:58:47.742]   - Field: ‘workers’
[10:58:47.742]   - Field: ‘packages’
[10:58:47.742]   - Field: ‘gc’
[10:58:47.742]   - Field: ‘conditions’
[10:58:47.742]   - Field: ‘persistent’
[10:58:47.743]   - Field: ‘expr’
[10:58:47.743]   - Field: ‘uuid’
[10:58:47.743]   - Field: ‘seed’
[10:58:47.743]   - Field: ‘version’
[10:58:47.743]   - Field: ‘result’
[10:58:47.743]   - Field: ‘asynchronous’
[10:58:47.743]   - Field: ‘calls’
[10:58:47.743]   - Field: ‘globals’
[10:58:47.743]   - Field: ‘stdout’
[10:58:47.743]   - Field: ‘earlySignal’
[10:58:47.743]   - Field: ‘lazy’
[10:58:47.743]   - Field: ‘state’
[10:58:47.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.744] - Launch lazy future ...
[10:58:47.744] Packages needed by the future expression (n = 1): ‘stats’
[10:58:47.744] Packages needed by future strategies (n = 0): <none>
[10:58:47.745] {
[10:58:47.745]     {
[10:58:47.745]         {
[10:58:47.745]             ...future.startTime <- base::Sys.time()
[10:58:47.745]             {
[10:58:47.745]                 {
[10:58:47.745]                   {
[10:58:47.745]                     {
[10:58:47.745]                       {
[10:58:47.745]                         base::local({
[10:58:47.745]                           has_future <- base::requireNamespace("future", 
[10:58:47.745]                             quietly = TRUE)
[10:58:47.745]                           if (has_future) {
[10:58:47.745]                             ns <- base::getNamespace("future")
[10:58:47.745]                             version <- ns[[".package"]][["version"]]
[10:58:47.745]                             if (is.null(version)) 
[10:58:47.745]                               version <- utils::packageVersion("future")
[10:58:47.745]                           }
[10:58:47.745]                           else {
[10:58:47.745]                             version <- NULL
[10:58:47.745]                           }
[10:58:47.745]                           if (!has_future || version < "1.8.0") {
[10:58:47.745]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.745]                               "", base::R.version$version.string), 
[10:58:47.745]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:47.745]                                 base::R.version$platform, 8 * 
[10:58:47.745]                                   base::.Machine$sizeof.pointer), 
[10:58:47.745]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.745]                                 "release", "version")], collapse = " "), 
[10:58:47.745]                               hostname = base::Sys.info()[["nodename"]])
[10:58:47.745]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.745]                               info)
[10:58:47.745]                             info <- base::paste(info, collapse = "; ")
[10:58:47.745]                             if (!has_future) {
[10:58:47.745]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.745]                                 info)
[10:58:47.745]                             }
[10:58:47.745]                             else {
[10:58:47.745]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.745]                                 info, version)
[10:58:47.745]                             }
[10:58:47.745]                             base::stop(msg)
[10:58:47.745]                           }
[10:58:47.745]                         })
[10:58:47.745]                       }
[10:58:47.745]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.745]                       base::options(mc.cores = 1L)
[10:58:47.745]                     }
[10:58:47.745]                     base::local({
[10:58:47.745]                       for (pkg in "stats") {
[10:58:47.745]                         base::loadNamespace(pkg)
[10:58:47.745]                         base::library(pkg, character.only = TRUE)
[10:58:47.745]                       }
[10:58:47.745]                     })
[10:58:47.745]                   }
[10:58:47.745]                   ...future.strategy.old <- future::plan("list")
[10:58:47.745]                   options(future.plan = NULL)
[10:58:47.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.745]                 }
[10:58:47.745]                 ...future.workdir <- getwd()
[10:58:47.745]             }
[10:58:47.745]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.745]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.745]         }
[10:58:47.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.745]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.745]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.745]             base::names(...future.oldOptions))
[10:58:47.745]     }
[10:58:47.745]     if (FALSE) {
[10:58:47.745]     }
[10:58:47.745]     else {
[10:58:47.745]         if (TRUE) {
[10:58:47.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.745]                 open = "w")
[10:58:47.745]         }
[10:58:47.745]         else {
[10:58:47.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.745]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.745]         }
[10:58:47.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.745]             base::sink(type = "output", split = FALSE)
[10:58:47.745]             base::close(...future.stdout)
[10:58:47.745]         }, add = TRUE)
[10:58:47.745]     }
[10:58:47.745]     ...future.frame <- base::sys.nframe()
[10:58:47.745]     ...future.conditions <- base::list()
[10:58:47.745]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.745]     if (FALSE) {
[10:58:47.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.745]     }
[10:58:47.745]     ...future.result <- base::tryCatch({
[10:58:47.745]         base::withCallingHandlers({
[10:58:47.745]             ...future.value <- base::withVisible(base::local({
[10:58:47.745]                 ...future.makeSendCondition <- base::local({
[10:58:47.745]                   sendCondition <- NULL
[10:58:47.745]                   function(frame = 1L) {
[10:58:47.745]                     if (is.function(sendCondition)) 
[10:58:47.745]                       return(sendCondition)
[10:58:47.745]                     ns <- getNamespace("parallel")
[10:58:47.745]                     if (exists("sendData", mode = "function", 
[10:58:47.745]                       envir = ns)) {
[10:58:47.745]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.745]                         envir = ns)
[10:58:47.745]                       envir <- sys.frame(frame)
[10:58:47.745]                       master <- NULL
[10:58:47.745]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.745]                         !identical(envir, emptyenv())) {
[10:58:47.745]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.745]                           inherits = FALSE)) {
[10:58:47.745]                           master <- get("master", mode = "list", 
[10:58:47.745]                             envir = envir, inherits = FALSE)
[10:58:47.745]                           if (inherits(master, c("SOCKnode", 
[10:58:47.745]                             "SOCK0node"))) {
[10:58:47.745]                             sendCondition <<- function(cond) {
[10:58:47.745]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.745]                                 success = TRUE)
[10:58:47.745]                               parallel_sendData(master, data)
[10:58:47.745]                             }
[10:58:47.745]                             return(sendCondition)
[10:58:47.745]                           }
[10:58:47.745]                         }
[10:58:47.745]                         frame <- frame + 1L
[10:58:47.745]                         envir <- sys.frame(frame)
[10:58:47.745]                       }
[10:58:47.745]                     }
[10:58:47.745]                     sendCondition <<- function(cond) NULL
[10:58:47.745]                   }
[10:58:47.745]                 })
[10:58:47.745]                 withCallingHandlers({
[10:58:47.745]                   {
[10:58:47.745]                     do.call(function(...) {
[10:58:47.745]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.745]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.745]                         ...future.globals.maxSize)) {
[10:58:47.745]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.745]                         on.exit(options(oopts), add = TRUE)
[10:58:47.745]                       }
[10:58:47.745]                       {
[10:58:47.745]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.745]                           FUN = function(jj) {
[10:58:47.745]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.745]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.745]                           })
[10:58:47.745]                       }
[10:58:47.745]                     }, args = future.call.arguments)
[10:58:47.745]                   }
[10:58:47.745]                 }, immediateCondition = function(cond) {
[10:58:47.745]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.745]                   sendCondition(cond)
[10:58:47.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.745]                   {
[10:58:47.745]                     inherits <- base::inherits
[10:58:47.745]                     invokeRestart <- base::invokeRestart
[10:58:47.745]                     is.null <- base::is.null
[10:58:47.745]                     muffled <- FALSE
[10:58:47.745]                     if (inherits(cond, "message")) {
[10:58:47.745]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.745]                       if (muffled) 
[10:58:47.745]                         invokeRestart("muffleMessage")
[10:58:47.745]                     }
[10:58:47.745]                     else if (inherits(cond, "warning")) {
[10:58:47.745]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.745]                       if (muffled) 
[10:58:47.745]                         invokeRestart("muffleWarning")
[10:58:47.745]                     }
[10:58:47.745]                     else if (inherits(cond, "condition")) {
[10:58:47.745]                       if (!is.null(pattern)) {
[10:58:47.745]                         computeRestarts <- base::computeRestarts
[10:58:47.745]                         grepl <- base::grepl
[10:58:47.745]                         restarts <- computeRestarts(cond)
[10:58:47.745]                         for (restart in restarts) {
[10:58:47.745]                           name <- restart$name
[10:58:47.745]                           if (is.null(name)) 
[10:58:47.745]                             next
[10:58:47.745]                           if (!grepl(pattern, name)) 
[10:58:47.745]                             next
[10:58:47.745]                           invokeRestart(restart)
[10:58:47.745]                           muffled <- TRUE
[10:58:47.745]                           break
[10:58:47.745]                         }
[10:58:47.745]                       }
[10:58:47.745]                     }
[10:58:47.745]                     invisible(muffled)
[10:58:47.745]                   }
[10:58:47.745]                   muffleCondition(cond)
[10:58:47.745]                 })
[10:58:47.745]             }))
[10:58:47.745]             future::FutureResult(value = ...future.value$value, 
[10:58:47.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.745]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.745]                     ...future.globalenv.names))
[10:58:47.745]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.745]         }, condition = base::local({
[10:58:47.745]             c <- base::c
[10:58:47.745]             inherits <- base::inherits
[10:58:47.745]             invokeRestart <- base::invokeRestart
[10:58:47.745]             length <- base::length
[10:58:47.745]             list <- base::list
[10:58:47.745]             seq.int <- base::seq.int
[10:58:47.745]             signalCondition <- base::signalCondition
[10:58:47.745]             sys.calls <- base::sys.calls
[10:58:47.745]             `[[` <- base::`[[`
[10:58:47.745]             `+` <- base::`+`
[10:58:47.745]             `<<-` <- base::`<<-`
[10:58:47.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.745]                   3L)]
[10:58:47.745]             }
[10:58:47.745]             function(cond) {
[10:58:47.745]                 is_error <- inherits(cond, "error")
[10:58:47.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.745]                   NULL)
[10:58:47.745]                 if (is_error) {
[10:58:47.745]                   sessionInformation <- function() {
[10:58:47.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.745]                       search = base::search(), system = base::Sys.info())
[10:58:47.745]                   }
[10:58:47.745]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.745]                     cond$call), session = sessionInformation(), 
[10:58:47.745]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.745]                   signalCondition(cond)
[10:58:47.745]                 }
[10:58:47.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.745]                 "immediateCondition"))) {
[10:58:47.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.745]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.745]                   if (TRUE && !signal) {
[10:58:47.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.745]                     {
[10:58:47.745]                       inherits <- base::inherits
[10:58:47.745]                       invokeRestart <- base::invokeRestart
[10:58:47.745]                       is.null <- base::is.null
[10:58:47.745]                       muffled <- FALSE
[10:58:47.745]                       if (inherits(cond, "message")) {
[10:58:47.745]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.745]                         if (muffled) 
[10:58:47.745]                           invokeRestart("muffleMessage")
[10:58:47.745]                       }
[10:58:47.745]                       else if (inherits(cond, "warning")) {
[10:58:47.745]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.745]                         if (muffled) 
[10:58:47.745]                           invokeRestart("muffleWarning")
[10:58:47.745]                       }
[10:58:47.745]                       else if (inherits(cond, "condition")) {
[10:58:47.745]                         if (!is.null(pattern)) {
[10:58:47.745]                           computeRestarts <- base::computeRestarts
[10:58:47.745]                           grepl <- base::grepl
[10:58:47.745]                           restarts <- computeRestarts(cond)
[10:58:47.745]                           for (restart in restarts) {
[10:58:47.745]                             name <- restart$name
[10:58:47.745]                             if (is.null(name)) 
[10:58:47.745]                               next
[10:58:47.745]                             if (!grepl(pattern, name)) 
[10:58:47.745]                               next
[10:58:47.745]                             invokeRestart(restart)
[10:58:47.745]                             muffled <- TRUE
[10:58:47.745]                             break
[10:58:47.745]                           }
[10:58:47.745]                         }
[10:58:47.745]                       }
[10:58:47.745]                       invisible(muffled)
[10:58:47.745]                     }
[10:58:47.745]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.745]                   }
[10:58:47.745]                 }
[10:58:47.745]                 else {
[10:58:47.745]                   if (TRUE) {
[10:58:47.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.745]                     {
[10:58:47.745]                       inherits <- base::inherits
[10:58:47.745]                       invokeRestart <- base::invokeRestart
[10:58:47.745]                       is.null <- base::is.null
[10:58:47.745]                       muffled <- FALSE
[10:58:47.745]                       if (inherits(cond, "message")) {
[10:58:47.745]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.745]                         if (muffled) 
[10:58:47.745]                           invokeRestart("muffleMessage")
[10:58:47.745]                       }
[10:58:47.745]                       else if (inherits(cond, "warning")) {
[10:58:47.745]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.745]                         if (muffled) 
[10:58:47.745]                           invokeRestart("muffleWarning")
[10:58:47.745]                       }
[10:58:47.745]                       else if (inherits(cond, "condition")) {
[10:58:47.745]                         if (!is.null(pattern)) {
[10:58:47.745]                           computeRestarts <- base::computeRestarts
[10:58:47.745]                           grepl <- base::grepl
[10:58:47.745]                           restarts <- computeRestarts(cond)
[10:58:47.745]                           for (restart in restarts) {
[10:58:47.745]                             name <- restart$name
[10:58:47.745]                             if (is.null(name)) 
[10:58:47.745]                               next
[10:58:47.745]                             if (!grepl(pattern, name)) 
[10:58:47.745]                               next
[10:58:47.745]                             invokeRestart(restart)
[10:58:47.745]                             muffled <- TRUE
[10:58:47.745]                             break
[10:58:47.745]                           }
[10:58:47.745]                         }
[10:58:47.745]                       }
[10:58:47.745]                       invisible(muffled)
[10:58:47.745]                     }
[10:58:47.745]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.745]                   }
[10:58:47.745]                 }
[10:58:47.745]             }
[10:58:47.745]         }))
[10:58:47.745]     }, error = function(ex) {
[10:58:47.745]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.745]                 ...future.rng), started = ...future.startTime, 
[10:58:47.745]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.745]             version = "1.8"), class = "FutureResult")
[10:58:47.745]     }, finally = {
[10:58:47.745]         if (!identical(...future.workdir, getwd())) 
[10:58:47.745]             setwd(...future.workdir)
[10:58:47.745]         {
[10:58:47.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.745]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.745]             }
[10:58:47.745]             base::options(...future.oldOptions)
[10:58:47.745]             if (.Platform$OS.type == "windows") {
[10:58:47.745]                 old_names <- names(...future.oldEnvVars)
[10:58:47.745]                 envs <- base::Sys.getenv()
[10:58:47.745]                 names <- names(envs)
[10:58:47.745]                 common <- intersect(names, old_names)
[10:58:47.745]                 added <- setdiff(names, old_names)
[10:58:47.745]                 removed <- setdiff(old_names, names)
[10:58:47.745]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.745]                   envs[common]]
[10:58:47.745]                 NAMES <- toupper(changed)
[10:58:47.745]                 args <- list()
[10:58:47.745]                 for (kk in seq_along(NAMES)) {
[10:58:47.745]                   name <- changed[[kk]]
[10:58:47.745]                   NAME <- NAMES[[kk]]
[10:58:47.745]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.745]                     next
[10:58:47.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.745]                 }
[10:58:47.745]                 NAMES <- toupper(added)
[10:58:47.745]                 for (kk in seq_along(NAMES)) {
[10:58:47.745]                   name <- added[[kk]]
[10:58:47.745]                   NAME <- NAMES[[kk]]
[10:58:47.745]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.745]                     next
[10:58:47.745]                   args[[name]] <- ""
[10:58:47.745]                 }
[10:58:47.745]                 NAMES <- toupper(removed)
[10:58:47.745]                 for (kk in seq_along(NAMES)) {
[10:58:47.745]                   name <- removed[[kk]]
[10:58:47.745]                   NAME <- NAMES[[kk]]
[10:58:47.745]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.745]                     next
[10:58:47.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.745]                 }
[10:58:47.745]                 if (length(args) > 0) 
[10:58:47.745]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.745]             }
[10:58:47.745]             else {
[10:58:47.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.745]             }
[10:58:47.745]             {
[10:58:47.745]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.745]                   0L) {
[10:58:47.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.745]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.745]                   base::options(opts)
[10:58:47.745]                 }
[10:58:47.745]                 {
[10:58:47.745]                   {
[10:58:47.745]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.745]                     NULL
[10:58:47.745]                   }
[10:58:47.745]                   options(future.plan = NULL)
[10:58:47.745]                   if (is.na(NA_character_)) 
[10:58:47.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.745]                     .init = FALSE)
[10:58:47.745]                 }
[10:58:47.745]             }
[10:58:47.745]         }
[10:58:47.745]     })
[10:58:47.745]     if (TRUE) {
[10:58:47.745]         base::sink(type = "output", split = FALSE)
[10:58:47.745]         if (TRUE) {
[10:58:47.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.745]         }
[10:58:47.745]         else {
[10:58:47.745]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.745]         }
[10:58:47.745]         base::close(...future.stdout)
[10:58:47.745]         ...future.stdout <- NULL
[10:58:47.745]     }
[10:58:47.745]     ...future.result$conditions <- ...future.conditions
[10:58:47.745]     ...future.result$finished <- base::Sys.time()
[10:58:47.745]     ...future.result
[10:58:47.745] }
[10:58:47.747] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[10:58:47.748] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:58:47.748] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:58:47.748] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:47.748] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:47.749] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ...
[10:58:47.749] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ... DONE
[10:58:47.749] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:47.749] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.750] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:47.750] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.750] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[10:58:47.751] MultisessionFuture started
[10:58:47.751] - Launch lazy future ... done
[10:58:47.751] run() for ‘MultisessionFuture’ ... done
[10:58:47.751] Created future:
[10:58:47.751] MultisessionFuture:
[10:58:47.751] Label: ‘future_eapply-1’
[10:58:47.751] Expression:
[10:58:47.751] {
[10:58:47.751]     do.call(function(...) {
[10:58:47.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.751]             on.exit(options(oopts), add = TRUE)
[10:58:47.751]         }
[10:58:47.751]         {
[10:58:47.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.751]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.751]             })
[10:58:47.751]         }
[10:58:47.751]     }, args = future.call.arguments)
[10:58:47.751] }
[10:58:47.751] Lazy evaluation: FALSE
[10:58:47.751] Asynchronous evaluation: TRUE
[10:58:47.751] Local evaluation: TRUE
[10:58:47.751] Environment: R_GlobalEnv
[10:58:47.751] Capture standard output: TRUE
[10:58:47.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.751] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.751] Packages: 1 packages (‘stats’)
[10:58:47.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.751] Resolved: FALSE
[10:58:47.751] Value: <not collected>
[10:58:47.751] Conditions captured: <none>
[10:58:47.751] Early signaling: FALSE
[10:58:47.751] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.751] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.762] Chunk #1 of 2 ... DONE
[10:58:47.762] Chunk #2 of 2 ...
[10:58:47.763]  - Finding globals in 'X' for chunk #2 ...
[10:58:47.763] getGlobalsAndPackages() ...
[10:58:47.763] Searching for globals...
[10:58:47.763] 
[10:58:47.763] Searching for globals ... DONE
[10:58:47.763] - globals: [0] <none>
[10:58:47.763] getGlobalsAndPackages() ... DONE
[10:58:47.763]    + additional globals found: [n=0] 
[10:58:47.763]    + additional namespaces needed: [n=0] 
[10:58:47.764]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:47.764]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.764]  - seeds: <none>
[10:58:47.764]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.764] getGlobalsAndPackages() ...
[10:58:47.764] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.764] Resolving globals: FALSE
[10:58:47.764] Tweak future expression to call with '...' arguments ...
[10:58:47.764] {
[10:58:47.764]     do.call(function(...) {
[10:58:47.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.764]             on.exit(options(oopts), add = TRUE)
[10:58:47.764]         }
[10:58:47.764]         {
[10:58:47.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.764]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.764]             })
[10:58:47.764]         }
[10:58:47.764]     }, args = future.call.arguments)
[10:58:47.764] }
[10:58:47.765] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.765] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.765] - packages: [1] ‘stats’
[10:58:47.765] getGlobalsAndPackages() ... DONE
[10:58:47.765] run() for ‘Future’ ...
[10:58:47.766] - state: ‘created’
[10:58:47.766] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.780] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.780]   - Field: ‘node’
[10:58:47.780]   - Field: ‘label’
[10:58:47.780]   - Field: ‘local’
[10:58:47.780]   - Field: ‘owner’
[10:58:47.780]   - Field: ‘envir’
[10:58:47.780]   - Field: ‘workers’
[10:58:47.781]   - Field: ‘packages’
[10:58:47.781]   - Field: ‘gc’
[10:58:47.781]   - Field: ‘conditions’
[10:58:47.781]   - Field: ‘persistent’
[10:58:47.781]   - Field: ‘expr’
[10:58:47.781]   - Field: ‘uuid’
[10:58:47.781]   - Field: ‘seed’
[10:58:47.781]   - Field: ‘version’
[10:58:47.781]   - Field: ‘result’
[10:58:47.781]   - Field: ‘asynchronous’
[10:58:47.781]   - Field: ‘calls’
[10:58:47.781]   - Field: ‘globals’
[10:58:47.782]   - Field: ‘stdout’
[10:58:47.782]   - Field: ‘earlySignal’
[10:58:47.782]   - Field: ‘lazy’
[10:58:47.782]   - Field: ‘state’
[10:58:47.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.782] - Launch lazy future ...
[10:58:47.782] Packages needed by the future expression (n = 1): ‘stats’
[10:58:47.782] Packages needed by future strategies (n = 0): <none>
[10:58:47.783] {
[10:58:47.783]     {
[10:58:47.783]         {
[10:58:47.783]             ...future.startTime <- base::Sys.time()
[10:58:47.783]             {
[10:58:47.783]                 {
[10:58:47.783]                   {
[10:58:47.783]                     {
[10:58:47.783]                       {
[10:58:47.783]                         base::local({
[10:58:47.783]                           has_future <- base::requireNamespace("future", 
[10:58:47.783]                             quietly = TRUE)
[10:58:47.783]                           if (has_future) {
[10:58:47.783]                             ns <- base::getNamespace("future")
[10:58:47.783]                             version <- ns[[".package"]][["version"]]
[10:58:47.783]                             if (is.null(version)) 
[10:58:47.783]                               version <- utils::packageVersion("future")
[10:58:47.783]                           }
[10:58:47.783]                           else {
[10:58:47.783]                             version <- NULL
[10:58:47.783]                           }
[10:58:47.783]                           if (!has_future || version < "1.8.0") {
[10:58:47.783]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.783]                               "", base::R.version$version.string), 
[10:58:47.783]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:47.783]                                 base::R.version$platform, 8 * 
[10:58:47.783]                                   base::.Machine$sizeof.pointer), 
[10:58:47.783]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.783]                                 "release", "version")], collapse = " "), 
[10:58:47.783]                               hostname = base::Sys.info()[["nodename"]])
[10:58:47.783]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.783]                               info)
[10:58:47.783]                             info <- base::paste(info, collapse = "; ")
[10:58:47.783]                             if (!has_future) {
[10:58:47.783]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.783]                                 info)
[10:58:47.783]                             }
[10:58:47.783]                             else {
[10:58:47.783]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.783]                                 info, version)
[10:58:47.783]                             }
[10:58:47.783]                             base::stop(msg)
[10:58:47.783]                           }
[10:58:47.783]                         })
[10:58:47.783]                       }
[10:58:47.783]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.783]                       base::options(mc.cores = 1L)
[10:58:47.783]                     }
[10:58:47.783]                     base::local({
[10:58:47.783]                       for (pkg in "stats") {
[10:58:47.783]                         base::loadNamespace(pkg)
[10:58:47.783]                         base::library(pkg, character.only = TRUE)
[10:58:47.783]                       }
[10:58:47.783]                     })
[10:58:47.783]                   }
[10:58:47.783]                   ...future.strategy.old <- future::plan("list")
[10:58:47.783]                   options(future.plan = NULL)
[10:58:47.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.783]                 }
[10:58:47.783]                 ...future.workdir <- getwd()
[10:58:47.783]             }
[10:58:47.783]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.783]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.783]         }
[10:58:47.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.783]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.783]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.783]             base::names(...future.oldOptions))
[10:58:47.783]     }
[10:58:47.783]     if (FALSE) {
[10:58:47.783]     }
[10:58:47.783]     else {
[10:58:47.783]         if (TRUE) {
[10:58:47.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.783]                 open = "w")
[10:58:47.783]         }
[10:58:47.783]         else {
[10:58:47.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.783]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.783]         }
[10:58:47.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.783]             base::sink(type = "output", split = FALSE)
[10:58:47.783]             base::close(...future.stdout)
[10:58:47.783]         }, add = TRUE)
[10:58:47.783]     }
[10:58:47.783]     ...future.frame <- base::sys.nframe()
[10:58:47.783]     ...future.conditions <- base::list()
[10:58:47.783]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.783]     if (FALSE) {
[10:58:47.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.783]     }
[10:58:47.783]     ...future.result <- base::tryCatch({
[10:58:47.783]         base::withCallingHandlers({
[10:58:47.783]             ...future.value <- base::withVisible(base::local({
[10:58:47.783]                 ...future.makeSendCondition <- base::local({
[10:58:47.783]                   sendCondition <- NULL
[10:58:47.783]                   function(frame = 1L) {
[10:58:47.783]                     if (is.function(sendCondition)) 
[10:58:47.783]                       return(sendCondition)
[10:58:47.783]                     ns <- getNamespace("parallel")
[10:58:47.783]                     if (exists("sendData", mode = "function", 
[10:58:47.783]                       envir = ns)) {
[10:58:47.783]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.783]                         envir = ns)
[10:58:47.783]                       envir <- sys.frame(frame)
[10:58:47.783]                       master <- NULL
[10:58:47.783]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.783]                         !identical(envir, emptyenv())) {
[10:58:47.783]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.783]                           inherits = FALSE)) {
[10:58:47.783]                           master <- get("master", mode = "list", 
[10:58:47.783]                             envir = envir, inherits = FALSE)
[10:58:47.783]                           if (inherits(master, c("SOCKnode", 
[10:58:47.783]                             "SOCK0node"))) {
[10:58:47.783]                             sendCondition <<- function(cond) {
[10:58:47.783]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.783]                                 success = TRUE)
[10:58:47.783]                               parallel_sendData(master, data)
[10:58:47.783]                             }
[10:58:47.783]                             return(sendCondition)
[10:58:47.783]                           }
[10:58:47.783]                         }
[10:58:47.783]                         frame <- frame + 1L
[10:58:47.783]                         envir <- sys.frame(frame)
[10:58:47.783]                       }
[10:58:47.783]                     }
[10:58:47.783]                     sendCondition <<- function(cond) NULL
[10:58:47.783]                   }
[10:58:47.783]                 })
[10:58:47.783]                 withCallingHandlers({
[10:58:47.783]                   {
[10:58:47.783]                     do.call(function(...) {
[10:58:47.783]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.783]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.783]                         ...future.globals.maxSize)) {
[10:58:47.783]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.783]                         on.exit(options(oopts), add = TRUE)
[10:58:47.783]                       }
[10:58:47.783]                       {
[10:58:47.783]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.783]                           FUN = function(jj) {
[10:58:47.783]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.783]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.783]                           })
[10:58:47.783]                       }
[10:58:47.783]                     }, args = future.call.arguments)
[10:58:47.783]                   }
[10:58:47.783]                 }, immediateCondition = function(cond) {
[10:58:47.783]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.783]                   sendCondition(cond)
[10:58:47.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.783]                   {
[10:58:47.783]                     inherits <- base::inherits
[10:58:47.783]                     invokeRestart <- base::invokeRestart
[10:58:47.783]                     is.null <- base::is.null
[10:58:47.783]                     muffled <- FALSE
[10:58:47.783]                     if (inherits(cond, "message")) {
[10:58:47.783]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.783]                       if (muffled) 
[10:58:47.783]                         invokeRestart("muffleMessage")
[10:58:47.783]                     }
[10:58:47.783]                     else if (inherits(cond, "warning")) {
[10:58:47.783]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.783]                       if (muffled) 
[10:58:47.783]                         invokeRestart("muffleWarning")
[10:58:47.783]                     }
[10:58:47.783]                     else if (inherits(cond, "condition")) {
[10:58:47.783]                       if (!is.null(pattern)) {
[10:58:47.783]                         computeRestarts <- base::computeRestarts
[10:58:47.783]                         grepl <- base::grepl
[10:58:47.783]                         restarts <- computeRestarts(cond)
[10:58:47.783]                         for (restart in restarts) {
[10:58:47.783]                           name <- restart$name
[10:58:47.783]                           if (is.null(name)) 
[10:58:47.783]                             next
[10:58:47.783]                           if (!grepl(pattern, name)) 
[10:58:47.783]                             next
[10:58:47.783]                           invokeRestart(restart)
[10:58:47.783]                           muffled <- TRUE
[10:58:47.783]                           break
[10:58:47.783]                         }
[10:58:47.783]                       }
[10:58:47.783]                     }
[10:58:47.783]                     invisible(muffled)
[10:58:47.783]                   }
[10:58:47.783]                   muffleCondition(cond)
[10:58:47.783]                 })
[10:58:47.783]             }))
[10:58:47.783]             future::FutureResult(value = ...future.value$value, 
[10:58:47.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.783]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.783]                     ...future.globalenv.names))
[10:58:47.783]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.783]         }, condition = base::local({
[10:58:47.783]             c <- base::c
[10:58:47.783]             inherits <- base::inherits
[10:58:47.783]             invokeRestart <- base::invokeRestart
[10:58:47.783]             length <- base::length
[10:58:47.783]             list <- base::list
[10:58:47.783]             seq.int <- base::seq.int
[10:58:47.783]             signalCondition <- base::signalCondition
[10:58:47.783]             sys.calls <- base::sys.calls
[10:58:47.783]             `[[` <- base::`[[`
[10:58:47.783]             `+` <- base::`+`
[10:58:47.783]             `<<-` <- base::`<<-`
[10:58:47.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.783]                   3L)]
[10:58:47.783]             }
[10:58:47.783]             function(cond) {
[10:58:47.783]                 is_error <- inherits(cond, "error")
[10:58:47.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.783]                   NULL)
[10:58:47.783]                 if (is_error) {
[10:58:47.783]                   sessionInformation <- function() {
[10:58:47.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.783]                       search = base::search(), system = base::Sys.info())
[10:58:47.783]                   }
[10:58:47.783]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.783]                     cond$call), session = sessionInformation(), 
[10:58:47.783]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.783]                   signalCondition(cond)
[10:58:47.783]                 }
[10:58:47.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.783]                 "immediateCondition"))) {
[10:58:47.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.783]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.783]                   if (TRUE && !signal) {
[10:58:47.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.783]                     {
[10:58:47.783]                       inherits <- base::inherits
[10:58:47.783]                       invokeRestart <- base::invokeRestart
[10:58:47.783]                       is.null <- base::is.null
[10:58:47.783]                       muffled <- FALSE
[10:58:47.783]                       if (inherits(cond, "message")) {
[10:58:47.783]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.783]                         if (muffled) 
[10:58:47.783]                           invokeRestart("muffleMessage")
[10:58:47.783]                       }
[10:58:47.783]                       else if (inherits(cond, "warning")) {
[10:58:47.783]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.783]                         if (muffled) 
[10:58:47.783]                           invokeRestart("muffleWarning")
[10:58:47.783]                       }
[10:58:47.783]                       else if (inherits(cond, "condition")) {
[10:58:47.783]                         if (!is.null(pattern)) {
[10:58:47.783]                           computeRestarts <- base::computeRestarts
[10:58:47.783]                           grepl <- base::grepl
[10:58:47.783]                           restarts <- computeRestarts(cond)
[10:58:47.783]                           for (restart in restarts) {
[10:58:47.783]                             name <- restart$name
[10:58:47.783]                             if (is.null(name)) 
[10:58:47.783]                               next
[10:58:47.783]                             if (!grepl(pattern, name)) 
[10:58:47.783]                               next
[10:58:47.783]                             invokeRestart(restart)
[10:58:47.783]                             muffled <- TRUE
[10:58:47.783]                             break
[10:58:47.783]                           }
[10:58:47.783]                         }
[10:58:47.783]                       }
[10:58:47.783]                       invisible(muffled)
[10:58:47.783]                     }
[10:58:47.783]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.783]                   }
[10:58:47.783]                 }
[10:58:47.783]                 else {
[10:58:47.783]                   if (TRUE) {
[10:58:47.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.783]                     {
[10:58:47.783]                       inherits <- base::inherits
[10:58:47.783]                       invokeRestart <- base::invokeRestart
[10:58:47.783]                       is.null <- base::is.null
[10:58:47.783]                       muffled <- FALSE
[10:58:47.783]                       if (inherits(cond, "message")) {
[10:58:47.783]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.783]                         if (muffled) 
[10:58:47.783]                           invokeRestart("muffleMessage")
[10:58:47.783]                       }
[10:58:47.783]                       else if (inherits(cond, "warning")) {
[10:58:47.783]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.783]                         if (muffled) 
[10:58:47.783]                           invokeRestart("muffleWarning")
[10:58:47.783]                       }
[10:58:47.783]                       else if (inherits(cond, "condition")) {
[10:58:47.783]                         if (!is.null(pattern)) {
[10:58:47.783]                           computeRestarts <- base::computeRestarts
[10:58:47.783]                           grepl <- base::grepl
[10:58:47.783]                           restarts <- computeRestarts(cond)
[10:58:47.783]                           for (restart in restarts) {
[10:58:47.783]                             name <- restart$name
[10:58:47.783]                             if (is.null(name)) 
[10:58:47.783]                               next
[10:58:47.783]                             if (!grepl(pattern, name)) 
[10:58:47.783]                               next
[10:58:47.783]                             invokeRestart(restart)
[10:58:47.783]                             muffled <- TRUE
[10:58:47.783]                             break
[10:58:47.783]                           }
[10:58:47.783]                         }
[10:58:47.783]                       }
[10:58:47.783]                       invisible(muffled)
[10:58:47.783]                     }
[10:58:47.783]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.783]                   }
[10:58:47.783]                 }
[10:58:47.783]             }
[10:58:47.783]         }))
[10:58:47.783]     }, error = function(ex) {
[10:58:47.783]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.783]                 ...future.rng), started = ...future.startTime, 
[10:58:47.783]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.783]             version = "1.8"), class = "FutureResult")
[10:58:47.783]     }, finally = {
[10:58:47.783]         if (!identical(...future.workdir, getwd())) 
[10:58:47.783]             setwd(...future.workdir)
[10:58:47.783]         {
[10:58:47.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.783]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.783]             }
[10:58:47.783]             base::options(...future.oldOptions)
[10:58:47.783]             if (.Platform$OS.type == "windows") {
[10:58:47.783]                 old_names <- names(...future.oldEnvVars)
[10:58:47.783]                 envs <- base::Sys.getenv()
[10:58:47.783]                 names <- names(envs)
[10:58:47.783]                 common <- intersect(names, old_names)
[10:58:47.783]                 added <- setdiff(names, old_names)
[10:58:47.783]                 removed <- setdiff(old_names, names)
[10:58:47.783]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.783]                   envs[common]]
[10:58:47.783]                 NAMES <- toupper(changed)
[10:58:47.783]                 args <- list()
[10:58:47.783]                 for (kk in seq_along(NAMES)) {
[10:58:47.783]                   name <- changed[[kk]]
[10:58:47.783]                   NAME <- NAMES[[kk]]
[10:58:47.783]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.783]                     next
[10:58:47.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.783]                 }
[10:58:47.783]                 NAMES <- toupper(added)
[10:58:47.783]                 for (kk in seq_along(NAMES)) {
[10:58:47.783]                   name <- added[[kk]]
[10:58:47.783]                   NAME <- NAMES[[kk]]
[10:58:47.783]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.783]                     next
[10:58:47.783]                   args[[name]] <- ""
[10:58:47.783]                 }
[10:58:47.783]                 NAMES <- toupper(removed)
[10:58:47.783]                 for (kk in seq_along(NAMES)) {
[10:58:47.783]                   name <- removed[[kk]]
[10:58:47.783]                   NAME <- NAMES[[kk]]
[10:58:47.783]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.783]                     next
[10:58:47.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.783]                 }
[10:58:47.783]                 if (length(args) > 0) 
[10:58:47.783]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.783]             }
[10:58:47.783]             else {
[10:58:47.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.783]             }
[10:58:47.783]             {
[10:58:47.783]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.783]                   0L) {
[10:58:47.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.783]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.783]                   base::options(opts)
[10:58:47.783]                 }
[10:58:47.783]                 {
[10:58:47.783]                   {
[10:58:47.783]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.783]                     NULL
[10:58:47.783]                   }
[10:58:47.783]                   options(future.plan = NULL)
[10:58:47.783]                   if (is.na(NA_character_)) 
[10:58:47.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.783]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.783]                     .init = FALSE)
[10:58:47.783]                 }
[10:58:47.783]             }
[10:58:47.783]         }
[10:58:47.783]     })
[10:58:47.783]     if (TRUE) {
[10:58:47.783]         base::sink(type = "output", split = FALSE)
[10:58:47.783]         if (TRUE) {
[10:58:47.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.783]         }
[10:58:47.783]         else {
[10:58:47.783]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.783]         }
[10:58:47.783]         base::close(...future.stdout)
[10:58:47.783]         ...future.stdout <- NULL
[10:58:47.783]     }
[10:58:47.783]     ...future.result$conditions <- ...future.conditions
[10:58:47.783]     ...future.result$finished <- base::Sys.time()
[10:58:47.783]     ...future.result
[10:58:47.783] }
[10:58:47.786] Exporting 5 global objects (1.14 KiB) to cluster node #2 ...
[10:58:47.786] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:58:47.786] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:58:47.786] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:47.787] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:47.787] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ...
[10:58:47.787] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ... DONE
[10:58:47.787] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:47.788] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.788] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:47.788] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.788] Exporting 5 global objects (1.14 KiB) to cluster node #2 ... DONE
[10:58:47.789] MultisessionFuture started
[10:58:47.789] - Launch lazy future ... done
[10:58:47.789] run() for ‘MultisessionFuture’ ... done
[10:58:47.789] Created future:
[10:58:47.789] MultisessionFuture:
[10:58:47.789] Label: ‘future_eapply-2’
[10:58:47.789] Expression:
[10:58:47.789] {
[10:58:47.789]     do.call(function(...) {
[10:58:47.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.789]             on.exit(options(oopts), add = TRUE)
[10:58:47.789]         }
[10:58:47.789]         {
[10:58:47.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.789]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.789]             })
[10:58:47.789]         }
[10:58:47.789]     }, args = future.call.arguments)
[10:58:47.789] }
[10:58:47.789] Lazy evaluation: FALSE
[10:58:47.789] Asynchronous evaluation: TRUE
[10:58:47.789] Local evaluation: TRUE
[10:58:47.789] Environment: R_GlobalEnv
[10:58:47.789] Capture standard output: TRUE
[10:58:47.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.789] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.789] Packages: 1 packages (‘stats’)
[10:58:47.789] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.789] Resolved: FALSE
[10:58:47.789] Value: <not collected>
[10:58:47.789] Conditions captured: <none>
[10:58:47.789] Early signaling: FALSE
[10:58:47.789] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.789] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.801] Chunk #2 of 2 ... DONE
[10:58:47.801] Launching 2 futures (chunks) ... DONE
[10:58:47.801] Resolving 2 futures (chunks) ...
[10:58:47.801] resolve() on list ...
[10:58:47.801]  recursive: 0
[10:58:47.806]  length: 2
[10:58:47.806] 
[10:58:47.806] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.806] - Validating connection of MultisessionFuture
[10:58:47.807] - received message: FutureResult
[10:58:47.807] - Received FutureResult
[10:58:47.807] - Erased future from FutureRegistry
[10:58:47.807] result() for ClusterFuture ...
[10:58:47.807] - result already collected: FutureResult
[10:58:47.807] result() for ClusterFuture ... done
[10:58:47.807] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.807] Future #1
[10:58:47.807] result() for ClusterFuture ...
[10:58:47.807] - result already collected: FutureResult
[10:58:47.807] result() for ClusterFuture ... done
[10:58:47.808] result() for ClusterFuture ...
[10:58:47.808] - result already collected: FutureResult
[10:58:47.808] result() for ClusterFuture ... done
[10:58:47.808] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:47.808] - nx: 2
[10:58:47.808] - relay: TRUE
[10:58:47.808] - stdout: TRUE
[10:58:47.808] - signal: TRUE
[10:58:47.808] - resignal: FALSE
[10:58:47.808] - force: TRUE
[10:58:47.808] - relayed: [n=2] FALSE, FALSE
[10:58:47.808] - queued futures: [n=2] FALSE, FALSE
[10:58:47.808]  - until=1
[10:58:47.809]  - relaying element #1
[10:58:47.809] result() for ClusterFuture ...
[10:58:47.809] - result already collected: FutureResult
[10:58:47.809] result() for ClusterFuture ... done
[10:58:47.809] result() for ClusterFuture ...
[10:58:47.809] - result already collected: FutureResult
[10:58:47.809] result() for ClusterFuture ... done
[10:58:47.809] result() for ClusterFuture ...
[10:58:47.809] - result already collected: FutureResult
[10:58:47.809] result() for ClusterFuture ... done
[10:58:47.809] result() for ClusterFuture ...
[10:58:47.809] - result already collected: FutureResult
[10:58:47.810] result() for ClusterFuture ... done
[10:58:47.810] - relayed: [n=2] TRUE, FALSE
[10:58:47.810] - queued futures: [n=2] TRUE, FALSE
[10:58:47.810] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:47.810]  length: 1 (resolved future 1)
[10:58:47.832] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.832] - Validating connection of MultisessionFuture
[10:58:47.832] - received message: FutureResult
[10:58:47.833] - Received FutureResult
[10:58:47.833] - Erased future from FutureRegistry
[10:58:47.833] result() for ClusterFuture ...
[10:58:47.833] - result already collected: FutureResult
[10:58:47.833] result() for ClusterFuture ... done
[10:58:47.833] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.833] Future #2
[10:58:47.833] result() for ClusterFuture ...
[10:58:47.833] - result already collected: FutureResult
[10:58:47.833] result() for ClusterFuture ... done
[10:58:47.833] result() for ClusterFuture ...
[10:58:47.834] - result already collected: FutureResult
[10:58:47.834] result() for ClusterFuture ... done
[10:58:47.834] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:47.834] - nx: 2
[10:58:47.834] - relay: TRUE
[10:58:47.834] - stdout: TRUE
[10:58:47.834] - signal: TRUE
[10:58:47.834] - resignal: FALSE
[10:58:47.834] - force: TRUE
[10:58:47.834] - relayed: [n=2] TRUE, FALSE
[10:58:47.834] - queued futures: [n=2] TRUE, FALSE
[10:58:47.834]  - until=2
[10:58:47.835]  - relaying element #2
[10:58:47.835] result() for ClusterFuture ...
[10:58:47.835] - result already collected: FutureResult
[10:58:47.835] result() for ClusterFuture ... done
[10:58:47.835] result() for ClusterFuture ...
[10:58:47.835] - result already collected: FutureResult
[10:58:47.835] result() for ClusterFuture ... done
[10:58:47.835] result() for ClusterFuture ...
[10:58:47.835] - result already collected: FutureResult
[10:58:47.835] result() for ClusterFuture ... done
[10:58:47.835] result() for ClusterFuture ...
[10:58:47.836] - result already collected: FutureResult
[10:58:47.836] result() for ClusterFuture ... done
[10:58:47.836] - relayed: [n=2] TRUE, TRUE
[10:58:47.836] - queued futures: [n=2] TRUE, TRUE
[10:58:47.836] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:47.836]  length: 0 (resolved future 2)
[10:58:47.836] Relaying remaining futures
[10:58:47.836] signalConditionsASAP(NULL, pos=0) ...
[10:58:47.836] - nx: 2
[10:58:47.836] - relay: TRUE
[10:58:47.836] - stdout: TRUE
[10:58:47.836] - signal: TRUE
[10:58:47.837] - resignal: FALSE
[10:58:47.837] - force: TRUE
[10:58:47.837] - relayed: [n=2] TRUE, TRUE
[10:58:47.837] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:47.837] - relayed: [n=2] TRUE, TRUE
[10:58:47.837] - queued futures: [n=2] TRUE, TRUE
[10:58:47.837] signalConditionsASAP(NULL, pos=0) ... done
[10:58:47.837] resolve() on list ... DONE
[10:58:47.837] result() for ClusterFuture ...
[10:58:47.837] - result already collected: FutureResult
[10:58:47.837] result() for ClusterFuture ... done
[10:58:47.837] result() for ClusterFuture ...
[10:58:47.838] - result already collected: FutureResult
[10:58:47.838] result() for ClusterFuture ... done
[10:58:47.838] result() for ClusterFuture ...
[10:58:47.838] - result already collected: FutureResult
[10:58:47.838] result() for ClusterFuture ... done
[10:58:47.838] result() for ClusterFuture ...
[10:58:47.838] - result already collected: FutureResult
[10:58:47.838] result() for ClusterFuture ... done
[10:58:47.838]  - Number of value chunks collected: 2
[10:58:47.838] Resolving 2 futures (chunks) ... DONE
[10:58:47.838] Reducing values from 2 chunks ...
[10:58:47.839]  - Number of values collected after concatenation: 3
[10:58:47.839]  - Number of values expected: 3
[10:58:47.839] Reducing values from 2 chunks ... DONE
[10:58:47.839] future_lapply() ... DONE
[10:58:47.839] future_lapply() ...
[10:58:47.841] Number of chunks: 2
[10:58:47.841] getGlobalsAndPackagesXApply() ...
[10:58:47.841]  - future.globals: TRUE
[10:58:47.841] getGlobalsAndPackages() ...
[10:58:47.842] Searching for globals...
[10:58:47.843] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:47.843] Searching for globals ... DONE
[10:58:47.843] Resolving globals: FALSE
[10:58:47.843] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:47.843] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:47.844] - globals: [1] ‘FUN’
[10:58:47.844] - packages: [1] ‘stats’
[10:58:47.844] getGlobalsAndPackages() ... DONE
[10:58:47.844]  - globals found/used: [n=1] ‘FUN’
[10:58:47.844]  - needed namespaces: [n=1] ‘stats’
[10:58:47.844] Finding globals ... DONE
[10:58:47.844]  - use_args: TRUE
[10:58:47.844]  - Getting '...' globals ...
[10:58:47.845] resolve() on list ...
[10:58:47.845]  recursive: 0
[10:58:47.845]  length: 1
[10:58:47.845]  elements: ‘...’
[10:58:47.845]  length: 0 (resolved future 1)
[10:58:47.845] resolve() on list ... DONE
[10:58:47.845]    - '...' content: [n=0] 
[10:58:47.845] List of 1
[10:58:47.845]  $ ...: list()
[10:58:47.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.845]  - attr(*, "where")=List of 1
[10:58:47.845]   ..$ ...:<environment: 0x55f48b1ce280> 
[10:58:47.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.845]  - attr(*, "resolved")= logi TRUE
[10:58:47.845]  - attr(*, "total_size")= num NA
[10:58:47.848]  - Getting '...' globals ... DONE
[10:58:47.848] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:47.848] List of 2
[10:58:47.848]  $ ...future.FUN:function (x, ...)  
[10:58:47.848]  $ ...          : list()
[10:58:47.848]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:47.848]  - attr(*, "where")=List of 2
[10:58:47.848]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:47.848]   ..$ ...          :<environment: 0x55f48b1ce280> 
[10:58:47.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:47.848]  - attr(*, "resolved")= logi FALSE
[10:58:47.848]  - attr(*, "total_size")= num 5437
[10:58:47.851] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:47.851] getGlobalsAndPackagesXApply() ... DONE
[10:58:47.851] Number of futures (= number of chunks): 2
[10:58:47.851] Launching 2 futures (chunks) ...
[10:58:47.851] Chunk #1 of 2 ...
[10:58:47.851]  - Finding globals in 'X' for chunk #1 ...
[10:58:47.851] getGlobalsAndPackages() ...
[10:58:47.851] Searching for globals...
[10:58:47.852] 
[10:58:47.852] Searching for globals ... DONE
[10:58:47.852] - globals: [0] <none>
[10:58:47.852] getGlobalsAndPackages() ... DONE
[10:58:47.852]    + additional globals found: [n=0] 
[10:58:47.852]    + additional namespaces needed: [n=0] 
[10:58:47.852]  - Finding globals in 'X' for chunk #1 ... DONE
[10:58:47.852]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.852]  - seeds: <none>
[10:58:47.852]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.852] getGlobalsAndPackages() ...
[10:58:47.853] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.853] Resolving globals: FALSE
[10:58:47.853] Tweak future expression to call with '...' arguments ...
[10:58:47.853] {
[10:58:47.853]     do.call(function(...) {
[10:58:47.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.853]             on.exit(options(oopts), add = TRUE)
[10:58:47.853]         }
[10:58:47.853]         {
[10:58:47.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.853]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.853]             })
[10:58:47.853]         }
[10:58:47.853]     }, args = future.call.arguments)
[10:58:47.853] }
[10:58:47.853] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.853] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.854] - packages: [1] ‘stats’
[10:58:47.854] getGlobalsAndPackages() ... DONE
[10:58:47.854] run() for ‘Future’ ...
[10:58:47.854] - state: ‘created’
[10:58:47.854] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.868] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.868]   - Field: ‘node’
[10:58:47.868]   - Field: ‘label’
[10:58:47.868]   - Field: ‘local’
[10:58:47.868]   - Field: ‘owner’
[10:58:47.868]   - Field: ‘envir’
[10:58:47.869]   - Field: ‘workers’
[10:58:47.869]   - Field: ‘packages’
[10:58:47.869]   - Field: ‘gc’
[10:58:47.869]   - Field: ‘conditions’
[10:58:47.869]   - Field: ‘persistent’
[10:58:47.869]   - Field: ‘expr’
[10:58:47.869]   - Field: ‘uuid’
[10:58:47.869]   - Field: ‘seed’
[10:58:47.869]   - Field: ‘version’
[10:58:47.869]   - Field: ‘result’
[10:58:47.869]   - Field: ‘asynchronous’
[10:58:47.869]   - Field: ‘calls’
[10:58:47.870]   - Field: ‘globals’
[10:58:47.870]   - Field: ‘stdout’
[10:58:47.870]   - Field: ‘earlySignal’
[10:58:47.870]   - Field: ‘lazy’
[10:58:47.870]   - Field: ‘state’
[10:58:47.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.870] - Launch lazy future ...
[10:58:47.870] Packages needed by the future expression (n = 1): ‘stats’
[10:58:47.870] Packages needed by future strategies (n = 0): <none>
[10:58:47.871] {
[10:58:47.871]     {
[10:58:47.871]         {
[10:58:47.871]             ...future.startTime <- base::Sys.time()
[10:58:47.871]             {
[10:58:47.871]                 {
[10:58:47.871]                   {
[10:58:47.871]                     {
[10:58:47.871]                       {
[10:58:47.871]                         base::local({
[10:58:47.871]                           has_future <- base::requireNamespace("future", 
[10:58:47.871]                             quietly = TRUE)
[10:58:47.871]                           if (has_future) {
[10:58:47.871]                             ns <- base::getNamespace("future")
[10:58:47.871]                             version <- ns[[".package"]][["version"]]
[10:58:47.871]                             if (is.null(version)) 
[10:58:47.871]                               version <- utils::packageVersion("future")
[10:58:47.871]                           }
[10:58:47.871]                           else {
[10:58:47.871]                             version <- NULL
[10:58:47.871]                           }
[10:58:47.871]                           if (!has_future || version < "1.8.0") {
[10:58:47.871]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.871]                               "", base::R.version$version.string), 
[10:58:47.871]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:47.871]                                 base::R.version$platform, 8 * 
[10:58:47.871]                                   base::.Machine$sizeof.pointer), 
[10:58:47.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.871]                                 "release", "version")], collapse = " "), 
[10:58:47.871]                               hostname = base::Sys.info()[["nodename"]])
[10:58:47.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.871]                               info)
[10:58:47.871]                             info <- base::paste(info, collapse = "; ")
[10:58:47.871]                             if (!has_future) {
[10:58:47.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.871]                                 info)
[10:58:47.871]                             }
[10:58:47.871]                             else {
[10:58:47.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.871]                                 info, version)
[10:58:47.871]                             }
[10:58:47.871]                             base::stop(msg)
[10:58:47.871]                           }
[10:58:47.871]                         })
[10:58:47.871]                       }
[10:58:47.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.871]                       base::options(mc.cores = 1L)
[10:58:47.871]                     }
[10:58:47.871]                     base::local({
[10:58:47.871]                       for (pkg in "stats") {
[10:58:47.871]                         base::loadNamespace(pkg)
[10:58:47.871]                         base::library(pkg, character.only = TRUE)
[10:58:47.871]                       }
[10:58:47.871]                     })
[10:58:47.871]                   }
[10:58:47.871]                   ...future.strategy.old <- future::plan("list")
[10:58:47.871]                   options(future.plan = NULL)
[10:58:47.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.871]                 }
[10:58:47.871]                 ...future.workdir <- getwd()
[10:58:47.871]             }
[10:58:47.871]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.871]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.871]         }
[10:58:47.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.871]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.871]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.871]             base::names(...future.oldOptions))
[10:58:47.871]     }
[10:58:47.871]     if (FALSE) {
[10:58:47.871]     }
[10:58:47.871]     else {
[10:58:47.871]         if (TRUE) {
[10:58:47.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.871]                 open = "w")
[10:58:47.871]         }
[10:58:47.871]         else {
[10:58:47.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.871]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.871]         }
[10:58:47.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.871]             base::sink(type = "output", split = FALSE)
[10:58:47.871]             base::close(...future.stdout)
[10:58:47.871]         }, add = TRUE)
[10:58:47.871]     }
[10:58:47.871]     ...future.frame <- base::sys.nframe()
[10:58:47.871]     ...future.conditions <- base::list()
[10:58:47.871]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.871]     if (FALSE) {
[10:58:47.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.871]     }
[10:58:47.871]     ...future.result <- base::tryCatch({
[10:58:47.871]         base::withCallingHandlers({
[10:58:47.871]             ...future.value <- base::withVisible(base::local({
[10:58:47.871]                 ...future.makeSendCondition <- base::local({
[10:58:47.871]                   sendCondition <- NULL
[10:58:47.871]                   function(frame = 1L) {
[10:58:47.871]                     if (is.function(sendCondition)) 
[10:58:47.871]                       return(sendCondition)
[10:58:47.871]                     ns <- getNamespace("parallel")
[10:58:47.871]                     if (exists("sendData", mode = "function", 
[10:58:47.871]                       envir = ns)) {
[10:58:47.871]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.871]                         envir = ns)
[10:58:47.871]                       envir <- sys.frame(frame)
[10:58:47.871]                       master <- NULL
[10:58:47.871]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.871]                         !identical(envir, emptyenv())) {
[10:58:47.871]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.871]                           inherits = FALSE)) {
[10:58:47.871]                           master <- get("master", mode = "list", 
[10:58:47.871]                             envir = envir, inherits = FALSE)
[10:58:47.871]                           if (inherits(master, c("SOCKnode", 
[10:58:47.871]                             "SOCK0node"))) {
[10:58:47.871]                             sendCondition <<- function(cond) {
[10:58:47.871]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.871]                                 success = TRUE)
[10:58:47.871]                               parallel_sendData(master, data)
[10:58:47.871]                             }
[10:58:47.871]                             return(sendCondition)
[10:58:47.871]                           }
[10:58:47.871]                         }
[10:58:47.871]                         frame <- frame + 1L
[10:58:47.871]                         envir <- sys.frame(frame)
[10:58:47.871]                       }
[10:58:47.871]                     }
[10:58:47.871]                     sendCondition <<- function(cond) NULL
[10:58:47.871]                   }
[10:58:47.871]                 })
[10:58:47.871]                 withCallingHandlers({
[10:58:47.871]                   {
[10:58:47.871]                     do.call(function(...) {
[10:58:47.871]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.871]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.871]                         ...future.globals.maxSize)) {
[10:58:47.871]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.871]                         on.exit(options(oopts), add = TRUE)
[10:58:47.871]                       }
[10:58:47.871]                       {
[10:58:47.871]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.871]                           FUN = function(jj) {
[10:58:47.871]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.871]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.871]                           })
[10:58:47.871]                       }
[10:58:47.871]                     }, args = future.call.arguments)
[10:58:47.871]                   }
[10:58:47.871]                 }, immediateCondition = function(cond) {
[10:58:47.871]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.871]                   sendCondition(cond)
[10:58:47.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.871]                   {
[10:58:47.871]                     inherits <- base::inherits
[10:58:47.871]                     invokeRestart <- base::invokeRestart
[10:58:47.871]                     is.null <- base::is.null
[10:58:47.871]                     muffled <- FALSE
[10:58:47.871]                     if (inherits(cond, "message")) {
[10:58:47.871]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.871]                       if (muffled) 
[10:58:47.871]                         invokeRestart("muffleMessage")
[10:58:47.871]                     }
[10:58:47.871]                     else if (inherits(cond, "warning")) {
[10:58:47.871]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.871]                       if (muffled) 
[10:58:47.871]                         invokeRestart("muffleWarning")
[10:58:47.871]                     }
[10:58:47.871]                     else if (inherits(cond, "condition")) {
[10:58:47.871]                       if (!is.null(pattern)) {
[10:58:47.871]                         computeRestarts <- base::computeRestarts
[10:58:47.871]                         grepl <- base::grepl
[10:58:47.871]                         restarts <- computeRestarts(cond)
[10:58:47.871]                         for (restart in restarts) {
[10:58:47.871]                           name <- restart$name
[10:58:47.871]                           if (is.null(name)) 
[10:58:47.871]                             next
[10:58:47.871]                           if (!grepl(pattern, name)) 
[10:58:47.871]                             next
[10:58:47.871]                           invokeRestart(restart)
[10:58:47.871]                           muffled <- TRUE
[10:58:47.871]                           break
[10:58:47.871]                         }
[10:58:47.871]                       }
[10:58:47.871]                     }
[10:58:47.871]                     invisible(muffled)
[10:58:47.871]                   }
[10:58:47.871]                   muffleCondition(cond)
[10:58:47.871]                 })
[10:58:47.871]             }))
[10:58:47.871]             future::FutureResult(value = ...future.value$value, 
[10:58:47.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.871]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.871]                     ...future.globalenv.names))
[10:58:47.871]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.871]         }, condition = base::local({
[10:58:47.871]             c <- base::c
[10:58:47.871]             inherits <- base::inherits
[10:58:47.871]             invokeRestart <- base::invokeRestart
[10:58:47.871]             length <- base::length
[10:58:47.871]             list <- base::list
[10:58:47.871]             seq.int <- base::seq.int
[10:58:47.871]             signalCondition <- base::signalCondition
[10:58:47.871]             sys.calls <- base::sys.calls
[10:58:47.871]             `[[` <- base::`[[`
[10:58:47.871]             `+` <- base::`+`
[10:58:47.871]             `<<-` <- base::`<<-`
[10:58:47.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.871]                   3L)]
[10:58:47.871]             }
[10:58:47.871]             function(cond) {
[10:58:47.871]                 is_error <- inherits(cond, "error")
[10:58:47.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.871]                   NULL)
[10:58:47.871]                 if (is_error) {
[10:58:47.871]                   sessionInformation <- function() {
[10:58:47.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.871]                       search = base::search(), system = base::Sys.info())
[10:58:47.871]                   }
[10:58:47.871]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.871]                     cond$call), session = sessionInformation(), 
[10:58:47.871]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.871]                   signalCondition(cond)
[10:58:47.871]                 }
[10:58:47.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.871]                 "immediateCondition"))) {
[10:58:47.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.871]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.871]                   if (TRUE && !signal) {
[10:58:47.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.871]                     {
[10:58:47.871]                       inherits <- base::inherits
[10:58:47.871]                       invokeRestart <- base::invokeRestart
[10:58:47.871]                       is.null <- base::is.null
[10:58:47.871]                       muffled <- FALSE
[10:58:47.871]                       if (inherits(cond, "message")) {
[10:58:47.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.871]                         if (muffled) 
[10:58:47.871]                           invokeRestart("muffleMessage")
[10:58:47.871]                       }
[10:58:47.871]                       else if (inherits(cond, "warning")) {
[10:58:47.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.871]                         if (muffled) 
[10:58:47.871]                           invokeRestart("muffleWarning")
[10:58:47.871]                       }
[10:58:47.871]                       else if (inherits(cond, "condition")) {
[10:58:47.871]                         if (!is.null(pattern)) {
[10:58:47.871]                           computeRestarts <- base::computeRestarts
[10:58:47.871]                           grepl <- base::grepl
[10:58:47.871]                           restarts <- computeRestarts(cond)
[10:58:47.871]                           for (restart in restarts) {
[10:58:47.871]                             name <- restart$name
[10:58:47.871]                             if (is.null(name)) 
[10:58:47.871]                               next
[10:58:47.871]                             if (!grepl(pattern, name)) 
[10:58:47.871]                               next
[10:58:47.871]                             invokeRestart(restart)
[10:58:47.871]                             muffled <- TRUE
[10:58:47.871]                             break
[10:58:47.871]                           }
[10:58:47.871]                         }
[10:58:47.871]                       }
[10:58:47.871]                       invisible(muffled)
[10:58:47.871]                     }
[10:58:47.871]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.871]                   }
[10:58:47.871]                 }
[10:58:47.871]                 else {
[10:58:47.871]                   if (TRUE) {
[10:58:47.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.871]                     {
[10:58:47.871]                       inherits <- base::inherits
[10:58:47.871]                       invokeRestart <- base::invokeRestart
[10:58:47.871]                       is.null <- base::is.null
[10:58:47.871]                       muffled <- FALSE
[10:58:47.871]                       if (inherits(cond, "message")) {
[10:58:47.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.871]                         if (muffled) 
[10:58:47.871]                           invokeRestart("muffleMessage")
[10:58:47.871]                       }
[10:58:47.871]                       else if (inherits(cond, "warning")) {
[10:58:47.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.871]                         if (muffled) 
[10:58:47.871]                           invokeRestart("muffleWarning")
[10:58:47.871]                       }
[10:58:47.871]                       else if (inherits(cond, "condition")) {
[10:58:47.871]                         if (!is.null(pattern)) {
[10:58:47.871]                           computeRestarts <- base::computeRestarts
[10:58:47.871]                           grepl <- base::grepl
[10:58:47.871]                           restarts <- computeRestarts(cond)
[10:58:47.871]                           for (restart in restarts) {
[10:58:47.871]                             name <- restart$name
[10:58:47.871]                             if (is.null(name)) 
[10:58:47.871]                               next
[10:58:47.871]                             if (!grepl(pattern, name)) 
[10:58:47.871]                               next
[10:58:47.871]                             invokeRestart(restart)
[10:58:47.871]                             muffled <- TRUE
[10:58:47.871]                             break
[10:58:47.871]                           }
[10:58:47.871]                         }
[10:58:47.871]                       }
[10:58:47.871]                       invisible(muffled)
[10:58:47.871]                     }
[10:58:47.871]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.871]                   }
[10:58:47.871]                 }
[10:58:47.871]             }
[10:58:47.871]         }))
[10:58:47.871]     }, error = function(ex) {
[10:58:47.871]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.871]                 ...future.rng), started = ...future.startTime, 
[10:58:47.871]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.871]             version = "1.8"), class = "FutureResult")
[10:58:47.871]     }, finally = {
[10:58:47.871]         if (!identical(...future.workdir, getwd())) 
[10:58:47.871]             setwd(...future.workdir)
[10:58:47.871]         {
[10:58:47.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.871]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.871]             }
[10:58:47.871]             base::options(...future.oldOptions)
[10:58:47.871]             if (.Platform$OS.type == "windows") {
[10:58:47.871]                 old_names <- names(...future.oldEnvVars)
[10:58:47.871]                 envs <- base::Sys.getenv()
[10:58:47.871]                 names <- names(envs)
[10:58:47.871]                 common <- intersect(names, old_names)
[10:58:47.871]                 added <- setdiff(names, old_names)
[10:58:47.871]                 removed <- setdiff(old_names, names)
[10:58:47.871]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.871]                   envs[common]]
[10:58:47.871]                 NAMES <- toupper(changed)
[10:58:47.871]                 args <- list()
[10:58:47.871]                 for (kk in seq_along(NAMES)) {
[10:58:47.871]                   name <- changed[[kk]]
[10:58:47.871]                   NAME <- NAMES[[kk]]
[10:58:47.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.871]                     next
[10:58:47.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.871]                 }
[10:58:47.871]                 NAMES <- toupper(added)
[10:58:47.871]                 for (kk in seq_along(NAMES)) {
[10:58:47.871]                   name <- added[[kk]]
[10:58:47.871]                   NAME <- NAMES[[kk]]
[10:58:47.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.871]                     next
[10:58:47.871]                   args[[name]] <- ""
[10:58:47.871]                 }
[10:58:47.871]                 NAMES <- toupper(removed)
[10:58:47.871]                 for (kk in seq_along(NAMES)) {
[10:58:47.871]                   name <- removed[[kk]]
[10:58:47.871]                   NAME <- NAMES[[kk]]
[10:58:47.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.871]                     next
[10:58:47.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.871]                 }
[10:58:47.871]                 if (length(args) > 0) 
[10:58:47.871]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.871]             }
[10:58:47.871]             else {
[10:58:47.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.871]             }
[10:58:47.871]             {
[10:58:47.871]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.871]                   0L) {
[10:58:47.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.871]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.871]                   base::options(opts)
[10:58:47.871]                 }
[10:58:47.871]                 {
[10:58:47.871]                   {
[10:58:47.871]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.871]                     NULL
[10:58:47.871]                   }
[10:58:47.871]                   options(future.plan = NULL)
[10:58:47.871]                   if (is.na(NA_character_)) 
[10:58:47.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.871]                     .init = FALSE)
[10:58:47.871]                 }
[10:58:47.871]             }
[10:58:47.871]         }
[10:58:47.871]     })
[10:58:47.871]     if (TRUE) {
[10:58:47.871]         base::sink(type = "output", split = FALSE)
[10:58:47.871]         if (TRUE) {
[10:58:47.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.871]         }
[10:58:47.871]         else {
[10:58:47.871]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.871]         }
[10:58:47.871]         base::close(...future.stdout)
[10:58:47.871]         ...future.stdout <- NULL
[10:58:47.871]     }
[10:58:47.871]     ...future.result$conditions <- ...future.conditions
[10:58:47.871]     ...future.result$finished <- base::Sys.time()
[10:58:47.871]     ...future.result
[10:58:47.871] }
[10:58:47.874] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[10:58:47.874] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:58:47.874] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:58:47.875] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:47.875] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:47.875] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ...
[10:58:47.875] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ... DONE
[10:58:47.876] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:47.876] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.876] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:58:47.876] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:58:47.877] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[10:58:47.877] MultisessionFuture started
[10:58:47.877] - Launch lazy future ... done
[10:58:47.877] run() for ‘MultisessionFuture’ ... done
[10:58:47.877] Created future:
[10:58:47.877] MultisessionFuture:
[10:58:47.877] Label: ‘future_eapply-1’
[10:58:47.877] Expression:
[10:58:47.877] {
[10:58:47.877]     do.call(function(...) {
[10:58:47.877]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.877]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.877]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.877]             on.exit(options(oopts), add = TRUE)
[10:58:47.877]         }
[10:58:47.877]         {
[10:58:47.877]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.877]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.877]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.877]             })
[10:58:47.877]         }
[10:58:47.877]     }, args = future.call.arguments)
[10:58:47.877] }
[10:58:47.877] Lazy evaluation: FALSE
[10:58:47.877] Asynchronous evaluation: TRUE
[10:58:47.877] Local evaluation: TRUE
[10:58:47.877] Environment: R_GlobalEnv
[10:58:47.877] Capture standard output: TRUE
[10:58:47.877] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.877] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.877] Packages: 1 packages (‘stats’)
[10:58:47.877] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.877] Resolved: FALSE
[10:58:47.877] Value: <not collected>
[10:58:47.877] Conditions captured: <none>
[10:58:47.877] Early signaling: FALSE
[10:58:47.877] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.877] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.889] Chunk #1 of 2 ... DONE
[10:58:47.889] Chunk #2 of 2 ...
[10:58:47.889]  - Finding globals in 'X' for chunk #2 ...
[10:58:47.889] getGlobalsAndPackages() ...
[10:58:47.889] Searching for globals...
[10:58:47.889] 
[10:58:47.889] Searching for globals ... DONE
[10:58:47.890] - globals: [0] <none>
[10:58:47.890] getGlobalsAndPackages() ... DONE
[10:58:47.890]    + additional globals found: [n=0] 
[10:58:47.890]    + additional namespaces needed: [n=0] 
[10:58:47.890]  - Finding globals in 'X' for chunk #2 ... DONE
[10:58:47.890]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:58:47.890]  - seeds: <none>
[10:58:47.890]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.890] getGlobalsAndPackages() ...
[10:58:47.890] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.890] Resolving globals: FALSE
[10:58:47.891] Tweak future expression to call with '...' arguments ...
[10:58:47.891] {
[10:58:47.891]     do.call(function(...) {
[10:58:47.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.891]             on.exit(options(oopts), add = TRUE)
[10:58:47.891]         }
[10:58:47.891]         {
[10:58:47.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.891]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.891]             })
[10:58:47.891]         }
[10:58:47.891]     }, args = future.call.arguments)
[10:58:47.891] }
[10:58:47.891] Tweak future expression to call with '...' arguments ... DONE
[10:58:47.891] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:47.891] - packages: [1] ‘stats’
[10:58:47.892] getGlobalsAndPackages() ... DONE
[10:58:47.892] run() for ‘Future’ ...
[10:58:47.892] - state: ‘created’
[10:58:47.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:47.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:47.906]   - Field: ‘node’
[10:58:47.906]   - Field: ‘label’
[10:58:47.906]   - Field: ‘local’
[10:58:47.906]   - Field: ‘owner’
[10:58:47.906]   - Field: ‘envir’
[10:58:47.906]   - Field: ‘workers’
[10:58:47.906]   - Field: ‘packages’
[10:58:47.906]   - Field: ‘gc’
[10:58:47.906]   - Field: ‘conditions’
[10:58:47.907]   - Field: ‘persistent’
[10:58:47.907]   - Field: ‘expr’
[10:58:47.907]   - Field: ‘uuid’
[10:58:47.907]   - Field: ‘seed’
[10:58:47.907]   - Field: ‘version’
[10:58:47.907]   - Field: ‘result’
[10:58:47.907]   - Field: ‘asynchronous’
[10:58:47.907]   - Field: ‘calls’
[10:58:47.907]   - Field: ‘globals’
[10:58:47.907]   - Field: ‘stdout’
[10:58:47.907]   - Field: ‘earlySignal’
[10:58:47.907]   - Field: ‘lazy’
[10:58:47.908]   - Field: ‘state’
[10:58:47.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:47.908] - Launch lazy future ...
[10:58:47.908] Packages needed by the future expression (n = 1): ‘stats’
[10:58:47.908] Packages needed by future strategies (n = 0): <none>
[10:58:47.909] {
[10:58:47.909]     {
[10:58:47.909]         {
[10:58:47.909]             ...future.startTime <- base::Sys.time()
[10:58:47.909]             {
[10:58:47.909]                 {
[10:58:47.909]                   {
[10:58:47.909]                     {
[10:58:47.909]                       {
[10:58:47.909]                         base::local({
[10:58:47.909]                           has_future <- base::requireNamespace("future", 
[10:58:47.909]                             quietly = TRUE)
[10:58:47.909]                           if (has_future) {
[10:58:47.909]                             ns <- base::getNamespace("future")
[10:58:47.909]                             version <- ns[[".package"]][["version"]]
[10:58:47.909]                             if (is.null(version)) 
[10:58:47.909]                               version <- utils::packageVersion("future")
[10:58:47.909]                           }
[10:58:47.909]                           else {
[10:58:47.909]                             version <- NULL
[10:58:47.909]                           }
[10:58:47.909]                           if (!has_future || version < "1.8.0") {
[10:58:47.909]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:47.909]                               "", base::R.version$version.string), 
[10:58:47.909]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:47.909]                                 base::R.version$platform, 8 * 
[10:58:47.909]                                   base::.Machine$sizeof.pointer), 
[10:58:47.909]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:47.909]                                 "release", "version")], collapse = " "), 
[10:58:47.909]                               hostname = base::Sys.info()[["nodename"]])
[10:58:47.909]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:47.909]                               info)
[10:58:47.909]                             info <- base::paste(info, collapse = "; ")
[10:58:47.909]                             if (!has_future) {
[10:58:47.909]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:47.909]                                 info)
[10:58:47.909]                             }
[10:58:47.909]                             else {
[10:58:47.909]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:47.909]                                 info, version)
[10:58:47.909]                             }
[10:58:47.909]                             base::stop(msg)
[10:58:47.909]                           }
[10:58:47.909]                         })
[10:58:47.909]                       }
[10:58:47.909]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:47.909]                       base::options(mc.cores = 1L)
[10:58:47.909]                     }
[10:58:47.909]                     base::local({
[10:58:47.909]                       for (pkg in "stats") {
[10:58:47.909]                         base::loadNamespace(pkg)
[10:58:47.909]                         base::library(pkg, character.only = TRUE)
[10:58:47.909]                       }
[10:58:47.909]                     })
[10:58:47.909]                   }
[10:58:47.909]                   ...future.strategy.old <- future::plan("list")
[10:58:47.909]                   options(future.plan = NULL)
[10:58:47.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:47.909]                 }
[10:58:47.909]                 ...future.workdir <- getwd()
[10:58:47.909]             }
[10:58:47.909]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:47.909]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:47.909]         }
[10:58:47.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:47.909]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:58:47.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:47.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:47.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:47.909]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:47.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:47.909]             base::names(...future.oldOptions))
[10:58:47.909]     }
[10:58:47.909]     if (FALSE) {
[10:58:47.909]     }
[10:58:47.909]     else {
[10:58:47.909]         if (TRUE) {
[10:58:47.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:47.909]                 open = "w")
[10:58:47.909]         }
[10:58:47.909]         else {
[10:58:47.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:47.909]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:47.909]         }
[10:58:47.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:47.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:47.909]             base::sink(type = "output", split = FALSE)
[10:58:47.909]             base::close(...future.stdout)
[10:58:47.909]         }, add = TRUE)
[10:58:47.909]     }
[10:58:47.909]     ...future.frame <- base::sys.nframe()
[10:58:47.909]     ...future.conditions <- base::list()
[10:58:47.909]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:47.909]     if (FALSE) {
[10:58:47.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:47.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:47.909]     }
[10:58:47.909]     ...future.result <- base::tryCatch({
[10:58:47.909]         base::withCallingHandlers({
[10:58:47.909]             ...future.value <- base::withVisible(base::local({
[10:58:47.909]                 ...future.makeSendCondition <- base::local({
[10:58:47.909]                   sendCondition <- NULL
[10:58:47.909]                   function(frame = 1L) {
[10:58:47.909]                     if (is.function(sendCondition)) 
[10:58:47.909]                       return(sendCondition)
[10:58:47.909]                     ns <- getNamespace("parallel")
[10:58:47.909]                     if (exists("sendData", mode = "function", 
[10:58:47.909]                       envir = ns)) {
[10:58:47.909]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:47.909]                         envir = ns)
[10:58:47.909]                       envir <- sys.frame(frame)
[10:58:47.909]                       master <- NULL
[10:58:47.909]                       while (!identical(envir, .GlobalEnv) && 
[10:58:47.909]                         !identical(envir, emptyenv())) {
[10:58:47.909]                         if (exists("master", mode = "list", envir = envir, 
[10:58:47.909]                           inherits = FALSE)) {
[10:58:47.909]                           master <- get("master", mode = "list", 
[10:58:47.909]                             envir = envir, inherits = FALSE)
[10:58:47.909]                           if (inherits(master, c("SOCKnode", 
[10:58:47.909]                             "SOCK0node"))) {
[10:58:47.909]                             sendCondition <<- function(cond) {
[10:58:47.909]                               data <- list(type = "VALUE", value = cond, 
[10:58:47.909]                                 success = TRUE)
[10:58:47.909]                               parallel_sendData(master, data)
[10:58:47.909]                             }
[10:58:47.909]                             return(sendCondition)
[10:58:47.909]                           }
[10:58:47.909]                         }
[10:58:47.909]                         frame <- frame + 1L
[10:58:47.909]                         envir <- sys.frame(frame)
[10:58:47.909]                       }
[10:58:47.909]                     }
[10:58:47.909]                     sendCondition <<- function(cond) NULL
[10:58:47.909]                   }
[10:58:47.909]                 })
[10:58:47.909]                 withCallingHandlers({
[10:58:47.909]                   {
[10:58:47.909]                     do.call(function(...) {
[10:58:47.909]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.909]                       if (!identical(...future.globals.maxSize.org, 
[10:58:47.909]                         ...future.globals.maxSize)) {
[10:58:47.909]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.909]                         on.exit(options(oopts), add = TRUE)
[10:58:47.909]                       }
[10:58:47.909]                       {
[10:58:47.909]                         lapply(seq_along(...future.elements_ii), 
[10:58:47.909]                           FUN = function(jj) {
[10:58:47.909]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.909]                             ...future.FUN(...future.X_jj, ...)
[10:58:47.909]                           })
[10:58:47.909]                       }
[10:58:47.909]                     }, args = future.call.arguments)
[10:58:47.909]                   }
[10:58:47.909]                 }, immediateCondition = function(cond) {
[10:58:47.909]                   sendCondition <- ...future.makeSendCondition()
[10:58:47.909]                   sendCondition(cond)
[10:58:47.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.909]                   {
[10:58:47.909]                     inherits <- base::inherits
[10:58:47.909]                     invokeRestart <- base::invokeRestart
[10:58:47.909]                     is.null <- base::is.null
[10:58:47.909]                     muffled <- FALSE
[10:58:47.909]                     if (inherits(cond, "message")) {
[10:58:47.909]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:47.909]                       if (muffled) 
[10:58:47.909]                         invokeRestart("muffleMessage")
[10:58:47.909]                     }
[10:58:47.909]                     else if (inherits(cond, "warning")) {
[10:58:47.909]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:47.909]                       if (muffled) 
[10:58:47.909]                         invokeRestart("muffleWarning")
[10:58:47.909]                     }
[10:58:47.909]                     else if (inherits(cond, "condition")) {
[10:58:47.909]                       if (!is.null(pattern)) {
[10:58:47.909]                         computeRestarts <- base::computeRestarts
[10:58:47.909]                         grepl <- base::grepl
[10:58:47.909]                         restarts <- computeRestarts(cond)
[10:58:47.909]                         for (restart in restarts) {
[10:58:47.909]                           name <- restart$name
[10:58:47.909]                           if (is.null(name)) 
[10:58:47.909]                             next
[10:58:47.909]                           if (!grepl(pattern, name)) 
[10:58:47.909]                             next
[10:58:47.909]                           invokeRestart(restart)
[10:58:47.909]                           muffled <- TRUE
[10:58:47.909]                           break
[10:58:47.909]                         }
[10:58:47.909]                       }
[10:58:47.909]                     }
[10:58:47.909]                     invisible(muffled)
[10:58:47.909]                   }
[10:58:47.909]                   muffleCondition(cond)
[10:58:47.909]                 })
[10:58:47.909]             }))
[10:58:47.909]             future::FutureResult(value = ...future.value$value, 
[10:58:47.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.909]                   ...future.rng), globalenv = if (FALSE) 
[10:58:47.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:47.909]                     ...future.globalenv.names))
[10:58:47.909]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:47.909]         }, condition = base::local({
[10:58:47.909]             c <- base::c
[10:58:47.909]             inherits <- base::inherits
[10:58:47.909]             invokeRestart <- base::invokeRestart
[10:58:47.909]             length <- base::length
[10:58:47.909]             list <- base::list
[10:58:47.909]             seq.int <- base::seq.int
[10:58:47.909]             signalCondition <- base::signalCondition
[10:58:47.909]             sys.calls <- base::sys.calls
[10:58:47.909]             `[[` <- base::`[[`
[10:58:47.909]             `+` <- base::`+`
[10:58:47.909]             `<<-` <- base::`<<-`
[10:58:47.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:47.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:47.909]                   3L)]
[10:58:47.909]             }
[10:58:47.909]             function(cond) {
[10:58:47.909]                 is_error <- inherits(cond, "error")
[10:58:47.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:47.909]                   NULL)
[10:58:47.909]                 if (is_error) {
[10:58:47.909]                   sessionInformation <- function() {
[10:58:47.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:47.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:47.909]                       search = base::search(), system = base::Sys.info())
[10:58:47.909]                   }
[10:58:47.909]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:47.909]                     cond$call), session = sessionInformation(), 
[10:58:47.909]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:47.909]                   signalCondition(cond)
[10:58:47.909]                 }
[10:58:47.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:47.909]                 "immediateCondition"))) {
[10:58:47.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:47.909]                   ...future.conditions[[length(...future.conditions) + 
[10:58:47.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:47.909]                   if (TRUE && !signal) {
[10:58:47.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.909]                     {
[10:58:47.909]                       inherits <- base::inherits
[10:58:47.909]                       invokeRestart <- base::invokeRestart
[10:58:47.909]                       is.null <- base::is.null
[10:58:47.909]                       muffled <- FALSE
[10:58:47.909]                       if (inherits(cond, "message")) {
[10:58:47.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.909]                         if (muffled) 
[10:58:47.909]                           invokeRestart("muffleMessage")
[10:58:47.909]                       }
[10:58:47.909]                       else if (inherits(cond, "warning")) {
[10:58:47.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.909]                         if (muffled) 
[10:58:47.909]                           invokeRestart("muffleWarning")
[10:58:47.909]                       }
[10:58:47.909]                       else if (inherits(cond, "condition")) {
[10:58:47.909]                         if (!is.null(pattern)) {
[10:58:47.909]                           computeRestarts <- base::computeRestarts
[10:58:47.909]                           grepl <- base::grepl
[10:58:47.909]                           restarts <- computeRestarts(cond)
[10:58:47.909]                           for (restart in restarts) {
[10:58:47.909]                             name <- restart$name
[10:58:47.909]                             if (is.null(name)) 
[10:58:47.909]                               next
[10:58:47.909]                             if (!grepl(pattern, name)) 
[10:58:47.909]                               next
[10:58:47.909]                             invokeRestart(restart)
[10:58:47.909]                             muffled <- TRUE
[10:58:47.909]                             break
[10:58:47.909]                           }
[10:58:47.909]                         }
[10:58:47.909]                       }
[10:58:47.909]                       invisible(muffled)
[10:58:47.909]                     }
[10:58:47.909]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.909]                   }
[10:58:47.909]                 }
[10:58:47.909]                 else {
[10:58:47.909]                   if (TRUE) {
[10:58:47.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:47.909]                     {
[10:58:47.909]                       inherits <- base::inherits
[10:58:47.909]                       invokeRestart <- base::invokeRestart
[10:58:47.909]                       is.null <- base::is.null
[10:58:47.909]                       muffled <- FALSE
[10:58:47.909]                       if (inherits(cond, "message")) {
[10:58:47.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:47.909]                         if (muffled) 
[10:58:47.909]                           invokeRestart("muffleMessage")
[10:58:47.909]                       }
[10:58:47.909]                       else if (inherits(cond, "warning")) {
[10:58:47.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:47.909]                         if (muffled) 
[10:58:47.909]                           invokeRestart("muffleWarning")
[10:58:47.909]                       }
[10:58:47.909]                       else if (inherits(cond, "condition")) {
[10:58:47.909]                         if (!is.null(pattern)) {
[10:58:47.909]                           computeRestarts <- base::computeRestarts
[10:58:47.909]                           grepl <- base::grepl
[10:58:47.909]                           restarts <- computeRestarts(cond)
[10:58:47.909]                           for (restart in restarts) {
[10:58:47.909]                             name <- restart$name
[10:58:47.909]                             if (is.null(name)) 
[10:58:47.909]                               next
[10:58:47.909]                             if (!grepl(pattern, name)) 
[10:58:47.909]                               next
[10:58:47.909]                             invokeRestart(restart)
[10:58:47.909]                             muffled <- TRUE
[10:58:47.909]                             break
[10:58:47.909]                           }
[10:58:47.909]                         }
[10:58:47.909]                       }
[10:58:47.909]                       invisible(muffled)
[10:58:47.909]                     }
[10:58:47.909]                     muffleCondition(cond, pattern = "^muffle")
[10:58:47.909]                   }
[10:58:47.909]                 }
[10:58:47.909]             }
[10:58:47.909]         }))
[10:58:47.909]     }, error = function(ex) {
[10:58:47.909]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:47.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:47.909]                 ...future.rng), started = ...future.startTime, 
[10:58:47.909]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:47.909]             version = "1.8"), class = "FutureResult")
[10:58:47.909]     }, finally = {
[10:58:47.909]         if (!identical(...future.workdir, getwd())) 
[10:58:47.909]             setwd(...future.workdir)
[10:58:47.909]         {
[10:58:47.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:47.909]                 ...future.oldOptions$nwarnings <- NULL
[10:58:47.909]             }
[10:58:47.909]             base::options(...future.oldOptions)
[10:58:47.909]             if (.Platform$OS.type == "windows") {
[10:58:47.909]                 old_names <- names(...future.oldEnvVars)
[10:58:47.909]                 envs <- base::Sys.getenv()
[10:58:47.909]                 names <- names(envs)
[10:58:47.909]                 common <- intersect(names, old_names)
[10:58:47.909]                 added <- setdiff(names, old_names)
[10:58:47.909]                 removed <- setdiff(old_names, names)
[10:58:47.909]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:47.909]                   envs[common]]
[10:58:47.909]                 NAMES <- toupper(changed)
[10:58:47.909]                 args <- list()
[10:58:47.909]                 for (kk in seq_along(NAMES)) {
[10:58:47.909]                   name <- changed[[kk]]
[10:58:47.909]                   NAME <- NAMES[[kk]]
[10:58:47.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.909]                     next
[10:58:47.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.909]                 }
[10:58:47.909]                 NAMES <- toupper(added)
[10:58:47.909]                 for (kk in seq_along(NAMES)) {
[10:58:47.909]                   name <- added[[kk]]
[10:58:47.909]                   NAME <- NAMES[[kk]]
[10:58:47.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.909]                     next
[10:58:47.909]                   args[[name]] <- ""
[10:58:47.909]                 }
[10:58:47.909]                 NAMES <- toupper(removed)
[10:58:47.909]                 for (kk in seq_along(NAMES)) {
[10:58:47.909]                   name <- removed[[kk]]
[10:58:47.909]                   NAME <- NAMES[[kk]]
[10:58:47.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:47.909]                     next
[10:58:47.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:47.909]                 }
[10:58:47.909]                 if (length(args) > 0) 
[10:58:47.909]                   base::do.call(base::Sys.setenv, args = args)
[10:58:47.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:47.909]             }
[10:58:47.909]             else {
[10:58:47.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:47.909]             }
[10:58:47.909]             {
[10:58:47.909]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:47.909]                   0L) {
[10:58:47.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:47.909]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:47.909]                   base::options(opts)
[10:58:47.909]                 }
[10:58:47.909]                 {
[10:58:47.909]                   {
[10:58:47.909]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:47.909]                     NULL
[10:58:47.909]                   }
[10:58:47.909]                   options(future.plan = NULL)
[10:58:47.909]                   if (is.na(NA_character_)) 
[10:58:47.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:47.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:47.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:47.909]                     .init = FALSE)
[10:58:47.909]                 }
[10:58:47.909]             }
[10:58:47.909]         }
[10:58:47.909]     })
[10:58:47.909]     if (TRUE) {
[10:58:47.909]         base::sink(type = "output", split = FALSE)
[10:58:47.909]         if (TRUE) {
[10:58:47.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:47.909]         }
[10:58:47.909]         else {
[10:58:47.909]             ...future.result["stdout"] <- base::list(NULL)
[10:58:47.909]         }
[10:58:47.909]         base::close(...future.stdout)
[10:58:47.909]         ...future.stdout <- NULL
[10:58:47.909]     }
[10:58:47.909]     ...future.result$conditions <- ...future.conditions
[10:58:47.909]     ...future.result$finished <- base::Sys.time()
[10:58:47.909]     ...future.result
[10:58:47.909] }
[10:58:47.911] Exporting 5 global objects (1.14 KiB) to cluster node #2 ...
[10:58:47.911] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:58:47.912] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:58:47.912] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:47.912] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:47.912] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ...
[10:58:47.913] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ... DONE
[10:58:47.913] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:47.913] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.913] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:58:47.914] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:58:47.914] Exporting 5 global objects (1.14 KiB) to cluster node #2 ... DONE
[10:58:47.914] MultisessionFuture started
[10:58:47.914] - Launch lazy future ... done
[10:58:47.914] run() for ‘MultisessionFuture’ ... done
[10:58:47.915] Created future:
[10:58:47.915] MultisessionFuture:
[10:58:47.915] Label: ‘future_eapply-2’
[10:58:47.915] Expression:
[10:58:47.915] {
[10:58:47.915]     do.call(function(...) {
[10:58:47.915]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:47.915]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:47.915]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:47.915]             on.exit(options(oopts), add = TRUE)
[10:58:47.915]         }
[10:58:47.915]         {
[10:58:47.915]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:47.915]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:47.915]                 ...future.FUN(...future.X_jj, ...)
[10:58:47.915]             })
[10:58:47.915]         }
[10:58:47.915]     }, args = future.call.arguments)
[10:58:47.915] }
[10:58:47.915] Lazy evaluation: FALSE
[10:58:47.915] Asynchronous evaluation: TRUE
[10:58:47.915] Local evaluation: TRUE
[10:58:47.915] Environment: R_GlobalEnv
[10:58:47.915] Capture standard output: TRUE
[10:58:47.915] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:47.915] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:58:47.915] Packages: 1 packages (‘stats’)
[10:58:47.915] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:47.915] Resolved: FALSE
[10:58:47.915] Value: <not collected>
[10:58:47.915] Conditions captured: <none>
[10:58:47.915] Early signaling: FALSE
[10:58:47.915] Owner process: e0bbc95b-1215-8967-664b-584ea0fd1c0d
[10:58:47.915] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:47.926] Chunk #2 of 2 ... DONE
[10:58:47.926] Launching 2 futures (chunks) ... DONE
[10:58:47.926] Resolving 2 futures (chunks) ...
[10:58:47.926] resolve() on list ...
[10:58:47.926]  recursive: 0
[10:58:47.926]  length: 2
[10:58:47.927] 
[10:58:47.927] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.927] - Validating connection of MultisessionFuture
[10:58:47.927] - received message: FutureResult
[10:58:47.927] - Received FutureResult
[10:58:47.928] - Erased future from FutureRegistry
[10:58:47.928] result() for ClusterFuture ...
[10:58:47.928] - result already collected: FutureResult
[10:58:47.928] result() for ClusterFuture ... done
[10:58:47.928] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.928] Future #1
[10:58:47.928] result() for ClusterFuture ...
[10:58:47.928] - result already collected: FutureResult
[10:58:47.928] result() for ClusterFuture ... done
[10:58:47.928] result() for ClusterFuture ...
[10:58:47.928] - result already collected: FutureResult
[10:58:47.928] result() for ClusterFuture ... done
[10:58:47.929] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:47.929] - nx: 2
[10:58:47.929] - relay: TRUE
[10:58:47.929] - stdout: TRUE
[10:58:47.929] - signal: TRUE
[10:58:47.929] - resignal: FALSE
[10:58:47.929] - force: TRUE
[10:58:47.929] - relayed: [n=2] FALSE, FALSE
[10:58:47.929] - queued futures: [n=2] FALSE, FALSE
[10:58:47.929]  - until=1
[10:58:47.929]  - relaying element #1
[10:58:47.929] result() for ClusterFuture ...
[10:58:47.930] - result already collected: FutureResult
[10:58:47.930] result() for ClusterFuture ... done
[10:58:47.930] result() for ClusterFuture ...
[10:58:47.930] - result already collected: FutureResult
[10:58:47.930] result() for ClusterFuture ... done
[10:58:47.930] result() for ClusterFuture ...
[10:58:47.930] - result already collected: FutureResult
[10:58:47.930] result() for ClusterFuture ... done
[10:58:47.930] result() for ClusterFuture ...
[10:58:47.930] - result already collected: FutureResult
[10:58:47.930] result() for ClusterFuture ... done
[10:58:47.930] - relayed: [n=2] TRUE, FALSE
[10:58:47.931] - queued futures: [n=2] TRUE, FALSE
[10:58:47.931] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:47.931]  length: 1 (resolved future 1)
[10:58:47.957] receiveMessageFromWorker() for ClusterFuture ...
[10:58:47.957] - Validating connection of MultisessionFuture
[10:58:47.957] - received message: FutureResult
[10:58:47.957] - Received FutureResult
[10:58:47.957] - Erased future from FutureRegistry
[10:58:47.957] result() for ClusterFuture ...
[10:58:47.957] - result already collected: FutureResult
[10:58:47.958] result() for ClusterFuture ... done
[10:58:47.958] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:47.958] Future #2
[10:58:47.958] result() for ClusterFuture ...
[10:58:47.958] - result already collected: FutureResult
[10:58:47.958] result() for ClusterFuture ... done
[10:58:47.958] result() for ClusterFuture ...
[10:58:47.958] - result already collected: FutureResult
[10:58:47.958] result() for ClusterFuture ... done
[10:58:47.958] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:47.958] - nx: 2
[10:58:47.959] - relay: TRUE
[10:58:47.959] - stdout: TRUE
[10:58:47.959] - signal: TRUE
[10:58:47.959] - resignal: FALSE
[10:58:47.959] - force: TRUE
[10:58:47.959] - relayed: [n=2] TRUE, FALSE
[10:58:47.959] - queued futures: [n=2] TRUE, FALSE
[10:58:47.959]  - until=2
[10:58:47.959]  - relaying element #2
[10:58:47.959] result() for ClusterFuture ...
[10:58:47.959] - result already collected: FutureResult
[10:58:47.959] result() for ClusterFuture ... done
[10:58:47.959] result() for ClusterFuture ...
[10:58:47.960] - result already collected: FutureResult
[10:58:47.960] result() for ClusterFuture ... done
[10:58:47.960] result() for ClusterFuture ...
[10:58:47.960] - result already collected: FutureResult
[10:58:47.960] result() for ClusterFuture ... done
[10:58:47.960] result() for ClusterFuture ...
[10:58:47.960] - result already collected: FutureResult
[10:58:47.960] result() for ClusterFuture ... done
[10:58:47.960] - relayed: [n=2] TRUE, TRUE
[10:58:47.960] - queued futures: [n=2] TRUE, TRUE
[10:58:47.960] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:47.961]  length: 0 (resolved future 2)
[10:58:47.961] Relaying remaining futures
[10:58:47.961] signalConditionsASAP(NULL, pos=0) ...
[10:58:47.961] - nx: 2
[10:58:47.961] - relay: TRUE
[10:58:47.961] - stdout: TRUE
[10:58:47.961] - signal: TRUE
[10:58:47.961] - resignal: FALSE
[10:58:47.961] - force: TRUE
[10:58:47.961] - relayed: [n=2] TRUE, TRUE
[10:58:47.961] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:47.961] - relayed: [n=2] TRUE, TRUE
[10:58:47.961] - queued futures: [n=2] TRUE, TRUE
[10:58:47.962] signalConditionsASAP(NULL, pos=0) ... done
[10:58:47.962] resolve() on list ... DONE
[10:58:47.962] result() for ClusterFuture ...
[10:58:47.962] - result already collected: FutureResult
[10:58:47.962] result() for ClusterFuture ... done
[10:58:47.962] result() for ClusterFuture ...
[10:58:47.962] - result already collected: FutureResult
[10:58:47.962] result() for ClusterFuture ... done
[10:58:47.962] result() for ClusterFuture ...
[10:58:47.962] - result already collected: FutureResult
[10:58:47.962] result() for ClusterFuture ... done
[10:58:47.962] result() for ClusterFuture ...
[10:58:47.963] - result already collected: FutureResult
[10:58:47.963] result() for ClusterFuture ... done
[10:58:47.963]  - Number of value chunks collected: 2
[10:58:47.963] Resolving 2 futures (chunks) ... DONE
[10:58:47.963] Reducing values from 2 chunks ...
[10:58:47.963]  - Number of values collected after concatenation: 3
[10:58:47.963]  - Number of values expected: 3
[10:58:47.963] Reducing values from 2 chunks ... DONE
[10:58:47.963] future_lapply() ... DONE
[10:58:47.964] plan(): Setting new future strategy stack:
[10:58:47.964] List of future strategies:
[10:58:47.964] 1. sequential:
[10:58:47.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:47.964]    - tweaked: FALSE
[10:58:47.964]    - call: plan(sequential)
[10:58:47.964] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[10:58:47.965] plan(): Setting new future strategy stack:
[10:58:47.966] List of future strategies:
[10:58:47.966] 1. FutureStrategy:
[10:58:47.966]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:47.966]    - tweaked: FALSE
[10:58:47.966]    - call: future::plan(oplan)
[10:58:47.966] plan(): nbrOfWorkers() = 1
> 
