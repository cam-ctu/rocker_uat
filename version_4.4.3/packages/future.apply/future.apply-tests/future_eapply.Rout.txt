
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:18:34.298] plan(): Setting new future strategy stack:
[10:18:34.299] List of future strategies:
[10:18:34.299] 1. sequential:
[10:18:34.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.299]    - tweaked: FALSE
[10:18:34.299]    - call: future::plan("sequential")
[10:18:34.313] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:18:34.340] plan(): Setting new future strategy stack:
[10:18:34.341] List of future strategies:
[10:18:34.341] 1. sequential:
[10:18:34.341]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.341]    - tweaked: FALSE
[10:18:34.341]    - call: plan(strategy)
[10:18:34.354] plan(): nbrOfWorkers() = 1
[10:18:34.354] future_lapply() ...
[10:18:34.358] Number of chunks: 1
[10:18:34.358] getGlobalsAndPackagesXApply() ...
[10:18:34.358]  - future.globals: TRUE
[10:18:34.359] getGlobalsAndPackages() ...
[10:18:34.359] Searching for globals...
[10:18:34.361] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.361] Searching for globals ... DONE
[10:18:34.361] Resolving globals: FALSE
[10:18:34.362] The total size of the 1 globals is 273 bytes (273 bytes)
[10:18:34.362] The total size of the 1 globals exported for future expression (‘FUN()’) is 273 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (273 bytes of class ‘function’)
[10:18:34.362] - globals: [1] ‘FUN’
[10:18:34.362] 
[10:18:34.362] getGlobalsAndPackages() ... DONE
[10:18:34.363]  - globals found/used: [n=1] ‘FUN’
[10:18:34.363]  - needed namespaces: [n=0] 
[10:18:34.363] Finding globals ... DONE
[10:18:34.363]  - use_args: TRUE
[10:18:34.363]  - Getting '...' globals ...
[10:18:34.364] resolve() on list ...
[10:18:34.364]  recursive: 0
[10:18:34.364]  length: 1
[10:18:34.364]  elements: ‘...’
[10:18:34.364]  length: 0 (resolved future 1)
[10:18:34.364] resolve() on list ... DONE
[10:18:34.364]    - '...' content: [n=0] 
[10:18:34.364] List of 1
[10:18:34.364]  $ ...: list()
[10:18:34.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.364]  - attr(*, "where")=List of 1
[10:18:34.364]   ..$ ...:<environment: 0x56033ac3bc90> 
[10:18:34.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.364]  - attr(*, "resolved")= logi TRUE
[10:18:34.364]  - attr(*, "total_size")= num NA
[10:18:34.368]  - Getting '...' globals ... DONE
[10:18:34.369] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.369] List of 2
[10:18:34.369]  $ ...future.FUN:function (x, ...)  
[10:18:34.369]  $ ...          : list()
[10:18:34.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.369]  - attr(*, "where")=List of 2
[10:18:34.369]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.369]   ..$ ...          :<environment: 0x56033ac3bc90> 
[10:18:34.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.369]  - attr(*, "resolved")= logi FALSE
[10:18:34.369]  - attr(*, "total_size")= num 5249
[10:18:34.371] Packages to be attached in all futures: [n=0] 
[10:18:34.371] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.372] Number of futures (= number of chunks): 1
[10:18:34.372] Launching 1 futures (chunks) ...
[10:18:34.372] Chunk #1 of 1 ...
[10:18:34.372]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.372] getGlobalsAndPackages() ...
[10:18:34.372] Searching for globals...
[10:18:34.373] 
[10:18:34.373] Searching for globals ... DONE
[10:18:34.373] - globals: [0] <none>
[10:18:34.373] getGlobalsAndPackages() ... DONE
[10:18:34.373]    + additional globals found: [n=0] 
[10:18:34.373]    + additional namespaces needed: [n=0] 
[10:18:34.373]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.373]  - seeds: <none>
[10:18:34.373]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.374] getGlobalsAndPackages() ...
[10:18:34.374] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.374] Resolving globals: FALSE
[10:18:34.374] Tweak future expression to call with '...' arguments ...
[10:18:34.374] {
[10:18:34.374]     do.call(function(...) {
[10:18:34.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.374]             on.exit(options(oopts), add = TRUE)
[10:18:34.374]         }
[10:18:34.374]         {
[10:18:34.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.374]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.374]             })
[10:18:34.374]         }
[10:18:34.374]     }, args = future.call.arguments)
[10:18:34.374] }
[10:18:34.374] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.375] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.375] 
[10:18:34.375] getGlobalsAndPackages() ... DONE
[10:18:34.375] run() for ‘Future’ ...
[10:18:34.375] - state: ‘created’
[10:18:34.376] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:34.376] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:34.376]   - Field: ‘label’
[10:18:34.376]   - Field: ‘local’
[10:18:34.376]   - Field: ‘owner’
[10:18:34.376]   - Field: ‘envir’
[10:18:34.377]   - Field: ‘packages’
[10:18:34.377]   - Field: ‘gc’
[10:18:34.377]   - Field: ‘conditions’
[10:18:34.377]   - Field: ‘expr’
[10:18:34.377]   - Field: ‘uuid’
[10:18:34.377]   - Field: ‘seed’
[10:18:34.377]   - Field: ‘version’
[10:18:34.377]   - Field: ‘result’
[10:18:34.377]   - Field: ‘asynchronous’
[10:18:34.377]   - Field: ‘calls’
[10:18:34.377]   - Field: ‘globals’
[10:18:34.377]   - Field: ‘stdout’
[10:18:34.378]   - Field: ‘earlySignal’
[10:18:34.380]   - Field: ‘lazy’
[10:18:34.380]   - Field: ‘state’
[10:18:34.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:34.380] - Launch lazy future ...
[10:18:34.381] Packages needed by the future expression (n = 0): <none>
[10:18:34.381] Packages needed by future strategies (n = 0): <none>
[10:18:34.382] {
[10:18:34.382]     {
[10:18:34.382]         {
[10:18:34.382]             ...future.startTime <- base::Sys.time()
[10:18:34.382]             {
[10:18:34.382]                 {
[10:18:34.382]                   {
[10:18:34.382]                     base::local({
[10:18:34.382]                       has_future <- base::requireNamespace("future", 
[10:18:34.382]                         quietly = TRUE)
[10:18:34.382]                       if (has_future) {
[10:18:34.382]                         ns <- base::getNamespace("future")
[10:18:34.382]                         version <- ns[[".package"]][["version"]]
[10:18:34.382]                         if (is.null(version)) 
[10:18:34.382]                           version <- utils::packageVersion("future")
[10:18:34.382]                       }
[10:18:34.382]                       else {
[10:18:34.382]                         version <- NULL
[10:18:34.382]                       }
[10:18:34.382]                       if (!has_future || version < "1.8.0") {
[10:18:34.382]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.382]                           "", base::R.version$version.string), 
[10:18:34.382]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:34.382]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:34.382]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.382]                             "release", "version")], collapse = " "), 
[10:18:34.382]                           hostname = base::Sys.info()[["nodename"]])
[10:18:34.382]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.382]                           info)
[10:18:34.382]                         info <- base::paste(info, collapse = "; ")
[10:18:34.382]                         if (!has_future) {
[10:18:34.382]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.382]                             info)
[10:18:34.382]                         }
[10:18:34.382]                         else {
[10:18:34.382]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.382]                             info, version)
[10:18:34.382]                         }
[10:18:34.382]                         base::stop(msg)
[10:18:34.382]                       }
[10:18:34.382]                     })
[10:18:34.382]                   }
[10:18:34.382]                   ...future.strategy.old <- future::plan("list")
[10:18:34.382]                   options(future.plan = NULL)
[10:18:34.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.382]                 }
[10:18:34.382]                 ...future.workdir <- getwd()
[10:18:34.382]             }
[10:18:34.382]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.382]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.382]         }
[10:18:34.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:34.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.382]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.382]             base::names(...future.oldOptions))
[10:18:34.382]     }
[10:18:34.382]     if (FALSE) {
[10:18:34.382]     }
[10:18:34.382]     else {
[10:18:34.382]         if (TRUE) {
[10:18:34.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.382]                 open = "w")
[10:18:34.382]         }
[10:18:34.382]         else {
[10:18:34.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.382]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.382]         }
[10:18:34.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.382]             base::sink(type = "output", split = FALSE)
[10:18:34.382]             base::close(...future.stdout)
[10:18:34.382]         }, add = TRUE)
[10:18:34.382]     }
[10:18:34.382]     ...future.frame <- base::sys.nframe()
[10:18:34.382]     ...future.conditions <- base::list()
[10:18:34.382]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.382]     if (FALSE) {
[10:18:34.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.382]     }
[10:18:34.382]     ...future.result <- base::tryCatch({
[10:18:34.382]         base::withCallingHandlers({
[10:18:34.382]             ...future.value <- base::withVisible(base::local({
[10:18:34.382]                 do.call(function(...) {
[10:18:34.382]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.382]                   if (!identical(...future.globals.maxSize.org, 
[10:18:34.382]                     ...future.globals.maxSize)) {
[10:18:34.382]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.382]                     on.exit(options(oopts), add = TRUE)
[10:18:34.382]                   }
[10:18:34.382]                   {
[10:18:34.382]                     lapply(seq_along(...future.elements_ii), 
[10:18:34.382]                       FUN = function(jj) {
[10:18:34.382]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.382]                         ...future.FUN(...future.X_jj, ...)
[10:18:34.382]                       })
[10:18:34.382]                   }
[10:18:34.382]                 }, args = future.call.arguments)
[10:18:34.382]             }))
[10:18:34.382]             future::FutureResult(value = ...future.value$value, 
[10:18:34.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.382]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.382]                     ...future.globalenv.names))
[10:18:34.382]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.382]         }, condition = base::local({
[10:18:34.382]             c <- base::c
[10:18:34.382]             inherits <- base::inherits
[10:18:34.382]             invokeRestart <- base::invokeRestart
[10:18:34.382]             length <- base::length
[10:18:34.382]             list <- base::list
[10:18:34.382]             seq.int <- base::seq.int
[10:18:34.382]             signalCondition <- base::signalCondition
[10:18:34.382]             sys.calls <- base::sys.calls
[10:18:34.382]             `[[` <- base::`[[`
[10:18:34.382]             `+` <- base::`+`
[10:18:34.382]             `<<-` <- base::`<<-`
[10:18:34.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.382]                   3L)]
[10:18:34.382]             }
[10:18:34.382]             function(cond) {
[10:18:34.382]                 is_error <- inherits(cond, "error")
[10:18:34.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.382]                   NULL)
[10:18:34.382]                 if (is_error) {
[10:18:34.382]                   sessionInformation <- function() {
[10:18:34.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.382]                       search = base::search(), system = base::Sys.info())
[10:18:34.382]                   }
[10:18:34.382]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.382]                     cond$call), session = sessionInformation(), 
[10:18:34.382]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.382]                   signalCondition(cond)
[10:18:34.382]                 }
[10:18:34.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.382]                 "immediateCondition"))) {
[10:18:34.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.382]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.382]                   if (TRUE && !signal) {
[10:18:34.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.382]                     {
[10:18:34.382]                       inherits <- base::inherits
[10:18:34.382]                       invokeRestart <- base::invokeRestart
[10:18:34.382]                       is.null <- base::is.null
[10:18:34.382]                       muffled <- FALSE
[10:18:34.382]                       if (inherits(cond, "message")) {
[10:18:34.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.382]                         if (muffled) 
[10:18:34.382]                           invokeRestart("muffleMessage")
[10:18:34.382]                       }
[10:18:34.382]                       else if (inherits(cond, "warning")) {
[10:18:34.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.382]                         if (muffled) 
[10:18:34.382]                           invokeRestart("muffleWarning")
[10:18:34.382]                       }
[10:18:34.382]                       else if (inherits(cond, "condition")) {
[10:18:34.382]                         if (!is.null(pattern)) {
[10:18:34.382]                           computeRestarts <- base::computeRestarts
[10:18:34.382]                           grepl <- base::grepl
[10:18:34.382]                           restarts <- computeRestarts(cond)
[10:18:34.382]                           for (restart in restarts) {
[10:18:34.382]                             name <- restart$name
[10:18:34.382]                             if (is.null(name)) 
[10:18:34.382]                               next
[10:18:34.382]                             if (!grepl(pattern, name)) 
[10:18:34.382]                               next
[10:18:34.382]                             invokeRestart(restart)
[10:18:34.382]                             muffled <- TRUE
[10:18:34.382]                             break
[10:18:34.382]                           }
[10:18:34.382]                         }
[10:18:34.382]                       }
[10:18:34.382]                       invisible(muffled)
[10:18:34.382]                     }
[10:18:34.382]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.382]                   }
[10:18:34.382]                 }
[10:18:34.382]                 else {
[10:18:34.382]                   if (TRUE) {
[10:18:34.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.382]                     {
[10:18:34.382]                       inherits <- base::inherits
[10:18:34.382]                       invokeRestart <- base::invokeRestart
[10:18:34.382]                       is.null <- base::is.null
[10:18:34.382]                       muffled <- FALSE
[10:18:34.382]                       if (inherits(cond, "message")) {
[10:18:34.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.382]                         if (muffled) 
[10:18:34.382]                           invokeRestart("muffleMessage")
[10:18:34.382]                       }
[10:18:34.382]                       else if (inherits(cond, "warning")) {
[10:18:34.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.382]                         if (muffled) 
[10:18:34.382]                           invokeRestart("muffleWarning")
[10:18:34.382]                       }
[10:18:34.382]                       else if (inherits(cond, "condition")) {
[10:18:34.382]                         if (!is.null(pattern)) {
[10:18:34.382]                           computeRestarts <- base::computeRestarts
[10:18:34.382]                           grepl <- base::grepl
[10:18:34.382]                           restarts <- computeRestarts(cond)
[10:18:34.382]                           for (restart in restarts) {
[10:18:34.382]                             name <- restart$name
[10:18:34.382]                             if (is.null(name)) 
[10:18:34.382]                               next
[10:18:34.382]                             if (!grepl(pattern, name)) 
[10:18:34.382]                               next
[10:18:34.382]                             invokeRestart(restart)
[10:18:34.382]                             muffled <- TRUE
[10:18:34.382]                             break
[10:18:34.382]                           }
[10:18:34.382]                         }
[10:18:34.382]                       }
[10:18:34.382]                       invisible(muffled)
[10:18:34.382]                     }
[10:18:34.382]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.382]                   }
[10:18:34.382]                 }
[10:18:34.382]             }
[10:18:34.382]         }))
[10:18:34.382]     }, error = function(ex) {
[10:18:34.382]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.382]                 ...future.rng), started = ...future.startTime, 
[10:18:34.382]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.382]             version = "1.8"), class = "FutureResult")
[10:18:34.382]     }, finally = {
[10:18:34.382]         if (!identical(...future.workdir, getwd())) 
[10:18:34.382]             setwd(...future.workdir)
[10:18:34.382]         {
[10:18:34.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.382]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.382]             }
[10:18:34.382]             base::options(...future.oldOptions)
[10:18:34.382]             if (.Platform$OS.type == "windows") {
[10:18:34.382]                 old_names <- names(...future.oldEnvVars)
[10:18:34.382]                 envs <- base::Sys.getenv()
[10:18:34.382]                 names <- names(envs)
[10:18:34.382]                 common <- intersect(names, old_names)
[10:18:34.382]                 added <- setdiff(names, old_names)
[10:18:34.382]                 removed <- setdiff(old_names, names)
[10:18:34.382]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.382]                   envs[common]]
[10:18:34.382]                 NAMES <- toupper(changed)
[10:18:34.382]                 args <- list()
[10:18:34.382]                 for (kk in seq_along(NAMES)) {
[10:18:34.382]                   name <- changed[[kk]]
[10:18:34.382]                   NAME <- NAMES[[kk]]
[10:18:34.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.382]                     next
[10:18:34.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.382]                 }
[10:18:34.382]                 NAMES <- toupper(added)
[10:18:34.382]                 for (kk in seq_along(NAMES)) {
[10:18:34.382]                   name <- added[[kk]]
[10:18:34.382]                   NAME <- NAMES[[kk]]
[10:18:34.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.382]                     next
[10:18:34.382]                   args[[name]] <- ""
[10:18:34.382]                 }
[10:18:34.382]                 NAMES <- toupper(removed)
[10:18:34.382]                 for (kk in seq_along(NAMES)) {
[10:18:34.382]                   name <- removed[[kk]]
[10:18:34.382]                   NAME <- NAMES[[kk]]
[10:18:34.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.382]                     next
[10:18:34.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.382]                 }
[10:18:34.382]                 if (length(args) > 0) 
[10:18:34.382]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.382]             }
[10:18:34.382]             else {
[10:18:34.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.382]             }
[10:18:34.382]             {
[10:18:34.382]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.382]                   0L) {
[10:18:34.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.382]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.382]                   base::options(opts)
[10:18:34.382]                 }
[10:18:34.382]                 {
[10:18:34.382]                   {
[10:18:34.382]                     NULL
[10:18:34.382]                     RNGkind("Mersenne-Twister")
[10:18:34.382]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:34.382]                       inherits = FALSE)
[10:18:34.382]                   }
[10:18:34.382]                   options(future.plan = NULL)
[10:18:34.382]                   if (is.na(NA_character_)) 
[10:18:34.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.382]                     .init = FALSE)
[10:18:34.382]                 }
[10:18:34.382]             }
[10:18:34.382]         }
[10:18:34.382]     })
[10:18:34.382]     if (TRUE) {
[10:18:34.382]         base::sink(type = "output", split = FALSE)
[10:18:34.382]         if (TRUE) {
[10:18:34.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.382]         }
[10:18:34.382]         else {
[10:18:34.382]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.382]         }
[10:18:34.382]         base::close(...future.stdout)
[10:18:34.382]         ...future.stdout <- NULL
[10:18:34.382]     }
[10:18:34.382]     ...future.result$conditions <- ...future.conditions
[10:18:34.382]     ...future.result$finished <- base::Sys.time()
[10:18:34.382]     ...future.result
[10:18:34.382] }
[10:18:34.384] assign_globals() ...
[10:18:34.384] List of 5
[10:18:34.384]  $ ...future.FUN            :function (x, ...)  
[10:18:34.384]  $ future.call.arguments    : list()
[10:18:34.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.384]  $ ...future.elements_ii    :List of 3
[10:18:34.384]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.384]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.384]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.384]  $ ...future.seeds_ii       : NULL
[10:18:34.384]  $ ...future.globals.maxSize: NULL
[10:18:34.384]  - attr(*, "where")=List of 5
[10:18:34.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.384]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.384]  - attr(*, "resolved")= logi FALSE
[10:18:34.384]  - attr(*, "total_size")= num 5249
[10:18:34.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.384]  - attr(*, "already-done")= logi TRUE
[10:18:34.389] - copied ‘...future.FUN’ to environment
[10:18:34.389] - copied ‘future.call.arguments’ to environment
[10:18:34.389] - copied ‘...future.elements_ii’ to environment
[10:18:34.389] - copied ‘...future.seeds_ii’ to environment
[10:18:34.389] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.389] assign_globals() ... done
[10:18:34.390] plan(): Setting new future strategy stack:
[10:18:34.390] List of future strategies:
[10:18:34.390] 1. sequential:
[10:18:34.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.390]    - tweaked: FALSE
[10:18:34.390]    - call: NULL
[10:18:34.390] plan(): nbrOfWorkers() = 1
[10:18:34.391] plan(): Setting new future strategy stack:
[10:18:34.392] List of future strategies:
[10:18:34.392] 1. sequential:
[10:18:34.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.392]    - tweaked: FALSE
[10:18:34.392]    - call: plan(strategy)
[10:18:34.392] plan(): nbrOfWorkers() = 1
[10:18:34.392] SequentialFuture started (and completed)
[10:18:34.393] - Launch lazy future ... done
[10:18:34.393] run() for ‘SequentialFuture’ ... done
[10:18:34.393] Created future:
[10:18:34.393] SequentialFuture:
[10:18:34.393] Label: ‘future_eapply-1’
[10:18:34.393] Expression:
[10:18:34.393] {
[10:18:34.393]     do.call(function(...) {
[10:18:34.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.393]             on.exit(options(oopts), add = TRUE)
[10:18:34.393]         }
[10:18:34.393]         {
[10:18:34.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.393]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.393]             })
[10:18:34.393]         }
[10:18:34.393]     }, args = future.call.arguments)
[10:18:34.393] }
[10:18:34.393] Lazy evaluation: FALSE
[10:18:34.393] Asynchronous evaluation: FALSE
[10:18:34.393] Local evaluation: TRUE
[10:18:34.393] Environment: R_GlobalEnv
[10:18:34.393] Capture standard output: TRUE
[10:18:34.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.393] Globals: 5 objects totaling 653 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 229 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.393] Packages: <none>
[10:18:34.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.393] Resolved: TRUE
[10:18:34.393] Value: 79 bytes of class ‘list’
[10:18:34.393] Early signaling: FALSE
[10:18:34.393] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.393] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.394] Chunk #1 of 1 ... DONE
[10:18:34.394] Launching 1 futures (chunks) ... DONE
[10:18:34.394] Resolving 1 futures (chunks) ...
[10:18:34.394] resolve() on list ...
[10:18:34.394]  recursive: 0
[10:18:34.395]  length: 1
[10:18:34.395] 
[10:18:34.395] resolved() for ‘SequentialFuture’ ...
[10:18:34.395] - state: ‘finished’
[10:18:34.395] - run: TRUE
[10:18:34.395] - result: ‘FutureResult’
[10:18:34.395] resolved() for ‘SequentialFuture’ ... done
[10:18:34.395] Future #1
[10:18:34.396] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:34.396] - nx: 1
[10:18:34.396] - relay: TRUE
[10:18:34.396] - stdout: TRUE
[10:18:34.396] - signal: TRUE
[10:18:34.396] - resignal: FALSE
[10:18:34.396] - force: TRUE
[10:18:34.396] - relayed: [n=1] FALSE
[10:18:34.396] - queued futures: [n=1] FALSE
[10:18:34.396]  - until=1
[10:18:34.396]  - relaying element #1
[10:18:34.397] - relayed: [n=1] TRUE
[10:18:34.397] - queued futures: [n=1] TRUE
[10:18:34.397] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:34.397]  length: 0 (resolved future 1)
[10:18:34.397] Relaying remaining futures
[10:18:34.397] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.397] - nx: 1
[10:18:34.397] - relay: TRUE
[10:18:34.397] - stdout: TRUE
[10:18:34.398] - signal: TRUE
[10:18:34.398] - resignal: FALSE
[10:18:34.398] - force: TRUE
[10:18:34.398] - relayed: [n=1] TRUE
[10:18:34.398] - queued futures: [n=1] TRUE
 - flush all
[10:18:34.398] - relayed: [n=1] TRUE
[10:18:34.398] - queued futures: [n=1] TRUE
[10:18:34.398] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.398] resolve() on list ... DONE
[10:18:34.398]  - Number of value chunks collected: 1
[10:18:34.398] Resolving 1 futures (chunks) ... DONE
[10:18:34.399] Reducing values from 1 chunks ...
[10:18:34.399]  - Number of values collected after concatenation: 3
[10:18:34.399]  - Number of values expected: 3
[10:18:34.399] Reducing values from 1 chunks ... DONE
[10:18:34.399] future_lapply() ... DONE
[10:18:34.401] future_lapply() ...
[10:18:34.401] Number of chunks: 1
[10:18:34.401] getGlobalsAndPackagesXApply() ...
[10:18:34.401]  - future.globals: TRUE
[10:18:34.401] getGlobalsAndPackages() ...
[10:18:34.402] Searching for globals...
[10:18:34.403] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.403] Searching for globals ... DONE
[10:18:34.403] Resolving globals: FALSE
[10:18:34.403] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:34.403] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:34.404] - globals: [1] ‘FUN’
[10:18:34.404] - packages: [1] ‘stats’
[10:18:34.404] getGlobalsAndPackages() ... DONE
[10:18:34.404]  - globals found/used: [n=1] ‘FUN’
[10:18:34.404]  - needed namespaces: [n=1] ‘stats’
[10:18:34.404] Finding globals ... DONE
[10:18:34.404]  - use_args: TRUE
[10:18:34.404]  - Getting '...' globals ...
[10:18:34.404] resolve() on list ...
[10:18:34.405]  recursive: 0
[10:18:34.405]  length: 1
[10:18:34.405]  elements: ‘...’
[10:18:34.405]  length: 0 (resolved future 1)
[10:18:34.405] resolve() on list ... DONE
[10:18:34.405]    - '...' content: [n=1] ‘probs’
[10:18:34.405] List of 1
[10:18:34.405]  $ ...:List of 1
[10:18:34.405]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:34.405]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.405]  - attr(*, "where")=List of 1
[10:18:34.405]   ..$ ...:<environment: 0x56033cbe8500> 
[10:18:34.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.405]  - attr(*, "resolved")= logi TRUE
[10:18:34.405]  - attr(*, "total_size")= num NA
[10:18:34.410]  - Getting '...' globals ... DONE
[10:18:34.410] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.410] List of 2
[10:18:34.410]  $ ...future.FUN:function (x, ...)  
[10:18:34.410]  $ ...          :List of 1
[10:18:34.410]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:34.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.410]  - attr(*, "where")=List of 2
[10:18:34.410]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.410]   ..$ ...          :<environment: 0x56033cbe8500> 
[10:18:34.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.410]  - attr(*, "resolved")= logi FALSE
[10:18:34.410]  - attr(*, "total_size")= num 6525
[10:18:34.413] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:34.413] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.413] Number of futures (= number of chunks): 1
[10:18:34.414] Launching 1 futures (chunks) ...
[10:18:34.414] Chunk #1 of 1 ...
[10:18:34.414]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.414] getGlobalsAndPackages() ...
[10:18:34.414] Searching for globals...
[10:18:34.414] 
[10:18:34.414] Searching for globals ... DONE
[10:18:34.414] - globals: [0] <none>
[10:18:34.415] getGlobalsAndPackages() ... DONE
[10:18:34.415]    + additional globals found: [n=0] 
[10:18:34.415]    + additional namespaces needed: [n=0] 
[10:18:34.415]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.415]  - seeds: <none>
[10:18:34.415]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.415] getGlobalsAndPackages() ...
[10:18:34.415] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.415] Resolving globals: FALSE
[10:18:34.415] Tweak future expression to call with '...' arguments ...
[10:18:34.415] {
[10:18:34.415]     do.call(function(...) {
[10:18:34.415]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.415]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.415]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.415]             on.exit(options(oopts), add = TRUE)
[10:18:34.415]         }
[10:18:34.415]         {
[10:18:34.415]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.415]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.415]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.415]             })
[10:18:34.415]         }
[10:18:34.415]     }, args = future.call.arguments)
[10:18:34.415] }
[10:18:34.416] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.416] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.416] - packages: [1] ‘stats’
[10:18:34.416] getGlobalsAndPackages() ... DONE
[10:18:34.417] run() for ‘Future’ ...
[10:18:34.417] - state: ‘created’
[10:18:34.417] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:34.417] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:34.417]   - Field: ‘label’
[10:18:34.417]   - Field: ‘local’
[10:18:34.417]   - Field: ‘owner’
[10:18:34.418]   - Field: ‘envir’
[10:18:34.418]   - Field: ‘packages’
[10:18:34.418]   - Field: ‘gc’
[10:18:34.418]   - Field: ‘conditions’
[10:18:34.418]   - Field: ‘expr’
[10:18:34.418]   - Field: ‘uuid’
[10:18:34.418]   - Field: ‘seed’
[10:18:34.418]   - Field: ‘version’
[10:18:34.418]   - Field: ‘result’
[10:18:34.418]   - Field: ‘asynchronous’
[10:18:34.418]   - Field: ‘calls’
[10:18:34.418]   - Field: ‘globals’
[10:18:34.419]   - Field: ‘stdout’
[10:18:34.419]   - Field: ‘earlySignal’
[10:18:34.419]   - Field: ‘lazy’
[10:18:34.419]   - Field: ‘state’
[10:18:34.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:34.419] - Launch lazy future ...
[10:18:34.419] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.419] Packages needed by future strategies (n = 0): <none>
[10:18:34.420] {
[10:18:34.420]     {
[10:18:34.420]         {
[10:18:34.420]             ...future.startTime <- base::Sys.time()
[10:18:34.420]             {
[10:18:34.420]                 {
[10:18:34.420]                   {
[10:18:34.420]                     {
[10:18:34.420]                       base::local({
[10:18:34.420]                         has_future <- base::requireNamespace("future", 
[10:18:34.420]                           quietly = TRUE)
[10:18:34.420]                         if (has_future) {
[10:18:34.420]                           ns <- base::getNamespace("future")
[10:18:34.420]                           version <- ns[[".package"]][["version"]]
[10:18:34.420]                           if (is.null(version)) 
[10:18:34.420]                             version <- utils::packageVersion("future")
[10:18:34.420]                         }
[10:18:34.420]                         else {
[10:18:34.420]                           version <- NULL
[10:18:34.420]                         }
[10:18:34.420]                         if (!has_future || version < "1.8.0") {
[10:18:34.420]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.420]                             "", base::R.version$version.string), 
[10:18:34.420]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:34.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:34.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.420]                               "release", "version")], collapse = " "), 
[10:18:34.420]                             hostname = base::Sys.info()[["nodename"]])
[10:18:34.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.420]                             info)
[10:18:34.420]                           info <- base::paste(info, collapse = "; ")
[10:18:34.420]                           if (!has_future) {
[10:18:34.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.420]                               info)
[10:18:34.420]                           }
[10:18:34.420]                           else {
[10:18:34.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.420]                               info, version)
[10:18:34.420]                           }
[10:18:34.420]                           base::stop(msg)
[10:18:34.420]                         }
[10:18:34.420]                       })
[10:18:34.420]                     }
[10:18:34.420]                     base::local({
[10:18:34.420]                       for (pkg in "stats") {
[10:18:34.420]                         base::loadNamespace(pkg)
[10:18:34.420]                         base::library(pkg, character.only = TRUE)
[10:18:34.420]                       }
[10:18:34.420]                     })
[10:18:34.420]                   }
[10:18:34.420]                   ...future.strategy.old <- future::plan("list")
[10:18:34.420]                   options(future.plan = NULL)
[10:18:34.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.420]                 }
[10:18:34.420]                 ...future.workdir <- getwd()
[10:18:34.420]             }
[10:18:34.420]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.420]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.420]         }
[10:18:34.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.420]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:34.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.420]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.420]             base::names(...future.oldOptions))
[10:18:34.420]     }
[10:18:34.420]     if (FALSE) {
[10:18:34.420]     }
[10:18:34.420]     else {
[10:18:34.420]         if (TRUE) {
[10:18:34.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.420]                 open = "w")
[10:18:34.420]         }
[10:18:34.420]         else {
[10:18:34.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.420]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.420]         }
[10:18:34.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.420]             base::sink(type = "output", split = FALSE)
[10:18:34.420]             base::close(...future.stdout)
[10:18:34.420]         }, add = TRUE)
[10:18:34.420]     }
[10:18:34.420]     ...future.frame <- base::sys.nframe()
[10:18:34.420]     ...future.conditions <- base::list()
[10:18:34.420]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.420]     if (FALSE) {
[10:18:34.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.420]     }
[10:18:34.420]     ...future.result <- base::tryCatch({
[10:18:34.420]         base::withCallingHandlers({
[10:18:34.420]             ...future.value <- base::withVisible(base::local({
[10:18:34.420]                 do.call(function(...) {
[10:18:34.420]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.420]                   if (!identical(...future.globals.maxSize.org, 
[10:18:34.420]                     ...future.globals.maxSize)) {
[10:18:34.420]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.420]                     on.exit(options(oopts), add = TRUE)
[10:18:34.420]                   }
[10:18:34.420]                   {
[10:18:34.420]                     lapply(seq_along(...future.elements_ii), 
[10:18:34.420]                       FUN = function(jj) {
[10:18:34.420]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.420]                         ...future.FUN(...future.X_jj, ...)
[10:18:34.420]                       })
[10:18:34.420]                   }
[10:18:34.420]                 }, args = future.call.arguments)
[10:18:34.420]             }))
[10:18:34.420]             future::FutureResult(value = ...future.value$value, 
[10:18:34.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.420]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.420]                     ...future.globalenv.names))
[10:18:34.420]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.420]         }, condition = base::local({
[10:18:34.420]             c <- base::c
[10:18:34.420]             inherits <- base::inherits
[10:18:34.420]             invokeRestart <- base::invokeRestart
[10:18:34.420]             length <- base::length
[10:18:34.420]             list <- base::list
[10:18:34.420]             seq.int <- base::seq.int
[10:18:34.420]             signalCondition <- base::signalCondition
[10:18:34.420]             sys.calls <- base::sys.calls
[10:18:34.420]             `[[` <- base::`[[`
[10:18:34.420]             `+` <- base::`+`
[10:18:34.420]             `<<-` <- base::`<<-`
[10:18:34.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.420]                   3L)]
[10:18:34.420]             }
[10:18:34.420]             function(cond) {
[10:18:34.420]                 is_error <- inherits(cond, "error")
[10:18:34.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.420]                   NULL)
[10:18:34.420]                 if (is_error) {
[10:18:34.420]                   sessionInformation <- function() {
[10:18:34.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.420]                       search = base::search(), system = base::Sys.info())
[10:18:34.420]                   }
[10:18:34.420]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.420]                     cond$call), session = sessionInformation(), 
[10:18:34.420]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.420]                   signalCondition(cond)
[10:18:34.420]                 }
[10:18:34.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.420]                 "immediateCondition"))) {
[10:18:34.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.420]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.420]                   if (TRUE && !signal) {
[10:18:34.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.420]                     {
[10:18:34.420]                       inherits <- base::inherits
[10:18:34.420]                       invokeRestart <- base::invokeRestart
[10:18:34.420]                       is.null <- base::is.null
[10:18:34.420]                       muffled <- FALSE
[10:18:34.420]                       if (inherits(cond, "message")) {
[10:18:34.420]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.420]                         if (muffled) 
[10:18:34.420]                           invokeRestart("muffleMessage")
[10:18:34.420]                       }
[10:18:34.420]                       else if (inherits(cond, "warning")) {
[10:18:34.420]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.420]                         if (muffled) 
[10:18:34.420]                           invokeRestart("muffleWarning")
[10:18:34.420]                       }
[10:18:34.420]                       else if (inherits(cond, "condition")) {
[10:18:34.420]                         if (!is.null(pattern)) {
[10:18:34.420]                           computeRestarts <- base::computeRestarts
[10:18:34.420]                           grepl <- base::grepl
[10:18:34.420]                           restarts <- computeRestarts(cond)
[10:18:34.420]                           for (restart in restarts) {
[10:18:34.420]                             name <- restart$name
[10:18:34.420]                             if (is.null(name)) 
[10:18:34.420]                               next
[10:18:34.420]                             if (!grepl(pattern, name)) 
[10:18:34.420]                               next
[10:18:34.420]                             invokeRestart(restart)
[10:18:34.420]                             muffled <- TRUE
[10:18:34.420]                             break
[10:18:34.420]                           }
[10:18:34.420]                         }
[10:18:34.420]                       }
[10:18:34.420]                       invisible(muffled)
[10:18:34.420]                     }
[10:18:34.420]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.420]                   }
[10:18:34.420]                 }
[10:18:34.420]                 else {
[10:18:34.420]                   if (TRUE) {
[10:18:34.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.420]                     {
[10:18:34.420]                       inherits <- base::inherits
[10:18:34.420]                       invokeRestart <- base::invokeRestart
[10:18:34.420]                       is.null <- base::is.null
[10:18:34.420]                       muffled <- FALSE
[10:18:34.420]                       if (inherits(cond, "message")) {
[10:18:34.420]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.420]                         if (muffled) 
[10:18:34.420]                           invokeRestart("muffleMessage")
[10:18:34.420]                       }
[10:18:34.420]                       else if (inherits(cond, "warning")) {
[10:18:34.420]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.420]                         if (muffled) 
[10:18:34.420]                           invokeRestart("muffleWarning")
[10:18:34.420]                       }
[10:18:34.420]                       else if (inherits(cond, "condition")) {
[10:18:34.420]                         if (!is.null(pattern)) {
[10:18:34.420]                           computeRestarts <- base::computeRestarts
[10:18:34.420]                           grepl <- base::grepl
[10:18:34.420]                           restarts <- computeRestarts(cond)
[10:18:34.420]                           for (restart in restarts) {
[10:18:34.420]                             name <- restart$name
[10:18:34.420]                             if (is.null(name)) 
[10:18:34.420]                               next
[10:18:34.420]                             if (!grepl(pattern, name)) 
[10:18:34.420]                               next
[10:18:34.420]                             invokeRestart(restart)
[10:18:34.420]                             muffled <- TRUE
[10:18:34.420]                             break
[10:18:34.420]                           }
[10:18:34.420]                         }
[10:18:34.420]                       }
[10:18:34.420]                       invisible(muffled)
[10:18:34.420]                     }
[10:18:34.420]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.420]                   }
[10:18:34.420]                 }
[10:18:34.420]             }
[10:18:34.420]         }))
[10:18:34.420]     }, error = function(ex) {
[10:18:34.420]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.420]                 ...future.rng), started = ...future.startTime, 
[10:18:34.420]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.420]             version = "1.8"), class = "FutureResult")
[10:18:34.420]     }, finally = {
[10:18:34.420]         if (!identical(...future.workdir, getwd())) 
[10:18:34.420]             setwd(...future.workdir)
[10:18:34.420]         {
[10:18:34.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.420]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.420]             }
[10:18:34.420]             base::options(...future.oldOptions)
[10:18:34.420]             if (.Platform$OS.type == "windows") {
[10:18:34.420]                 old_names <- names(...future.oldEnvVars)
[10:18:34.420]                 envs <- base::Sys.getenv()
[10:18:34.420]                 names <- names(envs)
[10:18:34.420]                 common <- intersect(names, old_names)
[10:18:34.420]                 added <- setdiff(names, old_names)
[10:18:34.420]                 removed <- setdiff(old_names, names)
[10:18:34.420]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.420]                   envs[common]]
[10:18:34.420]                 NAMES <- toupper(changed)
[10:18:34.420]                 args <- list()
[10:18:34.420]                 for (kk in seq_along(NAMES)) {
[10:18:34.420]                   name <- changed[[kk]]
[10:18:34.420]                   NAME <- NAMES[[kk]]
[10:18:34.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.420]                     next
[10:18:34.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.420]                 }
[10:18:34.420]                 NAMES <- toupper(added)
[10:18:34.420]                 for (kk in seq_along(NAMES)) {
[10:18:34.420]                   name <- added[[kk]]
[10:18:34.420]                   NAME <- NAMES[[kk]]
[10:18:34.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.420]                     next
[10:18:34.420]                   args[[name]] <- ""
[10:18:34.420]                 }
[10:18:34.420]                 NAMES <- toupper(removed)
[10:18:34.420]                 for (kk in seq_along(NAMES)) {
[10:18:34.420]                   name <- removed[[kk]]
[10:18:34.420]                   NAME <- NAMES[[kk]]
[10:18:34.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.420]                     next
[10:18:34.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.420]                 }
[10:18:34.420]                 if (length(args) > 0) 
[10:18:34.420]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.420]             }
[10:18:34.420]             else {
[10:18:34.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.420]             }
[10:18:34.420]             {
[10:18:34.420]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.420]                   0L) {
[10:18:34.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.420]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.420]                   base::options(opts)
[10:18:34.420]                 }
[10:18:34.420]                 {
[10:18:34.420]                   {
[10:18:34.420]                     NULL
[10:18:34.420]                     RNGkind("Mersenne-Twister")
[10:18:34.420]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:34.420]                       inherits = FALSE)
[10:18:34.420]                   }
[10:18:34.420]                   options(future.plan = NULL)
[10:18:34.420]                   if (is.na(NA_character_)) 
[10:18:34.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.420]                     .init = FALSE)
[10:18:34.420]                 }
[10:18:34.420]             }
[10:18:34.420]         }
[10:18:34.420]     })
[10:18:34.420]     if (TRUE) {
[10:18:34.420]         base::sink(type = "output", split = FALSE)
[10:18:34.420]         if (TRUE) {
[10:18:34.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.420]         }
[10:18:34.420]         else {
[10:18:34.420]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.420]         }
[10:18:34.420]         base::close(...future.stdout)
[10:18:34.420]         ...future.stdout <- NULL
[10:18:34.420]     }
[10:18:34.420]     ...future.result$conditions <- ...future.conditions
[10:18:34.420]     ...future.result$finished <- base::Sys.time()
[10:18:34.420]     ...future.result
[10:18:34.420] }
[10:18:34.422] assign_globals() ...
[10:18:34.422] List of 5
[10:18:34.422]  $ ...future.FUN            :function (x, ...)  
[10:18:34.422]  $ future.call.arguments    :List of 1
[10:18:34.422]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:34.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.422]  $ ...future.elements_ii    :List of 3
[10:18:34.422]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.422]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.422]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.422]  $ ...future.seeds_ii       : NULL
[10:18:34.422]  $ ...future.globals.maxSize: NULL
[10:18:34.422]  - attr(*, "where")=List of 5
[10:18:34.422]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.422]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.422]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.422]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.422]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.422]  - attr(*, "resolved")= logi FALSE
[10:18:34.422]  - attr(*, "total_size")= num 6525
[10:18:34.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.422]  - attr(*, "already-done")= logi TRUE
[10:18:34.427] - copied ‘...future.FUN’ to environment
[10:18:34.427] - copied ‘future.call.arguments’ to environment
[10:18:34.427] - copied ‘...future.elements_ii’ to environment
[10:18:34.427] - copied ‘...future.seeds_ii’ to environment
[10:18:34.427] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.428] assign_globals() ... done
[10:18:34.428] plan(): Setting new future strategy stack:
[10:18:34.428] List of future strategies:
[10:18:34.428] 1. sequential:
[10:18:34.428]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.428]    - tweaked: FALSE
[10:18:34.428]    - call: NULL
[10:18:34.428] plan(): nbrOfWorkers() = 1
[10:18:34.430] plan(): Setting new future strategy stack:
[10:18:34.430] List of future strategies:
[10:18:34.430] 1. sequential:
[10:18:34.430]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.430]    - tweaked: FALSE
[10:18:34.430]    - call: plan(strategy)
[10:18:34.430] plan(): nbrOfWorkers() = 1
[10:18:34.430] SequentialFuture started (and completed)
[10:18:34.430] - Launch lazy future ... done
[10:18:34.431] run() for ‘SequentialFuture’ ... done
[10:18:34.431] Created future:
[10:18:34.431] SequentialFuture:
[10:18:34.431] Label: ‘future_eapply-1’
[10:18:34.431] Expression:
[10:18:34.431] {
[10:18:34.431]     do.call(function(...) {
[10:18:34.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.431]             on.exit(options(oopts), add = TRUE)
[10:18:34.431]         }
[10:18:34.431]         {
[10:18:34.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.431]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.431]             })
[10:18:34.431]         }
[10:18:34.431]     }, args = future.call.arguments)
[10:18:34.431] }
[10:18:34.431] Lazy evaluation: FALSE
[10:18:34.431] Asynchronous evaluation: FALSE
[10:18:34.431] Local evaluation: TRUE
[10:18:34.431] Environment: R_GlobalEnv
[10:18:34.431] Capture standard output: TRUE
[10:18:34.431] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.431] Globals: 5 objects totaling 832 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 296 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.431] Packages: 1 packages (‘stats’)
[10:18:34.431] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.431] Resolved: TRUE
[10:18:34.431] Value: 299 bytes of class ‘list’
[10:18:34.431] Early signaling: FALSE
[10:18:34.431] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.431] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.432] Chunk #1 of 1 ... DONE
[10:18:34.432] Launching 1 futures (chunks) ... DONE
[10:18:34.432] Resolving 1 futures (chunks) ...
[10:18:34.432] resolve() on list ...
[10:18:34.432]  recursive: 0
[10:18:34.432]  length: 1
[10:18:34.432] 
[10:18:34.432] resolved() for ‘SequentialFuture’ ...
[10:18:34.432] - state: ‘finished’
[10:18:34.432] - run: TRUE
[10:18:34.432] - result: ‘FutureResult’
[10:18:34.433] resolved() for ‘SequentialFuture’ ... done
[10:18:34.433] Future #1
[10:18:34.433] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:34.433] - nx: 1
[10:18:34.433] - relay: TRUE
[10:18:34.433] - stdout: TRUE
[10:18:34.433] - signal: TRUE
[10:18:34.433] - resignal: FALSE
[10:18:34.433] - force: TRUE
[10:18:34.433] - relayed: [n=1] FALSE
[10:18:34.433] - queued futures: [n=1] FALSE
[10:18:34.434]  - until=1
[10:18:34.434]  - relaying element #1
[10:18:34.435] - relayed: [n=1] TRUE
[10:18:34.435] - queued futures: [n=1] TRUE
[10:18:34.436] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:34.436]  length: 0 (resolved future 1)
[10:18:34.436] Relaying remaining futures
[10:18:34.436] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.436] - nx: 1
[10:18:34.436] - relay: TRUE
[10:18:34.436] - stdout: TRUE
[10:18:34.436] - signal: TRUE
[10:18:34.436] - resignal: FALSE
[10:18:34.436] - force: TRUE
[10:18:34.436] - relayed: [n=1] TRUE
[10:18:34.436] - queued futures: [n=1] TRUE
 - flush all
[10:18:34.437] - relayed: [n=1] TRUE
[10:18:34.437] - queued futures: [n=1] TRUE
[10:18:34.437] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.437] resolve() on list ... DONE
[10:18:34.437]  - Number of value chunks collected: 1
[10:18:34.437] Resolving 1 futures (chunks) ... DONE
[10:18:34.437] Reducing values from 1 chunks ...
[10:18:34.437]  - Number of values collected after concatenation: 3
[10:18:34.437]  - Number of values expected: 3
[10:18:34.437] Reducing values from 1 chunks ... DONE
[10:18:34.437] future_lapply() ... DONE
[10:18:34.439] future_lapply() ...
[10:18:34.439] Number of chunks: 1
[10:18:34.439] getGlobalsAndPackagesXApply() ...
[10:18:34.439]  - future.globals: TRUE
[10:18:34.439] getGlobalsAndPackages() ...
[10:18:34.440] Searching for globals...
[10:18:34.441] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.441] Searching for globals ... DONE
[10:18:34.441] Resolving globals: FALSE
[10:18:34.441] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:34.441] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:34.442] - globals: [1] ‘FUN’
[10:18:34.442] - packages: [1] ‘stats’
[10:18:34.442] getGlobalsAndPackages() ... DONE
[10:18:34.442]  - globals found/used: [n=1] ‘FUN’
[10:18:34.442]  - needed namespaces: [n=1] ‘stats’
[10:18:34.442] Finding globals ... DONE
[10:18:34.442]  - use_args: TRUE
[10:18:34.442]  - Getting '...' globals ...
[10:18:34.443] resolve() on list ...
[10:18:34.443]  recursive: 0
[10:18:34.443]  length: 1
[10:18:34.443]  elements: ‘...’
[10:18:34.443]  length: 0 (resolved future 1)
[10:18:34.443] resolve() on list ... DONE
[10:18:34.443]    - '...' content: [n=0] 
[10:18:34.443] List of 1
[10:18:34.443]  $ ...: list()
[10:18:34.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.443]  - attr(*, "where")=List of 1
[10:18:34.443]   ..$ ...:<environment: 0x56033b043dd0> 
[10:18:34.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.443]  - attr(*, "resolved")= logi TRUE
[10:18:34.443]  - attr(*, "total_size")= num NA
[10:18:34.446]  - Getting '...' globals ... DONE
[10:18:34.446] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.446] List of 2
[10:18:34.446]  $ ...future.FUN:function (x, ...)  
[10:18:34.446]  $ ...          : list()
[10:18:34.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.446]  - attr(*, "where")=List of 2
[10:18:34.446]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.446]   ..$ ...          :<environment: 0x56033b043dd0> 
[10:18:34.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.446]  - attr(*, "resolved")= logi FALSE
[10:18:34.446]  - attr(*, "total_size")= num 5433
[10:18:34.448] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:34.448] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.449] Number of futures (= number of chunks): 1
[10:18:34.449] Launching 1 futures (chunks) ...
[10:18:34.449] Chunk #1 of 1 ...
[10:18:34.449]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.449] getGlobalsAndPackages() ...
[10:18:34.449] Searching for globals...
[10:18:34.449] 
[10:18:34.449] Searching for globals ... DONE
[10:18:34.450] - globals: [0] <none>
[10:18:34.450] getGlobalsAndPackages() ... DONE
[10:18:34.450]    + additional globals found: [n=0] 
[10:18:34.450]    + additional namespaces needed: [n=0] 
[10:18:34.450]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.450]  - seeds: <none>
[10:18:34.450]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.450] getGlobalsAndPackages() ...
[10:18:34.450] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.450] Resolving globals: FALSE
[10:18:34.450] Tweak future expression to call with '...' arguments ...
[10:18:34.451] {
[10:18:34.451]     do.call(function(...) {
[10:18:34.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.451]             on.exit(options(oopts), add = TRUE)
[10:18:34.451]         }
[10:18:34.451]         {
[10:18:34.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.451]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.451]             })
[10:18:34.451]         }
[10:18:34.451]     }, args = future.call.arguments)
[10:18:34.451] }
[10:18:34.451] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.451] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.451] - packages: [1] ‘stats’
[10:18:34.451] getGlobalsAndPackages() ... DONE
[10:18:34.452] run() for ‘Future’ ...
[10:18:34.452] - state: ‘created’
[10:18:34.452] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:34.452] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:34.452]   - Field: ‘label’
[10:18:34.452]   - Field: ‘local’
[10:18:34.453]   - Field: ‘owner’
[10:18:34.453]   - Field: ‘envir’
[10:18:34.453]   - Field: ‘packages’
[10:18:34.453]   - Field: ‘gc’
[10:18:34.453]   - Field: ‘conditions’
[10:18:34.453]   - Field: ‘expr’
[10:18:34.453]   - Field: ‘uuid’
[10:18:34.453]   - Field: ‘seed’
[10:18:34.453]   - Field: ‘version’
[10:18:34.453]   - Field: ‘result’
[10:18:34.453]   - Field: ‘asynchronous’
[10:18:34.454]   - Field: ‘calls’
[10:18:34.454]   - Field: ‘globals’
[10:18:34.454]   - Field: ‘stdout’
[10:18:34.454]   - Field: ‘earlySignal’
[10:18:34.454]   - Field: ‘lazy’
[10:18:34.454]   - Field: ‘state’
[10:18:34.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:34.454] - Launch lazy future ...
[10:18:34.454] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.454] Packages needed by future strategies (n = 0): <none>
[10:18:34.455] {
[10:18:34.455]     {
[10:18:34.455]         {
[10:18:34.455]             ...future.startTime <- base::Sys.time()
[10:18:34.455]             {
[10:18:34.455]                 {
[10:18:34.455]                   {
[10:18:34.455]                     {
[10:18:34.455]                       base::local({
[10:18:34.455]                         has_future <- base::requireNamespace("future", 
[10:18:34.455]                           quietly = TRUE)
[10:18:34.455]                         if (has_future) {
[10:18:34.455]                           ns <- base::getNamespace("future")
[10:18:34.455]                           version <- ns[[".package"]][["version"]]
[10:18:34.455]                           if (is.null(version)) 
[10:18:34.455]                             version <- utils::packageVersion("future")
[10:18:34.455]                         }
[10:18:34.455]                         else {
[10:18:34.455]                           version <- NULL
[10:18:34.455]                         }
[10:18:34.455]                         if (!has_future || version < "1.8.0") {
[10:18:34.455]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.455]                             "", base::R.version$version.string), 
[10:18:34.455]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:34.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:34.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.455]                               "release", "version")], collapse = " "), 
[10:18:34.455]                             hostname = base::Sys.info()[["nodename"]])
[10:18:34.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.455]                             info)
[10:18:34.455]                           info <- base::paste(info, collapse = "; ")
[10:18:34.455]                           if (!has_future) {
[10:18:34.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.455]                               info)
[10:18:34.455]                           }
[10:18:34.455]                           else {
[10:18:34.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.455]                               info, version)
[10:18:34.455]                           }
[10:18:34.455]                           base::stop(msg)
[10:18:34.455]                         }
[10:18:34.455]                       })
[10:18:34.455]                     }
[10:18:34.455]                     base::local({
[10:18:34.455]                       for (pkg in "stats") {
[10:18:34.455]                         base::loadNamespace(pkg)
[10:18:34.455]                         base::library(pkg, character.only = TRUE)
[10:18:34.455]                       }
[10:18:34.455]                     })
[10:18:34.455]                   }
[10:18:34.455]                   ...future.strategy.old <- future::plan("list")
[10:18:34.455]                   options(future.plan = NULL)
[10:18:34.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.455]                 }
[10:18:34.455]                 ...future.workdir <- getwd()
[10:18:34.455]             }
[10:18:34.455]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.455]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.455]         }
[10:18:34.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:34.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.455]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.455]             base::names(...future.oldOptions))
[10:18:34.455]     }
[10:18:34.455]     if (FALSE) {
[10:18:34.455]     }
[10:18:34.455]     else {
[10:18:34.455]         if (TRUE) {
[10:18:34.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.455]                 open = "w")
[10:18:34.455]         }
[10:18:34.455]         else {
[10:18:34.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.455]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.455]         }
[10:18:34.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.455]             base::sink(type = "output", split = FALSE)
[10:18:34.455]             base::close(...future.stdout)
[10:18:34.455]         }, add = TRUE)
[10:18:34.455]     }
[10:18:34.455]     ...future.frame <- base::sys.nframe()
[10:18:34.455]     ...future.conditions <- base::list()
[10:18:34.455]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.455]     if (FALSE) {
[10:18:34.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.455]     }
[10:18:34.455]     ...future.result <- base::tryCatch({
[10:18:34.455]         base::withCallingHandlers({
[10:18:34.455]             ...future.value <- base::withVisible(base::local({
[10:18:34.455]                 do.call(function(...) {
[10:18:34.455]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.455]                   if (!identical(...future.globals.maxSize.org, 
[10:18:34.455]                     ...future.globals.maxSize)) {
[10:18:34.455]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.455]                     on.exit(options(oopts), add = TRUE)
[10:18:34.455]                   }
[10:18:34.455]                   {
[10:18:34.455]                     lapply(seq_along(...future.elements_ii), 
[10:18:34.455]                       FUN = function(jj) {
[10:18:34.455]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.455]                         ...future.FUN(...future.X_jj, ...)
[10:18:34.455]                       })
[10:18:34.455]                   }
[10:18:34.455]                 }, args = future.call.arguments)
[10:18:34.455]             }))
[10:18:34.455]             future::FutureResult(value = ...future.value$value, 
[10:18:34.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.455]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.455]                     ...future.globalenv.names))
[10:18:34.455]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.455]         }, condition = base::local({
[10:18:34.455]             c <- base::c
[10:18:34.455]             inherits <- base::inherits
[10:18:34.455]             invokeRestart <- base::invokeRestart
[10:18:34.455]             length <- base::length
[10:18:34.455]             list <- base::list
[10:18:34.455]             seq.int <- base::seq.int
[10:18:34.455]             signalCondition <- base::signalCondition
[10:18:34.455]             sys.calls <- base::sys.calls
[10:18:34.455]             `[[` <- base::`[[`
[10:18:34.455]             `+` <- base::`+`
[10:18:34.455]             `<<-` <- base::`<<-`
[10:18:34.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.455]                   3L)]
[10:18:34.455]             }
[10:18:34.455]             function(cond) {
[10:18:34.455]                 is_error <- inherits(cond, "error")
[10:18:34.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.455]                   NULL)
[10:18:34.455]                 if (is_error) {
[10:18:34.455]                   sessionInformation <- function() {
[10:18:34.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.455]                       search = base::search(), system = base::Sys.info())
[10:18:34.455]                   }
[10:18:34.455]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.455]                     cond$call), session = sessionInformation(), 
[10:18:34.455]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.455]                   signalCondition(cond)
[10:18:34.455]                 }
[10:18:34.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.455]                 "immediateCondition"))) {
[10:18:34.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.455]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.455]                   if (TRUE && !signal) {
[10:18:34.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.455]                     {
[10:18:34.455]                       inherits <- base::inherits
[10:18:34.455]                       invokeRestart <- base::invokeRestart
[10:18:34.455]                       is.null <- base::is.null
[10:18:34.455]                       muffled <- FALSE
[10:18:34.455]                       if (inherits(cond, "message")) {
[10:18:34.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.455]                         if (muffled) 
[10:18:34.455]                           invokeRestart("muffleMessage")
[10:18:34.455]                       }
[10:18:34.455]                       else if (inherits(cond, "warning")) {
[10:18:34.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.455]                         if (muffled) 
[10:18:34.455]                           invokeRestart("muffleWarning")
[10:18:34.455]                       }
[10:18:34.455]                       else if (inherits(cond, "condition")) {
[10:18:34.455]                         if (!is.null(pattern)) {
[10:18:34.455]                           computeRestarts <- base::computeRestarts
[10:18:34.455]                           grepl <- base::grepl
[10:18:34.455]                           restarts <- computeRestarts(cond)
[10:18:34.455]                           for (restart in restarts) {
[10:18:34.455]                             name <- restart$name
[10:18:34.455]                             if (is.null(name)) 
[10:18:34.455]                               next
[10:18:34.455]                             if (!grepl(pattern, name)) 
[10:18:34.455]                               next
[10:18:34.455]                             invokeRestart(restart)
[10:18:34.455]                             muffled <- TRUE
[10:18:34.455]                             break
[10:18:34.455]                           }
[10:18:34.455]                         }
[10:18:34.455]                       }
[10:18:34.455]                       invisible(muffled)
[10:18:34.455]                     }
[10:18:34.455]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.455]                   }
[10:18:34.455]                 }
[10:18:34.455]                 else {
[10:18:34.455]                   if (TRUE) {
[10:18:34.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.455]                     {
[10:18:34.455]                       inherits <- base::inherits
[10:18:34.455]                       invokeRestart <- base::invokeRestart
[10:18:34.455]                       is.null <- base::is.null
[10:18:34.455]                       muffled <- FALSE
[10:18:34.455]                       if (inherits(cond, "message")) {
[10:18:34.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.455]                         if (muffled) 
[10:18:34.455]                           invokeRestart("muffleMessage")
[10:18:34.455]                       }
[10:18:34.455]                       else if (inherits(cond, "warning")) {
[10:18:34.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.455]                         if (muffled) 
[10:18:34.455]                           invokeRestart("muffleWarning")
[10:18:34.455]                       }
[10:18:34.455]                       else if (inherits(cond, "condition")) {
[10:18:34.455]                         if (!is.null(pattern)) {
[10:18:34.455]                           computeRestarts <- base::computeRestarts
[10:18:34.455]                           grepl <- base::grepl
[10:18:34.455]                           restarts <- computeRestarts(cond)
[10:18:34.455]                           for (restart in restarts) {
[10:18:34.455]                             name <- restart$name
[10:18:34.455]                             if (is.null(name)) 
[10:18:34.455]                               next
[10:18:34.455]                             if (!grepl(pattern, name)) 
[10:18:34.455]                               next
[10:18:34.455]                             invokeRestart(restart)
[10:18:34.455]                             muffled <- TRUE
[10:18:34.455]                             break
[10:18:34.455]                           }
[10:18:34.455]                         }
[10:18:34.455]                       }
[10:18:34.455]                       invisible(muffled)
[10:18:34.455]                     }
[10:18:34.455]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.455]                   }
[10:18:34.455]                 }
[10:18:34.455]             }
[10:18:34.455]         }))
[10:18:34.455]     }, error = function(ex) {
[10:18:34.455]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.455]                 ...future.rng), started = ...future.startTime, 
[10:18:34.455]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.455]             version = "1.8"), class = "FutureResult")
[10:18:34.455]     }, finally = {
[10:18:34.455]         if (!identical(...future.workdir, getwd())) 
[10:18:34.455]             setwd(...future.workdir)
[10:18:34.455]         {
[10:18:34.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.455]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.455]             }
[10:18:34.455]             base::options(...future.oldOptions)
[10:18:34.455]             if (.Platform$OS.type == "windows") {
[10:18:34.455]                 old_names <- names(...future.oldEnvVars)
[10:18:34.455]                 envs <- base::Sys.getenv()
[10:18:34.455]                 names <- names(envs)
[10:18:34.455]                 common <- intersect(names, old_names)
[10:18:34.455]                 added <- setdiff(names, old_names)
[10:18:34.455]                 removed <- setdiff(old_names, names)
[10:18:34.455]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.455]                   envs[common]]
[10:18:34.455]                 NAMES <- toupper(changed)
[10:18:34.455]                 args <- list()
[10:18:34.455]                 for (kk in seq_along(NAMES)) {
[10:18:34.455]                   name <- changed[[kk]]
[10:18:34.455]                   NAME <- NAMES[[kk]]
[10:18:34.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.455]                     next
[10:18:34.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.455]                 }
[10:18:34.455]                 NAMES <- toupper(added)
[10:18:34.455]                 for (kk in seq_along(NAMES)) {
[10:18:34.455]                   name <- added[[kk]]
[10:18:34.455]                   NAME <- NAMES[[kk]]
[10:18:34.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.455]                     next
[10:18:34.455]                   args[[name]] <- ""
[10:18:34.455]                 }
[10:18:34.455]                 NAMES <- toupper(removed)
[10:18:34.455]                 for (kk in seq_along(NAMES)) {
[10:18:34.455]                   name <- removed[[kk]]
[10:18:34.455]                   NAME <- NAMES[[kk]]
[10:18:34.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.455]                     next
[10:18:34.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.455]                 }
[10:18:34.455]                 if (length(args) > 0) 
[10:18:34.455]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.455]             }
[10:18:34.455]             else {
[10:18:34.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.455]             }
[10:18:34.455]             {
[10:18:34.455]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.455]                   0L) {
[10:18:34.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.455]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.455]                   base::options(opts)
[10:18:34.455]                 }
[10:18:34.455]                 {
[10:18:34.455]                   {
[10:18:34.455]                     NULL
[10:18:34.455]                     RNGkind("Mersenne-Twister")
[10:18:34.455]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:34.455]                       inherits = FALSE)
[10:18:34.455]                   }
[10:18:34.455]                   options(future.plan = NULL)
[10:18:34.455]                   if (is.na(NA_character_)) 
[10:18:34.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.455]                     .init = FALSE)
[10:18:34.455]                 }
[10:18:34.455]             }
[10:18:34.455]         }
[10:18:34.455]     })
[10:18:34.455]     if (TRUE) {
[10:18:34.455]         base::sink(type = "output", split = FALSE)
[10:18:34.455]         if (TRUE) {
[10:18:34.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.455]         }
[10:18:34.455]         else {
[10:18:34.455]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.455]         }
[10:18:34.455]         base::close(...future.stdout)
[10:18:34.455]         ...future.stdout <- NULL
[10:18:34.455]     }
[10:18:34.455]     ...future.result$conditions <- ...future.conditions
[10:18:34.455]     ...future.result$finished <- base::Sys.time()
[10:18:34.455]     ...future.result
[10:18:34.455] }
[10:18:34.457] assign_globals() ...
[10:18:34.457] List of 5
[10:18:34.457]  $ ...future.FUN            :function (x, ...)  
[10:18:34.457]  $ future.call.arguments    : list()
[10:18:34.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.457]  $ ...future.elements_ii    :List of 3
[10:18:34.457]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.457]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.457]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.457]  $ ...future.seeds_ii       : NULL
[10:18:34.457]  $ ...future.globals.maxSize: NULL
[10:18:34.457]  - attr(*, "where")=List of 5
[10:18:34.457]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.457]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.457]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.457]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.457]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.457]  - attr(*, "resolved")= logi FALSE
[10:18:34.457]  - attr(*, "total_size")= num 5433
[10:18:34.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.457]  - attr(*, "already-done")= logi TRUE
[10:18:34.464] - copied ‘...future.FUN’ to environment
[10:18:34.464] - copied ‘future.call.arguments’ to environment
[10:18:34.464] - copied ‘...future.elements_ii’ to environment
[10:18:34.464] - copied ‘...future.seeds_ii’ to environment
[10:18:34.464] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.464] assign_globals() ... done
[10:18:34.465] plan(): Setting new future strategy stack:
[10:18:34.465] List of future strategies:
[10:18:34.465] 1. sequential:
[10:18:34.465]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.465]    - tweaked: FALSE
[10:18:34.465]    - call: NULL
[10:18:34.465] plan(): nbrOfWorkers() = 1
[10:18:34.466] plan(): Setting new future strategy stack:
[10:18:34.467] List of future strategies:
[10:18:34.467] 1. sequential:
[10:18:34.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.467]    - tweaked: FALSE
[10:18:34.467]    - call: plan(strategy)
[10:18:34.467] plan(): nbrOfWorkers() = 1
[10:18:34.467] SequentialFuture started (and completed)
[10:18:34.467] - Launch lazy future ... done
[10:18:34.467] run() for ‘SequentialFuture’ ... done
[10:18:34.467] Created future:
[10:18:34.468] SequentialFuture:
[10:18:34.468] Label: ‘future_eapply-1’
[10:18:34.468] Expression:
[10:18:34.468] {
[10:18:34.468]     do.call(function(...) {
[10:18:34.468]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.468]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.468]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.468]             on.exit(options(oopts), add = TRUE)
[10:18:34.468]         }
[10:18:34.468]         {
[10:18:34.468]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.468]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.468]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.468]             })
[10:18:34.468]         }
[10:18:34.468]     }, args = future.call.arguments)
[10:18:34.468] }
[10:18:34.468] Lazy evaluation: FALSE
[10:18:34.468] Asynchronous evaluation: FALSE
[10:18:34.468] Local evaluation: TRUE
[10:18:34.468] Environment: R_GlobalEnv
[10:18:34.468] Capture standard output: TRUE
[10:18:34.468] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.468] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 296 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.468] Packages: 1 packages (‘stats’)
[10:18:34.468] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.468] Resolved: TRUE
[10:18:34.468] Value: 413 bytes of class ‘list’
[10:18:34.468] Early signaling: FALSE
[10:18:34.468] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.468] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.468] Chunk #1 of 1 ... DONE
[10:18:34.469] Launching 1 futures (chunks) ... DONE
[10:18:34.469] Resolving 1 futures (chunks) ...
[10:18:34.469] resolve() on list ...
[10:18:34.469]  recursive: 0
[10:18:34.469]  length: 1
[10:18:34.469] 
[10:18:34.469] resolved() for ‘SequentialFuture’ ...
[10:18:34.469] - state: ‘finished’
[10:18:34.469] - run: TRUE
[10:18:34.469] - result: ‘FutureResult’
[10:18:34.469] resolved() for ‘SequentialFuture’ ... done
[10:18:34.470] Future #1
[10:18:34.470] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:34.470] - nx: 1
[10:18:34.470] - relay: TRUE
[10:18:34.470] - stdout: TRUE
[10:18:34.470] - signal: TRUE
[10:18:34.470] - resignal: FALSE
[10:18:34.470] - force: TRUE
[10:18:34.470] - relayed: [n=1] FALSE
[10:18:34.470] - queued futures: [n=1] FALSE
[10:18:34.470]  - until=1
[10:18:34.471]  - relaying element #1
[10:18:34.471] - relayed: [n=1] TRUE
[10:18:34.471] - queued futures: [n=1] TRUE
[10:18:34.471] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:34.471]  length: 0 (resolved future 1)
[10:18:34.471] Relaying remaining futures
[10:18:34.471] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.471] - nx: 1
[10:18:34.471] - relay: TRUE
[10:18:34.471] - stdout: TRUE
[10:18:34.471] - signal: TRUE
[10:18:34.472] - resignal: FALSE
[10:18:34.472] - force: TRUE
[10:18:34.472] - relayed: [n=1] TRUE
[10:18:34.472] - queued futures: [n=1] TRUE
 - flush all
[10:18:34.472] - relayed: [n=1] TRUE
[10:18:34.472] - queued futures: [n=1] TRUE
[10:18:34.472] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.472] resolve() on list ... DONE
[10:18:34.472]  - Number of value chunks collected: 1
[10:18:34.472] Resolving 1 futures (chunks) ... DONE
[10:18:34.473] Reducing values from 1 chunks ...
[10:18:34.473]  - Number of values collected after concatenation: 3
[10:18:34.473]  - Number of values expected: 3
[10:18:34.473] Reducing values from 1 chunks ... DONE
[10:18:34.473] future_lapply() ... DONE
[10:18:34.473] future_lapply() ...
[10:18:34.474] Number of chunks: 1
[10:18:34.474] getGlobalsAndPackagesXApply() ...
[10:18:34.474]  - future.globals: TRUE
[10:18:34.474] getGlobalsAndPackages() ...
[10:18:34.474] Searching for globals...
[10:18:34.475] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.475] Searching for globals ... DONE
[10:18:34.475] Resolving globals: FALSE
[10:18:34.476] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:34.476] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:34.476] - globals: [1] ‘FUN’
[10:18:34.476] - packages: [1] ‘stats’
[10:18:34.476] getGlobalsAndPackages() ... DONE
[10:18:34.476]  - globals found/used: [n=1] ‘FUN’
[10:18:34.476]  - needed namespaces: [n=1] ‘stats’
[10:18:34.477] Finding globals ... DONE
[10:18:34.477]  - use_args: TRUE
[10:18:34.477]  - Getting '...' globals ...
[10:18:34.477] resolve() on list ...
[10:18:34.477]  recursive: 0
[10:18:34.477]  length: 1
[10:18:34.477]  elements: ‘...’
[10:18:34.477]  length: 0 (resolved future 1)
[10:18:34.478] resolve() on list ... DONE
[10:18:34.478]    - '...' content: [n=0] 
[10:18:34.478] List of 1
[10:18:34.478]  $ ...: list()
[10:18:34.478]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.478]  - attr(*, "where")=List of 1
[10:18:34.478]   ..$ ...:<environment: 0x56033c905be0> 
[10:18:34.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.478]  - attr(*, "resolved")= logi TRUE
[10:18:34.478]  - attr(*, "total_size")= num NA
[10:18:34.480]  - Getting '...' globals ... DONE
[10:18:34.480] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.480] List of 2
[10:18:34.480]  $ ...future.FUN:function (x, ...)  
[10:18:34.480]  $ ...          : list()
[10:18:34.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.480]  - attr(*, "where")=List of 2
[10:18:34.480]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.480]   ..$ ...          :<environment: 0x56033c905be0> 
[10:18:34.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.480]  - attr(*, "resolved")= logi FALSE
[10:18:34.480]  - attr(*, "total_size")= num 5437
[10:18:34.483] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:34.483] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.483] Number of futures (= number of chunks): 1
[10:18:34.485] Launching 1 futures (chunks) ...
[10:18:34.485] Chunk #1 of 1 ...
[10:18:34.485]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.485] getGlobalsAndPackages() ...
[10:18:34.485] Searching for globals...
[10:18:34.486] 
[10:18:34.486] Searching for globals ... DONE
[10:18:34.486] - globals: [0] <none>
[10:18:34.486] getGlobalsAndPackages() ... DONE
[10:18:34.486]    + additional globals found: [n=0] 
[10:18:34.486]    + additional namespaces needed: [n=0] 
[10:18:34.486]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.486]  - seeds: <none>
[10:18:34.486]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.486] getGlobalsAndPackages() ...
[10:18:34.487] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.487] Resolving globals: FALSE
[10:18:34.487] Tweak future expression to call with '...' arguments ...
[10:18:34.487] {
[10:18:34.487]     do.call(function(...) {
[10:18:34.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.487]             on.exit(options(oopts), add = TRUE)
[10:18:34.487]         }
[10:18:34.487]         {
[10:18:34.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.487]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.487]             })
[10:18:34.487]         }
[10:18:34.487]     }, args = future.call.arguments)
[10:18:34.487] }
[10:18:34.487] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.488] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.488] - packages: [1] ‘stats’
[10:18:34.488] getGlobalsAndPackages() ... DONE
[10:18:34.488] run() for ‘Future’ ...
[10:18:34.488] - state: ‘created’
[10:18:34.488] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:34.489] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:34.489]   - Field: ‘label’
[10:18:34.489]   - Field: ‘local’
[10:18:34.489]   - Field: ‘owner’
[10:18:34.489]   - Field: ‘envir’
[10:18:34.489]   - Field: ‘packages’
[10:18:34.489]   - Field: ‘gc’
[10:18:34.489]   - Field: ‘conditions’
[10:18:34.489]   - Field: ‘expr’
[10:18:34.489]   - Field: ‘uuid’
[10:18:34.490]   - Field: ‘seed’
[10:18:34.490]   - Field: ‘version’
[10:18:34.490]   - Field: ‘result’
[10:18:34.490]   - Field: ‘asynchronous’
[10:18:34.490]   - Field: ‘calls’
[10:18:34.490]   - Field: ‘globals’
[10:18:34.490]   - Field: ‘stdout’
[10:18:34.490]   - Field: ‘earlySignal’
[10:18:34.490]   - Field: ‘lazy’
[10:18:34.490]   - Field: ‘state’
[10:18:34.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:34.491] - Launch lazy future ...
[10:18:34.491] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.491] Packages needed by future strategies (n = 0): <none>
[10:18:34.491] {
[10:18:34.491]     {
[10:18:34.491]         {
[10:18:34.491]             ...future.startTime <- base::Sys.time()
[10:18:34.491]             {
[10:18:34.491]                 {
[10:18:34.491]                   {
[10:18:34.491]                     {
[10:18:34.491]                       base::local({
[10:18:34.491]                         has_future <- base::requireNamespace("future", 
[10:18:34.491]                           quietly = TRUE)
[10:18:34.491]                         if (has_future) {
[10:18:34.491]                           ns <- base::getNamespace("future")
[10:18:34.491]                           version <- ns[[".package"]][["version"]]
[10:18:34.491]                           if (is.null(version)) 
[10:18:34.491]                             version <- utils::packageVersion("future")
[10:18:34.491]                         }
[10:18:34.491]                         else {
[10:18:34.491]                           version <- NULL
[10:18:34.491]                         }
[10:18:34.491]                         if (!has_future || version < "1.8.0") {
[10:18:34.491]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.491]                             "", base::R.version$version.string), 
[10:18:34.491]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:34.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:34.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.491]                               "release", "version")], collapse = " "), 
[10:18:34.491]                             hostname = base::Sys.info()[["nodename"]])
[10:18:34.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.491]                             info)
[10:18:34.491]                           info <- base::paste(info, collapse = "; ")
[10:18:34.491]                           if (!has_future) {
[10:18:34.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.491]                               info)
[10:18:34.491]                           }
[10:18:34.491]                           else {
[10:18:34.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.491]                               info, version)
[10:18:34.491]                           }
[10:18:34.491]                           base::stop(msg)
[10:18:34.491]                         }
[10:18:34.491]                       })
[10:18:34.491]                     }
[10:18:34.491]                     base::local({
[10:18:34.491]                       for (pkg in "stats") {
[10:18:34.491]                         base::loadNamespace(pkg)
[10:18:34.491]                         base::library(pkg, character.only = TRUE)
[10:18:34.491]                       }
[10:18:34.491]                     })
[10:18:34.491]                   }
[10:18:34.491]                   ...future.strategy.old <- future::plan("list")
[10:18:34.491]                   options(future.plan = NULL)
[10:18:34.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.491]                 }
[10:18:34.491]                 ...future.workdir <- getwd()
[10:18:34.491]             }
[10:18:34.491]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.491]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.491]         }
[10:18:34.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:34.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.491]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.491]             base::names(...future.oldOptions))
[10:18:34.491]     }
[10:18:34.491]     if (FALSE) {
[10:18:34.491]     }
[10:18:34.491]     else {
[10:18:34.491]         if (TRUE) {
[10:18:34.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.491]                 open = "w")
[10:18:34.491]         }
[10:18:34.491]         else {
[10:18:34.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.491]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.491]         }
[10:18:34.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.491]             base::sink(type = "output", split = FALSE)
[10:18:34.491]             base::close(...future.stdout)
[10:18:34.491]         }, add = TRUE)
[10:18:34.491]     }
[10:18:34.491]     ...future.frame <- base::sys.nframe()
[10:18:34.491]     ...future.conditions <- base::list()
[10:18:34.491]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.491]     if (FALSE) {
[10:18:34.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.491]     }
[10:18:34.491]     ...future.result <- base::tryCatch({
[10:18:34.491]         base::withCallingHandlers({
[10:18:34.491]             ...future.value <- base::withVisible(base::local({
[10:18:34.491]                 do.call(function(...) {
[10:18:34.491]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.491]                   if (!identical(...future.globals.maxSize.org, 
[10:18:34.491]                     ...future.globals.maxSize)) {
[10:18:34.491]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.491]                     on.exit(options(oopts), add = TRUE)
[10:18:34.491]                   }
[10:18:34.491]                   {
[10:18:34.491]                     lapply(seq_along(...future.elements_ii), 
[10:18:34.491]                       FUN = function(jj) {
[10:18:34.491]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.491]                         ...future.FUN(...future.X_jj, ...)
[10:18:34.491]                       })
[10:18:34.491]                   }
[10:18:34.491]                 }, args = future.call.arguments)
[10:18:34.491]             }))
[10:18:34.491]             future::FutureResult(value = ...future.value$value, 
[10:18:34.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.491]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.491]                     ...future.globalenv.names))
[10:18:34.491]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.491]         }, condition = base::local({
[10:18:34.491]             c <- base::c
[10:18:34.491]             inherits <- base::inherits
[10:18:34.491]             invokeRestart <- base::invokeRestart
[10:18:34.491]             length <- base::length
[10:18:34.491]             list <- base::list
[10:18:34.491]             seq.int <- base::seq.int
[10:18:34.491]             signalCondition <- base::signalCondition
[10:18:34.491]             sys.calls <- base::sys.calls
[10:18:34.491]             `[[` <- base::`[[`
[10:18:34.491]             `+` <- base::`+`
[10:18:34.491]             `<<-` <- base::`<<-`
[10:18:34.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.491]                   3L)]
[10:18:34.491]             }
[10:18:34.491]             function(cond) {
[10:18:34.491]                 is_error <- inherits(cond, "error")
[10:18:34.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.491]                   NULL)
[10:18:34.491]                 if (is_error) {
[10:18:34.491]                   sessionInformation <- function() {
[10:18:34.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.491]                       search = base::search(), system = base::Sys.info())
[10:18:34.491]                   }
[10:18:34.491]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.491]                     cond$call), session = sessionInformation(), 
[10:18:34.491]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.491]                   signalCondition(cond)
[10:18:34.491]                 }
[10:18:34.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.491]                 "immediateCondition"))) {
[10:18:34.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.491]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.491]                   if (TRUE && !signal) {
[10:18:34.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.491]                     {
[10:18:34.491]                       inherits <- base::inherits
[10:18:34.491]                       invokeRestart <- base::invokeRestart
[10:18:34.491]                       is.null <- base::is.null
[10:18:34.491]                       muffled <- FALSE
[10:18:34.491]                       if (inherits(cond, "message")) {
[10:18:34.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.491]                         if (muffled) 
[10:18:34.491]                           invokeRestart("muffleMessage")
[10:18:34.491]                       }
[10:18:34.491]                       else if (inherits(cond, "warning")) {
[10:18:34.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.491]                         if (muffled) 
[10:18:34.491]                           invokeRestart("muffleWarning")
[10:18:34.491]                       }
[10:18:34.491]                       else if (inherits(cond, "condition")) {
[10:18:34.491]                         if (!is.null(pattern)) {
[10:18:34.491]                           computeRestarts <- base::computeRestarts
[10:18:34.491]                           grepl <- base::grepl
[10:18:34.491]                           restarts <- computeRestarts(cond)
[10:18:34.491]                           for (restart in restarts) {
[10:18:34.491]                             name <- restart$name
[10:18:34.491]                             if (is.null(name)) 
[10:18:34.491]                               next
[10:18:34.491]                             if (!grepl(pattern, name)) 
[10:18:34.491]                               next
[10:18:34.491]                             invokeRestart(restart)
[10:18:34.491]                             muffled <- TRUE
[10:18:34.491]                             break
[10:18:34.491]                           }
[10:18:34.491]                         }
[10:18:34.491]                       }
[10:18:34.491]                       invisible(muffled)
[10:18:34.491]                     }
[10:18:34.491]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.491]                   }
[10:18:34.491]                 }
[10:18:34.491]                 else {
[10:18:34.491]                   if (TRUE) {
[10:18:34.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.491]                     {
[10:18:34.491]                       inherits <- base::inherits
[10:18:34.491]                       invokeRestart <- base::invokeRestart
[10:18:34.491]                       is.null <- base::is.null
[10:18:34.491]                       muffled <- FALSE
[10:18:34.491]                       if (inherits(cond, "message")) {
[10:18:34.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.491]                         if (muffled) 
[10:18:34.491]                           invokeRestart("muffleMessage")
[10:18:34.491]                       }
[10:18:34.491]                       else if (inherits(cond, "warning")) {
[10:18:34.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.491]                         if (muffled) 
[10:18:34.491]                           invokeRestart("muffleWarning")
[10:18:34.491]                       }
[10:18:34.491]                       else if (inherits(cond, "condition")) {
[10:18:34.491]                         if (!is.null(pattern)) {
[10:18:34.491]                           computeRestarts <- base::computeRestarts
[10:18:34.491]                           grepl <- base::grepl
[10:18:34.491]                           restarts <- computeRestarts(cond)
[10:18:34.491]                           for (restart in restarts) {
[10:18:34.491]                             name <- restart$name
[10:18:34.491]                             if (is.null(name)) 
[10:18:34.491]                               next
[10:18:34.491]                             if (!grepl(pattern, name)) 
[10:18:34.491]                               next
[10:18:34.491]                             invokeRestart(restart)
[10:18:34.491]                             muffled <- TRUE
[10:18:34.491]                             break
[10:18:34.491]                           }
[10:18:34.491]                         }
[10:18:34.491]                       }
[10:18:34.491]                       invisible(muffled)
[10:18:34.491]                     }
[10:18:34.491]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.491]                   }
[10:18:34.491]                 }
[10:18:34.491]             }
[10:18:34.491]         }))
[10:18:34.491]     }, error = function(ex) {
[10:18:34.491]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.491]                 ...future.rng), started = ...future.startTime, 
[10:18:34.491]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.491]             version = "1.8"), class = "FutureResult")
[10:18:34.491]     }, finally = {
[10:18:34.491]         if (!identical(...future.workdir, getwd())) 
[10:18:34.491]             setwd(...future.workdir)
[10:18:34.491]         {
[10:18:34.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.491]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.491]             }
[10:18:34.491]             base::options(...future.oldOptions)
[10:18:34.491]             if (.Platform$OS.type == "windows") {
[10:18:34.491]                 old_names <- names(...future.oldEnvVars)
[10:18:34.491]                 envs <- base::Sys.getenv()
[10:18:34.491]                 names <- names(envs)
[10:18:34.491]                 common <- intersect(names, old_names)
[10:18:34.491]                 added <- setdiff(names, old_names)
[10:18:34.491]                 removed <- setdiff(old_names, names)
[10:18:34.491]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.491]                   envs[common]]
[10:18:34.491]                 NAMES <- toupper(changed)
[10:18:34.491]                 args <- list()
[10:18:34.491]                 for (kk in seq_along(NAMES)) {
[10:18:34.491]                   name <- changed[[kk]]
[10:18:34.491]                   NAME <- NAMES[[kk]]
[10:18:34.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.491]                     next
[10:18:34.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.491]                 }
[10:18:34.491]                 NAMES <- toupper(added)
[10:18:34.491]                 for (kk in seq_along(NAMES)) {
[10:18:34.491]                   name <- added[[kk]]
[10:18:34.491]                   NAME <- NAMES[[kk]]
[10:18:34.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.491]                     next
[10:18:34.491]                   args[[name]] <- ""
[10:18:34.491]                 }
[10:18:34.491]                 NAMES <- toupper(removed)
[10:18:34.491]                 for (kk in seq_along(NAMES)) {
[10:18:34.491]                   name <- removed[[kk]]
[10:18:34.491]                   NAME <- NAMES[[kk]]
[10:18:34.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.491]                     next
[10:18:34.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.491]                 }
[10:18:34.491]                 if (length(args) > 0) 
[10:18:34.491]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.491]             }
[10:18:34.491]             else {
[10:18:34.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.491]             }
[10:18:34.491]             {
[10:18:34.491]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.491]                   0L) {
[10:18:34.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.491]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.491]                   base::options(opts)
[10:18:34.491]                 }
[10:18:34.491]                 {
[10:18:34.491]                   {
[10:18:34.491]                     NULL
[10:18:34.491]                     RNGkind("Mersenne-Twister")
[10:18:34.491]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:34.491]                       inherits = FALSE)
[10:18:34.491]                   }
[10:18:34.491]                   options(future.plan = NULL)
[10:18:34.491]                   if (is.na(NA_character_)) 
[10:18:34.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.491]                     .init = FALSE)
[10:18:34.491]                 }
[10:18:34.491]             }
[10:18:34.491]         }
[10:18:34.491]     })
[10:18:34.491]     if (TRUE) {
[10:18:34.491]         base::sink(type = "output", split = FALSE)
[10:18:34.491]         if (TRUE) {
[10:18:34.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.491]         }
[10:18:34.491]         else {
[10:18:34.491]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.491]         }
[10:18:34.491]         base::close(...future.stdout)
[10:18:34.491]         ...future.stdout <- NULL
[10:18:34.491]     }
[10:18:34.491]     ...future.result$conditions <- ...future.conditions
[10:18:34.491]     ...future.result$finished <- base::Sys.time()
[10:18:34.491]     ...future.result
[10:18:34.491] }
[10:18:34.493] assign_globals() ...
[10:18:34.493] List of 5
[10:18:34.493]  $ ...future.FUN            :function (x, ...)  
[10:18:34.493]  $ future.call.arguments    : list()
[10:18:34.493]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.493]  $ ...future.elements_ii    :List of 3
[10:18:34.493]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.493]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.493]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.493]  $ ...future.seeds_ii       : NULL
[10:18:34.493]  $ ...future.globals.maxSize: NULL
[10:18:34.493]  - attr(*, "where")=List of 5
[10:18:34.493]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.493]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.493]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.493]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.493]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.493]  - attr(*, "resolved")= logi FALSE
[10:18:34.493]  - attr(*, "total_size")= num 5437
[10:18:34.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.493]  - attr(*, "already-done")= logi TRUE
[10:18:34.499] - copied ‘...future.FUN’ to environment
[10:18:34.499] - copied ‘future.call.arguments’ to environment
[10:18:34.499] - copied ‘...future.elements_ii’ to environment
[10:18:34.499] - copied ‘...future.seeds_ii’ to environment
[10:18:34.499] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.499] assign_globals() ... done
[10:18:34.499] plan(): Setting new future strategy stack:
[10:18:34.500] List of future strategies:
[10:18:34.500] 1. sequential:
[10:18:34.500]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.500]    - tweaked: FALSE
[10:18:34.500]    - call: NULL
[10:18:34.500] plan(): nbrOfWorkers() = 1
[10:18:34.501] plan(): Setting new future strategy stack:
[10:18:34.501] List of future strategies:
[10:18:34.501] 1. sequential:
[10:18:34.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.501]    - tweaked: FALSE
[10:18:34.501]    - call: plan(strategy)
[10:18:34.502] plan(): nbrOfWorkers() = 1
[10:18:34.502] SequentialFuture started (and completed)
[10:18:34.502] - Launch lazy future ... done
[10:18:34.502] run() for ‘SequentialFuture’ ... done
[10:18:34.502] Created future:
[10:18:34.502] SequentialFuture:
[10:18:34.502] Label: ‘future_eapply-1’
[10:18:34.502] Expression:
[10:18:34.502] {
[10:18:34.502]     do.call(function(...) {
[10:18:34.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.502]             on.exit(options(oopts), add = TRUE)
[10:18:34.502]         }
[10:18:34.502]         {
[10:18:34.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.502]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.502]             })
[10:18:34.502]         }
[10:18:34.502]     }, args = future.call.arguments)
[10:18:34.502] }
[10:18:34.502] Lazy evaluation: FALSE
[10:18:34.502] Asynchronous evaluation: FALSE
[10:18:34.502] Local evaluation: TRUE
[10:18:34.502] Environment: R_GlobalEnv
[10:18:34.502] Capture standard output: TRUE
[10:18:34.502] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.502] Globals: 5 objects totaling 758 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 296 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.502] Packages: 1 packages (‘stats’)
[10:18:34.502] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.502] Resolved: TRUE
[10:18:34.502] Value: 413 bytes of class ‘list’
[10:18:34.502] Early signaling: FALSE
[10:18:34.502] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.502] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:34.503] Chunk #1 of 1 ... DONE
[10:18:34.503] Launching 1 futures (chunks) ... DONE
[10:18:34.503] Resolving 1 futures (chunks) ...
[10:18:34.503] resolve() on list ...
[10:18:34.504]  recursive: 0
[10:18:34.504]  length: 1
[10:18:34.504] 
[10:18:34.504] resolved() for ‘SequentialFuture’ ...
[10:18:34.504] - state: ‘finished’
[10:18:34.504] - run: TRUE
[10:18:34.504] - result: ‘FutureResult’
[10:18:34.504] resolved() for ‘SequentialFuture’ ... done
[10:18:34.504] Future #1
[10:18:34.504] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:34.505] - nx: 1
[10:18:34.505] - relay: TRUE
[10:18:34.505] - stdout: TRUE
[10:18:34.505] - signal: TRUE
[10:18:34.505] - resignal: FALSE
[10:18:34.505] - force: TRUE
[10:18:34.505] - relayed: [n=1] FALSE
[10:18:34.505] - queued futures: [n=1] FALSE
[10:18:34.505]  - until=1
[10:18:34.505]  - relaying element #1
[10:18:34.505] - relayed: [n=1] TRUE
[10:18:34.506] - queued futures: [n=1] TRUE
[10:18:34.506] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:34.506]  length: 0 (resolved future 1)
[10:18:34.506] Relaying remaining futures
[10:18:34.506] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.506] - nx: 1
[10:18:34.506] - relay: TRUE
[10:18:34.506] - stdout: TRUE
[10:18:34.506] - signal: TRUE
[10:18:34.506] - resignal: FALSE
[10:18:34.506] - force: TRUE
[10:18:34.506] - relayed: [n=1] TRUE
[10:18:34.507] - queued futures: [n=1] TRUE
 - flush all
[10:18:34.507] - relayed: [n=1] TRUE
[10:18:34.507] - queued futures: [n=1] TRUE
[10:18:34.507] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.507] resolve() on list ... DONE
[10:18:34.507]  - Number of value chunks collected: 1
[10:18:34.507] Resolving 1 futures (chunks) ... DONE
[10:18:34.507] Reducing values from 1 chunks ...
[10:18:34.507]  - Number of values collected after concatenation: 3
[10:18:34.507]  - Number of values expected: 3
[10:18:34.508] Reducing values from 1 chunks ... DONE
[10:18:34.508] future_lapply() ... DONE
[10:18:34.508] plan(): Setting new future strategy stack:
[10:18:34.508] List of future strategies:
[10:18:34.508] 1. sequential:
[10:18:34.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.508]    - tweaked: FALSE
[10:18:34.508]    - call: plan(sequential)
[10:18:34.508] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:18:34.511] plan(): Setting new future strategy stack:
[10:18:34.511] List of future strategies:
[10:18:34.511] 1. multicore:
[10:18:34.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.511]    - tweaked: FALSE
[10:18:34.511]    - call: plan(strategy)
[10:18:34.512] plan(): nbrOfWorkers() = 2
[10:18:34.513] future_lapply() ...
[10:18:34.515] Number of chunks: 2
[10:18:34.515] getGlobalsAndPackagesXApply() ...
[10:18:34.515]  - future.globals: TRUE
[10:18:34.515] getGlobalsAndPackages() ...
[10:18:34.515] Searching for globals...
[10:18:34.516] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.516] Searching for globals ... DONE
[10:18:34.517] Resolving globals: FALSE
[10:18:34.517] The total size of the 1 globals is 273 bytes (273 bytes)
[10:18:34.517] The total size of the 1 globals exported for future expression (‘FUN()’) is 273 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (273 bytes of class ‘function’)
[10:18:34.517] - globals: [1] ‘FUN’
[10:18:34.517] 
[10:18:34.518] getGlobalsAndPackages() ... DONE
[10:18:34.518]  - globals found/used: [n=1] ‘FUN’
[10:18:34.518]  - needed namespaces: [n=0] 
[10:18:34.518] Finding globals ... DONE
[10:18:34.518]  - use_args: TRUE
[10:18:34.518]  - Getting '...' globals ...
[10:18:34.518] resolve() on list ...
[10:18:34.518]  recursive: 0
[10:18:34.518]  length: 1
[10:18:34.519]  elements: ‘...’
[10:18:34.519]  length: 0 (resolved future 1)
[10:18:34.519] resolve() on list ... DONE
[10:18:34.519]    - '...' content: [n=0] 
[10:18:34.519] List of 1
[10:18:34.519]  $ ...: list()
[10:18:34.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.519]  - attr(*, "where")=List of 1
[10:18:34.519]   ..$ ...:<environment: 0x56033b58dbd0> 
[10:18:34.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.519]  - attr(*, "resolved")= logi TRUE
[10:18:34.519]  - attr(*, "total_size")= num NA
[10:18:34.521]  - Getting '...' globals ... DONE
[10:18:34.521] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.522] List of 2
[10:18:34.522]  $ ...future.FUN:function (x, ...)  
[10:18:34.522]  $ ...          : list()
[10:18:34.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.522]  - attr(*, "where")=List of 2
[10:18:34.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.522]   ..$ ...          :<environment: 0x56033b58dbd0> 
[10:18:34.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.522]  - attr(*, "resolved")= logi FALSE
[10:18:34.522]  - attr(*, "total_size")= num 5249
[10:18:34.524] Packages to be attached in all futures: [n=0] 
[10:18:34.524] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.524] Number of futures (= number of chunks): 2
[10:18:34.524] Launching 2 futures (chunks) ...
[10:18:34.525] Chunk #1 of 2 ...
[10:18:34.525]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.525] getGlobalsAndPackages() ...
[10:18:34.525] Searching for globals...
[10:18:34.525] 
[10:18:34.525] Searching for globals ... DONE
[10:18:34.525] - globals: [0] <none>
[10:18:34.525] getGlobalsAndPackages() ... DONE
[10:18:34.525]    + additional globals found: [n=0] 
[10:18:34.526]    + additional namespaces needed: [n=0] 
[10:18:34.526]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.526]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.526]  - seeds: <none>
[10:18:34.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.526] getGlobalsAndPackages() ...
[10:18:34.526] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.526] Resolving globals: FALSE
[10:18:34.526] Tweak future expression to call with '...' arguments ...
[10:18:34.526] {
[10:18:34.526]     do.call(function(...) {
[10:18:34.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.526]             on.exit(options(oopts), add = TRUE)
[10:18:34.526]         }
[10:18:34.526]         {
[10:18:34.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.526]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.526]             })
[10:18:34.526]         }
[10:18:34.526]     }, args = future.call.arguments)
[10:18:34.526] }
[10:18:34.527] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.527] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.527] 
[10:18:34.527] getGlobalsAndPackages() ... DONE
[10:18:34.527] run() for ‘Future’ ...
[10:18:34.528] - state: ‘created’
[10:18:34.528] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.529] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.530]   - Field: ‘label’
[10:18:34.530]   - Field: ‘local’
[10:18:34.530]   - Field: ‘owner’
[10:18:34.530]   - Field: ‘envir’
[10:18:34.530]   - Field: ‘workers’
[10:18:34.530]   - Field: ‘packages’
[10:18:34.530]   - Field: ‘gc’
[10:18:34.530]   - Field: ‘job’
[10:18:34.530]   - Field: ‘conditions’
[10:18:34.530]   - Field: ‘expr’
[10:18:34.530]   - Field: ‘uuid’
[10:18:34.530]   - Field: ‘seed’
[10:18:34.531]   - Field: ‘version’
[10:18:34.531]   - Field: ‘result’
[10:18:34.531]   - Field: ‘asynchronous’
[10:18:34.531]   - Field: ‘calls’
[10:18:34.531]   - Field: ‘globals’
[10:18:34.531]   - Field: ‘stdout’
[10:18:34.531]   - Field: ‘earlySignal’
[10:18:34.531]   - Field: ‘lazy’
[10:18:34.531]   - Field: ‘state’
[10:18:34.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.531] - Launch lazy future ...
[10:18:34.532] Packages needed by the future expression (n = 0): <none>
[10:18:34.533] Packages needed by future strategies (n = 0): <none>
[10:18:34.533] {
[10:18:34.533]     {
[10:18:34.533]         {
[10:18:34.533]             ...future.startTime <- base::Sys.time()
[10:18:34.533]             {
[10:18:34.533]                 {
[10:18:34.533]                   {
[10:18:34.533]                     {
[10:18:34.533]                       base::local({
[10:18:34.533]                         has_future <- base::requireNamespace("future", 
[10:18:34.533]                           quietly = TRUE)
[10:18:34.533]                         if (has_future) {
[10:18:34.533]                           ns <- base::getNamespace("future")
[10:18:34.533]                           version <- ns[[".package"]][["version"]]
[10:18:34.533]                           if (is.null(version)) 
[10:18:34.533]                             version <- utils::packageVersion("future")
[10:18:34.533]                         }
[10:18:34.533]                         else {
[10:18:34.533]                           version <- NULL
[10:18:34.533]                         }
[10:18:34.533]                         if (!has_future || version < "1.8.0") {
[10:18:34.533]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.533]                             "", base::R.version$version.string), 
[10:18:34.533]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:34.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:34.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.533]                               "release", "version")], collapse = " "), 
[10:18:34.533]                             hostname = base::Sys.info()[["nodename"]])
[10:18:34.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.533]                             info)
[10:18:34.533]                           info <- base::paste(info, collapse = "; ")
[10:18:34.533]                           if (!has_future) {
[10:18:34.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.533]                               info)
[10:18:34.533]                           }
[10:18:34.533]                           else {
[10:18:34.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.533]                               info, version)
[10:18:34.533]                           }
[10:18:34.533]                           base::stop(msg)
[10:18:34.533]                         }
[10:18:34.533]                       })
[10:18:34.533]                     }
[10:18:34.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.533]                     base::options(mc.cores = 1L)
[10:18:34.533]                   }
[10:18:34.533]                   ...future.strategy.old <- future::plan("list")
[10:18:34.533]                   options(future.plan = NULL)
[10:18:34.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.533]                 }
[10:18:34.533]                 ...future.workdir <- getwd()
[10:18:34.533]             }
[10:18:34.533]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.533]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.533]         }
[10:18:34.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.533]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.533]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.533]             base::names(...future.oldOptions))
[10:18:34.533]     }
[10:18:34.533]     if (FALSE) {
[10:18:34.533]     }
[10:18:34.533]     else {
[10:18:34.533]         if (TRUE) {
[10:18:34.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.533]                 open = "w")
[10:18:34.533]         }
[10:18:34.533]         else {
[10:18:34.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.533]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.533]         }
[10:18:34.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.533]             base::sink(type = "output", split = FALSE)
[10:18:34.533]             base::close(...future.stdout)
[10:18:34.533]         }, add = TRUE)
[10:18:34.533]     }
[10:18:34.533]     ...future.frame <- base::sys.nframe()
[10:18:34.533]     ...future.conditions <- base::list()
[10:18:34.533]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.533]     if (FALSE) {
[10:18:34.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.533]     }
[10:18:34.533]     ...future.result <- base::tryCatch({
[10:18:34.533]         base::withCallingHandlers({
[10:18:34.533]             ...future.value <- base::withVisible(base::local({
[10:18:34.533]                 withCallingHandlers({
[10:18:34.533]                   {
[10:18:34.533]                     do.call(function(...) {
[10:18:34.533]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.533]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.533]                         ...future.globals.maxSize)) {
[10:18:34.533]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.533]                         on.exit(options(oopts), add = TRUE)
[10:18:34.533]                       }
[10:18:34.533]                       {
[10:18:34.533]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.533]                           FUN = function(jj) {
[10:18:34.533]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.533]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.533]                           })
[10:18:34.533]                       }
[10:18:34.533]                     }, args = future.call.arguments)
[10:18:34.533]                   }
[10:18:34.533]                 }, immediateCondition = function(cond) {
[10:18:34.533]                   save_rds <- function (object, pathname, ...) 
[10:18:34.533]                   {
[10:18:34.533]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.533]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.533]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.533]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.533]                         fi_tmp[["mtime"]])
[10:18:34.533]                     }
[10:18:34.533]                     tryCatch({
[10:18:34.533]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.533]                     }, error = function(ex) {
[10:18:34.533]                       msg <- conditionMessage(ex)
[10:18:34.533]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.533]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.533]                         fi_tmp[["mtime"]], msg)
[10:18:34.533]                       ex$message <- msg
[10:18:34.533]                       stop(ex)
[10:18:34.533]                     })
[10:18:34.533]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.533]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.533]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.533]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.533]                       fi <- file.info(pathname)
[10:18:34.533]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.533]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.533]                         fi[["size"]], fi[["mtime"]])
[10:18:34.533]                       stop(msg)
[10:18:34.533]                     }
[10:18:34.533]                     invisible(pathname)
[10:18:34.533]                   }
[10:18:34.533]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.533]                     rootPath = tempdir()) 
[10:18:34.533]                   {
[10:18:34.533]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.533]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.533]                       tmpdir = path, fileext = ".rds")
[10:18:34.533]                     save_rds(obj, file)
[10:18:34.533]                   }
[10:18:34.533]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.533]                   {
[10:18:34.533]                     inherits <- base::inherits
[10:18:34.533]                     invokeRestart <- base::invokeRestart
[10:18:34.533]                     is.null <- base::is.null
[10:18:34.533]                     muffled <- FALSE
[10:18:34.533]                     if (inherits(cond, "message")) {
[10:18:34.533]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.533]                       if (muffled) 
[10:18:34.533]                         invokeRestart("muffleMessage")
[10:18:34.533]                     }
[10:18:34.533]                     else if (inherits(cond, "warning")) {
[10:18:34.533]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.533]                       if (muffled) 
[10:18:34.533]                         invokeRestart("muffleWarning")
[10:18:34.533]                     }
[10:18:34.533]                     else if (inherits(cond, "condition")) {
[10:18:34.533]                       if (!is.null(pattern)) {
[10:18:34.533]                         computeRestarts <- base::computeRestarts
[10:18:34.533]                         grepl <- base::grepl
[10:18:34.533]                         restarts <- computeRestarts(cond)
[10:18:34.533]                         for (restart in restarts) {
[10:18:34.533]                           name <- restart$name
[10:18:34.533]                           if (is.null(name)) 
[10:18:34.533]                             next
[10:18:34.533]                           if (!grepl(pattern, name)) 
[10:18:34.533]                             next
[10:18:34.533]                           invokeRestart(restart)
[10:18:34.533]                           muffled <- TRUE
[10:18:34.533]                           break
[10:18:34.533]                         }
[10:18:34.533]                       }
[10:18:34.533]                     }
[10:18:34.533]                     invisible(muffled)
[10:18:34.533]                   }
[10:18:34.533]                   muffleCondition(cond)
[10:18:34.533]                 })
[10:18:34.533]             }))
[10:18:34.533]             future::FutureResult(value = ...future.value$value, 
[10:18:34.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.533]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.533]                     ...future.globalenv.names))
[10:18:34.533]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.533]         }, condition = base::local({
[10:18:34.533]             c <- base::c
[10:18:34.533]             inherits <- base::inherits
[10:18:34.533]             invokeRestart <- base::invokeRestart
[10:18:34.533]             length <- base::length
[10:18:34.533]             list <- base::list
[10:18:34.533]             seq.int <- base::seq.int
[10:18:34.533]             signalCondition <- base::signalCondition
[10:18:34.533]             sys.calls <- base::sys.calls
[10:18:34.533]             `[[` <- base::`[[`
[10:18:34.533]             `+` <- base::`+`
[10:18:34.533]             `<<-` <- base::`<<-`
[10:18:34.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.533]                   3L)]
[10:18:34.533]             }
[10:18:34.533]             function(cond) {
[10:18:34.533]                 is_error <- inherits(cond, "error")
[10:18:34.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.533]                   NULL)
[10:18:34.533]                 if (is_error) {
[10:18:34.533]                   sessionInformation <- function() {
[10:18:34.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.533]                       search = base::search(), system = base::Sys.info())
[10:18:34.533]                   }
[10:18:34.533]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.533]                     cond$call), session = sessionInformation(), 
[10:18:34.533]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.533]                   signalCondition(cond)
[10:18:34.533]                 }
[10:18:34.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.533]                 "immediateCondition"))) {
[10:18:34.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.533]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.533]                   if (TRUE && !signal) {
[10:18:34.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.533]                     {
[10:18:34.533]                       inherits <- base::inherits
[10:18:34.533]                       invokeRestart <- base::invokeRestart
[10:18:34.533]                       is.null <- base::is.null
[10:18:34.533]                       muffled <- FALSE
[10:18:34.533]                       if (inherits(cond, "message")) {
[10:18:34.533]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.533]                         if (muffled) 
[10:18:34.533]                           invokeRestart("muffleMessage")
[10:18:34.533]                       }
[10:18:34.533]                       else if (inherits(cond, "warning")) {
[10:18:34.533]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.533]                         if (muffled) 
[10:18:34.533]                           invokeRestart("muffleWarning")
[10:18:34.533]                       }
[10:18:34.533]                       else if (inherits(cond, "condition")) {
[10:18:34.533]                         if (!is.null(pattern)) {
[10:18:34.533]                           computeRestarts <- base::computeRestarts
[10:18:34.533]                           grepl <- base::grepl
[10:18:34.533]                           restarts <- computeRestarts(cond)
[10:18:34.533]                           for (restart in restarts) {
[10:18:34.533]                             name <- restart$name
[10:18:34.533]                             if (is.null(name)) 
[10:18:34.533]                               next
[10:18:34.533]                             if (!grepl(pattern, name)) 
[10:18:34.533]                               next
[10:18:34.533]                             invokeRestart(restart)
[10:18:34.533]                             muffled <- TRUE
[10:18:34.533]                             break
[10:18:34.533]                           }
[10:18:34.533]                         }
[10:18:34.533]                       }
[10:18:34.533]                       invisible(muffled)
[10:18:34.533]                     }
[10:18:34.533]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.533]                   }
[10:18:34.533]                 }
[10:18:34.533]                 else {
[10:18:34.533]                   if (TRUE) {
[10:18:34.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.533]                     {
[10:18:34.533]                       inherits <- base::inherits
[10:18:34.533]                       invokeRestart <- base::invokeRestart
[10:18:34.533]                       is.null <- base::is.null
[10:18:34.533]                       muffled <- FALSE
[10:18:34.533]                       if (inherits(cond, "message")) {
[10:18:34.533]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.533]                         if (muffled) 
[10:18:34.533]                           invokeRestart("muffleMessage")
[10:18:34.533]                       }
[10:18:34.533]                       else if (inherits(cond, "warning")) {
[10:18:34.533]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.533]                         if (muffled) 
[10:18:34.533]                           invokeRestart("muffleWarning")
[10:18:34.533]                       }
[10:18:34.533]                       else if (inherits(cond, "condition")) {
[10:18:34.533]                         if (!is.null(pattern)) {
[10:18:34.533]                           computeRestarts <- base::computeRestarts
[10:18:34.533]                           grepl <- base::grepl
[10:18:34.533]                           restarts <- computeRestarts(cond)
[10:18:34.533]                           for (restart in restarts) {
[10:18:34.533]                             name <- restart$name
[10:18:34.533]                             if (is.null(name)) 
[10:18:34.533]                               next
[10:18:34.533]                             if (!grepl(pattern, name)) 
[10:18:34.533]                               next
[10:18:34.533]                             invokeRestart(restart)
[10:18:34.533]                             muffled <- TRUE
[10:18:34.533]                             break
[10:18:34.533]                           }
[10:18:34.533]                         }
[10:18:34.533]                       }
[10:18:34.533]                       invisible(muffled)
[10:18:34.533]                     }
[10:18:34.533]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.533]                   }
[10:18:34.533]                 }
[10:18:34.533]             }
[10:18:34.533]         }))
[10:18:34.533]     }, error = function(ex) {
[10:18:34.533]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.533]                 ...future.rng), started = ...future.startTime, 
[10:18:34.533]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.533]             version = "1.8"), class = "FutureResult")
[10:18:34.533]     }, finally = {
[10:18:34.533]         if (!identical(...future.workdir, getwd())) 
[10:18:34.533]             setwd(...future.workdir)
[10:18:34.533]         {
[10:18:34.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.533]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.533]             }
[10:18:34.533]             base::options(...future.oldOptions)
[10:18:34.533]             if (.Platform$OS.type == "windows") {
[10:18:34.533]                 old_names <- names(...future.oldEnvVars)
[10:18:34.533]                 envs <- base::Sys.getenv()
[10:18:34.533]                 names <- names(envs)
[10:18:34.533]                 common <- intersect(names, old_names)
[10:18:34.533]                 added <- setdiff(names, old_names)
[10:18:34.533]                 removed <- setdiff(old_names, names)
[10:18:34.533]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.533]                   envs[common]]
[10:18:34.533]                 NAMES <- toupper(changed)
[10:18:34.533]                 args <- list()
[10:18:34.533]                 for (kk in seq_along(NAMES)) {
[10:18:34.533]                   name <- changed[[kk]]
[10:18:34.533]                   NAME <- NAMES[[kk]]
[10:18:34.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.533]                     next
[10:18:34.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.533]                 }
[10:18:34.533]                 NAMES <- toupper(added)
[10:18:34.533]                 for (kk in seq_along(NAMES)) {
[10:18:34.533]                   name <- added[[kk]]
[10:18:34.533]                   NAME <- NAMES[[kk]]
[10:18:34.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.533]                     next
[10:18:34.533]                   args[[name]] <- ""
[10:18:34.533]                 }
[10:18:34.533]                 NAMES <- toupper(removed)
[10:18:34.533]                 for (kk in seq_along(NAMES)) {
[10:18:34.533]                   name <- removed[[kk]]
[10:18:34.533]                   NAME <- NAMES[[kk]]
[10:18:34.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.533]                     next
[10:18:34.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.533]                 }
[10:18:34.533]                 if (length(args) > 0) 
[10:18:34.533]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.533]             }
[10:18:34.533]             else {
[10:18:34.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.533]             }
[10:18:34.533]             {
[10:18:34.533]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.533]                   0L) {
[10:18:34.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.533]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.533]                   base::options(opts)
[10:18:34.533]                 }
[10:18:34.533]                 {
[10:18:34.533]                   {
[10:18:34.533]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.533]                     NULL
[10:18:34.533]                   }
[10:18:34.533]                   options(future.plan = NULL)
[10:18:34.533]                   if (is.na(NA_character_)) 
[10:18:34.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.533]                     .init = FALSE)
[10:18:34.533]                 }
[10:18:34.533]             }
[10:18:34.533]         }
[10:18:34.533]     })
[10:18:34.533]     if (TRUE) {
[10:18:34.533]         base::sink(type = "output", split = FALSE)
[10:18:34.533]         if (TRUE) {
[10:18:34.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.533]         }
[10:18:34.533]         else {
[10:18:34.533]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.533]         }
[10:18:34.533]         base::close(...future.stdout)
[10:18:34.533]         ...future.stdout <- NULL
[10:18:34.533]     }
[10:18:34.533]     ...future.result$conditions <- ...future.conditions
[10:18:34.533]     ...future.result$finished <- base::Sys.time()
[10:18:34.533]     ...future.result
[10:18:34.533] }
[10:18:34.535] assign_globals() ...
[10:18:34.535] List of 5
[10:18:34.535]  $ ...future.FUN            :function (x, ...)  
[10:18:34.535]  $ future.call.arguments    : list()
[10:18:34.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.535]  $ ...future.elements_ii    :List of 1
[10:18:34.535]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.535]  $ ...future.seeds_ii       : NULL
[10:18:34.535]  $ ...future.globals.maxSize: NULL
[10:18:34.535]  - attr(*, "where")=List of 5
[10:18:34.535]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.535]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.535]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.535]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.535]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.535]  - attr(*, "resolved")= logi FALSE
[10:18:34.535]  - attr(*, "total_size")= num 5249
[10:18:34.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.535]  - attr(*, "already-done")= logi TRUE
[10:18:34.541] - copied ‘...future.FUN’ to environment
[10:18:34.541] - copied ‘future.call.arguments’ to environment
[10:18:34.542] - copied ‘...future.elements_ii’ to environment
[10:18:34.542] - copied ‘...future.seeds_ii’ to environment
[10:18:34.542] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.542] assign_globals() ... done
[10:18:34.542] requestCore(): workers = 2
[10:18:34.545] MulticoreFuture started
[10:18:34.546] - Launch lazy future ... done
[10:18:34.546] plan(): Setting new future strategy stack:
[10:18:34.546] run() for ‘MulticoreFuture’ ... done
[10:18:34.546] Created future:
[10:18:34.546] List of future strategies:
[10:18:34.546] 1. sequential:
[10:18:34.546]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.546]    - tweaked: FALSE
[10:18:34.546]    - call: NULL
[10:18:34.547] plan(): nbrOfWorkers() = 1
[10:18:34.549] plan(): Setting new future strategy stack:
[10:18:34.549] List of future strategies:
[10:18:34.549] 1. multicore:
[10:18:34.549]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.549]    - tweaked: FALSE
[10:18:34.549]    - call: plan(strategy)
[10:18:34.553] plan(): nbrOfWorkers() = 2
[10:18:34.546] MulticoreFuture:
[10:18:34.546] Label: ‘future_eapply-1’
[10:18:34.546] Expression:
[10:18:34.546] {
[10:18:34.546]     do.call(function(...) {
[10:18:34.546]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.546]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.546]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.546]             on.exit(options(oopts), add = TRUE)
[10:18:34.546]         }
[10:18:34.546]         {
[10:18:34.546]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.546]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.546]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.546]             })
[10:18:34.546]         }
[10:18:34.546]     }, args = future.call.arguments)
[10:18:34.546] }
[10:18:34.546] Lazy evaluation: FALSE
[10:18:34.546] Asynchronous evaluation: TRUE
[10:18:34.546] Local evaluation: TRUE
[10:18:34.546] Environment: R_GlobalEnv
[10:18:34.546] Capture standard output: TRUE
[10:18:34.546] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.546] Globals: 5 objects totaling 479 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.546] Packages: <none>
[10:18:34.546] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.546] Resolved: TRUE
[10:18:34.546] Value: <not collected>
[10:18:34.546] Conditions captured: <none>
[10:18:34.546] Early signaling: FALSE
[10:18:34.546] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.546] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.554] Chunk #1 of 2 ... DONE
[10:18:34.554] Chunk #2 of 2 ...
[10:18:34.554]  - Finding globals in 'X' for chunk #2 ...
[10:18:34.555] getGlobalsAndPackages() ...
[10:18:34.555] Searching for globals...
[10:18:34.555] 
[10:18:34.555] Searching for globals ... DONE
[10:18:34.556] - globals: [0] <none>
[10:18:34.556] getGlobalsAndPackages() ... DONE
[10:18:34.556]    + additional globals found: [n=0] 
[10:18:34.556]    + additional namespaces needed: [n=0] 
[10:18:34.556]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:34.556]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.556]  - seeds: <none>
[10:18:34.557]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.557] getGlobalsAndPackages() ...
[10:18:34.557] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.557] Resolving globals: FALSE
[10:18:34.557] Tweak future expression to call with '...' arguments ...
[10:18:34.558] {
[10:18:34.558]     do.call(function(...) {
[10:18:34.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.558]             on.exit(options(oopts), add = TRUE)
[10:18:34.558]         }
[10:18:34.558]         {
[10:18:34.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.558]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.558]             })
[10:18:34.558]         }
[10:18:34.558]     }, args = future.call.arguments)
[10:18:34.558] }
[10:18:34.558] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.559] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.559] 
[10:18:34.559] getGlobalsAndPackages() ... DONE
[10:18:34.560] run() for ‘Future’ ...
[10:18:34.560] - state: ‘created’
[10:18:34.560] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.563] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.564]   - Field: ‘label’
[10:18:34.564]   - Field: ‘local’
[10:18:34.564]   - Field: ‘owner’
[10:18:34.564]   - Field: ‘envir’
[10:18:34.564]   - Field: ‘workers’
[10:18:34.565]   - Field: ‘packages’
[10:18:34.565]   - Field: ‘gc’
[10:18:34.565]   - Field: ‘job’
[10:18:34.565]   - Field: ‘conditions’
[10:18:34.565]   - Field: ‘expr’
[10:18:34.566]   - Field: ‘uuid’
[10:18:34.566]   - Field: ‘seed’
[10:18:34.566]   - Field: ‘version’
[10:18:34.566]   - Field: ‘result’
[10:18:34.566]   - Field: ‘asynchronous’
[10:18:34.566]   - Field: ‘calls’
[10:18:34.567]   - Field: ‘globals’
[10:18:34.567]   - Field: ‘stdout’
[10:18:34.567]   - Field: ‘earlySignal’
[10:18:34.567]   - Field: ‘lazy’
[10:18:34.567]   - Field: ‘state’
[10:18:34.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.567] - Launch lazy future ...
[10:18:34.568] Packages needed by the future expression (n = 0): <none>
[10:18:34.568] Packages needed by future strategies (n = 0): <none>
[10:18:34.569] {
[10:18:34.569]     {
[10:18:34.569]         {
[10:18:34.569]             ...future.startTime <- base::Sys.time()
[10:18:34.569]             {
[10:18:34.569]                 {
[10:18:34.569]                   {
[10:18:34.569]                     {
[10:18:34.569]                       base::local({
[10:18:34.569]                         has_future <- base::requireNamespace("future", 
[10:18:34.569]                           quietly = TRUE)
[10:18:34.569]                         if (has_future) {
[10:18:34.569]                           ns <- base::getNamespace("future")
[10:18:34.569]                           version <- ns[[".package"]][["version"]]
[10:18:34.569]                           if (is.null(version)) 
[10:18:34.569]                             version <- utils::packageVersion("future")
[10:18:34.569]                         }
[10:18:34.569]                         else {
[10:18:34.569]                           version <- NULL
[10:18:34.569]                         }
[10:18:34.569]                         if (!has_future || version < "1.8.0") {
[10:18:34.569]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.569]                             "", base::R.version$version.string), 
[10:18:34.569]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:34.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:34.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.569]                               "release", "version")], collapse = " "), 
[10:18:34.569]                             hostname = base::Sys.info()[["nodename"]])
[10:18:34.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.569]                             info)
[10:18:34.569]                           info <- base::paste(info, collapse = "; ")
[10:18:34.569]                           if (!has_future) {
[10:18:34.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.569]                               info)
[10:18:34.569]                           }
[10:18:34.569]                           else {
[10:18:34.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.569]                               info, version)
[10:18:34.569]                           }
[10:18:34.569]                           base::stop(msg)
[10:18:34.569]                         }
[10:18:34.569]                       })
[10:18:34.569]                     }
[10:18:34.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.569]                     base::options(mc.cores = 1L)
[10:18:34.569]                   }
[10:18:34.569]                   ...future.strategy.old <- future::plan("list")
[10:18:34.569]                   options(future.plan = NULL)
[10:18:34.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.569]                 }
[10:18:34.569]                 ...future.workdir <- getwd()
[10:18:34.569]             }
[10:18:34.569]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.569]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.569]         }
[10:18:34.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.569]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.569]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.569]             base::names(...future.oldOptions))
[10:18:34.569]     }
[10:18:34.569]     if (FALSE) {
[10:18:34.569]     }
[10:18:34.569]     else {
[10:18:34.569]         if (TRUE) {
[10:18:34.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.569]                 open = "w")
[10:18:34.569]         }
[10:18:34.569]         else {
[10:18:34.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.569]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.569]         }
[10:18:34.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.569]             base::sink(type = "output", split = FALSE)
[10:18:34.569]             base::close(...future.stdout)
[10:18:34.569]         }, add = TRUE)
[10:18:34.569]     }
[10:18:34.569]     ...future.frame <- base::sys.nframe()
[10:18:34.569]     ...future.conditions <- base::list()
[10:18:34.569]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.569]     if (FALSE) {
[10:18:34.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.569]     }
[10:18:34.569]     ...future.result <- base::tryCatch({
[10:18:34.569]         base::withCallingHandlers({
[10:18:34.569]             ...future.value <- base::withVisible(base::local({
[10:18:34.569]                 withCallingHandlers({
[10:18:34.569]                   {
[10:18:34.569]                     do.call(function(...) {
[10:18:34.569]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.569]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.569]                         ...future.globals.maxSize)) {
[10:18:34.569]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.569]                         on.exit(options(oopts), add = TRUE)
[10:18:34.569]                       }
[10:18:34.569]                       {
[10:18:34.569]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.569]                           FUN = function(jj) {
[10:18:34.569]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.569]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.569]                           })
[10:18:34.569]                       }
[10:18:34.569]                     }, args = future.call.arguments)
[10:18:34.569]                   }
[10:18:34.569]                 }, immediateCondition = function(cond) {
[10:18:34.569]                   save_rds <- function (object, pathname, ...) 
[10:18:34.569]                   {
[10:18:34.569]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.569]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.569]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.569]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.569]                         fi_tmp[["mtime"]])
[10:18:34.569]                     }
[10:18:34.569]                     tryCatch({
[10:18:34.569]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.569]                     }, error = function(ex) {
[10:18:34.569]                       msg <- conditionMessage(ex)
[10:18:34.569]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.569]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.569]                         fi_tmp[["mtime"]], msg)
[10:18:34.569]                       ex$message <- msg
[10:18:34.569]                       stop(ex)
[10:18:34.569]                     })
[10:18:34.569]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.569]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.569]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.569]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.569]                       fi <- file.info(pathname)
[10:18:34.569]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.569]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.569]                         fi[["size"]], fi[["mtime"]])
[10:18:34.569]                       stop(msg)
[10:18:34.569]                     }
[10:18:34.569]                     invisible(pathname)
[10:18:34.569]                   }
[10:18:34.569]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.569]                     rootPath = tempdir()) 
[10:18:34.569]                   {
[10:18:34.569]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.569]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.569]                       tmpdir = path, fileext = ".rds")
[10:18:34.569]                     save_rds(obj, file)
[10:18:34.569]                   }
[10:18:34.569]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.569]                   {
[10:18:34.569]                     inherits <- base::inherits
[10:18:34.569]                     invokeRestart <- base::invokeRestart
[10:18:34.569]                     is.null <- base::is.null
[10:18:34.569]                     muffled <- FALSE
[10:18:34.569]                     if (inherits(cond, "message")) {
[10:18:34.569]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.569]                       if (muffled) 
[10:18:34.569]                         invokeRestart("muffleMessage")
[10:18:34.569]                     }
[10:18:34.569]                     else if (inherits(cond, "warning")) {
[10:18:34.569]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.569]                       if (muffled) 
[10:18:34.569]                         invokeRestart("muffleWarning")
[10:18:34.569]                     }
[10:18:34.569]                     else if (inherits(cond, "condition")) {
[10:18:34.569]                       if (!is.null(pattern)) {
[10:18:34.569]                         computeRestarts <- base::computeRestarts
[10:18:34.569]                         grepl <- base::grepl
[10:18:34.569]                         restarts <- computeRestarts(cond)
[10:18:34.569]                         for (restart in restarts) {
[10:18:34.569]                           name <- restart$name
[10:18:34.569]                           if (is.null(name)) 
[10:18:34.569]                             next
[10:18:34.569]                           if (!grepl(pattern, name)) 
[10:18:34.569]                             next
[10:18:34.569]                           invokeRestart(restart)
[10:18:34.569]                           muffled <- TRUE
[10:18:34.569]                           break
[10:18:34.569]                         }
[10:18:34.569]                       }
[10:18:34.569]                     }
[10:18:34.569]                     invisible(muffled)
[10:18:34.569]                   }
[10:18:34.569]                   muffleCondition(cond)
[10:18:34.569]                 })
[10:18:34.569]             }))
[10:18:34.569]             future::FutureResult(value = ...future.value$value, 
[10:18:34.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.569]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.569]                     ...future.globalenv.names))
[10:18:34.569]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.569]         }, condition = base::local({
[10:18:34.569]             c <- base::c
[10:18:34.569]             inherits <- base::inherits
[10:18:34.569]             invokeRestart <- base::invokeRestart
[10:18:34.569]             length <- base::length
[10:18:34.569]             list <- base::list
[10:18:34.569]             seq.int <- base::seq.int
[10:18:34.569]             signalCondition <- base::signalCondition
[10:18:34.569]             sys.calls <- base::sys.calls
[10:18:34.569]             `[[` <- base::`[[`
[10:18:34.569]             `+` <- base::`+`
[10:18:34.569]             `<<-` <- base::`<<-`
[10:18:34.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.569]                   3L)]
[10:18:34.569]             }
[10:18:34.569]             function(cond) {
[10:18:34.569]                 is_error <- inherits(cond, "error")
[10:18:34.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.569]                   NULL)
[10:18:34.569]                 if (is_error) {
[10:18:34.569]                   sessionInformation <- function() {
[10:18:34.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.569]                       search = base::search(), system = base::Sys.info())
[10:18:34.569]                   }
[10:18:34.569]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.569]                     cond$call), session = sessionInformation(), 
[10:18:34.569]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.569]                   signalCondition(cond)
[10:18:34.569]                 }
[10:18:34.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.569]                 "immediateCondition"))) {
[10:18:34.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.569]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.569]                   if (TRUE && !signal) {
[10:18:34.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.569]                     {
[10:18:34.569]                       inherits <- base::inherits
[10:18:34.569]                       invokeRestart <- base::invokeRestart
[10:18:34.569]                       is.null <- base::is.null
[10:18:34.569]                       muffled <- FALSE
[10:18:34.569]                       if (inherits(cond, "message")) {
[10:18:34.569]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.569]                         if (muffled) 
[10:18:34.569]                           invokeRestart("muffleMessage")
[10:18:34.569]                       }
[10:18:34.569]                       else if (inherits(cond, "warning")) {
[10:18:34.569]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.569]                         if (muffled) 
[10:18:34.569]                           invokeRestart("muffleWarning")
[10:18:34.569]                       }
[10:18:34.569]                       else if (inherits(cond, "condition")) {
[10:18:34.569]                         if (!is.null(pattern)) {
[10:18:34.569]                           computeRestarts <- base::computeRestarts
[10:18:34.569]                           grepl <- base::grepl
[10:18:34.569]                           restarts <- computeRestarts(cond)
[10:18:34.569]                           for (restart in restarts) {
[10:18:34.569]                             name <- restart$name
[10:18:34.569]                             if (is.null(name)) 
[10:18:34.569]                               next
[10:18:34.569]                             if (!grepl(pattern, name)) 
[10:18:34.569]                               next
[10:18:34.569]                             invokeRestart(restart)
[10:18:34.569]                             muffled <- TRUE
[10:18:34.569]                             break
[10:18:34.569]                           }
[10:18:34.569]                         }
[10:18:34.569]                       }
[10:18:34.569]                       invisible(muffled)
[10:18:34.569]                     }
[10:18:34.569]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.569]                   }
[10:18:34.569]                 }
[10:18:34.569]                 else {
[10:18:34.569]                   if (TRUE) {
[10:18:34.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.569]                     {
[10:18:34.569]                       inherits <- base::inherits
[10:18:34.569]                       invokeRestart <- base::invokeRestart
[10:18:34.569]                       is.null <- base::is.null
[10:18:34.569]                       muffled <- FALSE
[10:18:34.569]                       if (inherits(cond, "message")) {
[10:18:34.569]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.569]                         if (muffled) 
[10:18:34.569]                           invokeRestart("muffleMessage")
[10:18:34.569]                       }
[10:18:34.569]                       else if (inherits(cond, "warning")) {
[10:18:34.569]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.569]                         if (muffled) 
[10:18:34.569]                           invokeRestart("muffleWarning")
[10:18:34.569]                       }
[10:18:34.569]                       else if (inherits(cond, "condition")) {
[10:18:34.569]                         if (!is.null(pattern)) {
[10:18:34.569]                           computeRestarts <- base::computeRestarts
[10:18:34.569]                           grepl <- base::grepl
[10:18:34.569]                           restarts <- computeRestarts(cond)
[10:18:34.569]                           for (restart in restarts) {
[10:18:34.569]                             name <- restart$name
[10:18:34.569]                             if (is.null(name)) 
[10:18:34.569]                               next
[10:18:34.569]                             if (!grepl(pattern, name)) 
[10:18:34.569]                               next
[10:18:34.569]                             invokeRestart(restart)
[10:18:34.569]                             muffled <- TRUE
[10:18:34.569]                             break
[10:18:34.569]                           }
[10:18:34.569]                         }
[10:18:34.569]                       }
[10:18:34.569]                       invisible(muffled)
[10:18:34.569]                     }
[10:18:34.569]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.569]                   }
[10:18:34.569]                 }
[10:18:34.569]             }
[10:18:34.569]         }))
[10:18:34.569]     }, error = function(ex) {
[10:18:34.569]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.569]                 ...future.rng), started = ...future.startTime, 
[10:18:34.569]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.569]             version = "1.8"), class = "FutureResult")
[10:18:34.569]     }, finally = {
[10:18:34.569]         if (!identical(...future.workdir, getwd())) 
[10:18:34.569]             setwd(...future.workdir)
[10:18:34.569]         {
[10:18:34.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.569]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.569]             }
[10:18:34.569]             base::options(...future.oldOptions)
[10:18:34.569]             if (.Platform$OS.type == "windows") {
[10:18:34.569]                 old_names <- names(...future.oldEnvVars)
[10:18:34.569]                 envs <- base::Sys.getenv()
[10:18:34.569]                 names <- names(envs)
[10:18:34.569]                 common <- intersect(names, old_names)
[10:18:34.569]                 added <- setdiff(names, old_names)
[10:18:34.569]                 removed <- setdiff(old_names, names)
[10:18:34.569]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.569]                   envs[common]]
[10:18:34.569]                 NAMES <- toupper(changed)
[10:18:34.569]                 args <- list()
[10:18:34.569]                 for (kk in seq_along(NAMES)) {
[10:18:34.569]                   name <- changed[[kk]]
[10:18:34.569]                   NAME <- NAMES[[kk]]
[10:18:34.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.569]                     next
[10:18:34.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.569]                 }
[10:18:34.569]                 NAMES <- toupper(added)
[10:18:34.569]                 for (kk in seq_along(NAMES)) {
[10:18:34.569]                   name <- added[[kk]]
[10:18:34.569]                   NAME <- NAMES[[kk]]
[10:18:34.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.569]                     next
[10:18:34.569]                   args[[name]] <- ""
[10:18:34.569]                 }
[10:18:34.569]                 NAMES <- toupper(removed)
[10:18:34.569]                 for (kk in seq_along(NAMES)) {
[10:18:34.569]                   name <- removed[[kk]]
[10:18:34.569]                   NAME <- NAMES[[kk]]
[10:18:34.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.569]                     next
[10:18:34.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.569]                 }
[10:18:34.569]                 if (length(args) > 0) 
[10:18:34.569]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.569]             }
[10:18:34.569]             else {
[10:18:34.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.569]             }
[10:18:34.569]             {
[10:18:34.569]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.569]                   0L) {
[10:18:34.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.569]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.569]                   base::options(opts)
[10:18:34.569]                 }
[10:18:34.569]                 {
[10:18:34.569]                   {
[10:18:34.569]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.569]                     NULL
[10:18:34.569]                   }
[10:18:34.569]                   options(future.plan = NULL)
[10:18:34.569]                   if (is.na(NA_character_)) 
[10:18:34.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.569]                     .init = FALSE)
[10:18:34.569]                 }
[10:18:34.569]             }
[10:18:34.569]         }
[10:18:34.569]     })
[10:18:34.569]     if (TRUE) {
[10:18:34.569]         base::sink(type = "output", split = FALSE)
[10:18:34.569]         if (TRUE) {
[10:18:34.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.569]         }
[10:18:34.569]         else {
[10:18:34.569]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.569]         }
[10:18:34.569]         base::close(...future.stdout)
[10:18:34.569]         ...future.stdout <- NULL
[10:18:34.569]     }
[10:18:34.569]     ...future.result$conditions <- ...future.conditions
[10:18:34.569]     ...future.result$finished <- base::Sys.time()
[10:18:34.569]     ...future.result
[10:18:34.569] }
[10:18:34.573] assign_globals() ...
[10:18:34.573] List of 5
[10:18:34.573]  $ ...future.FUN            :function (x, ...)  
[10:18:34.573]  $ future.call.arguments    : list()
[10:18:34.573]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.573]  $ ...future.elements_ii    :List of 2
[10:18:34.573]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.573]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.573]  $ ...future.seeds_ii       : NULL
[10:18:34.573]  $ ...future.globals.maxSize: NULL
[10:18:34.573]  - attr(*, "where")=List of 5
[10:18:34.573]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.573]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.573]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.573]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.573]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.573]  - attr(*, "resolved")= logi FALSE
[10:18:34.573]  - attr(*, "total_size")= num 5249
[10:18:34.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.573]  - attr(*, "already-done")= logi TRUE
[10:18:34.582] - copied ‘...future.FUN’ to environment
[10:18:34.582] - copied ‘future.call.arguments’ to environment
[10:18:34.582] - copied ‘...future.elements_ii’ to environment
[10:18:34.582] - copied ‘...future.seeds_ii’ to environment
[10:18:34.582] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.583] assign_globals() ... done
[10:18:34.583] requestCore(): workers = 2
[10:18:34.593] MulticoreFuture started
[10:18:34.593] - Launch lazy future ... done
[10:18:34.594] run() for ‘MulticoreFuture’ ... done
[10:18:34.594] plan(): Setting new future strategy stack:
[10:18:34.594] Created future:
[10:18:34.594] List of future strategies:
[10:18:34.594] 1. sequential:
[10:18:34.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.594]    - tweaked: FALSE
[10:18:34.594]    - call: NULL
[10:18:34.595] plan(): nbrOfWorkers() = 1
[10:18:34.598] plan(): Setting new future strategy stack:
[10:18:34.598] List of future strategies:
[10:18:34.598] 1. multicore:
[10:18:34.598]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.598]    - tweaked: FALSE
[10:18:34.598]    - call: plan(strategy)
[10:18:34.601] plan(): nbrOfWorkers() = 2
[10:18:34.595] MulticoreFuture:
[10:18:34.595] Label: ‘future_eapply-2’
[10:18:34.595] Expression:
[10:18:34.595] {
[10:18:34.595]     do.call(function(...) {
[10:18:34.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.595]             on.exit(options(oopts), add = TRUE)
[10:18:34.595]         }
[10:18:34.595]         {
[10:18:34.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.595]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.595]             })
[10:18:34.595]         }
[10:18:34.595]     }, args = future.call.arguments)
[10:18:34.595] }
[10:18:34.595] Lazy evaluation: FALSE
[10:18:34.595] Asynchronous evaluation: TRUE
[10:18:34.595] Local evaluation: TRUE
[10:18:34.595] Environment: R_GlobalEnv
[10:18:34.595] Capture standard output: TRUE
[10:18:34.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.595] Globals: 5 objects totaling 629 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 205 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.595] Packages: <none>
[10:18:34.595] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.595] Resolved: TRUE
[10:18:34.595] Value: <not collected>
[10:18:34.595] Conditions captured: <none>
[10:18:34.595] Early signaling: FALSE
[10:18:34.595] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.595] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.603] Chunk #2 of 2 ... DONE
[10:18:34.603] Launching 2 futures (chunks) ... DONE
[10:18:34.603] Resolving 2 futures (chunks) ...
[10:18:34.604] resolve() on list ...
[10:18:34.604]  recursive: 0
[10:18:34.604]  length: 2
[10:18:34.604] 
[10:18:34.605] Future #1
[10:18:34.605] result() for MulticoreFuture ...
[10:18:34.607] result() for MulticoreFuture ...
[10:18:34.608] result() for MulticoreFuture ... done
[10:18:34.608] result() for MulticoreFuture ... done
[10:18:34.608] result() for MulticoreFuture ...
[10:18:34.608] result() for MulticoreFuture ... done
[10:18:34.608] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:34.608] - nx: 2
[10:18:34.609] - relay: TRUE
[10:18:34.609] - stdout: TRUE
[10:18:34.609] - signal: TRUE
[10:18:34.609] - resignal: FALSE
[10:18:34.609] - force: TRUE
[10:18:34.609] - relayed: [n=2] FALSE, FALSE
[10:18:34.609] - queued futures: [n=2] FALSE, FALSE
[10:18:34.610]  - until=1
[10:18:34.610]  - relaying element #1
[10:18:34.610] result() for MulticoreFuture ...
[10:18:34.610] result() for MulticoreFuture ... done
[10:18:34.610] result() for MulticoreFuture ...
[10:18:34.610] result() for MulticoreFuture ... done
[10:18:34.610] result() for MulticoreFuture ...
[10:18:34.611] result() for MulticoreFuture ... done
[10:18:34.611] result() for MulticoreFuture ...
[10:18:34.611] result() for MulticoreFuture ... done
[10:18:34.611] - relayed: [n=2] TRUE, FALSE
[10:18:34.611] - queued futures: [n=2] TRUE, FALSE
[10:18:34.611] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:34.612]  length: 1 (resolved future 1)
[10:18:34.612] Future #2
[10:18:34.612] result() for MulticoreFuture ...
[10:18:34.613] result() for MulticoreFuture ...
[10:18:34.613] result() for MulticoreFuture ... done
[10:18:34.613] result() for MulticoreFuture ... done
[10:18:34.613] result() for MulticoreFuture ...
[10:18:34.613] result() for MulticoreFuture ... done
[10:18:34.613] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:34.613] - nx: 2
[10:18:34.614] - relay: TRUE
[10:18:34.614] - stdout: TRUE
[10:18:34.614] - signal: TRUE
[10:18:34.614] - resignal: FALSE
[10:18:34.614] - force: TRUE
[10:18:34.614] - relayed: [n=2] TRUE, FALSE
[10:18:34.614] - queued futures: [n=2] TRUE, FALSE
[10:18:34.614]  - until=2
[10:18:34.614]  - relaying element #2
[10:18:34.615] result() for MulticoreFuture ...
[10:18:34.615] result() for MulticoreFuture ... done
[10:18:34.615] result() for MulticoreFuture ...
[10:18:34.615] result() for MulticoreFuture ... done
[10:18:34.615] result() for MulticoreFuture ...
[10:18:34.615] result() for MulticoreFuture ... done
[10:18:34.615] result() for MulticoreFuture ...
[10:18:34.615] result() for MulticoreFuture ... done
[10:18:34.616] - relayed: [n=2] TRUE, TRUE
[10:18:34.616] - queued futures: [n=2] TRUE, TRUE
[10:18:34.616] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:34.616]  length: 0 (resolved future 2)
[10:18:34.616] Relaying remaining futures
[10:18:34.616] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.616] - nx: 2
[10:18:34.616] - relay: TRUE
[10:18:34.616] - stdout: TRUE
[10:18:34.617] - signal: TRUE
[10:18:34.617] - resignal: FALSE
[10:18:34.617] - force: TRUE
[10:18:34.617] - relayed: [n=2] TRUE, TRUE
[10:18:34.617] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:34.617] - relayed: [n=2] TRUE, TRUE
[10:18:34.617] - queued futures: [n=2] TRUE, TRUE
[10:18:34.617] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.617] resolve() on list ... DONE
[10:18:34.618] result() for MulticoreFuture ...
[10:18:34.618] result() for MulticoreFuture ... done
[10:18:34.618] result() for MulticoreFuture ...
[10:18:34.618] result() for MulticoreFuture ... done
[10:18:34.618] result() for MulticoreFuture ...
[10:18:34.618] result() for MulticoreFuture ... done
[10:18:34.618] result() for MulticoreFuture ...
[10:18:34.618] result() for MulticoreFuture ... done
[10:18:34.618]  - Number of value chunks collected: 2
[10:18:34.619] Resolving 2 futures (chunks) ... DONE
[10:18:34.619] Reducing values from 2 chunks ...
[10:18:34.619]  - Number of values collected after concatenation: 3
[10:18:34.619]  - Number of values expected: 3
[10:18:34.619] Reducing values from 2 chunks ... DONE
[10:18:34.619] future_lapply() ... DONE
[10:18:34.620] future_lapply() ...
[10:18:34.622] Number of chunks: 2
[10:18:34.623] getGlobalsAndPackagesXApply() ...
[10:18:34.623]  - future.globals: TRUE
[10:18:34.623] getGlobalsAndPackages() ...
[10:18:34.623] Searching for globals...
[10:18:34.624] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.624] Searching for globals ... DONE
[10:18:34.624] Resolving globals: FALSE
[10:18:34.625] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:34.625] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:34.625] - globals: [1] ‘FUN’
[10:18:34.626] - packages: [1] ‘stats’
[10:18:34.626] getGlobalsAndPackages() ... DONE
[10:18:34.626]  - globals found/used: [n=1] ‘FUN’
[10:18:34.626]  - needed namespaces: [n=1] ‘stats’
[10:18:34.626] Finding globals ... DONE
[10:18:34.626]  - use_args: TRUE
[10:18:34.626]  - Getting '...' globals ...
[10:18:34.627] resolve() on list ...
[10:18:34.627]  recursive: 0
[10:18:34.627]  length: 1
[10:18:34.627]  elements: ‘...’
[10:18:34.627]  length: 0 (resolved future 1)
[10:18:34.627] resolve() on list ... DONE
[10:18:34.627]    - '...' content: [n=1] ‘probs’
[10:18:34.627] List of 1
[10:18:34.627]  $ ...:List of 1
[10:18:34.627]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:34.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.627]  - attr(*, "where")=List of 1
[10:18:34.627]   ..$ ...:<environment: 0x56033ca5f450> 
[10:18:34.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.627]  - attr(*, "resolved")= logi TRUE
[10:18:34.627]  - attr(*, "total_size")= num NA
[10:18:34.633]  - Getting '...' globals ... DONE
[10:18:34.633] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.633] List of 2
[10:18:34.633]  $ ...future.FUN:function (x, ...)  
[10:18:34.633]  $ ...          :List of 1
[10:18:34.633]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:34.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.633]  - attr(*, "where")=List of 2
[10:18:34.633]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.633]   ..$ ...          :<environment: 0x56033ca5f450> 
[10:18:34.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.633]  - attr(*, "resolved")= logi FALSE
[10:18:34.633]  - attr(*, "total_size")= num 6525
[10:18:34.637] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:34.637] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.637] Number of futures (= number of chunks): 2
[10:18:34.637] Launching 2 futures (chunks) ...
[10:18:34.637] Chunk #1 of 2 ...
[10:18:34.637]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.637] getGlobalsAndPackages() ...
[10:18:34.637] Searching for globals...
[10:18:34.638] 
[10:18:34.638] Searching for globals ... DONE
[10:18:34.638] - globals: [0] <none>
[10:18:34.638] getGlobalsAndPackages() ... DONE
[10:18:34.638]    + additional globals found: [n=0] 
[10:18:34.638]    + additional namespaces needed: [n=0] 
[10:18:34.638]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.638]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.638]  - seeds: <none>
[10:18:34.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.638] getGlobalsAndPackages() ...
[10:18:34.639] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.639] Resolving globals: FALSE
[10:18:34.639] Tweak future expression to call with '...' arguments ...
[10:18:34.639] {
[10:18:34.639]     do.call(function(...) {
[10:18:34.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.639]             on.exit(options(oopts), add = TRUE)
[10:18:34.639]         }
[10:18:34.639]         {
[10:18:34.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.639]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.639]             })
[10:18:34.639]         }
[10:18:34.639]     }, args = future.call.arguments)
[10:18:34.639] }
[10:18:34.639] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.639] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.640] - packages: [1] ‘stats’
[10:18:34.640] getGlobalsAndPackages() ... DONE
[10:18:34.640] run() for ‘Future’ ...
[10:18:34.640] - state: ‘created’
[10:18:34.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.642] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.642]   - Field: ‘label’
[10:18:34.642]   - Field: ‘local’
[10:18:34.642]   - Field: ‘owner’
[10:18:34.642]   - Field: ‘envir’
[10:18:34.642]   - Field: ‘workers’
[10:18:34.643]   - Field: ‘packages’
[10:18:34.643]   - Field: ‘gc’
[10:18:34.643]   - Field: ‘job’
[10:18:34.643]   - Field: ‘conditions’
[10:18:34.643]   - Field: ‘expr’
[10:18:34.643]   - Field: ‘uuid’
[10:18:34.643]   - Field: ‘seed’
[10:18:34.643]   - Field: ‘version’
[10:18:34.643]   - Field: ‘result’
[10:18:34.643]   - Field: ‘asynchronous’
[10:18:34.643]   - Field: ‘calls’
[10:18:34.643]   - Field: ‘globals’
[10:18:34.644]   - Field: ‘stdout’
[10:18:34.644]   - Field: ‘earlySignal’
[10:18:34.644]   - Field: ‘lazy’
[10:18:34.644]   - Field: ‘state’
[10:18:34.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.644] - Launch lazy future ...
[10:18:34.644] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.644] Packages needed by future strategies (n = 0): <none>
[10:18:34.645] {
[10:18:34.645]     {
[10:18:34.645]         {
[10:18:34.645]             ...future.startTime <- base::Sys.time()
[10:18:34.645]             {
[10:18:34.645]                 {
[10:18:34.645]                   {
[10:18:34.645]                     {
[10:18:34.645]                       {
[10:18:34.645]                         base::local({
[10:18:34.645]                           has_future <- base::requireNamespace("future", 
[10:18:34.645]                             quietly = TRUE)
[10:18:34.645]                           if (has_future) {
[10:18:34.645]                             ns <- base::getNamespace("future")
[10:18:34.645]                             version <- ns[[".package"]][["version"]]
[10:18:34.645]                             if (is.null(version)) 
[10:18:34.645]                               version <- utils::packageVersion("future")
[10:18:34.645]                           }
[10:18:34.645]                           else {
[10:18:34.645]                             version <- NULL
[10:18:34.645]                           }
[10:18:34.645]                           if (!has_future || version < "1.8.0") {
[10:18:34.645]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.645]                               "", base::R.version$version.string), 
[10:18:34.645]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:34.645]                                 base::R.version$platform, 8 * 
[10:18:34.645]                                   base::.Machine$sizeof.pointer), 
[10:18:34.645]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.645]                                 "release", "version")], collapse = " "), 
[10:18:34.645]                               hostname = base::Sys.info()[["nodename"]])
[10:18:34.645]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.645]                               info)
[10:18:34.645]                             info <- base::paste(info, collapse = "; ")
[10:18:34.645]                             if (!has_future) {
[10:18:34.645]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.645]                                 info)
[10:18:34.645]                             }
[10:18:34.645]                             else {
[10:18:34.645]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.645]                                 info, version)
[10:18:34.645]                             }
[10:18:34.645]                             base::stop(msg)
[10:18:34.645]                           }
[10:18:34.645]                         })
[10:18:34.645]                       }
[10:18:34.645]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.645]                       base::options(mc.cores = 1L)
[10:18:34.645]                     }
[10:18:34.645]                     base::local({
[10:18:34.645]                       for (pkg in "stats") {
[10:18:34.645]                         base::loadNamespace(pkg)
[10:18:34.645]                         base::library(pkg, character.only = TRUE)
[10:18:34.645]                       }
[10:18:34.645]                     })
[10:18:34.645]                   }
[10:18:34.645]                   ...future.strategy.old <- future::plan("list")
[10:18:34.645]                   options(future.plan = NULL)
[10:18:34.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.645]                 }
[10:18:34.645]                 ...future.workdir <- getwd()
[10:18:34.645]             }
[10:18:34.645]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.645]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.645]         }
[10:18:34.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.645]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.645]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.645]             base::names(...future.oldOptions))
[10:18:34.645]     }
[10:18:34.645]     if (FALSE) {
[10:18:34.645]     }
[10:18:34.645]     else {
[10:18:34.645]         if (TRUE) {
[10:18:34.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.645]                 open = "w")
[10:18:34.645]         }
[10:18:34.645]         else {
[10:18:34.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.645]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.645]         }
[10:18:34.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.645]             base::sink(type = "output", split = FALSE)
[10:18:34.645]             base::close(...future.stdout)
[10:18:34.645]         }, add = TRUE)
[10:18:34.645]     }
[10:18:34.645]     ...future.frame <- base::sys.nframe()
[10:18:34.645]     ...future.conditions <- base::list()
[10:18:34.645]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.645]     if (FALSE) {
[10:18:34.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.645]     }
[10:18:34.645]     ...future.result <- base::tryCatch({
[10:18:34.645]         base::withCallingHandlers({
[10:18:34.645]             ...future.value <- base::withVisible(base::local({
[10:18:34.645]                 withCallingHandlers({
[10:18:34.645]                   {
[10:18:34.645]                     do.call(function(...) {
[10:18:34.645]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.645]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.645]                         ...future.globals.maxSize)) {
[10:18:34.645]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.645]                         on.exit(options(oopts), add = TRUE)
[10:18:34.645]                       }
[10:18:34.645]                       {
[10:18:34.645]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.645]                           FUN = function(jj) {
[10:18:34.645]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.645]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.645]                           })
[10:18:34.645]                       }
[10:18:34.645]                     }, args = future.call.arguments)
[10:18:34.645]                   }
[10:18:34.645]                 }, immediateCondition = function(cond) {
[10:18:34.645]                   save_rds <- function (object, pathname, ...) 
[10:18:34.645]                   {
[10:18:34.645]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.645]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.645]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.645]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.645]                         fi_tmp[["mtime"]])
[10:18:34.645]                     }
[10:18:34.645]                     tryCatch({
[10:18:34.645]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.645]                     }, error = function(ex) {
[10:18:34.645]                       msg <- conditionMessage(ex)
[10:18:34.645]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.645]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.645]                         fi_tmp[["mtime"]], msg)
[10:18:34.645]                       ex$message <- msg
[10:18:34.645]                       stop(ex)
[10:18:34.645]                     })
[10:18:34.645]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.645]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.645]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.645]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.645]                       fi <- file.info(pathname)
[10:18:34.645]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.645]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.645]                         fi[["size"]], fi[["mtime"]])
[10:18:34.645]                       stop(msg)
[10:18:34.645]                     }
[10:18:34.645]                     invisible(pathname)
[10:18:34.645]                   }
[10:18:34.645]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.645]                     rootPath = tempdir()) 
[10:18:34.645]                   {
[10:18:34.645]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.645]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.645]                       tmpdir = path, fileext = ".rds")
[10:18:34.645]                     save_rds(obj, file)
[10:18:34.645]                   }
[10:18:34.645]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.645]                   {
[10:18:34.645]                     inherits <- base::inherits
[10:18:34.645]                     invokeRestart <- base::invokeRestart
[10:18:34.645]                     is.null <- base::is.null
[10:18:34.645]                     muffled <- FALSE
[10:18:34.645]                     if (inherits(cond, "message")) {
[10:18:34.645]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.645]                       if (muffled) 
[10:18:34.645]                         invokeRestart("muffleMessage")
[10:18:34.645]                     }
[10:18:34.645]                     else if (inherits(cond, "warning")) {
[10:18:34.645]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.645]                       if (muffled) 
[10:18:34.645]                         invokeRestart("muffleWarning")
[10:18:34.645]                     }
[10:18:34.645]                     else if (inherits(cond, "condition")) {
[10:18:34.645]                       if (!is.null(pattern)) {
[10:18:34.645]                         computeRestarts <- base::computeRestarts
[10:18:34.645]                         grepl <- base::grepl
[10:18:34.645]                         restarts <- computeRestarts(cond)
[10:18:34.645]                         for (restart in restarts) {
[10:18:34.645]                           name <- restart$name
[10:18:34.645]                           if (is.null(name)) 
[10:18:34.645]                             next
[10:18:34.645]                           if (!grepl(pattern, name)) 
[10:18:34.645]                             next
[10:18:34.645]                           invokeRestart(restart)
[10:18:34.645]                           muffled <- TRUE
[10:18:34.645]                           break
[10:18:34.645]                         }
[10:18:34.645]                       }
[10:18:34.645]                     }
[10:18:34.645]                     invisible(muffled)
[10:18:34.645]                   }
[10:18:34.645]                   muffleCondition(cond)
[10:18:34.645]                 })
[10:18:34.645]             }))
[10:18:34.645]             future::FutureResult(value = ...future.value$value, 
[10:18:34.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.645]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.645]                     ...future.globalenv.names))
[10:18:34.645]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.645]         }, condition = base::local({
[10:18:34.645]             c <- base::c
[10:18:34.645]             inherits <- base::inherits
[10:18:34.645]             invokeRestart <- base::invokeRestart
[10:18:34.645]             length <- base::length
[10:18:34.645]             list <- base::list
[10:18:34.645]             seq.int <- base::seq.int
[10:18:34.645]             signalCondition <- base::signalCondition
[10:18:34.645]             sys.calls <- base::sys.calls
[10:18:34.645]             `[[` <- base::`[[`
[10:18:34.645]             `+` <- base::`+`
[10:18:34.645]             `<<-` <- base::`<<-`
[10:18:34.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.645]                   3L)]
[10:18:34.645]             }
[10:18:34.645]             function(cond) {
[10:18:34.645]                 is_error <- inherits(cond, "error")
[10:18:34.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.645]                   NULL)
[10:18:34.645]                 if (is_error) {
[10:18:34.645]                   sessionInformation <- function() {
[10:18:34.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.645]                       search = base::search(), system = base::Sys.info())
[10:18:34.645]                   }
[10:18:34.645]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.645]                     cond$call), session = sessionInformation(), 
[10:18:34.645]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.645]                   signalCondition(cond)
[10:18:34.645]                 }
[10:18:34.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.645]                 "immediateCondition"))) {
[10:18:34.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.645]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.645]                   if (TRUE && !signal) {
[10:18:34.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.645]                     {
[10:18:34.645]                       inherits <- base::inherits
[10:18:34.645]                       invokeRestart <- base::invokeRestart
[10:18:34.645]                       is.null <- base::is.null
[10:18:34.645]                       muffled <- FALSE
[10:18:34.645]                       if (inherits(cond, "message")) {
[10:18:34.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.645]                         if (muffled) 
[10:18:34.645]                           invokeRestart("muffleMessage")
[10:18:34.645]                       }
[10:18:34.645]                       else if (inherits(cond, "warning")) {
[10:18:34.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.645]                         if (muffled) 
[10:18:34.645]                           invokeRestart("muffleWarning")
[10:18:34.645]                       }
[10:18:34.645]                       else if (inherits(cond, "condition")) {
[10:18:34.645]                         if (!is.null(pattern)) {
[10:18:34.645]                           computeRestarts <- base::computeRestarts
[10:18:34.645]                           grepl <- base::grepl
[10:18:34.645]                           restarts <- computeRestarts(cond)
[10:18:34.645]                           for (restart in restarts) {
[10:18:34.645]                             name <- restart$name
[10:18:34.645]                             if (is.null(name)) 
[10:18:34.645]                               next
[10:18:34.645]                             if (!grepl(pattern, name)) 
[10:18:34.645]                               next
[10:18:34.645]                             invokeRestart(restart)
[10:18:34.645]                             muffled <- TRUE
[10:18:34.645]                             break
[10:18:34.645]                           }
[10:18:34.645]                         }
[10:18:34.645]                       }
[10:18:34.645]                       invisible(muffled)
[10:18:34.645]                     }
[10:18:34.645]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.645]                   }
[10:18:34.645]                 }
[10:18:34.645]                 else {
[10:18:34.645]                   if (TRUE) {
[10:18:34.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.645]                     {
[10:18:34.645]                       inherits <- base::inherits
[10:18:34.645]                       invokeRestart <- base::invokeRestart
[10:18:34.645]                       is.null <- base::is.null
[10:18:34.645]                       muffled <- FALSE
[10:18:34.645]                       if (inherits(cond, "message")) {
[10:18:34.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.645]                         if (muffled) 
[10:18:34.645]                           invokeRestart("muffleMessage")
[10:18:34.645]                       }
[10:18:34.645]                       else if (inherits(cond, "warning")) {
[10:18:34.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.645]                         if (muffled) 
[10:18:34.645]                           invokeRestart("muffleWarning")
[10:18:34.645]                       }
[10:18:34.645]                       else if (inherits(cond, "condition")) {
[10:18:34.645]                         if (!is.null(pattern)) {
[10:18:34.645]                           computeRestarts <- base::computeRestarts
[10:18:34.645]                           grepl <- base::grepl
[10:18:34.645]                           restarts <- computeRestarts(cond)
[10:18:34.645]                           for (restart in restarts) {
[10:18:34.645]                             name <- restart$name
[10:18:34.645]                             if (is.null(name)) 
[10:18:34.645]                               next
[10:18:34.645]                             if (!grepl(pattern, name)) 
[10:18:34.645]                               next
[10:18:34.645]                             invokeRestart(restart)
[10:18:34.645]                             muffled <- TRUE
[10:18:34.645]                             break
[10:18:34.645]                           }
[10:18:34.645]                         }
[10:18:34.645]                       }
[10:18:34.645]                       invisible(muffled)
[10:18:34.645]                     }
[10:18:34.645]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.645]                   }
[10:18:34.645]                 }
[10:18:34.645]             }
[10:18:34.645]         }))
[10:18:34.645]     }, error = function(ex) {
[10:18:34.645]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.645]                 ...future.rng), started = ...future.startTime, 
[10:18:34.645]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.645]             version = "1.8"), class = "FutureResult")
[10:18:34.645]     }, finally = {
[10:18:34.645]         if (!identical(...future.workdir, getwd())) 
[10:18:34.645]             setwd(...future.workdir)
[10:18:34.645]         {
[10:18:34.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.645]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.645]             }
[10:18:34.645]             base::options(...future.oldOptions)
[10:18:34.645]             if (.Platform$OS.type == "windows") {
[10:18:34.645]                 old_names <- names(...future.oldEnvVars)
[10:18:34.645]                 envs <- base::Sys.getenv()
[10:18:34.645]                 names <- names(envs)
[10:18:34.645]                 common <- intersect(names, old_names)
[10:18:34.645]                 added <- setdiff(names, old_names)
[10:18:34.645]                 removed <- setdiff(old_names, names)
[10:18:34.645]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.645]                   envs[common]]
[10:18:34.645]                 NAMES <- toupper(changed)
[10:18:34.645]                 args <- list()
[10:18:34.645]                 for (kk in seq_along(NAMES)) {
[10:18:34.645]                   name <- changed[[kk]]
[10:18:34.645]                   NAME <- NAMES[[kk]]
[10:18:34.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.645]                     next
[10:18:34.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.645]                 }
[10:18:34.645]                 NAMES <- toupper(added)
[10:18:34.645]                 for (kk in seq_along(NAMES)) {
[10:18:34.645]                   name <- added[[kk]]
[10:18:34.645]                   NAME <- NAMES[[kk]]
[10:18:34.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.645]                     next
[10:18:34.645]                   args[[name]] <- ""
[10:18:34.645]                 }
[10:18:34.645]                 NAMES <- toupper(removed)
[10:18:34.645]                 for (kk in seq_along(NAMES)) {
[10:18:34.645]                   name <- removed[[kk]]
[10:18:34.645]                   NAME <- NAMES[[kk]]
[10:18:34.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.645]                     next
[10:18:34.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.645]                 }
[10:18:34.645]                 if (length(args) > 0) 
[10:18:34.645]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.645]             }
[10:18:34.645]             else {
[10:18:34.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.645]             }
[10:18:34.645]             {
[10:18:34.645]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.645]                   0L) {
[10:18:34.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.645]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.645]                   base::options(opts)
[10:18:34.645]                 }
[10:18:34.645]                 {
[10:18:34.645]                   {
[10:18:34.645]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.645]                     NULL
[10:18:34.645]                   }
[10:18:34.645]                   options(future.plan = NULL)
[10:18:34.645]                   if (is.na(NA_character_)) 
[10:18:34.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.645]                     .init = FALSE)
[10:18:34.645]                 }
[10:18:34.645]             }
[10:18:34.645]         }
[10:18:34.645]     })
[10:18:34.645]     if (TRUE) {
[10:18:34.645]         base::sink(type = "output", split = FALSE)
[10:18:34.645]         if (TRUE) {
[10:18:34.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.645]         }
[10:18:34.645]         else {
[10:18:34.645]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.645]         }
[10:18:34.645]         base::close(...future.stdout)
[10:18:34.645]         ...future.stdout <- NULL
[10:18:34.645]     }
[10:18:34.645]     ...future.result$conditions <- ...future.conditions
[10:18:34.645]     ...future.result$finished <- base::Sys.time()
[10:18:34.645]     ...future.result
[10:18:34.645] }
[10:18:34.648] assign_globals() ...
[10:18:34.648] List of 5
[10:18:34.648]  $ ...future.FUN            :function (x, ...)  
[10:18:34.648]  $ future.call.arguments    :List of 1
[10:18:34.648]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:34.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.648]  $ ...future.elements_ii    :List of 1
[10:18:34.648]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.648]  $ ...future.seeds_ii       : NULL
[10:18:34.648]  $ ...future.globals.maxSize: NULL
[10:18:34.648]  - attr(*, "where")=List of 5
[10:18:34.648]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.648]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.648]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.648]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.648]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.648]  - attr(*, "resolved")= logi FALSE
[10:18:34.648]  - attr(*, "total_size")= num 6525
[10:18:34.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.648]  - attr(*, "already-done")= logi TRUE
[10:18:34.653] - copied ‘...future.FUN’ to environment
[10:18:34.653] - copied ‘future.call.arguments’ to environment
[10:18:34.653] - copied ‘...future.elements_ii’ to environment
[10:18:34.653] - copied ‘...future.seeds_ii’ to environment
[10:18:34.653] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.653] assign_globals() ... done
[10:18:34.653] requestCore(): workers = 2
[10:18:34.655] MulticoreFuture started
[10:18:34.656] - Launch lazy future ... done
[10:18:34.656] run() for ‘MulticoreFuture’ ... done
[10:18:34.656] Created future:
[10:18:34.657] plan(): Setting new future strategy stack:
[10:18:34.657] List of future strategies:
[10:18:34.657] 1. sequential:
[10:18:34.657]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.657]    - tweaked: FALSE
[10:18:34.657]    - call: NULL
[10:18:34.658] plan(): nbrOfWorkers() = 1
[10:18:34.660] plan(): Setting new future strategy stack:
[10:18:34.660] List of future strategies:
[10:18:34.660] 1. multicore:
[10:18:34.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.660]    - tweaked: FALSE
[10:18:34.660]    - call: plan(strategy)
[10:18:34.667] plan(): nbrOfWorkers() = 2
[10:18:34.656] MulticoreFuture:
[10:18:34.656] Label: ‘future_eapply-1’
[10:18:34.656] Expression:
[10:18:34.656] {
[10:18:34.656]     do.call(function(...) {
[10:18:34.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.656]             on.exit(options(oopts), add = TRUE)
[10:18:34.656]         }
[10:18:34.656]         {
[10:18:34.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.656]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.656]             })
[10:18:34.656]         }
[10:18:34.656]     }, args = future.call.arguments)
[10:18:34.656] }
[10:18:34.656] Lazy evaluation: FALSE
[10:18:34.656] Asynchronous evaluation: TRUE
[10:18:34.656] Local evaluation: TRUE
[10:18:34.656] Environment: R_GlobalEnv
[10:18:34.656] Capture standard output: TRUE
[10:18:34.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.656] Globals: 5 objects totaling 637 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.656] Packages: 1 packages (‘stats’)
[10:18:34.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.656] Resolved: TRUE
[10:18:34.656] Value: <not collected>
[10:18:34.656] Conditions captured: <none>
[10:18:34.656] Early signaling: FALSE
[10:18:34.656] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.656] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.668] Chunk #1 of 2 ... DONE
[10:18:34.668] Chunk #2 of 2 ...
[10:18:34.668]  - Finding globals in 'X' for chunk #2 ...
[10:18:34.668] getGlobalsAndPackages() ...
[10:18:34.669] Searching for globals...
[10:18:34.669] 
[10:18:34.669] Searching for globals ... DONE
[10:18:34.669] - globals: [0] <none>
[10:18:34.669] getGlobalsAndPackages() ... DONE
[10:18:34.672]    + additional globals found: [n=0] 
[10:18:34.672]    + additional namespaces needed: [n=0] 
[10:18:34.672]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:34.672]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.672]  - seeds: <none>
[10:18:34.672]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.673] getGlobalsAndPackages() ...
[10:18:34.673] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.673] Resolving globals: FALSE
[10:18:34.673] Tweak future expression to call with '...' arguments ...
[10:18:34.673] {
[10:18:34.673]     do.call(function(...) {
[10:18:34.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.673]             on.exit(options(oopts), add = TRUE)
[10:18:34.673]         }
[10:18:34.673]         {
[10:18:34.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.673]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.673]             })
[10:18:34.673]         }
[10:18:34.673]     }, args = future.call.arguments)
[10:18:34.673] }
[10:18:34.674] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.675] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.675] - packages: [1] ‘stats’
[10:18:34.675] getGlobalsAndPackages() ... DONE
[10:18:34.676] run() for ‘Future’ ...
[10:18:34.676] - state: ‘created’
[10:18:34.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.679] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.679]   - Field: ‘label’
[10:18:34.679]   - Field: ‘local’
[10:18:34.680]   - Field: ‘owner’
[10:18:34.680]   - Field: ‘envir’
[10:18:34.680]   - Field: ‘workers’
[10:18:34.680]   - Field: ‘packages’
[10:18:34.680]   - Field: ‘gc’
[10:18:34.680]   - Field: ‘job’
[10:18:34.680]   - Field: ‘conditions’
[10:18:34.681]   - Field: ‘expr’
[10:18:34.681]   - Field: ‘uuid’
[10:18:34.681]   - Field: ‘seed’
[10:18:34.681]   - Field: ‘version’
[10:18:34.681]   - Field: ‘result’
[10:18:34.681]   - Field: ‘asynchronous’
[10:18:34.681]   - Field: ‘calls’
[10:18:34.682]   - Field: ‘globals’
[10:18:34.682]   - Field: ‘stdout’
[10:18:34.682]   - Field: ‘earlySignal’
[10:18:34.682]   - Field: ‘lazy’
[10:18:34.682]   - Field: ‘state’
[10:18:34.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.682] - Launch lazy future ...
[10:18:34.683] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.683] Packages needed by future strategies (n = 0): <none>
[10:18:34.684] {
[10:18:34.684]     {
[10:18:34.684]         {
[10:18:34.684]             ...future.startTime <- base::Sys.time()
[10:18:34.684]             {
[10:18:34.684]                 {
[10:18:34.684]                   {
[10:18:34.684]                     {
[10:18:34.684]                       {
[10:18:34.684]                         base::local({
[10:18:34.684]                           has_future <- base::requireNamespace("future", 
[10:18:34.684]                             quietly = TRUE)
[10:18:34.684]                           if (has_future) {
[10:18:34.684]                             ns <- base::getNamespace("future")
[10:18:34.684]                             version <- ns[[".package"]][["version"]]
[10:18:34.684]                             if (is.null(version)) 
[10:18:34.684]                               version <- utils::packageVersion("future")
[10:18:34.684]                           }
[10:18:34.684]                           else {
[10:18:34.684]                             version <- NULL
[10:18:34.684]                           }
[10:18:34.684]                           if (!has_future || version < "1.8.0") {
[10:18:34.684]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.684]                               "", base::R.version$version.string), 
[10:18:34.684]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:34.684]                                 base::R.version$platform, 8 * 
[10:18:34.684]                                   base::.Machine$sizeof.pointer), 
[10:18:34.684]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.684]                                 "release", "version")], collapse = " "), 
[10:18:34.684]                               hostname = base::Sys.info()[["nodename"]])
[10:18:34.684]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.684]                               info)
[10:18:34.684]                             info <- base::paste(info, collapse = "; ")
[10:18:34.684]                             if (!has_future) {
[10:18:34.684]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.684]                                 info)
[10:18:34.684]                             }
[10:18:34.684]                             else {
[10:18:34.684]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.684]                                 info, version)
[10:18:34.684]                             }
[10:18:34.684]                             base::stop(msg)
[10:18:34.684]                           }
[10:18:34.684]                         })
[10:18:34.684]                       }
[10:18:34.684]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.684]                       base::options(mc.cores = 1L)
[10:18:34.684]                     }
[10:18:34.684]                     base::local({
[10:18:34.684]                       for (pkg in "stats") {
[10:18:34.684]                         base::loadNamespace(pkg)
[10:18:34.684]                         base::library(pkg, character.only = TRUE)
[10:18:34.684]                       }
[10:18:34.684]                     })
[10:18:34.684]                   }
[10:18:34.684]                   ...future.strategy.old <- future::plan("list")
[10:18:34.684]                   options(future.plan = NULL)
[10:18:34.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.684]                 }
[10:18:34.684]                 ...future.workdir <- getwd()
[10:18:34.684]             }
[10:18:34.684]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.684]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.684]         }
[10:18:34.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.684]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.684]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.684]             base::names(...future.oldOptions))
[10:18:34.684]     }
[10:18:34.684]     if (FALSE) {
[10:18:34.684]     }
[10:18:34.684]     else {
[10:18:34.684]         if (TRUE) {
[10:18:34.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.684]                 open = "w")
[10:18:34.684]         }
[10:18:34.684]         else {
[10:18:34.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.684]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.684]         }
[10:18:34.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.684]             base::sink(type = "output", split = FALSE)
[10:18:34.684]             base::close(...future.stdout)
[10:18:34.684]         }, add = TRUE)
[10:18:34.684]     }
[10:18:34.684]     ...future.frame <- base::sys.nframe()
[10:18:34.684]     ...future.conditions <- base::list()
[10:18:34.684]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.684]     if (FALSE) {
[10:18:34.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.684]     }
[10:18:34.684]     ...future.result <- base::tryCatch({
[10:18:34.684]         base::withCallingHandlers({
[10:18:34.684]             ...future.value <- base::withVisible(base::local({
[10:18:34.684]                 withCallingHandlers({
[10:18:34.684]                   {
[10:18:34.684]                     do.call(function(...) {
[10:18:34.684]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.684]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.684]                         ...future.globals.maxSize)) {
[10:18:34.684]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.684]                         on.exit(options(oopts), add = TRUE)
[10:18:34.684]                       }
[10:18:34.684]                       {
[10:18:34.684]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.684]                           FUN = function(jj) {
[10:18:34.684]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.684]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.684]                           })
[10:18:34.684]                       }
[10:18:34.684]                     }, args = future.call.arguments)
[10:18:34.684]                   }
[10:18:34.684]                 }, immediateCondition = function(cond) {
[10:18:34.684]                   save_rds <- function (object, pathname, ...) 
[10:18:34.684]                   {
[10:18:34.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.684]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.684]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.684]                         fi_tmp[["mtime"]])
[10:18:34.684]                     }
[10:18:34.684]                     tryCatch({
[10:18:34.684]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.684]                     }, error = function(ex) {
[10:18:34.684]                       msg <- conditionMessage(ex)
[10:18:34.684]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.684]                         fi_tmp[["mtime"]], msg)
[10:18:34.684]                       ex$message <- msg
[10:18:34.684]                       stop(ex)
[10:18:34.684]                     })
[10:18:34.684]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.684]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.684]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.684]                       fi <- file.info(pathname)
[10:18:34.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.684]                         fi[["size"]], fi[["mtime"]])
[10:18:34.684]                       stop(msg)
[10:18:34.684]                     }
[10:18:34.684]                     invisible(pathname)
[10:18:34.684]                   }
[10:18:34.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.684]                     rootPath = tempdir()) 
[10:18:34.684]                   {
[10:18:34.684]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.684]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.684]                       tmpdir = path, fileext = ".rds")
[10:18:34.684]                     save_rds(obj, file)
[10:18:34.684]                   }
[10:18:34.684]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.684]                   {
[10:18:34.684]                     inherits <- base::inherits
[10:18:34.684]                     invokeRestart <- base::invokeRestart
[10:18:34.684]                     is.null <- base::is.null
[10:18:34.684]                     muffled <- FALSE
[10:18:34.684]                     if (inherits(cond, "message")) {
[10:18:34.684]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.684]                       if (muffled) 
[10:18:34.684]                         invokeRestart("muffleMessage")
[10:18:34.684]                     }
[10:18:34.684]                     else if (inherits(cond, "warning")) {
[10:18:34.684]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.684]                       if (muffled) 
[10:18:34.684]                         invokeRestart("muffleWarning")
[10:18:34.684]                     }
[10:18:34.684]                     else if (inherits(cond, "condition")) {
[10:18:34.684]                       if (!is.null(pattern)) {
[10:18:34.684]                         computeRestarts <- base::computeRestarts
[10:18:34.684]                         grepl <- base::grepl
[10:18:34.684]                         restarts <- computeRestarts(cond)
[10:18:34.684]                         for (restart in restarts) {
[10:18:34.684]                           name <- restart$name
[10:18:34.684]                           if (is.null(name)) 
[10:18:34.684]                             next
[10:18:34.684]                           if (!grepl(pattern, name)) 
[10:18:34.684]                             next
[10:18:34.684]                           invokeRestart(restart)
[10:18:34.684]                           muffled <- TRUE
[10:18:34.684]                           break
[10:18:34.684]                         }
[10:18:34.684]                       }
[10:18:34.684]                     }
[10:18:34.684]                     invisible(muffled)
[10:18:34.684]                   }
[10:18:34.684]                   muffleCondition(cond)
[10:18:34.684]                 })
[10:18:34.684]             }))
[10:18:34.684]             future::FutureResult(value = ...future.value$value, 
[10:18:34.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.684]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.684]                     ...future.globalenv.names))
[10:18:34.684]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.684]         }, condition = base::local({
[10:18:34.684]             c <- base::c
[10:18:34.684]             inherits <- base::inherits
[10:18:34.684]             invokeRestart <- base::invokeRestart
[10:18:34.684]             length <- base::length
[10:18:34.684]             list <- base::list
[10:18:34.684]             seq.int <- base::seq.int
[10:18:34.684]             signalCondition <- base::signalCondition
[10:18:34.684]             sys.calls <- base::sys.calls
[10:18:34.684]             `[[` <- base::`[[`
[10:18:34.684]             `+` <- base::`+`
[10:18:34.684]             `<<-` <- base::`<<-`
[10:18:34.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.684]                   3L)]
[10:18:34.684]             }
[10:18:34.684]             function(cond) {
[10:18:34.684]                 is_error <- inherits(cond, "error")
[10:18:34.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.684]                   NULL)
[10:18:34.684]                 if (is_error) {
[10:18:34.684]                   sessionInformation <- function() {
[10:18:34.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.684]                       search = base::search(), system = base::Sys.info())
[10:18:34.684]                   }
[10:18:34.684]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.684]                     cond$call), session = sessionInformation(), 
[10:18:34.684]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.684]                   signalCondition(cond)
[10:18:34.684]                 }
[10:18:34.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.684]                 "immediateCondition"))) {
[10:18:34.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.684]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.684]                   if (TRUE && !signal) {
[10:18:34.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.684]                     {
[10:18:34.684]                       inherits <- base::inherits
[10:18:34.684]                       invokeRestart <- base::invokeRestart
[10:18:34.684]                       is.null <- base::is.null
[10:18:34.684]                       muffled <- FALSE
[10:18:34.684]                       if (inherits(cond, "message")) {
[10:18:34.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.684]                         if (muffled) 
[10:18:34.684]                           invokeRestart("muffleMessage")
[10:18:34.684]                       }
[10:18:34.684]                       else if (inherits(cond, "warning")) {
[10:18:34.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.684]                         if (muffled) 
[10:18:34.684]                           invokeRestart("muffleWarning")
[10:18:34.684]                       }
[10:18:34.684]                       else if (inherits(cond, "condition")) {
[10:18:34.684]                         if (!is.null(pattern)) {
[10:18:34.684]                           computeRestarts <- base::computeRestarts
[10:18:34.684]                           grepl <- base::grepl
[10:18:34.684]                           restarts <- computeRestarts(cond)
[10:18:34.684]                           for (restart in restarts) {
[10:18:34.684]                             name <- restart$name
[10:18:34.684]                             if (is.null(name)) 
[10:18:34.684]                               next
[10:18:34.684]                             if (!grepl(pattern, name)) 
[10:18:34.684]                               next
[10:18:34.684]                             invokeRestart(restart)
[10:18:34.684]                             muffled <- TRUE
[10:18:34.684]                             break
[10:18:34.684]                           }
[10:18:34.684]                         }
[10:18:34.684]                       }
[10:18:34.684]                       invisible(muffled)
[10:18:34.684]                     }
[10:18:34.684]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.684]                   }
[10:18:34.684]                 }
[10:18:34.684]                 else {
[10:18:34.684]                   if (TRUE) {
[10:18:34.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.684]                     {
[10:18:34.684]                       inherits <- base::inherits
[10:18:34.684]                       invokeRestart <- base::invokeRestart
[10:18:34.684]                       is.null <- base::is.null
[10:18:34.684]                       muffled <- FALSE
[10:18:34.684]                       if (inherits(cond, "message")) {
[10:18:34.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.684]                         if (muffled) 
[10:18:34.684]                           invokeRestart("muffleMessage")
[10:18:34.684]                       }
[10:18:34.684]                       else if (inherits(cond, "warning")) {
[10:18:34.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.684]                         if (muffled) 
[10:18:34.684]                           invokeRestart("muffleWarning")
[10:18:34.684]                       }
[10:18:34.684]                       else if (inherits(cond, "condition")) {
[10:18:34.684]                         if (!is.null(pattern)) {
[10:18:34.684]                           computeRestarts <- base::computeRestarts
[10:18:34.684]                           grepl <- base::grepl
[10:18:34.684]                           restarts <- computeRestarts(cond)
[10:18:34.684]                           for (restart in restarts) {
[10:18:34.684]                             name <- restart$name
[10:18:34.684]                             if (is.null(name)) 
[10:18:34.684]                               next
[10:18:34.684]                             if (!grepl(pattern, name)) 
[10:18:34.684]                               next
[10:18:34.684]                             invokeRestart(restart)
[10:18:34.684]                             muffled <- TRUE
[10:18:34.684]                             break
[10:18:34.684]                           }
[10:18:34.684]                         }
[10:18:34.684]                       }
[10:18:34.684]                       invisible(muffled)
[10:18:34.684]                     }
[10:18:34.684]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.684]                   }
[10:18:34.684]                 }
[10:18:34.684]             }
[10:18:34.684]         }))
[10:18:34.684]     }, error = function(ex) {
[10:18:34.684]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.684]                 ...future.rng), started = ...future.startTime, 
[10:18:34.684]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.684]             version = "1.8"), class = "FutureResult")
[10:18:34.684]     }, finally = {
[10:18:34.684]         if (!identical(...future.workdir, getwd())) 
[10:18:34.684]             setwd(...future.workdir)
[10:18:34.684]         {
[10:18:34.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.684]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.684]             }
[10:18:34.684]             base::options(...future.oldOptions)
[10:18:34.684]             if (.Platform$OS.type == "windows") {
[10:18:34.684]                 old_names <- names(...future.oldEnvVars)
[10:18:34.684]                 envs <- base::Sys.getenv()
[10:18:34.684]                 names <- names(envs)
[10:18:34.684]                 common <- intersect(names, old_names)
[10:18:34.684]                 added <- setdiff(names, old_names)
[10:18:34.684]                 removed <- setdiff(old_names, names)
[10:18:34.684]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.684]                   envs[common]]
[10:18:34.684]                 NAMES <- toupper(changed)
[10:18:34.684]                 args <- list()
[10:18:34.684]                 for (kk in seq_along(NAMES)) {
[10:18:34.684]                   name <- changed[[kk]]
[10:18:34.684]                   NAME <- NAMES[[kk]]
[10:18:34.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.684]                     next
[10:18:34.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.684]                 }
[10:18:34.684]                 NAMES <- toupper(added)
[10:18:34.684]                 for (kk in seq_along(NAMES)) {
[10:18:34.684]                   name <- added[[kk]]
[10:18:34.684]                   NAME <- NAMES[[kk]]
[10:18:34.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.684]                     next
[10:18:34.684]                   args[[name]] <- ""
[10:18:34.684]                 }
[10:18:34.684]                 NAMES <- toupper(removed)
[10:18:34.684]                 for (kk in seq_along(NAMES)) {
[10:18:34.684]                   name <- removed[[kk]]
[10:18:34.684]                   NAME <- NAMES[[kk]]
[10:18:34.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.684]                     next
[10:18:34.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.684]                 }
[10:18:34.684]                 if (length(args) > 0) 
[10:18:34.684]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.684]             }
[10:18:34.684]             else {
[10:18:34.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.684]             }
[10:18:34.684]             {
[10:18:34.684]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.684]                   0L) {
[10:18:34.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.684]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.684]                   base::options(opts)
[10:18:34.684]                 }
[10:18:34.684]                 {
[10:18:34.684]                   {
[10:18:34.684]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.684]                     NULL
[10:18:34.684]                   }
[10:18:34.684]                   options(future.plan = NULL)
[10:18:34.684]                   if (is.na(NA_character_)) 
[10:18:34.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.684]                     .init = FALSE)
[10:18:34.684]                 }
[10:18:34.684]             }
[10:18:34.684]         }
[10:18:34.684]     })
[10:18:34.684]     if (TRUE) {
[10:18:34.684]         base::sink(type = "output", split = FALSE)
[10:18:34.684]         if (TRUE) {
[10:18:34.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.684]         }
[10:18:34.684]         else {
[10:18:34.684]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.684]         }
[10:18:34.684]         base::close(...future.stdout)
[10:18:34.684]         ...future.stdout <- NULL
[10:18:34.684]     }
[10:18:34.684]     ...future.result$conditions <- ...future.conditions
[10:18:34.684]     ...future.result$finished <- base::Sys.time()
[10:18:34.684]     ...future.result
[10:18:34.684] }
[10:18:34.687] assign_globals() ...
[10:18:34.687] List of 5
[10:18:34.687]  $ ...future.FUN            :function (x, ...)  
[10:18:34.687]  $ future.call.arguments    :List of 1
[10:18:34.687]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:34.687]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.687]  $ ...future.elements_ii    :List of 2
[10:18:34.687]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.687]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.687]  $ ...future.seeds_ii       : NULL
[10:18:34.687]  $ ...future.globals.maxSize: NULL
[10:18:34.687]  - attr(*, "where")=List of 5
[10:18:34.687]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.687]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.687]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.687]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.687]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.687]  - attr(*, "resolved")= logi FALSE
[10:18:34.687]  - attr(*, "total_size")= num 6525
[10:18:34.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.687]  - attr(*, "already-done")= logi TRUE
[10:18:34.695] - copied ‘...future.FUN’ to environment
[10:18:34.695] - copied ‘future.call.arguments’ to environment
[10:18:34.695] - copied ‘...future.elements_ii’ to environment
[10:18:34.695] - copied ‘...future.seeds_ii’ to environment
[10:18:34.695] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.695] assign_globals() ... done
[10:18:34.696] requestCore(): workers = 2
[10:18:34.698] MulticoreFuture started
[10:18:34.698] - Launch lazy future ... done
[10:18:34.699] run() for ‘MulticoreFuture’ ... done
[10:18:34.699] Created future:
[10:18:34.700] plan(): Setting new future strategy stack:
[10:18:34.700] List of future strategies:
[10:18:34.700] 1. sequential:
[10:18:34.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.700]    - tweaked: FALSE
[10:18:34.700]    - call: NULL
[10:18:34.701] plan(): nbrOfWorkers() = 1
[10:18:34.703] plan(): Setting new future strategy stack:
[10:18:34.703] List of future strategies:
[10:18:34.703] 1. multicore:
[10:18:34.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.703]    - tweaked: FALSE
[10:18:34.703]    - call: plan(strategy)
[10:18:34.707] plan(): nbrOfWorkers() = 2
[10:18:34.699] MulticoreFuture:
[10:18:34.699] Label: ‘future_eapply-2’
[10:18:34.699] Expression:
[10:18:34.699] {
[10:18:34.699]     do.call(function(...) {
[10:18:34.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.699]             on.exit(options(oopts), add = TRUE)
[10:18:34.699]         }
[10:18:34.699]         {
[10:18:34.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.699]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.699]             })
[10:18:34.699]         }
[10:18:34.699]     }, args = future.call.arguments)
[10:18:34.699] }
[10:18:34.699] Lazy evaluation: FALSE
[10:18:34.699] Asynchronous evaluation: TRUE
[10:18:34.699] Local evaluation: TRUE
[10:18:34.699] Environment: R_GlobalEnv
[10:18:34.699] Capture standard output: TRUE
[10:18:34.699] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.699] Globals: 5 objects totaling 795 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.699] Packages: 1 packages (‘stats’)
[10:18:34.699] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.699] Resolved: TRUE
[10:18:34.699] Value: <not collected>
[10:18:34.699] Conditions captured: <none>
[10:18:34.699] Early signaling: FALSE
[10:18:34.699] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.699] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.708] Chunk #2 of 2 ... DONE
[10:18:34.708] Launching 2 futures (chunks) ... DONE
[10:18:34.708] Resolving 2 futures (chunks) ...
[10:18:34.708] resolve() on list ...
[10:18:34.708]  recursive: 0
[10:18:34.708]  length: 2
[10:18:34.708] 
[10:18:34.709] Future #1
[10:18:34.709] result() for MulticoreFuture ...
[10:18:34.710] result() for MulticoreFuture ...
[10:18:34.710] result() for MulticoreFuture ... done
[10:18:34.710] result() for MulticoreFuture ... done
[10:18:34.711] result() for MulticoreFuture ...
[10:18:34.711] result() for MulticoreFuture ... done
[10:18:34.711] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:34.711] - nx: 2
[10:18:34.711] - relay: TRUE
[10:18:34.711] - stdout: TRUE
[10:18:34.711] - signal: TRUE
[10:18:34.711] - resignal: FALSE
[10:18:34.712] - force: TRUE
[10:18:34.712] - relayed: [n=2] FALSE, FALSE
[10:18:34.712] - queued futures: [n=2] FALSE, FALSE
[10:18:34.712]  - until=1
[10:18:34.712]  - relaying element #1
[10:18:34.712] result() for MulticoreFuture ...
[10:18:34.712] result() for MulticoreFuture ... done
[10:18:34.712] result() for MulticoreFuture ...
[10:18:34.713] result() for MulticoreFuture ... done
[10:18:34.713] result() for MulticoreFuture ...
[10:18:34.713] result() for MulticoreFuture ... done
[10:18:34.713] result() for MulticoreFuture ...
[10:18:34.713] result() for MulticoreFuture ... done
[10:18:34.713] - relayed: [n=2] TRUE, FALSE
[10:18:34.713] - queued futures: [n=2] TRUE, FALSE
[10:18:34.714] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:34.714]  length: 1 (resolved future 1)
[10:18:34.714] Future #2
[10:18:34.714] result() for MulticoreFuture ...
[10:18:34.715] result() for MulticoreFuture ...
[10:18:34.715] result() for MulticoreFuture ... done
[10:18:34.715] result() for MulticoreFuture ... done
[10:18:34.715] result() for MulticoreFuture ...
[10:18:34.715] result() for MulticoreFuture ... done
[10:18:34.716] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:34.716] - nx: 2
[10:18:34.716] - relay: TRUE
[10:18:34.716] - stdout: TRUE
[10:18:34.716] - signal: TRUE
[10:18:34.716] - resignal: FALSE
[10:18:34.716] - force: TRUE
[10:18:34.716] - relayed: [n=2] TRUE, FALSE
[10:18:34.716] - queued futures: [n=2] TRUE, FALSE
[10:18:34.717]  - until=2
[10:18:34.717]  - relaying element #2
[10:18:34.719] result() for MulticoreFuture ...
[10:18:34.719] result() for MulticoreFuture ... done
[10:18:34.719] result() for MulticoreFuture ...
[10:18:34.720] result() for MulticoreFuture ... done
[10:18:34.720] result() for MulticoreFuture ...
[10:18:34.720] result() for MulticoreFuture ... done
[10:18:34.720] result() for MulticoreFuture ...
[10:18:34.720] result() for MulticoreFuture ... done
[10:18:34.720] - relayed: [n=2] TRUE, TRUE
[10:18:34.720] - queued futures: [n=2] TRUE, TRUE
[10:18:34.720] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:34.721]  length: 0 (resolved future 2)
[10:18:34.721] Relaying remaining futures
[10:18:34.721] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.721] - nx: 2
[10:18:34.721] - relay: TRUE
[10:18:34.721] - stdout: TRUE
[10:18:34.721] - signal: TRUE
[10:18:34.721] - resignal: FALSE
[10:18:34.722] - force: TRUE
[10:18:34.722] - relayed: [n=2] TRUE, TRUE
[10:18:34.722] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:34.722] - relayed: [n=2] TRUE, TRUE
[10:18:34.722] - queued futures: [n=2] TRUE, TRUE
[10:18:34.722] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.722] resolve() on list ... DONE
[10:18:34.722] result() for MulticoreFuture ...
[10:18:34.723] result() for MulticoreFuture ... done
[10:18:34.723] result() for MulticoreFuture ...
[10:18:34.723] result() for MulticoreFuture ... done
[10:18:34.723] result() for MulticoreFuture ...
[10:18:34.723] result() for MulticoreFuture ... done
[10:18:34.723] result() for MulticoreFuture ...
[10:18:34.723] result() for MulticoreFuture ... done
[10:18:34.723]  - Number of value chunks collected: 2
[10:18:34.724] Resolving 2 futures (chunks) ... DONE
[10:18:34.724] Reducing values from 2 chunks ...
[10:18:34.724]  - Number of values collected after concatenation: 3
[10:18:34.724]  - Number of values expected: 3
[10:18:34.724] Reducing values from 2 chunks ... DONE
[10:18:34.724] future_lapply() ... DONE
[10:18:34.725] future_lapply() ...
[10:18:34.728] Number of chunks: 2
[10:18:34.728] getGlobalsAndPackagesXApply() ...
[10:18:34.728]  - future.globals: TRUE
[10:18:34.728] getGlobalsAndPackages() ...
[10:18:34.728] Searching for globals...
[10:18:34.730] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.730] Searching for globals ... DONE
[10:18:34.730] Resolving globals: FALSE
[10:18:34.730] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:34.731] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:34.731] - globals: [1] ‘FUN’
[10:18:34.731] - packages: [1] ‘stats’
[10:18:34.731] getGlobalsAndPackages() ... DONE
[10:18:34.731]  - globals found/used: [n=1] ‘FUN’
[10:18:34.731]  - needed namespaces: [n=1] ‘stats’
[10:18:34.732] Finding globals ... DONE
[10:18:34.732]  - use_args: TRUE
[10:18:34.732]  - Getting '...' globals ...
[10:18:34.732] resolve() on list ...
[10:18:34.732]  recursive: 0
[10:18:34.732]  length: 1
[10:18:34.733]  elements: ‘...’
[10:18:34.733]  length: 0 (resolved future 1)
[10:18:34.733] resolve() on list ... DONE
[10:18:34.733]    - '...' content: [n=0] 
[10:18:34.733] List of 1
[10:18:34.733]  $ ...: list()
[10:18:34.733]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.733]  - attr(*, "where")=List of 1
[10:18:34.733]   ..$ ...:<environment: 0x56033a6ba818> 
[10:18:34.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.733]  - attr(*, "resolved")= logi TRUE
[10:18:34.733]  - attr(*, "total_size")= num NA
[10:18:34.736]  - Getting '...' globals ... DONE
[10:18:34.736] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.736] List of 2
[10:18:34.736]  $ ...future.FUN:function (x, ...)  
[10:18:34.736]  $ ...          : list()
[10:18:34.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.736]  - attr(*, "where")=List of 2
[10:18:34.736]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.736]   ..$ ...          :<environment: 0x56033a6ba818> 
[10:18:34.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.736]  - attr(*, "resolved")= logi FALSE
[10:18:34.736]  - attr(*, "total_size")= num 5433
[10:18:34.739] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:34.739] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.739] Number of futures (= number of chunks): 2
[10:18:34.739] Launching 2 futures (chunks) ...
[10:18:34.740] Chunk #1 of 2 ...
[10:18:34.740]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.740] getGlobalsAndPackages() ...
[10:18:34.740] Searching for globals...
[10:18:34.740] 
[10:18:34.740] Searching for globals ... DONE
[10:18:34.740] - globals: [0] <none>
[10:18:34.740] getGlobalsAndPackages() ... DONE
[10:18:34.740]    + additional globals found: [n=0] 
[10:18:34.741]    + additional namespaces needed: [n=0] 
[10:18:34.741]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.741]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.741]  - seeds: <none>
[10:18:34.741]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.741] getGlobalsAndPackages() ...
[10:18:34.741] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.741] Resolving globals: FALSE
[10:18:34.741] Tweak future expression to call with '...' arguments ...
[10:18:34.741] {
[10:18:34.741]     do.call(function(...) {
[10:18:34.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.741]             on.exit(options(oopts), add = TRUE)
[10:18:34.741]         }
[10:18:34.741]         {
[10:18:34.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.741]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.741]             })
[10:18:34.741]         }
[10:18:34.741]     }, args = future.call.arguments)
[10:18:34.741] }
[10:18:34.742] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.742] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.742] - packages: [1] ‘stats’
[10:18:34.742] getGlobalsAndPackages() ... DONE
[10:18:34.743] run() for ‘Future’ ...
[10:18:34.743] - state: ‘created’
[10:18:34.743] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.745] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.747]   - Field: ‘label’
[10:18:34.747]   - Field: ‘local’
[10:18:34.747]   - Field: ‘owner’
[10:18:34.747]   - Field: ‘envir’
[10:18:34.747]   - Field: ‘workers’
[10:18:34.747]   - Field: ‘packages’
[10:18:34.747]   - Field: ‘gc’
[10:18:34.747]   - Field: ‘job’
[10:18:34.747]   - Field: ‘conditions’
[10:18:34.748]   - Field: ‘expr’
[10:18:34.748]   - Field: ‘uuid’
[10:18:34.748]   - Field: ‘seed’
[10:18:34.748]   - Field: ‘version’
[10:18:34.748]   - Field: ‘result’
[10:18:34.748]   - Field: ‘asynchronous’
[10:18:34.748]   - Field: ‘calls’
[10:18:34.748]   - Field: ‘globals’
[10:18:34.748]   - Field: ‘stdout’
[10:18:34.748]   - Field: ‘earlySignal’
[10:18:34.748]   - Field: ‘lazy’
[10:18:34.748]   - Field: ‘state’
[10:18:34.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.749] - Launch lazy future ...
[10:18:34.749] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.749] Packages needed by future strategies (n = 0): <none>
[10:18:34.750] {
[10:18:34.750]     {
[10:18:34.750]         {
[10:18:34.750]             ...future.startTime <- base::Sys.time()
[10:18:34.750]             {
[10:18:34.750]                 {
[10:18:34.750]                   {
[10:18:34.750]                     {
[10:18:34.750]                       {
[10:18:34.750]                         base::local({
[10:18:34.750]                           has_future <- base::requireNamespace("future", 
[10:18:34.750]                             quietly = TRUE)
[10:18:34.750]                           if (has_future) {
[10:18:34.750]                             ns <- base::getNamespace("future")
[10:18:34.750]                             version <- ns[[".package"]][["version"]]
[10:18:34.750]                             if (is.null(version)) 
[10:18:34.750]                               version <- utils::packageVersion("future")
[10:18:34.750]                           }
[10:18:34.750]                           else {
[10:18:34.750]                             version <- NULL
[10:18:34.750]                           }
[10:18:34.750]                           if (!has_future || version < "1.8.0") {
[10:18:34.750]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.750]                               "", base::R.version$version.string), 
[10:18:34.750]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:34.750]                                 base::R.version$platform, 8 * 
[10:18:34.750]                                   base::.Machine$sizeof.pointer), 
[10:18:34.750]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.750]                                 "release", "version")], collapse = " "), 
[10:18:34.750]                               hostname = base::Sys.info()[["nodename"]])
[10:18:34.750]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.750]                               info)
[10:18:34.750]                             info <- base::paste(info, collapse = "; ")
[10:18:34.750]                             if (!has_future) {
[10:18:34.750]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.750]                                 info)
[10:18:34.750]                             }
[10:18:34.750]                             else {
[10:18:34.750]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.750]                                 info, version)
[10:18:34.750]                             }
[10:18:34.750]                             base::stop(msg)
[10:18:34.750]                           }
[10:18:34.750]                         })
[10:18:34.750]                       }
[10:18:34.750]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.750]                       base::options(mc.cores = 1L)
[10:18:34.750]                     }
[10:18:34.750]                     base::local({
[10:18:34.750]                       for (pkg in "stats") {
[10:18:34.750]                         base::loadNamespace(pkg)
[10:18:34.750]                         base::library(pkg, character.only = TRUE)
[10:18:34.750]                       }
[10:18:34.750]                     })
[10:18:34.750]                   }
[10:18:34.750]                   ...future.strategy.old <- future::plan("list")
[10:18:34.750]                   options(future.plan = NULL)
[10:18:34.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.750]                 }
[10:18:34.750]                 ...future.workdir <- getwd()
[10:18:34.750]             }
[10:18:34.750]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.750]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.750]         }
[10:18:34.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.750]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.750]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.750]             base::names(...future.oldOptions))
[10:18:34.750]     }
[10:18:34.750]     if (FALSE) {
[10:18:34.750]     }
[10:18:34.750]     else {
[10:18:34.750]         if (TRUE) {
[10:18:34.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.750]                 open = "w")
[10:18:34.750]         }
[10:18:34.750]         else {
[10:18:34.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.750]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.750]         }
[10:18:34.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.750]             base::sink(type = "output", split = FALSE)
[10:18:34.750]             base::close(...future.stdout)
[10:18:34.750]         }, add = TRUE)
[10:18:34.750]     }
[10:18:34.750]     ...future.frame <- base::sys.nframe()
[10:18:34.750]     ...future.conditions <- base::list()
[10:18:34.750]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.750]     if (FALSE) {
[10:18:34.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.750]     }
[10:18:34.750]     ...future.result <- base::tryCatch({
[10:18:34.750]         base::withCallingHandlers({
[10:18:34.750]             ...future.value <- base::withVisible(base::local({
[10:18:34.750]                 withCallingHandlers({
[10:18:34.750]                   {
[10:18:34.750]                     do.call(function(...) {
[10:18:34.750]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.750]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.750]                         ...future.globals.maxSize)) {
[10:18:34.750]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.750]                         on.exit(options(oopts), add = TRUE)
[10:18:34.750]                       }
[10:18:34.750]                       {
[10:18:34.750]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.750]                           FUN = function(jj) {
[10:18:34.750]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.750]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.750]                           })
[10:18:34.750]                       }
[10:18:34.750]                     }, args = future.call.arguments)
[10:18:34.750]                   }
[10:18:34.750]                 }, immediateCondition = function(cond) {
[10:18:34.750]                   save_rds <- function (object, pathname, ...) 
[10:18:34.750]                   {
[10:18:34.750]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.750]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.750]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.750]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.750]                         fi_tmp[["mtime"]])
[10:18:34.750]                     }
[10:18:34.750]                     tryCatch({
[10:18:34.750]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.750]                     }, error = function(ex) {
[10:18:34.750]                       msg <- conditionMessage(ex)
[10:18:34.750]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.750]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.750]                         fi_tmp[["mtime"]], msg)
[10:18:34.750]                       ex$message <- msg
[10:18:34.750]                       stop(ex)
[10:18:34.750]                     })
[10:18:34.750]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.750]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.750]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.750]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.750]                       fi <- file.info(pathname)
[10:18:34.750]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.750]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.750]                         fi[["size"]], fi[["mtime"]])
[10:18:34.750]                       stop(msg)
[10:18:34.750]                     }
[10:18:34.750]                     invisible(pathname)
[10:18:34.750]                   }
[10:18:34.750]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.750]                     rootPath = tempdir()) 
[10:18:34.750]                   {
[10:18:34.750]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.750]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.750]                       tmpdir = path, fileext = ".rds")
[10:18:34.750]                     save_rds(obj, file)
[10:18:34.750]                   }
[10:18:34.750]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.750]                   {
[10:18:34.750]                     inherits <- base::inherits
[10:18:34.750]                     invokeRestart <- base::invokeRestart
[10:18:34.750]                     is.null <- base::is.null
[10:18:34.750]                     muffled <- FALSE
[10:18:34.750]                     if (inherits(cond, "message")) {
[10:18:34.750]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.750]                       if (muffled) 
[10:18:34.750]                         invokeRestart("muffleMessage")
[10:18:34.750]                     }
[10:18:34.750]                     else if (inherits(cond, "warning")) {
[10:18:34.750]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.750]                       if (muffled) 
[10:18:34.750]                         invokeRestart("muffleWarning")
[10:18:34.750]                     }
[10:18:34.750]                     else if (inherits(cond, "condition")) {
[10:18:34.750]                       if (!is.null(pattern)) {
[10:18:34.750]                         computeRestarts <- base::computeRestarts
[10:18:34.750]                         grepl <- base::grepl
[10:18:34.750]                         restarts <- computeRestarts(cond)
[10:18:34.750]                         for (restart in restarts) {
[10:18:34.750]                           name <- restart$name
[10:18:34.750]                           if (is.null(name)) 
[10:18:34.750]                             next
[10:18:34.750]                           if (!grepl(pattern, name)) 
[10:18:34.750]                             next
[10:18:34.750]                           invokeRestart(restart)
[10:18:34.750]                           muffled <- TRUE
[10:18:34.750]                           break
[10:18:34.750]                         }
[10:18:34.750]                       }
[10:18:34.750]                     }
[10:18:34.750]                     invisible(muffled)
[10:18:34.750]                   }
[10:18:34.750]                   muffleCondition(cond)
[10:18:34.750]                 })
[10:18:34.750]             }))
[10:18:34.750]             future::FutureResult(value = ...future.value$value, 
[10:18:34.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.750]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.750]                     ...future.globalenv.names))
[10:18:34.750]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.750]         }, condition = base::local({
[10:18:34.750]             c <- base::c
[10:18:34.750]             inherits <- base::inherits
[10:18:34.750]             invokeRestart <- base::invokeRestart
[10:18:34.750]             length <- base::length
[10:18:34.750]             list <- base::list
[10:18:34.750]             seq.int <- base::seq.int
[10:18:34.750]             signalCondition <- base::signalCondition
[10:18:34.750]             sys.calls <- base::sys.calls
[10:18:34.750]             `[[` <- base::`[[`
[10:18:34.750]             `+` <- base::`+`
[10:18:34.750]             `<<-` <- base::`<<-`
[10:18:34.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.750]                   3L)]
[10:18:34.750]             }
[10:18:34.750]             function(cond) {
[10:18:34.750]                 is_error <- inherits(cond, "error")
[10:18:34.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.750]                   NULL)
[10:18:34.750]                 if (is_error) {
[10:18:34.750]                   sessionInformation <- function() {
[10:18:34.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.750]                       search = base::search(), system = base::Sys.info())
[10:18:34.750]                   }
[10:18:34.750]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.750]                     cond$call), session = sessionInformation(), 
[10:18:34.750]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.750]                   signalCondition(cond)
[10:18:34.750]                 }
[10:18:34.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.750]                 "immediateCondition"))) {
[10:18:34.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.750]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.750]                   if (TRUE && !signal) {
[10:18:34.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.750]                     {
[10:18:34.750]                       inherits <- base::inherits
[10:18:34.750]                       invokeRestart <- base::invokeRestart
[10:18:34.750]                       is.null <- base::is.null
[10:18:34.750]                       muffled <- FALSE
[10:18:34.750]                       if (inherits(cond, "message")) {
[10:18:34.750]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.750]                         if (muffled) 
[10:18:34.750]                           invokeRestart("muffleMessage")
[10:18:34.750]                       }
[10:18:34.750]                       else if (inherits(cond, "warning")) {
[10:18:34.750]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.750]                         if (muffled) 
[10:18:34.750]                           invokeRestart("muffleWarning")
[10:18:34.750]                       }
[10:18:34.750]                       else if (inherits(cond, "condition")) {
[10:18:34.750]                         if (!is.null(pattern)) {
[10:18:34.750]                           computeRestarts <- base::computeRestarts
[10:18:34.750]                           grepl <- base::grepl
[10:18:34.750]                           restarts <- computeRestarts(cond)
[10:18:34.750]                           for (restart in restarts) {
[10:18:34.750]                             name <- restart$name
[10:18:34.750]                             if (is.null(name)) 
[10:18:34.750]                               next
[10:18:34.750]                             if (!grepl(pattern, name)) 
[10:18:34.750]                               next
[10:18:34.750]                             invokeRestart(restart)
[10:18:34.750]                             muffled <- TRUE
[10:18:34.750]                             break
[10:18:34.750]                           }
[10:18:34.750]                         }
[10:18:34.750]                       }
[10:18:34.750]                       invisible(muffled)
[10:18:34.750]                     }
[10:18:34.750]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.750]                   }
[10:18:34.750]                 }
[10:18:34.750]                 else {
[10:18:34.750]                   if (TRUE) {
[10:18:34.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.750]                     {
[10:18:34.750]                       inherits <- base::inherits
[10:18:34.750]                       invokeRestart <- base::invokeRestart
[10:18:34.750]                       is.null <- base::is.null
[10:18:34.750]                       muffled <- FALSE
[10:18:34.750]                       if (inherits(cond, "message")) {
[10:18:34.750]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.750]                         if (muffled) 
[10:18:34.750]                           invokeRestart("muffleMessage")
[10:18:34.750]                       }
[10:18:34.750]                       else if (inherits(cond, "warning")) {
[10:18:34.750]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.750]                         if (muffled) 
[10:18:34.750]                           invokeRestart("muffleWarning")
[10:18:34.750]                       }
[10:18:34.750]                       else if (inherits(cond, "condition")) {
[10:18:34.750]                         if (!is.null(pattern)) {
[10:18:34.750]                           computeRestarts <- base::computeRestarts
[10:18:34.750]                           grepl <- base::grepl
[10:18:34.750]                           restarts <- computeRestarts(cond)
[10:18:34.750]                           for (restart in restarts) {
[10:18:34.750]                             name <- restart$name
[10:18:34.750]                             if (is.null(name)) 
[10:18:34.750]                               next
[10:18:34.750]                             if (!grepl(pattern, name)) 
[10:18:34.750]                               next
[10:18:34.750]                             invokeRestart(restart)
[10:18:34.750]                             muffled <- TRUE
[10:18:34.750]                             break
[10:18:34.750]                           }
[10:18:34.750]                         }
[10:18:34.750]                       }
[10:18:34.750]                       invisible(muffled)
[10:18:34.750]                     }
[10:18:34.750]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.750]                   }
[10:18:34.750]                 }
[10:18:34.750]             }
[10:18:34.750]         }))
[10:18:34.750]     }, error = function(ex) {
[10:18:34.750]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.750]                 ...future.rng), started = ...future.startTime, 
[10:18:34.750]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.750]             version = "1.8"), class = "FutureResult")
[10:18:34.750]     }, finally = {
[10:18:34.750]         if (!identical(...future.workdir, getwd())) 
[10:18:34.750]             setwd(...future.workdir)
[10:18:34.750]         {
[10:18:34.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.750]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.750]             }
[10:18:34.750]             base::options(...future.oldOptions)
[10:18:34.750]             if (.Platform$OS.type == "windows") {
[10:18:34.750]                 old_names <- names(...future.oldEnvVars)
[10:18:34.750]                 envs <- base::Sys.getenv()
[10:18:34.750]                 names <- names(envs)
[10:18:34.750]                 common <- intersect(names, old_names)
[10:18:34.750]                 added <- setdiff(names, old_names)
[10:18:34.750]                 removed <- setdiff(old_names, names)
[10:18:34.750]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.750]                   envs[common]]
[10:18:34.750]                 NAMES <- toupper(changed)
[10:18:34.750]                 args <- list()
[10:18:34.750]                 for (kk in seq_along(NAMES)) {
[10:18:34.750]                   name <- changed[[kk]]
[10:18:34.750]                   NAME <- NAMES[[kk]]
[10:18:34.750]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.750]                     next
[10:18:34.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.750]                 }
[10:18:34.750]                 NAMES <- toupper(added)
[10:18:34.750]                 for (kk in seq_along(NAMES)) {
[10:18:34.750]                   name <- added[[kk]]
[10:18:34.750]                   NAME <- NAMES[[kk]]
[10:18:34.750]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.750]                     next
[10:18:34.750]                   args[[name]] <- ""
[10:18:34.750]                 }
[10:18:34.750]                 NAMES <- toupper(removed)
[10:18:34.750]                 for (kk in seq_along(NAMES)) {
[10:18:34.750]                   name <- removed[[kk]]
[10:18:34.750]                   NAME <- NAMES[[kk]]
[10:18:34.750]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.750]                     next
[10:18:34.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.750]                 }
[10:18:34.750]                 if (length(args) > 0) 
[10:18:34.750]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.750]             }
[10:18:34.750]             else {
[10:18:34.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.750]             }
[10:18:34.750]             {
[10:18:34.750]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.750]                   0L) {
[10:18:34.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.750]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.750]                   base::options(opts)
[10:18:34.750]                 }
[10:18:34.750]                 {
[10:18:34.750]                   {
[10:18:34.750]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.750]                     NULL
[10:18:34.750]                   }
[10:18:34.750]                   options(future.plan = NULL)
[10:18:34.750]                   if (is.na(NA_character_)) 
[10:18:34.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.750]                     .init = FALSE)
[10:18:34.750]                 }
[10:18:34.750]             }
[10:18:34.750]         }
[10:18:34.750]     })
[10:18:34.750]     if (TRUE) {
[10:18:34.750]         base::sink(type = "output", split = FALSE)
[10:18:34.750]         if (TRUE) {
[10:18:34.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.750]         }
[10:18:34.750]         else {
[10:18:34.750]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.750]         }
[10:18:34.750]         base::close(...future.stdout)
[10:18:34.750]         ...future.stdout <- NULL
[10:18:34.750]     }
[10:18:34.750]     ...future.result$conditions <- ...future.conditions
[10:18:34.750]     ...future.result$finished <- base::Sys.time()
[10:18:34.750]     ...future.result
[10:18:34.750] }
[10:18:34.752] assign_globals() ...
[10:18:34.752] List of 5
[10:18:34.752]  $ ...future.FUN            :function (x, ...)  
[10:18:34.752]  $ future.call.arguments    : list()
[10:18:34.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.752]  $ ...future.elements_ii    :List of 1
[10:18:34.752]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.752]  $ ...future.seeds_ii       : NULL
[10:18:34.752]  $ ...future.globals.maxSize: NULL
[10:18:34.752]  - attr(*, "where")=List of 5
[10:18:34.752]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.752]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.752]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.752]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.752]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.752]  - attr(*, "resolved")= logi FALSE
[10:18:34.752]  - attr(*, "total_size")= num 5433
[10:18:34.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.752]  - attr(*, "already-done")= logi TRUE
[10:18:34.757] - copied ‘...future.FUN’ to environment
[10:18:34.757] - copied ‘future.call.arguments’ to environment
[10:18:34.757] - copied ‘...future.elements_ii’ to environment
[10:18:34.757] - copied ‘...future.seeds_ii’ to environment
[10:18:34.757] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.757] assign_globals() ... done
[10:18:34.757] requestCore(): workers = 2
[10:18:34.760] MulticoreFuture started
[10:18:34.760] - Launch lazy future ... done
[10:18:34.760] run() for ‘MulticoreFuture’ ... done
[10:18:34.761] Created future:
[10:18:34.761] plan(): Setting new future strategy stack:
[10:18:34.761] List of future strategies:
[10:18:34.761] 1. sequential:
[10:18:34.761]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.761]    - tweaked: FALSE
[10:18:34.761]    - call: NULL
[10:18:34.762] plan(): nbrOfWorkers() = 1
[10:18:34.765] plan(): Setting new future strategy stack:
[10:18:34.765] List of future strategies:
[10:18:34.765] 1. multicore:
[10:18:34.765]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.765]    - tweaked: FALSE
[10:18:34.765]    - call: plan(strategy)
[10:18:34.768] plan(): nbrOfWorkers() = 2
[10:18:34.761] MulticoreFuture:
[10:18:34.761] Label: ‘future_eapply-1’
[10:18:34.761] Expression:
[10:18:34.761] {
[10:18:34.761]     do.call(function(...) {
[10:18:34.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.761]             on.exit(options(oopts), add = TRUE)
[10:18:34.761]         }
[10:18:34.761]         {
[10:18:34.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.761]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.761]             })
[10:18:34.761]         }
[10:18:34.761]     }, args = future.call.arguments)
[10:18:34.761] }
[10:18:34.761] Lazy evaluation: FALSE
[10:18:34.761] Asynchronous evaluation: TRUE
[10:18:34.761] Local evaluation: TRUE
[10:18:34.761] Environment: R_GlobalEnv
[10:18:34.761] Capture standard output: TRUE
[10:18:34.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.761] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.761] Packages: 1 packages (‘stats’)
[10:18:34.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.761] Resolved: TRUE
[10:18:34.761] Value: <not collected>
[10:18:34.761] Conditions captured: <none>
[10:18:34.761] Early signaling: FALSE
[10:18:34.761] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.761] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.769] Chunk #1 of 2 ... DONE
[10:18:34.769] Chunk #2 of 2 ...
[10:18:34.770]  - Finding globals in 'X' for chunk #2 ...
[10:18:34.770] getGlobalsAndPackages() ...
[10:18:34.770] Searching for globals...
[10:18:34.770] 
[10:18:34.770] Searching for globals ... DONE
[10:18:34.771] - globals: [0] <none>
[10:18:34.771] getGlobalsAndPackages() ... DONE
[10:18:34.771]    + additional globals found: [n=0] 
[10:18:34.771]    + additional namespaces needed: [n=0] 
[10:18:34.771]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:34.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.771]  - seeds: <none>
[10:18:34.771]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.772] getGlobalsAndPackages() ...
[10:18:34.772] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.772] Resolving globals: FALSE
[10:18:34.772] Tweak future expression to call with '...' arguments ...
[10:18:34.772] {
[10:18:34.772]     do.call(function(...) {
[10:18:34.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.772]             on.exit(options(oopts), add = TRUE)
[10:18:34.772]         }
[10:18:34.772]         {
[10:18:34.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.772]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.772]             })
[10:18:34.772]         }
[10:18:34.772]     }, args = future.call.arguments)
[10:18:34.772] }
[10:18:34.773] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.773] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.773] - packages: [1] ‘stats’
[10:18:34.774] getGlobalsAndPackages() ... DONE
[10:18:34.774] run() for ‘Future’ ...
[10:18:34.774] - state: ‘created’
[10:18:34.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.777]   - Field: ‘label’
[10:18:34.778]   - Field: ‘local’
[10:18:34.778]   - Field: ‘owner’
[10:18:34.778]   - Field: ‘envir’
[10:18:34.778]   - Field: ‘workers’
[10:18:34.778]   - Field: ‘packages’
[10:18:34.778]   - Field: ‘gc’
[10:18:34.778]   - Field: ‘job’
[10:18:34.779]   - Field: ‘conditions’
[10:18:34.779]   - Field: ‘expr’
[10:18:34.779]   - Field: ‘uuid’
[10:18:34.779]   - Field: ‘seed’
[10:18:34.779]   - Field: ‘version’
[10:18:34.779]   - Field: ‘result’
[10:18:34.779]   - Field: ‘asynchronous’
[10:18:34.779]   - Field: ‘calls’
[10:18:34.780]   - Field: ‘globals’
[10:18:34.780]   - Field: ‘stdout’
[10:18:34.780]   - Field: ‘earlySignal’
[10:18:34.780]   - Field: ‘lazy’
[10:18:34.780]   - Field: ‘state’
[10:18:34.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.780] - Launch lazy future ...
[10:18:34.781] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.781] Packages needed by future strategies (n = 0): <none>
[10:18:34.782] {
[10:18:34.782]     {
[10:18:34.782]         {
[10:18:34.782]             ...future.startTime <- base::Sys.time()
[10:18:34.782]             {
[10:18:34.782]                 {
[10:18:34.782]                   {
[10:18:34.782]                     {
[10:18:34.782]                       {
[10:18:34.782]                         base::local({
[10:18:34.782]                           has_future <- base::requireNamespace("future", 
[10:18:34.782]                             quietly = TRUE)
[10:18:34.782]                           if (has_future) {
[10:18:34.782]                             ns <- base::getNamespace("future")
[10:18:34.782]                             version <- ns[[".package"]][["version"]]
[10:18:34.782]                             if (is.null(version)) 
[10:18:34.782]                               version <- utils::packageVersion("future")
[10:18:34.782]                           }
[10:18:34.782]                           else {
[10:18:34.782]                             version <- NULL
[10:18:34.782]                           }
[10:18:34.782]                           if (!has_future || version < "1.8.0") {
[10:18:34.782]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.782]                               "", base::R.version$version.string), 
[10:18:34.782]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:34.782]                                 base::R.version$platform, 8 * 
[10:18:34.782]                                   base::.Machine$sizeof.pointer), 
[10:18:34.782]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.782]                                 "release", "version")], collapse = " "), 
[10:18:34.782]                               hostname = base::Sys.info()[["nodename"]])
[10:18:34.782]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.782]                               info)
[10:18:34.782]                             info <- base::paste(info, collapse = "; ")
[10:18:34.782]                             if (!has_future) {
[10:18:34.782]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.782]                                 info)
[10:18:34.782]                             }
[10:18:34.782]                             else {
[10:18:34.782]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.782]                                 info, version)
[10:18:34.782]                             }
[10:18:34.782]                             base::stop(msg)
[10:18:34.782]                           }
[10:18:34.782]                         })
[10:18:34.782]                       }
[10:18:34.782]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.782]                       base::options(mc.cores = 1L)
[10:18:34.782]                     }
[10:18:34.782]                     base::local({
[10:18:34.782]                       for (pkg in "stats") {
[10:18:34.782]                         base::loadNamespace(pkg)
[10:18:34.782]                         base::library(pkg, character.only = TRUE)
[10:18:34.782]                       }
[10:18:34.782]                     })
[10:18:34.782]                   }
[10:18:34.782]                   ...future.strategy.old <- future::plan("list")
[10:18:34.782]                   options(future.plan = NULL)
[10:18:34.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.782]                 }
[10:18:34.782]                 ...future.workdir <- getwd()
[10:18:34.782]             }
[10:18:34.782]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.782]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.782]         }
[10:18:34.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.782]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.782]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.782]             base::names(...future.oldOptions))
[10:18:34.782]     }
[10:18:34.782]     if (FALSE) {
[10:18:34.782]     }
[10:18:34.782]     else {
[10:18:34.782]         if (TRUE) {
[10:18:34.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.782]                 open = "w")
[10:18:34.782]         }
[10:18:34.782]         else {
[10:18:34.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.782]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.782]         }
[10:18:34.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.782]             base::sink(type = "output", split = FALSE)
[10:18:34.782]             base::close(...future.stdout)
[10:18:34.782]         }, add = TRUE)
[10:18:34.782]     }
[10:18:34.782]     ...future.frame <- base::sys.nframe()
[10:18:34.782]     ...future.conditions <- base::list()
[10:18:34.782]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.782]     if (FALSE) {
[10:18:34.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.782]     }
[10:18:34.782]     ...future.result <- base::tryCatch({
[10:18:34.782]         base::withCallingHandlers({
[10:18:34.782]             ...future.value <- base::withVisible(base::local({
[10:18:34.782]                 withCallingHandlers({
[10:18:34.782]                   {
[10:18:34.782]                     do.call(function(...) {
[10:18:34.782]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.782]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.782]                         ...future.globals.maxSize)) {
[10:18:34.782]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.782]                         on.exit(options(oopts), add = TRUE)
[10:18:34.782]                       }
[10:18:34.782]                       {
[10:18:34.782]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.782]                           FUN = function(jj) {
[10:18:34.782]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.782]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.782]                           })
[10:18:34.782]                       }
[10:18:34.782]                     }, args = future.call.arguments)
[10:18:34.782]                   }
[10:18:34.782]                 }, immediateCondition = function(cond) {
[10:18:34.782]                   save_rds <- function (object, pathname, ...) 
[10:18:34.782]                   {
[10:18:34.782]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.782]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.782]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.782]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.782]                         fi_tmp[["mtime"]])
[10:18:34.782]                     }
[10:18:34.782]                     tryCatch({
[10:18:34.782]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.782]                     }, error = function(ex) {
[10:18:34.782]                       msg <- conditionMessage(ex)
[10:18:34.782]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.782]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.782]                         fi_tmp[["mtime"]], msg)
[10:18:34.782]                       ex$message <- msg
[10:18:34.782]                       stop(ex)
[10:18:34.782]                     })
[10:18:34.782]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.782]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.782]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.782]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.782]                       fi <- file.info(pathname)
[10:18:34.782]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.782]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.782]                         fi[["size"]], fi[["mtime"]])
[10:18:34.782]                       stop(msg)
[10:18:34.782]                     }
[10:18:34.782]                     invisible(pathname)
[10:18:34.782]                   }
[10:18:34.782]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.782]                     rootPath = tempdir()) 
[10:18:34.782]                   {
[10:18:34.782]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.782]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.782]                       tmpdir = path, fileext = ".rds")
[10:18:34.782]                     save_rds(obj, file)
[10:18:34.782]                   }
[10:18:34.782]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.782]                   {
[10:18:34.782]                     inherits <- base::inherits
[10:18:34.782]                     invokeRestart <- base::invokeRestart
[10:18:34.782]                     is.null <- base::is.null
[10:18:34.782]                     muffled <- FALSE
[10:18:34.782]                     if (inherits(cond, "message")) {
[10:18:34.782]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.782]                       if (muffled) 
[10:18:34.782]                         invokeRestart("muffleMessage")
[10:18:34.782]                     }
[10:18:34.782]                     else if (inherits(cond, "warning")) {
[10:18:34.782]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.782]                       if (muffled) 
[10:18:34.782]                         invokeRestart("muffleWarning")
[10:18:34.782]                     }
[10:18:34.782]                     else if (inherits(cond, "condition")) {
[10:18:34.782]                       if (!is.null(pattern)) {
[10:18:34.782]                         computeRestarts <- base::computeRestarts
[10:18:34.782]                         grepl <- base::grepl
[10:18:34.782]                         restarts <- computeRestarts(cond)
[10:18:34.782]                         for (restart in restarts) {
[10:18:34.782]                           name <- restart$name
[10:18:34.782]                           if (is.null(name)) 
[10:18:34.782]                             next
[10:18:34.782]                           if (!grepl(pattern, name)) 
[10:18:34.782]                             next
[10:18:34.782]                           invokeRestart(restart)
[10:18:34.782]                           muffled <- TRUE
[10:18:34.782]                           break
[10:18:34.782]                         }
[10:18:34.782]                       }
[10:18:34.782]                     }
[10:18:34.782]                     invisible(muffled)
[10:18:34.782]                   }
[10:18:34.782]                   muffleCondition(cond)
[10:18:34.782]                 })
[10:18:34.782]             }))
[10:18:34.782]             future::FutureResult(value = ...future.value$value, 
[10:18:34.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.782]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.782]                     ...future.globalenv.names))
[10:18:34.782]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.782]         }, condition = base::local({
[10:18:34.782]             c <- base::c
[10:18:34.782]             inherits <- base::inherits
[10:18:34.782]             invokeRestart <- base::invokeRestart
[10:18:34.782]             length <- base::length
[10:18:34.782]             list <- base::list
[10:18:34.782]             seq.int <- base::seq.int
[10:18:34.782]             signalCondition <- base::signalCondition
[10:18:34.782]             sys.calls <- base::sys.calls
[10:18:34.782]             `[[` <- base::`[[`
[10:18:34.782]             `+` <- base::`+`
[10:18:34.782]             `<<-` <- base::`<<-`
[10:18:34.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.782]                   3L)]
[10:18:34.782]             }
[10:18:34.782]             function(cond) {
[10:18:34.782]                 is_error <- inherits(cond, "error")
[10:18:34.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.782]                   NULL)
[10:18:34.782]                 if (is_error) {
[10:18:34.782]                   sessionInformation <- function() {
[10:18:34.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.782]                       search = base::search(), system = base::Sys.info())
[10:18:34.782]                   }
[10:18:34.782]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.782]                     cond$call), session = sessionInformation(), 
[10:18:34.782]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.782]                   signalCondition(cond)
[10:18:34.782]                 }
[10:18:34.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.782]                 "immediateCondition"))) {
[10:18:34.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.782]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.782]                   if (TRUE && !signal) {
[10:18:34.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.782]                     {
[10:18:34.782]                       inherits <- base::inherits
[10:18:34.782]                       invokeRestart <- base::invokeRestart
[10:18:34.782]                       is.null <- base::is.null
[10:18:34.782]                       muffled <- FALSE
[10:18:34.782]                       if (inherits(cond, "message")) {
[10:18:34.782]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.782]                         if (muffled) 
[10:18:34.782]                           invokeRestart("muffleMessage")
[10:18:34.782]                       }
[10:18:34.782]                       else if (inherits(cond, "warning")) {
[10:18:34.782]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.782]                         if (muffled) 
[10:18:34.782]                           invokeRestart("muffleWarning")
[10:18:34.782]                       }
[10:18:34.782]                       else if (inherits(cond, "condition")) {
[10:18:34.782]                         if (!is.null(pattern)) {
[10:18:34.782]                           computeRestarts <- base::computeRestarts
[10:18:34.782]                           grepl <- base::grepl
[10:18:34.782]                           restarts <- computeRestarts(cond)
[10:18:34.782]                           for (restart in restarts) {
[10:18:34.782]                             name <- restart$name
[10:18:34.782]                             if (is.null(name)) 
[10:18:34.782]                               next
[10:18:34.782]                             if (!grepl(pattern, name)) 
[10:18:34.782]                               next
[10:18:34.782]                             invokeRestart(restart)
[10:18:34.782]                             muffled <- TRUE
[10:18:34.782]                             break
[10:18:34.782]                           }
[10:18:34.782]                         }
[10:18:34.782]                       }
[10:18:34.782]                       invisible(muffled)
[10:18:34.782]                     }
[10:18:34.782]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.782]                   }
[10:18:34.782]                 }
[10:18:34.782]                 else {
[10:18:34.782]                   if (TRUE) {
[10:18:34.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.782]                     {
[10:18:34.782]                       inherits <- base::inherits
[10:18:34.782]                       invokeRestart <- base::invokeRestart
[10:18:34.782]                       is.null <- base::is.null
[10:18:34.782]                       muffled <- FALSE
[10:18:34.782]                       if (inherits(cond, "message")) {
[10:18:34.782]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.782]                         if (muffled) 
[10:18:34.782]                           invokeRestart("muffleMessage")
[10:18:34.782]                       }
[10:18:34.782]                       else if (inherits(cond, "warning")) {
[10:18:34.782]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.782]                         if (muffled) 
[10:18:34.782]                           invokeRestart("muffleWarning")
[10:18:34.782]                       }
[10:18:34.782]                       else if (inherits(cond, "condition")) {
[10:18:34.782]                         if (!is.null(pattern)) {
[10:18:34.782]                           computeRestarts <- base::computeRestarts
[10:18:34.782]                           grepl <- base::grepl
[10:18:34.782]                           restarts <- computeRestarts(cond)
[10:18:34.782]                           for (restart in restarts) {
[10:18:34.782]                             name <- restart$name
[10:18:34.782]                             if (is.null(name)) 
[10:18:34.782]                               next
[10:18:34.782]                             if (!grepl(pattern, name)) 
[10:18:34.782]                               next
[10:18:34.782]                             invokeRestart(restart)
[10:18:34.782]                             muffled <- TRUE
[10:18:34.782]                             break
[10:18:34.782]                           }
[10:18:34.782]                         }
[10:18:34.782]                       }
[10:18:34.782]                       invisible(muffled)
[10:18:34.782]                     }
[10:18:34.782]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.782]                   }
[10:18:34.782]                 }
[10:18:34.782]             }
[10:18:34.782]         }))
[10:18:34.782]     }, error = function(ex) {
[10:18:34.782]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.782]                 ...future.rng), started = ...future.startTime, 
[10:18:34.782]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.782]             version = "1.8"), class = "FutureResult")
[10:18:34.782]     }, finally = {
[10:18:34.782]         if (!identical(...future.workdir, getwd())) 
[10:18:34.782]             setwd(...future.workdir)
[10:18:34.782]         {
[10:18:34.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.782]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.782]             }
[10:18:34.782]             base::options(...future.oldOptions)
[10:18:34.782]             if (.Platform$OS.type == "windows") {
[10:18:34.782]                 old_names <- names(...future.oldEnvVars)
[10:18:34.782]                 envs <- base::Sys.getenv()
[10:18:34.782]                 names <- names(envs)
[10:18:34.782]                 common <- intersect(names, old_names)
[10:18:34.782]                 added <- setdiff(names, old_names)
[10:18:34.782]                 removed <- setdiff(old_names, names)
[10:18:34.782]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.782]                   envs[common]]
[10:18:34.782]                 NAMES <- toupper(changed)
[10:18:34.782]                 args <- list()
[10:18:34.782]                 for (kk in seq_along(NAMES)) {
[10:18:34.782]                   name <- changed[[kk]]
[10:18:34.782]                   NAME <- NAMES[[kk]]
[10:18:34.782]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.782]                     next
[10:18:34.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.782]                 }
[10:18:34.782]                 NAMES <- toupper(added)
[10:18:34.782]                 for (kk in seq_along(NAMES)) {
[10:18:34.782]                   name <- added[[kk]]
[10:18:34.782]                   NAME <- NAMES[[kk]]
[10:18:34.782]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.782]                     next
[10:18:34.782]                   args[[name]] <- ""
[10:18:34.782]                 }
[10:18:34.782]                 NAMES <- toupper(removed)
[10:18:34.782]                 for (kk in seq_along(NAMES)) {
[10:18:34.782]                   name <- removed[[kk]]
[10:18:34.782]                   NAME <- NAMES[[kk]]
[10:18:34.782]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.782]                     next
[10:18:34.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.782]                 }
[10:18:34.782]                 if (length(args) > 0) 
[10:18:34.782]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.782]             }
[10:18:34.782]             else {
[10:18:34.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.782]             }
[10:18:34.782]             {
[10:18:34.782]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.782]                   0L) {
[10:18:34.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.782]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.782]                   base::options(opts)
[10:18:34.782]                 }
[10:18:34.782]                 {
[10:18:34.782]                   {
[10:18:34.782]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.782]                     NULL
[10:18:34.782]                   }
[10:18:34.782]                   options(future.plan = NULL)
[10:18:34.782]                   if (is.na(NA_character_)) 
[10:18:34.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.782]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.782]                     .init = FALSE)
[10:18:34.782]                 }
[10:18:34.782]             }
[10:18:34.782]         }
[10:18:34.782]     })
[10:18:34.782]     if (TRUE) {
[10:18:34.782]         base::sink(type = "output", split = FALSE)
[10:18:34.782]         if (TRUE) {
[10:18:34.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.782]         }
[10:18:34.782]         else {
[10:18:34.782]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.782]         }
[10:18:34.782]         base::close(...future.stdout)
[10:18:34.782]         ...future.stdout <- NULL
[10:18:34.782]     }
[10:18:34.782]     ...future.result$conditions <- ...future.conditions
[10:18:34.782]     ...future.result$finished <- base::Sys.time()
[10:18:34.782]     ...future.result
[10:18:34.782] }
[10:18:34.785] assign_globals() ...
[10:18:34.785] List of 5
[10:18:34.785]  $ ...future.FUN            :function (x, ...)  
[10:18:34.785]  $ future.call.arguments    : list()
[10:18:34.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.785]  $ ...future.elements_ii    :List of 2
[10:18:34.785]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.785]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.785]  $ ...future.seeds_ii       : NULL
[10:18:34.785]  $ ...future.globals.maxSize: NULL
[10:18:34.785]  - attr(*, "where")=List of 5
[10:18:34.785]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.785]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.785]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.785]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.785]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.785]  - attr(*, "resolved")= logi FALSE
[10:18:34.785]  - attr(*, "total_size")= num 5433
[10:18:34.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.785]  - attr(*, "already-done")= logi TRUE
[10:18:34.797] - copied ‘...future.FUN’ to environment
[10:18:34.797] - copied ‘future.call.arguments’ to environment
[10:18:34.797] - copied ‘...future.elements_ii’ to environment
[10:18:34.797] - copied ‘...future.seeds_ii’ to environment
[10:18:34.798] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.798] assign_globals() ... done
[10:18:34.798] requestCore(): workers = 2
[10:18:34.800] MulticoreFuture started
[10:18:34.801] - Launch lazy future ... done
[10:18:34.801] run() for ‘MulticoreFuture’ ... done
[10:18:34.801] Created future:
[10:18:34.802] plan(): Setting new future strategy stack:
[10:18:34.802] List of future strategies:
[10:18:34.802] 1. sequential:
[10:18:34.802]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.802]    - tweaked: FALSE
[10:18:34.802]    - call: NULL
[10:18:34.803] plan(): nbrOfWorkers() = 1
[10:18:34.806] plan(): Setting new future strategy stack:
[10:18:34.806] List of future strategies:
[10:18:34.806] 1. multicore:
[10:18:34.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.806]    - tweaked: FALSE
[10:18:34.806]    - call: plan(strategy)
[10:18:34.809] plan(): nbrOfWorkers() = 2
[10:18:34.801] MulticoreFuture:
[10:18:34.801] Label: ‘future_eapply-2’
[10:18:34.801] Expression:
[10:18:34.801] {
[10:18:34.801]     do.call(function(...) {
[10:18:34.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.801]             on.exit(options(oopts), add = TRUE)
[10:18:34.801]         }
[10:18:34.801]         {
[10:18:34.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.801]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.801]             })
[10:18:34.801]         }
[10:18:34.801]     }, args = future.call.arguments)
[10:18:34.801] }
[10:18:34.801] Lazy evaluation: FALSE
[10:18:34.801] Asynchronous evaluation: TRUE
[10:18:34.801] Local evaluation: TRUE
[10:18:34.801] Environment: R_GlobalEnv
[10:18:34.801] Capture standard output: TRUE
[10:18:34.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.801] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.801] Packages: 1 packages (‘stats’)
[10:18:34.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.801] Resolved: TRUE
[10:18:34.801] Value: <not collected>
[10:18:34.801] Conditions captured: <none>
[10:18:34.801] Early signaling: FALSE
[10:18:34.801] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.801] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.810] Chunk #2 of 2 ... DONE
[10:18:34.810] Launching 2 futures (chunks) ... DONE
[10:18:34.811] Resolving 2 futures (chunks) ...
[10:18:34.811] resolve() on list ...
[10:18:34.811]  recursive: 0
[10:18:34.811]  length: 2
[10:18:34.811] 
[10:18:34.812] Future #1
[10:18:34.812] result() for MulticoreFuture ...
[10:18:34.813] result() for MulticoreFuture ...
[10:18:34.813] result() for MulticoreFuture ... done
[10:18:34.813] result() for MulticoreFuture ... done
[10:18:34.813] result() for MulticoreFuture ...
[10:18:34.813] result() for MulticoreFuture ... done
[10:18:34.814] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:34.814] - nx: 2
[10:18:34.814] - relay: TRUE
[10:18:34.814] - stdout: TRUE
[10:18:34.814] - signal: TRUE
[10:18:34.814] - resignal: FALSE
[10:18:34.814] - force: TRUE
[10:18:34.815] - relayed: [n=2] FALSE, FALSE
[10:18:34.815] - queued futures: [n=2] FALSE, FALSE
[10:18:34.815]  - until=1
[10:18:34.815]  - relaying element #1
[10:18:34.815] result() for MulticoreFuture ...
[10:18:34.815] result() for MulticoreFuture ... done
[10:18:34.815] result() for MulticoreFuture ...
[10:18:34.816] result() for MulticoreFuture ... done
[10:18:34.816] result() for MulticoreFuture ...
[10:18:34.816] result() for MulticoreFuture ... done
[10:18:34.816] result() for MulticoreFuture ...
[10:18:34.816] result() for MulticoreFuture ... done
[10:18:34.816] - relayed: [n=2] TRUE, FALSE
[10:18:34.816] - queued futures: [n=2] TRUE, FALSE
[10:18:34.817] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:34.817]  length: 1 (resolved future 1)
[10:18:34.817] Future #2
[10:18:34.817] result() for MulticoreFuture ...
[10:18:34.818] result() for MulticoreFuture ...
[10:18:34.818] result() for MulticoreFuture ... done
[10:18:34.818] result() for MulticoreFuture ... done
[10:18:34.818] result() for MulticoreFuture ...
[10:18:34.819] result() for MulticoreFuture ... done
[10:18:34.819] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:34.819] - nx: 2
[10:18:34.819] - relay: TRUE
[10:18:34.819] - stdout: TRUE
[10:18:34.819] - signal: TRUE
[10:18:34.819] - resignal: FALSE
[10:18:34.819] - force: TRUE
[10:18:34.819] - relayed: [n=2] TRUE, FALSE
[10:18:34.820] - queued futures: [n=2] TRUE, FALSE
[10:18:34.820]  - until=2
[10:18:34.820]  - relaying element #2
[10:18:34.820] result() for MulticoreFuture ...
[10:18:34.820] result() for MulticoreFuture ... done
[10:18:34.820] result() for MulticoreFuture ...
[10:18:34.820] result() for MulticoreFuture ... done
[10:18:34.820] result() for MulticoreFuture ...
[10:18:34.821] result() for MulticoreFuture ... done
[10:18:34.821] result() for MulticoreFuture ...
[10:18:34.821] result() for MulticoreFuture ... done
[10:18:34.821] - relayed: [n=2] TRUE, TRUE
[10:18:34.821] - queued futures: [n=2] TRUE, TRUE
[10:18:34.821] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:34.821]  length: 0 (resolved future 2)
[10:18:34.821] Relaying remaining futures
[10:18:34.821] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.822] - nx: 2
[10:18:34.822] - relay: TRUE
[10:18:34.822] - stdout: TRUE
[10:18:34.822] - signal: TRUE
[10:18:34.822] - resignal: FALSE
[10:18:34.822] - force: TRUE
[10:18:34.822] - relayed: [n=2] TRUE, TRUE
[10:18:34.822] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:34.822] - relayed: [n=2] TRUE, TRUE
[10:18:34.823] - queued futures: [n=2] TRUE, TRUE
[10:18:34.823] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.823] resolve() on list ... DONE
[10:18:34.823] result() for MulticoreFuture ...
[10:18:34.823] result() for MulticoreFuture ... done
[10:18:34.823] result() for MulticoreFuture ...
[10:18:34.823] result() for MulticoreFuture ... done
[10:18:34.823] result() for MulticoreFuture ...
[10:18:34.823] result() for MulticoreFuture ... done
[10:18:34.824] result() for MulticoreFuture ...
[10:18:34.824] result() for MulticoreFuture ... done
[10:18:34.824]  - Number of value chunks collected: 2
[10:18:34.824] Resolving 2 futures (chunks) ... DONE
[10:18:34.824] Reducing values from 2 chunks ...
[10:18:34.824]  - Number of values collected after concatenation: 3
[10:18:34.824]  - Number of values expected: 3
[10:18:34.824] Reducing values from 2 chunks ... DONE
[10:18:34.824] future_lapply() ... DONE
[10:18:34.825] future_lapply() ...
[10:18:34.828] Number of chunks: 2
[10:18:34.828] getGlobalsAndPackagesXApply() ...
[10:18:34.828]  - future.globals: TRUE
[10:18:34.828] getGlobalsAndPackages() ...
[10:18:34.828] Searching for globals...
[10:18:34.829] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:34.829] Searching for globals ... DONE
[10:18:34.830] Resolving globals: FALSE
[10:18:34.830] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:34.830] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:34.831] - globals: [1] ‘FUN’
[10:18:34.831] - packages: [1] ‘stats’
[10:18:34.831] getGlobalsAndPackages() ... DONE
[10:18:34.831]  - globals found/used: [n=1] ‘FUN’
[10:18:34.831]  - needed namespaces: [n=1] ‘stats’
[10:18:34.831] Finding globals ... DONE
[10:18:34.831]  - use_args: TRUE
[10:18:34.831]  - Getting '...' globals ...
[10:18:34.834] resolve() on list ...
[10:18:34.834]  recursive: 0
[10:18:34.834]  length: 1
[10:18:34.834]  elements: ‘...’
[10:18:34.835]  length: 0 (resolved future 1)
[10:18:34.835] resolve() on list ... DONE
[10:18:34.835]    - '...' content: [n=0] 
[10:18:34.835] List of 1
[10:18:34.835]  $ ...: list()
[10:18:34.835]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.835]  - attr(*, "where")=List of 1
[10:18:34.835]   ..$ ...:<environment: 0x56033cc78958> 
[10:18:34.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.835]  - attr(*, "resolved")= logi TRUE
[10:18:34.835]  - attr(*, "total_size")= num NA
[10:18:34.838]  - Getting '...' globals ... DONE
[10:18:34.839] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:34.839] List of 2
[10:18:34.839]  $ ...future.FUN:function (x, ...)  
[10:18:34.839]  $ ...          : list()
[10:18:34.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.839]  - attr(*, "where")=List of 2
[10:18:34.839]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:34.839]   ..$ ...          :<environment: 0x56033cc78958> 
[10:18:34.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.839]  - attr(*, "resolved")= logi FALSE
[10:18:34.839]  - attr(*, "total_size")= num 5437
[10:18:34.841] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:34.842] getGlobalsAndPackagesXApply() ... DONE
[10:18:34.842] Number of futures (= number of chunks): 2
[10:18:34.842] Launching 2 futures (chunks) ...
[10:18:34.842] Chunk #1 of 2 ...
[10:18:34.842]  - Finding globals in 'X' for chunk #1 ...
[10:18:34.842] getGlobalsAndPackages() ...
[10:18:34.842] Searching for globals...
[10:18:34.842] 
[10:18:34.843] Searching for globals ... DONE
[10:18:34.843] - globals: [0] <none>
[10:18:34.843] getGlobalsAndPackages() ... DONE
[10:18:34.843]    + additional globals found: [n=0] 
[10:18:34.843]    + additional namespaces needed: [n=0] 
[10:18:34.843]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:34.843]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.843]  - seeds: <none>
[10:18:34.843]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.843] getGlobalsAndPackages() ...
[10:18:34.843] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.844] Resolving globals: FALSE
[10:18:34.844] Tweak future expression to call with '...' arguments ...
[10:18:34.844] {
[10:18:34.844]     do.call(function(...) {
[10:18:34.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.844]             on.exit(options(oopts), add = TRUE)
[10:18:34.844]         }
[10:18:34.844]         {
[10:18:34.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.844]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.844]             })
[10:18:34.844]         }
[10:18:34.844]     }, args = future.call.arguments)
[10:18:34.844] }
[10:18:34.844] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.844] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.845] - packages: [1] ‘stats’
[10:18:34.845] getGlobalsAndPackages() ... DONE
[10:18:34.845] run() for ‘Future’ ...
[10:18:34.845] - state: ‘created’
[10:18:34.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.847] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.847] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.847]   - Field: ‘label’
[10:18:34.847]   - Field: ‘local’
[10:18:34.847]   - Field: ‘owner’
[10:18:34.847]   - Field: ‘envir’
[10:18:34.848]   - Field: ‘workers’
[10:18:34.848]   - Field: ‘packages’
[10:18:34.848]   - Field: ‘gc’
[10:18:34.848]   - Field: ‘job’
[10:18:34.848]   - Field: ‘conditions’
[10:18:34.848]   - Field: ‘expr’
[10:18:34.848]   - Field: ‘uuid’
[10:18:34.848]   - Field: ‘seed’
[10:18:34.848]   - Field: ‘version’
[10:18:34.848]   - Field: ‘result’
[10:18:34.848]   - Field: ‘asynchronous’
[10:18:34.848]   - Field: ‘calls’
[10:18:34.849]   - Field: ‘globals’
[10:18:34.849]   - Field: ‘stdout’
[10:18:34.849]   - Field: ‘earlySignal’
[10:18:34.849]   - Field: ‘lazy’
[10:18:34.849]   - Field: ‘state’
[10:18:34.849] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.849] - Launch lazy future ...
[10:18:34.849] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.850] Packages needed by future strategies (n = 0): <none>
[10:18:34.850] {
[10:18:34.850]     {
[10:18:34.850]         {
[10:18:34.850]             ...future.startTime <- base::Sys.time()
[10:18:34.850]             {
[10:18:34.850]                 {
[10:18:34.850]                   {
[10:18:34.850]                     {
[10:18:34.850]                       {
[10:18:34.850]                         base::local({
[10:18:34.850]                           has_future <- base::requireNamespace("future", 
[10:18:34.850]                             quietly = TRUE)
[10:18:34.850]                           if (has_future) {
[10:18:34.850]                             ns <- base::getNamespace("future")
[10:18:34.850]                             version <- ns[[".package"]][["version"]]
[10:18:34.850]                             if (is.null(version)) 
[10:18:34.850]                               version <- utils::packageVersion("future")
[10:18:34.850]                           }
[10:18:34.850]                           else {
[10:18:34.850]                             version <- NULL
[10:18:34.850]                           }
[10:18:34.850]                           if (!has_future || version < "1.8.0") {
[10:18:34.850]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.850]                               "", base::R.version$version.string), 
[10:18:34.850]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:34.850]                                 base::R.version$platform, 8 * 
[10:18:34.850]                                   base::.Machine$sizeof.pointer), 
[10:18:34.850]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.850]                                 "release", "version")], collapse = " "), 
[10:18:34.850]                               hostname = base::Sys.info()[["nodename"]])
[10:18:34.850]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.850]                               info)
[10:18:34.850]                             info <- base::paste(info, collapse = "; ")
[10:18:34.850]                             if (!has_future) {
[10:18:34.850]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.850]                                 info)
[10:18:34.850]                             }
[10:18:34.850]                             else {
[10:18:34.850]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.850]                                 info, version)
[10:18:34.850]                             }
[10:18:34.850]                             base::stop(msg)
[10:18:34.850]                           }
[10:18:34.850]                         })
[10:18:34.850]                       }
[10:18:34.850]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.850]                       base::options(mc.cores = 1L)
[10:18:34.850]                     }
[10:18:34.850]                     base::local({
[10:18:34.850]                       for (pkg in "stats") {
[10:18:34.850]                         base::loadNamespace(pkg)
[10:18:34.850]                         base::library(pkg, character.only = TRUE)
[10:18:34.850]                       }
[10:18:34.850]                     })
[10:18:34.850]                   }
[10:18:34.850]                   ...future.strategy.old <- future::plan("list")
[10:18:34.850]                   options(future.plan = NULL)
[10:18:34.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.850]                 }
[10:18:34.850]                 ...future.workdir <- getwd()
[10:18:34.850]             }
[10:18:34.850]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.850]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.850]         }
[10:18:34.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.850]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.850]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.850]             base::names(...future.oldOptions))
[10:18:34.850]     }
[10:18:34.850]     if (FALSE) {
[10:18:34.850]     }
[10:18:34.850]     else {
[10:18:34.850]         if (TRUE) {
[10:18:34.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.850]                 open = "w")
[10:18:34.850]         }
[10:18:34.850]         else {
[10:18:34.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.850]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.850]         }
[10:18:34.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.850]             base::sink(type = "output", split = FALSE)
[10:18:34.850]             base::close(...future.stdout)
[10:18:34.850]         }, add = TRUE)
[10:18:34.850]     }
[10:18:34.850]     ...future.frame <- base::sys.nframe()
[10:18:34.850]     ...future.conditions <- base::list()
[10:18:34.850]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.850]     if (FALSE) {
[10:18:34.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.850]     }
[10:18:34.850]     ...future.result <- base::tryCatch({
[10:18:34.850]         base::withCallingHandlers({
[10:18:34.850]             ...future.value <- base::withVisible(base::local({
[10:18:34.850]                 withCallingHandlers({
[10:18:34.850]                   {
[10:18:34.850]                     do.call(function(...) {
[10:18:34.850]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.850]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.850]                         ...future.globals.maxSize)) {
[10:18:34.850]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.850]                         on.exit(options(oopts), add = TRUE)
[10:18:34.850]                       }
[10:18:34.850]                       {
[10:18:34.850]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.850]                           FUN = function(jj) {
[10:18:34.850]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.850]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.850]                           })
[10:18:34.850]                       }
[10:18:34.850]                     }, args = future.call.arguments)
[10:18:34.850]                   }
[10:18:34.850]                 }, immediateCondition = function(cond) {
[10:18:34.850]                   save_rds <- function (object, pathname, ...) 
[10:18:34.850]                   {
[10:18:34.850]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.850]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.850]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.850]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.850]                         fi_tmp[["mtime"]])
[10:18:34.850]                     }
[10:18:34.850]                     tryCatch({
[10:18:34.850]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.850]                     }, error = function(ex) {
[10:18:34.850]                       msg <- conditionMessage(ex)
[10:18:34.850]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.850]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.850]                         fi_tmp[["mtime"]], msg)
[10:18:34.850]                       ex$message <- msg
[10:18:34.850]                       stop(ex)
[10:18:34.850]                     })
[10:18:34.850]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.850]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.850]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.850]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.850]                       fi <- file.info(pathname)
[10:18:34.850]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.850]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.850]                         fi[["size"]], fi[["mtime"]])
[10:18:34.850]                       stop(msg)
[10:18:34.850]                     }
[10:18:34.850]                     invisible(pathname)
[10:18:34.850]                   }
[10:18:34.850]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.850]                     rootPath = tempdir()) 
[10:18:34.850]                   {
[10:18:34.850]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.850]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.850]                       tmpdir = path, fileext = ".rds")
[10:18:34.850]                     save_rds(obj, file)
[10:18:34.850]                   }
[10:18:34.850]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.850]                   {
[10:18:34.850]                     inherits <- base::inherits
[10:18:34.850]                     invokeRestart <- base::invokeRestart
[10:18:34.850]                     is.null <- base::is.null
[10:18:34.850]                     muffled <- FALSE
[10:18:34.850]                     if (inherits(cond, "message")) {
[10:18:34.850]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.850]                       if (muffled) 
[10:18:34.850]                         invokeRestart("muffleMessage")
[10:18:34.850]                     }
[10:18:34.850]                     else if (inherits(cond, "warning")) {
[10:18:34.850]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.850]                       if (muffled) 
[10:18:34.850]                         invokeRestart("muffleWarning")
[10:18:34.850]                     }
[10:18:34.850]                     else if (inherits(cond, "condition")) {
[10:18:34.850]                       if (!is.null(pattern)) {
[10:18:34.850]                         computeRestarts <- base::computeRestarts
[10:18:34.850]                         grepl <- base::grepl
[10:18:34.850]                         restarts <- computeRestarts(cond)
[10:18:34.850]                         for (restart in restarts) {
[10:18:34.850]                           name <- restart$name
[10:18:34.850]                           if (is.null(name)) 
[10:18:34.850]                             next
[10:18:34.850]                           if (!grepl(pattern, name)) 
[10:18:34.850]                             next
[10:18:34.850]                           invokeRestart(restart)
[10:18:34.850]                           muffled <- TRUE
[10:18:34.850]                           break
[10:18:34.850]                         }
[10:18:34.850]                       }
[10:18:34.850]                     }
[10:18:34.850]                     invisible(muffled)
[10:18:34.850]                   }
[10:18:34.850]                   muffleCondition(cond)
[10:18:34.850]                 })
[10:18:34.850]             }))
[10:18:34.850]             future::FutureResult(value = ...future.value$value, 
[10:18:34.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.850]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.850]                     ...future.globalenv.names))
[10:18:34.850]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.850]         }, condition = base::local({
[10:18:34.850]             c <- base::c
[10:18:34.850]             inherits <- base::inherits
[10:18:34.850]             invokeRestart <- base::invokeRestart
[10:18:34.850]             length <- base::length
[10:18:34.850]             list <- base::list
[10:18:34.850]             seq.int <- base::seq.int
[10:18:34.850]             signalCondition <- base::signalCondition
[10:18:34.850]             sys.calls <- base::sys.calls
[10:18:34.850]             `[[` <- base::`[[`
[10:18:34.850]             `+` <- base::`+`
[10:18:34.850]             `<<-` <- base::`<<-`
[10:18:34.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.850]                   3L)]
[10:18:34.850]             }
[10:18:34.850]             function(cond) {
[10:18:34.850]                 is_error <- inherits(cond, "error")
[10:18:34.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.850]                   NULL)
[10:18:34.850]                 if (is_error) {
[10:18:34.850]                   sessionInformation <- function() {
[10:18:34.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.850]                       search = base::search(), system = base::Sys.info())
[10:18:34.850]                   }
[10:18:34.850]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.850]                     cond$call), session = sessionInformation(), 
[10:18:34.850]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.850]                   signalCondition(cond)
[10:18:34.850]                 }
[10:18:34.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.850]                 "immediateCondition"))) {
[10:18:34.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.850]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.850]                   if (TRUE && !signal) {
[10:18:34.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.850]                     {
[10:18:34.850]                       inherits <- base::inherits
[10:18:34.850]                       invokeRestart <- base::invokeRestart
[10:18:34.850]                       is.null <- base::is.null
[10:18:34.850]                       muffled <- FALSE
[10:18:34.850]                       if (inherits(cond, "message")) {
[10:18:34.850]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.850]                         if (muffled) 
[10:18:34.850]                           invokeRestart("muffleMessage")
[10:18:34.850]                       }
[10:18:34.850]                       else if (inherits(cond, "warning")) {
[10:18:34.850]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.850]                         if (muffled) 
[10:18:34.850]                           invokeRestart("muffleWarning")
[10:18:34.850]                       }
[10:18:34.850]                       else if (inherits(cond, "condition")) {
[10:18:34.850]                         if (!is.null(pattern)) {
[10:18:34.850]                           computeRestarts <- base::computeRestarts
[10:18:34.850]                           grepl <- base::grepl
[10:18:34.850]                           restarts <- computeRestarts(cond)
[10:18:34.850]                           for (restart in restarts) {
[10:18:34.850]                             name <- restart$name
[10:18:34.850]                             if (is.null(name)) 
[10:18:34.850]                               next
[10:18:34.850]                             if (!grepl(pattern, name)) 
[10:18:34.850]                               next
[10:18:34.850]                             invokeRestart(restart)
[10:18:34.850]                             muffled <- TRUE
[10:18:34.850]                             break
[10:18:34.850]                           }
[10:18:34.850]                         }
[10:18:34.850]                       }
[10:18:34.850]                       invisible(muffled)
[10:18:34.850]                     }
[10:18:34.850]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.850]                   }
[10:18:34.850]                 }
[10:18:34.850]                 else {
[10:18:34.850]                   if (TRUE) {
[10:18:34.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.850]                     {
[10:18:34.850]                       inherits <- base::inherits
[10:18:34.850]                       invokeRestart <- base::invokeRestart
[10:18:34.850]                       is.null <- base::is.null
[10:18:34.850]                       muffled <- FALSE
[10:18:34.850]                       if (inherits(cond, "message")) {
[10:18:34.850]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.850]                         if (muffled) 
[10:18:34.850]                           invokeRestart("muffleMessage")
[10:18:34.850]                       }
[10:18:34.850]                       else if (inherits(cond, "warning")) {
[10:18:34.850]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.850]                         if (muffled) 
[10:18:34.850]                           invokeRestart("muffleWarning")
[10:18:34.850]                       }
[10:18:34.850]                       else if (inherits(cond, "condition")) {
[10:18:34.850]                         if (!is.null(pattern)) {
[10:18:34.850]                           computeRestarts <- base::computeRestarts
[10:18:34.850]                           grepl <- base::grepl
[10:18:34.850]                           restarts <- computeRestarts(cond)
[10:18:34.850]                           for (restart in restarts) {
[10:18:34.850]                             name <- restart$name
[10:18:34.850]                             if (is.null(name)) 
[10:18:34.850]                               next
[10:18:34.850]                             if (!grepl(pattern, name)) 
[10:18:34.850]                               next
[10:18:34.850]                             invokeRestart(restart)
[10:18:34.850]                             muffled <- TRUE
[10:18:34.850]                             break
[10:18:34.850]                           }
[10:18:34.850]                         }
[10:18:34.850]                       }
[10:18:34.850]                       invisible(muffled)
[10:18:34.850]                     }
[10:18:34.850]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.850]                   }
[10:18:34.850]                 }
[10:18:34.850]             }
[10:18:34.850]         }))
[10:18:34.850]     }, error = function(ex) {
[10:18:34.850]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.850]                 ...future.rng), started = ...future.startTime, 
[10:18:34.850]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.850]             version = "1.8"), class = "FutureResult")
[10:18:34.850]     }, finally = {
[10:18:34.850]         if (!identical(...future.workdir, getwd())) 
[10:18:34.850]             setwd(...future.workdir)
[10:18:34.850]         {
[10:18:34.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.850]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.850]             }
[10:18:34.850]             base::options(...future.oldOptions)
[10:18:34.850]             if (.Platform$OS.type == "windows") {
[10:18:34.850]                 old_names <- names(...future.oldEnvVars)
[10:18:34.850]                 envs <- base::Sys.getenv()
[10:18:34.850]                 names <- names(envs)
[10:18:34.850]                 common <- intersect(names, old_names)
[10:18:34.850]                 added <- setdiff(names, old_names)
[10:18:34.850]                 removed <- setdiff(old_names, names)
[10:18:34.850]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.850]                   envs[common]]
[10:18:34.850]                 NAMES <- toupper(changed)
[10:18:34.850]                 args <- list()
[10:18:34.850]                 for (kk in seq_along(NAMES)) {
[10:18:34.850]                   name <- changed[[kk]]
[10:18:34.850]                   NAME <- NAMES[[kk]]
[10:18:34.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.850]                     next
[10:18:34.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.850]                 }
[10:18:34.850]                 NAMES <- toupper(added)
[10:18:34.850]                 for (kk in seq_along(NAMES)) {
[10:18:34.850]                   name <- added[[kk]]
[10:18:34.850]                   NAME <- NAMES[[kk]]
[10:18:34.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.850]                     next
[10:18:34.850]                   args[[name]] <- ""
[10:18:34.850]                 }
[10:18:34.850]                 NAMES <- toupper(removed)
[10:18:34.850]                 for (kk in seq_along(NAMES)) {
[10:18:34.850]                   name <- removed[[kk]]
[10:18:34.850]                   NAME <- NAMES[[kk]]
[10:18:34.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.850]                     next
[10:18:34.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.850]                 }
[10:18:34.850]                 if (length(args) > 0) 
[10:18:34.850]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.850]             }
[10:18:34.850]             else {
[10:18:34.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.850]             }
[10:18:34.850]             {
[10:18:34.850]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.850]                   0L) {
[10:18:34.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.850]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.850]                   base::options(opts)
[10:18:34.850]                 }
[10:18:34.850]                 {
[10:18:34.850]                   {
[10:18:34.850]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.850]                     NULL
[10:18:34.850]                   }
[10:18:34.850]                   options(future.plan = NULL)
[10:18:34.850]                   if (is.na(NA_character_)) 
[10:18:34.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.850]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.850]                     .init = FALSE)
[10:18:34.850]                 }
[10:18:34.850]             }
[10:18:34.850]         }
[10:18:34.850]     })
[10:18:34.850]     if (TRUE) {
[10:18:34.850]         base::sink(type = "output", split = FALSE)
[10:18:34.850]         if (TRUE) {
[10:18:34.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.850]         }
[10:18:34.850]         else {
[10:18:34.850]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.850]         }
[10:18:34.850]         base::close(...future.stdout)
[10:18:34.850]         ...future.stdout <- NULL
[10:18:34.850]     }
[10:18:34.850]     ...future.result$conditions <- ...future.conditions
[10:18:34.850]     ...future.result$finished <- base::Sys.time()
[10:18:34.850]     ...future.result
[10:18:34.850] }
[10:18:34.853] assign_globals() ...
[10:18:34.853] List of 5
[10:18:34.853]  $ ...future.FUN            :function (x, ...)  
[10:18:34.853]  $ future.call.arguments    : list()
[10:18:34.853]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.853]  $ ...future.elements_ii    :List of 1
[10:18:34.853]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:18:34.853]  $ ...future.seeds_ii       : NULL
[10:18:34.853]  $ ...future.globals.maxSize: NULL
[10:18:34.853]  - attr(*, "where")=List of 5
[10:18:34.853]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.853]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.853]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.853]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.853]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.853]  - attr(*, "resolved")= logi FALSE
[10:18:34.853]  - attr(*, "total_size")= num 5437
[10:18:34.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.853]  - attr(*, "already-done")= logi TRUE
[10:18:34.857] - copied ‘...future.FUN’ to environment
[10:18:34.858] - copied ‘future.call.arguments’ to environment
[10:18:34.859] - copied ‘...future.elements_ii’ to environment
[10:18:34.860] - copied ‘...future.seeds_ii’ to environment
[10:18:34.860] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.860] assign_globals() ... done
[10:18:34.860] requestCore(): workers = 2
[10:18:34.862] MulticoreFuture started
[10:18:34.862] - Launch lazy future ... done
[10:18:34.863] run() for ‘MulticoreFuture’ ... done
[10:18:34.863] Created future:
[10:18:34.864] plan(): Setting new future strategy stack:
[10:18:34.864] List of future strategies:
[10:18:34.864] 1. sequential:
[10:18:34.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.864]    - tweaked: FALSE
[10:18:34.864]    - call: NULL
[10:18:34.865] plan(): nbrOfWorkers() = 1
[10:18:34.868] plan(): Setting new future strategy stack:
[10:18:34.868] List of future strategies:
[10:18:34.868] 1. multicore:
[10:18:34.868]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.868]    - tweaked: FALSE
[10:18:34.868]    - call: plan(strategy)
[10:18:34.871] plan(): nbrOfWorkers() = 2
[10:18:34.863] MulticoreFuture:
[10:18:34.863] Label: ‘future_eapply-1’
[10:18:34.863] Expression:
[10:18:34.863] {
[10:18:34.863]     do.call(function(...) {
[10:18:34.863]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.863]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.863]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.863]             on.exit(options(oopts), add = TRUE)
[10:18:34.863]         }
[10:18:34.863]         {
[10:18:34.863]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.863]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.863]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.863]             })
[10:18:34.863]         }
[10:18:34.863]     }, args = future.call.arguments)
[10:18:34.863] }
[10:18:34.863] Lazy evaluation: FALSE
[10:18:34.863] Asynchronous evaluation: TRUE
[10:18:34.863] Local evaluation: TRUE
[10:18:34.863] Environment: R_GlobalEnv
[10:18:34.863] Capture standard output: TRUE
[10:18:34.863] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.863] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.863] Packages: 1 packages (‘stats’)
[10:18:34.863] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.863] Resolved: TRUE
[10:18:34.863] Value: <not collected>
[10:18:34.863] Conditions captured: <none>
[10:18:34.863] Early signaling: FALSE
[10:18:34.863] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.863] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.872] Chunk #1 of 2 ... DONE
[10:18:34.873] Chunk #2 of 2 ...
[10:18:34.873]  - Finding globals in 'X' for chunk #2 ...
[10:18:34.873] getGlobalsAndPackages() ...
[10:18:34.873] Searching for globals...
[10:18:34.874] 
[10:18:34.874] Searching for globals ... DONE
[10:18:34.874] - globals: [0] <none>
[10:18:34.874] getGlobalsAndPackages() ... DONE
[10:18:34.874]    + additional globals found: [n=0] 
[10:18:34.874]    + additional namespaces needed: [n=0] 
[10:18:34.875]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:34.875]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:34.875]  - seeds: <none>
[10:18:34.875]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.875] getGlobalsAndPackages() ...
[10:18:34.875] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.875] Resolving globals: FALSE
[10:18:34.876] Tweak future expression to call with '...' arguments ...
[10:18:34.876] {
[10:18:34.876]     do.call(function(...) {
[10:18:34.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.876]             on.exit(options(oopts), add = TRUE)
[10:18:34.876]         }
[10:18:34.876]         {
[10:18:34.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.876]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.876]             })
[10:18:34.876]         }
[10:18:34.876]     }, args = future.call.arguments)
[10:18:34.876] }
[10:18:34.876] Tweak future expression to call with '...' arguments ... DONE
[10:18:34.877] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:34.877] - packages: [1] ‘stats’
[10:18:34.877] getGlobalsAndPackages() ... DONE
[10:18:34.878] run() for ‘Future’ ...
[10:18:34.878] - state: ‘created’
[10:18:34.878] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:34.881] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:34.881]   - Field: ‘label’
[10:18:34.881]   - Field: ‘local’
[10:18:34.881]   - Field: ‘owner’
[10:18:34.881]   - Field: ‘envir’
[10:18:34.882]   - Field: ‘workers’
[10:18:34.882]   - Field: ‘packages’
[10:18:34.882]   - Field: ‘gc’
[10:18:34.882]   - Field: ‘job’
[10:18:34.882]   - Field: ‘conditions’
[10:18:34.882]   - Field: ‘expr’
[10:18:34.882]   - Field: ‘uuid’
[10:18:34.883]   - Field: ‘seed’
[10:18:34.883]   - Field: ‘version’
[10:18:34.883]   - Field: ‘result’
[10:18:34.883]   - Field: ‘asynchronous’
[10:18:34.883]   - Field: ‘calls’
[10:18:34.883]   - Field: ‘globals’
[10:18:34.883]   - Field: ‘stdout’
[10:18:34.883]   - Field: ‘earlySignal’
[10:18:34.884]   - Field: ‘lazy’
[10:18:34.884]   - Field: ‘state’
[10:18:34.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:34.884] - Launch lazy future ...
[10:18:34.885] Packages needed by the future expression (n = 1): ‘stats’
[10:18:34.885] Packages needed by future strategies (n = 0): <none>
[10:18:34.886] {
[10:18:34.886]     {
[10:18:34.886]         {
[10:18:34.886]             ...future.startTime <- base::Sys.time()
[10:18:34.886]             {
[10:18:34.886]                 {
[10:18:34.886]                   {
[10:18:34.886]                     {
[10:18:34.886]                       {
[10:18:34.886]                         base::local({
[10:18:34.886]                           has_future <- base::requireNamespace("future", 
[10:18:34.886]                             quietly = TRUE)
[10:18:34.886]                           if (has_future) {
[10:18:34.886]                             ns <- base::getNamespace("future")
[10:18:34.886]                             version <- ns[[".package"]][["version"]]
[10:18:34.886]                             if (is.null(version)) 
[10:18:34.886]                               version <- utils::packageVersion("future")
[10:18:34.886]                           }
[10:18:34.886]                           else {
[10:18:34.886]                             version <- NULL
[10:18:34.886]                           }
[10:18:34.886]                           if (!has_future || version < "1.8.0") {
[10:18:34.886]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:34.886]                               "", base::R.version$version.string), 
[10:18:34.886]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:34.886]                                 base::R.version$platform, 8 * 
[10:18:34.886]                                   base::.Machine$sizeof.pointer), 
[10:18:34.886]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:34.886]                                 "release", "version")], collapse = " "), 
[10:18:34.886]                               hostname = base::Sys.info()[["nodename"]])
[10:18:34.886]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:34.886]                               info)
[10:18:34.886]                             info <- base::paste(info, collapse = "; ")
[10:18:34.886]                             if (!has_future) {
[10:18:34.886]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:34.886]                                 info)
[10:18:34.886]                             }
[10:18:34.886]                             else {
[10:18:34.886]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:34.886]                                 info, version)
[10:18:34.886]                             }
[10:18:34.886]                             base::stop(msg)
[10:18:34.886]                           }
[10:18:34.886]                         })
[10:18:34.886]                       }
[10:18:34.886]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:34.886]                       base::options(mc.cores = 1L)
[10:18:34.886]                     }
[10:18:34.886]                     base::local({
[10:18:34.886]                       for (pkg in "stats") {
[10:18:34.886]                         base::loadNamespace(pkg)
[10:18:34.886]                         base::library(pkg, character.only = TRUE)
[10:18:34.886]                       }
[10:18:34.886]                     })
[10:18:34.886]                   }
[10:18:34.886]                   ...future.strategy.old <- future::plan("list")
[10:18:34.886]                   options(future.plan = NULL)
[10:18:34.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:34.886]                 }
[10:18:34.886]                 ...future.workdir <- getwd()
[10:18:34.886]             }
[10:18:34.886]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:34.886]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:34.886]         }
[10:18:34.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:34.886]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:34.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:34.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:34.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:34.886]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:34.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:34.886]             base::names(...future.oldOptions))
[10:18:34.886]     }
[10:18:34.886]     if (FALSE) {
[10:18:34.886]     }
[10:18:34.886]     else {
[10:18:34.886]         if (TRUE) {
[10:18:34.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:34.886]                 open = "w")
[10:18:34.886]         }
[10:18:34.886]         else {
[10:18:34.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:34.886]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:34.886]         }
[10:18:34.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:34.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:34.886]             base::sink(type = "output", split = FALSE)
[10:18:34.886]             base::close(...future.stdout)
[10:18:34.886]         }, add = TRUE)
[10:18:34.886]     }
[10:18:34.886]     ...future.frame <- base::sys.nframe()
[10:18:34.886]     ...future.conditions <- base::list()
[10:18:34.886]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:34.886]     if (FALSE) {
[10:18:34.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:34.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:34.886]     }
[10:18:34.886]     ...future.result <- base::tryCatch({
[10:18:34.886]         base::withCallingHandlers({
[10:18:34.886]             ...future.value <- base::withVisible(base::local({
[10:18:34.886]                 withCallingHandlers({
[10:18:34.886]                   {
[10:18:34.886]                     do.call(function(...) {
[10:18:34.886]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.886]                       if (!identical(...future.globals.maxSize.org, 
[10:18:34.886]                         ...future.globals.maxSize)) {
[10:18:34.886]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.886]                         on.exit(options(oopts), add = TRUE)
[10:18:34.886]                       }
[10:18:34.886]                       {
[10:18:34.886]                         lapply(seq_along(...future.elements_ii), 
[10:18:34.886]                           FUN = function(jj) {
[10:18:34.886]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.886]                             ...future.FUN(...future.X_jj, ...)
[10:18:34.886]                           })
[10:18:34.886]                       }
[10:18:34.886]                     }, args = future.call.arguments)
[10:18:34.886]                   }
[10:18:34.886]                 }, immediateCondition = function(cond) {
[10:18:34.886]                   save_rds <- function (object, pathname, ...) 
[10:18:34.886]                   {
[10:18:34.886]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:34.886]                     if (file_test("-f", pathname_tmp)) {
[10:18:34.886]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.886]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:34.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.886]                         fi_tmp[["mtime"]])
[10:18:34.886]                     }
[10:18:34.886]                     tryCatch({
[10:18:34.886]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:34.886]                     }, error = function(ex) {
[10:18:34.886]                       msg <- conditionMessage(ex)
[10:18:34.886]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.886]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:34.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.886]                         fi_tmp[["mtime"]], msg)
[10:18:34.886]                       ex$message <- msg
[10:18:34.886]                       stop(ex)
[10:18:34.886]                     })
[10:18:34.886]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:34.886]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:34.886]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:34.886]                       fi_tmp <- file.info(pathname_tmp)
[10:18:34.886]                       fi <- file.info(pathname)
[10:18:34.886]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:34.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:34.886]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:34.886]                         fi[["size"]], fi[["mtime"]])
[10:18:34.886]                       stop(msg)
[10:18:34.886]                     }
[10:18:34.886]                     invisible(pathname)
[10:18:34.886]                   }
[10:18:34.886]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:34.886]                     rootPath = tempdir()) 
[10:18:34.886]                   {
[10:18:34.886]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:34.886]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:34.886]                       tmpdir = path, fileext = ".rds")
[10:18:34.886]                     save_rds(obj, file)
[10:18:34.886]                   }
[10:18:34.886]                   saveImmediateCondition(cond, path = "/tmp/RtmpC7bjnn/.future/immediateConditions")
[10:18:34.886]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.886]                   {
[10:18:34.886]                     inherits <- base::inherits
[10:18:34.886]                     invokeRestart <- base::invokeRestart
[10:18:34.886]                     is.null <- base::is.null
[10:18:34.886]                     muffled <- FALSE
[10:18:34.886]                     if (inherits(cond, "message")) {
[10:18:34.886]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:34.886]                       if (muffled) 
[10:18:34.886]                         invokeRestart("muffleMessage")
[10:18:34.886]                     }
[10:18:34.886]                     else if (inherits(cond, "warning")) {
[10:18:34.886]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:34.886]                       if (muffled) 
[10:18:34.886]                         invokeRestart("muffleWarning")
[10:18:34.886]                     }
[10:18:34.886]                     else if (inherits(cond, "condition")) {
[10:18:34.886]                       if (!is.null(pattern)) {
[10:18:34.886]                         computeRestarts <- base::computeRestarts
[10:18:34.886]                         grepl <- base::grepl
[10:18:34.886]                         restarts <- computeRestarts(cond)
[10:18:34.886]                         for (restart in restarts) {
[10:18:34.886]                           name <- restart$name
[10:18:34.886]                           if (is.null(name)) 
[10:18:34.886]                             next
[10:18:34.886]                           if (!grepl(pattern, name)) 
[10:18:34.886]                             next
[10:18:34.886]                           invokeRestart(restart)
[10:18:34.886]                           muffled <- TRUE
[10:18:34.886]                           break
[10:18:34.886]                         }
[10:18:34.886]                       }
[10:18:34.886]                     }
[10:18:34.886]                     invisible(muffled)
[10:18:34.886]                   }
[10:18:34.886]                   muffleCondition(cond)
[10:18:34.886]                 })
[10:18:34.886]             }))
[10:18:34.886]             future::FutureResult(value = ...future.value$value, 
[10:18:34.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.886]                   ...future.rng), globalenv = if (FALSE) 
[10:18:34.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:34.886]                     ...future.globalenv.names))
[10:18:34.886]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:34.886]         }, condition = base::local({
[10:18:34.886]             c <- base::c
[10:18:34.886]             inherits <- base::inherits
[10:18:34.886]             invokeRestart <- base::invokeRestart
[10:18:34.886]             length <- base::length
[10:18:34.886]             list <- base::list
[10:18:34.886]             seq.int <- base::seq.int
[10:18:34.886]             signalCondition <- base::signalCondition
[10:18:34.886]             sys.calls <- base::sys.calls
[10:18:34.886]             `[[` <- base::`[[`
[10:18:34.886]             `+` <- base::`+`
[10:18:34.886]             `<<-` <- base::`<<-`
[10:18:34.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:34.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:34.886]                   3L)]
[10:18:34.886]             }
[10:18:34.886]             function(cond) {
[10:18:34.886]                 is_error <- inherits(cond, "error")
[10:18:34.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:34.886]                   NULL)
[10:18:34.886]                 if (is_error) {
[10:18:34.886]                   sessionInformation <- function() {
[10:18:34.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:34.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:34.886]                       search = base::search(), system = base::Sys.info())
[10:18:34.886]                   }
[10:18:34.886]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:34.886]                     cond$call), session = sessionInformation(), 
[10:18:34.886]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:34.886]                   signalCondition(cond)
[10:18:34.886]                 }
[10:18:34.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:34.886]                 "immediateCondition"))) {
[10:18:34.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:34.886]                   ...future.conditions[[length(...future.conditions) + 
[10:18:34.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:34.886]                   if (TRUE && !signal) {
[10:18:34.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.886]                     {
[10:18:34.886]                       inherits <- base::inherits
[10:18:34.886]                       invokeRestart <- base::invokeRestart
[10:18:34.886]                       is.null <- base::is.null
[10:18:34.886]                       muffled <- FALSE
[10:18:34.886]                       if (inherits(cond, "message")) {
[10:18:34.886]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.886]                         if (muffled) 
[10:18:34.886]                           invokeRestart("muffleMessage")
[10:18:34.886]                       }
[10:18:34.886]                       else if (inherits(cond, "warning")) {
[10:18:34.886]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.886]                         if (muffled) 
[10:18:34.886]                           invokeRestart("muffleWarning")
[10:18:34.886]                       }
[10:18:34.886]                       else if (inherits(cond, "condition")) {
[10:18:34.886]                         if (!is.null(pattern)) {
[10:18:34.886]                           computeRestarts <- base::computeRestarts
[10:18:34.886]                           grepl <- base::grepl
[10:18:34.886]                           restarts <- computeRestarts(cond)
[10:18:34.886]                           for (restart in restarts) {
[10:18:34.886]                             name <- restart$name
[10:18:34.886]                             if (is.null(name)) 
[10:18:34.886]                               next
[10:18:34.886]                             if (!grepl(pattern, name)) 
[10:18:34.886]                               next
[10:18:34.886]                             invokeRestart(restart)
[10:18:34.886]                             muffled <- TRUE
[10:18:34.886]                             break
[10:18:34.886]                           }
[10:18:34.886]                         }
[10:18:34.886]                       }
[10:18:34.886]                       invisible(muffled)
[10:18:34.886]                     }
[10:18:34.886]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.886]                   }
[10:18:34.886]                 }
[10:18:34.886]                 else {
[10:18:34.886]                   if (TRUE) {
[10:18:34.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:34.886]                     {
[10:18:34.886]                       inherits <- base::inherits
[10:18:34.886]                       invokeRestart <- base::invokeRestart
[10:18:34.886]                       is.null <- base::is.null
[10:18:34.886]                       muffled <- FALSE
[10:18:34.886]                       if (inherits(cond, "message")) {
[10:18:34.886]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:34.886]                         if (muffled) 
[10:18:34.886]                           invokeRestart("muffleMessage")
[10:18:34.886]                       }
[10:18:34.886]                       else if (inherits(cond, "warning")) {
[10:18:34.886]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:34.886]                         if (muffled) 
[10:18:34.886]                           invokeRestart("muffleWarning")
[10:18:34.886]                       }
[10:18:34.886]                       else if (inherits(cond, "condition")) {
[10:18:34.886]                         if (!is.null(pattern)) {
[10:18:34.886]                           computeRestarts <- base::computeRestarts
[10:18:34.886]                           grepl <- base::grepl
[10:18:34.886]                           restarts <- computeRestarts(cond)
[10:18:34.886]                           for (restart in restarts) {
[10:18:34.886]                             name <- restart$name
[10:18:34.886]                             if (is.null(name)) 
[10:18:34.886]                               next
[10:18:34.886]                             if (!grepl(pattern, name)) 
[10:18:34.886]                               next
[10:18:34.886]                             invokeRestart(restart)
[10:18:34.886]                             muffled <- TRUE
[10:18:34.886]                             break
[10:18:34.886]                           }
[10:18:34.886]                         }
[10:18:34.886]                       }
[10:18:34.886]                       invisible(muffled)
[10:18:34.886]                     }
[10:18:34.886]                     muffleCondition(cond, pattern = "^muffle")
[10:18:34.886]                   }
[10:18:34.886]                 }
[10:18:34.886]             }
[10:18:34.886]         }))
[10:18:34.886]     }, error = function(ex) {
[10:18:34.886]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:34.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:34.886]                 ...future.rng), started = ...future.startTime, 
[10:18:34.886]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:34.886]             version = "1.8"), class = "FutureResult")
[10:18:34.886]     }, finally = {
[10:18:34.886]         if (!identical(...future.workdir, getwd())) 
[10:18:34.886]             setwd(...future.workdir)
[10:18:34.886]         {
[10:18:34.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:34.886]                 ...future.oldOptions$nwarnings <- NULL
[10:18:34.886]             }
[10:18:34.886]             base::options(...future.oldOptions)
[10:18:34.886]             if (.Platform$OS.type == "windows") {
[10:18:34.886]                 old_names <- names(...future.oldEnvVars)
[10:18:34.886]                 envs <- base::Sys.getenv()
[10:18:34.886]                 names <- names(envs)
[10:18:34.886]                 common <- intersect(names, old_names)
[10:18:34.886]                 added <- setdiff(names, old_names)
[10:18:34.886]                 removed <- setdiff(old_names, names)
[10:18:34.886]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:34.886]                   envs[common]]
[10:18:34.886]                 NAMES <- toupper(changed)
[10:18:34.886]                 args <- list()
[10:18:34.886]                 for (kk in seq_along(NAMES)) {
[10:18:34.886]                   name <- changed[[kk]]
[10:18:34.886]                   NAME <- NAMES[[kk]]
[10:18:34.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.886]                     next
[10:18:34.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.886]                 }
[10:18:34.886]                 NAMES <- toupper(added)
[10:18:34.886]                 for (kk in seq_along(NAMES)) {
[10:18:34.886]                   name <- added[[kk]]
[10:18:34.886]                   NAME <- NAMES[[kk]]
[10:18:34.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.886]                     next
[10:18:34.886]                   args[[name]] <- ""
[10:18:34.886]                 }
[10:18:34.886]                 NAMES <- toupper(removed)
[10:18:34.886]                 for (kk in seq_along(NAMES)) {
[10:18:34.886]                   name <- removed[[kk]]
[10:18:34.886]                   NAME <- NAMES[[kk]]
[10:18:34.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:34.886]                     next
[10:18:34.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:34.886]                 }
[10:18:34.886]                 if (length(args) > 0) 
[10:18:34.886]                   base::do.call(base::Sys.setenv, args = args)
[10:18:34.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:34.886]             }
[10:18:34.886]             else {
[10:18:34.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:34.886]             }
[10:18:34.886]             {
[10:18:34.886]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:34.886]                   0L) {
[10:18:34.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:34.886]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:34.886]                   base::options(opts)
[10:18:34.886]                 }
[10:18:34.886]                 {
[10:18:34.886]                   {
[10:18:34.886]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:34.886]                     NULL
[10:18:34.886]                   }
[10:18:34.886]                   options(future.plan = NULL)
[10:18:34.886]                   if (is.na(NA_character_)) 
[10:18:34.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:34.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:34.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:34.886]                     .init = FALSE)
[10:18:34.886]                 }
[10:18:34.886]             }
[10:18:34.886]         }
[10:18:34.886]     })
[10:18:34.886]     if (TRUE) {
[10:18:34.886]         base::sink(type = "output", split = FALSE)
[10:18:34.886]         if (TRUE) {
[10:18:34.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:34.886]         }
[10:18:34.886]         else {
[10:18:34.886]             ...future.result["stdout"] <- base::list(NULL)
[10:18:34.886]         }
[10:18:34.886]         base::close(...future.stdout)
[10:18:34.886]         ...future.stdout <- NULL
[10:18:34.886]     }
[10:18:34.886]     ...future.result$conditions <- ...future.conditions
[10:18:34.886]     ...future.result$finished <- base::Sys.time()
[10:18:34.886]     ...future.result
[10:18:34.886] }
[10:18:34.889] assign_globals() ...
[10:18:34.889] List of 5
[10:18:34.889]  $ ...future.FUN            :function (x, ...)  
[10:18:34.889]  $ future.call.arguments    : list()
[10:18:34.889]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:34.889]  $ ...future.elements_ii    :List of 2
[10:18:34.889]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:18:34.889]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:18:34.889]  $ ...future.seeds_ii       : NULL
[10:18:34.889]  $ ...future.globals.maxSize: NULL
[10:18:34.889]  - attr(*, "where")=List of 5
[10:18:34.889]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:34.889]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:34.889]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:34.889]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:34.889]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:34.889]  - attr(*, "resolved")= logi FALSE
[10:18:34.889]  - attr(*, "total_size")= num 5437
[10:18:34.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:34.889]  - attr(*, "already-done")= logi TRUE
[10:18:34.897] - copied ‘...future.FUN’ to environment
[10:18:34.897] - copied ‘future.call.arguments’ to environment
[10:18:34.897] - copied ‘...future.elements_ii’ to environment
[10:18:34.897] - copied ‘...future.seeds_ii’ to environment
[10:18:34.897] - copied ‘...future.globals.maxSize’ to environment
[10:18:34.897] assign_globals() ... done
[10:18:34.898] requestCore(): workers = 2
[10:18:34.900] MulticoreFuture started
[10:18:34.900] - Launch lazy future ... done
[10:18:34.900] run() for ‘MulticoreFuture’ ... done
[10:18:34.901] Created future:
[10:18:34.901] plan(): Setting new future strategy stack:
[10:18:34.901] List of future strategies:
[10:18:34.901] 1. sequential:
[10:18:34.901]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.901]    - tweaked: FALSE
[10:18:34.901]    - call: NULL
[10:18:34.902] plan(): nbrOfWorkers() = 1
[10:18:34.905] plan(): Setting new future strategy stack:
[10:18:34.905] List of future strategies:
[10:18:34.905] 1. multicore:
[10:18:34.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:34.905]    - tweaked: FALSE
[10:18:34.905]    - call: plan(strategy)
[10:18:34.909] plan(): nbrOfWorkers() = 2
[10:18:34.901] MulticoreFuture:
[10:18:34.901] Label: ‘future_eapply-2’
[10:18:34.901] Expression:
[10:18:34.901] {
[10:18:34.901]     do.call(function(...) {
[10:18:34.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:34.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:34.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:34.901]             on.exit(options(oopts), add = TRUE)
[10:18:34.901]         }
[10:18:34.901]         {
[10:18:34.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:34.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:34.901]                 ...future.FUN(...future.X_jj, ...)
[10:18:34.901]             })
[10:18:34.901]         }
[10:18:34.901]     }, args = future.call.arguments)
[10:18:34.901] }
[10:18:34.901] Lazy evaluation: FALSE
[10:18:34.901] Asynchronous evaluation: TRUE
[10:18:34.901] Local evaluation: TRUE
[10:18:34.901] Environment: R_GlobalEnv
[10:18:34.901] Capture standard output: TRUE
[10:18:34.901] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:34.901] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:34.901] Packages: 1 packages (‘stats’)
[10:18:34.901] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:34.901] Resolved: TRUE
[10:18:34.901] Value: <not collected>
[10:18:34.901] Conditions captured: <none>
[10:18:34.901] Early signaling: FALSE
[10:18:34.901] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:34.901] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:34.910] Chunk #2 of 2 ... DONE
[10:18:34.910] Launching 2 futures (chunks) ... DONE
[10:18:34.910] Resolving 2 futures (chunks) ...
[10:18:34.911] resolve() on list ...
[10:18:34.911]  recursive: 0
[10:18:34.911]  length: 2
[10:18:34.911] 
[10:18:34.911] Future #1
[10:18:34.911] result() for MulticoreFuture ...
[10:18:34.912] result() for MulticoreFuture ...
[10:18:34.913] result() for MulticoreFuture ... done
[10:18:34.913] result() for MulticoreFuture ... done
[10:18:34.913] result() for MulticoreFuture ...
[10:18:34.913] result() for MulticoreFuture ... done
[10:18:34.913] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:34.913] - nx: 2
[10:18:34.914] - relay: TRUE
[10:18:34.914] - stdout: TRUE
[10:18:34.914] - signal: TRUE
[10:18:34.914] - resignal: FALSE
[10:18:34.914] - force: TRUE
[10:18:34.914] - relayed: [n=2] FALSE, FALSE
[10:18:34.914] - queued futures: [n=2] FALSE, FALSE
[10:18:34.914]  - until=1
[10:18:34.915]  - relaying element #1
[10:18:34.915] result() for MulticoreFuture ...
[10:18:34.918] result() for MulticoreFuture ... done
[10:18:34.919] result() for MulticoreFuture ...
[10:18:34.919] result() for MulticoreFuture ... done
[10:18:34.919] result() for MulticoreFuture ...
[10:18:34.919] result() for MulticoreFuture ... done
[10:18:34.919] result() for MulticoreFuture ...
[10:18:34.919] result() for MulticoreFuture ... done
[10:18:34.919] - relayed: [n=2] TRUE, FALSE
[10:18:34.920] - queued futures: [n=2] TRUE, FALSE
[10:18:34.920] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:34.920]  length: 1 (resolved future 1)
[10:18:34.921] Future #2
[10:18:34.921] result() for MulticoreFuture ...
[10:18:34.922] result() for MulticoreFuture ...
[10:18:34.922] result() for MulticoreFuture ... done
[10:18:34.922] result() for MulticoreFuture ... done
[10:18:34.922] result() for MulticoreFuture ...
[10:18:34.922] result() for MulticoreFuture ... done
[10:18:34.923] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:34.923] - nx: 2
[10:18:34.923] - relay: TRUE
[10:18:34.923] - stdout: TRUE
[10:18:34.923] - signal: TRUE
[10:18:34.923] - resignal: FALSE
[10:18:34.923] - force: TRUE
[10:18:34.923] - relayed: [n=2] TRUE, FALSE
[10:18:34.924] - queued futures: [n=2] TRUE, FALSE
[10:18:34.924]  - until=2
[10:18:34.924]  - relaying element #2
[10:18:34.924] result() for MulticoreFuture ...
[10:18:34.924] result() for MulticoreFuture ... done
[10:18:34.924] result() for MulticoreFuture ...
[10:18:34.924] result() for MulticoreFuture ... done
[10:18:34.924] result() for MulticoreFuture ...
[10:18:34.925] result() for MulticoreFuture ... done
[10:18:34.925] result() for MulticoreFuture ...
[10:18:34.925] result() for MulticoreFuture ... done
[10:18:34.925] - relayed: [n=2] TRUE, TRUE
[10:18:34.925] - queued futures: [n=2] TRUE, TRUE
[10:18:34.925] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:34.925]  length: 0 (resolved future 2)
[10:18:34.925] Relaying remaining futures
[10:18:34.925] signalConditionsASAP(NULL, pos=0) ...
[10:18:34.926] - nx: 2
[10:18:34.926] - relay: TRUE
[10:18:34.926] - stdout: TRUE
[10:18:34.926] - signal: TRUE
[10:18:34.926] - resignal: FALSE
[10:18:34.926] - force: TRUE
[10:18:34.926] - relayed: [n=2] TRUE, TRUE
[10:18:34.926] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:34.926] - relayed: [n=2] TRUE, TRUE
[10:18:34.927] - queued futures: [n=2] TRUE, TRUE
[10:18:34.927] signalConditionsASAP(NULL, pos=0) ... done
[10:18:34.927] resolve() on list ... DONE
[10:18:34.927] result() for MulticoreFuture ...
[10:18:34.927] result() for MulticoreFuture ... done
[10:18:34.927] result() for MulticoreFuture ...
[10:18:34.927] result() for MulticoreFuture ... done
[10:18:34.927] result() for MulticoreFuture ...
[10:18:34.927] result() for MulticoreFuture ... done
[10:18:34.928] result() for MulticoreFuture ...
[10:18:34.928] result() for MulticoreFuture ... done
[10:18:34.928]  - Number of value chunks collected: 2
[10:18:34.928] Resolving 2 futures (chunks) ... DONE
[10:18:34.928] Reducing values from 2 chunks ...
[10:18:34.928]  - Number of values collected after concatenation: 3
[10:18:34.928]  - Number of values expected: 3
[10:18:34.928] Reducing values from 2 chunks ... DONE
[10:18:34.929] future_lapply() ... DONE
[10:18:34.929] plan(): Setting new future strategy stack:
[10:18:34.929] List of future strategies:
[10:18:34.929] 1. sequential:
[10:18:34.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:34.929]    - tweaked: FALSE
[10:18:34.929]    - call: plan(sequential)
[10:18:34.930] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:18:34.930] plan(): Setting new future strategy stack:
[10:18:34.930] List of future strategies:
[10:18:34.930] 1. multisession:
[10:18:34.930]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:34.930]    - tweaked: FALSE
[10:18:34.930]    - call: plan(strategy)
[10:18:34.931] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:18:34.931] multisession:
[10:18:34.931] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:34.931] - tweaked: FALSE
[10:18:34.931] - call: plan(strategy)
[10:18:34.935] getGlobalsAndPackages() ...
[10:18:34.936] Not searching for globals
[10:18:34.936] - globals: [0] <none>
[10:18:34.936] getGlobalsAndPackages() ... DONE
[10:18:35.431] Packages needed by the future expression (n = 0): <none>
[10:18:35.432] Packages needed by future strategies (n = 0): <none>
[10:18:35.432] {
[10:18:35.432]     {
[10:18:35.432]         {
[10:18:35.432]             ...future.startTime <- base::Sys.time()
[10:18:35.432]             {
[10:18:35.432]                 {
[10:18:35.432]                   {
[10:18:35.432]                     {
[10:18:35.432]                       base::local({
[10:18:35.432]                         has_future <- base::requireNamespace("future", 
[10:18:35.432]                           quietly = TRUE)
[10:18:35.432]                         if (has_future) {
[10:18:35.432]                           ns <- base::getNamespace("future")
[10:18:35.432]                           version <- ns[[".package"]][["version"]]
[10:18:35.432]                           if (is.null(version)) 
[10:18:35.432]                             version <- utils::packageVersion("future")
[10:18:35.432]                         }
[10:18:35.432]                         else {
[10:18:35.432]                           version <- NULL
[10:18:35.432]                         }
[10:18:35.432]                         if (!has_future || version < "1.8.0") {
[10:18:35.432]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:35.432]                             "", base::R.version$version.string), 
[10:18:35.432]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:35.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:35.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:35.432]                               "release", "version")], collapse = " "), 
[10:18:35.432]                             hostname = base::Sys.info()[["nodename"]])
[10:18:35.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:35.432]                             info)
[10:18:35.432]                           info <- base::paste(info, collapse = "; ")
[10:18:35.432]                           if (!has_future) {
[10:18:35.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:35.432]                               info)
[10:18:35.432]                           }
[10:18:35.432]                           else {
[10:18:35.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:35.432]                               info, version)
[10:18:35.432]                           }
[10:18:35.432]                           base::stop(msg)
[10:18:35.432]                         }
[10:18:35.432]                       })
[10:18:35.432]                     }
[10:18:35.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:35.432]                     base::options(mc.cores = 1L)
[10:18:35.432]                   }
[10:18:35.432]                   ...future.strategy.old <- future::plan("list")
[10:18:35.432]                   options(future.plan = NULL)
[10:18:35.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:35.432]                 }
[10:18:35.432]                 ...future.workdir <- getwd()
[10:18:35.432]             }
[10:18:35.432]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:35.432]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:35.432]         }
[10:18:35.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:35.432]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:35.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:35.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:35.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:35.432]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:35.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:35.432]             base::names(...future.oldOptions))
[10:18:35.432]     }
[10:18:35.432]     if (FALSE) {
[10:18:35.432]     }
[10:18:35.432]     else {
[10:18:35.432]         if (TRUE) {
[10:18:35.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:35.432]                 open = "w")
[10:18:35.432]         }
[10:18:35.432]         else {
[10:18:35.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:35.432]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:35.432]         }
[10:18:35.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:35.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:35.432]             base::sink(type = "output", split = FALSE)
[10:18:35.432]             base::close(...future.stdout)
[10:18:35.432]         }, add = TRUE)
[10:18:35.432]     }
[10:18:35.432]     ...future.frame <- base::sys.nframe()
[10:18:35.432]     ...future.conditions <- base::list()
[10:18:35.432]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:35.432]     if (FALSE) {
[10:18:35.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:35.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:35.432]     }
[10:18:35.432]     ...future.result <- base::tryCatch({
[10:18:35.432]         base::withCallingHandlers({
[10:18:35.432]             ...future.value <- base::withVisible(base::local({
[10:18:35.432]                 ...future.makeSendCondition <- base::local({
[10:18:35.432]                   sendCondition <- NULL
[10:18:35.432]                   function(frame = 1L) {
[10:18:35.432]                     if (is.function(sendCondition)) 
[10:18:35.432]                       return(sendCondition)
[10:18:35.432]                     ns <- getNamespace("parallel")
[10:18:35.432]                     if (exists("sendData", mode = "function", 
[10:18:35.432]                       envir = ns)) {
[10:18:35.432]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:35.432]                         envir = ns)
[10:18:35.432]                       envir <- sys.frame(frame)
[10:18:35.432]                       master <- NULL
[10:18:35.432]                       while (!identical(envir, .GlobalEnv) && 
[10:18:35.432]                         !identical(envir, emptyenv())) {
[10:18:35.432]                         if (exists("master", mode = "list", envir = envir, 
[10:18:35.432]                           inherits = FALSE)) {
[10:18:35.432]                           master <- get("master", mode = "list", 
[10:18:35.432]                             envir = envir, inherits = FALSE)
[10:18:35.432]                           if (inherits(master, c("SOCKnode", 
[10:18:35.432]                             "SOCK0node"))) {
[10:18:35.432]                             sendCondition <<- function(cond) {
[10:18:35.432]                               data <- list(type = "VALUE", value = cond, 
[10:18:35.432]                                 success = TRUE)
[10:18:35.432]                               parallel_sendData(master, data)
[10:18:35.432]                             }
[10:18:35.432]                             return(sendCondition)
[10:18:35.432]                           }
[10:18:35.432]                         }
[10:18:35.432]                         frame <- frame + 1L
[10:18:35.432]                         envir <- sys.frame(frame)
[10:18:35.432]                       }
[10:18:35.432]                     }
[10:18:35.432]                     sendCondition <<- function(cond) NULL
[10:18:35.432]                   }
[10:18:35.432]                 })
[10:18:35.432]                 withCallingHandlers({
[10:18:35.432]                   NA
[10:18:35.432]                 }, immediateCondition = function(cond) {
[10:18:35.432]                   sendCondition <- ...future.makeSendCondition()
[10:18:35.432]                   sendCondition(cond)
[10:18:35.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.432]                   {
[10:18:35.432]                     inherits <- base::inherits
[10:18:35.432]                     invokeRestart <- base::invokeRestart
[10:18:35.432]                     is.null <- base::is.null
[10:18:35.432]                     muffled <- FALSE
[10:18:35.432]                     if (inherits(cond, "message")) {
[10:18:35.432]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:35.432]                       if (muffled) 
[10:18:35.432]                         invokeRestart("muffleMessage")
[10:18:35.432]                     }
[10:18:35.432]                     else if (inherits(cond, "warning")) {
[10:18:35.432]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:35.432]                       if (muffled) 
[10:18:35.432]                         invokeRestart("muffleWarning")
[10:18:35.432]                     }
[10:18:35.432]                     else if (inherits(cond, "condition")) {
[10:18:35.432]                       if (!is.null(pattern)) {
[10:18:35.432]                         computeRestarts <- base::computeRestarts
[10:18:35.432]                         grepl <- base::grepl
[10:18:35.432]                         restarts <- computeRestarts(cond)
[10:18:35.432]                         for (restart in restarts) {
[10:18:35.432]                           name <- restart$name
[10:18:35.432]                           if (is.null(name)) 
[10:18:35.432]                             next
[10:18:35.432]                           if (!grepl(pattern, name)) 
[10:18:35.432]                             next
[10:18:35.432]                           invokeRestart(restart)
[10:18:35.432]                           muffled <- TRUE
[10:18:35.432]                           break
[10:18:35.432]                         }
[10:18:35.432]                       }
[10:18:35.432]                     }
[10:18:35.432]                     invisible(muffled)
[10:18:35.432]                   }
[10:18:35.432]                   muffleCondition(cond)
[10:18:35.432]                 })
[10:18:35.432]             }))
[10:18:35.432]             future::FutureResult(value = ...future.value$value, 
[10:18:35.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.432]                   ...future.rng), globalenv = if (FALSE) 
[10:18:35.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:35.432]                     ...future.globalenv.names))
[10:18:35.432]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:35.432]         }, condition = base::local({
[10:18:35.432]             c <- base::c
[10:18:35.432]             inherits <- base::inherits
[10:18:35.432]             invokeRestart <- base::invokeRestart
[10:18:35.432]             length <- base::length
[10:18:35.432]             list <- base::list
[10:18:35.432]             seq.int <- base::seq.int
[10:18:35.432]             signalCondition <- base::signalCondition
[10:18:35.432]             sys.calls <- base::sys.calls
[10:18:35.432]             `[[` <- base::`[[`
[10:18:35.432]             `+` <- base::`+`
[10:18:35.432]             `<<-` <- base::`<<-`
[10:18:35.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:35.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:35.432]                   3L)]
[10:18:35.432]             }
[10:18:35.432]             function(cond) {
[10:18:35.432]                 is_error <- inherits(cond, "error")
[10:18:35.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:35.432]                   NULL)
[10:18:35.432]                 if (is_error) {
[10:18:35.432]                   sessionInformation <- function() {
[10:18:35.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:35.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:35.432]                       search = base::search(), system = base::Sys.info())
[10:18:35.432]                   }
[10:18:35.432]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:35.432]                     cond$call), session = sessionInformation(), 
[10:18:35.432]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:35.432]                   signalCondition(cond)
[10:18:35.432]                 }
[10:18:35.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:35.432]                 "immediateCondition"))) {
[10:18:35.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:35.432]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:35.432]                   if (TRUE && !signal) {
[10:18:35.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.432]                     {
[10:18:35.432]                       inherits <- base::inherits
[10:18:35.432]                       invokeRestart <- base::invokeRestart
[10:18:35.432]                       is.null <- base::is.null
[10:18:35.432]                       muffled <- FALSE
[10:18:35.432]                       if (inherits(cond, "message")) {
[10:18:35.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.432]                         if (muffled) 
[10:18:35.432]                           invokeRestart("muffleMessage")
[10:18:35.432]                       }
[10:18:35.432]                       else if (inherits(cond, "warning")) {
[10:18:35.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.432]                         if (muffled) 
[10:18:35.432]                           invokeRestart("muffleWarning")
[10:18:35.432]                       }
[10:18:35.432]                       else if (inherits(cond, "condition")) {
[10:18:35.432]                         if (!is.null(pattern)) {
[10:18:35.432]                           computeRestarts <- base::computeRestarts
[10:18:35.432]                           grepl <- base::grepl
[10:18:35.432]                           restarts <- computeRestarts(cond)
[10:18:35.432]                           for (restart in restarts) {
[10:18:35.432]                             name <- restart$name
[10:18:35.432]                             if (is.null(name)) 
[10:18:35.432]                               next
[10:18:35.432]                             if (!grepl(pattern, name)) 
[10:18:35.432]                               next
[10:18:35.432]                             invokeRestart(restart)
[10:18:35.432]                             muffled <- TRUE
[10:18:35.432]                             break
[10:18:35.432]                           }
[10:18:35.432]                         }
[10:18:35.432]                       }
[10:18:35.432]                       invisible(muffled)
[10:18:35.432]                     }
[10:18:35.432]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.432]                   }
[10:18:35.432]                 }
[10:18:35.432]                 else {
[10:18:35.432]                   if (TRUE) {
[10:18:35.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.432]                     {
[10:18:35.432]                       inherits <- base::inherits
[10:18:35.432]                       invokeRestart <- base::invokeRestart
[10:18:35.432]                       is.null <- base::is.null
[10:18:35.432]                       muffled <- FALSE
[10:18:35.432]                       if (inherits(cond, "message")) {
[10:18:35.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.432]                         if (muffled) 
[10:18:35.432]                           invokeRestart("muffleMessage")
[10:18:35.432]                       }
[10:18:35.432]                       else if (inherits(cond, "warning")) {
[10:18:35.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.432]                         if (muffled) 
[10:18:35.432]                           invokeRestart("muffleWarning")
[10:18:35.432]                       }
[10:18:35.432]                       else if (inherits(cond, "condition")) {
[10:18:35.432]                         if (!is.null(pattern)) {
[10:18:35.432]                           computeRestarts <- base::computeRestarts
[10:18:35.432]                           grepl <- base::grepl
[10:18:35.432]                           restarts <- computeRestarts(cond)
[10:18:35.432]                           for (restart in restarts) {
[10:18:35.432]                             name <- restart$name
[10:18:35.432]                             if (is.null(name)) 
[10:18:35.432]                               next
[10:18:35.432]                             if (!grepl(pattern, name)) 
[10:18:35.432]                               next
[10:18:35.432]                             invokeRestart(restart)
[10:18:35.432]                             muffled <- TRUE
[10:18:35.432]                             break
[10:18:35.432]                           }
[10:18:35.432]                         }
[10:18:35.432]                       }
[10:18:35.432]                       invisible(muffled)
[10:18:35.432]                     }
[10:18:35.432]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.432]                   }
[10:18:35.432]                 }
[10:18:35.432]             }
[10:18:35.432]         }))
[10:18:35.432]     }, error = function(ex) {
[10:18:35.432]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:35.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.432]                 ...future.rng), started = ...future.startTime, 
[10:18:35.432]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:35.432]             version = "1.8"), class = "FutureResult")
[10:18:35.432]     }, finally = {
[10:18:35.432]         if (!identical(...future.workdir, getwd())) 
[10:18:35.432]             setwd(...future.workdir)
[10:18:35.432]         {
[10:18:35.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:35.432]                 ...future.oldOptions$nwarnings <- NULL
[10:18:35.432]             }
[10:18:35.432]             base::options(...future.oldOptions)
[10:18:35.432]             if (.Platform$OS.type == "windows") {
[10:18:35.432]                 old_names <- names(...future.oldEnvVars)
[10:18:35.432]                 envs <- base::Sys.getenv()
[10:18:35.432]                 names <- names(envs)
[10:18:35.432]                 common <- intersect(names, old_names)
[10:18:35.432]                 added <- setdiff(names, old_names)
[10:18:35.432]                 removed <- setdiff(old_names, names)
[10:18:35.432]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:35.432]                   envs[common]]
[10:18:35.432]                 NAMES <- toupper(changed)
[10:18:35.432]                 args <- list()
[10:18:35.432]                 for (kk in seq_along(NAMES)) {
[10:18:35.432]                   name <- changed[[kk]]
[10:18:35.432]                   NAME <- NAMES[[kk]]
[10:18:35.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.432]                     next
[10:18:35.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.432]                 }
[10:18:35.432]                 NAMES <- toupper(added)
[10:18:35.432]                 for (kk in seq_along(NAMES)) {
[10:18:35.432]                   name <- added[[kk]]
[10:18:35.432]                   NAME <- NAMES[[kk]]
[10:18:35.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.432]                     next
[10:18:35.432]                   args[[name]] <- ""
[10:18:35.432]                 }
[10:18:35.432]                 NAMES <- toupper(removed)
[10:18:35.432]                 for (kk in seq_along(NAMES)) {
[10:18:35.432]                   name <- removed[[kk]]
[10:18:35.432]                   NAME <- NAMES[[kk]]
[10:18:35.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.432]                     next
[10:18:35.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.432]                 }
[10:18:35.432]                 if (length(args) > 0) 
[10:18:35.432]                   base::do.call(base::Sys.setenv, args = args)
[10:18:35.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:35.432]             }
[10:18:35.432]             else {
[10:18:35.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:35.432]             }
[10:18:35.432]             {
[10:18:35.432]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:35.432]                   0L) {
[10:18:35.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:35.432]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:35.432]                   base::options(opts)
[10:18:35.432]                 }
[10:18:35.432]                 {
[10:18:35.432]                   {
[10:18:35.432]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:35.432]                     NULL
[10:18:35.432]                   }
[10:18:35.432]                   options(future.plan = NULL)
[10:18:35.432]                   if (is.na(NA_character_)) 
[10:18:35.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:35.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:35.432]                     .init = FALSE)
[10:18:35.432]                 }
[10:18:35.432]             }
[10:18:35.432]         }
[10:18:35.432]     })
[10:18:35.432]     if (TRUE) {
[10:18:35.432]         base::sink(type = "output", split = FALSE)
[10:18:35.432]         if (TRUE) {
[10:18:35.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:35.432]         }
[10:18:35.432]         else {
[10:18:35.432]             ...future.result["stdout"] <- base::list(NULL)
[10:18:35.432]         }
[10:18:35.432]         base::close(...future.stdout)
[10:18:35.432]         ...future.stdout <- NULL
[10:18:35.432]     }
[10:18:35.432]     ...future.result$conditions <- ...future.conditions
[10:18:35.432]     ...future.result$finished <- base::Sys.time()
[10:18:35.432]     ...future.result
[10:18:35.432] }
[10:18:35.503] MultisessionFuture started
[10:18:35.503] result() for ClusterFuture ...
[10:18:35.503] receiveMessageFromWorker() for ClusterFuture ...
[10:18:35.503] - Validating connection of MultisessionFuture
[10:18:35.535] - received message: FutureResult
[10:18:35.535] - Received FutureResult
[10:18:35.535] - Erased future from FutureRegistry
[10:18:35.535] result() for ClusterFuture ...
[10:18:35.535] - result already collected: FutureResult
[10:18:35.535] result() for ClusterFuture ... done
[10:18:35.536] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:35.536] result() for ClusterFuture ... done
[10:18:35.536] result() for ClusterFuture ...
[10:18:35.536] - result already collected: FutureResult
[10:18:35.536] result() for ClusterFuture ... done
[10:18:35.536] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:18:35.538] plan(): nbrOfWorkers() = 2
[10:18:35.538] future_lapply() ...
[10:18:35.540] Number of chunks: 2
[10:18:35.540] getGlobalsAndPackagesXApply() ...
[10:18:35.540]  - future.globals: TRUE
[10:18:35.540] getGlobalsAndPackages() ...
[10:18:35.540] Searching for globals...
[10:18:35.541] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:35.541] Searching for globals ... DONE
[10:18:35.541] Resolving globals: FALSE
[10:18:35.542] The total size of the 1 globals is 273 bytes (273 bytes)
[10:18:35.542] The total size of the 1 globals exported for future expression (‘FUN()’) is 273 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (273 bytes of class ‘function’)
[10:18:35.542] - globals: [1] ‘FUN’
[10:18:35.542] 
[10:18:35.542] getGlobalsAndPackages() ... DONE
[10:18:35.542]  - globals found/used: [n=1] ‘FUN’
[10:18:35.543]  - needed namespaces: [n=0] 
[10:18:35.543] Finding globals ... DONE
[10:18:35.543]  - use_args: TRUE
[10:18:35.543]  - Getting '...' globals ...
[10:18:35.543] resolve() on list ...
[10:18:35.543]  recursive: 0
[10:18:35.543]  length: 1
[10:18:35.543]  elements: ‘...’
[10:18:35.544]  length: 0 (resolved future 1)
[10:18:35.544] resolve() on list ... DONE
[10:18:35.544]    - '...' content: [n=0] 
[10:18:35.544] List of 1
[10:18:35.544]  $ ...: list()
[10:18:35.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:35.544]  - attr(*, "where")=List of 1
[10:18:35.544]   ..$ ...:<environment: 0x56033cc93a18> 
[10:18:35.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:35.544]  - attr(*, "resolved")= logi TRUE
[10:18:35.544]  - attr(*, "total_size")= num NA
[10:18:35.546]  - Getting '...' globals ... DONE
[10:18:35.546] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:35.546] List of 2
[10:18:35.546]  $ ...future.FUN:function (x, ...)  
[10:18:35.546]  $ ...          : list()
[10:18:35.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:35.546]  - attr(*, "where")=List of 2
[10:18:35.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:35.546]   ..$ ...          :<environment: 0x56033cc93a18> 
[10:18:35.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:35.546]  - attr(*, "resolved")= logi FALSE
[10:18:35.546]  - attr(*, "total_size")= num 5249
[10:18:35.549] Packages to be attached in all futures: [n=0] 
[10:18:35.549] getGlobalsAndPackagesXApply() ... DONE
[10:18:35.549] Number of futures (= number of chunks): 2
[10:18:35.549] Launching 2 futures (chunks) ...
[10:18:35.549] Chunk #1 of 2 ...
[10:18:35.550]  - Finding globals in 'X' for chunk #1 ...
[10:18:35.550] getGlobalsAndPackages() ...
[10:18:35.550] Searching for globals...
[10:18:35.550] 
[10:18:35.550] Searching for globals ... DONE
[10:18:35.550] - globals: [0] <none>
[10:18:35.550] getGlobalsAndPackages() ... DONE
[10:18:35.550]    + additional globals found: [n=0] 
[10:18:35.550]    + additional namespaces needed: [n=0] 
[10:18:35.551]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:35.551]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:35.551]  - seeds: <none>
[10:18:35.551]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.551] getGlobalsAndPackages() ...
[10:18:35.551] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.551] Resolving globals: FALSE
[10:18:35.551] Tweak future expression to call with '...' arguments ...
[10:18:35.551] {
[10:18:35.551]     do.call(function(...) {
[10:18:35.551]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.551]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.551]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.551]             on.exit(options(oopts), add = TRUE)
[10:18:35.551]         }
[10:18:35.551]         {
[10:18:35.551]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.551]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.551]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.551]             })
[10:18:35.551]         }
[10:18:35.551]     }, args = future.call.arguments)
[10:18:35.551] }
[10:18:35.552] Tweak future expression to call with '...' arguments ... DONE
[10:18:35.552] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.552] 
[10:18:35.552] getGlobalsAndPackages() ... DONE
[10:18:35.552] run() for ‘Future’ ...
[10:18:35.552] - state: ‘created’
[10:18:35.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:35.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:35.568]   - Field: ‘node’
[10:18:35.568]   - Field: ‘label’
[10:18:35.568]   - Field: ‘local’
[10:18:35.568]   - Field: ‘owner’
[10:18:35.568]   - Field: ‘envir’
[10:18:35.568]   - Field: ‘workers’
[10:18:35.568]   - Field: ‘packages’
[10:18:35.568]   - Field: ‘gc’
[10:18:35.568]   - Field: ‘conditions’
[10:18:35.568]   - Field: ‘persistent’
[10:18:35.569]   - Field: ‘expr’
[10:18:35.569]   - Field: ‘uuid’
[10:18:35.569]   - Field: ‘seed’
[10:18:35.569]   - Field: ‘version’
[10:18:35.569]   - Field: ‘result’
[10:18:35.569]   - Field: ‘asynchronous’
[10:18:35.569]   - Field: ‘calls’
[10:18:35.569]   - Field: ‘globals’
[10:18:35.569]   - Field: ‘stdout’
[10:18:35.570]   - Field: ‘earlySignal’
[10:18:35.570]   - Field: ‘lazy’
[10:18:35.570]   - Field: ‘state’
[10:18:35.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:35.570] - Launch lazy future ...
[10:18:35.570] Packages needed by the future expression (n = 0): <none>
[10:18:35.570] Packages needed by future strategies (n = 0): <none>
[10:18:35.571] {
[10:18:35.571]     {
[10:18:35.571]         {
[10:18:35.571]             ...future.startTime <- base::Sys.time()
[10:18:35.571]             {
[10:18:35.571]                 {
[10:18:35.571]                   {
[10:18:35.571]                     {
[10:18:35.571]                       base::local({
[10:18:35.571]                         has_future <- base::requireNamespace("future", 
[10:18:35.571]                           quietly = TRUE)
[10:18:35.571]                         if (has_future) {
[10:18:35.571]                           ns <- base::getNamespace("future")
[10:18:35.571]                           version <- ns[[".package"]][["version"]]
[10:18:35.571]                           if (is.null(version)) 
[10:18:35.571]                             version <- utils::packageVersion("future")
[10:18:35.571]                         }
[10:18:35.571]                         else {
[10:18:35.571]                           version <- NULL
[10:18:35.571]                         }
[10:18:35.571]                         if (!has_future || version < "1.8.0") {
[10:18:35.571]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:35.571]                             "", base::R.version$version.string), 
[10:18:35.571]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:35.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:35.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:35.571]                               "release", "version")], collapse = " "), 
[10:18:35.571]                             hostname = base::Sys.info()[["nodename"]])
[10:18:35.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:35.571]                             info)
[10:18:35.571]                           info <- base::paste(info, collapse = "; ")
[10:18:35.571]                           if (!has_future) {
[10:18:35.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:35.571]                               info)
[10:18:35.571]                           }
[10:18:35.571]                           else {
[10:18:35.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:35.571]                               info, version)
[10:18:35.571]                           }
[10:18:35.571]                           base::stop(msg)
[10:18:35.571]                         }
[10:18:35.571]                       })
[10:18:35.571]                     }
[10:18:35.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:35.571]                     base::options(mc.cores = 1L)
[10:18:35.571]                   }
[10:18:35.571]                   ...future.strategy.old <- future::plan("list")
[10:18:35.571]                   options(future.plan = NULL)
[10:18:35.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:35.571]                 }
[10:18:35.571]                 ...future.workdir <- getwd()
[10:18:35.571]             }
[10:18:35.571]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:35.571]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:35.571]         }
[10:18:35.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:35.571]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:35.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:35.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:35.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:35.571]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:35.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:35.571]             base::names(...future.oldOptions))
[10:18:35.571]     }
[10:18:35.571]     if (FALSE) {
[10:18:35.571]     }
[10:18:35.571]     else {
[10:18:35.571]         if (TRUE) {
[10:18:35.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:35.571]                 open = "w")
[10:18:35.571]         }
[10:18:35.571]         else {
[10:18:35.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:35.571]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:35.571]         }
[10:18:35.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:35.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:35.571]             base::sink(type = "output", split = FALSE)
[10:18:35.571]             base::close(...future.stdout)
[10:18:35.571]         }, add = TRUE)
[10:18:35.571]     }
[10:18:35.571]     ...future.frame <- base::sys.nframe()
[10:18:35.571]     ...future.conditions <- base::list()
[10:18:35.571]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:35.571]     if (FALSE) {
[10:18:35.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:35.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:35.571]     }
[10:18:35.571]     ...future.result <- base::tryCatch({
[10:18:35.571]         base::withCallingHandlers({
[10:18:35.571]             ...future.value <- base::withVisible(base::local({
[10:18:35.571]                 ...future.makeSendCondition <- base::local({
[10:18:35.571]                   sendCondition <- NULL
[10:18:35.571]                   function(frame = 1L) {
[10:18:35.571]                     if (is.function(sendCondition)) 
[10:18:35.571]                       return(sendCondition)
[10:18:35.571]                     ns <- getNamespace("parallel")
[10:18:35.571]                     if (exists("sendData", mode = "function", 
[10:18:35.571]                       envir = ns)) {
[10:18:35.571]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:35.571]                         envir = ns)
[10:18:35.571]                       envir <- sys.frame(frame)
[10:18:35.571]                       master <- NULL
[10:18:35.571]                       while (!identical(envir, .GlobalEnv) && 
[10:18:35.571]                         !identical(envir, emptyenv())) {
[10:18:35.571]                         if (exists("master", mode = "list", envir = envir, 
[10:18:35.571]                           inherits = FALSE)) {
[10:18:35.571]                           master <- get("master", mode = "list", 
[10:18:35.571]                             envir = envir, inherits = FALSE)
[10:18:35.571]                           if (inherits(master, c("SOCKnode", 
[10:18:35.571]                             "SOCK0node"))) {
[10:18:35.571]                             sendCondition <<- function(cond) {
[10:18:35.571]                               data <- list(type = "VALUE", value = cond, 
[10:18:35.571]                                 success = TRUE)
[10:18:35.571]                               parallel_sendData(master, data)
[10:18:35.571]                             }
[10:18:35.571]                             return(sendCondition)
[10:18:35.571]                           }
[10:18:35.571]                         }
[10:18:35.571]                         frame <- frame + 1L
[10:18:35.571]                         envir <- sys.frame(frame)
[10:18:35.571]                       }
[10:18:35.571]                     }
[10:18:35.571]                     sendCondition <<- function(cond) NULL
[10:18:35.571]                   }
[10:18:35.571]                 })
[10:18:35.571]                 withCallingHandlers({
[10:18:35.571]                   {
[10:18:35.571]                     do.call(function(...) {
[10:18:35.571]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.571]                       if (!identical(...future.globals.maxSize.org, 
[10:18:35.571]                         ...future.globals.maxSize)) {
[10:18:35.571]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.571]                         on.exit(options(oopts), add = TRUE)
[10:18:35.571]                       }
[10:18:35.571]                       {
[10:18:35.571]                         lapply(seq_along(...future.elements_ii), 
[10:18:35.571]                           FUN = function(jj) {
[10:18:35.571]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.571]                             ...future.FUN(...future.X_jj, ...)
[10:18:35.571]                           })
[10:18:35.571]                       }
[10:18:35.571]                     }, args = future.call.arguments)
[10:18:35.571]                   }
[10:18:35.571]                 }, immediateCondition = function(cond) {
[10:18:35.571]                   sendCondition <- ...future.makeSendCondition()
[10:18:35.571]                   sendCondition(cond)
[10:18:35.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.571]                   {
[10:18:35.571]                     inherits <- base::inherits
[10:18:35.571]                     invokeRestart <- base::invokeRestart
[10:18:35.571]                     is.null <- base::is.null
[10:18:35.571]                     muffled <- FALSE
[10:18:35.571]                     if (inherits(cond, "message")) {
[10:18:35.571]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:35.571]                       if (muffled) 
[10:18:35.571]                         invokeRestart("muffleMessage")
[10:18:35.571]                     }
[10:18:35.571]                     else if (inherits(cond, "warning")) {
[10:18:35.571]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:35.571]                       if (muffled) 
[10:18:35.571]                         invokeRestart("muffleWarning")
[10:18:35.571]                     }
[10:18:35.571]                     else if (inherits(cond, "condition")) {
[10:18:35.571]                       if (!is.null(pattern)) {
[10:18:35.571]                         computeRestarts <- base::computeRestarts
[10:18:35.571]                         grepl <- base::grepl
[10:18:35.571]                         restarts <- computeRestarts(cond)
[10:18:35.571]                         for (restart in restarts) {
[10:18:35.571]                           name <- restart$name
[10:18:35.571]                           if (is.null(name)) 
[10:18:35.571]                             next
[10:18:35.571]                           if (!grepl(pattern, name)) 
[10:18:35.571]                             next
[10:18:35.571]                           invokeRestart(restart)
[10:18:35.571]                           muffled <- TRUE
[10:18:35.571]                           break
[10:18:35.571]                         }
[10:18:35.571]                       }
[10:18:35.571]                     }
[10:18:35.571]                     invisible(muffled)
[10:18:35.571]                   }
[10:18:35.571]                   muffleCondition(cond)
[10:18:35.571]                 })
[10:18:35.571]             }))
[10:18:35.571]             future::FutureResult(value = ...future.value$value, 
[10:18:35.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.571]                   ...future.rng), globalenv = if (FALSE) 
[10:18:35.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:35.571]                     ...future.globalenv.names))
[10:18:35.571]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:35.571]         }, condition = base::local({
[10:18:35.571]             c <- base::c
[10:18:35.571]             inherits <- base::inherits
[10:18:35.571]             invokeRestart <- base::invokeRestart
[10:18:35.571]             length <- base::length
[10:18:35.571]             list <- base::list
[10:18:35.571]             seq.int <- base::seq.int
[10:18:35.571]             signalCondition <- base::signalCondition
[10:18:35.571]             sys.calls <- base::sys.calls
[10:18:35.571]             `[[` <- base::`[[`
[10:18:35.571]             `+` <- base::`+`
[10:18:35.571]             `<<-` <- base::`<<-`
[10:18:35.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:35.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:35.571]                   3L)]
[10:18:35.571]             }
[10:18:35.571]             function(cond) {
[10:18:35.571]                 is_error <- inherits(cond, "error")
[10:18:35.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:35.571]                   NULL)
[10:18:35.571]                 if (is_error) {
[10:18:35.571]                   sessionInformation <- function() {
[10:18:35.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:35.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:35.571]                       search = base::search(), system = base::Sys.info())
[10:18:35.571]                   }
[10:18:35.571]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:35.571]                     cond$call), session = sessionInformation(), 
[10:18:35.571]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:35.571]                   signalCondition(cond)
[10:18:35.571]                 }
[10:18:35.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:35.571]                 "immediateCondition"))) {
[10:18:35.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:35.571]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:35.571]                   if (TRUE && !signal) {
[10:18:35.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.571]                     {
[10:18:35.571]                       inherits <- base::inherits
[10:18:35.571]                       invokeRestart <- base::invokeRestart
[10:18:35.571]                       is.null <- base::is.null
[10:18:35.571]                       muffled <- FALSE
[10:18:35.571]                       if (inherits(cond, "message")) {
[10:18:35.571]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.571]                         if (muffled) 
[10:18:35.571]                           invokeRestart("muffleMessage")
[10:18:35.571]                       }
[10:18:35.571]                       else if (inherits(cond, "warning")) {
[10:18:35.571]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.571]                         if (muffled) 
[10:18:35.571]                           invokeRestart("muffleWarning")
[10:18:35.571]                       }
[10:18:35.571]                       else if (inherits(cond, "condition")) {
[10:18:35.571]                         if (!is.null(pattern)) {
[10:18:35.571]                           computeRestarts <- base::computeRestarts
[10:18:35.571]                           grepl <- base::grepl
[10:18:35.571]                           restarts <- computeRestarts(cond)
[10:18:35.571]                           for (restart in restarts) {
[10:18:35.571]                             name <- restart$name
[10:18:35.571]                             if (is.null(name)) 
[10:18:35.571]                               next
[10:18:35.571]                             if (!grepl(pattern, name)) 
[10:18:35.571]                               next
[10:18:35.571]                             invokeRestart(restart)
[10:18:35.571]                             muffled <- TRUE
[10:18:35.571]                             break
[10:18:35.571]                           }
[10:18:35.571]                         }
[10:18:35.571]                       }
[10:18:35.571]                       invisible(muffled)
[10:18:35.571]                     }
[10:18:35.571]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.571]                   }
[10:18:35.571]                 }
[10:18:35.571]                 else {
[10:18:35.571]                   if (TRUE) {
[10:18:35.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.571]                     {
[10:18:35.571]                       inherits <- base::inherits
[10:18:35.571]                       invokeRestart <- base::invokeRestart
[10:18:35.571]                       is.null <- base::is.null
[10:18:35.571]                       muffled <- FALSE
[10:18:35.571]                       if (inherits(cond, "message")) {
[10:18:35.571]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.571]                         if (muffled) 
[10:18:35.571]                           invokeRestart("muffleMessage")
[10:18:35.571]                       }
[10:18:35.571]                       else if (inherits(cond, "warning")) {
[10:18:35.571]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.571]                         if (muffled) 
[10:18:35.571]                           invokeRestart("muffleWarning")
[10:18:35.571]                       }
[10:18:35.571]                       else if (inherits(cond, "condition")) {
[10:18:35.571]                         if (!is.null(pattern)) {
[10:18:35.571]                           computeRestarts <- base::computeRestarts
[10:18:35.571]                           grepl <- base::grepl
[10:18:35.571]                           restarts <- computeRestarts(cond)
[10:18:35.571]                           for (restart in restarts) {
[10:18:35.571]                             name <- restart$name
[10:18:35.571]                             if (is.null(name)) 
[10:18:35.571]                               next
[10:18:35.571]                             if (!grepl(pattern, name)) 
[10:18:35.571]                               next
[10:18:35.571]                             invokeRestart(restart)
[10:18:35.571]                             muffled <- TRUE
[10:18:35.571]                             break
[10:18:35.571]                           }
[10:18:35.571]                         }
[10:18:35.571]                       }
[10:18:35.571]                       invisible(muffled)
[10:18:35.571]                     }
[10:18:35.571]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.571]                   }
[10:18:35.571]                 }
[10:18:35.571]             }
[10:18:35.571]         }))
[10:18:35.571]     }, error = function(ex) {
[10:18:35.571]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:35.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.571]                 ...future.rng), started = ...future.startTime, 
[10:18:35.571]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:35.571]             version = "1.8"), class = "FutureResult")
[10:18:35.571]     }, finally = {
[10:18:35.571]         if (!identical(...future.workdir, getwd())) 
[10:18:35.571]             setwd(...future.workdir)
[10:18:35.571]         {
[10:18:35.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:35.571]                 ...future.oldOptions$nwarnings <- NULL
[10:18:35.571]             }
[10:18:35.571]             base::options(...future.oldOptions)
[10:18:35.571]             if (.Platform$OS.type == "windows") {
[10:18:35.571]                 old_names <- names(...future.oldEnvVars)
[10:18:35.571]                 envs <- base::Sys.getenv()
[10:18:35.571]                 names <- names(envs)
[10:18:35.571]                 common <- intersect(names, old_names)
[10:18:35.571]                 added <- setdiff(names, old_names)
[10:18:35.571]                 removed <- setdiff(old_names, names)
[10:18:35.571]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:35.571]                   envs[common]]
[10:18:35.571]                 NAMES <- toupper(changed)
[10:18:35.571]                 args <- list()
[10:18:35.571]                 for (kk in seq_along(NAMES)) {
[10:18:35.571]                   name <- changed[[kk]]
[10:18:35.571]                   NAME <- NAMES[[kk]]
[10:18:35.571]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.571]                     next
[10:18:35.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.571]                 }
[10:18:35.571]                 NAMES <- toupper(added)
[10:18:35.571]                 for (kk in seq_along(NAMES)) {
[10:18:35.571]                   name <- added[[kk]]
[10:18:35.571]                   NAME <- NAMES[[kk]]
[10:18:35.571]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.571]                     next
[10:18:35.571]                   args[[name]] <- ""
[10:18:35.571]                 }
[10:18:35.571]                 NAMES <- toupper(removed)
[10:18:35.571]                 for (kk in seq_along(NAMES)) {
[10:18:35.571]                   name <- removed[[kk]]
[10:18:35.571]                   NAME <- NAMES[[kk]]
[10:18:35.571]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.571]                     next
[10:18:35.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.571]                 }
[10:18:35.571]                 if (length(args) > 0) 
[10:18:35.571]                   base::do.call(base::Sys.setenv, args = args)
[10:18:35.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:35.571]             }
[10:18:35.571]             else {
[10:18:35.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:35.571]             }
[10:18:35.571]             {
[10:18:35.571]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:35.571]                   0L) {
[10:18:35.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:35.571]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:35.571]                   base::options(opts)
[10:18:35.571]                 }
[10:18:35.571]                 {
[10:18:35.571]                   {
[10:18:35.571]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:35.571]                     NULL
[10:18:35.571]                   }
[10:18:35.571]                   options(future.plan = NULL)
[10:18:35.571]                   if (is.na(NA_character_)) 
[10:18:35.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:35.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:35.571]                     .init = FALSE)
[10:18:35.571]                 }
[10:18:35.571]             }
[10:18:35.571]         }
[10:18:35.571]     })
[10:18:35.571]     if (TRUE) {
[10:18:35.571]         base::sink(type = "output", split = FALSE)
[10:18:35.571]         if (TRUE) {
[10:18:35.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:35.571]         }
[10:18:35.571]         else {
[10:18:35.571]             ...future.result["stdout"] <- base::list(NULL)
[10:18:35.571]         }
[10:18:35.571]         base::close(...future.stdout)
[10:18:35.571]         ...future.stdout <- NULL
[10:18:35.571]     }
[10:18:35.571]     ...future.result$conditions <- ...future.conditions
[10:18:35.571]     ...future.result$finished <- base::Sys.time()
[10:18:35.571]     ...future.result
[10:18:35.571] }
[10:18:35.574] Exporting 5 global objects (942 bytes) to cluster node #1 ...
[10:18:35.574] Exporting ‘...future.FUN’ (273 bytes) to cluster node #1 ...
[10:18:35.575] Exporting ‘...future.FUN’ (273 bytes) to cluster node #1 ... DONE
[10:18:35.575] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:35.575] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:35.576] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #1 ...
[10:18:35.576] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #1 ... DONE
[10:18:35.576] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:35.576] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:35.576] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:35.577] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:35.577] Exporting 5 global objects (942 bytes) to cluster node #1 ... DONE
[10:18:35.577] MultisessionFuture started
[10:18:35.578] - Launch lazy future ... done
[10:18:35.578] run() for ‘MultisessionFuture’ ... done
[10:18:35.578] Created future:
[10:18:35.578] MultisessionFuture:
[10:18:35.578] Label: ‘future_eapply-1’
[10:18:35.578] Expression:
[10:18:35.578] {
[10:18:35.578]     do.call(function(...) {
[10:18:35.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.578]             on.exit(options(oopts), add = TRUE)
[10:18:35.578]         }
[10:18:35.578]         {
[10:18:35.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.578]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.578]             })
[10:18:35.578]         }
[10:18:35.578]     }, args = future.call.arguments)
[10:18:35.578] }
[10:18:35.578] Lazy evaluation: FALSE
[10:18:35.578] Asynchronous evaluation: TRUE
[10:18:35.578] Local evaluation: TRUE
[10:18:35.578] Environment: R_GlobalEnv
[10:18:35.578] Capture standard output: TRUE
[10:18:35.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:35.578] Globals: 5 objects totaling 479 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:35.578] Packages: <none>
[10:18:35.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:35.578] Resolved: FALSE
[10:18:35.578] Value: <not collected>
[10:18:35.578] Conditions captured: <none>
[10:18:35.578] Early signaling: FALSE
[10:18:35.578] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:35.578] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.590] Chunk #1 of 2 ... DONE
[10:18:35.590] Chunk #2 of 2 ...
[10:18:35.590]  - Finding globals in 'X' for chunk #2 ...
[10:18:35.590] getGlobalsAndPackages() ...
[10:18:35.590] Searching for globals...
[10:18:35.591] 
[10:18:35.591] Searching for globals ... DONE
[10:18:35.591] - globals: [0] <none>
[10:18:35.591] getGlobalsAndPackages() ... DONE
[10:18:35.591]    + additional globals found: [n=0] 
[10:18:35.591]    + additional namespaces needed: [n=0] 
[10:18:35.591]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:35.592]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:35.592]  - seeds: <none>
[10:18:35.592]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.592] getGlobalsAndPackages() ...
[10:18:35.592] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.592] Resolving globals: FALSE
[10:18:35.592] Tweak future expression to call with '...' arguments ...
[10:18:35.592] {
[10:18:35.592]     do.call(function(...) {
[10:18:35.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.592]             on.exit(options(oopts), add = TRUE)
[10:18:35.592]         }
[10:18:35.592]         {
[10:18:35.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.592]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.592]             })
[10:18:35.592]         }
[10:18:35.592]     }, args = future.call.arguments)
[10:18:35.592] }
[10:18:35.593] Tweak future expression to call with '...' arguments ... DONE
[10:18:35.593] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.593] 
[10:18:35.593] getGlobalsAndPackages() ... DONE
[10:18:35.594] run() for ‘Future’ ...
[10:18:35.594] - state: ‘created’
[10:18:35.594] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:35.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:35.609]   - Field: ‘node’
[10:18:35.609]   - Field: ‘label’
[10:18:35.609]   - Field: ‘local’
[10:18:35.609]   - Field: ‘owner’
[10:18:35.609]   - Field: ‘envir’
[10:18:35.609]   - Field: ‘workers’
[10:18:35.609]   - Field: ‘packages’
[10:18:35.610]   - Field: ‘gc’
[10:18:35.610]   - Field: ‘conditions’
[10:18:35.610]   - Field: ‘persistent’
[10:18:35.610]   - Field: ‘expr’
[10:18:35.610]   - Field: ‘uuid’
[10:18:35.610]   - Field: ‘seed’
[10:18:35.610]   - Field: ‘version’
[10:18:35.610]   - Field: ‘result’
[10:18:35.610]   - Field: ‘asynchronous’
[10:18:35.610]   - Field: ‘calls’
[10:18:35.611]   - Field: ‘globals’
[10:18:35.611]   - Field: ‘stdout’
[10:18:35.611]   - Field: ‘earlySignal’
[10:18:35.611]   - Field: ‘lazy’
[10:18:35.611]   - Field: ‘state’
[10:18:35.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:35.611] - Launch lazy future ...
[10:18:35.612] Packages needed by the future expression (n = 0): <none>
[10:18:35.612] Packages needed by future strategies (n = 0): <none>
[10:18:35.612] {
[10:18:35.612]     {
[10:18:35.612]         {
[10:18:35.612]             ...future.startTime <- base::Sys.time()
[10:18:35.612]             {
[10:18:35.612]                 {
[10:18:35.612]                   {
[10:18:35.612]                     {
[10:18:35.612]                       base::local({
[10:18:35.612]                         has_future <- base::requireNamespace("future", 
[10:18:35.612]                           quietly = TRUE)
[10:18:35.612]                         if (has_future) {
[10:18:35.612]                           ns <- base::getNamespace("future")
[10:18:35.612]                           version <- ns[[".package"]][["version"]]
[10:18:35.612]                           if (is.null(version)) 
[10:18:35.612]                             version <- utils::packageVersion("future")
[10:18:35.612]                         }
[10:18:35.612]                         else {
[10:18:35.612]                           version <- NULL
[10:18:35.612]                         }
[10:18:35.612]                         if (!has_future || version < "1.8.0") {
[10:18:35.612]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:35.612]                             "", base::R.version$version.string), 
[10:18:35.612]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:35.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:35.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:35.612]                               "release", "version")], collapse = " "), 
[10:18:35.612]                             hostname = base::Sys.info()[["nodename"]])
[10:18:35.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:35.612]                             info)
[10:18:35.612]                           info <- base::paste(info, collapse = "; ")
[10:18:35.612]                           if (!has_future) {
[10:18:35.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:35.612]                               info)
[10:18:35.612]                           }
[10:18:35.612]                           else {
[10:18:35.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:35.612]                               info, version)
[10:18:35.612]                           }
[10:18:35.612]                           base::stop(msg)
[10:18:35.612]                         }
[10:18:35.612]                       })
[10:18:35.612]                     }
[10:18:35.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:35.612]                     base::options(mc.cores = 1L)
[10:18:35.612]                   }
[10:18:35.612]                   ...future.strategy.old <- future::plan("list")
[10:18:35.612]                   options(future.plan = NULL)
[10:18:35.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:35.612]                 }
[10:18:35.612]                 ...future.workdir <- getwd()
[10:18:35.612]             }
[10:18:35.612]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:35.612]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:35.612]         }
[10:18:35.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:35.612]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:35.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:35.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:35.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:35.612]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:35.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:35.612]             base::names(...future.oldOptions))
[10:18:35.612]     }
[10:18:35.612]     if (FALSE) {
[10:18:35.612]     }
[10:18:35.612]     else {
[10:18:35.612]         if (TRUE) {
[10:18:35.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:35.612]                 open = "w")
[10:18:35.612]         }
[10:18:35.612]         else {
[10:18:35.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:35.612]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:35.612]         }
[10:18:35.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:35.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:35.612]             base::sink(type = "output", split = FALSE)
[10:18:35.612]             base::close(...future.stdout)
[10:18:35.612]         }, add = TRUE)
[10:18:35.612]     }
[10:18:35.612]     ...future.frame <- base::sys.nframe()
[10:18:35.612]     ...future.conditions <- base::list()
[10:18:35.612]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:35.612]     if (FALSE) {
[10:18:35.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:35.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:35.612]     }
[10:18:35.612]     ...future.result <- base::tryCatch({
[10:18:35.612]         base::withCallingHandlers({
[10:18:35.612]             ...future.value <- base::withVisible(base::local({
[10:18:35.612]                 ...future.makeSendCondition <- base::local({
[10:18:35.612]                   sendCondition <- NULL
[10:18:35.612]                   function(frame = 1L) {
[10:18:35.612]                     if (is.function(sendCondition)) 
[10:18:35.612]                       return(sendCondition)
[10:18:35.612]                     ns <- getNamespace("parallel")
[10:18:35.612]                     if (exists("sendData", mode = "function", 
[10:18:35.612]                       envir = ns)) {
[10:18:35.612]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:35.612]                         envir = ns)
[10:18:35.612]                       envir <- sys.frame(frame)
[10:18:35.612]                       master <- NULL
[10:18:35.612]                       while (!identical(envir, .GlobalEnv) && 
[10:18:35.612]                         !identical(envir, emptyenv())) {
[10:18:35.612]                         if (exists("master", mode = "list", envir = envir, 
[10:18:35.612]                           inherits = FALSE)) {
[10:18:35.612]                           master <- get("master", mode = "list", 
[10:18:35.612]                             envir = envir, inherits = FALSE)
[10:18:35.612]                           if (inherits(master, c("SOCKnode", 
[10:18:35.612]                             "SOCK0node"))) {
[10:18:35.612]                             sendCondition <<- function(cond) {
[10:18:35.612]                               data <- list(type = "VALUE", value = cond, 
[10:18:35.612]                                 success = TRUE)
[10:18:35.612]                               parallel_sendData(master, data)
[10:18:35.612]                             }
[10:18:35.612]                             return(sendCondition)
[10:18:35.612]                           }
[10:18:35.612]                         }
[10:18:35.612]                         frame <- frame + 1L
[10:18:35.612]                         envir <- sys.frame(frame)
[10:18:35.612]                       }
[10:18:35.612]                     }
[10:18:35.612]                     sendCondition <<- function(cond) NULL
[10:18:35.612]                   }
[10:18:35.612]                 })
[10:18:35.612]                 withCallingHandlers({
[10:18:35.612]                   {
[10:18:35.612]                     do.call(function(...) {
[10:18:35.612]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.612]                       if (!identical(...future.globals.maxSize.org, 
[10:18:35.612]                         ...future.globals.maxSize)) {
[10:18:35.612]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.612]                         on.exit(options(oopts), add = TRUE)
[10:18:35.612]                       }
[10:18:35.612]                       {
[10:18:35.612]                         lapply(seq_along(...future.elements_ii), 
[10:18:35.612]                           FUN = function(jj) {
[10:18:35.612]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.612]                             ...future.FUN(...future.X_jj, ...)
[10:18:35.612]                           })
[10:18:35.612]                       }
[10:18:35.612]                     }, args = future.call.arguments)
[10:18:35.612]                   }
[10:18:35.612]                 }, immediateCondition = function(cond) {
[10:18:35.612]                   sendCondition <- ...future.makeSendCondition()
[10:18:35.612]                   sendCondition(cond)
[10:18:35.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.612]                   {
[10:18:35.612]                     inherits <- base::inherits
[10:18:35.612]                     invokeRestart <- base::invokeRestart
[10:18:35.612]                     is.null <- base::is.null
[10:18:35.612]                     muffled <- FALSE
[10:18:35.612]                     if (inherits(cond, "message")) {
[10:18:35.612]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:35.612]                       if (muffled) 
[10:18:35.612]                         invokeRestart("muffleMessage")
[10:18:35.612]                     }
[10:18:35.612]                     else if (inherits(cond, "warning")) {
[10:18:35.612]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:35.612]                       if (muffled) 
[10:18:35.612]                         invokeRestart("muffleWarning")
[10:18:35.612]                     }
[10:18:35.612]                     else if (inherits(cond, "condition")) {
[10:18:35.612]                       if (!is.null(pattern)) {
[10:18:35.612]                         computeRestarts <- base::computeRestarts
[10:18:35.612]                         grepl <- base::grepl
[10:18:35.612]                         restarts <- computeRestarts(cond)
[10:18:35.612]                         for (restart in restarts) {
[10:18:35.612]                           name <- restart$name
[10:18:35.612]                           if (is.null(name)) 
[10:18:35.612]                             next
[10:18:35.612]                           if (!grepl(pattern, name)) 
[10:18:35.612]                             next
[10:18:35.612]                           invokeRestart(restart)
[10:18:35.612]                           muffled <- TRUE
[10:18:35.612]                           break
[10:18:35.612]                         }
[10:18:35.612]                       }
[10:18:35.612]                     }
[10:18:35.612]                     invisible(muffled)
[10:18:35.612]                   }
[10:18:35.612]                   muffleCondition(cond)
[10:18:35.612]                 })
[10:18:35.612]             }))
[10:18:35.612]             future::FutureResult(value = ...future.value$value, 
[10:18:35.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.612]                   ...future.rng), globalenv = if (FALSE) 
[10:18:35.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:35.612]                     ...future.globalenv.names))
[10:18:35.612]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:35.612]         }, condition = base::local({
[10:18:35.612]             c <- base::c
[10:18:35.612]             inherits <- base::inherits
[10:18:35.612]             invokeRestart <- base::invokeRestart
[10:18:35.612]             length <- base::length
[10:18:35.612]             list <- base::list
[10:18:35.612]             seq.int <- base::seq.int
[10:18:35.612]             signalCondition <- base::signalCondition
[10:18:35.612]             sys.calls <- base::sys.calls
[10:18:35.612]             `[[` <- base::`[[`
[10:18:35.612]             `+` <- base::`+`
[10:18:35.612]             `<<-` <- base::`<<-`
[10:18:35.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:35.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:35.612]                   3L)]
[10:18:35.612]             }
[10:18:35.612]             function(cond) {
[10:18:35.612]                 is_error <- inherits(cond, "error")
[10:18:35.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:35.612]                   NULL)
[10:18:35.612]                 if (is_error) {
[10:18:35.612]                   sessionInformation <- function() {
[10:18:35.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:35.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:35.612]                       search = base::search(), system = base::Sys.info())
[10:18:35.612]                   }
[10:18:35.612]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:35.612]                     cond$call), session = sessionInformation(), 
[10:18:35.612]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:35.612]                   signalCondition(cond)
[10:18:35.612]                 }
[10:18:35.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:35.612]                 "immediateCondition"))) {
[10:18:35.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:35.612]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:35.612]                   if (TRUE && !signal) {
[10:18:35.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.612]                     {
[10:18:35.612]                       inherits <- base::inherits
[10:18:35.612]                       invokeRestart <- base::invokeRestart
[10:18:35.612]                       is.null <- base::is.null
[10:18:35.612]                       muffled <- FALSE
[10:18:35.612]                       if (inherits(cond, "message")) {
[10:18:35.612]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.612]                         if (muffled) 
[10:18:35.612]                           invokeRestart("muffleMessage")
[10:18:35.612]                       }
[10:18:35.612]                       else if (inherits(cond, "warning")) {
[10:18:35.612]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.612]                         if (muffled) 
[10:18:35.612]                           invokeRestart("muffleWarning")
[10:18:35.612]                       }
[10:18:35.612]                       else if (inherits(cond, "condition")) {
[10:18:35.612]                         if (!is.null(pattern)) {
[10:18:35.612]                           computeRestarts <- base::computeRestarts
[10:18:35.612]                           grepl <- base::grepl
[10:18:35.612]                           restarts <- computeRestarts(cond)
[10:18:35.612]                           for (restart in restarts) {
[10:18:35.612]                             name <- restart$name
[10:18:35.612]                             if (is.null(name)) 
[10:18:35.612]                               next
[10:18:35.612]                             if (!grepl(pattern, name)) 
[10:18:35.612]                               next
[10:18:35.612]                             invokeRestart(restart)
[10:18:35.612]                             muffled <- TRUE
[10:18:35.612]                             break
[10:18:35.612]                           }
[10:18:35.612]                         }
[10:18:35.612]                       }
[10:18:35.612]                       invisible(muffled)
[10:18:35.612]                     }
[10:18:35.612]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.612]                   }
[10:18:35.612]                 }
[10:18:35.612]                 else {
[10:18:35.612]                   if (TRUE) {
[10:18:35.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.612]                     {
[10:18:35.612]                       inherits <- base::inherits
[10:18:35.612]                       invokeRestart <- base::invokeRestart
[10:18:35.612]                       is.null <- base::is.null
[10:18:35.612]                       muffled <- FALSE
[10:18:35.612]                       if (inherits(cond, "message")) {
[10:18:35.612]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.612]                         if (muffled) 
[10:18:35.612]                           invokeRestart("muffleMessage")
[10:18:35.612]                       }
[10:18:35.612]                       else if (inherits(cond, "warning")) {
[10:18:35.612]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.612]                         if (muffled) 
[10:18:35.612]                           invokeRestart("muffleWarning")
[10:18:35.612]                       }
[10:18:35.612]                       else if (inherits(cond, "condition")) {
[10:18:35.612]                         if (!is.null(pattern)) {
[10:18:35.612]                           computeRestarts <- base::computeRestarts
[10:18:35.612]                           grepl <- base::grepl
[10:18:35.612]                           restarts <- computeRestarts(cond)
[10:18:35.612]                           for (restart in restarts) {
[10:18:35.612]                             name <- restart$name
[10:18:35.612]                             if (is.null(name)) 
[10:18:35.612]                               next
[10:18:35.612]                             if (!grepl(pattern, name)) 
[10:18:35.612]                               next
[10:18:35.612]                             invokeRestart(restart)
[10:18:35.612]                             muffled <- TRUE
[10:18:35.612]                             break
[10:18:35.612]                           }
[10:18:35.612]                         }
[10:18:35.612]                       }
[10:18:35.612]                       invisible(muffled)
[10:18:35.612]                     }
[10:18:35.612]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.612]                   }
[10:18:35.612]                 }
[10:18:35.612]             }
[10:18:35.612]         }))
[10:18:35.612]     }, error = function(ex) {
[10:18:35.612]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:35.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.612]                 ...future.rng), started = ...future.startTime, 
[10:18:35.612]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:35.612]             version = "1.8"), class = "FutureResult")
[10:18:35.612]     }, finally = {
[10:18:35.612]         if (!identical(...future.workdir, getwd())) 
[10:18:35.612]             setwd(...future.workdir)
[10:18:35.612]         {
[10:18:35.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:35.612]                 ...future.oldOptions$nwarnings <- NULL
[10:18:35.612]             }
[10:18:35.612]             base::options(...future.oldOptions)
[10:18:35.612]             if (.Platform$OS.type == "windows") {
[10:18:35.612]                 old_names <- names(...future.oldEnvVars)
[10:18:35.612]                 envs <- base::Sys.getenv()
[10:18:35.612]                 names <- names(envs)
[10:18:35.612]                 common <- intersect(names, old_names)
[10:18:35.612]                 added <- setdiff(names, old_names)
[10:18:35.612]                 removed <- setdiff(old_names, names)
[10:18:35.612]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:35.612]                   envs[common]]
[10:18:35.612]                 NAMES <- toupper(changed)
[10:18:35.612]                 args <- list()
[10:18:35.612]                 for (kk in seq_along(NAMES)) {
[10:18:35.612]                   name <- changed[[kk]]
[10:18:35.612]                   NAME <- NAMES[[kk]]
[10:18:35.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.612]                     next
[10:18:35.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.612]                 }
[10:18:35.612]                 NAMES <- toupper(added)
[10:18:35.612]                 for (kk in seq_along(NAMES)) {
[10:18:35.612]                   name <- added[[kk]]
[10:18:35.612]                   NAME <- NAMES[[kk]]
[10:18:35.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.612]                     next
[10:18:35.612]                   args[[name]] <- ""
[10:18:35.612]                 }
[10:18:35.612]                 NAMES <- toupper(removed)
[10:18:35.612]                 for (kk in seq_along(NAMES)) {
[10:18:35.612]                   name <- removed[[kk]]
[10:18:35.612]                   NAME <- NAMES[[kk]]
[10:18:35.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.612]                     next
[10:18:35.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.612]                 }
[10:18:35.612]                 if (length(args) > 0) 
[10:18:35.612]                   base::do.call(base::Sys.setenv, args = args)
[10:18:35.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:35.612]             }
[10:18:35.612]             else {
[10:18:35.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:35.612]             }
[10:18:35.612]             {
[10:18:35.612]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:35.612]                   0L) {
[10:18:35.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:35.612]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:35.612]                   base::options(opts)
[10:18:35.612]                 }
[10:18:35.612]                 {
[10:18:35.612]                   {
[10:18:35.612]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:35.612]                     NULL
[10:18:35.612]                   }
[10:18:35.612]                   options(future.plan = NULL)
[10:18:35.612]                   if (is.na(NA_character_)) 
[10:18:35.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:35.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:35.612]                     .init = FALSE)
[10:18:35.612]                 }
[10:18:35.612]             }
[10:18:35.612]         }
[10:18:35.612]     })
[10:18:35.612]     if (TRUE) {
[10:18:35.612]         base::sink(type = "output", split = FALSE)
[10:18:35.612]         if (TRUE) {
[10:18:35.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:35.612]         }
[10:18:35.612]         else {
[10:18:35.612]             ...future.result["stdout"] <- base::list(NULL)
[10:18:35.612]         }
[10:18:35.612]         base::close(...future.stdout)
[10:18:35.612]         ...future.stdout <- NULL
[10:18:35.612]     }
[10:18:35.612]     ...future.result$conditions <- ...future.conditions
[10:18:35.612]     ...future.result$finished <- base::Sys.time()
[10:18:35.612]     ...future.result
[10:18:35.612] }
[10:18:35.667] Exporting 5 global objects (1.07 KiB) to cluster node #2 ...
[10:18:35.667] Exporting ‘...future.FUN’ (273 bytes) to cluster node #2 ...
[10:18:35.667] Exporting ‘...future.FUN’ (273 bytes) to cluster node #2 ... DONE
[10:18:35.668] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:35.668] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:35.668] Exporting ‘...future.elements_ii’ (205 bytes) to cluster node #2 ...
[10:18:35.669] Exporting ‘...future.elements_ii’ (205 bytes) to cluster node #2 ... DONE
[10:18:35.669] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:35.669] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:35.669] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:35.669] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:35.670] Exporting 5 global objects (1.07 KiB) to cluster node #2 ... DONE
[10:18:35.670] MultisessionFuture started
[10:18:35.670] - Launch lazy future ... done
[10:18:35.670] run() for ‘MultisessionFuture’ ... done
[10:18:35.671] Created future:
[10:18:35.671] MultisessionFuture:
[10:18:35.671] Label: ‘future_eapply-2’
[10:18:35.671] Expression:
[10:18:35.671] {
[10:18:35.671]     do.call(function(...) {
[10:18:35.671]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.671]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.671]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.671]             on.exit(options(oopts), add = TRUE)
[10:18:35.671]         }
[10:18:35.671]         {
[10:18:35.671]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.671]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.671]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.671]             })
[10:18:35.671]         }
[10:18:35.671]     }, args = future.call.arguments)
[10:18:35.671] }
[10:18:35.671] Lazy evaluation: FALSE
[10:18:35.671] Asynchronous evaluation: TRUE
[10:18:35.671] Local evaluation: TRUE
[10:18:35.671] Environment: R_GlobalEnv
[10:18:35.671] Capture standard output: TRUE
[10:18:35.671] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:35.671] Globals: 5 objects totaling 629 bytes (function ‘...future.FUN’ of 273 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 205 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:35.671] Packages: <none>
[10:18:35.671] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:35.671] Resolved: FALSE
[10:18:35.671] Value: <not collected>
[10:18:35.671] Conditions captured: <none>
[10:18:35.671] Early signaling: FALSE
[10:18:35.671] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:35.671] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.683] Chunk #2 of 2 ... DONE
[10:18:35.683] Launching 2 futures (chunks) ... DONE
[10:18:35.683] Resolving 2 futures (chunks) ...
[10:18:35.683] resolve() on list ...
[10:18:35.683]  recursive: 0
[10:18:35.683]  length: 2
[10:18:35.683] 
[10:18:35.684] receiveMessageFromWorker() for ClusterFuture ...
[10:18:35.684] - Validating connection of MultisessionFuture
[10:18:35.684] - received message: FutureResult
[10:18:35.684] - Received FutureResult
[10:18:35.685] - Erased future from FutureRegistry
[10:18:35.685] result() for ClusterFuture ...
[10:18:35.685] - result already collected: FutureResult
[10:18:35.685] result() for ClusterFuture ... done
[10:18:35.685] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:35.685] Future #1
[10:18:35.685] result() for ClusterFuture ...
[10:18:35.685] - result already collected: FutureResult
[10:18:35.685] result() for ClusterFuture ... done
[10:18:35.686] result() for ClusterFuture ...
[10:18:35.686] - result already collected: FutureResult
[10:18:35.686] result() for ClusterFuture ... done
[10:18:35.686] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:35.686] - nx: 2
[10:18:35.686] - relay: TRUE
[10:18:35.686] - stdout: TRUE
[10:18:35.686] - signal: TRUE
[10:18:35.686] - resignal: FALSE
[10:18:35.687] - force: TRUE
[10:18:35.687] - relayed: [n=2] FALSE, FALSE
[10:18:35.687] - queued futures: [n=2] FALSE, FALSE
[10:18:35.687]  - until=1
[10:18:35.687]  - relaying element #1
[10:18:35.687] result() for ClusterFuture ...
[10:18:35.687] - result already collected: FutureResult
[10:18:35.687] result() for ClusterFuture ... done
[10:18:35.687] result() for ClusterFuture ...
[10:18:35.687] - result already collected: FutureResult
[10:18:35.688] result() for ClusterFuture ... done
[10:18:35.688] result() for ClusterFuture ...
[10:18:35.688] - result already collected: FutureResult
[10:18:35.688] result() for ClusterFuture ... done
[10:18:35.688] result() for ClusterFuture ...
[10:18:35.688] - result already collected: FutureResult
[10:18:35.688] result() for ClusterFuture ... done
[10:18:35.688] - relayed: [n=2] TRUE, FALSE
[10:18:35.688] - queued futures: [n=2] TRUE, FALSE
[10:18:35.689] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:35.689]  length: 1 (resolved future 1)
[10:18:35.751] receiveMessageFromWorker() for ClusterFuture ...
[10:18:35.752] - Validating connection of MultisessionFuture
[10:18:35.752] - received message: FutureResult
[10:18:35.752] - Received FutureResult
[10:18:35.752] - Erased future from FutureRegistry
[10:18:35.752] result() for ClusterFuture ...
[10:18:35.753] - result already collected: FutureResult
[10:18:35.753] result() for ClusterFuture ... done
[10:18:35.753] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:35.753] Future #2
[10:18:35.753] result() for ClusterFuture ...
[10:18:35.753] - result already collected: FutureResult
[10:18:35.753] result() for ClusterFuture ... done
[10:18:35.753] result() for ClusterFuture ...
[10:18:35.753] - result already collected: FutureResult
[10:18:35.753] result() for ClusterFuture ... done
[10:18:35.754] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:35.754] - nx: 2
[10:18:35.754] - relay: TRUE
[10:18:35.754] - stdout: TRUE
[10:18:35.754] - signal: TRUE
[10:18:35.754] - resignal: FALSE
[10:18:35.754] - force: TRUE
[10:18:35.754] - relayed: [n=2] TRUE, FALSE
[10:18:35.754] - queued futures: [n=2] TRUE, FALSE
[10:18:35.755]  - until=2
[10:18:35.755]  - relaying element #2
[10:18:35.755] result() for ClusterFuture ...
[10:18:35.755] - result already collected: FutureResult
[10:18:35.755] result() for ClusterFuture ... done
[10:18:35.755] result() for ClusterFuture ...
[10:18:35.755] - result already collected: FutureResult
[10:18:35.755] result() for ClusterFuture ... done
[10:18:35.755] result() for ClusterFuture ...
[10:18:35.756] - result already collected: FutureResult
[10:18:35.756] result() for ClusterFuture ... done
[10:18:35.756] result() for ClusterFuture ...
[10:18:35.756] - result already collected: FutureResult
[10:18:35.756] result() for ClusterFuture ... done
[10:18:35.756] - relayed: [n=2] TRUE, TRUE
[10:18:35.756] - queued futures: [n=2] TRUE, TRUE
[10:18:35.756] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:35.756]  length: 0 (resolved future 2)
[10:18:35.757] Relaying remaining futures
[10:18:35.757] signalConditionsASAP(NULL, pos=0) ...
[10:18:35.757] - nx: 2
[10:18:35.757] - relay: TRUE
[10:18:35.757] - stdout: TRUE
[10:18:35.757] - signal: TRUE
[10:18:35.757] - resignal: FALSE
[10:18:35.757] - force: TRUE
[10:18:35.757] - relayed: [n=2] TRUE, TRUE
[10:18:35.757] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:35.758] - relayed: [n=2] TRUE, TRUE
[10:18:35.758] - queued futures: [n=2] TRUE, TRUE
[10:18:35.758] signalConditionsASAP(NULL, pos=0) ... done
[10:18:35.758] resolve() on list ... DONE
[10:18:35.758] result() for ClusterFuture ...
[10:18:35.758] - result already collected: FutureResult
[10:18:35.758] result() for ClusterFuture ... done
[10:18:35.758] result() for ClusterFuture ...
[10:18:35.759] - result already collected: FutureResult
[10:18:35.759] result() for ClusterFuture ... done
[10:18:35.759] result() for ClusterFuture ...
[10:18:35.759] - result already collected: FutureResult
[10:18:35.759] result() for ClusterFuture ... done
[10:18:35.759] result() for ClusterFuture ...
[10:18:35.759] - result already collected: FutureResult
[10:18:35.759] result() for ClusterFuture ... done
[10:18:35.759]  - Number of value chunks collected: 2
[10:18:35.760] Resolving 2 futures (chunks) ... DONE
[10:18:35.760] Reducing values from 2 chunks ...
[10:18:35.760]  - Number of values collected after concatenation: 3
[10:18:35.760]  - Number of values expected: 3
[10:18:35.760] Reducing values from 2 chunks ... DONE
[10:18:35.760] future_lapply() ... DONE
[10:18:35.761] future_lapply() ...
[10:18:35.763] Number of chunks: 2
[10:18:35.763] getGlobalsAndPackagesXApply() ...
[10:18:35.764]  - future.globals: TRUE
[10:18:35.764] getGlobalsAndPackages() ...
[10:18:35.764] Searching for globals...
[10:18:35.765] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:35.765] Searching for globals ... DONE
[10:18:35.766] Resolving globals: FALSE
[10:18:35.766] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:35.766] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:35.767] - globals: [1] ‘FUN’
[10:18:35.767] - packages: [1] ‘stats’
[10:18:35.767] getGlobalsAndPackages() ... DONE
[10:18:35.767]  - globals found/used: [n=1] ‘FUN’
[10:18:35.767]  - needed namespaces: [n=1] ‘stats’
[10:18:35.767] Finding globals ... DONE
[10:18:35.767]  - use_args: TRUE
[10:18:35.767]  - Getting '...' globals ...
[10:18:35.768] resolve() on list ...
[10:18:35.768]  recursive: 0
[10:18:35.768]  length: 1
[10:18:35.768]  elements: ‘...’
[10:18:35.768]  length: 0 (resolved future 1)
[10:18:35.768] resolve() on list ... DONE
[10:18:35.768]    - '...' content: [n=1] ‘probs’
[10:18:35.769] List of 1
[10:18:35.769]  $ ...:List of 1
[10:18:35.769]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:35.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:35.769]  - attr(*, "where")=List of 1
[10:18:35.769]   ..$ ...:<environment: 0x56033ed363c8> 
[10:18:35.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:35.769]  - attr(*, "resolved")= logi TRUE
[10:18:35.769]  - attr(*, "total_size")= num NA
[10:18:35.772]  - Getting '...' globals ... DONE
[10:18:35.772] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:35.773] List of 2
[10:18:35.773]  $ ...future.FUN:function (x, ...)  
[10:18:35.773]  $ ...          :List of 1
[10:18:35.773]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:18:35.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:35.773]  - attr(*, "where")=List of 2
[10:18:35.773]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:35.773]   ..$ ...          :<environment: 0x56033ed363c8> 
[10:18:35.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:35.773]  - attr(*, "resolved")= logi FALSE
[10:18:35.773]  - attr(*, "total_size")= num 6525
[10:18:35.776] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:35.777] getGlobalsAndPackagesXApply() ... DONE
[10:18:35.777] Number of futures (= number of chunks): 2
[10:18:35.777] Launching 2 futures (chunks) ...
[10:18:35.777] Chunk #1 of 2 ...
[10:18:35.777]  - Finding globals in 'X' for chunk #1 ...
[10:18:35.777] getGlobalsAndPackages() ...
[10:18:35.777] Searching for globals...
[10:18:35.778] 
[10:18:35.778] Searching for globals ... DONE
[10:18:35.778] - globals: [0] <none>
[10:18:35.778] getGlobalsAndPackages() ... DONE
[10:18:35.778]    + additional globals found: [n=0] 
[10:18:35.778]    + additional namespaces needed: [n=0] 
[10:18:35.778]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:35.779]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:35.779]  - seeds: <none>
[10:18:35.779]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.779] getGlobalsAndPackages() ...
[10:18:35.781] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.782] Resolving globals: FALSE
[10:18:35.782] Tweak future expression to call with '...' arguments ...
[10:18:35.782] {
[10:18:35.782]     do.call(function(...) {
[10:18:35.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.782]             on.exit(options(oopts), add = TRUE)
[10:18:35.782]         }
[10:18:35.782]         {
[10:18:35.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.782]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.782]             })
[10:18:35.782]         }
[10:18:35.782]     }, args = future.call.arguments)
[10:18:35.782] }
[10:18:35.782] Tweak future expression to call with '...' arguments ... DONE
[10:18:35.782] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.783] - packages: [1] ‘stats’
[10:18:35.783] getGlobalsAndPackages() ... DONE
[10:18:35.783] run() for ‘Future’ ...
[10:18:35.783] - state: ‘created’
[10:18:35.783] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:35.797] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.797] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:35.798]   - Field: ‘node’
[10:18:35.798]   - Field: ‘label’
[10:18:35.798]   - Field: ‘local’
[10:18:35.798]   - Field: ‘owner’
[10:18:35.798]   - Field: ‘envir’
[10:18:35.798]   - Field: ‘workers’
[10:18:35.798]   - Field: ‘packages’
[10:18:35.798]   - Field: ‘gc’
[10:18:35.798]   - Field: ‘conditions’
[10:18:35.798]   - Field: ‘persistent’
[10:18:35.798]   - Field: ‘expr’
[10:18:35.798]   - Field: ‘uuid’
[10:18:35.799]   - Field: ‘seed’
[10:18:35.799]   - Field: ‘version’
[10:18:35.799]   - Field: ‘result’
[10:18:35.799]   - Field: ‘asynchronous’
[10:18:35.799]   - Field: ‘calls’
[10:18:35.799]   - Field: ‘globals’
[10:18:35.799]   - Field: ‘stdout’
[10:18:35.799]   - Field: ‘earlySignal’
[10:18:35.799]   - Field: ‘lazy’
[10:18:35.799]   - Field: ‘state’
[10:18:35.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:35.799] - Launch lazy future ...
[10:18:35.800] Packages needed by the future expression (n = 1): ‘stats’
[10:18:35.800] Packages needed by future strategies (n = 0): <none>
[10:18:35.800] {
[10:18:35.800]     {
[10:18:35.800]         {
[10:18:35.800]             ...future.startTime <- base::Sys.time()
[10:18:35.800]             {
[10:18:35.800]                 {
[10:18:35.800]                   {
[10:18:35.800]                     {
[10:18:35.800]                       {
[10:18:35.800]                         base::local({
[10:18:35.800]                           has_future <- base::requireNamespace("future", 
[10:18:35.800]                             quietly = TRUE)
[10:18:35.800]                           if (has_future) {
[10:18:35.800]                             ns <- base::getNamespace("future")
[10:18:35.800]                             version <- ns[[".package"]][["version"]]
[10:18:35.800]                             if (is.null(version)) 
[10:18:35.800]                               version <- utils::packageVersion("future")
[10:18:35.800]                           }
[10:18:35.800]                           else {
[10:18:35.800]                             version <- NULL
[10:18:35.800]                           }
[10:18:35.800]                           if (!has_future || version < "1.8.0") {
[10:18:35.800]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:35.800]                               "", base::R.version$version.string), 
[10:18:35.800]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:35.800]                                 base::R.version$platform, 8 * 
[10:18:35.800]                                   base::.Machine$sizeof.pointer), 
[10:18:35.800]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:35.800]                                 "release", "version")], collapse = " "), 
[10:18:35.800]                               hostname = base::Sys.info()[["nodename"]])
[10:18:35.800]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:35.800]                               info)
[10:18:35.800]                             info <- base::paste(info, collapse = "; ")
[10:18:35.800]                             if (!has_future) {
[10:18:35.800]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:35.800]                                 info)
[10:18:35.800]                             }
[10:18:35.800]                             else {
[10:18:35.800]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:35.800]                                 info, version)
[10:18:35.800]                             }
[10:18:35.800]                             base::stop(msg)
[10:18:35.800]                           }
[10:18:35.800]                         })
[10:18:35.800]                       }
[10:18:35.800]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:35.800]                       base::options(mc.cores = 1L)
[10:18:35.800]                     }
[10:18:35.800]                     base::local({
[10:18:35.800]                       for (pkg in "stats") {
[10:18:35.800]                         base::loadNamespace(pkg)
[10:18:35.800]                         base::library(pkg, character.only = TRUE)
[10:18:35.800]                       }
[10:18:35.800]                     })
[10:18:35.800]                   }
[10:18:35.800]                   ...future.strategy.old <- future::plan("list")
[10:18:35.800]                   options(future.plan = NULL)
[10:18:35.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:35.800]                 }
[10:18:35.800]                 ...future.workdir <- getwd()
[10:18:35.800]             }
[10:18:35.800]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:35.800]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:35.800]         }
[10:18:35.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:35.800]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:35.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:35.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:35.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:35.800]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:35.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:35.800]             base::names(...future.oldOptions))
[10:18:35.800]     }
[10:18:35.800]     if (FALSE) {
[10:18:35.800]     }
[10:18:35.800]     else {
[10:18:35.800]         if (TRUE) {
[10:18:35.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:35.800]                 open = "w")
[10:18:35.800]         }
[10:18:35.800]         else {
[10:18:35.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:35.800]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:35.800]         }
[10:18:35.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:35.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:35.800]             base::sink(type = "output", split = FALSE)
[10:18:35.800]             base::close(...future.stdout)
[10:18:35.800]         }, add = TRUE)
[10:18:35.800]     }
[10:18:35.800]     ...future.frame <- base::sys.nframe()
[10:18:35.800]     ...future.conditions <- base::list()
[10:18:35.800]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:35.800]     if (FALSE) {
[10:18:35.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:35.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:35.800]     }
[10:18:35.800]     ...future.result <- base::tryCatch({
[10:18:35.800]         base::withCallingHandlers({
[10:18:35.800]             ...future.value <- base::withVisible(base::local({
[10:18:35.800]                 ...future.makeSendCondition <- base::local({
[10:18:35.800]                   sendCondition <- NULL
[10:18:35.800]                   function(frame = 1L) {
[10:18:35.800]                     if (is.function(sendCondition)) 
[10:18:35.800]                       return(sendCondition)
[10:18:35.800]                     ns <- getNamespace("parallel")
[10:18:35.800]                     if (exists("sendData", mode = "function", 
[10:18:35.800]                       envir = ns)) {
[10:18:35.800]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:35.800]                         envir = ns)
[10:18:35.800]                       envir <- sys.frame(frame)
[10:18:35.800]                       master <- NULL
[10:18:35.800]                       while (!identical(envir, .GlobalEnv) && 
[10:18:35.800]                         !identical(envir, emptyenv())) {
[10:18:35.800]                         if (exists("master", mode = "list", envir = envir, 
[10:18:35.800]                           inherits = FALSE)) {
[10:18:35.800]                           master <- get("master", mode = "list", 
[10:18:35.800]                             envir = envir, inherits = FALSE)
[10:18:35.800]                           if (inherits(master, c("SOCKnode", 
[10:18:35.800]                             "SOCK0node"))) {
[10:18:35.800]                             sendCondition <<- function(cond) {
[10:18:35.800]                               data <- list(type = "VALUE", value = cond, 
[10:18:35.800]                                 success = TRUE)
[10:18:35.800]                               parallel_sendData(master, data)
[10:18:35.800]                             }
[10:18:35.800]                             return(sendCondition)
[10:18:35.800]                           }
[10:18:35.800]                         }
[10:18:35.800]                         frame <- frame + 1L
[10:18:35.800]                         envir <- sys.frame(frame)
[10:18:35.800]                       }
[10:18:35.800]                     }
[10:18:35.800]                     sendCondition <<- function(cond) NULL
[10:18:35.800]                   }
[10:18:35.800]                 })
[10:18:35.800]                 withCallingHandlers({
[10:18:35.800]                   {
[10:18:35.800]                     do.call(function(...) {
[10:18:35.800]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.800]                       if (!identical(...future.globals.maxSize.org, 
[10:18:35.800]                         ...future.globals.maxSize)) {
[10:18:35.800]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.800]                         on.exit(options(oopts), add = TRUE)
[10:18:35.800]                       }
[10:18:35.800]                       {
[10:18:35.800]                         lapply(seq_along(...future.elements_ii), 
[10:18:35.800]                           FUN = function(jj) {
[10:18:35.800]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.800]                             ...future.FUN(...future.X_jj, ...)
[10:18:35.800]                           })
[10:18:35.800]                       }
[10:18:35.800]                     }, args = future.call.arguments)
[10:18:35.800]                   }
[10:18:35.800]                 }, immediateCondition = function(cond) {
[10:18:35.800]                   sendCondition <- ...future.makeSendCondition()
[10:18:35.800]                   sendCondition(cond)
[10:18:35.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.800]                   {
[10:18:35.800]                     inherits <- base::inherits
[10:18:35.800]                     invokeRestart <- base::invokeRestart
[10:18:35.800]                     is.null <- base::is.null
[10:18:35.800]                     muffled <- FALSE
[10:18:35.800]                     if (inherits(cond, "message")) {
[10:18:35.800]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:35.800]                       if (muffled) 
[10:18:35.800]                         invokeRestart("muffleMessage")
[10:18:35.800]                     }
[10:18:35.800]                     else if (inherits(cond, "warning")) {
[10:18:35.800]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:35.800]                       if (muffled) 
[10:18:35.800]                         invokeRestart("muffleWarning")
[10:18:35.800]                     }
[10:18:35.800]                     else if (inherits(cond, "condition")) {
[10:18:35.800]                       if (!is.null(pattern)) {
[10:18:35.800]                         computeRestarts <- base::computeRestarts
[10:18:35.800]                         grepl <- base::grepl
[10:18:35.800]                         restarts <- computeRestarts(cond)
[10:18:35.800]                         for (restart in restarts) {
[10:18:35.800]                           name <- restart$name
[10:18:35.800]                           if (is.null(name)) 
[10:18:35.800]                             next
[10:18:35.800]                           if (!grepl(pattern, name)) 
[10:18:35.800]                             next
[10:18:35.800]                           invokeRestart(restart)
[10:18:35.800]                           muffled <- TRUE
[10:18:35.800]                           break
[10:18:35.800]                         }
[10:18:35.800]                       }
[10:18:35.800]                     }
[10:18:35.800]                     invisible(muffled)
[10:18:35.800]                   }
[10:18:35.800]                   muffleCondition(cond)
[10:18:35.800]                 })
[10:18:35.800]             }))
[10:18:35.800]             future::FutureResult(value = ...future.value$value, 
[10:18:35.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.800]                   ...future.rng), globalenv = if (FALSE) 
[10:18:35.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:35.800]                     ...future.globalenv.names))
[10:18:35.800]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:35.800]         }, condition = base::local({
[10:18:35.800]             c <- base::c
[10:18:35.800]             inherits <- base::inherits
[10:18:35.800]             invokeRestart <- base::invokeRestart
[10:18:35.800]             length <- base::length
[10:18:35.800]             list <- base::list
[10:18:35.800]             seq.int <- base::seq.int
[10:18:35.800]             signalCondition <- base::signalCondition
[10:18:35.800]             sys.calls <- base::sys.calls
[10:18:35.800]             `[[` <- base::`[[`
[10:18:35.800]             `+` <- base::`+`
[10:18:35.800]             `<<-` <- base::`<<-`
[10:18:35.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:35.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:35.800]                   3L)]
[10:18:35.800]             }
[10:18:35.800]             function(cond) {
[10:18:35.800]                 is_error <- inherits(cond, "error")
[10:18:35.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:35.800]                   NULL)
[10:18:35.800]                 if (is_error) {
[10:18:35.800]                   sessionInformation <- function() {
[10:18:35.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:35.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:35.800]                       search = base::search(), system = base::Sys.info())
[10:18:35.800]                   }
[10:18:35.800]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:35.800]                     cond$call), session = sessionInformation(), 
[10:18:35.800]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:35.800]                   signalCondition(cond)
[10:18:35.800]                 }
[10:18:35.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:35.800]                 "immediateCondition"))) {
[10:18:35.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:35.800]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:35.800]                   if (TRUE && !signal) {
[10:18:35.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.800]                     {
[10:18:35.800]                       inherits <- base::inherits
[10:18:35.800]                       invokeRestart <- base::invokeRestart
[10:18:35.800]                       is.null <- base::is.null
[10:18:35.800]                       muffled <- FALSE
[10:18:35.800]                       if (inherits(cond, "message")) {
[10:18:35.800]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.800]                         if (muffled) 
[10:18:35.800]                           invokeRestart("muffleMessage")
[10:18:35.800]                       }
[10:18:35.800]                       else if (inherits(cond, "warning")) {
[10:18:35.800]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.800]                         if (muffled) 
[10:18:35.800]                           invokeRestart("muffleWarning")
[10:18:35.800]                       }
[10:18:35.800]                       else if (inherits(cond, "condition")) {
[10:18:35.800]                         if (!is.null(pattern)) {
[10:18:35.800]                           computeRestarts <- base::computeRestarts
[10:18:35.800]                           grepl <- base::grepl
[10:18:35.800]                           restarts <- computeRestarts(cond)
[10:18:35.800]                           for (restart in restarts) {
[10:18:35.800]                             name <- restart$name
[10:18:35.800]                             if (is.null(name)) 
[10:18:35.800]                               next
[10:18:35.800]                             if (!grepl(pattern, name)) 
[10:18:35.800]                               next
[10:18:35.800]                             invokeRestart(restart)
[10:18:35.800]                             muffled <- TRUE
[10:18:35.800]                             break
[10:18:35.800]                           }
[10:18:35.800]                         }
[10:18:35.800]                       }
[10:18:35.800]                       invisible(muffled)
[10:18:35.800]                     }
[10:18:35.800]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.800]                   }
[10:18:35.800]                 }
[10:18:35.800]                 else {
[10:18:35.800]                   if (TRUE) {
[10:18:35.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.800]                     {
[10:18:35.800]                       inherits <- base::inherits
[10:18:35.800]                       invokeRestart <- base::invokeRestart
[10:18:35.800]                       is.null <- base::is.null
[10:18:35.800]                       muffled <- FALSE
[10:18:35.800]                       if (inherits(cond, "message")) {
[10:18:35.800]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.800]                         if (muffled) 
[10:18:35.800]                           invokeRestart("muffleMessage")
[10:18:35.800]                       }
[10:18:35.800]                       else if (inherits(cond, "warning")) {
[10:18:35.800]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.800]                         if (muffled) 
[10:18:35.800]                           invokeRestart("muffleWarning")
[10:18:35.800]                       }
[10:18:35.800]                       else if (inherits(cond, "condition")) {
[10:18:35.800]                         if (!is.null(pattern)) {
[10:18:35.800]                           computeRestarts <- base::computeRestarts
[10:18:35.800]                           grepl <- base::grepl
[10:18:35.800]                           restarts <- computeRestarts(cond)
[10:18:35.800]                           for (restart in restarts) {
[10:18:35.800]                             name <- restart$name
[10:18:35.800]                             if (is.null(name)) 
[10:18:35.800]                               next
[10:18:35.800]                             if (!grepl(pattern, name)) 
[10:18:35.800]                               next
[10:18:35.800]                             invokeRestart(restart)
[10:18:35.800]                             muffled <- TRUE
[10:18:35.800]                             break
[10:18:35.800]                           }
[10:18:35.800]                         }
[10:18:35.800]                       }
[10:18:35.800]                       invisible(muffled)
[10:18:35.800]                     }
[10:18:35.800]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.800]                   }
[10:18:35.800]                 }
[10:18:35.800]             }
[10:18:35.800]         }))
[10:18:35.800]     }, error = function(ex) {
[10:18:35.800]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:35.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.800]                 ...future.rng), started = ...future.startTime, 
[10:18:35.800]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:35.800]             version = "1.8"), class = "FutureResult")
[10:18:35.800]     }, finally = {
[10:18:35.800]         if (!identical(...future.workdir, getwd())) 
[10:18:35.800]             setwd(...future.workdir)
[10:18:35.800]         {
[10:18:35.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:35.800]                 ...future.oldOptions$nwarnings <- NULL
[10:18:35.800]             }
[10:18:35.800]             base::options(...future.oldOptions)
[10:18:35.800]             if (.Platform$OS.type == "windows") {
[10:18:35.800]                 old_names <- names(...future.oldEnvVars)
[10:18:35.800]                 envs <- base::Sys.getenv()
[10:18:35.800]                 names <- names(envs)
[10:18:35.800]                 common <- intersect(names, old_names)
[10:18:35.800]                 added <- setdiff(names, old_names)
[10:18:35.800]                 removed <- setdiff(old_names, names)
[10:18:35.800]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:35.800]                   envs[common]]
[10:18:35.800]                 NAMES <- toupper(changed)
[10:18:35.800]                 args <- list()
[10:18:35.800]                 for (kk in seq_along(NAMES)) {
[10:18:35.800]                   name <- changed[[kk]]
[10:18:35.800]                   NAME <- NAMES[[kk]]
[10:18:35.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.800]                     next
[10:18:35.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.800]                 }
[10:18:35.800]                 NAMES <- toupper(added)
[10:18:35.800]                 for (kk in seq_along(NAMES)) {
[10:18:35.800]                   name <- added[[kk]]
[10:18:35.800]                   NAME <- NAMES[[kk]]
[10:18:35.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.800]                     next
[10:18:35.800]                   args[[name]] <- ""
[10:18:35.800]                 }
[10:18:35.800]                 NAMES <- toupper(removed)
[10:18:35.800]                 for (kk in seq_along(NAMES)) {
[10:18:35.800]                   name <- removed[[kk]]
[10:18:35.800]                   NAME <- NAMES[[kk]]
[10:18:35.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.800]                     next
[10:18:35.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.800]                 }
[10:18:35.800]                 if (length(args) > 0) 
[10:18:35.800]                   base::do.call(base::Sys.setenv, args = args)
[10:18:35.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:35.800]             }
[10:18:35.800]             else {
[10:18:35.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:35.800]             }
[10:18:35.800]             {
[10:18:35.800]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:35.800]                   0L) {
[10:18:35.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:35.800]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:35.800]                   base::options(opts)
[10:18:35.800]                 }
[10:18:35.800]                 {
[10:18:35.800]                   {
[10:18:35.800]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:35.800]                     NULL
[10:18:35.800]                   }
[10:18:35.800]                   options(future.plan = NULL)
[10:18:35.800]                   if (is.na(NA_character_)) 
[10:18:35.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:35.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:35.800]                     .init = FALSE)
[10:18:35.800]                 }
[10:18:35.800]             }
[10:18:35.800]         }
[10:18:35.800]     })
[10:18:35.800]     if (TRUE) {
[10:18:35.800]         base::sink(type = "output", split = FALSE)
[10:18:35.800]         if (TRUE) {
[10:18:35.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:35.800]         }
[10:18:35.800]         else {
[10:18:35.800]             ...future.result["stdout"] <- base::list(NULL)
[10:18:35.800]         }
[10:18:35.800]         base::close(...future.stdout)
[10:18:35.800]         ...future.stdout <- NULL
[10:18:35.800]     }
[10:18:35.800]     ...future.result$conditions <- ...future.conditions
[10:18:35.800]     ...future.result$finished <- base::Sys.time()
[10:18:35.800]     ...future.result
[10:18:35.800] }
[10:18:35.803] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[10:18:35.804] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:18:35.804] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:18:35.804] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #1 ...
[10:18:35.805] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #1 ... DONE
[10:18:35.805] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ...
[10:18:35.805] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ... DONE
[10:18:35.805] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:35.805] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:35.805] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:35.806] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:35.806] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[10:18:35.806] MultisessionFuture started
[10:18:35.806] - Launch lazy future ... done
[10:18:35.806] run() for ‘MultisessionFuture’ ... done
[10:18:35.807] Created future:
[10:18:35.807] MultisessionFuture:
[10:18:35.807] Label: ‘future_eapply-1’
[10:18:35.807] Expression:
[10:18:35.807] {
[10:18:35.807]     do.call(function(...) {
[10:18:35.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.807]             on.exit(options(oopts), add = TRUE)
[10:18:35.807]         }
[10:18:35.807]         {
[10:18:35.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.807]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.807]             })
[10:18:35.807]         }
[10:18:35.807]     }, args = future.call.arguments)
[10:18:35.807] }
[10:18:35.807] Lazy evaluation: FALSE
[10:18:35.807] Asynchronous evaluation: TRUE
[10:18:35.807] Local evaluation: TRUE
[10:18:35.807] Environment: R_GlobalEnv
[10:18:35.807] Capture standard output: TRUE
[10:18:35.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:35.807] Globals: 5 objects totaling 637 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:35.807] Packages: 1 packages (‘stats’)
[10:18:35.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:35.807] Resolved: FALSE
[10:18:35.807] Value: <not collected>
[10:18:35.807] Conditions captured: <none>
[10:18:35.807] Early signaling: FALSE
[10:18:35.807] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:35.807] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.818] Chunk #1 of 2 ... DONE
[10:18:35.818] Chunk #2 of 2 ...
[10:18:35.818]  - Finding globals in 'X' for chunk #2 ...
[10:18:35.819] getGlobalsAndPackages() ...
[10:18:35.819] Searching for globals...
[10:18:35.819] 
[10:18:35.819] Searching for globals ... DONE
[10:18:35.819] - globals: [0] <none>
[10:18:35.819] getGlobalsAndPackages() ... DONE
[10:18:35.819]    + additional globals found: [n=0] 
[10:18:35.819]    + additional namespaces needed: [n=0] 
[10:18:35.819]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:35.820]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:35.820]  - seeds: <none>
[10:18:35.820]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.820] getGlobalsAndPackages() ...
[10:18:35.820] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.820] Resolving globals: FALSE
[10:18:35.820] Tweak future expression to call with '...' arguments ...
[10:18:35.820] {
[10:18:35.820]     do.call(function(...) {
[10:18:35.820]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.820]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.820]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.820]             on.exit(options(oopts), add = TRUE)
[10:18:35.820]         }
[10:18:35.820]         {
[10:18:35.820]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.820]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.820]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.820]             })
[10:18:35.820]         }
[10:18:35.820]     }, args = future.call.arguments)
[10:18:35.820] }
[10:18:35.820] Tweak future expression to call with '...' arguments ... DONE
[10:18:35.821] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.821] - packages: [1] ‘stats’
[10:18:35.821] getGlobalsAndPackages() ... DONE
[10:18:35.821] run() for ‘Future’ ...
[10:18:35.821] - state: ‘created’
[10:18:35.822] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:35.837] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:35.837]   - Field: ‘node’
[10:18:35.837]   - Field: ‘label’
[10:18:35.837]   - Field: ‘local’
[10:18:35.837]   - Field: ‘owner’
[10:18:35.837]   - Field: ‘envir’
[10:18:35.838]   - Field: ‘workers’
[10:18:35.838]   - Field: ‘packages’
[10:18:35.838]   - Field: ‘gc’
[10:18:35.838]   - Field: ‘conditions’
[10:18:35.838]   - Field: ‘persistent’
[10:18:35.838]   - Field: ‘expr’
[10:18:35.838]   - Field: ‘uuid’
[10:18:35.838]   - Field: ‘seed’
[10:18:35.838]   - Field: ‘version’
[10:18:35.838]   - Field: ‘result’
[10:18:35.838]   - Field: ‘asynchronous’
[10:18:35.838]   - Field: ‘calls’
[10:18:35.839]   - Field: ‘globals’
[10:18:35.839]   - Field: ‘stdout’
[10:18:35.839]   - Field: ‘earlySignal’
[10:18:35.839]   - Field: ‘lazy’
[10:18:35.839]   - Field: ‘state’
[10:18:35.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:35.839] - Launch lazy future ...
[10:18:35.839] Packages needed by the future expression (n = 1): ‘stats’
[10:18:35.840] Packages needed by future strategies (n = 0): <none>
[10:18:35.840] {
[10:18:35.840]     {
[10:18:35.840]         {
[10:18:35.840]             ...future.startTime <- base::Sys.time()
[10:18:35.840]             {
[10:18:35.840]                 {
[10:18:35.840]                   {
[10:18:35.840]                     {
[10:18:35.840]                       {
[10:18:35.840]                         base::local({
[10:18:35.840]                           has_future <- base::requireNamespace("future", 
[10:18:35.840]                             quietly = TRUE)
[10:18:35.840]                           if (has_future) {
[10:18:35.840]                             ns <- base::getNamespace("future")
[10:18:35.840]                             version <- ns[[".package"]][["version"]]
[10:18:35.840]                             if (is.null(version)) 
[10:18:35.840]                               version <- utils::packageVersion("future")
[10:18:35.840]                           }
[10:18:35.840]                           else {
[10:18:35.840]                             version <- NULL
[10:18:35.840]                           }
[10:18:35.840]                           if (!has_future || version < "1.8.0") {
[10:18:35.840]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:35.840]                               "", base::R.version$version.string), 
[10:18:35.840]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:35.840]                                 base::R.version$platform, 8 * 
[10:18:35.840]                                   base::.Machine$sizeof.pointer), 
[10:18:35.840]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:35.840]                                 "release", "version")], collapse = " "), 
[10:18:35.840]                               hostname = base::Sys.info()[["nodename"]])
[10:18:35.840]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:35.840]                               info)
[10:18:35.840]                             info <- base::paste(info, collapse = "; ")
[10:18:35.840]                             if (!has_future) {
[10:18:35.840]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:35.840]                                 info)
[10:18:35.840]                             }
[10:18:35.840]                             else {
[10:18:35.840]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:35.840]                                 info, version)
[10:18:35.840]                             }
[10:18:35.840]                             base::stop(msg)
[10:18:35.840]                           }
[10:18:35.840]                         })
[10:18:35.840]                       }
[10:18:35.840]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:35.840]                       base::options(mc.cores = 1L)
[10:18:35.840]                     }
[10:18:35.840]                     base::local({
[10:18:35.840]                       for (pkg in "stats") {
[10:18:35.840]                         base::loadNamespace(pkg)
[10:18:35.840]                         base::library(pkg, character.only = TRUE)
[10:18:35.840]                       }
[10:18:35.840]                     })
[10:18:35.840]                   }
[10:18:35.840]                   ...future.strategy.old <- future::plan("list")
[10:18:35.840]                   options(future.plan = NULL)
[10:18:35.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:35.840]                 }
[10:18:35.840]                 ...future.workdir <- getwd()
[10:18:35.840]             }
[10:18:35.840]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:35.840]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:35.840]         }
[10:18:35.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:35.840]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:35.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:35.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:35.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:35.840]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:35.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:35.840]             base::names(...future.oldOptions))
[10:18:35.840]     }
[10:18:35.840]     if (FALSE) {
[10:18:35.840]     }
[10:18:35.840]     else {
[10:18:35.840]         if (TRUE) {
[10:18:35.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:35.840]                 open = "w")
[10:18:35.840]         }
[10:18:35.840]         else {
[10:18:35.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:35.840]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:35.840]         }
[10:18:35.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:35.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:35.840]             base::sink(type = "output", split = FALSE)
[10:18:35.840]             base::close(...future.stdout)
[10:18:35.840]         }, add = TRUE)
[10:18:35.840]     }
[10:18:35.840]     ...future.frame <- base::sys.nframe()
[10:18:35.840]     ...future.conditions <- base::list()
[10:18:35.840]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:35.840]     if (FALSE) {
[10:18:35.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:35.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:35.840]     }
[10:18:35.840]     ...future.result <- base::tryCatch({
[10:18:35.840]         base::withCallingHandlers({
[10:18:35.840]             ...future.value <- base::withVisible(base::local({
[10:18:35.840]                 ...future.makeSendCondition <- base::local({
[10:18:35.840]                   sendCondition <- NULL
[10:18:35.840]                   function(frame = 1L) {
[10:18:35.840]                     if (is.function(sendCondition)) 
[10:18:35.840]                       return(sendCondition)
[10:18:35.840]                     ns <- getNamespace("parallel")
[10:18:35.840]                     if (exists("sendData", mode = "function", 
[10:18:35.840]                       envir = ns)) {
[10:18:35.840]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:35.840]                         envir = ns)
[10:18:35.840]                       envir <- sys.frame(frame)
[10:18:35.840]                       master <- NULL
[10:18:35.840]                       while (!identical(envir, .GlobalEnv) && 
[10:18:35.840]                         !identical(envir, emptyenv())) {
[10:18:35.840]                         if (exists("master", mode = "list", envir = envir, 
[10:18:35.840]                           inherits = FALSE)) {
[10:18:35.840]                           master <- get("master", mode = "list", 
[10:18:35.840]                             envir = envir, inherits = FALSE)
[10:18:35.840]                           if (inherits(master, c("SOCKnode", 
[10:18:35.840]                             "SOCK0node"))) {
[10:18:35.840]                             sendCondition <<- function(cond) {
[10:18:35.840]                               data <- list(type = "VALUE", value = cond, 
[10:18:35.840]                                 success = TRUE)
[10:18:35.840]                               parallel_sendData(master, data)
[10:18:35.840]                             }
[10:18:35.840]                             return(sendCondition)
[10:18:35.840]                           }
[10:18:35.840]                         }
[10:18:35.840]                         frame <- frame + 1L
[10:18:35.840]                         envir <- sys.frame(frame)
[10:18:35.840]                       }
[10:18:35.840]                     }
[10:18:35.840]                     sendCondition <<- function(cond) NULL
[10:18:35.840]                   }
[10:18:35.840]                 })
[10:18:35.840]                 withCallingHandlers({
[10:18:35.840]                   {
[10:18:35.840]                     do.call(function(...) {
[10:18:35.840]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.840]                       if (!identical(...future.globals.maxSize.org, 
[10:18:35.840]                         ...future.globals.maxSize)) {
[10:18:35.840]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.840]                         on.exit(options(oopts), add = TRUE)
[10:18:35.840]                       }
[10:18:35.840]                       {
[10:18:35.840]                         lapply(seq_along(...future.elements_ii), 
[10:18:35.840]                           FUN = function(jj) {
[10:18:35.840]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.840]                             ...future.FUN(...future.X_jj, ...)
[10:18:35.840]                           })
[10:18:35.840]                       }
[10:18:35.840]                     }, args = future.call.arguments)
[10:18:35.840]                   }
[10:18:35.840]                 }, immediateCondition = function(cond) {
[10:18:35.840]                   sendCondition <- ...future.makeSendCondition()
[10:18:35.840]                   sendCondition(cond)
[10:18:35.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.840]                   {
[10:18:35.840]                     inherits <- base::inherits
[10:18:35.840]                     invokeRestart <- base::invokeRestart
[10:18:35.840]                     is.null <- base::is.null
[10:18:35.840]                     muffled <- FALSE
[10:18:35.840]                     if (inherits(cond, "message")) {
[10:18:35.840]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:35.840]                       if (muffled) 
[10:18:35.840]                         invokeRestart("muffleMessage")
[10:18:35.840]                     }
[10:18:35.840]                     else if (inherits(cond, "warning")) {
[10:18:35.840]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:35.840]                       if (muffled) 
[10:18:35.840]                         invokeRestart("muffleWarning")
[10:18:35.840]                     }
[10:18:35.840]                     else if (inherits(cond, "condition")) {
[10:18:35.840]                       if (!is.null(pattern)) {
[10:18:35.840]                         computeRestarts <- base::computeRestarts
[10:18:35.840]                         grepl <- base::grepl
[10:18:35.840]                         restarts <- computeRestarts(cond)
[10:18:35.840]                         for (restart in restarts) {
[10:18:35.840]                           name <- restart$name
[10:18:35.840]                           if (is.null(name)) 
[10:18:35.840]                             next
[10:18:35.840]                           if (!grepl(pattern, name)) 
[10:18:35.840]                             next
[10:18:35.840]                           invokeRestart(restart)
[10:18:35.840]                           muffled <- TRUE
[10:18:35.840]                           break
[10:18:35.840]                         }
[10:18:35.840]                       }
[10:18:35.840]                     }
[10:18:35.840]                     invisible(muffled)
[10:18:35.840]                   }
[10:18:35.840]                   muffleCondition(cond)
[10:18:35.840]                 })
[10:18:35.840]             }))
[10:18:35.840]             future::FutureResult(value = ...future.value$value, 
[10:18:35.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.840]                   ...future.rng), globalenv = if (FALSE) 
[10:18:35.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:35.840]                     ...future.globalenv.names))
[10:18:35.840]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:35.840]         }, condition = base::local({
[10:18:35.840]             c <- base::c
[10:18:35.840]             inherits <- base::inherits
[10:18:35.840]             invokeRestart <- base::invokeRestart
[10:18:35.840]             length <- base::length
[10:18:35.840]             list <- base::list
[10:18:35.840]             seq.int <- base::seq.int
[10:18:35.840]             signalCondition <- base::signalCondition
[10:18:35.840]             sys.calls <- base::sys.calls
[10:18:35.840]             `[[` <- base::`[[`
[10:18:35.840]             `+` <- base::`+`
[10:18:35.840]             `<<-` <- base::`<<-`
[10:18:35.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:35.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:35.840]                   3L)]
[10:18:35.840]             }
[10:18:35.840]             function(cond) {
[10:18:35.840]                 is_error <- inherits(cond, "error")
[10:18:35.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:35.840]                   NULL)
[10:18:35.840]                 if (is_error) {
[10:18:35.840]                   sessionInformation <- function() {
[10:18:35.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:35.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:35.840]                       search = base::search(), system = base::Sys.info())
[10:18:35.840]                   }
[10:18:35.840]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:35.840]                     cond$call), session = sessionInformation(), 
[10:18:35.840]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:35.840]                   signalCondition(cond)
[10:18:35.840]                 }
[10:18:35.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:35.840]                 "immediateCondition"))) {
[10:18:35.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:35.840]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:35.840]                   if (TRUE && !signal) {
[10:18:35.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.840]                     {
[10:18:35.840]                       inherits <- base::inherits
[10:18:35.840]                       invokeRestart <- base::invokeRestart
[10:18:35.840]                       is.null <- base::is.null
[10:18:35.840]                       muffled <- FALSE
[10:18:35.840]                       if (inherits(cond, "message")) {
[10:18:35.840]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.840]                         if (muffled) 
[10:18:35.840]                           invokeRestart("muffleMessage")
[10:18:35.840]                       }
[10:18:35.840]                       else if (inherits(cond, "warning")) {
[10:18:35.840]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.840]                         if (muffled) 
[10:18:35.840]                           invokeRestart("muffleWarning")
[10:18:35.840]                       }
[10:18:35.840]                       else if (inherits(cond, "condition")) {
[10:18:35.840]                         if (!is.null(pattern)) {
[10:18:35.840]                           computeRestarts <- base::computeRestarts
[10:18:35.840]                           grepl <- base::grepl
[10:18:35.840]                           restarts <- computeRestarts(cond)
[10:18:35.840]                           for (restart in restarts) {
[10:18:35.840]                             name <- restart$name
[10:18:35.840]                             if (is.null(name)) 
[10:18:35.840]                               next
[10:18:35.840]                             if (!grepl(pattern, name)) 
[10:18:35.840]                               next
[10:18:35.840]                             invokeRestart(restart)
[10:18:35.840]                             muffled <- TRUE
[10:18:35.840]                             break
[10:18:35.840]                           }
[10:18:35.840]                         }
[10:18:35.840]                       }
[10:18:35.840]                       invisible(muffled)
[10:18:35.840]                     }
[10:18:35.840]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.840]                   }
[10:18:35.840]                 }
[10:18:35.840]                 else {
[10:18:35.840]                   if (TRUE) {
[10:18:35.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.840]                     {
[10:18:35.840]                       inherits <- base::inherits
[10:18:35.840]                       invokeRestart <- base::invokeRestart
[10:18:35.840]                       is.null <- base::is.null
[10:18:35.840]                       muffled <- FALSE
[10:18:35.840]                       if (inherits(cond, "message")) {
[10:18:35.840]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.840]                         if (muffled) 
[10:18:35.840]                           invokeRestart("muffleMessage")
[10:18:35.840]                       }
[10:18:35.840]                       else if (inherits(cond, "warning")) {
[10:18:35.840]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.840]                         if (muffled) 
[10:18:35.840]                           invokeRestart("muffleWarning")
[10:18:35.840]                       }
[10:18:35.840]                       else if (inherits(cond, "condition")) {
[10:18:35.840]                         if (!is.null(pattern)) {
[10:18:35.840]                           computeRestarts <- base::computeRestarts
[10:18:35.840]                           grepl <- base::grepl
[10:18:35.840]                           restarts <- computeRestarts(cond)
[10:18:35.840]                           for (restart in restarts) {
[10:18:35.840]                             name <- restart$name
[10:18:35.840]                             if (is.null(name)) 
[10:18:35.840]                               next
[10:18:35.840]                             if (!grepl(pattern, name)) 
[10:18:35.840]                               next
[10:18:35.840]                             invokeRestart(restart)
[10:18:35.840]                             muffled <- TRUE
[10:18:35.840]                             break
[10:18:35.840]                           }
[10:18:35.840]                         }
[10:18:35.840]                       }
[10:18:35.840]                       invisible(muffled)
[10:18:35.840]                     }
[10:18:35.840]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.840]                   }
[10:18:35.840]                 }
[10:18:35.840]             }
[10:18:35.840]         }))
[10:18:35.840]     }, error = function(ex) {
[10:18:35.840]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:35.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.840]                 ...future.rng), started = ...future.startTime, 
[10:18:35.840]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:35.840]             version = "1.8"), class = "FutureResult")
[10:18:35.840]     }, finally = {
[10:18:35.840]         if (!identical(...future.workdir, getwd())) 
[10:18:35.840]             setwd(...future.workdir)
[10:18:35.840]         {
[10:18:35.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:35.840]                 ...future.oldOptions$nwarnings <- NULL
[10:18:35.840]             }
[10:18:35.840]             base::options(...future.oldOptions)
[10:18:35.840]             if (.Platform$OS.type == "windows") {
[10:18:35.840]                 old_names <- names(...future.oldEnvVars)
[10:18:35.840]                 envs <- base::Sys.getenv()
[10:18:35.840]                 names <- names(envs)
[10:18:35.840]                 common <- intersect(names, old_names)
[10:18:35.840]                 added <- setdiff(names, old_names)
[10:18:35.840]                 removed <- setdiff(old_names, names)
[10:18:35.840]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:35.840]                   envs[common]]
[10:18:35.840]                 NAMES <- toupper(changed)
[10:18:35.840]                 args <- list()
[10:18:35.840]                 for (kk in seq_along(NAMES)) {
[10:18:35.840]                   name <- changed[[kk]]
[10:18:35.840]                   NAME <- NAMES[[kk]]
[10:18:35.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.840]                     next
[10:18:35.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.840]                 }
[10:18:35.840]                 NAMES <- toupper(added)
[10:18:35.840]                 for (kk in seq_along(NAMES)) {
[10:18:35.840]                   name <- added[[kk]]
[10:18:35.840]                   NAME <- NAMES[[kk]]
[10:18:35.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.840]                     next
[10:18:35.840]                   args[[name]] <- ""
[10:18:35.840]                 }
[10:18:35.840]                 NAMES <- toupper(removed)
[10:18:35.840]                 for (kk in seq_along(NAMES)) {
[10:18:35.840]                   name <- removed[[kk]]
[10:18:35.840]                   NAME <- NAMES[[kk]]
[10:18:35.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.840]                     next
[10:18:35.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.840]                 }
[10:18:35.840]                 if (length(args) > 0) 
[10:18:35.840]                   base::do.call(base::Sys.setenv, args = args)
[10:18:35.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:35.840]             }
[10:18:35.840]             else {
[10:18:35.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:35.840]             }
[10:18:35.840]             {
[10:18:35.840]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:35.840]                   0L) {
[10:18:35.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:35.840]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:35.840]                   base::options(opts)
[10:18:35.840]                 }
[10:18:35.840]                 {
[10:18:35.840]                   {
[10:18:35.840]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:35.840]                     NULL
[10:18:35.840]                   }
[10:18:35.840]                   options(future.plan = NULL)
[10:18:35.840]                   if (is.na(NA_character_)) 
[10:18:35.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:35.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:35.840]                     .init = FALSE)
[10:18:35.840]                 }
[10:18:35.840]             }
[10:18:35.840]         }
[10:18:35.840]     })
[10:18:35.840]     if (TRUE) {
[10:18:35.840]         base::sink(type = "output", split = FALSE)
[10:18:35.840]         if (TRUE) {
[10:18:35.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:35.840]         }
[10:18:35.840]         else {
[10:18:35.840]             ...future.result["stdout"] <- base::list(NULL)
[10:18:35.840]         }
[10:18:35.840]         base::close(...future.stdout)
[10:18:35.840]         ...future.stdout <- NULL
[10:18:35.840]     }
[10:18:35.840]     ...future.result$conditions <- ...future.conditions
[10:18:35.840]     ...future.result$finished <- base::Sys.time()
[10:18:35.840]     ...future.result
[10:18:35.840] }
[10:18:35.843] Exporting 5 global objects (1.20 KiB) to cluster node #2 ...
[10:18:35.843] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:18:35.844] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:18:35.844] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #2 ...
[10:18:35.844] Exporting ‘future.call.arguments’ (171 bytes) to cluster node #2 ... DONE
[10:18:35.844] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ...
[10:18:35.845] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ... DONE
[10:18:35.845] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:35.845] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:35.845] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:35.846] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:35.846] Exporting 5 global objects (1.20 KiB) to cluster node #2 ... DONE
[10:18:35.846] MultisessionFuture started
[10:18:35.846] - Launch lazy future ... done
[10:18:35.846] run() for ‘MultisessionFuture’ ... done
[10:18:35.847] Created future:
[10:18:35.847] MultisessionFuture:
[10:18:35.847] Label: ‘future_eapply-2’
[10:18:35.847] Expression:
[10:18:35.847] {
[10:18:35.847]     do.call(function(...) {
[10:18:35.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.847]             on.exit(options(oopts), add = TRUE)
[10:18:35.847]         }
[10:18:35.847]         {
[10:18:35.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.847]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.847]             })
[10:18:35.847]         }
[10:18:35.847]     }, args = future.call.arguments)
[10:18:35.847] }
[10:18:35.847] Lazy evaluation: FALSE
[10:18:35.847] Asynchronous evaluation: TRUE
[10:18:35.847] Local evaluation: TRUE
[10:18:35.847] Environment: R_GlobalEnv
[10:18:35.847] Capture standard output: TRUE
[10:18:35.847] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:35.847] Globals: 5 objects totaling 795 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 171 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:35.847] Packages: 1 packages (‘stats’)
[10:18:35.847] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:35.847] Resolved: FALSE
[10:18:35.847] Value: <not collected>
[10:18:35.847] Conditions captured: <none>
[10:18:35.847] Early signaling: FALSE
[10:18:35.847] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:35.847] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.858] Chunk #2 of 2 ... DONE
[10:18:35.858] Launching 2 futures (chunks) ... DONE
[10:18:35.858] Resolving 2 futures (chunks) ...
[10:18:35.859] resolve() on list ...
[10:18:35.859]  recursive: 0
[10:18:35.859]  length: 2
[10:18:35.859] 
[10:18:35.859] receiveMessageFromWorker() for ClusterFuture ...
[10:18:35.860] - Validating connection of MultisessionFuture
[10:18:35.860] - received message: FutureResult
[10:18:35.860] - Received FutureResult
[10:18:35.860] - Erased future from FutureRegistry
[10:18:35.860] result() for ClusterFuture ...
[10:18:35.860] - result already collected: FutureResult
[10:18:35.860] result() for ClusterFuture ... done
[10:18:35.860] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:35.860] Future #1
[10:18:35.860] result() for ClusterFuture ...
[10:18:35.861] - result already collected: FutureResult
[10:18:35.861] result() for ClusterFuture ... done
[10:18:35.861] result() for ClusterFuture ...
[10:18:35.861] - result already collected: FutureResult
[10:18:35.861] result() for ClusterFuture ... done
[10:18:35.861] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:35.861] - nx: 2
[10:18:35.861] - relay: TRUE
[10:18:35.861] - stdout: TRUE
[10:18:35.861] - signal: TRUE
[10:18:35.861] - resignal: FALSE
[10:18:35.861] - force: TRUE
[10:18:35.862] - relayed: [n=2] FALSE, FALSE
[10:18:35.862] - queued futures: [n=2] FALSE, FALSE
[10:18:35.862]  - until=1
[10:18:35.862]  - relaying element #1
[10:18:35.862] result() for ClusterFuture ...
[10:18:35.862] - result already collected: FutureResult
[10:18:35.862] result() for ClusterFuture ... done
[10:18:35.862] result() for ClusterFuture ...
[10:18:35.862] - result already collected: FutureResult
[10:18:35.862] result() for ClusterFuture ... done
[10:18:35.862] result() for ClusterFuture ...
[10:18:35.863] - result already collected: FutureResult
[10:18:35.863] result() for ClusterFuture ... done
[10:18:35.863] result() for ClusterFuture ...
[10:18:35.863] - result already collected: FutureResult
[10:18:35.863] result() for ClusterFuture ... done
[10:18:35.863] - relayed: [n=2] TRUE, FALSE
[10:18:35.863] - queued futures: [n=2] TRUE, FALSE
[10:18:35.863] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:35.863]  length: 1 (resolved future 1)
[10:18:35.893] receiveMessageFromWorker() for ClusterFuture ...
[10:18:35.893] - Validating connection of MultisessionFuture
[10:18:35.893] - received message: FutureResult
[10:18:35.893] - Received FutureResult
[10:18:35.894] - Erased future from FutureRegistry
[10:18:35.894] result() for ClusterFuture ...
[10:18:35.894] - result already collected: FutureResult
[10:18:35.894] result() for ClusterFuture ... done
[10:18:35.894] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:35.894] Future #2
[10:18:35.894] result() for ClusterFuture ...
[10:18:35.894] - result already collected: FutureResult
[10:18:35.894] result() for ClusterFuture ... done
[10:18:35.894] result() for ClusterFuture ...
[10:18:35.894] - result already collected: FutureResult
[10:18:35.895] result() for ClusterFuture ... done
[10:18:35.895] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:35.895] - nx: 2
[10:18:35.895] - relay: TRUE
[10:18:35.895] - stdout: TRUE
[10:18:35.895] - signal: TRUE
[10:18:35.895] - resignal: FALSE
[10:18:35.895] - force: TRUE
[10:18:35.895] - relayed: [n=2] TRUE, FALSE
[10:18:35.895] - queued futures: [n=2] TRUE, FALSE
[10:18:35.895]  - until=2
[10:18:35.895]  - relaying element #2
[10:18:35.896] result() for ClusterFuture ...
[10:18:35.896] - result already collected: FutureResult
[10:18:35.896] result() for ClusterFuture ... done
[10:18:35.896] result() for ClusterFuture ...
[10:18:35.896] - result already collected: FutureResult
[10:18:35.896] result() for ClusterFuture ... done
[10:18:35.896] result() for ClusterFuture ...
[10:18:35.896] - result already collected: FutureResult
[10:18:35.896] result() for ClusterFuture ... done
[10:18:35.896] result() for ClusterFuture ...
[10:18:35.896] - result already collected: FutureResult
[10:18:35.896] result() for ClusterFuture ... done
[10:18:35.897] - relayed: [n=2] TRUE, TRUE
[10:18:35.897] - queued futures: [n=2] TRUE, TRUE
[10:18:35.897] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:35.897]  length: 0 (resolved future 2)
[10:18:35.897] Relaying remaining futures
[10:18:35.897] signalConditionsASAP(NULL, pos=0) ...
[10:18:35.897] - nx: 2
[10:18:35.897] - relay: TRUE
[10:18:35.897] - stdout: TRUE
[10:18:35.897] - signal: TRUE
[10:18:35.897] - resignal: FALSE
[10:18:35.897] - force: TRUE
[10:18:35.898] - relayed: [n=2] TRUE, TRUE
[10:18:35.898] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:35.898] - relayed: [n=2] TRUE, TRUE
[10:18:35.898] - queued futures: [n=2] TRUE, TRUE
[10:18:35.898] signalConditionsASAP(NULL, pos=0) ... done
[10:18:35.898] resolve() on list ... DONE
[10:18:35.898] result() for ClusterFuture ...
[10:18:35.898] - result already collected: FutureResult
[10:18:35.898] result() for ClusterFuture ... done
[10:18:35.898] result() for ClusterFuture ...
[10:18:35.898] - result already collected: FutureResult
[10:18:35.898] result() for ClusterFuture ... done
[10:18:35.899] result() for ClusterFuture ...
[10:18:35.899] - result already collected: FutureResult
[10:18:35.899] result() for ClusterFuture ... done
[10:18:35.899] result() for ClusterFuture ...
[10:18:35.899] - result already collected: FutureResult
[10:18:35.899] result() for ClusterFuture ... done
[10:18:35.899]  - Number of value chunks collected: 2
[10:18:35.899] Resolving 2 futures (chunks) ... DONE
[10:18:35.899] Reducing values from 2 chunks ...
[10:18:35.899]  - Number of values collected after concatenation: 3
[10:18:35.899]  - Number of values expected: 3
[10:18:35.900] Reducing values from 2 chunks ... DONE
[10:18:35.900] future_lapply() ... DONE
[10:18:35.900] future_lapply() ...
[10:18:35.903] Number of chunks: 2
[10:18:35.903] getGlobalsAndPackagesXApply() ...
[10:18:35.903]  - future.globals: TRUE
[10:18:35.903] getGlobalsAndPackages() ...
[10:18:35.903] Searching for globals...
[10:18:35.904] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:35.904] Searching for globals ... DONE
[10:18:35.904] Resolving globals: FALSE
[10:18:35.905] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:35.905] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:35.905] - globals: [1] ‘FUN’
[10:18:35.905] - packages: [1] ‘stats’
[10:18:35.905] getGlobalsAndPackages() ... DONE
[10:18:35.906]  - globals found/used: [n=1] ‘FUN’
[10:18:35.906]  - needed namespaces: [n=1] ‘stats’
[10:18:35.906] Finding globals ... DONE
[10:18:35.906]  - use_args: TRUE
[10:18:35.906]  - Getting '...' globals ...
[10:18:35.906] resolve() on list ...
[10:18:35.906]  recursive: 0
[10:18:35.906]  length: 1
[10:18:35.906]  elements: ‘...’
[10:18:35.907]  length: 0 (resolved future 1)
[10:18:35.907] resolve() on list ... DONE
[10:18:35.907]    - '...' content: [n=0] 
[10:18:35.907] List of 1
[10:18:35.907]  $ ...: list()
[10:18:35.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:35.907]  - attr(*, "where")=List of 1
[10:18:35.907]   ..$ ...:<environment: 0x56033e1882b8> 
[10:18:35.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:35.907]  - attr(*, "resolved")= logi TRUE
[10:18:35.907]  - attr(*, "total_size")= num NA
[10:18:35.910]  - Getting '...' globals ... DONE
[10:18:35.910] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:35.910] List of 2
[10:18:35.910]  $ ...future.FUN:function (x, ...)  
[10:18:35.910]  $ ...          : list()
[10:18:35.910]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:35.910]  - attr(*, "where")=List of 2
[10:18:35.910]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:35.910]   ..$ ...          :<environment: 0x56033e1882b8> 
[10:18:35.910]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:35.910]  - attr(*, "resolved")= logi FALSE
[10:18:35.910]  - attr(*, "total_size")= num 5433
[10:18:35.913] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:35.913] getGlobalsAndPackagesXApply() ... DONE
[10:18:35.913] Number of futures (= number of chunks): 2
[10:18:35.913] Launching 2 futures (chunks) ...
[10:18:35.913] Chunk #1 of 2 ...
[10:18:35.914]  - Finding globals in 'X' for chunk #1 ...
[10:18:35.914] getGlobalsAndPackages() ...
[10:18:35.914] Searching for globals...
[10:18:35.914] 
[10:18:35.914] Searching for globals ... DONE
[10:18:35.914] - globals: [0] <none>
[10:18:35.914] getGlobalsAndPackages() ... DONE
[10:18:35.914]    + additional globals found: [n=0] 
[10:18:35.914]    + additional namespaces needed: [n=0] 
[10:18:35.915]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:35.915]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:35.915]  - seeds: <none>
[10:18:35.915]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.915] getGlobalsAndPackages() ...
[10:18:35.915] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.915] Resolving globals: FALSE
[10:18:35.915] Tweak future expression to call with '...' arguments ...
[10:18:35.915] {
[10:18:35.915]     do.call(function(...) {
[10:18:35.915]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.915]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.915]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.915]             on.exit(options(oopts), add = TRUE)
[10:18:35.915]         }
[10:18:35.915]         {
[10:18:35.915]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.915]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.915]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.915]             })
[10:18:35.915]         }
[10:18:35.915]     }, args = future.call.arguments)
[10:18:35.915] }
[10:18:35.916] Tweak future expression to call with '...' arguments ... DONE
[10:18:35.916] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.916] - packages: [1] ‘stats’
[10:18:35.916] getGlobalsAndPackages() ... DONE
[10:18:35.917] run() for ‘Future’ ...
[10:18:35.917] - state: ‘created’
[10:18:35.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:35.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:35.931]   - Field: ‘node’
[10:18:35.931]   - Field: ‘label’
[10:18:35.932]   - Field: ‘local’
[10:18:35.932]   - Field: ‘owner’
[10:18:35.932]   - Field: ‘envir’
[10:18:35.932]   - Field: ‘workers’
[10:18:35.932]   - Field: ‘packages’
[10:18:35.932]   - Field: ‘gc’
[10:18:35.932]   - Field: ‘conditions’
[10:18:35.932]   - Field: ‘persistent’
[10:18:35.932]   - Field: ‘expr’
[10:18:35.932]   - Field: ‘uuid’
[10:18:35.932]   - Field: ‘seed’
[10:18:35.933]   - Field: ‘version’
[10:18:35.933]   - Field: ‘result’
[10:18:35.933]   - Field: ‘asynchronous’
[10:18:35.933]   - Field: ‘calls’
[10:18:35.933]   - Field: ‘globals’
[10:18:35.933]   - Field: ‘stdout’
[10:18:35.933]   - Field: ‘earlySignal’
[10:18:35.933]   - Field: ‘lazy’
[10:18:35.933]   - Field: ‘state’
[10:18:35.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:35.933] - Launch lazy future ...
[10:18:35.934] Packages needed by the future expression (n = 1): ‘stats’
[10:18:35.934] Packages needed by future strategies (n = 0): <none>
[10:18:35.934] {
[10:18:35.934]     {
[10:18:35.934]         {
[10:18:35.934]             ...future.startTime <- base::Sys.time()
[10:18:35.934]             {
[10:18:35.934]                 {
[10:18:35.934]                   {
[10:18:35.934]                     {
[10:18:35.934]                       {
[10:18:35.934]                         base::local({
[10:18:35.934]                           has_future <- base::requireNamespace("future", 
[10:18:35.934]                             quietly = TRUE)
[10:18:35.934]                           if (has_future) {
[10:18:35.934]                             ns <- base::getNamespace("future")
[10:18:35.934]                             version <- ns[[".package"]][["version"]]
[10:18:35.934]                             if (is.null(version)) 
[10:18:35.934]                               version <- utils::packageVersion("future")
[10:18:35.934]                           }
[10:18:35.934]                           else {
[10:18:35.934]                             version <- NULL
[10:18:35.934]                           }
[10:18:35.934]                           if (!has_future || version < "1.8.0") {
[10:18:35.934]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:35.934]                               "", base::R.version$version.string), 
[10:18:35.934]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:35.934]                                 base::R.version$platform, 8 * 
[10:18:35.934]                                   base::.Machine$sizeof.pointer), 
[10:18:35.934]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:35.934]                                 "release", "version")], collapse = " "), 
[10:18:35.934]                               hostname = base::Sys.info()[["nodename"]])
[10:18:35.934]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:35.934]                               info)
[10:18:35.934]                             info <- base::paste(info, collapse = "; ")
[10:18:35.934]                             if (!has_future) {
[10:18:35.934]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:35.934]                                 info)
[10:18:35.934]                             }
[10:18:35.934]                             else {
[10:18:35.934]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:35.934]                                 info, version)
[10:18:35.934]                             }
[10:18:35.934]                             base::stop(msg)
[10:18:35.934]                           }
[10:18:35.934]                         })
[10:18:35.934]                       }
[10:18:35.934]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:35.934]                       base::options(mc.cores = 1L)
[10:18:35.934]                     }
[10:18:35.934]                     base::local({
[10:18:35.934]                       for (pkg in "stats") {
[10:18:35.934]                         base::loadNamespace(pkg)
[10:18:35.934]                         base::library(pkg, character.only = TRUE)
[10:18:35.934]                       }
[10:18:35.934]                     })
[10:18:35.934]                   }
[10:18:35.934]                   ...future.strategy.old <- future::plan("list")
[10:18:35.934]                   options(future.plan = NULL)
[10:18:35.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:35.934]                 }
[10:18:35.934]                 ...future.workdir <- getwd()
[10:18:35.934]             }
[10:18:35.934]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:35.934]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:35.934]         }
[10:18:35.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:35.934]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:35.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:35.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:35.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:35.934]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:35.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:35.934]             base::names(...future.oldOptions))
[10:18:35.934]     }
[10:18:35.934]     if (FALSE) {
[10:18:35.934]     }
[10:18:35.934]     else {
[10:18:35.934]         if (TRUE) {
[10:18:35.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:35.934]                 open = "w")
[10:18:35.934]         }
[10:18:35.934]         else {
[10:18:35.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:35.934]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:35.934]         }
[10:18:35.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:35.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:35.934]             base::sink(type = "output", split = FALSE)
[10:18:35.934]             base::close(...future.stdout)
[10:18:35.934]         }, add = TRUE)
[10:18:35.934]     }
[10:18:35.934]     ...future.frame <- base::sys.nframe()
[10:18:35.934]     ...future.conditions <- base::list()
[10:18:35.934]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:35.934]     if (FALSE) {
[10:18:35.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:35.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:35.934]     }
[10:18:35.934]     ...future.result <- base::tryCatch({
[10:18:35.934]         base::withCallingHandlers({
[10:18:35.934]             ...future.value <- base::withVisible(base::local({
[10:18:35.934]                 ...future.makeSendCondition <- base::local({
[10:18:35.934]                   sendCondition <- NULL
[10:18:35.934]                   function(frame = 1L) {
[10:18:35.934]                     if (is.function(sendCondition)) 
[10:18:35.934]                       return(sendCondition)
[10:18:35.934]                     ns <- getNamespace("parallel")
[10:18:35.934]                     if (exists("sendData", mode = "function", 
[10:18:35.934]                       envir = ns)) {
[10:18:35.934]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:35.934]                         envir = ns)
[10:18:35.934]                       envir <- sys.frame(frame)
[10:18:35.934]                       master <- NULL
[10:18:35.934]                       while (!identical(envir, .GlobalEnv) && 
[10:18:35.934]                         !identical(envir, emptyenv())) {
[10:18:35.934]                         if (exists("master", mode = "list", envir = envir, 
[10:18:35.934]                           inherits = FALSE)) {
[10:18:35.934]                           master <- get("master", mode = "list", 
[10:18:35.934]                             envir = envir, inherits = FALSE)
[10:18:35.934]                           if (inherits(master, c("SOCKnode", 
[10:18:35.934]                             "SOCK0node"))) {
[10:18:35.934]                             sendCondition <<- function(cond) {
[10:18:35.934]                               data <- list(type = "VALUE", value = cond, 
[10:18:35.934]                                 success = TRUE)
[10:18:35.934]                               parallel_sendData(master, data)
[10:18:35.934]                             }
[10:18:35.934]                             return(sendCondition)
[10:18:35.934]                           }
[10:18:35.934]                         }
[10:18:35.934]                         frame <- frame + 1L
[10:18:35.934]                         envir <- sys.frame(frame)
[10:18:35.934]                       }
[10:18:35.934]                     }
[10:18:35.934]                     sendCondition <<- function(cond) NULL
[10:18:35.934]                   }
[10:18:35.934]                 })
[10:18:35.934]                 withCallingHandlers({
[10:18:35.934]                   {
[10:18:35.934]                     do.call(function(...) {
[10:18:35.934]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.934]                       if (!identical(...future.globals.maxSize.org, 
[10:18:35.934]                         ...future.globals.maxSize)) {
[10:18:35.934]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.934]                         on.exit(options(oopts), add = TRUE)
[10:18:35.934]                       }
[10:18:35.934]                       {
[10:18:35.934]                         lapply(seq_along(...future.elements_ii), 
[10:18:35.934]                           FUN = function(jj) {
[10:18:35.934]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.934]                             ...future.FUN(...future.X_jj, ...)
[10:18:35.934]                           })
[10:18:35.934]                       }
[10:18:35.934]                     }, args = future.call.arguments)
[10:18:35.934]                   }
[10:18:35.934]                 }, immediateCondition = function(cond) {
[10:18:35.934]                   sendCondition <- ...future.makeSendCondition()
[10:18:35.934]                   sendCondition(cond)
[10:18:35.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.934]                   {
[10:18:35.934]                     inherits <- base::inherits
[10:18:35.934]                     invokeRestart <- base::invokeRestart
[10:18:35.934]                     is.null <- base::is.null
[10:18:35.934]                     muffled <- FALSE
[10:18:35.934]                     if (inherits(cond, "message")) {
[10:18:35.934]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:35.934]                       if (muffled) 
[10:18:35.934]                         invokeRestart("muffleMessage")
[10:18:35.934]                     }
[10:18:35.934]                     else if (inherits(cond, "warning")) {
[10:18:35.934]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:35.934]                       if (muffled) 
[10:18:35.934]                         invokeRestart("muffleWarning")
[10:18:35.934]                     }
[10:18:35.934]                     else if (inherits(cond, "condition")) {
[10:18:35.934]                       if (!is.null(pattern)) {
[10:18:35.934]                         computeRestarts <- base::computeRestarts
[10:18:35.934]                         grepl <- base::grepl
[10:18:35.934]                         restarts <- computeRestarts(cond)
[10:18:35.934]                         for (restart in restarts) {
[10:18:35.934]                           name <- restart$name
[10:18:35.934]                           if (is.null(name)) 
[10:18:35.934]                             next
[10:18:35.934]                           if (!grepl(pattern, name)) 
[10:18:35.934]                             next
[10:18:35.934]                           invokeRestart(restart)
[10:18:35.934]                           muffled <- TRUE
[10:18:35.934]                           break
[10:18:35.934]                         }
[10:18:35.934]                       }
[10:18:35.934]                     }
[10:18:35.934]                     invisible(muffled)
[10:18:35.934]                   }
[10:18:35.934]                   muffleCondition(cond)
[10:18:35.934]                 })
[10:18:35.934]             }))
[10:18:35.934]             future::FutureResult(value = ...future.value$value, 
[10:18:35.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.934]                   ...future.rng), globalenv = if (FALSE) 
[10:18:35.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:35.934]                     ...future.globalenv.names))
[10:18:35.934]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:35.934]         }, condition = base::local({
[10:18:35.934]             c <- base::c
[10:18:35.934]             inherits <- base::inherits
[10:18:35.934]             invokeRestart <- base::invokeRestart
[10:18:35.934]             length <- base::length
[10:18:35.934]             list <- base::list
[10:18:35.934]             seq.int <- base::seq.int
[10:18:35.934]             signalCondition <- base::signalCondition
[10:18:35.934]             sys.calls <- base::sys.calls
[10:18:35.934]             `[[` <- base::`[[`
[10:18:35.934]             `+` <- base::`+`
[10:18:35.934]             `<<-` <- base::`<<-`
[10:18:35.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:35.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:35.934]                   3L)]
[10:18:35.934]             }
[10:18:35.934]             function(cond) {
[10:18:35.934]                 is_error <- inherits(cond, "error")
[10:18:35.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:35.934]                   NULL)
[10:18:35.934]                 if (is_error) {
[10:18:35.934]                   sessionInformation <- function() {
[10:18:35.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:35.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:35.934]                       search = base::search(), system = base::Sys.info())
[10:18:35.934]                   }
[10:18:35.934]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:35.934]                     cond$call), session = sessionInformation(), 
[10:18:35.934]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:35.934]                   signalCondition(cond)
[10:18:35.934]                 }
[10:18:35.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:35.934]                 "immediateCondition"))) {
[10:18:35.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:35.934]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:35.934]                   if (TRUE && !signal) {
[10:18:35.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.934]                     {
[10:18:35.934]                       inherits <- base::inherits
[10:18:35.934]                       invokeRestart <- base::invokeRestart
[10:18:35.934]                       is.null <- base::is.null
[10:18:35.934]                       muffled <- FALSE
[10:18:35.934]                       if (inherits(cond, "message")) {
[10:18:35.934]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.934]                         if (muffled) 
[10:18:35.934]                           invokeRestart("muffleMessage")
[10:18:35.934]                       }
[10:18:35.934]                       else if (inherits(cond, "warning")) {
[10:18:35.934]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.934]                         if (muffled) 
[10:18:35.934]                           invokeRestart("muffleWarning")
[10:18:35.934]                       }
[10:18:35.934]                       else if (inherits(cond, "condition")) {
[10:18:35.934]                         if (!is.null(pattern)) {
[10:18:35.934]                           computeRestarts <- base::computeRestarts
[10:18:35.934]                           grepl <- base::grepl
[10:18:35.934]                           restarts <- computeRestarts(cond)
[10:18:35.934]                           for (restart in restarts) {
[10:18:35.934]                             name <- restart$name
[10:18:35.934]                             if (is.null(name)) 
[10:18:35.934]                               next
[10:18:35.934]                             if (!grepl(pattern, name)) 
[10:18:35.934]                               next
[10:18:35.934]                             invokeRestart(restart)
[10:18:35.934]                             muffled <- TRUE
[10:18:35.934]                             break
[10:18:35.934]                           }
[10:18:35.934]                         }
[10:18:35.934]                       }
[10:18:35.934]                       invisible(muffled)
[10:18:35.934]                     }
[10:18:35.934]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.934]                   }
[10:18:35.934]                 }
[10:18:35.934]                 else {
[10:18:35.934]                   if (TRUE) {
[10:18:35.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.934]                     {
[10:18:35.934]                       inherits <- base::inherits
[10:18:35.934]                       invokeRestart <- base::invokeRestart
[10:18:35.934]                       is.null <- base::is.null
[10:18:35.934]                       muffled <- FALSE
[10:18:35.934]                       if (inherits(cond, "message")) {
[10:18:35.934]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.934]                         if (muffled) 
[10:18:35.934]                           invokeRestart("muffleMessage")
[10:18:35.934]                       }
[10:18:35.934]                       else if (inherits(cond, "warning")) {
[10:18:35.934]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.934]                         if (muffled) 
[10:18:35.934]                           invokeRestart("muffleWarning")
[10:18:35.934]                       }
[10:18:35.934]                       else if (inherits(cond, "condition")) {
[10:18:35.934]                         if (!is.null(pattern)) {
[10:18:35.934]                           computeRestarts <- base::computeRestarts
[10:18:35.934]                           grepl <- base::grepl
[10:18:35.934]                           restarts <- computeRestarts(cond)
[10:18:35.934]                           for (restart in restarts) {
[10:18:35.934]                             name <- restart$name
[10:18:35.934]                             if (is.null(name)) 
[10:18:35.934]                               next
[10:18:35.934]                             if (!grepl(pattern, name)) 
[10:18:35.934]                               next
[10:18:35.934]                             invokeRestart(restart)
[10:18:35.934]                             muffled <- TRUE
[10:18:35.934]                             break
[10:18:35.934]                           }
[10:18:35.934]                         }
[10:18:35.934]                       }
[10:18:35.934]                       invisible(muffled)
[10:18:35.934]                     }
[10:18:35.934]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.934]                   }
[10:18:35.934]                 }
[10:18:35.934]             }
[10:18:35.934]         }))
[10:18:35.934]     }, error = function(ex) {
[10:18:35.934]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:35.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.934]                 ...future.rng), started = ...future.startTime, 
[10:18:35.934]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:35.934]             version = "1.8"), class = "FutureResult")
[10:18:35.934]     }, finally = {
[10:18:35.934]         if (!identical(...future.workdir, getwd())) 
[10:18:35.934]             setwd(...future.workdir)
[10:18:35.934]         {
[10:18:35.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:35.934]                 ...future.oldOptions$nwarnings <- NULL
[10:18:35.934]             }
[10:18:35.934]             base::options(...future.oldOptions)
[10:18:35.934]             if (.Platform$OS.type == "windows") {
[10:18:35.934]                 old_names <- names(...future.oldEnvVars)
[10:18:35.934]                 envs <- base::Sys.getenv()
[10:18:35.934]                 names <- names(envs)
[10:18:35.934]                 common <- intersect(names, old_names)
[10:18:35.934]                 added <- setdiff(names, old_names)
[10:18:35.934]                 removed <- setdiff(old_names, names)
[10:18:35.934]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:35.934]                   envs[common]]
[10:18:35.934]                 NAMES <- toupper(changed)
[10:18:35.934]                 args <- list()
[10:18:35.934]                 for (kk in seq_along(NAMES)) {
[10:18:35.934]                   name <- changed[[kk]]
[10:18:35.934]                   NAME <- NAMES[[kk]]
[10:18:35.934]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.934]                     next
[10:18:35.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.934]                 }
[10:18:35.934]                 NAMES <- toupper(added)
[10:18:35.934]                 for (kk in seq_along(NAMES)) {
[10:18:35.934]                   name <- added[[kk]]
[10:18:35.934]                   NAME <- NAMES[[kk]]
[10:18:35.934]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.934]                     next
[10:18:35.934]                   args[[name]] <- ""
[10:18:35.934]                 }
[10:18:35.934]                 NAMES <- toupper(removed)
[10:18:35.934]                 for (kk in seq_along(NAMES)) {
[10:18:35.934]                   name <- removed[[kk]]
[10:18:35.934]                   NAME <- NAMES[[kk]]
[10:18:35.934]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.934]                     next
[10:18:35.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.934]                 }
[10:18:35.934]                 if (length(args) > 0) 
[10:18:35.934]                   base::do.call(base::Sys.setenv, args = args)
[10:18:35.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:35.934]             }
[10:18:35.934]             else {
[10:18:35.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:35.934]             }
[10:18:35.934]             {
[10:18:35.934]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:35.934]                   0L) {
[10:18:35.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:35.934]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:35.934]                   base::options(opts)
[10:18:35.934]                 }
[10:18:35.934]                 {
[10:18:35.934]                   {
[10:18:35.934]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:35.934]                     NULL
[10:18:35.934]                   }
[10:18:35.934]                   options(future.plan = NULL)
[10:18:35.934]                   if (is.na(NA_character_)) 
[10:18:35.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:35.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:35.934]                     .init = FALSE)
[10:18:35.934]                 }
[10:18:35.934]             }
[10:18:35.934]         }
[10:18:35.934]     })
[10:18:35.934]     if (TRUE) {
[10:18:35.934]         base::sink(type = "output", split = FALSE)
[10:18:35.934]         if (TRUE) {
[10:18:35.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:35.934]         }
[10:18:35.934]         else {
[10:18:35.934]             ...future.result["stdout"] <- base::list(NULL)
[10:18:35.934]         }
[10:18:35.934]         base::close(...future.stdout)
[10:18:35.934]         ...future.stdout <- NULL
[10:18:35.934]     }
[10:18:35.934]     ...future.result$conditions <- ...future.conditions
[10:18:35.934]     ...future.result$finished <- base::Sys.time()
[10:18:35.934]     ...future.result
[10:18:35.934] }
[10:18:35.937] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[10:18:35.938] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:18:35.938] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:18:35.938] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:35.938] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:35.938] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ...
[10:18:35.939] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ... DONE
[10:18:35.939] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:35.939] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:35.939] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:35.940] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:35.940] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[10:18:35.940] MultisessionFuture started
[10:18:35.940] - Launch lazy future ... done
[10:18:35.940] run() for ‘MultisessionFuture’ ... done
[10:18:35.941] Created future:
[10:18:35.941] MultisessionFuture:
[10:18:35.941] Label: ‘future_eapply-1’
[10:18:35.941] Expression:
[10:18:35.941] {
[10:18:35.941]     do.call(function(...) {
[10:18:35.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.941]             on.exit(options(oopts), add = TRUE)
[10:18:35.941]         }
[10:18:35.941]         {
[10:18:35.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.941]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.941]             })
[10:18:35.941]         }
[10:18:35.941]     }, args = future.call.arguments)
[10:18:35.941] }
[10:18:35.941] Lazy evaluation: FALSE
[10:18:35.941] Asynchronous evaluation: TRUE
[10:18:35.941] Local evaluation: TRUE
[10:18:35.941] Environment: R_GlobalEnv
[10:18:35.941] Capture standard output: TRUE
[10:18:35.941] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:35.941] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:35.941] Packages: 1 packages (‘stats’)
[10:18:35.941] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:35.941] Resolved: FALSE
[10:18:35.941] Value: <not collected>
[10:18:35.941] Conditions captured: <none>
[10:18:35.941] Early signaling: FALSE
[10:18:35.941] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:35.941] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.952] Chunk #1 of 2 ... DONE
[10:18:35.952] Chunk #2 of 2 ...
[10:18:35.952]  - Finding globals in 'X' for chunk #2 ...
[10:18:35.952] getGlobalsAndPackages() ...
[10:18:35.953] Searching for globals...
[10:18:35.953] 
[10:18:35.953] Searching for globals ... DONE
[10:18:35.953] - globals: [0] <none>
[10:18:35.953] getGlobalsAndPackages() ... DONE
[10:18:35.953]    + additional globals found: [n=0] 
[10:18:35.953]    + additional namespaces needed: [n=0] 
[10:18:35.953]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:35.954]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:35.954]  - seeds: <none>
[10:18:35.954]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.954] getGlobalsAndPackages() ...
[10:18:35.954] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.954] Resolving globals: FALSE
[10:18:35.954] Tweak future expression to call with '...' arguments ...
[10:18:35.954] {
[10:18:35.954]     do.call(function(...) {
[10:18:35.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.954]             on.exit(options(oopts), add = TRUE)
[10:18:35.954]         }
[10:18:35.954]         {
[10:18:35.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.954]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.954]             })
[10:18:35.954]         }
[10:18:35.954]     }, args = future.call.arguments)
[10:18:35.954] }
[10:18:35.955] Tweak future expression to call with '...' arguments ... DONE
[10:18:35.955] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:35.955] - packages: [1] ‘stats’
[10:18:35.955] getGlobalsAndPackages() ... DONE
[10:18:35.955] run() for ‘Future’ ...
[10:18:35.956] - state: ‘created’
[10:18:35.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:35.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:35.970]   - Field: ‘node’
[10:18:35.970]   - Field: ‘label’
[10:18:35.970]   - Field: ‘local’
[10:18:35.971]   - Field: ‘owner’
[10:18:35.971]   - Field: ‘envir’
[10:18:35.971]   - Field: ‘workers’
[10:18:35.971]   - Field: ‘packages’
[10:18:35.971]   - Field: ‘gc’
[10:18:35.971]   - Field: ‘conditions’
[10:18:35.971]   - Field: ‘persistent’
[10:18:35.971]   - Field: ‘expr’
[10:18:35.971]   - Field: ‘uuid’
[10:18:35.971]   - Field: ‘seed’
[10:18:35.971]   - Field: ‘version’
[10:18:35.972]   - Field: ‘result’
[10:18:35.972]   - Field: ‘asynchronous’
[10:18:35.972]   - Field: ‘calls’
[10:18:35.972]   - Field: ‘globals’
[10:18:35.972]   - Field: ‘stdout’
[10:18:35.972]   - Field: ‘earlySignal’
[10:18:35.972]   - Field: ‘lazy’
[10:18:35.972]   - Field: ‘state’
[10:18:35.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:35.972] - Launch lazy future ...
[10:18:35.973] Packages needed by the future expression (n = 1): ‘stats’
[10:18:35.973] Packages needed by future strategies (n = 0): <none>
[10:18:35.973] {
[10:18:35.973]     {
[10:18:35.973]         {
[10:18:35.973]             ...future.startTime <- base::Sys.time()
[10:18:35.973]             {
[10:18:35.973]                 {
[10:18:35.973]                   {
[10:18:35.973]                     {
[10:18:35.973]                       {
[10:18:35.973]                         base::local({
[10:18:35.973]                           has_future <- base::requireNamespace("future", 
[10:18:35.973]                             quietly = TRUE)
[10:18:35.973]                           if (has_future) {
[10:18:35.973]                             ns <- base::getNamespace("future")
[10:18:35.973]                             version <- ns[[".package"]][["version"]]
[10:18:35.973]                             if (is.null(version)) 
[10:18:35.973]                               version <- utils::packageVersion("future")
[10:18:35.973]                           }
[10:18:35.973]                           else {
[10:18:35.973]                             version <- NULL
[10:18:35.973]                           }
[10:18:35.973]                           if (!has_future || version < "1.8.0") {
[10:18:35.973]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:35.973]                               "", base::R.version$version.string), 
[10:18:35.973]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:35.973]                                 base::R.version$platform, 8 * 
[10:18:35.973]                                   base::.Machine$sizeof.pointer), 
[10:18:35.973]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:35.973]                                 "release", "version")], collapse = " "), 
[10:18:35.973]                               hostname = base::Sys.info()[["nodename"]])
[10:18:35.973]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:35.973]                               info)
[10:18:35.973]                             info <- base::paste(info, collapse = "; ")
[10:18:35.973]                             if (!has_future) {
[10:18:35.973]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:35.973]                                 info)
[10:18:35.973]                             }
[10:18:35.973]                             else {
[10:18:35.973]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:35.973]                                 info, version)
[10:18:35.973]                             }
[10:18:35.973]                             base::stop(msg)
[10:18:35.973]                           }
[10:18:35.973]                         })
[10:18:35.973]                       }
[10:18:35.973]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:35.973]                       base::options(mc.cores = 1L)
[10:18:35.973]                     }
[10:18:35.973]                     base::local({
[10:18:35.973]                       for (pkg in "stats") {
[10:18:35.973]                         base::loadNamespace(pkg)
[10:18:35.973]                         base::library(pkg, character.only = TRUE)
[10:18:35.973]                       }
[10:18:35.973]                     })
[10:18:35.973]                   }
[10:18:35.973]                   ...future.strategy.old <- future::plan("list")
[10:18:35.973]                   options(future.plan = NULL)
[10:18:35.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:35.973]                 }
[10:18:35.973]                 ...future.workdir <- getwd()
[10:18:35.973]             }
[10:18:35.973]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:35.973]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:35.973]         }
[10:18:35.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:35.973]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:35.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:35.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:35.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:35.973]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:35.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:35.973]             base::names(...future.oldOptions))
[10:18:35.973]     }
[10:18:35.973]     if (FALSE) {
[10:18:35.973]     }
[10:18:35.973]     else {
[10:18:35.973]         if (TRUE) {
[10:18:35.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:35.973]                 open = "w")
[10:18:35.973]         }
[10:18:35.973]         else {
[10:18:35.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:35.973]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:35.973]         }
[10:18:35.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:35.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:35.973]             base::sink(type = "output", split = FALSE)
[10:18:35.973]             base::close(...future.stdout)
[10:18:35.973]         }, add = TRUE)
[10:18:35.973]     }
[10:18:35.973]     ...future.frame <- base::sys.nframe()
[10:18:35.973]     ...future.conditions <- base::list()
[10:18:35.973]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:35.973]     if (FALSE) {
[10:18:35.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:35.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:35.973]     }
[10:18:35.973]     ...future.result <- base::tryCatch({
[10:18:35.973]         base::withCallingHandlers({
[10:18:35.973]             ...future.value <- base::withVisible(base::local({
[10:18:35.973]                 ...future.makeSendCondition <- base::local({
[10:18:35.973]                   sendCondition <- NULL
[10:18:35.973]                   function(frame = 1L) {
[10:18:35.973]                     if (is.function(sendCondition)) 
[10:18:35.973]                       return(sendCondition)
[10:18:35.973]                     ns <- getNamespace("parallel")
[10:18:35.973]                     if (exists("sendData", mode = "function", 
[10:18:35.973]                       envir = ns)) {
[10:18:35.973]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:35.973]                         envir = ns)
[10:18:35.973]                       envir <- sys.frame(frame)
[10:18:35.973]                       master <- NULL
[10:18:35.973]                       while (!identical(envir, .GlobalEnv) && 
[10:18:35.973]                         !identical(envir, emptyenv())) {
[10:18:35.973]                         if (exists("master", mode = "list", envir = envir, 
[10:18:35.973]                           inherits = FALSE)) {
[10:18:35.973]                           master <- get("master", mode = "list", 
[10:18:35.973]                             envir = envir, inherits = FALSE)
[10:18:35.973]                           if (inherits(master, c("SOCKnode", 
[10:18:35.973]                             "SOCK0node"))) {
[10:18:35.973]                             sendCondition <<- function(cond) {
[10:18:35.973]                               data <- list(type = "VALUE", value = cond, 
[10:18:35.973]                                 success = TRUE)
[10:18:35.973]                               parallel_sendData(master, data)
[10:18:35.973]                             }
[10:18:35.973]                             return(sendCondition)
[10:18:35.973]                           }
[10:18:35.973]                         }
[10:18:35.973]                         frame <- frame + 1L
[10:18:35.973]                         envir <- sys.frame(frame)
[10:18:35.973]                       }
[10:18:35.973]                     }
[10:18:35.973]                     sendCondition <<- function(cond) NULL
[10:18:35.973]                   }
[10:18:35.973]                 })
[10:18:35.973]                 withCallingHandlers({
[10:18:35.973]                   {
[10:18:35.973]                     do.call(function(...) {
[10:18:35.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.973]                       if (!identical(...future.globals.maxSize.org, 
[10:18:35.973]                         ...future.globals.maxSize)) {
[10:18:35.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.973]                         on.exit(options(oopts), add = TRUE)
[10:18:35.973]                       }
[10:18:35.973]                       {
[10:18:35.973]                         lapply(seq_along(...future.elements_ii), 
[10:18:35.973]                           FUN = function(jj) {
[10:18:35.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.973]                             ...future.FUN(...future.X_jj, ...)
[10:18:35.973]                           })
[10:18:35.973]                       }
[10:18:35.973]                     }, args = future.call.arguments)
[10:18:35.973]                   }
[10:18:35.973]                 }, immediateCondition = function(cond) {
[10:18:35.973]                   sendCondition <- ...future.makeSendCondition()
[10:18:35.973]                   sendCondition(cond)
[10:18:35.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.973]                   {
[10:18:35.973]                     inherits <- base::inherits
[10:18:35.973]                     invokeRestart <- base::invokeRestart
[10:18:35.973]                     is.null <- base::is.null
[10:18:35.973]                     muffled <- FALSE
[10:18:35.973]                     if (inherits(cond, "message")) {
[10:18:35.973]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:35.973]                       if (muffled) 
[10:18:35.973]                         invokeRestart("muffleMessage")
[10:18:35.973]                     }
[10:18:35.973]                     else if (inherits(cond, "warning")) {
[10:18:35.973]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:35.973]                       if (muffled) 
[10:18:35.973]                         invokeRestart("muffleWarning")
[10:18:35.973]                     }
[10:18:35.973]                     else if (inherits(cond, "condition")) {
[10:18:35.973]                       if (!is.null(pattern)) {
[10:18:35.973]                         computeRestarts <- base::computeRestarts
[10:18:35.973]                         grepl <- base::grepl
[10:18:35.973]                         restarts <- computeRestarts(cond)
[10:18:35.973]                         for (restart in restarts) {
[10:18:35.973]                           name <- restart$name
[10:18:35.973]                           if (is.null(name)) 
[10:18:35.973]                             next
[10:18:35.973]                           if (!grepl(pattern, name)) 
[10:18:35.973]                             next
[10:18:35.973]                           invokeRestart(restart)
[10:18:35.973]                           muffled <- TRUE
[10:18:35.973]                           break
[10:18:35.973]                         }
[10:18:35.973]                       }
[10:18:35.973]                     }
[10:18:35.973]                     invisible(muffled)
[10:18:35.973]                   }
[10:18:35.973]                   muffleCondition(cond)
[10:18:35.973]                 })
[10:18:35.973]             }))
[10:18:35.973]             future::FutureResult(value = ...future.value$value, 
[10:18:35.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.973]                   ...future.rng), globalenv = if (FALSE) 
[10:18:35.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:35.973]                     ...future.globalenv.names))
[10:18:35.973]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:35.973]         }, condition = base::local({
[10:18:35.973]             c <- base::c
[10:18:35.973]             inherits <- base::inherits
[10:18:35.973]             invokeRestart <- base::invokeRestart
[10:18:35.973]             length <- base::length
[10:18:35.973]             list <- base::list
[10:18:35.973]             seq.int <- base::seq.int
[10:18:35.973]             signalCondition <- base::signalCondition
[10:18:35.973]             sys.calls <- base::sys.calls
[10:18:35.973]             `[[` <- base::`[[`
[10:18:35.973]             `+` <- base::`+`
[10:18:35.973]             `<<-` <- base::`<<-`
[10:18:35.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:35.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:35.973]                   3L)]
[10:18:35.973]             }
[10:18:35.973]             function(cond) {
[10:18:35.973]                 is_error <- inherits(cond, "error")
[10:18:35.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:35.973]                   NULL)
[10:18:35.973]                 if (is_error) {
[10:18:35.973]                   sessionInformation <- function() {
[10:18:35.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:35.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:35.973]                       search = base::search(), system = base::Sys.info())
[10:18:35.973]                   }
[10:18:35.973]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:35.973]                     cond$call), session = sessionInformation(), 
[10:18:35.973]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:35.973]                   signalCondition(cond)
[10:18:35.973]                 }
[10:18:35.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:35.973]                 "immediateCondition"))) {
[10:18:35.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:35.973]                   ...future.conditions[[length(...future.conditions) + 
[10:18:35.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:35.973]                   if (TRUE && !signal) {
[10:18:35.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.973]                     {
[10:18:35.973]                       inherits <- base::inherits
[10:18:35.973]                       invokeRestart <- base::invokeRestart
[10:18:35.973]                       is.null <- base::is.null
[10:18:35.973]                       muffled <- FALSE
[10:18:35.973]                       if (inherits(cond, "message")) {
[10:18:35.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.973]                         if (muffled) 
[10:18:35.973]                           invokeRestart("muffleMessage")
[10:18:35.973]                       }
[10:18:35.973]                       else if (inherits(cond, "warning")) {
[10:18:35.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.973]                         if (muffled) 
[10:18:35.973]                           invokeRestart("muffleWarning")
[10:18:35.973]                       }
[10:18:35.973]                       else if (inherits(cond, "condition")) {
[10:18:35.973]                         if (!is.null(pattern)) {
[10:18:35.973]                           computeRestarts <- base::computeRestarts
[10:18:35.973]                           grepl <- base::grepl
[10:18:35.973]                           restarts <- computeRestarts(cond)
[10:18:35.973]                           for (restart in restarts) {
[10:18:35.973]                             name <- restart$name
[10:18:35.973]                             if (is.null(name)) 
[10:18:35.973]                               next
[10:18:35.973]                             if (!grepl(pattern, name)) 
[10:18:35.973]                               next
[10:18:35.973]                             invokeRestart(restart)
[10:18:35.973]                             muffled <- TRUE
[10:18:35.973]                             break
[10:18:35.973]                           }
[10:18:35.973]                         }
[10:18:35.973]                       }
[10:18:35.973]                       invisible(muffled)
[10:18:35.973]                     }
[10:18:35.973]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.973]                   }
[10:18:35.973]                 }
[10:18:35.973]                 else {
[10:18:35.973]                   if (TRUE) {
[10:18:35.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:35.973]                     {
[10:18:35.973]                       inherits <- base::inherits
[10:18:35.973]                       invokeRestart <- base::invokeRestart
[10:18:35.973]                       is.null <- base::is.null
[10:18:35.973]                       muffled <- FALSE
[10:18:35.973]                       if (inherits(cond, "message")) {
[10:18:35.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:35.973]                         if (muffled) 
[10:18:35.973]                           invokeRestart("muffleMessage")
[10:18:35.973]                       }
[10:18:35.973]                       else if (inherits(cond, "warning")) {
[10:18:35.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:35.973]                         if (muffled) 
[10:18:35.973]                           invokeRestart("muffleWarning")
[10:18:35.973]                       }
[10:18:35.973]                       else if (inherits(cond, "condition")) {
[10:18:35.973]                         if (!is.null(pattern)) {
[10:18:35.973]                           computeRestarts <- base::computeRestarts
[10:18:35.973]                           grepl <- base::grepl
[10:18:35.973]                           restarts <- computeRestarts(cond)
[10:18:35.973]                           for (restart in restarts) {
[10:18:35.973]                             name <- restart$name
[10:18:35.973]                             if (is.null(name)) 
[10:18:35.973]                               next
[10:18:35.973]                             if (!grepl(pattern, name)) 
[10:18:35.973]                               next
[10:18:35.973]                             invokeRestart(restart)
[10:18:35.973]                             muffled <- TRUE
[10:18:35.973]                             break
[10:18:35.973]                           }
[10:18:35.973]                         }
[10:18:35.973]                       }
[10:18:35.973]                       invisible(muffled)
[10:18:35.973]                     }
[10:18:35.973]                     muffleCondition(cond, pattern = "^muffle")
[10:18:35.973]                   }
[10:18:35.973]                 }
[10:18:35.973]             }
[10:18:35.973]         }))
[10:18:35.973]     }, error = function(ex) {
[10:18:35.973]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:35.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:35.973]                 ...future.rng), started = ...future.startTime, 
[10:18:35.973]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:35.973]             version = "1.8"), class = "FutureResult")
[10:18:35.973]     }, finally = {
[10:18:35.973]         if (!identical(...future.workdir, getwd())) 
[10:18:35.973]             setwd(...future.workdir)
[10:18:35.973]         {
[10:18:35.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:35.973]                 ...future.oldOptions$nwarnings <- NULL
[10:18:35.973]             }
[10:18:35.973]             base::options(...future.oldOptions)
[10:18:35.973]             if (.Platform$OS.type == "windows") {
[10:18:35.973]                 old_names <- names(...future.oldEnvVars)
[10:18:35.973]                 envs <- base::Sys.getenv()
[10:18:35.973]                 names <- names(envs)
[10:18:35.973]                 common <- intersect(names, old_names)
[10:18:35.973]                 added <- setdiff(names, old_names)
[10:18:35.973]                 removed <- setdiff(old_names, names)
[10:18:35.973]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:35.973]                   envs[common]]
[10:18:35.973]                 NAMES <- toupper(changed)
[10:18:35.973]                 args <- list()
[10:18:35.973]                 for (kk in seq_along(NAMES)) {
[10:18:35.973]                   name <- changed[[kk]]
[10:18:35.973]                   NAME <- NAMES[[kk]]
[10:18:35.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.973]                     next
[10:18:35.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.973]                 }
[10:18:35.973]                 NAMES <- toupper(added)
[10:18:35.973]                 for (kk in seq_along(NAMES)) {
[10:18:35.973]                   name <- added[[kk]]
[10:18:35.973]                   NAME <- NAMES[[kk]]
[10:18:35.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.973]                     next
[10:18:35.973]                   args[[name]] <- ""
[10:18:35.973]                 }
[10:18:35.973]                 NAMES <- toupper(removed)
[10:18:35.973]                 for (kk in seq_along(NAMES)) {
[10:18:35.973]                   name <- removed[[kk]]
[10:18:35.973]                   NAME <- NAMES[[kk]]
[10:18:35.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:35.973]                     next
[10:18:35.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:35.973]                 }
[10:18:35.973]                 if (length(args) > 0) 
[10:18:35.973]                   base::do.call(base::Sys.setenv, args = args)
[10:18:35.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:35.973]             }
[10:18:35.973]             else {
[10:18:35.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:35.973]             }
[10:18:35.973]             {
[10:18:35.973]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:35.973]                   0L) {
[10:18:35.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:35.973]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:35.973]                   base::options(opts)
[10:18:35.973]                 }
[10:18:35.973]                 {
[10:18:35.973]                   {
[10:18:35.973]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:35.973]                     NULL
[10:18:35.973]                   }
[10:18:35.973]                   options(future.plan = NULL)
[10:18:35.973]                   if (is.na(NA_character_)) 
[10:18:35.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:35.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:35.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:35.973]                     .init = FALSE)
[10:18:35.973]                 }
[10:18:35.973]             }
[10:18:35.973]         }
[10:18:35.973]     })
[10:18:35.973]     if (TRUE) {
[10:18:35.973]         base::sink(type = "output", split = FALSE)
[10:18:35.973]         if (TRUE) {
[10:18:35.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:35.973]         }
[10:18:35.973]         else {
[10:18:35.973]             ...future.result["stdout"] <- base::list(NULL)
[10:18:35.973]         }
[10:18:35.973]         base::close(...future.stdout)
[10:18:35.973]         ...future.stdout <- NULL
[10:18:35.973]     }
[10:18:35.973]     ...future.result$conditions <- ...future.conditions
[10:18:35.973]     ...future.result$finished <- base::Sys.time()
[10:18:35.973]     ...future.result
[10:18:35.973] }
[10:18:35.976] Exporting 5 global objects (1.14 KiB) to cluster node #2 ...
[10:18:35.977] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:18:35.977] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:18:35.977] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:35.977] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:35.978] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ...
[10:18:35.978] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ... DONE
[10:18:35.978] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:35.978] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:35.978] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:35.979] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:35.979] Exporting 5 global objects (1.14 KiB) to cluster node #2 ... DONE
[10:18:35.979] MultisessionFuture started
[10:18:35.980] - Launch lazy future ... done
[10:18:35.980] run() for ‘MultisessionFuture’ ... done
[10:18:35.980] Created future:
[10:18:35.980] MultisessionFuture:
[10:18:35.980] Label: ‘future_eapply-2’
[10:18:35.980] Expression:
[10:18:35.980] {
[10:18:35.980]     do.call(function(...) {
[10:18:35.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:35.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:35.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:35.980]             on.exit(options(oopts), add = TRUE)
[10:18:35.980]         }
[10:18:35.980]         {
[10:18:35.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:35.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:35.980]                 ...future.FUN(...future.X_jj, ...)
[10:18:35.980]             })
[10:18:35.980]         }
[10:18:35.980]     }, args = future.call.arguments)
[10:18:35.980] }
[10:18:35.980] Lazy evaluation: FALSE
[10:18:35.980] Asynchronous evaluation: TRUE
[10:18:35.980] Local evaluation: TRUE
[10:18:35.980] Environment: R_GlobalEnv
[10:18:35.980] Capture standard output: TRUE
[10:18:35.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:35.980] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:35.980] Packages: 1 packages (‘stats’)
[10:18:35.980] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:35.980] Resolved: FALSE
[10:18:35.980] Value: <not collected>
[10:18:35.980] Conditions captured: <none>
[10:18:35.980] Early signaling: FALSE
[10:18:35.980] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:35.980] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:35.991] Chunk #2 of 2 ... DONE
[10:18:35.992] Launching 2 futures (chunks) ... DONE
[10:18:35.992] Resolving 2 futures (chunks) ...
[10:18:35.992] resolve() on list ...
[10:18:35.992]  recursive: 0
[10:18:35.998]  length: 2
[10:18:35.998] 
[10:18:35.999] receiveMessageFromWorker() for ClusterFuture ...
[10:18:35.999] - Validating connection of MultisessionFuture
[10:18:35.999] - received message: FutureResult
[10:18:35.999] - Received FutureResult
[10:18:35.999] - Erased future from FutureRegistry
[10:18:35.999] result() for ClusterFuture ...
[10:18:35.999] - result already collected: FutureResult
[10:18:35.999] result() for ClusterFuture ... done
[10:18:35.999] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:36.000] Future #1
[10:18:36.000] result() for ClusterFuture ...
[10:18:36.000] - result already collected: FutureResult
[10:18:36.000] result() for ClusterFuture ... done
[10:18:36.000] result() for ClusterFuture ...
[10:18:36.000] - result already collected: FutureResult
[10:18:36.000] result() for ClusterFuture ... done
[10:18:36.000] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:36.000] - nx: 2
[10:18:36.000] - relay: TRUE
[10:18:36.000] - stdout: TRUE
[10:18:36.000] - signal: TRUE
[10:18:36.001] - resignal: FALSE
[10:18:36.001] - force: TRUE
[10:18:36.001] - relayed: [n=2] FALSE, FALSE
[10:18:36.001] - queued futures: [n=2] FALSE, FALSE
[10:18:36.001]  - until=1
[10:18:36.001]  - relaying element #1
[10:18:36.001] result() for ClusterFuture ...
[10:18:36.001] - result already collected: FutureResult
[10:18:36.001] result() for ClusterFuture ... done
[10:18:36.001] result() for ClusterFuture ...
[10:18:36.001] - result already collected: FutureResult
[10:18:36.001] result() for ClusterFuture ... done
[10:18:36.002] result() for ClusterFuture ...
[10:18:36.002] - result already collected: FutureResult
[10:18:36.002] result() for ClusterFuture ... done
[10:18:36.002] result() for ClusterFuture ...
[10:18:36.002] - result already collected: FutureResult
[10:18:36.002] result() for ClusterFuture ... done
[10:18:36.002] - relayed: [n=2] TRUE, FALSE
[10:18:36.002] - queued futures: [n=2] TRUE, FALSE
[10:18:36.002] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:36.002]  length: 1 (resolved future 1)
[10:18:36.023] receiveMessageFromWorker() for ClusterFuture ...
[10:18:36.024] - Validating connection of MultisessionFuture
[10:18:36.024] - received message: FutureResult
[10:18:36.024] - Received FutureResult
[10:18:36.024] - Erased future from FutureRegistry
[10:18:36.024] result() for ClusterFuture ...
[10:18:36.024] - result already collected: FutureResult
[10:18:36.024] result() for ClusterFuture ... done
[10:18:36.024] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:36.024] Future #2
[10:18:36.025] result() for ClusterFuture ...
[10:18:36.025] - result already collected: FutureResult
[10:18:36.025] result() for ClusterFuture ... done
[10:18:36.025] result() for ClusterFuture ...
[10:18:36.025] - result already collected: FutureResult
[10:18:36.025] result() for ClusterFuture ... done
[10:18:36.025] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:36.025] - nx: 2
[10:18:36.025] - relay: TRUE
[10:18:36.025] - stdout: TRUE
[10:18:36.025] - signal: TRUE
[10:18:36.025] - resignal: FALSE
[10:18:36.026] - force: TRUE
[10:18:36.026] - relayed: [n=2] TRUE, FALSE
[10:18:36.026] - queued futures: [n=2] TRUE, FALSE
[10:18:36.026]  - until=2
[10:18:36.026]  - relaying element #2
[10:18:36.026] result() for ClusterFuture ...
[10:18:36.026] - result already collected: FutureResult
[10:18:36.026] result() for ClusterFuture ... done
[10:18:36.026] result() for ClusterFuture ...
[10:18:36.026] - result already collected: FutureResult
[10:18:36.026] result() for ClusterFuture ... done
[10:18:36.027] result() for ClusterFuture ...
[10:18:36.027] - result already collected: FutureResult
[10:18:36.027] result() for ClusterFuture ... done
[10:18:36.027] result() for ClusterFuture ...
[10:18:36.027] - result already collected: FutureResult
[10:18:36.027] result() for ClusterFuture ... done
[10:18:36.027] - relayed: [n=2] TRUE, TRUE
[10:18:36.027] - queued futures: [n=2] TRUE, TRUE
[10:18:36.027] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:36.027]  length: 0 (resolved future 2)
[10:18:36.027] Relaying remaining futures
[10:18:36.027] signalConditionsASAP(NULL, pos=0) ...
[10:18:36.028] - nx: 2
[10:18:36.028] - relay: TRUE
[10:18:36.028] - stdout: TRUE
[10:18:36.028] - signal: TRUE
[10:18:36.028] - resignal: FALSE
[10:18:36.028] - force: TRUE
[10:18:36.028] - relayed: [n=2] TRUE, TRUE
[10:18:36.028] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:36.028] - relayed: [n=2] TRUE, TRUE
[10:18:36.028] - queued futures: [n=2] TRUE, TRUE
[10:18:36.028] signalConditionsASAP(NULL, pos=0) ... done
[10:18:36.028] resolve() on list ... DONE
[10:18:36.029] result() for ClusterFuture ...
[10:18:36.029] - result already collected: FutureResult
[10:18:36.029] result() for ClusterFuture ... done
[10:18:36.029] result() for ClusterFuture ...
[10:18:36.029] - result already collected: FutureResult
[10:18:36.029] result() for ClusterFuture ... done
[10:18:36.029] result() for ClusterFuture ...
[10:18:36.029] - result already collected: FutureResult
[10:18:36.029] result() for ClusterFuture ... done
[10:18:36.029] result() for ClusterFuture ...
[10:18:36.029] - result already collected: FutureResult
[10:18:36.029] result() for ClusterFuture ... done
[10:18:36.030]  - Number of value chunks collected: 2
[10:18:36.030] Resolving 2 futures (chunks) ... DONE
[10:18:36.030] Reducing values from 2 chunks ...
[10:18:36.030]  - Number of values collected after concatenation: 3
[10:18:36.030]  - Number of values expected: 3
[10:18:36.030] Reducing values from 2 chunks ... DONE
[10:18:36.030] future_lapply() ... DONE
[10:18:36.030] future_lapply() ...
[10:18:36.032] Number of chunks: 2
[10:18:36.032] getGlobalsAndPackagesXApply() ...
[10:18:36.033]  - future.globals: TRUE
[10:18:36.033] getGlobalsAndPackages() ...
[10:18:36.033] Searching for globals...
[10:18:36.034] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:36.034] Searching for globals ... DONE
[10:18:36.034] Resolving globals: FALSE
[10:18:36.034] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:36.035] The total size of the 1 globals exported for future expression (‘FUN()’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:36.035] - globals: [1] ‘FUN’
[10:18:36.035] - packages: [1] ‘stats’
[10:18:36.035] getGlobalsAndPackages() ... DONE
[10:18:36.035]  - globals found/used: [n=1] ‘FUN’
[10:18:36.035]  - needed namespaces: [n=1] ‘stats’
[10:18:36.036] Finding globals ... DONE
[10:18:36.036]  - use_args: TRUE
[10:18:36.036]  - Getting '...' globals ...
[10:18:36.036] resolve() on list ...
[10:18:36.036]  recursive: 0
[10:18:36.036]  length: 1
[10:18:36.036]  elements: ‘...’
[10:18:36.036]  length: 0 (resolved future 1)
[10:18:36.036] resolve() on list ... DONE
[10:18:36.037]    - '...' content: [n=0] 
[10:18:36.037] List of 1
[10:18:36.037]  $ ...: list()
[10:18:36.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:36.037]  - attr(*, "where")=List of 1
[10:18:36.037]   ..$ ...:<environment: 0x56033cb00ed8> 
[10:18:36.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:36.037]  - attr(*, "resolved")= logi TRUE
[10:18:36.037]  - attr(*, "total_size")= num NA
[10:18:36.039]  - Getting '...' globals ... DONE
[10:18:36.039] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:36.039] List of 2
[10:18:36.039]  $ ...future.FUN:function (x, ...)  
[10:18:36.039]  $ ...          : list()
[10:18:36.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:36.039]  - attr(*, "where")=List of 2
[10:18:36.039]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:36.039]   ..$ ...          :<environment: 0x56033cb00ed8> 
[10:18:36.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:36.039]  - attr(*, "resolved")= logi FALSE
[10:18:36.039]  - attr(*, "total_size")= num 5437
[10:18:36.042] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:36.042] getGlobalsAndPackagesXApply() ... DONE
[10:18:36.042] Number of futures (= number of chunks): 2
[10:18:36.043] Launching 2 futures (chunks) ...
[10:18:36.043] Chunk #1 of 2 ...
[10:18:36.043]  - Finding globals in 'X' for chunk #1 ...
[10:18:36.043] getGlobalsAndPackages() ...
[10:18:36.043] Searching for globals...
[10:18:36.043] 
[10:18:36.043] Searching for globals ... DONE
[10:18:36.043] - globals: [0] <none>
[10:18:36.043] getGlobalsAndPackages() ... DONE
[10:18:36.044]    + additional globals found: [n=0] 
[10:18:36.044]    + additional namespaces needed: [n=0] 
[10:18:36.044]  - Finding globals in 'X' for chunk #1 ... DONE
[10:18:36.044]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:36.044]  - seeds: <none>
[10:18:36.044]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:36.044] getGlobalsAndPackages() ...
[10:18:36.044] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:36.044] Resolving globals: FALSE
[10:18:36.044] Tweak future expression to call with '...' arguments ...
[10:18:36.044] {
[10:18:36.044]     do.call(function(...) {
[10:18:36.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:36.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:36.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:36.044]             on.exit(options(oopts), add = TRUE)
[10:18:36.044]         }
[10:18:36.044]         {
[10:18:36.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:36.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:36.044]                 ...future.FUN(...future.X_jj, ...)
[10:18:36.044]             })
[10:18:36.044]         }
[10:18:36.044]     }, args = future.call.arguments)
[10:18:36.044] }
[10:18:36.045] Tweak future expression to call with '...' arguments ... DONE
[10:18:36.045] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:36.045] - packages: [1] ‘stats’
[10:18:36.045] getGlobalsAndPackages() ... DONE
[10:18:36.046] run() for ‘Future’ ...
[10:18:36.046] - state: ‘created’
[10:18:36.046] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:36.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:36.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:36.061]   - Field: ‘node’
[10:18:36.061]   - Field: ‘label’
[10:18:36.061]   - Field: ‘local’
[10:18:36.062]   - Field: ‘owner’
[10:18:36.062]   - Field: ‘envir’
[10:18:36.062]   - Field: ‘workers’
[10:18:36.062]   - Field: ‘packages’
[10:18:36.062]   - Field: ‘gc’
[10:18:36.062]   - Field: ‘conditions’
[10:18:36.062]   - Field: ‘persistent’
[10:18:36.062]   - Field: ‘expr’
[10:18:36.062]   - Field: ‘uuid’
[10:18:36.062]   - Field: ‘seed’
[10:18:36.062]   - Field: ‘version’
[10:18:36.063]   - Field: ‘result’
[10:18:36.063]   - Field: ‘asynchronous’
[10:18:36.063]   - Field: ‘calls’
[10:18:36.063]   - Field: ‘globals’
[10:18:36.063]   - Field: ‘stdout’
[10:18:36.063]   - Field: ‘earlySignal’
[10:18:36.063]   - Field: ‘lazy’
[10:18:36.063]   - Field: ‘state’
[10:18:36.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:36.063] - Launch lazy future ...
[10:18:36.064] Packages needed by the future expression (n = 1): ‘stats’
[10:18:36.064] Packages needed by future strategies (n = 0): <none>
[10:18:36.064] {
[10:18:36.064]     {
[10:18:36.064]         {
[10:18:36.064]             ...future.startTime <- base::Sys.time()
[10:18:36.064]             {
[10:18:36.064]                 {
[10:18:36.064]                   {
[10:18:36.064]                     {
[10:18:36.064]                       {
[10:18:36.064]                         base::local({
[10:18:36.064]                           has_future <- base::requireNamespace("future", 
[10:18:36.064]                             quietly = TRUE)
[10:18:36.064]                           if (has_future) {
[10:18:36.064]                             ns <- base::getNamespace("future")
[10:18:36.064]                             version <- ns[[".package"]][["version"]]
[10:18:36.064]                             if (is.null(version)) 
[10:18:36.064]                               version <- utils::packageVersion("future")
[10:18:36.064]                           }
[10:18:36.064]                           else {
[10:18:36.064]                             version <- NULL
[10:18:36.064]                           }
[10:18:36.064]                           if (!has_future || version < "1.8.0") {
[10:18:36.064]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:36.064]                               "", base::R.version$version.string), 
[10:18:36.064]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:36.064]                                 base::R.version$platform, 8 * 
[10:18:36.064]                                   base::.Machine$sizeof.pointer), 
[10:18:36.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:36.064]                                 "release", "version")], collapse = " "), 
[10:18:36.064]                               hostname = base::Sys.info()[["nodename"]])
[10:18:36.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:36.064]                               info)
[10:18:36.064]                             info <- base::paste(info, collapse = "; ")
[10:18:36.064]                             if (!has_future) {
[10:18:36.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:36.064]                                 info)
[10:18:36.064]                             }
[10:18:36.064]                             else {
[10:18:36.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:36.064]                                 info, version)
[10:18:36.064]                             }
[10:18:36.064]                             base::stop(msg)
[10:18:36.064]                           }
[10:18:36.064]                         })
[10:18:36.064]                       }
[10:18:36.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:36.064]                       base::options(mc.cores = 1L)
[10:18:36.064]                     }
[10:18:36.064]                     base::local({
[10:18:36.064]                       for (pkg in "stats") {
[10:18:36.064]                         base::loadNamespace(pkg)
[10:18:36.064]                         base::library(pkg, character.only = TRUE)
[10:18:36.064]                       }
[10:18:36.064]                     })
[10:18:36.064]                   }
[10:18:36.064]                   ...future.strategy.old <- future::plan("list")
[10:18:36.064]                   options(future.plan = NULL)
[10:18:36.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:36.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:36.064]                 }
[10:18:36.064]                 ...future.workdir <- getwd()
[10:18:36.064]             }
[10:18:36.064]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:36.064]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:36.064]         }
[10:18:36.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:36.064]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:36.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:36.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:36.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:36.064]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:36.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:36.064]             base::names(...future.oldOptions))
[10:18:36.064]     }
[10:18:36.064]     if (FALSE) {
[10:18:36.064]     }
[10:18:36.064]     else {
[10:18:36.064]         if (TRUE) {
[10:18:36.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:36.064]                 open = "w")
[10:18:36.064]         }
[10:18:36.064]         else {
[10:18:36.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:36.064]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:36.064]         }
[10:18:36.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:36.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:36.064]             base::sink(type = "output", split = FALSE)
[10:18:36.064]             base::close(...future.stdout)
[10:18:36.064]         }, add = TRUE)
[10:18:36.064]     }
[10:18:36.064]     ...future.frame <- base::sys.nframe()
[10:18:36.064]     ...future.conditions <- base::list()
[10:18:36.064]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:36.064]     if (FALSE) {
[10:18:36.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:36.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:36.064]     }
[10:18:36.064]     ...future.result <- base::tryCatch({
[10:18:36.064]         base::withCallingHandlers({
[10:18:36.064]             ...future.value <- base::withVisible(base::local({
[10:18:36.064]                 ...future.makeSendCondition <- base::local({
[10:18:36.064]                   sendCondition <- NULL
[10:18:36.064]                   function(frame = 1L) {
[10:18:36.064]                     if (is.function(sendCondition)) 
[10:18:36.064]                       return(sendCondition)
[10:18:36.064]                     ns <- getNamespace("parallel")
[10:18:36.064]                     if (exists("sendData", mode = "function", 
[10:18:36.064]                       envir = ns)) {
[10:18:36.064]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:36.064]                         envir = ns)
[10:18:36.064]                       envir <- sys.frame(frame)
[10:18:36.064]                       master <- NULL
[10:18:36.064]                       while (!identical(envir, .GlobalEnv) && 
[10:18:36.064]                         !identical(envir, emptyenv())) {
[10:18:36.064]                         if (exists("master", mode = "list", envir = envir, 
[10:18:36.064]                           inherits = FALSE)) {
[10:18:36.064]                           master <- get("master", mode = "list", 
[10:18:36.064]                             envir = envir, inherits = FALSE)
[10:18:36.064]                           if (inherits(master, c("SOCKnode", 
[10:18:36.064]                             "SOCK0node"))) {
[10:18:36.064]                             sendCondition <<- function(cond) {
[10:18:36.064]                               data <- list(type = "VALUE", value = cond, 
[10:18:36.064]                                 success = TRUE)
[10:18:36.064]                               parallel_sendData(master, data)
[10:18:36.064]                             }
[10:18:36.064]                             return(sendCondition)
[10:18:36.064]                           }
[10:18:36.064]                         }
[10:18:36.064]                         frame <- frame + 1L
[10:18:36.064]                         envir <- sys.frame(frame)
[10:18:36.064]                       }
[10:18:36.064]                     }
[10:18:36.064]                     sendCondition <<- function(cond) NULL
[10:18:36.064]                   }
[10:18:36.064]                 })
[10:18:36.064]                 withCallingHandlers({
[10:18:36.064]                   {
[10:18:36.064]                     do.call(function(...) {
[10:18:36.064]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:36.064]                       if (!identical(...future.globals.maxSize.org, 
[10:18:36.064]                         ...future.globals.maxSize)) {
[10:18:36.064]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:36.064]                         on.exit(options(oopts), add = TRUE)
[10:18:36.064]                       }
[10:18:36.064]                       {
[10:18:36.064]                         lapply(seq_along(...future.elements_ii), 
[10:18:36.064]                           FUN = function(jj) {
[10:18:36.064]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:36.064]                             ...future.FUN(...future.X_jj, ...)
[10:18:36.064]                           })
[10:18:36.064]                       }
[10:18:36.064]                     }, args = future.call.arguments)
[10:18:36.064]                   }
[10:18:36.064]                 }, immediateCondition = function(cond) {
[10:18:36.064]                   sendCondition <- ...future.makeSendCondition()
[10:18:36.064]                   sendCondition(cond)
[10:18:36.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:36.064]                   {
[10:18:36.064]                     inherits <- base::inherits
[10:18:36.064]                     invokeRestart <- base::invokeRestart
[10:18:36.064]                     is.null <- base::is.null
[10:18:36.064]                     muffled <- FALSE
[10:18:36.064]                     if (inherits(cond, "message")) {
[10:18:36.064]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:36.064]                       if (muffled) 
[10:18:36.064]                         invokeRestart("muffleMessage")
[10:18:36.064]                     }
[10:18:36.064]                     else if (inherits(cond, "warning")) {
[10:18:36.064]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:36.064]                       if (muffled) 
[10:18:36.064]                         invokeRestart("muffleWarning")
[10:18:36.064]                     }
[10:18:36.064]                     else if (inherits(cond, "condition")) {
[10:18:36.064]                       if (!is.null(pattern)) {
[10:18:36.064]                         computeRestarts <- base::computeRestarts
[10:18:36.064]                         grepl <- base::grepl
[10:18:36.064]                         restarts <- computeRestarts(cond)
[10:18:36.064]                         for (restart in restarts) {
[10:18:36.064]                           name <- restart$name
[10:18:36.064]                           if (is.null(name)) 
[10:18:36.064]                             next
[10:18:36.064]                           if (!grepl(pattern, name)) 
[10:18:36.064]                             next
[10:18:36.064]                           invokeRestart(restart)
[10:18:36.064]                           muffled <- TRUE
[10:18:36.064]                           break
[10:18:36.064]                         }
[10:18:36.064]                       }
[10:18:36.064]                     }
[10:18:36.064]                     invisible(muffled)
[10:18:36.064]                   }
[10:18:36.064]                   muffleCondition(cond)
[10:18:36.064]                 })
[10:18:36.064]             }))
[10:18:36.064]             future::FutureResult(value = ...future.value$value, 
[10:18:36.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:36.064]                   ...future.rng), globalenv = if (FALSE) 
[10:18:36.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:36.064]                     ...future.globalenv.names))
[10:18:36.064]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:36.064]         }, condition = base::local({
[10:18:36.064]             c <- base::c
[10:18:36.064]             inherits <- base::inherits
[10:18:36.064]             invokeRestart <- base::invokeRestart
[10:18:36.064]             length <- base::length
[10:18:36.064]             list <- base::list
[10:18:36.064]             seq.int <- base::seq.int
[10:18:36.064]             signalCondition <- base::signalCondition
[10:18:36.064]             sys.calls <- base::sys.calls
[10:18:36.064]             `[[` <- base::`[[`
[10:18:36.064]             `+` <- base::`+`
[10:18:36.064]             `<<-` <- base::`<<-`
[10:18:36.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:36.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:36.064]                   3L)]
[10:18:36.064]             }
[10:18:36.064]             function(cond) {
[10:18:36.064]                 is_error <- inherits(cond, "error")
[10:18:36.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:36.064]                   NULL)
[10:18:36.064]                 if (is_error) {
[10:18:36.064]                   sessionInformation <- function() {
[10:18:36.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:36.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:36.064]                       search = base::search(), system = base::Sys.info())
[10:18:36.064]                   }
[10:18:36.064]                   ...future.conditions[[length(...future.conditions) + 
[10:18:36.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:36.064]                     cond$call), session = sessionInformation(), 
[10:18:36.064]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:36.064]                   signalCondition(cond)
[10:18:36.064]                 }
[10:18:36.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:36.064]                 "immediateCondition"))) {
[10:18:36.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:36.064]                   ...future.conditions[[length(...future.conditions) + 
[10:18:36.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:36.064]                   if (TRUE && !signal) {
[10:18:36.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:36.064]                     {
[10:18:36.064]                       inherits <- base::inherits
[10:18:36.064]                       invokeRestart <- base::invokeRestart
[10:18:36.064]                       is.null <- base::is.null
[10:18:36.064]                       muffled <- FALSE
[10:18:36.064]                       if (inherits(cond, "message")) {
[10:18:36.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:36.064]                         if (muffled) 
[10:18:36.064]                           invokeRestart("muffleMessage")
[10:18:36.064]                       }
[10:18:36.064]                       else if (inherits(cond, "warning")) {
[10:18:36.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:36.064]                         if (muffled) 
[10:18:36.064]                           invokeRestart("muffleWarning")
[10:18:36.064]                       }
[10:18:36.064]                       else if (inherits(cond, "condition")) {
[10:18:36.064]                         if (!is.null(pattern)) {
[10:18:36.064]                           computeRestarts <- base::computeRestarts
[10:18:36.064]                           grepl <- base::grepl
[10:18:36.064]                           restarts <- computeRestarts(cond)
[10:18:36.064]                           for (restart in restarts) {
[10:18:36.064]                             name <- restart$name
[10:18:36.064]                             if (is.null(name)) 
[10:18:36.064]                               next
[10:18:36.064]                             if (!grepl(pattern, name)) 
[10:18:36.064]                               next
[10:18:36.064]                             invokeRestart(restart)
[10:18:36.064]                             muffled <- TRUE
[10:18:36.064]                             break
[10:18:36.064]                           }
[10:18:36.064]                         }
[10:18:36.064]                       }
[10:18:36.064]                       invisible(muffled)
[10:18:36.064]                     }
[10:18:36.064]                     muffleCondition(cond, pattern = "^muffle")
[10:18:36.064]                   }
[10:18:36.064]                 }
[10:18:36.064]                 else {
[10:18:36.064]                   if (TRUE) {
[10:18:36.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:36.064]                     {
[10:18:36.064]                       inherits <- base::inherits
[10:18:36.064]                       invokeRestart <- base::invokeRestart
[10:18:36.064]                       is.null <- base::is.null
[10:18:36.064]                       muffled <- FALSE
[10:18:36.064]                       if (inherits(cond, "message")) {
[10:18:36.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:36.064]                         if (muffled) 
[10:18:36.064]                           invokeRestart("muffleMessage")
[10:18:36.064]                       }
[10:18:36.064]                       else if (inherits(cond, "warning")) {
[10:18:36.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:36.064]                         if (muffled) 
[10:18:36.064]                           invokeRestart("muffleWarning")
[10:18:36.064]                       }
[10:18:36.064]                       else if (inherits(cond, "condition")) {
[10:18:36.064]                         if (!is.null(pattern)) {
[10:18:36.064]                           computeRestarts <- base::computeRestarts
[10:18:36.064]                           grepl <- base::grepl
[10:18:36.064]                           restarts <- computeRestarts(cond)
[10:18:36.064]                           for (restart in restarts) {
[10:18:36.064]                             name <- restart$name
[10:18:36.064]                             if (is.null(name)) 
[10:18:36.064]                               next
[10:18:36.064]                             if (!grepl(pattern, name)) 
[10:18:36.064]                               next
[10:18:36.064]                             invokeRestart(restart)
[10:18:36.064]                             muffled <- TRUE
[10:18:36.064]                             break
[10:18:36.064]                           }
[10:18:36.064]                         }
[10:18:36.064]                       }
[10:18:36.064]                       invisible(muffled)
[10:18:36.064]                     }
[10:18:36.064]                     muffleCondition(cond, pattern = "^muffle")
[10:18:36.064]                   }
[10:18:36.064]                 }
[10:18:36.064]             }
[10:18:36.064]         }))
[10:18:36.064]     }, error = function(ex) {
[10:18:36.064]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:36.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:36.064]                 ...future.rng), started = ...future.startTime, 
[10:18:36.064]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:36.064]             version = "1.8"), class = "FutureResult")
[10:18:36.064]     }, finally = {
[10:18:36.064]         if (!identical(...future.workdir, getwd())) 
[10:18:36.064]             setwd(...future.workdir)
[10:18:36.064]         {
[10:18:36.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:36.064]                 ...future.oldOptions$nwarnings <- NULL
[10:18:36.064]             }
[10:18:36.064]             base::options(...future.oldOptions)
[10:18:36.064]             if (.Platform$OS.type == "windows") {
[10:18:36.064]                 old_names <- names(...future.oldEnvVars)
[10:18:36.064]                 envs <- base::Sys.getenv()
[10:18:36.064]                 names <- names(envs)
[10:18:36.064]                 common <- intersect(names, old_names)
[10:18:36.064]                 added <- setdiff(names, old_names)
[10:18:36.064]                 removed <- setdiff(old_names, names)
[10:18:36.064]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:36.064]                   envs[common]]
[10:18:36.064]                 NAMES <- toupper(changed)
[10:18:36.064]                 args <- list()
[10:18:36.064]                 for (kk in seq_along(NAMES)) {
[10:18:36.064]                   name <- changed[[kk]]
[10:18:36.064]                   NAME <- NAMES[[kk]]
[10:18:36.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:36.064]                     next
[10:18:36.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:36.064]                 }
[10:18:36.064]                 NAMES <- toupper(added)
[10:18:36.064]                 for (kk in seq_along(NAMES)) {
[10:18:36.064]                   name <- added[[kk]]
[10:18:36.064]                   NAME <- NAMES[[kk]]
[10:18:36.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:36.064]                     next
[10:18:36.064]                   args[[name]] <- ""
[10:18:36.064]                 }
[10:18:36.064]                 NAMES <- toupper(removed)
[10:18:36.064]                 for (kk in seq_along(NAMES)) {
[10:18:36.064]                   name <- removed[[kk]]
[10:18:36.064]                   NAME <- NAMES[[kk]]
[10:18:36.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:36.064]                     next
[10:18:36.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:36.064]                 }
[10:18:36.064]                 if (length(args) > 0) 
[10:18:36.064]                   base::do.call(base::Sys.setenv, args = args)
[10:18:36.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:36.064]             }
[10:18:36.064]             else {
[10:18:36.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:36.064]             }
[10:18:36.064]             {
[10:18:36.064]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:36.064]                   0L) {
[10:18:36.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:36.064]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:36.064]                   base::options(opts)
[10:18:36.064]                 }
[10:18:36.064]                 {
[10:18:36.064]                   {
[10:18:36.064]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:36.064]                     NULL
[10:18:36.064]                   }
[10:18:36.064]                   options(future.plan = NULL)
[10:18:36.064]                   if (is.na(NA_character_)) 
[10:18:36.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:36.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:36.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:36.064]                     .init = FALSE)
[10:18:36.064]                 }
[10:18:36.064]             }
[10:18:36.064]         }
[10:18:36.064]     })
[10:18:36.064]     if (TRUE) {
[10:18:36.064]         base::sink(type = "output", split = FALSE)
[10:18:36.064]         if (TRUE) {
[10:18:36.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:36.064]         }
[10:18:36.064]         else {
[10:18:36.064]             ...future.result["stdout"] <- base::list(NULL)
[10:18:36.064]         }
[10:18:36.064]         base::close(...future.stdout)
[10:18:36.064]         ...future.stdout <- NULL
[10:18:36.064]     }
[10:18:36.064]     ...future.result$conditions <- ...future.conditions
[10:18:36.064]     ...future.result$finished <- base::Sys.time()
[10:18:36.064]     ...future.result
[10:18:36.064] }
[10:18:36.067] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[10:18:36.067] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:18:36.068] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:18:36.068] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:36.068] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:36.068] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ...
[10:18:36.069] Exporting ‘...future.elements_ii’ (101 bytes) to cluster node #1 ... DONE
[10:18:36.069] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:36.069] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:36.069] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:18:36.069] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:18:36.070] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[10:18:36.070] MultisessionFuture started
[10:18:36.070] - Launch lazy future ... done
[10:18:36.070] run() for ‘MultisessionFuture’ ... done
[10:18:36.070] Created future:
[10:18:36.070] MultisessionFuture:
[10:18:36.070] Label: ‘future_eapply-1’
[10:18:36.070] Expression:
[10:18:36.070] {
[10:18:36.070]     do.call(function(...) {
[10:18:36.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:36.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:36.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:36.070]             on.exit(options(oopts), add = TRUE)
[10:18:36.070]         }
[10:18:36.070]         {
[10:18:36.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:36.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:36.070]                 ...future.FUN(...future.X_jj, ...)
[10:18:36.070]             })
[10:18:36.070]         }
[10:18:36.070]     }, args = future.call.arguments)
[10:18:36.070] }
[10:18:36.070] Lazy evaluation: FALSE
[10:18:36.070] Asynchronous evaluation: TRUE
[10:18:36.070] Local evaluation: TRUE
[10:18:36.070] Environment: R_GlobalEnv
[10:18:36.070] Capture standard output: TRUE
[10:18:36.070] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:36.070] Globals: 5 objects totaling 563 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 101 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:36.070] Packages: 1 packages (‘stats’)
[10:18:36.070] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:36.070] Resolved: FALSE
[10:18:36.070] Value: <not collected>
[10:18:36.070] Conditions captured: <none>
[10:18:36.070] Early signaling: FALSE
[10:18:36.070] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:36.070] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:36.082] Chunk #1 of 2 ... DONE
[10:18:36.082] Chunk #2 of 2 ...
[10:18:36.082]  - Finding globals in 'X' for chunk #2 ...
[10:18:36.082] getGlobalsAndPackages() ...
[10:18:36.082] Searching for globals...
[10:18:36.083] 
[10:18:36.083] Searching for globals ... DONE
[10:18:36.083] - globals: [0] <none>
[10:18:36.083] getGlobalsAndPackages() ... DONE
[10:18:36.083]    + additional globals found: [n=0] 
[10:18:36.083]    + additional namespaces needed: [n=0] 
[10:18:36.083]  - Finding globals in 'X' for chunk #2 ... DONE
[10:18:36.083]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:18:36.083]  - seeds: <none>
[10:18:36.083]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:36.084] getGlobalsAndPackages() ...
[10:18:36.084] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:36.084] Resolving globals: FALSE
[10:18:36.084] Tweak future expression to call with '...' arguments ...
[10:18:36.084] {
[10:18:36.084]     do.call(function(...) {
[10:18:36.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:36.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:36.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:36.084]             on.exit(options(oopts), add = TRUE)
[10:18:36.084]         }
[10:18:36.084]         {
[10:18:36.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:36.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:36.084]                 ...future.FUN(...future.X_jj, ...)
[10:18:36.084]             })
[10:18:36.084]         }
[10:18:36.084]     }, args = future.call.arguments)
[10:18:36.084] }
[10:18:36.084] Tweak future expression to call with '...' arguments ... DONE
[10:18:36.085] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:36.085] - packages: [1] ‘stats’
[10:18:36.085] getGlobalsAndPackages() ... DONE
[10:18:36.085] run() for ‘Future’ ...
[10:18:36.085] - state: ‘created’
[10:18:36.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:36.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:36.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:36.100]   - Field: ‘node’
[10:18:36.100]   - Field: ‘label’
[10:18:36.100]   - Field: ‘local’
[10:18:36.100]   - Field: ‘owner’
[10:18:36.100]   - Field: ‘envir’
[10:18:36.100]   - Field: ‘workers’
[10:18:36.100]   - Field: ‘packages’
[10:18:36.100]   - Field: ‘gc’
[10:18:36.100]   - Field: ‘conditions’
[10:18:36.100]   - Field: ‘persistent’
[10:18:36.100]   - Field: ‘expr’
[10:18:36.101]   - Field: ‘uuid’
[10:18:36.101]   - Field: ‘seed’
[10:18:36.101]   - Field: ‘version’
[10:18:36.101]   - Field: ‘result’
[10:18:36.101]   - Field: ‘asynchronous’
[10:18:36.101]   - Field: ‘calls’
[10:18:36.101]   - Field: ‘globals’
[10:18:36.101]   - Field: ‘stdout’
[10:18:36.101]   - Field: ‘earlySignal’
[10:18:36.101]   - Field: ‘lazy’
[10:18:36.101]   - Field: ‘state’
[10:18:36.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:36.102] - Launch lazy future ...
[10:18:36.102] Packages needed by the future expression (n = 1): ‘stats’
[10:18:36.102] Packages needed by future strategies (n = 0): <none>
[10:18:36.102] {
[10:18:36.102]     {
[10:18:36.102]         {
[10:18:36.102]             ...future.startTime <- base::Sys.time()
[10:18:36.102]             {
[10:18:36.102]                 {
[10:18:36.102]                   {
[10:18:36.102]                     {
[10:18:36.102]                       {
[10:18:36.102]                         base::local({
[10:18:36.102]                           has_future <- base::requireNamespace("future", 
[10:18:36.102]                             quietly = TRUE)
[10:18:36.102]                           if (has_future) {
[10:18:36.102]                             ns <- base::getNamespace("future")
[10:18:36.102]                             version <- ns[[".package"]][["version"]]
[10:18:36.102]                             if (is.null(version)) 
[10:18:36.102]                               version <- utils::packageVersion("future")
[10:18:36.102]                           }
[10:18:36.102]                           else {
[10:18:36.102]                             version <- NULL
[10:18:36.102]                           }
[10:18:36.102]                           if (!has_future || version < "1.8.0") {
[10:18:36.102]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:36.102]                               "", base::R.version$version.string), 
[10:18:36.102]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:36.102]                                 base::R.version$platform, 8 * 
[10:18:36.102]                                   base::.Machine$sizeof.pointer), 
[10:18:36.102]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:36.102]                                 "release", "version")], collapse = " "), 
[10:18:36.102]                               hostname = base::Sys.info()[["nodename"]])
[10:18:36.102]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:36.102]                               info)
[10:18:36.102]                             info <- base::paste(info, collapse = "; ")
[10:18:36.102]                             if (!has_future) {
[10:18:36.102]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:36.102]                                 info)
[10:18:36.102]                             }
[10:18:36.102]                             else {
[10:18:36.102]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:36.102]                                 info, version)
[10:18:36.102]                             }
[10:18:36.102]                             base::stop(msg)
[10:18:36.102]                           }
[10:18:36.102]                         })
[10:18:36.102]                       }
[10:18:36.102]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:36.102]                       base::options(mc.cores = 1L)
[10:18:36.102]                     }
[10:18:36.102]                     base::local({
[10:18:36.102]                       for (pkg in "stats") {
[10:18:36.102]                         base::loadNamespace(pkg)
[10:18:36.102]                         base::library(pkg, character.only = TRUE)
[10:18:36.102]                       }
[10:18:36.102]                     })
[10:18:36.102]                   }
[10:18:36.102]                   ...future.strategy.old <- future::plan("list")
[10:18:36.102]                   options(future.plan = NULL)
[10:18:36.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:36.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:36.102]                 }
[10:18:36.102]                 ...future.workdir <- getwd()
[10:18:36.102]             }
[10:18:36.102]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:36.102]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:36.102]         }
[10:18:36.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:36.102]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:18:36.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:36.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:36.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:36.102]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:36.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:36.102]             base::names(...future.oldOptions))
[10:18:36.102]     }
[10:18:36.102]     if (FALSE) {
[10:18:36.102]     }
[10:18:36.102]     else {
[10:18:36.102]         if (TRUE) {
[10:18:36.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:36.102]                 open = "w")
[10:18:36.102]         }
[10:18:36.102]         else {
[10:18:36.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:36.102]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:36.102]         }
[10:18:36.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:36.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:36.102]             base::sink(type = "output", split = FALSE)
[10:18:36.102]             base::close(...future.stdout)
[10:18:36.102]         }, add = TRUE)
[10:18:36.102]     }
[10:18:36.102]     ...future.frame <- base::sys.nframe()
[10:18:36.102]     ...future.conditions <- base::list()
[10:18:36.102]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:36.102]     if (FALSE) {
[10:18:36.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:36.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:36.102]     }
[10:18:36.102]     ...future.result <- base::tryCatch({
[10:18:36.102]         base::withCallingHandlers({
[10:18:36.102]             ...future.value <- base::withVisible(base::local({
[10:18:36.102]                 ...future.makeSendCondition <- base::local({
[10:18:36.102]                   sendCondition <- NULL
[10:18:36.102]                   function(frame = 1L) {
[10:18:36.102]                     if (is.function(sendCondition)) 
[10:18:36.102]                       return(sendCondition)
[10:18:36.102]                     ns <- getNamespace("parallel")
[10:18:36.102]                     if (exists("sendData", mode = "function", 
[10:18:36.102]                       envir = ns)) {
[10:18:36.102]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:36.102]                         envir = ns)
[10:18:36.102]                       envir <- sys.frame(frame)
[10:18:36.102]                       master <- NULL
[10:18:36.102]                       while (!identical(envir, .GlobalEnv) && 
[10:18:36.102]                         !identical(envir, emptyenv())) {
[10:18:36.102]                         if (exists("master", mode = "list", envir = envir, 
[10:18:36.102]                           inherits = FALSE)) {
[10:18:36.102]                           master <- get("master", mode = "list", 
[10:18:36.102]                             envir = envir, inherits = FALSE)
[10:18:36.102]                           if (inherits(master, c("SOCKnode", 
[10:18:36.102]                             "SOCK0node"))) {
[10:18:36.102]                             sendCondition <<- function(cond) {
[10:18:36.102]                               data <- list(type = "VALUE", value = cond, 
[10:18:36.102]                                 success = TRUE)
[10:18:36.102]                               parallel_sendData(master, data)
[10:18:36.102]                             }
[10:18:36.102]                             return(sendCondition)
[10:18:36.102]                           }
[10:18:36.102]                         }
[10:18:36.102]                         frame <- frame + 1L
[10:18:36.102]                         envir <- sys.frame(frame)
[10:18:36.102]                       }
[10:18:36.102]                     }
[10:18:36.102]                     sendCondition <<- function(cond) NULL
[10:18:36.102]                   }
[10:18:36.102]                 })
[10:18:36.102]                 withCallingHandlers({
[10:18:36.102]                   {
[10:18:36.102]                     do.call(function(...) {
[10:18:36.102]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:36.102]                       if (!identical(...future.globals.maxSize.org, 
[10:18:36.102]                         ...future.globals.maxSize)) {
[10:18:36.102]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:36.102]                         on.exit(options(oopts), add = TRUE)
[10:18:36.102]                       }
[10:18:36.102]                       {
[10:18:36.102]                         lapply(seq_along(...future.elements_ii), 
[10:18:36.102]                           FUN = function(jj) {
[10:18:36.102]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:36.102]                             ...future.FUN(...future.X_jj, ...)
[10:18:36.102]                           })
[10:18:36.102]                       }
[10:18:36.102]                     }, args = future.call.arguments)
[10:18:36.102]                   }
[10:18:36.102]                 }, immediateCondition = function(cond) {
[10:18:36.102]                   sendCondition <- ...future.makeSendCondition()
[10:18:36.102]                   sendCondition(cond)
[10:18:36.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:36.102]                   {
[10:18:36.102]                     inherits <- base::inherits
[10:18:36.102]                     invokeRestart <- base::invokeRestart
[10:18:36.102]                     is.null <- base::is.null
[10:18:36.102]                     muffled <- FALSE
[10:18:36.102]                     if (inherits(cond, "message")) {
[10:18:36.102]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:36.102]                       if (muffled) 
[10:18:36.102]                         invokeRestart("muffleMessage")
[10:18:36.102]                     }
[10:18:36.102]                     else if (inherits(cond, "warning")) {
[10:18:36.102]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:36.102]                       if (muffled) 
[10:18:36.102]                         invokeRestart("muffleWarning")
[10:18:36.102]                     }
[10:18:36.102]                     else if (inherits(cond, "condition")) {
[10:18:36.102]                       if (!is.null(pattern)) {
[10:18:36.102]                         computeRestarts <- base::computeRestarts
[10:18:36.102]                         grepl <- base::grepl
[10:18:36.102]                         restarts <- computeRestarts(cond)
[10:18:36.102]                         for (restart in restarts) {
[10:18:36.102]                           name <- restart$name
[10:18:36.102]                           if (is.null(name)) 
[10:18:36.102]                             next
[10:18:36.102]                           if (!grepl(pattern, name)) 
[10:18:36.102]                             next
[10:18:36.102]                           invokeRestart(restart)
[10:18:36.102]                           muffled <- TRUE
[10:18:36.102]                           break
[10:18:36.102]                         }
[10:18:36.102]                       }
[10:18:36.102]                     }
[10:18:36.102]                     invisible(muffled)
[10:18:36.102]                   }
[10:18:36.102]                   muffleCondition(cond)
[10:18:36.102]                 })
[10:18:36.102]             }))
[10:18:36.102]             future::FutureResult(value = ...future.value$value, 
[10:18:36.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:36.102]                   ...future.rng), globalenv = if (FALSE) 
[10:18:36.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:36.102]                     ...future.globalenv.names))
[10:18:36.102]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:36.102]         }, condition = base::local({
[10:18:36.102]             c <- base::c
[10:18:36.102]             inherits <- base::inherits
[10:18:36.102]             invokeRestart <- base::invokeRestart
[10:18:36.102]             length <- base::length
[10:18:36.102]             list <- base::list
[10:18:36.102]             seq.int <- base::seq.int
[10:18:36.102]             signalCondition <- base::signalCondition
[10:18:36.102]             sys.calls <- base::sys.calls
[10:18:36.102]             `[[` <- base::`[[`
[10:18:36.102]             `+` <- base::`+`
[10:18:36.102]             `<<-` <- base::`<<-`
[10:18:36.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:36.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:36.102]                   3L)]
[10:18:36.102]             }
[10:18:36.102]             function(cond) {
[10:18:36.102]                 is_error <- inherits(cond, "error")
[10:18:36.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:36.102]                   NULL)
[10:18:36.102]                 if (is_error) {
[10:18:36.102]                   sessionInformation <- function() {
[10:18:36.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:36.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:36.102]                       search = base::search(), system = base::Sys.info())
[10:18:36.102]                   }
[10:18:36.102]                   ...future.conditions[[length(...future.conditions) + 
[10:18:36.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:36.102]                     cond$call), session = sessionInformation(), 
[10:18:36.102]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:36.102]                   signalCondition(cond)
[10:18:36.102]                 }
[10:18:36.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:36.102]                 "immediateCondition"))) {
[10:18:36.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:36.102]                   ...future.conditions[[length(...future.conditions) + 
[10:18:36.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:36.102]                   if (TRUE && !signal) {
[10:18:36.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:36.102]                     {
[10:18:36.102]                       inherits <- base::inherits
[10:18:36.102]                       invokeRestart <- base::invokeRestart
[10:18:36.102]                       is.null <- base::is.null
[10:18:36.102]                       muffled <- FALSE
[10:18:36.102]                       if (inherits(cond, "message")) {
[10:18:36.102]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:36.102]                         if (muffled) 
[10:18:36.102]                           invokeRestart("muffleMessage")
[10:18:36.102]                       }
[10:18:36.102]                       else if (inherits(cond, "warning")) {
[10:18:36.102]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:36.102]                         if (muffled) 
[10:18:36.102]                           invokeRestart("muffleWarning")
[10:18:36.102]                       }
[10:18:36.102]                       else if (inherits(cond, "condition")) {
[10:18:36.102]                         if (!is.null(pattern)) {
[10:18:36.102]                           computeRestarts <- base::computeRestarts
[10:18:36.102]                           grepl <- base::grepl
[10:18:36.102]                           restarts <- computeRestarts(cond)
[10:18:36.102]                           for (restart in restarts) {
[10:18:36.102]                             name <- restart$name
[10:18:36.102]                             if (is.null(name)) 
[10:18:36.102]                               next
[10:18:36.102]                             if (!grepl(pattern, name)) 
[10:18:36.102]                               next
[10:18:36.102]                             invokeRestart(restart)
[10:18:36.102]                             muffled <- TRUE
[10:18:36.102]                             break
[10:18:36.102]                           }
[10:18:36.102]                         }
[10:18:36.102]                       }
[10:18:36.102]                       invisible(muffled)
[10:18:36.102]                     }
[10:18:36.102]                     muffleCondition(cond, pattern = "^muffle")
[10:18:36.102]                   }
[10:18:36.102]                 }
[10:18:36.102]                 else {
[10:18:36.102]                   if (TRUE) {
[10:18:36.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:36.102]                     {
[10:18:36.102]                       inherits <- base::inherits
[10:18:36.102]                       invokeRestart <- base::invokeRestart
[10:18:36.102]                       is.null <- base::is.null
[10:18:36.102]                       muffled <- FALSE
[10:18:36.102]                       if (inherits(cond, "message")) {
[10:18:36.102]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:36.102]                         if (muffled) 
[10:18:36.102]                           invokeRestart("muffleMessage")
[10:18:36.102]                       }
[10:18:36.102]                       else if (inherits(cond, "warning")) {
[10:18:36.102]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:36.102]                         if (muffled) 
[10:18:36.102]                           invokeRestart("muffleWarning")
[10:18:36.102]                       }
[10:18:36.102]                       else if (inherits(cond, "condition")) {
[10:18:36.102]                         if (!is.null(pattern)) {
[10:18:36.102]                           computeRestarts <- base::computeRestarts
[10:18:36.102]                           grepl <- base::grepl
[10:18:36.102]                           restarts <- computeRestarts(cond)
[10:18:36.102]                           for (restart in restarts) {
[10:18:36.102]                             name <- restart$name
[10:18:36.102]                             if (is.null(name)) 
[10:18:36.102]                               next
[10:18:36.102]                             if (!grepl(pattern, name)) 
[10:18:36.102]                               next
[10:18:36.102]                             invokeRestart(restart)
[10:18:36.102]                             muffled <- TRUE
[10:18:36.102]                             break
[10:18:36.102]                           }
[10:18:36.102]                         }
[10:18:36.102]                       }
[10:18:36.102]                       invisible(muffled)
[10:18:36.102]                     }
[10:18:36.102]                     muffleCondition(cond, pattern = "^muffle")
[10:18:36.102]                   }
[10:18:36.102]                 }
[10:18:36.102]             }
[10:18:36.102]         }))
[10:18:36.102]     }, error = function(ex) {
[10:18:36.102]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:36.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:36.102]                 ...future.rng), started = ...future.startTime, 
[10:18:36.102]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:36.102]             version = "1.8"), class = "FutureResult")
[10:18:36.102]     }, finally = {
[10:18:36.102]         if (!identical(...future.workdir, getwd())) 
[10:18:36.102]             setwd(...future.workdir)
[10:18:36.102]         {
[10:18:36.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:36.102]                 ...future.oldOptions$nwarnings <- NULL
[10:18:36.102]             }
[10:18:36.102]             base::options(...future.oldOptions)
[10:18:36.102]             if (.Platform$OS.type == "windows") {
[10:18:36.102]                 old_names <- names(...future.oldEnvVars)
[10:18:36.102]                 envs <- base::Sys.getenv()
[10:18:36.102]                 names <- names(envs)
[10:18:36.102]                 common <- intersect(names, old_names)
[10:18:36.102]                 added <- setdiff(names, old_names)
[10:18:36.102]                 removed <- setdiff(old_names, names)
[10:18:36.102]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:36.102]                   envs[common]]
[10:18:36.102]                 NAMES <- toupper(changed)
[10:18:36.102]                 args <- list()
[10:18:36.102]                 for (kk in seq_along(NAMES)) {
[10:18:36.102]                   name <- changed[[kk]]
[10:18:36.102]                   NAME <- NAMES[[kk]]
[10:18:36.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:36.102]                     next
[10:18:36.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:36.102]                 }
[10:18:36.102]                 NAMES <- toupper(added)
[10:18:36.102]                 for (kk in seq_along(NAMES)) {
[10:18:36.102]                   name <- added[[kk]]
[10:18:36.102]                   NAME <- NAMES[[kk]]
[10:18:36.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:36.102]                     next
[10:18:36.102]                   args[[name]] <- ""
[10:18:36.102]                 }
[10:18:36.102]                 NAMES <- toupper(removed)
[10:18:36.102]                 for (kk in seq_along(NAMES)) {
[10:18:36.102]                   name <- removed[[kk]]
[10:18:36.102]                   NAME <- NAMES[[kk]]
[10:18:36.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:36.102]                     next
[10:18:36.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:36.102]                 }
[10:18:36.102]                 if (length(args) > 0) 
[10:18:36.102]                   base::do.call(base::Sys.setenv, args = args)
[10:18:36.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:36.102]             }
[10:18:36.102]             else {
[10:18:36.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:36.102]             }
[10:18:36.102]             {
[10:18:36.102]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:36.102]                   0L) {
[10:18:36.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:36.102]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:36.102]                   base::options(opts)
[10:18:36.102]                 }
[10:18:36.102]                 {
[10:18:36.102]                   {
[10:18:36.102]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:36.102]                     NULL
[10:18:36.102]                   }
[10:18:36.102]                   options(future.plan = NULL)
[10:18:36.102]                   if (is.na(NA_character_)) 
[10:18:36.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:36.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:36.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:36.102]                     .init = FALSE)
[10:18:36.102]                 }
[10:18:36.102]             }
[10:18:36.102]         }
[10:18:36.102]     })
[10:18:36.102]     if (TRUE) {
[10:18:36.102]         base::sink(type = "output", split = FALSE)
[10:18:36.102]         if (TRUE) {
[10:18:36.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:36.102]         }
[10:18:36.102]         else {
[10:18:36.102]             ...future.result["stdout"] <- base::list(NULL)
[10:18:36.102]         }
[10:18:36.102]         base::close(...future.stdout)
[10:18:36.102]         ...future.stdout <- NULL
[10:18:36.102]     }
[10:18:36.102]     ...future.result$conditions <- ...future.conditions
[10:18:36.102]     ...future.result$finished <- base::Sys.time()
[10:18:36.102]     ...future.result
[10:18:36.102] }
[10:18:36.105] Exporting 5 global objects (1.14 KiB) to cluster node #2 ...
[10:18:36.105] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:18:36.106] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:18:36.106] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:36.106] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:36.106] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ...
[10:18:36.107] Exporting ‘...future.elements_ii’ (259 bytes) to cluster node #2 ... DONE
[10:18:36.107] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:36.107] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:36.107] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:18:36.108] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:18:36.108] Exporting 5 global objects (1.14 KiB) to cluster node #2 ... DONE
[10:18:36.108] MultisessionFuture started
[10:18:36.108] - Launch lazy future ... done
[10:18:36.109] run() for ‘MultisessionFuture’ ... done
[10:18:36.109] Created future:
[10:18:36.109] MultisessionFuture:
[10:18:36.109] Label: ‘future_eapply-2’
[10:18:36.109] Expression:
[10:18:36.109] {
[10:18:36.109]     do.call(function(...) {
[10:18:36.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:36.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:36.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:36.109]             on.exit(options(oopts), add = TRUE)
[10:18:36.109]         }
[10:18:36.109]         {
[10:18:36.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:36.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:36.109]                 ...future.FUN(...future.X_jj, ...)
[10:18:36.109]             })
[10:18:36.109]         }
[10:18:36.109]     }, args = future.call.arguments)
[10:18:36.109] }
[10:18:36.109] Lazy evaluation: FALSE
[10:18:36.109] Asynchronous evaluation: TRUE
[10:18:36.109] Local evaluation: TRUE
[10:18:36.109] Environment: R_GlobalEnv
[10:18:36.109] Capture standard output: TRUE
[10:18:36.109] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:36.109] Globals: 5 objects totaling 721 bytes (function ‘...future.FUN’ of 311 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 259 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:18:36.109] Packages: 1 packages (‘stats’)
[10:18:36.109] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:36.109] Resolved: FALSE
[10:18:36.109] Value: <not collected>
[10:18:36.109] Conditions captured: <none>
[10:18:36.109] Early signaling: FALSE
[10:18:36.109] Owner process: 47c05577-86e7-e1be-4e50-fe4b22f6c06f
[10:18:36.109] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:36.120] Chunk #2 of 2 ... DONE
[10:18:36.120] Launching 2 futures (chunks) ... DONE
[10:18:36.120] Resolving 2 futures (chunks) ...
[10:18:36.120] resolve() on list ...
[10:18:36.120]  recursive: 0
[10:18:36.121]  length: 2
[10:18:36.121] 
[10:18:36.121] receiveMessageFromWorker() for ClusterFuture ...
[10:18:36.121] - Validating connection of MultisessionFuture
[10:18:36.122] - received message: FutureResult
[10:18:36.122] - Received FutureResult
[10:18:36.122] - Erased future from FutureRegistry
[10:18:36.122] result() for ClusterFuture ...
[10:18:36.122] - result already collected: FutureResult
[10:18:36.122] result() for ClusterFuture ... done
[10:18:36.122] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:36.122] Future #1
[10:18:36.122] result() for ClusterFuture ...
[10:18:36.123] - result already collected: FutureResult
[10:18:36.123] result() for ClusterFuture ... done
[10:18:36.123] result() for ClusterFuture ...
[10:18:36.123] - result already collected: FutureResult
[10:18:36.123] result() for ClusterFuture ... done
[10:18:36.123] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:36.123] - nx: 2
[10:18:36.123] - relay: TRUE
[10:18:36.123] - stdout: TRUE
[10:18:36.123] - signal: TRUE
[10:18:36.123] - resignal: FALSE
[10:18:36.123] - force: TRUE
[10:18:36.124] - relayed: [n=2] FALSE, FALSE
[10:18:36.124] - queued futures: [n=2] FALSE, FALSE
[10:18:36.124]  - until=1
[10:18:36.124]  - relaying element #1
[10:18:36.124] result() for ClusterFuture ...
[10:18:36.124] - result already collected: FutureResult
[10:18:36.124] result() for ClusterFuture ... done
[10:18:36.124] result() for ClusterFuture ...
[10:18:36.124] - result already collected: FutureResult
[10:18:36.124] result() for ClusterFuture ... done
[10:18:36.124] result() for ClusterFuture ...
[10:18:36.124] - result already collected: FutureResult
[10:18:36.125] result() for ClusterFuture ... done
[10:18:36.125] result() for ClusterFuture ...
[10:18:36.125] - result already collected: FutureResult
[10:18:36.125] result() for ClusterFuture ... done
[10:18:36.125] - relayed: [n=2] TRUE, FALSE
[10:18:36.125] - queued futures: [n=2] TRUE, FALSE
[10:18:36.125] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:36.125]  length: 1 (resolved future 1)
[10:18:36.151] receiveMessageFromWorker() for ClusterFuture ...
[10:18:36.151] - Validating connection of MultisessionFuture
[10:18:36.151] - received message: FutureResult
[10:18:36.151] - Received FutureResult
[10:18:36.151] - Erased future from FutureRegistry
[10:18:36.151] result() for ClusterFuture ...
[10:18:36.152] - result already collected: FutureResult
[10:18:36.152] result() for ClusterFuture ... done
[10:18:36.152] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:36.152] Future #2
[10:18:36.152] result() for ClusterFuture ...
[10:18:36.152] - result already collected: FutureResult
[10:18:36.152] result() for ClusterFuture ... done
[10:18:36.152] result() for ClusterFuture ...
[10:18:36.152] - result already collected: FutureResult
[10:18:36.152] result() for ClusterFuture ... done
[10:18:36.152] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:36.153] - nx: 2
[10:18:36.153] - relay: TRUE
[10:18:36.153] - stdout: TRUE
[10:18:36.153] - signal: TRUE
[10:18:36.153] - resignal: FALSE
[10:18:36.153] - force: TRUE
[10:18:36.153] - relayed: [n=2] TRUE, FALSE
[10:18:36.153] - queued futures: [n=2] TRUE, FALSE
[10:18:36.153]  - until=2
[10:18:36.153]  - relaying element #2
[10:18:36.153] result() for ClusterFuture ...
[10:18:36.153] - result already collected: FutureResult
[10:18:36.154] result() for ClusterFuture ... done
[10:18:36.154] result() for ClusterFuture ...
[10:18:36.154] - result already collected: FutureResult
[10:18:36.154] result() for ClusterFuture ... done
[10:18:36.154] result() for ClusterFuture ...
[10:18:36.154] - result already collected: FutureResult
[10:18:36.154] result() for ClusterFuture ... done
[10:18:36.154] result() for ClusterFuture ...
[10:18:36.154] - result already collected: FutureResult
[10:18:36.154] result() for ClusterFuture ... done
[10:18:36.154] - relayed: [n=2] TRUE, TRUE
[10:18:36.154] - queued futures: [n=2] TRUE, TRUE
[10:18:36.155] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:36.155]  length: 0 (resolved future 2)
[10:18:36.155] Relaying remaining futures
[10:18:36.155] signalConditionsASAP(NULL, pos=0) ...
[10:18:36.155] - nx: 2
[10:18:36.155] - relay: TRUE
[10:18:36.155] - stdout: TRUE
[10:18:36.155] - signal: TRUE
[10:18:36.155] - resignal: FALSE
[10:18:36.155] - force: TRUE
[10:18:36.155] - relayed: [n=2] TRUE, TRUE
[10:18:36.155] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:36.156] - relayed: [n=2] TRUE, TRUE
[10:18:36.156] - queued futures: [n=2] TRUE, TRUE
[10:18:36.156] signalConditionsASAP(NULL, pos=0) ... done
[10:18:36.156] resolve() on list ... DONE
[10:18:36.156] result() for ClusterFuture ...
[10:18:36.156] - result already collected: FutureResult
[10:18:36.156] result() for ClusterFuture ... done
[10:18:36.156] result() for ClusterFuture ...
[10:18:36.156] - result already collected: FutureResult
[10:18:36.156] result() for ClusterFuture ... done
[10:18:36.157] result() for ClusterFuture ...
[10:18:36.157] - result already collected: FutureResult
[10:18:36.157] result() for ClusterFuture ... done
[10:18:36.157] result() for ClusterFuture ...
[10:18:36.157] - result already collected: FutureResult
[10:18:36.157] result() for ClusterFuture ... done
[10:18:36.157]  - Number of value chunks collected: 2
[10:18:36.157] Resolving 2 futures (chunks) ... DONE
[10:18:36.157] Reducing values from 2 chunks ...
[10:18:36.157]  - Number of values collected after concatenation: 3
[10:18:36.157]  - Number of values expected: 3
[10:18:36.157] Reducing values from 2 chunks ... DONE
[10:18:36.158] future_lapply() ... DONE
[10:18:36.158] plan(): Setting new future strategy stack:
[10:18:36.158] List of future strategies:
[10:18:36.158] 1. sequential:
[10:18:36.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:36.158]    - tweaked: FALSE
[10:18:36.158]    - call: plan(sequential)
[10:18:36.159] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[10:18:36.160] plan(): Setting new future strategy stack:
[10:18:36.160] List of future strategies:
[10:18:36.160] 1. FutureStrategy:
[10:18:36.160]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:36.160]    - tweaked: FALSE
[10:18:36.160]    - call: future::plan(oplan)
[10:18:36.160] plan(): nbrOfWorkers() = 1
> 
