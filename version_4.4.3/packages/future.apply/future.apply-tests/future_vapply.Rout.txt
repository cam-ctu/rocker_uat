
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:19:50.962] plan(): Setting new future strategy stack:
[10:19:50.962] List of future strategies:
[10:19:50.962] 1. sequential:
[10:19:50.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:50.962]    - tweaked: FALSE
[10:19:50.962]    - call: future::plan("sequential")
[10:19:50.975] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:19:51.081] plan(): Setting new future strategy stack:
[10:19:51.081] List of future strategies:
[10:19:51.081] 1. sequential:
[10:19:51.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.081]    - tweaked: FALSE
[10:19:51.081]    - call: plan(strategy)
[10:19:51.092] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:19:51.097] future_lapply() ...
[10:19:51.102] Number of chunks: 1
[10:19:51.102] getGlobalsAndPackagesXApply() ...
[10:19:51.102]  - future.globals: TRUE
[10:19:51.103] getGlobalsAndPackages() ...
[10:19:51.103] Searching for globals...
[10:19:51.107] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:51.107] Searching for globals ... DONE
[10:19:51.107] Resolving globals: FALSE
[10:19:51.109] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[10:19:51.109] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.109] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.110] - packages: [1] ‘future.apply’
[10:19:51.110] getGlobalsAndPackages() ... DONE
[10:19:51.110]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.110]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.110] Finding globals ... DONE
[10:19:51.110]  - use_args: TRUE
[10:19:51.110]  - Getting '...' globals ...
[10:19:51.111] resolve() on list ...
[10:19:51.111]  recursive: 0
[10:19:51.111]  length: 1
[10:19:51.111]  elements: ‘...’
[10:19:51.111]  length: 0 (resolved future 1)
[10:19:51.112] resolve() on list ... DONE
[10:19:51.112]    - '...' content: [n=0] 
[10:19:51.112] List of 1
[10:19:51.112]  $ ...: list()
[10:19:51.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.112]  - attr(*, "where")=List of 1
[10:19:51.112]   ..$ ...:<environment: 0x55c69d9b1780> 
[10:19:51.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.112]  - attr(*, "resolved")= logi TRUE
[10:19:51.112]  - attr(*, "total_size")= num NA
[10:19:51.114]  - Getting '...' globals ... DONE
[10:19:51.114] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.114] List of 8
[10:19:51.114]  $ ...future.FUN:function (x, ...)  
[10:19:51.114]  $ x_FUN        :function (x)  
[10:19:51.114]  $ times        : int 1
[10:19:51.114]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.114]  $ stop_if_not  :function (...)  
[10:19:51.114]  $ dim          : NULL
[10:19:51.114]  $ valid_types  : chr "character"
[10:19:51.114]  $ ...          : list()
[10:19:51.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.114]  - attr(*, "where")=List of 8
[10:19:51.114]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.114]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.114]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.114]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.114]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.114]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.114]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.114]   ..$ ...          :<environment: 0x55c69d9b1780> 
[10:19:51.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.114]  - attr(*, "resolved")= logi FALSE
[10:19:51.114]  - attr(*, "total_size")= num 22333
[10:19:51.119] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.120] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.120] Number of futures (= number of chunks): 1
[10:19:51.120] Launching 1 futures (chunks) ...
[10:19:51.120] Chunk #1 of 1 ...
[10:19:51.120]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.120] getGlobalsAndPackages() ...
[10:19:51.120] Searching for globals...
[10:19:51.123] 
[10:19:51.123] Searching for globals ... DONE
[10:19:51.123] - globals: [0] <none>
[10:19:51.123] getGlobalsAndPackages() ... DONE
[10:19:51.123]    + additional globals found: [n=0] 
[10:19:51.123]    + additional namespaces needed: [n=0] 
[10:19:51.123]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.123]  - seeds: <none>
[10:19:51.124]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.124] getGlobalsAndPackages() ...
[10:19:51.124] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.124] Resolving globals: FALSE
[10:19:51.124] Tweak future expression to call with '...' arguments ...
[10:19:51.124] {
[10:19:51.124]     do.call(function(...) {
[10:19:51.124]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.124]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.124]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.124]             on.exit(options(oopts), add = TRUE)
[10:19:51.124]         }
[10:19:51.124]         {
[10:19:51.124]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.124]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.124]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.124]             })
[10:19:51.124]         }
[10:19:51.124]     }, args = future.call.arguments)
[10:19:51.124] }
[10:19:51.124] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.125] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.125] - packages: [1] ‘future.apply’
[10:19:51.125] getGlobalsAndPackages() ... DONE
[10:19:51.126] run() for ‘Future’ ...
[10:19:51.126] - state: ‘created’
[10:19:51.126] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.126] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.126]   - Field: ‘label’
[10:19:51.127]   - Field: ‘local’
[10:19:51.127]   - Field: ‘owner’
[10:19:51.127]   - Field: ‘envir’
[10:19:51.127]   - Field: ‘packages’
[10:19:51.127]   - Field: ‘gc’
[10:19:51.127]   - Field: ‘conditions’
[10:19:51.127]   - Field: ‘expr’
[10:19:51.127]   - Field: ‘uuid’
[10:19:51.127]   - Field: ‘seed’
[10:19:51.127]   - Field: ‘version’
[10:19:51.127]   - Field: ‘result’
[10:19:51.127]   - Field: ‘asynchronous’
[10:19:51.128]   - Field: ‘calls’
[10:19:51.128]   - Field: ‘globals’
[10:19:51.128]   - Field: ‘stdout’
[10:19:51.128]   - Field: ‘earlySignal’
[10:19:51.128]   - Field: ‘lazy’
[10:19:51.128]   - Field: ‘state’
[10:19:51.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.128] - Launch lazy future ...
[10:19:51.129] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.129] Packages needed by future strategies (n = 0): <none>
[10:19:51.130] {
[10:19:51.130]     {
[10:19:51.130]         {
[10:19:51.130]             ...future.startTime <- base::Sys.time()
[10:19:51.130]             {
[10:19:51.130]                 {
[10:19:51.130]                   {
[10:19:51.130]                     {
[10:19:51.130]                       base::local({
[10:19:51.130]                         has_future <- base::requireNamespace("future", 
[10:19:51.130]                           quietly = TRUE)
[10:19:51.130]                         if (has_future) {
[10:19:51.130]                           ns <- base::getNamespace("future")
[10:19:51.130]                           version <- ns[[".package"]][["version"]]
[10:19:51.130]                           if (is.null(version)) 
[10:19:51.130]                             version <- utils::packageVersion("future")
[10:19:51.130]                         }
[10:19:51.130]                         else {
[10:19:51.130]                           version <- NULL
[10:19:51.130]                         }
[10:19:51.130]                         if (!has_future || version < "1.8.0") {
[10:19:51.130]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.130]                             "", base::R.version$version.string), 
[10:19:51.130]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.130]                               "release", "version")], collapse = " "), 
[10:19:51.130]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.130]                             info)
[10:19:51.130]                           info <- base::paste(info, collapse = "; ")
[10:19:51.130]                           if (!has_future) {
[10:19:51.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.130]                               info)
[10:19:51.130]                           }
[10:19:51.130]                           else {
[10:19:51.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.130]                               info, version)
[10:19:51.130]                           }
[10:19:51.130]                           base::stop(msg)
[10:19:51.130]                         }
[10:19:51.130]                       })
[10:19:51.130]                     }
[10:19:51.130]                     base::local({
[10:19:51.130]                       for (pkg in "future.apply") {
[10:19:51.130]                         base::loadNamespace(pkg)
[10:19:51.130]                         base::library(pkg, character.only = TRUE)
[10:19:51.130]                       }
[10:19:51.130]                     })
[10:19:51.130]                   }
[10:19:51.130]                   ...future.strategy.old <- future::plan("list")
[10:19:51.130]                   options(future.plan = NULL)
[10:19:51.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.130]                 }
[10:19:51.130]                 ...future.workdir <- getwd()
[10:19:51.130]             }
[10:19:51.130]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.130]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.130]         }
[10:19:51.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.130]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.130]             base::names(...future.oldOptions))
[10:19:51.130]     }
[10:19:51.130]     if (FALSE) {
[10:19:51.130]     }
[10:19:51.130]     else {
[10:19:51.130]         if (TRUE) {
[10:19:51.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.130]                 open = "w")
[10:19:51.130]         }
[10:19:51.130]         else {
[10:19:51.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.130]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.130]         }
[10:19:51.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.130]             base::sink(type = "output", split = FALSE)
[10:19:51.130]             base::close(...future.stdout)
[10:19:51.130]         }, add = TRUE)
[10:19:51.130]     }
[10:19:51.130]     ...future.frame <- base::sys.nframe()
[10:19:51.130]     ...future.conditions <- base::list()
[10:19:51.130]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.130]     if (FALSE) {
[10:19:51.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.130]     }
[10:19:51.130]     ...future.result <- base::tryCatch({
[10:19:51.130]         base::withCallingHandlers({
[10:19:51.130]             ...future.value <- base::withVisible(base::local({
[10:19:51.130]                 do.call(function(...) {
[10:19:51.130]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.130]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.130]                     ...future.globals.maxSize)) {
[10:19:51.130]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.130]                     on.exit(options(oopts), add = TRUE)
[10:19:51.130]                   }
[10:19:51.130]                   {
[10:19:51.130]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.130]                       FUN = function(jj) {
[10:19:51.130]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.130]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.130]                       })
[10:19:51.130]                   }
[10:19:51.130]                 }, args = future.call.arguments)
[10:19:51.130]             }))
[10:19:51.130]             future::FutureResult(value = ...future.value$value, 
[10:19:51.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.130]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.130]                     ...future.globalenv.names))
[10:19:51.130]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.130]         }, condition = base::local({
[10:19:51.130]             c <- base::c
[10:19:51.130]             inherits <- base::inherits
[10:19:51.130]             invokeRestart <- base::invokeRestart
[10:19:51.130]             length <- base::length
[10:19:51.130]             list <- base::list
[10:19:51.130]             seq.int <- base::seq.int
[10:19:51.130]             signalCondition <- base::signalCondition
[10:19:51.130]             sys.calls <- base::sys.calls
[10:19:51.130]             `[[` <- base::`[[`
[10:19:51.130]             `+` <- base::`+`
[10:19:51.130]             `<<-` <- base::`<<-`
[10:19:51.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.130]                   3L)]
[10:19:51.130]             }
[10:19:51.130]             function(cond) {
[10:19:51.130]                 is_error <- inherits(cond, "error")
[10:19:51.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.130]                   NULL)
[10:19:51.130]                 if (is_error) {
[10:19:51.130]                   sessionInformation <- function() {
[10:19:51.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.130]                       search = base::search(), system = base::Sys.info())
[10:19:51.130]                   }
[10:19:51.130]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.130]                     cond$call), session = sessionInformation(), 
[10:19:51.130]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.130]                   signalCondition(cond)
[10:19:51.130]                 }
[10:19:51.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.130]                 "immediateCondition"))) {
[10:19:51.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.130]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.130]                   if (TRUE && !signal) {
[10:19:51.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.130]                     {
[10:19:51.130]                       inherits <- base::inherits
[10:19:51.130]                       invokeRestart <- base::invokeRestart
[10:19:51.130]                       is.null <- base::is.null
[10:19:51.130]                       muffled <- FALSE
[10:19:51.130]                       if (inherits(cond, "message")) {
[10:19:51.130]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.130]                         if (muffled) 
[10:19:51.130]                           invokeRestart("muffleMessage")
[10:19:51.130]                       }
[10:19:51.130]                       else if (inherits(cond, "warning")) {
[10:19:51.130]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.130]                         if (muffled) 
[10:19:51.130]                           invokeRestart("muffleWarning")
[10:19:51.130]                       }
[10:19:51.130]                       else if (inherits(cond, "condition")) {
[10:19:51.130]                         if (!is.null(pattern)) {
[10:19:51.130]                           computeRestarts <- base::computeRestarts
[10:19:51.130]                           grepl <- base::grepl
[10:19:51.130]                           restarts <- computeRestarts(cond)
[10:19:51.130]                           for (restart in restarts) {
[10:19:51.130]                             name <- restart$name
[10:19:51.130]                             if (is.null(name)) 
[10:19:51.130]                               next
[10:19:51.130]                             if (!grepl(pattern, name)) 
[10:19:51.130]                               next
[10:19:51.130]                             invokeRestart(restart)
[10:19:51.130]                             muffled <- TRUE
[10:19:51.130]                             break
[10:19:51.130]                           }
[10:19:51.130]                         }
[10:19:51.130]                       }
[10:19:51.130]                       invisible(muffled)
[10:19:51.130]                     }
[10:19:51.130]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.130]                   }
[10:19:51.130]                 }
[10:19:51.130]                 else {
[10:19:51.130]                   if (TRUE) {
[10:19:51.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.130]                     {
[10:19:51.130]                       inherits <- base::inherits
[10:19:51.130]                       invokeRestart <- base::invokeRestart
[10:19:51.130]                       is.null <- base::is.null
[10:19:51.130]                       muffled <- FALSE
[10:19:51.130]                       if (inherits(cond, "message")) {
[10:19:51.130]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.130]                         if (muffled) 
[10:19:51.130]                           invokeRestart("muffleMessage")
[10:19:51.130]                       }
[10:19:51.130]                       else if (inherits(cond, "warning")) {
[10:19:51.130]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.130]                         if (muffled) 
[10:19:51.130]                           invokeRestart("muffleWarning")
[10:19:51.130]                       }
[10:19:51.130]                       else if (inherits(cond, "condition")) {
[10:19:51.130]                         if (!is.null(pattern)) {
[10:19:51.130]                           computeRestarts <- base::computeRestarts
[10:19:51.130]                           grepl <- base::grepl
[10:19:51.130]                           restarts <- computeRestarts(cond)
[10:19:51.130]                           for (restart in restarts) {
[10:19:51.130]                             name <- restart$name
[10:19:51.130]                             if (is.null(name)) 
[10:19:51.130]                               next
[10:19:51.130]                             if (!grepl(pattern, name)) 
[10:19:51.130]                               next
[10:19:51.130]                             invokeRestart(restart)
[10:19:51.130]                             muffled <- TRUE
[10:19:51.130]                             break
[10:19:51.130]                           }
[10:19:51.130]                         }
[10:19:51.130]                       }
[10:19:51.130]                       invisible(muffled)
[10:19:51.130]                     }
[10:19:51.130]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.130]                   }
[10:19:51.130]                 }
[10:19:51.130]             }
[10:19:51.130]         }))
[10:19:51.130]     }, error = function(ex) {
[10:19:51.130]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.130]                 ...future.rng), started = ...future.startTime, 
[10:19:51.130]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.130]             version = "1.8"), class = "FutureResult")
[10:19:51.130]     }, finally = {
[10:19:51.130]         if (!identical(...future.workdir, getwd())) 
[10:19:51.130]             setwd(...future.workdir)
[10:19:51.130]         {
[10:19:51.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.130]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.130]             }
[10:19:51.130]             base::options(...future.oldOptions)
[10:19:51.130]             if (.Platform$OS.type == "windows") {
[10:19:51.130]                 old_names <- names(...future.oldEnvVars)
[10:19:51.130]                 envs <- base::Sys.getenv()
[10:19:51.130]                 names <- names(envs)
[10:19:51.130]                 common <- intersect(names, old_names)
[10:19:51.130]                 added <- setdiff(names, old_names)
[10:19:51.130]                 removed <- setdiff(old_names, names)
[10:19:51.130]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.130]                   envs[common]]
[10:19:51.130]                 NAMES <- toupper(changed)
[10:19:51.130]                 args <- list()
[10:19:51.130]                 for (kk in seq_along(NAMES)) {
[10:19:51.130]                   name <- changed[[kk]]
[10:19:51.130]                   NAME <- NAMES[[kk]]
[10:19:51.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.130]                     next
[10:19:51.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.130]                 }
[10:19:51.130]                 NAMES <- toupper(added)
[10:19:51.130]                 for (kk in seq_along(NAMES)) {
[10:19:51.130]                   name <- added[[kk]]
[10:19:51.130]                   NAME <- NAMES[[kk]]
[10:19:51.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.130]                     next
[10:19:51.130]                   args[[name]] <- ""
[10:19:51.130]                 }
[10:19:51.130]                 NAMES <- toupper(removed)
[10:19:51.130]                 for (kk in seq_along(NAMES)) {
[10:19:51.130]                   name <- removed[[kk]]
[10:19:51.130]                   NAME <- NAMES[[kk]]
[10:19:51.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.130]                     next
[10:19:51.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.130]                 }
[10:19:51.130]                 if (length(args) > 0) 
[10:19:51.130]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.130]             }
[10:19:51.130]             else {
[10:19:51.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.130]             }
[10:19:51.130]             {
[10:19:51.130]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.130]                   0L) {
[10:19:51.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.130]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.130]                   base::options(opts)
[10:19:51.130]                 }
[10:19:51.130]                 {
[10:19:51.130]                   {
[10:19:51.130]                     NULL
[10:19:51.130]                     RNGkind("Mersenne-Twister")
[10:19:51.130]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.130]                       inherits = FALSE)
[10:19:51.130]                   }
[10:19:51.130]                   options(future.plan = NULL)
[10:19:51.130]                   if (is.na(NA_character_)) 
[10:19:51.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.130]                     .init = FALSE)
[10:19:51.130]                 }
[10:19:51.130]             }
[10:19:51.130]         }
[10:19:51.130]     })
[10:19:51.130]     if (TRUE) {
[10:19:51.130]         base::sink(type = "output", split = FALSE)
[10:19:51.130]         if (TRUE) {
[10:19:51.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.130]         }
[10:19:51.130]         else {
[10:19:51.130]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.130]         }
[10:19:51.130]         base::close(...future.stdout)
[10:19:51.130]         ...future.stdout <- NULL
[10:19:51.130]     }
[10:19:51.130]     ...future.result$conditions <- ...future.conditions
[10:19:51.130]     ...future.result$finished <- base::Sys.time()
[10:19:51.130]     ...future.result
[10:19:51.130] }
[10:19:51.131] assign_globals() ...
[10:19:51.132] List of 11
[10:19:51.132]  $ ...future.FUN            :function (x, ...)  
[10:19:51.132]  $ x_FUN                    :function (x)  
[10:19:51.132]  $ times                    : int 1
[10:19:51.132]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.132]  $ stop_if_not              :function (...)  
[10:19:51.132]  $ dim                      : NULL
[10:19:51.132]  $ valid_types              : chr "character"
[10:19:51.132]  $ future.call.arguments    : list()
[10:19:51.132]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.132]  $ ...future.elements_ii    :List of 2
[10:19:51.132]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:19:51.132]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[10:19:51.132]  $ ...future.seeds_ii       : NULL
[10:19:51.132]  $ ...future.globals.maxSize: NULL
[10:19:51.132]  - attr(*, "where")=List of 11
[10:19:51.132]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.132]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.132]  - attr(*, "resolved")= logi FALSE
[10:19:51.132]  - attr(*, "total_size")= num 22333
[10:19:51.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.132]  - attr(*, "already-done")= logi TRUE
[10:19:51.139] - copied ‘...future.FUN’ to environment
[10:19:51.139] - copied ‘x_FUN’ to environment
[10:19:51.139] - copied ‘times’ to environment
[10:19:51.139] - copied ‘stopf’ to environment
[10:19:51.139] - copied ‘stop_if_not’ to environment
[10:19:51.139] - copied ‘dim’ to environment
[10:19:51.139] - copied ‘valid_types’ to environment
[10:19:51.139] - copied ‘future.call.arguments’ to environment
[10:19:51.139] - copied ‘...future.elements_ii’ to environment
[10:19:51.139] - copied ‘...future.seeds_ii’ to environment
[10:19:51.139] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.140] assign_globals() ... done
[10:19:51.140] plan(): Setting new future strategy stack:
[10:19:51.140] List of future strategies:
[10:19:51.140] 1. sequential:
[10:19:51.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.140]    - tweaked: FALSE
[10:19:51.140]    - call: NULL
[10:19:51.140] plan(): nbrOfWorkers() = 1
[10:19:51.142] plan(): Setting new future strategy stack:
[10:19:51.142] List of future strategies:
[10:19:51.142] 1. sequential:
[10:19:51.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.142]    - tweaked: FALSE
[10:19:51.142]    - call: plan(strategy)
[10:19:51.142] plan(): nbrOfWorkers() = 1
[10:19:51.142] SequentialFuture started (and completed)
[10:19:51.143] - Launch lazy future ... done
[10:19:51.143] run() for ‘SequentialFuture’ ... done
[10:19:51.143] Created future:
[10:19:51.143] SequentialFuture:
[10:19:51.143] Label: ‘future_vapply-1’
[10:19:51.143] Expression:
[10:19:51.143] {
[10:19:51.143]     do.call(function(...) {
[10:19:51.143]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.143]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.143]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.143]             on.exit(options(oopts), add = TRUE)
[10:19:51.143]         }
[10:19:51.143]         {
[10:19:51.143]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.143]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.143]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.143]             })
[10:19:51.143]         }
[10:19:51.143]     }, args = future.call.arguments)
[10:19:51.143] }
[10:19:51.143] Lazy evaluation: FALSE
[10:19:51.143] Asynchronous evaluation: FALSE
[10:19:51.143] Local evaluation: TRUE
[10:19:51.143] Environment: R_GlobalEnv
[10:19:51.143] Capture standard output: TRUE
[10:19:51.143] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.143] Globals: 11 objects totaling 12.43 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.143] Packages: 1 packages (‘future.apply’)
[10:19:51.143] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.143] Resolved: TRUE
[10:19:51.143] Value: 79 bytes of class ‘list’
[10:19:51.143] Early signaling: FALSE
[10:19:51.143] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.143] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.144] Chunk #1 of 1 ... DONE
[10:19:51.144] Launching 1 futures (chunks) ... DONE
[10:19:51.144] Resolving 1 futures (chunks) ...
[10:19:51.144] resolve() on list ...
[10:19:51.145]  recursive: 0
[10:19:51.145]  length: 1
[10:19:51.145] 
[10:19:51.145] resolved() for ‘SequentialFuture’ ...
[10:19:51.145] - state: ‘finished’
[10:19:51.145] - run: TRUE
[10:19:51.145] - result: ‘FutureResult’
[10:19:51.145] resolved() for ‘SequentialFuture’ ... done
[10:19:51.145] Future #1
[10:19:51.146] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.146] - nx: 1
[10:19:51.146] - relay: TRUE
[10:19:51.146] - stdout: TRUE
[10:19:51.146] - signal: TRUE
[10:19:51.146] - resignal: FALSE
[10:19:51.146] - force: TRUE
[10:19:51.146] - relayed: [n=1] FALSE
[10:19:51.146] - queued futures: [n=1] FALSE
[10:19:51.146]  - until=1
[10:19:51.146]  - relaying element #1
[10:19:51.147] - relayed: [n=1] TRUE
[10:19:51.147] - queued futures: [n=1] TRUE
[10:19:51.147] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.147]  length: 0 (resolved future 1)
[10:19:51.147] Relaying remaining futures
[10:19:51.147] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.147] - nx: 1
[10:19:51.147] - relay: TRUE
[10:19:51.147] - stdout: TRUE
[10:19:51.147] - signal: TRUE
[10:19:51.147] - resignal: FALSE
[10:19:51.148] - force: TRUE
[10:19:51.148] - relayed: [n=1] TRUE
[10:19:51.149] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.149] - relayed: [n=1] TRUE
[10:19:51.149] - queued futures: [n=1] TRUE
[10:19:51.149] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.149] resolve() on list ... DONE
[10:19:51.150]  - Number of value chunks collected: 1
[10:19:51.150] Resolving 1 futures (chunks) ... DONE
[10:19:51.150] Reducing values from 1 chunks ...
[10:19:51.150]  - Number of values collected after concatenation: 2
[10:19:51.150]  - Number of values expected: 2
[10:19:51.150] Reducing values from 1 chunks ... DONE
[10:19:51.150] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:19:51.151] future_lapply() ...
[10:19:51.153] Number of chunks: 1
[10:19:51.153] getGlobalsAndPackagesXApply() ...
[10:19:51.153]  - future.globals: TRUE
[10:19:51.153] getGlobalsAndPackages() ...
[10:19:51.153] Searching for globals...
[10:19:51.156] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:19:51.156] Searching for globals ... DONE
[10:19:51.156] Resolving globals: FALSE
[10:19:51.157] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[10:19:51.157] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.158] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.158] - packages: [1] ‘future.apply’
[10:19:51.158] getGlobalsAndPackages() ... DONE
[10:19:51.158]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.158]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.158] Finding globals ... DONE
[10:19:51.158]  - use_args: TRUE
[10:19:51.158]  - Getting '...' globals ...
[10:19:51.159] resolve() on list ...
[10:19:51.159]  recursive: 0
[10:19:51.159]  length: 1
[10:19:51.159]  elements: ‘...’
[10:19:51.159]  length: 0 (resolved future 1)
[10:19:51.159] resolve() on list ... DONE
[10:19:51.159]    - '...' content: [n=0] 
[10:19:51.159] List of 1
[10:19:51.159]  $ ...: list()
[10:19:51.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.159]  - attr(*, "where")=List of 1
[10:19:51.159]   ..$ ...:<environment: 0x55c69e6989d8> 
[10:19:51.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.159]  - attr(*, "resolved")= logi TRUE
[10:19:51.159]  - attr(*, "total_size")= num NA
[10:19:51.161]  - Getting '...' globals ... DONE
[10:19:51.161] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.161] List of 8
[10:19:51.161]  $ ...future.FUN:function (x, ...)  
[10:19:51.161]  $ x_FUN        :function (x)  
[10:19:51.161]  $ times        : int 0
[10:19:51.161]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.161]  $ stop_if_not  :function (...)  
[10:19:51.161]  $ dim          : NULL
[10:19:51.161]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.161]  $ ...          : list()
[10:19:51.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.161]  - attr(*, "where")=List of 8
[10:19:51.161]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.161]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.161]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.161]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.161]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.161]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.161]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.161]   ..$ ...          :<environment: 0x55c69e6989d8> 
[10:19:51.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.161]  - attr(*, "resolved")= logi FALSE
[10:19:51.161]  - attr(*, "total_size")= num 23490
[10:19:51.166] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.166] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.167] Number of futures (= number of chunks): 1
[10:19:51.167] Launching 1 futures (chunks) ...
[10:19:51.167] Chunk #1 of 1 ...
[10:19:51.167]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.167] getGlobalsAndPackages() ...
[10:19:51.167] Searching for globals...
[10:19:51.167] 
[10:19:51.167] Searching for globals ... DONE
[10:19:51.167] - globals: [0] <none>
[10:19:51.168] getGlobalsAndPackages() ... DONE
[10:19:51.168]    + additional globals found: [n=0] 
[10:19:51.168]    + additional namespaces needed: [n=0] 
[10:19:51.168]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.168]  - seeds: <none>
[10:19:51.168]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.168] getGlobalsAndPackages() ...
[10:19:51.168] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.168] Resolving globals: FALSE
[10:19:51.168] Tweak future expression to call with '...' arguments ...
[10:19:51.168] {
[10:19:51.168]     do.call(function(...) {
[10:19:51.168]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.168]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.168]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.168]             on.exit(options(oopts), add = TRUE)
[10:19:51.168]         }
[10:19:51.168]         {
[10:19:51.168]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.168]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.168]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.168]             })
[10:19:51.168]         }
[10:19:51.168]     }, args = future.call.arguments)
[10:19:51.168] }
[10:19:51.169] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.170] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.170] - packages: [1] ‘future.apply’
[10:19:51.170] getGlobalsAndPackages() ... DONE
[10:19:51.171] run() for ‘Future’ ...
[10:19:51.171] - state: ‘created’
[10:19:51.171] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.171] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.171]   - Field: ‘label’
[10:19:51.171]   - Field: ‘local’
[10:19:51.171]   - Field: ‘owner’
[10:19:51.171]   - Field: ‘envir’
[10:19:51.172]   - Field: ‘packages’
[10:19:51.172]   - Field: ‘gc’
[10:19:51.172]   - Field: ‘conditions’
[10:19:51.172]   - Field: ‘expr’
[10:19:51.172]   - Field: ‘uuid’
[10:19:51.172]   - Field: ‘seed’
[10:19:51.172]   - Field: ‘version’
[10:19:51.172]   - Field: ‘result’
[10:19:51.172]   - Field: ‘asynchronous’
[10:19:51.172]   - Field: ‘calls’
[10:19:51.172]   - Field: ‘globals’
[10:19:51.172]   - Field: ‘stdout’
[10:19:51.173]   - Field: ‘earlySignal’
[10:19:51.173]   - Field: ‘lazy’
[10:19:51.173]   - Field: ‘state’
[10:19:51.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.173] - Launch lazy future ...
[10:19:51.173] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.173] Packages needed by future strategies (n = 0): <none>
[10:19:51.174] {
[10:19:51.174]     {
[10:19:51.174]         {
[10:19:51.174]             ...future.startTime <- base::Sys.time()
[10:19:51.174]             {
[10:19:51.174]                 {
[10:19:51.174]                   {
[10:19:51.174]                     {
[10:19:51.174]                       base::local({
[10:19:51.174]                         has_future <- base::requireNamespace("future", 
[10:19:51.174]                           quietly = TRUE)
[10:19:51.174]                         if (has_future) {
[10:19:51.174]                           ns <- base::getNamespace("future")
[10:19:51.174]                           version <- ns[[".package"]][["version"]]
[10:19:51.174]                           if (is.null(version)) 
[10:19:51.174]                             version <- utils::packageVersion("future")
[10:19:51.174]                         }
[10:19:51.174]                         else {
[10:19:51.174]                           version <- NULL
[10:19:51.174]                         }
[10:19:51.174]                         if (!has_future || version < "1.8.0") {
[10:19:51.174]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.174]                             "", base::R.version$version.string), 
[10:19:51.174]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.174]                               "release", "version")], collapse = " "), 
[10:19:51.174]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.174]                             info)
[10:19:51.174]                           info <- base::paste(info, collapse = "; ")
[10:19:51.174]                           if (!has_future) {
[10:19:51.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.174]                               info)
[10:19:51.174]                           }
[10:19:51.174]                           else {
[10:19:51.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.174]                               info, version)
[10:19:51.174]                           }
[10:19:51.174]                           base::stop(msg)
[10:19:51.174]                         }
[10:19:51.174]                       })
[10:19:51.174]                     }
[10:19:51.174]                     base::local({
[10:19:51.174]                       for (pkg in "future.apply") {
[10:19:51.174]                         base::loadNamespace(pkg)
[10:19:51.174]                         base::library(pkg, character.only = TRUE)
[10:19:51.174]                       }
[10:19:51.174]                     })
[10:19:51.174]                   }
[10:19:51.174]                   ...future.strategy.old <- future::plan("list")
[10:19:51.174]                   options(future.plan = NULL)
[10:19:51.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.174]                 }
[10:19:51.174]                 ...future.workdir <- getwd()
[10:19:51.174]             }
[10:19:51.174]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.174]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.174]         }
[10:19:51.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.174]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.174]             base::names(...future.oldOptions))
[10:19:51.174]     }
[10:19:51.174]     if (FALSE) {
[10:19:51.174]     }
[10:19:51.174]     else {
[10:19:51.174]         if (TRUE) {
[10:19:51.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.174]                 open = "w")
[10:19:51.174]         }
[10:19:51.174]         else {
[10:19:51.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.174]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.174]         }
[10:19:51.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.174]             base::sink(type = "output", split = FALSE)
[10:19:51.174]             base::close(...future.stdout)
[10:19:51.174]         }, add = TRUE)
[10:19:51.174]     }
[10:19:51.174]     ...future.frame <- base::sys.nframe()
[10:19:51.174]     ...future.conditions <- base::list()
[10:19:51.174]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.174]     if (FALSE) {
[10:19:51.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.174]     }
[10:19:51.174]     ...future.result <- base::tryCatch({
[10:19:51.174]         base::withCallingHandlers({
[10:19:51.174]             ...future.value <- base::withVisible(base::local({
[10:19:51.174]                 do.call(function(...) {
[10:19:51.174]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.174]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.174]                     ...future.globals.maxSize)) {
[10:19:51.174]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.174]                     on.exit(options(oopts), add = TRUE)
[10:19:51.174]                   }
[10:19:51.174]                   {
[10:19:51.174]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.174]                       FUN = function(jj) {
[10:19:51.174]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.174]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.174]                       })
[10:19:51.174]                   }
[10:19:51.174]                 }, args = future.call.arguments)
[10:19:51.174]             }))
[10:19:51.174]             future::FutureResult(value = ...future.value$value, 
[10:19:51.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.174]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.174]                     ...future.globalenv.names))
[10:19:51.174]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.174]         }, condition = base::local({
[10:19:51.174]             c <- base::c
[10:19:51.174]             inherits <- base::inherits
[10:19:51.174]             invokeRestart <- base::invokeRestart
[10:19:51.174]             length <- base::length
[10:19:51.174]             list <- base::list
[10:19:51.174]             seq.int <- base::seq.int
[10:19:51.174]             signalCondition <- base::signalCondition
[10:19:51.174]             sys.calls <- base::sys.calls
[10:19:51.174]             `[[` <- base::`[[`
[10:19:51.174]             `+` <- base::`+`
[10:19:51.174]             `<<-` <- base::`<<-`
[10:19:51.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.174]                   3L)]
[10:19:51.174]             }
[10:19:51.174]             function(cond) {
[10:19:51.174]                 is_error <- inherits(cond, "error")
[10:19:51.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.174]                   NULL)
[10:19:51.174]                 if (is_error) {
[10:19:51.174]                   sessionInformation <- function() {
[10:19:51.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.174]                       search = base::search(), system = base::Sys.info())
[10:19:51.174]                   }
[10:19:51.174]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.174]                     cond$call), session = sessionInformation(), 
[10:19:51.174]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.174]                   signalCondition(cond)
[10:19:51.174]                 }
[10:19:51.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.174]                 "immediateCondition"))) {
[10:19:51.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.174]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.174]                   if (TRUE && !signal) {
[10:19:51.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.174]                     {
[10:19:51.174]                       inherits <- base::inherits
[10:19:51.174]                       invokeRestart <- base::invokeRestart
[10:19:51.174]                       is.null <- base::is.null
[10:19:51.174]                       muffled <- FALSE
[10:19:51.174]                       if (inherits(cond, "message")) {
[10:19:51.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.174]                         if (muffled) 
[10:19:51.174]                           invokeRestart("muffleMessage")
[10:19:51.174]                       }
[10:19:51.174]                       else if (inherits(cond, "warning")) {
[10:19:51.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.174]                         if (muffled) 
[10:19:51.174]                           invokeRestart("muffleWarning")
[10:19:51.174]                       }
[10:19:51.174]                       else if (inherits(cond, "condition")) {
[10:19:51.174]                         if (!is.null(pattern)) {
[10:19:51.174]                           computeRestarts <- base::computeRestarts
[10:19:51.174]                           grepl <- base::grepl
[10:19:51.174]                           restarts <- computeRestarts(cond)
[10:19:51.174]                           for (restart in restarts) {
[10:19:51.174]                             name <- restart$name
[10:19:51.174]                             if (is.null(name)) 
[10:19:51.174]                               next
[10:19:51.174]                             if (!grepl(pattern, name)) 
[10:19:51.174]                               next
[10:19:51.174]                             invokeRestart(restart)
[10:19:51.174]                             muffled <- TRUE
[10:19:51.174]                             break
[10:19:51.174]                           }
[10:19:51.174]                         }
[10:19:51.174]                       }
[10:19:51.174]                       invisible(muffled)
[10:19:51.174]                     }
[10:19:51.174]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.174]                   }
[10:19:51.174]                 }
[10:19:51.174]                 else {
[10:19:51.174]                   if (TRUE) {
[10:19:51.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.174]                     {
[10:19:51.174]                       inherits <- base::inherits
[10:19:51.174]                       invokeRestart <- base::invokeRestart
[10:19:51.174]                       is.null <- base::is.null
[10:19:51.174]                       muffled <- FALSE
[10:19:51.174]                       if (inherits(cond, "message")) {
[10:19:51.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.174]                         if (muffled) 
[10:19:51.174]                           invokeRestart("muffleMessage")
[10:19:51.174]                       }
[10:19:51.174]                       else if (inherits(cond, "warning")) {
[10:19:51.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.174]                         if (muffled) 
[10:19:51.174]                           invokeRestart("muffleWarning")
[10:19:51.174]                       }
[10:19:51.174]                       else if (inherits(cond, "condition")) {
[10:19:51.174]                         if (!is.null(pattern)) {
[10:19:51.174]                           computeRestarts <- base::computeRestarts
[10:19:51.174]                           grepl <- base::grepl
[10:19:51.174]                           restarts <- computeRestarts(cond)
[10:19:51.174]                           for (restart in restarts) {
[10:19:51.174]                             name <- restart$name
[10:19:51.174]                             if (is.null(name)) 
[10:19:51.174]                               next
[10:19:51.174]                             if (!grepl(pattern, name)) 
[10:19:51.174]                               next
[10:19:51.174]                             invokeRestart(restart)
[10:19:51.174]                             muffled <- TRUE
[10:19:51.174]                             break
[10:19:51.174]                           }
[10:19:51.174]                         }
[10:19:51.174]                       }
[10:19:51.174]                       invisible(muffled)
[10:19:51.174]                     }
[10:19:51.174]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.174]                   }
[10:19:51.174]                 }
[10:19:51.174]             }
[10:19:51.174]         }))
[10:19:51.174]     }, error = function(ex) {
[10:19:51.174]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.174]                 ...future.rng), started = ...future.startTime, 
[10:19:51.174]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.174]             version = "1.8"), class = "FutureResult")
[10:19:51.174]     }, finally = {
[10:19:51.174]         if (!identical(...future.workdir, getwd())) 
[10:19:51.174]             setwd(...future.workdir)
[10:19:51.174]         {
[10:19:51.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.174]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.174]             }
[10:19:51.174]             base::options(...future.oldOptions)
[10:19:51.174]             if (.Platform$OS.type == "windows") {
[10:19:51.174]                 old_names <- names(...future.oldEnvVars)
[10:19:51.174]                 envs <- base::Sys.getenv()
[10:19:51.174]                 names <- names(envs)
[10:19:51.174]                 common <- intersect(names, old_names)
[10:19:51.174]                 added <- setdiff(names, old_names)
[10:19:51.174]                 removed <- setdiff(old_names, names)
[10:19:51.174]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.174]                   envs[common]]
[10:19:51.174]                 NAMES <- toupper(changed)
[10:19:51.174]                 args <- list()
[10:19:51.174]                 for (kk in seq_along(NAMES)) {
[10:19:51.174]                   name <- changed[[kk]]
[10:19:51.174]                   NAME <- NAMES[[kk]]
[10:19:51.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.174]                     next
[10:19:51.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.174]                 }
[10:19:51.174]                 NAMES <- toupper(added)
[10:19:51.174]                 for (kk in seq_along(NAMES)) {
[10:19:51.174]                   name <- added[[kk]]
[10:19:51.174]                   NAME <- NAMES[[kk]]
[10:19:51.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.174]                     next
[10:19:51.174]                   args[[name]] <- ""
[10:19:51.174]                 }
[10:19:51.174]                 NAMES <- toupper(removed)
[10:19:51.174]                 for (kk in seq_along(NAMES)) {
[10:19:51.174]                   name <- removed[[kk]]
[10:19:51.174]                   NAME <- NAMES[[kk]]
[10:19:51.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.174]                     next
[10:19:51.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.174]                 }
[10:19:51.174]                 if (length(args) > 0) 
[10:19:51.174]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.174]             }
[10:19:51.174]             else {
[10:19:51.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.174]             }
[10:19:51.174]             {
[10:19:51.174]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.174]                   0L) {
[10:19:51.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.174]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.174]                   base::options(opts)
[10:19:51.174]                 }
[10:19:51.174]                 {
[10:19:51.174]                   {
[10:19:51.174]                     NULL
[10:19:51.174]                     RNGkind("Mersenne-Twister")
[10:19:51.174]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.174]                       inherits = FALSE)
[10:19:51.174]                   }
[10:19:51.174]                   options(future.plan = NULL)
[10:19:51.174]                   if (is.na(NA_character_)) 
[10:19:51.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.174]                     .init = FALSE)
[10:19:51.174]                 }
[10:19:51.174]             }
[10:19:51.174]         }
[10:19:51.174]     })
[10:19:51.174]     if (TRUE) {
[10:19:51.174]         base::sink(type = "output", split = FALSE)
[10:19:51.174]         if (TRUE) {
[10:19:51.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.174]         }
[10:19:51.174]         else {
[10:19:51.174]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.174]         }
[10:19:51.174]         base::close(...future.stdout)
[10:19:51.174]         ...future.stdout <- NULL
[10:19:51.174]     }
[10:19:51.174]     ...future.result$conditions <- ...future.conditions
[10:19:51.174]     ...future.result$finished <- base::Sys.time()
[10:19:51.174]     ...future.result
[10:19:51.174] }
[10:19:51.175] assign_globals() ...
[10:19:51.175] List of 11
[10:19:51.175]  $ ...future.FUN            :function (x, ...)  
[10:19:51.175]  $ x_FUN                    :function (x)  
[10:19:51.175]  $ times                    : int 0
[10:19:51.175]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.175]  $ stop_if_not              :function (...)  
[10:19:51.175]  $ dim                      : NULL
[10:19:51.175]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.175]  $ future.call.arguments    : list()
[10:19:51.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.175]  $ ...future.elements_ii    :List of 10
[10:19:51.175]   ..$ : int 1
[10:19:51.175]   ..$ : int 2
[10:19:51.175]   ..$ : int 3
[10:19:51.175]   ..$ : int 4
[10:19:51.175]   ..$ : int 5
[10:19:51.175]   ..$ : int 6
[10:19:51.175]   ..$ : int 7
[10:19:51.175]   ..$ : int 8
[10:19:51.175]   ..$ : int 9
[10:19:51.175]   ..$ : int 10
[10:19:51.175]  $ ...future.seeds_ii       : NULL
[10:19:51.175]  $ ...future.globals.maxSize: NULL
[10:19:51.175]  - attr(*, "where")=List of 11
[10:19:51.175]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.175]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.175]  - attr(*, "resolved")= logi FALSE
[10:19:51.175]  - attr(*, "total_size")= num 23490
[10:19:51.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.175]  - attr(*, "already-done")= logi TRUE
[10:19:51.184] - copied ‘...future.FUN’ to environment
[10:19:51.184] - reassign environment for ‘x_FUN’
[10:19:51.184] - copied ‘x_FUN’ to environment
[10:19:51.185] - copied ‘times’ to environment
[10:19:51.185] - copied ‘stopf’ to environment
[10:19:51.185] - copied ‘stop_if_not’ to environment
[10:19:51.185] - copied ‘dim’ to environment
[10:19:51.185] - copied ‘valid_types’ to environment
[10:19:51.185] - copied ‘future.call.arguments’ to environment
[10:19:51.185] - copied ‘...future.elements_ii’ to environment
[10:19:51.185] - copied ‘...future.seeds_ii’ to environment
[10:19:51.185] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.185] assign_globals() ... done
[10:19:51.186] plan(): Setting new future strategy stack:
[10:19:51.186] List of future strategies:
[10:19:51.186] 1. sequential:
[10:19:51.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.186]    - tweaked: FALSE
[10:19:51.186]    - call: NULL
[10:19:51.186] plan(): nbrOfWorkers() = 1
[10:19:51.187] plan(): Setting new future strategy stack:
[10:19:51.187] List of future strategies:
[10:19:51.187] 1. sequential:
[10:19:51.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.187]    - tweaked: FALSE
[10:19:51.187]    - call: plan(strategy)
[10:19:51.187] plan(): nbrOfWorkers() = 1
[10:19:51.187] SequentialFuture started (and completed)
[10:19:51.188] - Launch lazy future ... done
[10:19:51.188] run() for ‘SequentialFuture’ ... done
[10:19:51.188] Created future:
[10:19:51.188] SequentialFuture:
[10:19:51.188] Label: ‘future_vapply-1’
[10:19:51.188] Expression:
[10:19:51.188] {
[10:19:51.188]     do.call(function(...) {
[10:19:51.188]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.188]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.188]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.188]             on.exit(options(oopts), add = TRUE)
[10:19:51.188]         }
[10:19:51.188]         {
[10:19:51.188]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.188]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.188]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.188]             })
[10:19:51.188]         }
[10:19:51.188]     }, args = future.call.arguments)
[10:19:51.188] }
[10:19:51.188] Lazy evaluation: FALSE
[10:19:51.188] Asynchronous evaluation: FALSE
[10:19:51.188] Local evaluation: TRUE
[10:19:51.188] Environment: R_GlobalEnv
[10:19:51.188] Capture standard output: TRUE
[10:19:51.188] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.188] Globals: 11 objects totaling 13.07 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.188] Packages: 1 packages (‘future.apply’)
[10:19:51.188] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.188] Resolved: TRUE
[10:19:51.188] Value: 111 bytes of class ‘list’
[10:19:51.188] Early signaling: FALSE
[10:19:51.188] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.188] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.189] Chunk #1 of 1 ... DONE
[10:19:51.189] Launching 1 futures (chunks) ... DONE
[10:19:51.189] Resolving 1 futures (chunks) ...
[10:19:51.189] resolve() on list ...
[10:19:51.189]  recursive: 0
[10:19:51.189]  length: 1
[10:19:51.189] 
[10:19:51.189] resolved() for ‘SequentialFuture’ ...
[10:19:51.189] - state: ‘finished’
[10:19:51.189] - run: TRUE
[10:19:51.190] - result: ‘FutureResult’
[10:19:51.190] resolved() for ‘SequentialFuture’ ... done
[10:19:51.190] Future #1
[10:19:51.190] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.190] - nx: 1
[10:19:51.190] - relay: TRUE
[10:19:51.190] - stdout: TRUE
[10:19:51.190] - signal: TRUE
[10:19:51.190] - resignal: FALSE
[10:19:51.190] - force: TRUE
[10:19:51.190] - relayed: [n=1] FALSE
[10:19:51.190] - queued futures: [n=1] FALSE
[10:19:51.190]  - until=1
[10:19:51.191]  - relaying element #1
[10:19:51.191] - relayed: [n=1] TRUE
[10:19:51.192] - queued futures: [n=1] TRUE
[10:19:51.192] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.192]  length: 0 (resolved future 1)
[10:19:51.192] Relaying remaining futures
[10:19:51.192] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.192] - nx: 1
[10:19:51.192] - relay: TRUE
[10:19:51.192] - stdout: TRUE
[10:19:51.192] - signal: TRUE
[10:19:51.192] - resignal: FALSE
[10:19:51.192] - force: TRUE
[10:19:51.193] - relayed: [n=1] TRUE
[10:19:51.193] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.193] - relayed: [n=1] TRUE
[10:19:51.193] - queued futures: [n=1] TRUE
[10:19:51.193] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.193] resolve() on list ... DONE
[10:19:51.193]  - Number of value chunks collected: 1
[10:19:51.193] Resolving 1 futures (chunks) ... DONE
[10:19:51.193] Reducing values from 1 chunks ...
[10:19:51.193]  - Number of values collected after concatenation: 10
[10:19:51.194]  - Number of values expected: 10
[10:19:51.194] Reducing values from 1 chunks ... DONE
[10:19:51.194] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:19:51.195] future_lapply() ...
[10:19:51.196] Number of chunks: 1
[10:19:51.196] getGlobalsAndPackagesXApply() ...
[10:19:51.196]  - future.globals: TRUE
[10:19:51.196] getGlobalsAndPackages() ...
[10:19:51.196] Searching for globals...
[10:19:51.199] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:19:51.200] Searching for globals ... DONE
[10:19:51.200] Resolving globals: FALSE
[10:19:51.200] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[10:19:51.201] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.201] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.201] - packages: [1] ‘future.apply’
[10:19:51.201] getGlobalsAndPackages() ... DONE
[10:19:51.201]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.201]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.201] Finding globals ... DONE
[10:19:51.201]  - use_args: TRUE
[10:19:51.202]  - Getting '...' globals ...
[10:19:51.202] resolve() on list ...
[10:19:51.202]  recursive: 0
[10:19:51.202]  length: 1
[10:19:51.202]  elements: ‘...’
[10:19:51.202]  length: 0 (resolved future 1)
[10:19:51.202] resolve() on list ... DONE
[10:19:51.202]    - '...' content: [n=0] 
[10:19:51.202] List of 1
[10:19:51.202]  $ ...: list()
[10:19:51.202]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.202]  - attr(*, "where")=List of 1
[10:19:51.202]   ..$ ...:<environment: 0x55c69e1482b0> 
[10:19:51.202]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.202]  - attr(*, "resolved")= logi TRUE
[10:19:51.202]  - attr(*, "total_size")= num NA
[10:19:51.205]  - Getting '...' globals ... DONE
[10:19:51.205] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.205] List of 8
[10:19:51.205]  $ ...future.FUN:function (x, ...)  
[10:19:51.205]  $ x_FUN        :function (x)  
[10:19:51.205]  $ times        : int 0
[10:19:51.205]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.205]  $ stop_if_not  :function (...)  
[10:19:51.205]  $ dim          : NULL
[10:19:51.205]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:51.205]  $ ...          : list()
[10:19:51.205]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.205]  - attr(*, "where")=List of 8
[10:19:51.205]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.205]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.205]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.205]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.205]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.205]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.205]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.205]   ..$ ...          :<environment: 0x55c69e1482b0> 
[10:19:51.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.205]  - attr(*, "resolved")= logi FALSE
[10:19:51.205]  - attr(*, "total_size")= num 23453
[10:19:51.210] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.210] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.210] Number of futures (= number of chunks): 1
[10:19:51.210] Launching 1 futures (chunks) ...
[10:19:51.210] Chunk #1 of 1 ...
[10:19:51.210]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.210] getGlobalsAndPackages() ...
[10:19:51.210] Searching for globals...
[10:19:51.211] 
[10:19:51.211] Searching for globals ... DONE
[10:19:51.211] - globals: [0] <none>
[10:19:51.212] getGlobalsAndPackages() ... DONE
[10:19:51.212]    + additional globals found: [n=0] 
[10:19:51.212]    + additional namespaces needed: [n=0] 
[10:19:51.212]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.212]  - seeds: <none>
[10:19:51.212]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.212] getGlobalsAndPackages() ...
[10:19:51.212] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.212] Resolving globals: FALSE
[10:19:51.213] Tweak future expression to call with '...' arguments ...
[10:19:51.213] {
[10:19:51.213]     do.call(function(...) {
[10:19:51.213]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.213]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.213]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.213]             on.exit(options(oopts), add = TRUE)
[10:19:51.213]         }
[10:19:51.213]         {
[10:19:51.213]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.213]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.213]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.213]             })
[10:19:51.213]         }
[10:19:51.213]     }, args = future.call.arguments)
[10:19:51.213] }
[10:19:51.213] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.213] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.213] - packages: [1] ‘future.apply’
[10:19:51.214] getGlobalsAndPackages() ... DONE
[10:19:51.214] run() for ‘Future’ ...
[10:19:51.214] - state: ‘created’
[10:19:51.214] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.214]   - Field: ‘label’
[10:19:51.215]   - Field: ‘local’
[10:19:51.215]   - Field: ‘owner’
[10:19:51.215]   - Field: ‘envir’
[10:19:51.215]   - Field: ‘packages’
[10:19:51.215]   - Field: ‘gc’
[10:19:51.215]   - Field: ‘conditions’
[10:19:51.215]   - Field: ‘expr’
[10:19:51.215]   - Field: ‘uuid’
[10:19:51.215]   - Field: ‘seed’
[10:19:51.215]   - Field: ‘version’
[10:19:51.215]   - Field: ‘result’
[10:19:51.215]   - Field: ‘asynchronous’
[10:19:51.216]   - Field: ‘calls’
[10:19:51.216]   - Field: ‘globals’
[10:19:51.216]   - Field: ‘stdout’
[10:19:51.216]   - Field: ‘earlySignal’
[10:19:51.216]   - Field: ‘lazy’
[10:19:51.216]   - Field: ‘state’
[10:19:51.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.216] - Launch lazy future ...
[10:19:51.216] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.216] Packages needed by future strategies (n = 0): <none>
[10:19:51.217] {
[10:19:51.217]     {
[10:19:51.217]         {
[10:19:51.217]             ...future.startTime <- base::Sys.time()
[10:19:51.217]             {
[10:19:51.217]                 {
[10:19:51.217]                   {
[10:19:51.217]                     {
[10:19:51.217]                       base::local({
[10:19:51.217]                         has_future <- base::requireNamespace("future", 
[10:19:51.217]                           quietly = TRUE)
[10:19:51.217]                         if (has_future) {
[10:19:51.217]                           ns <- base::getNamespace("future")
[10:19:51.217]                           version <- ns[[".package"]][["version"]]
[10:19:51.217]                           if (is.null(version)) 
[10:19:51.217]                             version <- utils::packageVersion("future")
[10:19:51.217]                         }
[10:19:51.217]                         else {
[10:19:51.217]                           version <- NULL
[10:19:51.217]                         }
[10:19:51.217]                         if (!has_future || version < "1.8.0") {
[10:19:51.217]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.217]                             "", base::R.version$version.string), 
[10:19:51.217]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.217]                               "release", "version")], collapse = " "), 
[10:19:51.217]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.217]                             info)
[10:19:51.217]                           info <- base::paste(info, collapse = "; ")
[10:19:51.217]                           if (!has_future) {
[10:19:51.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.217]                               info)
[10:19:51.217]                           }
[10:19:51.217]                           else {
[10:19:51.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.217]                               info, version)
[10:19:51.217]                           }
[10:19:51.217]                           base::stop(msg)
[10:19:51.217]                         }
[10:19:51.217]                       })
[10:19:51.217]                     }
[10:19:51.217]                     base::local({
[10:19:51.217]                       for (pkg in "future.apply") {
[10:19:51.217]                         base::loadNamespace(pkg)
[10:19:51.217]                         base::library(pkg, character.only = TRUE)
[10:19:51.217]                       }
[10:19:51.217]                     })
[10:19:51.217]                   }
[10:19:51.217]                   ...future.strategy.old <- future::plan("list")
[10:19:51.217]                   options(future.plan = NULL)
[10:19:51.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.217]                 }
[10:19:51.217]                 ...future.workdir <- getwd()
[10:19:51.217]             }
[10:19:51.217]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.217]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.217]         }
[10:19:51.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.217]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.217]             base::names(...future.oldOptions))
[10:19:51.217]     }
[10:19:51.217]     if (FALSE) {
[10:19:51.217]     }
[10:19:51.217]     else {
[10:19:51.217]         if (TRUE) {
[10:19:51.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.217]                 open = "w")
[10:19:51.217]         }
[10:19:51.217]         else {
[10:19:51.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.217]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.217]         }
[10:19:51.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.217]             base::sink(type = "output", split = FALSE)
[10:19:51.217]             base::close(...future.stdout)
[10:19:51.217]         }, add = TRUE)
[10:19:51.217]     }
[10:19:51.217]     ...future.frame <- base::sys.nframe()
[10:19:51.217]     ...future.conditions <- base::list()
[10:19:51.217]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.217]     if (FALSE) {
[10:19:51.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.217]     }
[10:19:51.217]     ...future.result <- base::tryCatch({
[10:19:51.217]         base::withCallingHandlers({
[10:19:51.217]             ...future.value <- base::withVisible(base::local({
[10:19:51.217]                 do.call(function(...) {
[10:19:51.217]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.217]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.217]                     ...future.globals.maxSize)) {
[10:19:51.217]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.217]                     on.exit(options(oopts), add = TRUE)
[10:19:51.217]                   }
[10:19:51.217]                   {
[10:19:51.217]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.217]                       FUN = function(jj) {
[10:19:51.217]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.217]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.217]                       })
[10:19:51.217]                   }
[10:19:51.217]                 }, args = future.call.arguments)
[10:19:51.217]             }))
[10:19:51.217]             future::FutureResult(value = ...future.value$value, 
[10:19:51.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.217]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.217]                     ...future.globalenv.names))
[10:19:51.217]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.217]         }, condition = base::local({
[10:19:51.217]             c <- base::c
[10:19:51.217]             inherits <- base::inherits
[10:19:51.217]             invokeRestart <- base::invokeRestart
[10:19:51.217]             length <- base::length
[10:19:51.217]             list <- base::list
[10:19:51.217]             seq.int <- base::seq.int
[10:19:51.217]             signalCondition <- base::signalCondition
[10:19:51.217]             sys.calls <- base::sys.calls
[10:19:51.217]             `[[` <- base::`[[`
[10:19:51.217]             `+` <- base::`+`
[10:19:51.217]             `<<-` <- base::`<<-`
[10:19:51.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.217]                   3L)]
[10:19:51.217]             }
[10:19:51.217]             function(cond) {
[10:19:51.217]                 is_error <- inherits(cond, "error")
[10:19:51.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.217]                   NULL)
[10:19:51.217]                 if (is_error) {
[10:19:51.217]                   sessionInformation <- function() {
[10:19:51.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.217]                       search = base::search(), system = base::Sys.info())
[10:19:51.217]                   }
[10:19:51.217]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.217]                     cond$call), session = sessionInformation(), 
[10:19:51.217]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.217]                   signalCondition(cond)
[10:19:51.217]                 }
[10:19:51.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.217]                 "immediateCondition"))) {
[10:19:51.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.217]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.217]                   if (TRUE && !signal) {
[10:19:51.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.217]                     {
[10:19:51.217]                       inherits <- base::inherits
[10:19:51.217]                       invokeRestart <- base::invokeRestart
[10:19:51.217]                       is.null <- base::is.null
[10:19:51.217]                       muffled <- FALSE
[10:19:51.217]                       if (inherits(cond, "message")) {
[10:19:51.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.217]                         if (muffled) 
[10:19:51.217]                           invokeRestart("muffleMessage")
[10:19:51.217]                       }
[10:19:51.217]                       else if (inherits(cond, "warning")) {
[10:19:51.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.217]                         if (muffled) 
[10:19:51.217]                           invokeRestart("muffleWarning")
[10:19:51.217]                       }
[10:19:51.217]                       else if (inherits(cond, "condition")) {
[10:19:51.217]                         if (!is.null(pattern)) {
[10:19:51.217]                           computeRestarts <- base::computeRestarts
[10:19:51.217]                           grepl <- base::grepl
[10:19:51.217]                           restarts <- computeRestarts(cond)
[10:19:51.217]                           for (restart in restarts) {
[10:19:51.217]                             name <- restart$name
[10:19:51.217]                             if (is.null(name)) 
[10:19:51.217]                               next
[10:19:51.217]                             if (!grepl(pattern, name)) 
[10:19:51.217]                               next
[10:19:51.217]                             invokeRestart(restart)
[10:19:51.217]                             muffled <- TRUE
[10:19:51.217]                             break
[10:19:51.217]                           }
[10:19:51.217]                         }
[10:19:51.217]                       }
[10:19:51.217]                       invisible(muffled)
[10:19:51.217]                     }
[10:19:51.217]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.217]                   }
[10:19:51.217]                 }
[10:19:51.217]                 else {
[10:19:51.217]                   if (TRUE) {
[10:19:51.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.217]                     {
[10:19:51.217]                       inherits <- base::inherits
[10:19:51.217]                       invokeRestart <- base::invokeRestart
[10:19:51.217]                       is.null <- base::is.null
[10:19:51.217]                       muffled <- FALSE
[10:19:51.217]                       if (inherits(cond, "message")) {
[10:19:51.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.217]                         if (muffled) 
[10:19:51.217]                           invokeRestart("muffleMessage")
[10:19:51.217]                       }
[10:19:51.217]                       else if (inherits(cond, "warning")) {
[10:19:51.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.217]                         if (muffled) 
[10:19:51.217]                           invokeRestart("muffleWarning")
[10:19:51.217]                       }
[10:19:51.217]                       else if (inherits(cond, "condition")) {
[10:19:51.217]                         if (!is.null(pattern)) {
[10:19:51.217]                           computeRestarts <- base::computeRestarts
[10:19:51.217]                           grepl <- base::grepl
[10:19:51.217]                           restarts <- computeRestarts(cond)
[10:19:51.217]                           for (restart in restarts) {
[10:19:51.217]                             name <- restart$name
[10:19:51.217]                             if (is.null(name)) 
[10:19:51.217]                               next
[10:19:51.217]                             if (!grepl(pattern, name)) 
[10:19:51.217]                               next
[10:19:51.217]                             invokeRestart(restart)
[10:19:51.217]                             muffled <- TRUE
[10:19:51.217]                             break
[10:19:51.217]                           }
[10:19:51.217]                         }
[10:19:51.217]                       }
[10:19:51.217]                       invisible(muffled)
[10:19:51.217]                     }
[10:19:51.217]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.217]                   }
[10:19:51.217]                 }
[10:19:51.217]             }
[10:19:51.217]         }))
[10:19:51.217]     }, error = function(ex) {
[10:19:51.217]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.217]                 ...future.rng), started = ...future.startTime, 
[10:19:51.217]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.217]             version = "1.8"), class = "FutureResult")
[10:19:51.217]     }, finally = {
[10:19:51.217]         if (!identical(...future.workdir, getwd())) 
[10:19:51.217]             setwd(...future.workdir)
[10:19:51.217]         {
[10:19:51.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.217]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.217]             }
[10:19:51.217]             base::options(...future.oldOptions)
[10:19:51.217]             if (.Platform$OS.type == "windows") {
[10:19:51.217]                 old_names <- names(...future.oldEnvVars)
[10:19:51.217]                 envs <- base::Sys.getenv()
[10:19:51.217]                 names <- names(envs)
[10:19:51.217]                 common <- intersect(names, old_names)
[10:19:51.217]                 added <- setdiff(names, old_names)
[10:19:51.217]                 removed <- setdiff(old_names, names)
[10:19:51.217]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.217]                   envs[common]]
[10:19:51.217]                 NAMES <- toupper(changed)
[10:19:51.217]                 args <- list()
[10:19:51.217]                 for (kk in seq_along(NAMES)) {
[10:19:51.217]                   name <- changed[[kk]]
[10:19:51.217]                   NAME <- NAMES[[kk]]
[10:19:51.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.217]                     next
[10:19:51.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.217]                 }
[10:19:51.217]                 NAMES <- toupper(added)
[10:19:51.217]                 for (kk in seq_along(NAMES)) {
[10:19:51.217]                   name <- added[[kk]]
[10:19:51.217]                   NAME <- NAMES[[kk]]
[10:19:51.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.217]                     next
[10:19:51.217]                   args[[name]] <- ""
[10:19:51.217]                 }
[10:19:51.217]                 NAMES <- toupper(removed)
[10:19:51.217]                 for (kk in seq_along(NAMES)) {
[10:19:51.217]                   name <- removed[[kk]]
[10:19:51.217]                   NAME <- NAMES[[kk]]
[10:19:51.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.217]                     next
[10:19:51.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.217]                 }
[10:19:51.217]                 if (length(args) > 0) 
[10:19:51.217]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.217]             }
[10:19:51.217]             else {
[10:19:51.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.217]             }
[10:19:51.217]             {
[10:19:51.217]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.217]                   0L) {
[10:19:51.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.217]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.217]                   base::options(opts)
[10:19:51.217]                 }
[10:19:51.217]                 {
[10:19:51.217]                   {
[10:19:51.217]                     NULL
[10:19:51.217]                     RNGkind("Mersenne-Twister")
[10:19:51.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.217]                       inherits = FALSE)
[10:19:51.217]                   }
[10:19:51.217]                   options(future.plan = NULL)
[10:19:51.217]                   if (is.na(NA_character_)) 
[10:19:51.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.217]                     .init = FALSE)
[10:19:51.217]                 }
[10:19:51.217]             }
[10:19:51.217]         }
[10:19:51.217]     })
[10:19:51.217]     if (TRUE) {
[10:19:51.217]         base::sink(type = "output", split = FALSE)
[10:19:51.217]         if (TRUE) {
[10:19:51.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.217]         }
[10:19:51.217]         else {
[10:19:51.217]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.217]         }
[10:19:51.217]         base::close(...future.stdout)
[10:19:51.217]         ...future.stdout <- NULL
[10:19:51.217]     }
[10:19:51.217]     ...future.result$conditions <- ...future.conditions
[10:19:51.217]     ...future.result$finished <- base::Sys.time()
[10:19:51.217]     ...future.result
[10:19:51.217] }
[10:19:51.219] assign_globals() ...
[10:19:51.219] List of 11
[10:19:51.219]  $ ...future.FUN            :function (x, ...)  
[10:19:51.219]  $ x_FUN                    :function (x)  
[10:19:51.219]  $ times                    : int 0
[10:19:51.219]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.219]  $ stop_if_not              :function (...)  
[10:19:51.219]  $ dim                      : NULL
[10:19:51.219]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:51.219]  $ future.call.arguments    : list()
[10:19:51.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.219]  $ ...future.elements_ii    :List of 10
[10:19:51.219]   ..$ : int 1
[10:19:51.219]   ..$ : int 2
[10:19:51.219]   ..$ : int 3
[10:19:51.219]   ..$ : int 4
[10:19:51.219]   ..$ : int 5
[10:19:51.219]   ..$ : int 6
[10:19:51.219]   ..$ : int 7
[10:19:51.219]   ..$ : int 8
[10:19:51.219]   ..$ : int 9
[10:19:51.219]   ..$ : int 10
[10:19:51.219]  $ ...future.seeds_ii       : NULL
[10:19:51.219]  $ ...future.globals.maxSize: NULL
[10:19:51.219]  - attr(*, "where")=List of 11
[10:19:51.219]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.219]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.219]  - attr(*, "resolved")= logi FALSE
[10:19:51.219]  - attr(*, "total_size")= num 23453
[10:19:51.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.219]  - attr(*, "already-done")= logi TRUE
[10:19:51.228] - copied ‘...future.FUN’ to environment
[10:19:51.228] - reassign environment for ‘x_FUN’
[10:19:51.228] - copied ‘x_FUN’ to environment
[10:19:51.228] - copied ‘times’ to environment
[10:19:51.228] - copied ‘stopf’ to environment
[10:19:51.229] - copied ‘stop_if_not’ to environment
[10:19:51.229] - copied ‘dim’ to environment
[10:19:51.229] - copied ‘valid_types’ to environment
[10:19:51.229] - copied ‘future.call.arguments’ to environment
[10:19:51.229] - copied ‘...future.elements_ii’ to environment
[10:19:51.229] - copied ‘...future.seeds_ii’ to environment
[10:19:51.229] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.229] assign_globals() ... done
[10:19:51.230] plan(): Setting new future strategy stack:
[10:19:51.230] List of future strategies:
[10:19:51.230] 1. sequential:
[10:19:51.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.230]    - tweaked: FALSE
[10:19:51.230]    - call: NULL
[10:19:51.230] plan(): nbrOfWorkers() = 1
[10:19:51.231] plan(): Setting new future strategy stack:
[10:19:51.231] List of future strategies:
[10:19:51.231] 1. sequential:
[10:19:51.231]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.231]    - tweaked: FALSE
[10:19:51.231]    - call: plan(strategy)
[10:19:51.231] plan(): nbrOfWorkers() = 1
[10:19:51.232] SequentialFuture started (and completed)
[10:19:51.232] - Launch lazy future ... done
[10:19:51.232] run() for ‘SequentialFuture’ ... done
[10:19:51.232] Created future:
[10:19:51.232] SequentialFuture:
[10:19:51.232] Label: ‘future_vapply-1’
[10:19:51.232] Expression:
[10:19:51.232] {
[10:19:51.232]     do.call(function(...) {
[10:19:51.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.232]             on.exit(options(oopts), add = TRUE)
[10:19:51.232]         }
[10:19:51.232]         {
[10:19:51.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.232]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.232]             })
[10:19:51.232]         }
[10:19:51.232]     }, args = future.call.arguments)
[10:19:51.232] }
[10:19:51.232] Lazy evaluation: FALSE
[10:19:51.232] Asynchronous evaluation: FALSE
[10:19:51.232] Local evaluation: TRUE
[10:19:51.232] Environment: R_GlobalEnv
[10:19:51.232] Capture standard output: TRUE
[10:19:51.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.232] Globals: 11 objects totaling 13.04 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.232] Packages: 1 packages (‘future.apply’)
[10:19:51.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.232] Resolved: TRUE
[10:19:51.232] Value: 111 bytes of class ‘list’
[10:19:51.232] Early signaling: FALSE
[10:19:51.232] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.232] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.233] Chunk #1 of 1 ... DONE
[10:19:51.233] Launching 1 futures (chunks) ... DONE
[10:19:51.233] Resolving 1 futures (chunks) ...
[10:19:51.233] resolve() on list ...
[10:19:51.233]  recursive: 0
[10:19:51.233]  length: 1
[10:19:51.233] 
[10:19:51.234] resolved() for ‘SequentialFuture’ ...
[10:19:51.234] - state: ‘finished’
[10:19:51.234] - run: TRUE
[10:19:51.236] - result: ‘FutureResult’
[10:19:51.236] resolved() for ‘SequentialFuture’ ... done
[10:19:51.236] Future #1
[10:19:51.236] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.236] - nx: 1
[10:19:51.236] - relay: TRUE
[10:19:51.236] - stdout: TRUE
[10:19:51.236] - signal: TRUE
[10:19:51.236] - resignal: FALSE
[10:19:51.236] - force: TRUE
[10:19:51.237] - relayed: [n=1] FALSE
[10:19:51.237] - queued futures: [n=1] FALSE
[10:19:51.237]  - until=1
[10:19:51.237]  - relaying element #1
[10:19:51.237] - relayed: [n=1] TRUE
[10:19:51.237] - queued futures: [n=1] TRUE
[10:19:51.237] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.237]  length: 0 (resolved future 1)
[10:19:51.237] Relaying remaining futures
[10:19:51.237] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.237] - nx: 1
[10:19:51.238] - relay: TRUE
[10:19:51.238] - stdout: TRUE
[10:19:51.238] - signal: TRUE
[10:19:51.238] - resignal: FALSE
[10:19:51.238] - force: TRUE
[10:19:51.238] - relayed: [n=1] TRUE
[10:19:51.238] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.238] - relayed: [n=1] TRUE
[10:19:51.238] - queued futures: [n=1] TRUE
[10:19:51.238] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.238] resolve() on list ... DONE
[10:19:51.239]  - Number of value chunks collected: 1
[10:19:51.239] Resolving 1 futures (chunks) ... DONE
[10:19:51.239] Reducing values from 1 chunks ...
[10:19:51.239]  - Number of values collected after concatenation: 10
[10:19:51.239]  - Number of values expected: 10
[10:19:51.239] Reducing values from 1 chunks ... DONE
[10:19:51.239] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:19:51.240] future_lapply() ...
[10:19:51.242] Number of chunks: 1
[10:19:51.242] getGlobalsAndPackagesXApply() ...
[10:19:51.242]  - future.globals: TRUE
[10:19:51.242] getGlobalsAndPackages() ...
[10:19:51.242] Searching for globals...
[10:19:51.245] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:51.245] Searching for globals ... DONE
[10:19:51.245] Resolving globals: FALSE
[10:19:51.246] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[10:19:51.246] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.246] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.246] - packages: [1] ‘future.apply’
[10:19:51.247] getGlobalsAndPackages() ... DONE
[10:19:51.247]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.247]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.247] Finding globals ... DONE
[10:19:51.247]  - use_args: TRUE
[10:19:51.247]  - Getting '...' globals ...
[10:19:51.247] resolve() on list ...
[10:19:51.247]  recursive: 0
[10:19:51.247]  length: 1
[10:19:51.248]  elements: ‘...’
[10:19:51.248]  length: 0 (resolved future 1)
[10:19:51.248] resolve() on list ... DONE
[10:19:51.248]    - '...' content: [n=0] 
[10:19:51.248] List of 1
[10:19:51.248]  $ ...: list()
[10:19:51.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.248]  - attr(*, "where")=List of 1
[10:19:51.248]   ..$ ...:<environment: 0x55c69d830608> 
[10:19:51.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.248]  - attr(*, "resolved")= logi TRUE
[10:19:51.248]  - attr(*, "total_size")= num NA
[10:19:51.250]  - Getting '...' globals ... DONE
[10:19:51.250] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.251] List of 8
[10:19:51.251]  $ ...future.FUN:function (x, ...)  
[10:19:51.251]  $ x_FUN        :function (x)  
[10:19:51.251]  $ times        : int 1
[10:19:51.251]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.251]  $ stop_if_not  :function (...)  
[10:19:51.251]  $ dim          : NULL
[10:19:51.251]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.251]  $ ...          : list()
[10:19:51.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.251]  - attr(*, "where")=List of 8
[10:19:51.251]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.251]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.251]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.251]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.251]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.251]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.251]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.251]   ..$ ...          :<environment: 0x55c69d830608> 
[10:19:51.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.251]  - attr(*, "resolved")= logi FALSE
[10:19:51.251]  - attr(*, "total_size")= num 22322
[10:19:51.256] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.256] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.257] Number of futures (= number of chunks): 1
[10:19:51.258] Launching 1 futures (chunks) ...
[10:19:51.258] Chunk #1 of 1 ...
[10:19:51.258]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.258] getGlobalsAndPackages() ...
[10:19:51.258] Searching for globals...
[10:19:51.258] 
[10:19:51.258] Searching for globals ... DONE
[10:19:51.258] - globals: [0] <none>
[10:19:51.258] getGlobalsAndPackages() ... DONE
[10:19:51.258]    + additional globals found: [n=0] 
[10:19:51.259]    + additional namespaces needed: [n=0] 
[10:19:51.259]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.259]  - seeds: <none>
[10:19:51.259]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.259] getGlobalsAndPackages() ...
[10:19:51.259] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.259] Resolving globals: FALSE
[10:19:51.259] Tweak future expression to call with '...' arguments ...
[10:19:51.259] {
[10:19:51.259]     do.call(function(...) {
[10:19:51.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.259]             on.exit(options(oopts), add = TRUE)
[10:19:51.259]         }
[10:19:51.259]         {
[10:19:51.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.259]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.259]             })
[10:19:51.259]         }
[10:19:51.259]     }, args = future.call.arguments)
[10:19:51.259] }
[10:19:51.260] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.260] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.260] - packages: [1] ‘future.apply’
[10:19:51.260] getGlobalsAndPackages() ... DONE
[10:19:51.261] run() for ‘Future’ ...
[10:19:51.261] - state: ‘created’
[10:19:51.261] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.261] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.261]   - Field: ‘label’
[10:19:51.261]   - Field: ‘local’
[10:19:51.262]   - Field: ‘owner’
[10:19:51.262]   - Field: ‘envir’
[10:19:51.262]   - Field: ‘packages’
[10:19:51.262]   - Field: ‘gc’
[10:19:51.262]   - Field: ‘conditions’
[10:19:51.262]   - Field: ‘expr’
[10:19:51.262]   - Field: ‘uuid’
[10:19:51.262]   - Field: ‘seed’
[10:19:51.262]   - Field: ‘version’
[10:19:51.262]   - Field: ‘result’
[10:19:51.262]   - Field: ‘asynchronous’
[10:19:51.263]   - Field: ‘calls’
[10:19:51.263]   - Field: ‘globals’
[10:19:51.263]   - Field: ‘stdout’
[10:19:51.263]   - Field: ‘earlySignal’
[10:19:51.263]   - Field: ‘lazy’
[10:19:51.263]   - Field: ‘state’
[10:19:51.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.263] - Launch lazy future ...
[10:19:51.263] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.263] Packages needed by future strategies (n = 0): <none>
[10:19:51.264] {
[10:19:51.264]     {
[10:19:51.264]         {
[10:19:51.264]             ...future.startTime <- base::Sys.time()
[10:19:51.264]             {
[10:19:51.264]                 {
[10:19:51.264]                   {
[10:19:51.264]                     {
[10:19:51.264]                       base::local({
[10:19:51.264]                         has_future <- base::requireNamespace("future", 
[10:19:51.264]                           quietly = TRUE)
[10:19:51.264]                         if (has_future) {
[10:19:51.264]                           ns <- base::getNamespace("future")
[10:19:51.264]                           version <- ns[[".package"]][["version"]]
[10:19:51.264]                           if (is.null(version)) 
[10:19:51.264]                             version <- utils::packageVersion("future")
[10:19:51.264]                         }
[10:19:51.264]                         else {
[10:19:51.264]                           version <- NULL
[10:19:51.264]                         }
[10:19:51.264]                         if (!has_future || version < "1.8.0") {
[10:19:51.264]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.264]                             "", base::R.version$version.string), 
[10:19:51.264]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.264]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.264]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.264]                               "release", "version")], collapse = " "), 
[10:19:51.264]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.264]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.264]                             info)
[10:19:51.264]                           info <- base::paste(info, collapse = "; ")
[10:19:51.264]                           if (!has_future) {
[10:19:51.264]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.264]                               info)
[10:19:51.264]                           }
[10:19:51.264]                           else {
[10:19:51.264]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.264]                               info, version)
[10:19:51.264]                           }
[10:19:51.264]                           base::stop(msg)
[10:19:51.264]                         }
[10:19:51.264]                       })
[10:19:51.264]                     }
[10:19:51.264]                     base::local({
[10:19:51.264]                       for (pkg in "future.apply") {
[10:19:51.264]                         base::loadNamespace(pkg)
[10:19:51.264]                         base::library(pkg, character.only = TRUE)
[10:19:51.264]                       }
[10:19:51.264]                     })
[10:19:51.264]                   }
[10:19:51.264]                   ...future.strategy.old <- future::plan("list")
[10:19:51.264]                   options(future.plan = NULL)
[10:19:51.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.264]                 }
[10:19:51.264]                 ...future.workdir <- getwd()
[10:19:51.264]             }
[10:19:51.264]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.264]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.264]         }
[10:19:51.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.264]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.264]             base::names(...future.oldOptions))
[10:19:51.264]     }
[10:19:51.264]     if (FALSE) {
[10:19:51.264]     }
[10:19:51.264]     else {
[10:19:51.264]         if (TRUE) {
[10:19:51.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.264]                 open = "w")
[10:19:51.264]         }
[10:19:51.264]         else {
[10:19:51.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.264]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.264]         }
[10:19:51.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.264]             base::sink(type = "output", split = FALSE)
[10:19:51.264]             base::close(...future.stdout)
[10:19:51.264]         }, add = TRUE)
[10:19:51.264]     }
[10:19:51.264]     ...future.frame <- base::sys.nframe()
[10:19:51.264]     ...future.conditions <- base::list()
[10:19:51.264]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.264]     if (FALSE) {
[10:19:51.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.264]     }
[10:19:51.264]     ...future.result <- base::tryCatch({
[10:19:51.264]         base::withCallingHandlers({
[10:19:51.264]             ...future.value <- base::withVisible(base::local({
[10:19:51.264]                 do.call(function(...) {
[10:19:51.264]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.264]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.264]                     ...future.globals.maxSize)) {
[10:19:51.264]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.264]                     on.exit(options(oopts), add = TRUE)
[10:19:51.264]                   }
[10:19:51.264]                   {
[10:19:51.264]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.264]                       FUN = function(jj) {
[10:19:51.264]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.264]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.264]                       })
[10:19:51.264]                   }
[10:19:51.264]                 }, args = future.call.arguments)
[10:19:51.264]             }))
[10:19:51.264]             future::FutureResult(value = ...future.value$value, 
[10:19:51.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.264]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.264]                     ...future.globalenv.names))
[10:19:51.264]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.264]         }, condition = base::local({
[10:19:51.264]             c <- base::c
[10:19:51.264]             inherits <- base::inherits
[10:19:51.264]             invokeRestart <- base::invokeRestart
[10:19:51.264]             length <- base::length
[10:19:51.264]             list <- base::list
[10:19:51.264]             seq.int <- base::seq.int
[10:19:51.264]             signalCondition <- base::signalCondition
[10:19:51.264]             sys.calls <- base::sys.calls
[10:19:51.264]             `[[` <- base::`[[`
[10:19:51.264]             `+` <- base::`+`
[10:19:51.264]             `<<-` <- base::`<<-`
[10:19:51.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.264]                   3L)]
[10:19:51.264]             }
[10:19:51.264]             function(cond) {
[10:19:51.264]                 is_error <- inherits(cond, "error")
[10:19:51.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.264]                   NULL)
[10:19:51.264]                 if (is_error) {
[10:19:51.264]                   sessionInformation <- function() {
[10:19:51.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.264]                       search = base::search(), system = base::Sys.info())
[10:19:51.264]                   }
[10:19:51.264]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.264]                     cond$call), session = sessionInformation(), 
[10:19:51.264]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.264]                   signalCondition(cond)
[10:19:51.264]                 }
[10:19:51.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.264]                 "immediateCondition"))) {
[10:19:51.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.264]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.264]                   if (TRUE && !signal) {
[10:19:51.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.264]                     {
[10:19:51.264]                       inherits <- base::inherits
[10:19:51.264]                       invokeRestart <- base::invokeRestart
[10:19:51.264]                       is.null <- base::is.null
[10:19:51.264]                       muffled <- FALSE
[10:19:51.264]                       if (inherits(cond, "message")) {
[10:19:51.264]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.264]                         if (muffled) 
[10:19:51.264]                           invokeRestart("muffleMessage")
[10:19:51.264]                       }
[10:19:51.264]                       else if (inherits(cond, "warning")) {
[10:19:51.264]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.264]                         if (muffled) 
[10:19:51.264]                           invokeRestart("muffleWarning")
[10:19:51.264]                       }
[10:19:51.264]                       else if (inherits(cond, "condition")) {
[10:19:51.264]                         if (!is.null(pattern)) {
[10:19:51.264]                           computeRestarts <- base::computeRestarts
[10:19:51.264]                           grepl <- base::grepl
[10:19:51.264]                           restarts <- computeRestarts(cond)
[10:19:51.264]                           for (restart in restarts) {
[10:19:51.264]                             name <- restart$name
[10:19:51.264]                             if (is.null(name)) 
[10:19:51.264]                               next
[10:19:51.264]                             if (!grepl(pattern, name)) 
[10:19:51.264]                               next
[10:19:51.264]                             invokeRestart(restart)
[10:19:51.264]                             muffled <- TRUE
[10:19:51.264]                             break
[10:19:51.264]                           }
[10:19:51.264]                         }
[10:19:51.264]                       }
[10:19:51.264]                       invisible(muffled)
[10:19:51.264]                     }
[10:19:51.264]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.264]                   }
[10:19:51.264]                 }
[10:19:51.264]                 else {
[10:19:51.264]                   if (TRUE) {
[10:19:51.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.264]                     {
[10:19:51.264]                       inherits <- base::inherits
[10:19:51.264]                       invokeRestart <- base::invokeRestart
[10:19:51.264]                       is.null <- base::is.null
[10:19:51.264]                       muffled <- FALSE
[10:19:51.264]                       if (inherits(cond, "message")) {
[10:19:51.264]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.264]                         if (muffled) 
[10:19:51.264]                           invokeRestart("muffleMessage")
[10:19:51.264]                       }
[10:19:51.264]                       else if (inherits(cond, "warning")) {
[10:19:51.264]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.264]                         if (muffled) 
[10:19:51.264]                           invokeRestart("muffleWarning")
[10:19:51.264]                       }
[10:19:51.264]                       else if (inherits(cond, "condition")) {
[10:19:51.264]                         if (!is.null(pattern)) {
[10:19:51.264]                           computeRestarts <- base::computeRestarts
[10:19:51.264]                           grepl <- base::grepl
[10:19:51.264]                           restarts <- computeRestarts(cond)
[10:19:51.264]                           for (restart in restarts) {
[10:19:51.264]                             name <- restart$name
[10:19:51.264]                             if (is.null(name)) 
[10:19:51.264]                               next
[10:19:51.264]                             if (!grepl(pattern, name)) 
[10:19:51.264]                               next
[10:19:51.264]                             invokeRestart(restart)
[10:19:51.264]                             muffled <- TRUE
[10:19:51.264]                             break
[10:19:51.264]                           }
[10:19:51.264]                         }
[10:19:51.264]                       }
[10:19:51.264]                       invisible(muffled)
[10:19:51.264]                     }
[10:19:51.264]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.264]                   }
[10:19:51.264]                 }
[10:19:51.264]             }
[10:19:51.264]         }))
[10:19:51.264]     }, error = function(ex) {
[10:19:51.264]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.264]                 ...future.rng), started = ...future.startTime, 
[10:19:51.264]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.264]             version = "1.8"), class = "FutureResult")
[10:19:51.264]     }, finally = {
[10:19:51.264]         if (!identical(...future.workdir, getwd())) 
[10:19:51.264]             setwd(...future.workdir)
[10:19:51.264]         {
[10:19:51.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.264]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.264]             }
[10:19:51.264]             base::options(...future.oldOptions)
[10:19:51.264]             if (.Platform$OS.type == "windows") {
[10:19:51.264]                 old_names <- names(...future.oldEnvVars)
[10:19:51.264]                 envs <- base::Sys.getenv()
[10:19:51.264]                 names <- names(envs)
[10:19:51.264]                 common <- intersect(names, old_names)
[10:19:51.264]                 added <- setdiff(names, old_names)
[10:19:51.264]                 removed <- setdiff(old_names, names)
[10:19:51.264]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.264]                   envs[common]]
[10:19:51.264]                 NAMES <- toupper(changed)
[10:19:51.264]                 args <- list()
[10:19:51.264]                 for (kk in seq_along(NAMES)) {
[10:19:51.264]                   name <- changed[[kk]]
[10:19:51.264]                   NAME <- NAMES[[kk]]
[10:19:51.264]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.264]                     next
[10:19:51.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.264]                 }
[10:19:51.264]                 NAMES <- toupper(added)
[10:19:51.264]                 for (kk in seq_along(NAMES)) {
[10:19:51.264]                   name <- added[[kk]]
[10:19:51.264]                   NAME <- NAMES[[kk]]
[10:19:51.264]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.264]                     next
[10:19:51.264]                   args[[name]] <- ""
[10:19:51.264]                 }
[10:19:51.264]                 NAMES <- toupper(removed)
[10:19:51.264]                 for (kk in seq_along(NAMES)) {
[10:19:51.264]                   name <- removed[[kk]]
[10:19:51.264]                   NAME <- NAMES[[kk]]
[10:19:51.264]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.264]                     next
[10:19:51.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.264]                 }
[10:19:51.264]                 if (length(args) > 0) 
[10:19:51.264]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.264]             }
[10:19:51.264]             else {
[10:19:51.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.264]             }
[10:19:51.264]             {
[10:19:51.264]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.264]                   0L) {
[10:19:51.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.264]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.264]                   base::options(opts)
[10:19:51.264]                 }
[10:19:51.264]                 {
[10:19:51.264]                   {
[10:19:51.264]                     NULL
[10:19:51.264]                     RNGkind("Mersenne-Twister")
[10:19:51.264]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.264]                       inherits = FALSE)
[10:19:51.264]                   }
[10:19:51.264]                   options(future.plan = NULL)
[10:19:51.264]                   if (is.na(NA_character_)) 
[10:19:51.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.264]                     .init = FALSE)
[10:19:51.264]                 }
[10:19:51.264]             }
[10:19:51.264]         }
[10:19:51.264]     })
[10:19:51.264]     if (TRUE) {
[10:19:51.264]         base::sink(type = "output", split = FALSE)
[10:19:51.264]         if (TRUE) {
[10:19:51.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.264]         }
[10:19:51.264]         else {
[10:19:51.264]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.264]         }
[10:19:51.264]         base::close(...future.stdout)
[10:19:51.264]         ...future.stdout <- NULL
[10:19:51.264]     }
[10:19:51.264]     ...future.result$conditions <- ...future.conditions
[10:19:51.264]     ...future.result$finished <- base::Sys.time()
[10:19:51.264]     ...future.result
[10:19:51.264] }
[10:19:51.266] assign_globals() ...
[10:19:51.266] List of 11
[10:19:51.266]  $ ...future.FUN            :function (x, ...)  
[10:19:51.266]  $ x_FUN                    :function (x)  
[10:19:51.266]  $ times                    : int 1
[10:19:51.266]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.266]  $ stop_if_not              :function (...)  
[10:19:51.266]  $ dim                      : NULL
[10:19:51.266]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.266]  $ future.call.arguments    : list()
[10:19:51.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.266]  $ ...future.elements_ii    :List of 10
[10:19:51.266]   ..$ : int 1
[10:19:51.266]   ..$ : int 2
[10:19:51.266]   ..$ : int 3
[10:19:51.266]   ..$ : int 4
[10:19:51.266]   ..$ : int 5
[10:19:51.266]   ..$ : int 6
[10:19:51.266]   ..$ : int 7
[10:19:51.266]   ..$ : int 8
[10:19:51.266]   ..$ : int 9
[10:19:51.266]   ..$ : int 10
[10:19:51.266]  $ ...future.seeds_ii       : NULL
[10:19:51.266]  $ ...future.globals.maxSize: NULL
[10:19:51.266]  - attr(*, "where")=List of 11
[10:19:51.266]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.266]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.266]  - attr(*, "resolved")= logi FALSE
[10:19:51.266]  - attr(*, "total_size")= num 22322
[10:19:51.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.266]  - attr(*, "already-done")= logi TRUE
[10:19:51.275] - copied ‘...future.FUN’ to environment
[10:19:51.275] - copied ‘x_FUN’ to environment
[10:19:51.275] - copied ‘times’ to environment
[10:19:51.275] - copied ‘stopf’ to environment
[10:19:51.276] - copied ‘stop_if_not’ to environment
[10:19:51.276] - copied ‘dim’ to environment
[10:19:51.276] - copied ‘valid_types’ to environment
[10:19:51.276] - copied ‘future.call.arguments’ to environment
[10:19:51.276] - copied ‘...future.elements_ii’ to environment
[10:19:51.276] - copied ‘...future.seeds_ii’ to environment
[10:19:51.276] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.276] assign_globals() ... done
[10:19:51.276] plan(): Setting new future strategy stack:
[10:19:51.277] List of future strategies:
[10:19:51.277] 1. sequential:
[10:19:51.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.277]    - tweaked: FALSE
[10:19:51.277]    - call: NULL
[10:19:51.277] plan(): nbrOfWorkers() = 1
[10:19:51.278] plan(): Setting new future strategy stack:
[10:19:51.278] List of future strategies:
[10:19:51.278] 1. sequential:
[10:19:51.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.278]    - tweaked: FALSE
[10:19:51.278]    - call: plan(strategy)
[10:19:51.278] plan(): nbrOfWorkers() = 1
[10:19:51.279] SequentialFuture started (and completed)
[10:19:51.279] - Launch lazy future ... done
[10:19:51.279] run() for ‘SequentialFuture’ ... done
[10:19:51.279] Created future:
[10:19:51.279] SequentialFuture:
[10:19:51.279] Label: ‘future_vapply-1’
[10:19:51.279] Expression:
[10:19:51.279] {
[10:19:51.279]     do.call(function(...) {
[10:19:51.279]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.279]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.279]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.279]             on.exit(options(oopts), add = TRUE)
[10:19:51.279]         }
[10:19:51.279]         {
[10:19:51.279]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.279]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.279]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.279]             })
[10:19:51.279]         }
[10:19:51.279]     }, args = future.call.arguments)
[10:19:51.279] }
[10:19:51.279] Lazy evaluation: FALSE
[10:19:51.279] Asynchronous evaluation: FALSE
[10:19:51.279] Local evaluation: TRUE
[10:19:51.279] Environment: R_GlobalEnv
[10:19:51.279] Capture standard output: TRUE
[10:19:51.279] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.279] Globals: 11 objects totaling 12.37 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.279] Packages: 1 packages (‘future.apply’)
[10:19:51.279] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.279] Resolved: TRUE
[10:19:51.279] Value: 191 bytes of class ‘list’
[10:19:51.279] Early signaling: FALSE
[10:19:51.279] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.279] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.282] Chunk #1 of 1 ... DONE
[10:19:51.282] Launching 1 futures (chunks) ... DONE
[10:19:51.282] Resolving 1 futures (chunks) ...
[10:19:51.282] resolve() on list ...
[10:19:51.282]  recursive: 0
[10:19:51.282]  length: 1
[10:19:51.282] 
[10:19:51.282] resolved() for ‘SequentialFuture’ ...
[10:19:51.282] - state: ‘finished’
[10:19:51.282] - run: TRUE
[10:19:51.282] - result: ‘FutureResult’
[10:19:51.283] resolved() for ‘SequentialFuture’ ... done
[10:19:51.283] Future #1
[10:19:51.283] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.283] - nx: 1
[10:19:51.283] - relay: TRUE
[10:19:51.283] - stdout: TRUE
[10:19:51.283] - signal: TRUE
[10:19:51.283] - resignal: FALSE
[10:19:51.283] - force: TRUE
[10:19:51.283] - relayed: [n=1] FALSE
[10:19:51.283] - queued futures: [n=1] FALSE
[10:19:51.284]  - until=1
[10:19:51.284]  - relaying element #1
[10:19:51.284] - relayed: [n=1] TRUE
[10:19:51.284] - queued futures: [n=1] TRUE
[10:19:51.284] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.284]  length: 0 (resolved future 1)
[10:19:51.284] Relaying remaining futures
[10:19:51.284] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.284] - nx: 1
[10:19:51.284] - relay: TRUE
[10:19:51.284] - stdout: TRUE
[10:19:51.285] - signal: TRUE
[10:19:51.285] - resignal: FALSE
[10:19:51.285] - force: TRUE
[10:19:51.285] - relayed: [n=1] TRUE
[10:19:51.285] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.285] - relayed: [n=1] TRUE
[10:19:51.285] - queued futures: [n=1] TRUE
[10:19:51.285] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.285] resolve() on list ... DONE
[10:19:51.285]  - Number of value chunks collected: 1
[10:19:51.285] Resolving 1 futures (chunks) ... DONE
[10:19:51.286] Reducing values from 1 chunks ...
[10:19:51.286]  - Number of values collected after concatenation: 10
[10:19:51.286]  - Number of values expected: 10
[10:19:51.286] Reducing values from 1 chunks ... DONE
[10:19:51.286] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:19:51.287] future_lapply() ...
[10:19:51.288] Number of chunks: 1
[10:19:51.288] getGlobalsAndPackagesXApply() ...
[10:19:51.288]  - future.globals: TRUE
[10:19:51.289] getGlobalsAndPackages() ...
[10:19:51.289] Searching for globals...
[10:19:51.292] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:19:51.292] Searching for globals ... DONE
[10:19:51.292] Resolving globals: FALSE
[10:19:51.293] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[10:19:51.293] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.294] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.294] - packages: [1] ‘future.apply’
[10:19:51.294] getGlobalsAndPackages() ... DONE
[10:19:51.294]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.294]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.294] Finding globals ... DONE
[10:19:51.294]  - use_args: TRUE
[10:19:51.294]  - Getting '...' globals ...
[10:19:51.295] resolve() on list ...
[10:19:51.295]  recursive: 0
[10:19:51.295]  length: 1
[10:19:51.295]  elements: ‘...’
[10:19:51.295]  length: 0 (resolved future 1)
[10:19:51.295] resolve() on list ... DONE
[10:19:51.295]    - '...' content: [n=0] 
[10:19:51.295] List of 1
[10:19:51.295]  $ ...: list()
[10:19:51.295]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.295]  - attr(*, "where")=List of 1
[10:19:51.295]   ..$ ...:<environment: 0x55c69dcd0ed8> 
[10:19:51.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.295]  - attr(*, "resolved")= logi TRUE
[10:19:51.295]  - attr(*, "total_size")= num NA
[10:19:51.297]  - Getting '...' globals ... DONE
[10:19:51.298] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.298] List of 8
[10:19:51.298]  $ ...future.FUN:function (x, ...)  
[10:19:51.298]  $ x_FUN        :function (x)  
[10:19:51.298]  $ times        : int 2
[10:19:51.298]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.298]  $ stop_if_not  :function (...)  
[10:19:51.298]  $ dim          : NULL
[10:19:51.298]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.298]  $ ...          : list()
[10:19:51.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.298]  - attr(*, "where")=List of 8
[10:19:51.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.298]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.298]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.298]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.298]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.298]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.298]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.298]   ..$ ...          :<environment: 0x55c69dcd0ed8> 
[10:19:51.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.298]  - attr(*, "resolved")= logi FALSE
[10:19:51.298]  - attr(*, "total_size")= num 24454
[10:19:51.305] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.305] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.305] Number of futures (= number of chunks): 1
[10:19:51.305] Launching 1 futures (chunks) ...
[10:19:51.305] Chunk #1 of 1 ...
[10:19:51.305]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.305] getGlobalsAndPackages() ...
[10:19:51.305] Searching for globals...
[10:19:51.306] 
[10:19:51.306] Searching for globals ... DONE
[10:19:51.306] - globals: [0] <none>
[10:19:51.306] getGlobalsAndPackages() ... DONE
[10:19:51.306]    + additional globals found: [n=0] 
[10:19:51.306]    + additional namespaces needed: [n=0] 
[10:19:51.306]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.306]  - seeds: <none>
[10:19:51.306]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.306] getGlobalsAndPackages() ...
[10:19:51.307] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.307] Resolving globals: FALSE
[10:19:51.307] Tweak future expression to call with '...' arguments ...
[10:19:51.307] {
[10:19:51.307]     do.call(function(...) {
[10:19:51.307]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.307]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.307]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.307]             on.exit(options(oopts), add = TRUE)
[10:19:51.307]         }
[10:19:51.307]         {
[10:19:51.307]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.307]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.307]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.307]             })
[10:19:51.307]         }
[10:19:51.307]     }, args = future.call.arguments)
[10:19:51.307] }
[10:19:51.307] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.308] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.308] - packages: [1] ‘future.apply’
[10:19:51.308] getGlobalsAndPackages() ... DONE
[10:19:51.308] run() for ‘Future’ ...
[10:19:51.308] - state: ‘created’
[10:19:51.308] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.309] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.309]   - Field: ‘label’
[10:19:51.309]   - Field: ‘local’
[10:19:51.309]   - Field: ‘owner’
[10:19:51.309]   - Field: ‘envir’
[10:19:51.309]   - Field: ‘packages’
[10:19:51.309]   - Field: ‘gc’
[10:19:51.309]   - Field: ‘conditions’
[10:19:51.309]   - Field: ‘expr’
[10:19:51.309]   - Field: ‘uuid’
[10:19:51.310]   - Field: ‘seed’
[10:19:51.310]   - Field: ‘version’
[10:19:51.310]   - Field: ‘result’
[10:19:51.310]   - Field: ‘asynchronous’
[10:19:51.310]   - Field: ‘calls’
[10:19:51.310]   - Field: ‘globals’
[10:19:51.310]   - Field: ‘stdout’
[10:19:51.310]   - Field: ‘earlySignal’
[10:19:51.310]   - Field: ‘lazy’
[10:19:51.310]   - Field: ‘state’
[10:19:51.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.310] - Launch lazy future ...
[10:19:51.311] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.311] Packages needed by future strategies (n = 0): <none>
[10:19:51.311] {
[10:19:51.311]     {
[10:19:51.311]         {
[10:19:51.311]             ...future.startTime <- base::Sys.time()
[10:19:51.311]             {
[10:19:51.311]                 {
[10:19:51.311]                   {
[10:19:51.311]                     {
[10:19:51.311]                       base::local({
[10:19:51.311]                         has_future <- base::requireNamespace("future", 
[10:19:51.311]                           quietly = TRUE)
[10:19:51.311]                         if (has_future) {
[10:19:51.311]                           ns <- base::getNamespace("future")
[10:19:51.311]                           version <- ns[[".package"]][["version"]]
[10:19:51.311]                           if (is.null(version)) 
[10:19:51.311]                             version <- utils::packageVersion("future")
[10:19:51.311]                         }
[10:19:51.311]                         else {
[10:19:51.311]                           version <- NULL
[10:19:51.311]                         }
[10:19:51.311]                         if (!has_future || version < "1.8.0") {
[10:19:51.311]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.311]                             "", base::R.version$version.string), 
[10:19:51.311]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.311]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.311]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.311]                               "release", "version")], collapse = " "), 
[10:19:51.311]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.311]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.311]                             info)
[10:19:51.311]                           info <- base::paste(info, collapse = "; ")
[10:19:51.311]                           if (!has_future) {
[10:19:51.311]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.311]                               info)
[10:19:51.311]                           }
[10:19:51.311]                           else {
[10:19:51.311]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.311]                               info, version)
[10:19:51.311]                           }
[10:19:51.311]                           base::stop(msg)
[10:19:51.311]                         }
[10:19:51.311]                       })
[10:19:51.311]                     }
[10:19:51.311]                     base::local({
[10:19:51.311]                       for (pkg in "future.apply") {
[10:19:51.311]                         base::loadNamespace(pkg)
[10:19:51.311]                         base::library(pkg, character.only = TRUE)
[10:19:51.311]                       }
[10:19:51.311]                     })
[10:19:51.311]                   }
[10:19:51.311]                   ...future.strategy.old <- future::plan("list")
[10:19:51.311]                   options(future.plan = NULL)
[10:19:51.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.311]                 }
[10:19:51.311]                 ...future.workdir <- getwd()
[10:19:51.311]             }
[10:19:51.311]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.311]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.311]         }
[10:19:51.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.311]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.311]             base::names(...future.oldOptions))
[10:19:51.311]     }
[10:19:51.311]     if (FALSE) {
[10:19:51.311]     }
[10:19:51.311]     else {
[10:19:51.311]         if (TRUE) {
[10:19:51.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.311]                 open = "w")
[10:19:51.311]         }
[10:19:51.311]         else {
[10:19:51.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.311]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.311]         }
[10:19:51.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.311]             base::sink(type = "output", split = FALSE)
[10:19:51.311]             base::close(...future.stdout)
[10:19:51.311]         }, add = TRUE)
[10:19:51.311]     }
[10:19:51.311]     ...future.frame <- base::sys.nframe()
[10:19:51.311]     ...future.conditions <- base::list()
[10:19:51.311]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.311]     if (FALSE) {
[10:19:51.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.311]     }
[10:19:51.311]     ...future.result <- base::tryCatch({
[10:19:51.311]         base::withCallingHandlers({
[10:19:51.311]             ...future.value <- base::withVisible(base::local({
[10:19:51.311]                 do.call(function(...) {
[10:19:51.311]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.311]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.311]                     ...future.globals.maxSize)) {
[10:19:51.311]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.311]                     on.exit(options(oopts), add = TRUE)
[10:19:51.311]                   }
[10:19:51.311]                   {
[10:19:51.311]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.311]                       FUN = function(jj) {
[10:19:51.311]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.311]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.311]                       })
[10:19:51.311]                   }
[10:19:51.311]                 }, args = future.call.arguments)
[10:19:51.311]             }))
[10:19:51.311]             future::FutureResult(value = ...future.value$value, 
[10:19:51.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.311]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.311]                     ...future.globalenv.names))
[10:19:51.311]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.311]         }, condition = base::local({
[10:19:51.311]             c <- base::c
[10:19:51.311]             inherits <- base::inherits
[10:19:51.311]             invokeRestart <- base::invokeRestart
[10:19:51.311]             length <- base::length
[10:19:51.311]             list <- base::list
[10:19:51.311]             seq.int <- base::seq.int
[10:19:51.311]             signalCondition <- base::signalCondition
[10:19:51.311]             sys.calls <- base::sys.calls
[10:19:51.311]             `[[` <- base::`[[`
[10:19:51.311]             `+` <- base::`+`
[10:19:51.311]             `<<-` <- base::`<<-`
[10:19:51.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.311]                   3L)]
[10:19:51.311]             }
[10:19:51.311]             function(cond) {
[10:19:51.311]                 is_error <- inherits(cond, "error")
[10:19:51.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.311]                   NULL)
[10:19:51.311]                 if (is_error) {
[10:19:51.311]                   sessionInformation <- function() {
[10:19:51.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.311]                       search = base::search(), system = base::Sys.info())
[10:19:51.311]                   }
[10:19:51.311]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.311]                     cond$call), session = sessionInformation(), 
[10:19:51.311]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.311]                   signalCondition(cond)
[10:19:51.311]                 }
[10:19:51.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.311]                 "immediateCondition"))) {
[10:19:51.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.311]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.311]                   if (TRUE && !signal) {
[10:19:51.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.311]                     {
[10:19:51.311]                       inherits <- base::inherits
[10:19:51.311]                       invokeRestart <- base::invokeRestart
[10:19:51.311]                       is.null <- base::is.null
[10:19:51.311]                       muffled <- FALSE
[10:19:51.311]                       if (inherits(cond, "message")) {
[10:19:51.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.311]                         if (muffled) 
[10:19:51.311]                           invokeRestart("muffleMessage")
[10:19:51.311]                       }
[10:19:51.311]                       else if (inherits(cond, "warning")) {
[10:19:51.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.311]                         if (muffled) 
[10:19:51.311]                           invokeRestart("muffleWarning")
[10:19:51.311]                       }
[10:19:51.311]                       else if (inherits(cond, "condition")) {
[10:19:51.311]                         if (!is.null(pattern)) {
[10:19:51.311]                           computeRestarts <- base::computeRestarts
[10:19:51.311]                           grepl <- base::grepl
[10:19:51.311]                           restarts <- computeRestarts(cond)
[10:19:51.311]                           for (restart in restarts) {
[10:19:51.311]                             name <- restart$name
[10:19:51.311]                             if (is.null(name)) 
[10:19:51.311]                               next
[10:19:51.311]                             if (!grepl(pattern, name)) 
[10:19:51.311]                               next
[10:19:51.311]                             invokeRestart(restart)
[10:19:51.311]                             muffled <- TRUE
[10:19:51.311]                             break
[10:19:51.311]                           }
[10:19:51.311]                         }
[10:19:51.311]                       }
[10:19:51.311]                       invisible(muffled)
[10:19:51.311]                     }
[10:19:51.311]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.311]                   }
[10:19:51.311]                 }
[10:19:51.311]                 else {
[10:19:51.311]                   if (TRUE) {
[10:19:51.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.311]                     {
[10:19:51.311]                       inherits <- base::inherits
[10:19:51.311]                       invokeRestart <- base::invokeRestart
[10:19:51.311]                       is.null <- base::is.null
[10:19:51.311]                       muffled <- FALSE
[10:19:51.311]                       if (inherits(cond, "message")) {
[10:19:51.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.311]                         if (muffled) 
[10:19:51.311]                           invokeRestart("muffleMessage")
[10:19:51.311]                       }
[10:19:51.311]                       else if (inherits(cond, "warning")) {
[10:19:51.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.311]                         if (muffled) 
[10:19:51.311]                           invokeRestart("muffleWarning")
[10:19:51.311]                       }
[10:19:51.311]                       else if (inherits(cond, "condition")) {
[10:19:51.311]                         if (!is.null(pattern)) {
[10:19:51.311]                           computeRestarts <- base::computeRestarts
[10:19:51.311]                           grepl <- base::grepl
[10:19:51.311]                           restarts <- computeRestarts(cond)
[10:19:51.311]                           for (restart in restarts) {
[10:19:51.311]                             name <- restart$name
[10:19:51.311]                             if (is.null(name)) 
[10:19:51.311]                               next
[10:19:51.311]                             if (!grepl(pattern, name)) 
[10:19:51.311]                               next
[10:19:51.311]                             invokeRestart(restart)
[10:19:51.311]                             muffled <- TRUE
[10:19:51.311]                             break
[10:19:51.311]                           }
[10:19:51.311]                         }
[10:19:51.311]                       }
[10:19:51.311]                       invisible(muffled)
[10:19:51.311]                     }
[10:19:51.311]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.311]                   }
[10:19:51.311]                 }
[10:19:51.311]             }
[10:19:51.311]         }))
[10:19:51.311]     }, error = function(ex) {
[10:19:51.311]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.311]                 ...future.rng), started = ...future.startTime, 
[10:19:51.311]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.311]             version = "1.8"), class = "FutureResult")
[10:19:51.311]     }, finally = {
[10:19:51.311]         if (!identical(...future.workdir, getwd())) 
[10:19:51.311]             setwd(...future.workdir)
[10:19:51.311]         {
[10:19:51.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.311]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.311]             }
[10:19:51.311]             base::options(...future.oldOptions)
[10:19:51.311]             if (.Platform$OS.type == "windows") {
[10:19:51.311]                 old_names <- names(...future.oldEnvVars)
[10:19:51.311]                 envs <- base::Sys.getenv()
[10:19:51.311]                 names <- names(envs)
[10:19:51.311]                 common <- intersect(names, old_names)
[10:19:51.311]                 added <- setdiff(names, old_names)
[10:19:51.311]                 removed <- setdiff(old_names, names)
[10:19:51.311]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.311]                   envs[common]]
[10:19:51.311]                 NAMES <- toupper(changed)
[10:19:51.311]                 args <- list()
[10:19:51.311]                 for (kk in seq_along(NAMES)) {
[10:19:51.311]                   name <- changed[[kk]]
[10:19:51.311]                   NAME <- NAMES[[kk]]
[10:19:51.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.311]                     next
[10:19:51.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.311]                 }
[10:19:51.311]                 NAMES <- toupper(added)
[10:19:51.311]                 for (kk in seq_along(NAMES)) {
[10:19:51.311]                   name <- added[[kk]]
[10:19:51.311]                   NAME <- NAMES[[kk]]
[10:19:51.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.311]                     next
[10:19:51.311]                   args[[name]] <- ""
[10:19:51.311]                 }
[10:19:51.311]                 NAMES <- toupper(removed)
[10:19:51.311]                 for (kk in seq_along(NAMES)) {
[10:19:51.311]                   name <- removed[[kk]]
[10:19:51.311]                   NAME <- NAMES[[kk]]
[10:19:51.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.311]                     next
[10:19:51.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.311]                 }
[10:19:51.311]                 if (length(args) > 0) 
[10:19:51.311]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.311]             }
[10:19:51.311]             else {
[10:19:51.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.311]             }
[10:19:51.311]             {
[10:19:51.311]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.311]                   0L) {
[10:19:51.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.311]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.311]                   base::options(opts)
[10:19:51.311]                 }
[10:19:51.311]                 {
[10:19:51.311]                   {
[10:19:51.311]                     NULL
[10:19:51.311]                     RNGkind("Mersenne-Twister")
[10:19:51.311]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.311]                       inherits = FALSE)
[10:19:51.311]                   }
[10:19:51.311]                   options(future.plan = NULL)
[10:19:51.311]                   if (is.na(NA_character_)) 
[10:19:51.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.311]                     .init = FALSE)
[10:19:51.311]                 }
[10:19:51.311]             }
[10:19:51.311]         }
[10:19:51.311]     })
[10:19:51.311]     if (TRUE) {
[10:19:51.311]         base::sink(type = "output", split = FALSE)
[10:19:51.311]         if (TRUE) {
[10:19:51.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.311]         }
[10:19:51.311]         else {
[10:19:51.311]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.311]         }
[10:19:51.311]         base::close(...future.stdout)
[10:19:51.311]         ...future.stdout <- NULL
[10:19:51.311]     }
[10:19:51.311]     ...future.result$conditions <- ...future.conditions
[10:19:51.311]     ...future.result$finished <- base::Sys.time()
[10:19:51.311]     ...future.result
[10:19:51.311] }
[10:19:51.313] assign_globals() ...
[10:19:51.313] List of 11
[10:19:51.313]  $ ...future.FUN            :function (x, ...)  
[10:19:51.313]  $ x_FUN                    :function (x)  
[10:19:51.313]  $ times                    : int 2
[10:19:51.313]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.313]  $ stop_if_not              :function (...)  
[10:19:51.313]  $ dim                      : NULL
[10:19:51.313]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.313]  $ future.call.arguments    : list()
[10:19:51.313]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.313]  $ ...future.elements_ii    :List of 10
[10:19:51.313]   ..$ : int 1
[10:19:51.313]   ..$ : int 2
[10:19:51.313]   ..$ : int 3
[10:19:51.313]   ..$ : int 4
[10:19:51.313]   ..$ : int 5
[10:19:51.313]   ..$ : int 6
[10:19:51.313]   ..$ : int 7
[10:19:51.313]   ..$ : int 8
[10:19:51.313]   ..$ : int 9
[10:19:51.313]   ..$ : int 10
[10:19:51.313]  $ ...future.seeds_ii       : NULL
[10:19:51.313]  $ ...future.globals.maxSize: NULL
[10:19:51.313]  - attr(*, "where")=List of 11
[10:19:51.313]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.313]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.313]  - attr(*, "resolved")= logi FALSE
[10:19:51.313]  - attr(*, "total_size")= num 24454
[10:19:51.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.313]  - attr(*, "already-done")= logi TRUE
[10:19:51.322] - copied ‘...future.FUN’ to environment
[10:19:51.322] - reassign environment for ‘x_FUN’
[10:19:51.323] - copied ‘x_FUN’ to environment
[10:19:51.323] - copied ‘times’ to environment
[10:19:51.323] - copied ‘stopf’ to environment
[10:19:51.323] - copied ‘stop_if_not’ to environment
[10:19:51.323] - copied ‘dim’ to environment
[10:19:51.323] - copied ‘valid_types’ to environment
[10:19:51.323] - copied ‘future.call.arguments’ to environment
[10:19:51.323] - copied ‘...future.elements_ii’ to environment
[10:19:51.323] - copied ‘...future.seeds_ii’ to environment
[10:19:51.323] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.323] assign_globals() ... done
[10:19:51.324] plan(): Setting new future strategy stack:
[10:19:51.324] List of future strategies:
[10:19:51.324] 1. sequential:
[10:19:51.324]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.324]    - tweaked: FALSE
[10:19:51.324]    - call: NULL
[10:19:51.326] plan(): nbrOfWorkers() = 1
[10:19:51.327] plan(): Setting new future strategy stack:
[10:19:51.327] List of future strategies:
[10:19:51.327] 1. sequential:
[10:19:51.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.327]    - tweaked: FALSE
[10:19:51.327]    - call: plan(strategy)
[10:19:51.327] plan(): nbrOfWorkers() = 1
[10:19:51.327] SequentialFuture started (and completed)
[10:19:51.327] - Launch lazy future ... done
[10:19:51.327] run() for ‘SequentialFuture’ ... done
[10:19:51.328] Created future:
[10:19:51.328] SequentialFuture:
[10:19:51.328] Label: ‘future_vapply-1’
[10:19:51.328] Expression:
[10:19:51.328] {
[10:19:51.328]     do.call(function(...) {
[10:19:51.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.328]             on.exit(options(oopts), add = TRUE)
[10:19:51.328]         }
[10:19:51.328]         {
[10:19:51.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.328]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.328]             })
[10:19:51.328]         }
[10:19:51.328]     }, args = future.call.arguments)
[10:19:51.328] }
[10:19:51.328] Lazy evaluation: FALSE
[10:19:51.328] Asynchronous evaluation: FALSE
[10:19:51.328] Local evaluation: TRUE
[10:19:51.328] Environment: R_GlobalEnv
[10:19:51.328] Capture standard output: TRUE
[10:19:51.328] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.328] Globals: 11 objects totaling 13.63 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.328] Packages: 1 packages (‘future.apply’)
[10:19:51.328] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.328] Resolved: TRUE
[10:19:51.328] Value: 271 bytes of class ‘list’
[10:19:51.328] Early signaling: FALSE
[10:19:51.328] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.328] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.329] Chunk #1 of 1 ... DONE
[10:19:51.329] Launching 1 futures (chunks) ... DONE
[10:19:51.329] Resolving 1 futures (chunks) ...
[10:19:51.329] resolve() on list ...
[10:19:51.329]  recursive: 0
[10:19:51.329]  length: 1
[10:19:51.329] 
[10:19:51.329] resolved() for ‘SequentialFuture’ ...
[10:19:51.329] - state: ‘finished’
[10:19:51.329] - run: TRUE
[10:19:51.329] - result: ‘FutureResult’
[10:19:51.330] resolved() for ‘SequentialFuture’ ... done
[10:19:51.330] Future #1
[10:19:51.330] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.330] - nx: 1
[10:19:51.330] - relay: TRUE
[10:19:51.330] - stdout: TRUE
[10:19:51.330] - signal: TRUE
[10:19:51.330] - resignal: FALSE
[10:19:51.330] - force: TRUE
[10:19:51.330] - relayed: [n=1] FALSE
[10:19:51.330] - queued futures: [n=1] FALSE
[10:19:51.330]  - until=1
[10:19:51.331]  - relaying element #1
[10:19:51.331] - relayed: [n=1] TRUE
[10:19:51.331] - queued futures: [n=1] TRUE
[10:19:51.331] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.331]  length: 0 (resolved future 1)
[10:19:51.331] Relaying remaining futures
[10:19:51.331] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.331] - nx: 1
[10:19:51.331] - relay: TRUE
[10:19:51.331] - stdout: TRUE
[10:19:51.331] - signal: TRUE
[10:19:51.332] - resignal: FALSE
[10:19:51.332] - force: TRUE
[10:19:51.332] - relayed: [n=1] TRUE
[10:19:51.332] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.332] - relayed: [n=1] TRUE
[10:19:51.332] - queued futures: [n=1] TRUE
[10:19:51.332] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.332] resolve() on list ... DONE
[10:19:51.332]  - Number of value chunks collected: 1
[10:19:51.332] Resolving 1 futures (chunks) ... DONE
[10:19:51.332] Reducing values from 1 chunks ...
[10:19:51.333]  - Number of values collected after concatenation: 10
[10:19:51.333]  - Number of values expected: 10
[10:19:51.333] Reducing values from 1 chunks ... DONE
[10:19:51.333] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:19:51.334] future_lapply() ...
[10:19:51.335] Number of chunks: 1
[10:19:51.335] getGlobalsAndPackagesXApply() ...
[10:19:51.335]  - future.globals: TRUE
[10:19:51.335] getGlobalsAndPackages() ...
[10:19:51.336] Searching for globals...
[10:19:51.339] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:19:51.339] Searching for globals ... DONE
[10:19:51.339] Resolving globals: FALSE
[10:19:51.340] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[10:19:51.340] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.340] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.340] - packages: [1] ‘future.apply’
[10:19:51.340] getGlobalsAndPackages() ... DONE
[10:19:51.340]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.341]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.341] Finding globals ... DONE
[10:19:51.341]  - use_args: TRUE
[10:19:51.341]  - Getting '...' globals ...
[10:19:51.341] resolve() on list ...
[10:19:51.341]  recursive: 0
[10:19:51.341]  length: 1
[10:19:51.341]  elements: ‘...’
[10:19:51.341]  length: 0 (resolved future 1)
[10:19:51.342] resolve() on list ... DONE
[10:19:51.342]    - '...' content: [n=0] 
[10:19:51.342] List of 1
[10:19:51.342]  $ ...: list()
[10:19:51.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.342]  - attr(*, "where")=List of 1
[10:19:51.342]   ..$ ...:<environment: 0x55c69f4717c8> 
[10:19:51.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.342]  - attr(*, "resolved")= logi TRUE
[10:19:51.342]  - attr(*, "total_size")= num NA
[10:19:51.344]  - Getting '...' globals ... DONE
[10:19:51.344] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.344] List of 8
[10:19:51.344]  $ ...future.FUN:function (x, ...)  
[10:19:51.344]  $ x_FUN        :function (x)  
[10:19:51.344]  $ times        : int 4
[10:19:51.344]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.344]  $ stop_if_not  :function (...)  
[10:19:51.344]  $ dim          : int [1:2] 2 2
[10:19:51.344]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:51.344]  $ ...          : list()
[10:19:51.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.344]  - attr(*, "where")=List of 8
[10:19:51.344]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.344]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.344]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.344]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.344]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.344]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.344]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.344]   ..$ ...          :<environment: 0x55c69f4717c8> 
[10:19:51.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.344]  - attr(*, "resolved")= logi FALSE
[10:19:51.344]  - attr(*, "total_size")= num 24886
[10:19:51.351] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.351] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.351] Number of futures (= number of chunks): 1
[10:19:51.351] Launching 1 futures (chunks) ...
[10:19:51.351] Chunk #1 of 1 ...
[10:19:51.351]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.351] getGlobalsAndPackages() ...
[10:19:51.351] Searching for globals...
[10:19:51.352] 
[10:19:51.352] Searching for globals ... DONE
[10:19:51.352] - globals: [0] <none>
[10:19:51.352] getGlobalsAndPackages() ... DONE
[10:19:51.352]    + additional globals found: [n=0] 
[10:19:51.352]    + additional namespaces needed: [n=0] 
[10:19:51.352]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.352]  - seeds: <none>
[10:19:51.352]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.352] getGlobalsAndPackages() ...
[10:19:51.352] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.353] Resolving globals: FALSE
[10:19:51.353] Tweak future expression to call with '...' arguments ...
[10:19:51.353] {
[10:19:51.353]     do.call(function(...) {
[10:19:51.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.353]             on.exit(options(oopts), add = TRUE)
[10:19:51.353]         }
[10:19:51.353]         {
[10:19:51.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.353]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.353]             })
[10:19:51.353]         }
[10:19:51.353]     }, args = future.call.arguments)
[10:19:51.353] }
[10:19:51.353] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.353] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.354] - packages: [1] ‘future.apply’
[10:19:51.354] getGlobalsAndPackages() ... DONE
[10:19:51.354] run() for ‘Future’ ...
[10:19:51.354] - state: ‘created’
[10:19:51.354] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.354] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.354] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.355]   - Field: ‘label’
[10:19:51.355]   - Field: ‘local’
[10:19:51.355]   - Field: ‘owner’
[10:19:51.355]   - Field: ‘envir’
[10:19:51.355]   - Field: ‘packages’
[10:19:51.355]   - Field: ‘gc’
[10:19:51.355]   - Field: ‘conditions’
[10:19:51.355]   - Field: ‘expr’
[10:19:51.355]   - Field: ‘uuid’
[10:19:51.355]   - Field: ‘seed’
[10:19:51.355]   - Field: ‘version’
[10:19:51.355]   - Field: ‘result’
[10:19:51.356]   - Field: ‘asynchronous’
[10:19:51.356]   - Field: ‘calls’
[10:19:51.356]   - Field: ‘globals’
[10:19:51.356]   - Field: ‘stdout’
[10:19:51.356]   - Field: ‘earlySignal’
[10:19:51.356]   - Field: ‘lazy’
[10:19:51.356]   - Field: ‘state’
[10:19:51.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.356] - Launch lazy future ...
[10:19:51.356] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.356] Packages needed by future strategies (n = 0): <none>
[10:19:51.357] {
[10:19:51.357]     {
[10:19:51.357]         {
[10:19:51.357]             ...future.startTime <- base::Sys.time()
[10:19:51.357]             {
[10:19:51.357]                 {
[10:19:51.357]                   {
[10:19:51.357]                     {
[10:19:51.357]                       base::local({
[10:19:51.357]                         has_future <- base::requireNamespace("future", 
[10:19:51.357]                           quietly = TRUE)
[10:19:51.357]                         if (has_future) {
[10:19:51.357]                           ns <- base::getNamespace("future")
[10:19:51.357]                           version <- ns[[".package"]][["version"]]
[10:19:51.357]                           if (is.null(version)) 
[10:19:51.357]                             version <- utils::packageVersion("future")
[10:19:51.357]                         }
[10:19:51.357]                         else {
[10:19:51.357]                           version <- NULL
[10:19:51.357]                         }
[10:19:51.357]                         if (!has_future || version < "1.8.0") {
[10:19:51.357]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.357]                             "", base::R.version$version.string), 
[10:19:51.357]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.357]                               "release", "version")], collapse = " "), 
[10:19:51.357]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.357]                             info)
[10:19:51.357]                           info <- base::paste(info, collapse = "; ")
[10:19:51.357]                           if (!has_future) {
[10:19:51.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.357]                               info)
[10:19:51.357]                           }
[10:19:51.357]                           else {
[10:19:51.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.357]                               info, version)
[10:19:51.357]                           }
[10:19:51.357]                           base::stop(msg)
[10:19:51.357]                         }
[10:19:51.357]                       })
[10:19:51.357]                     }
[10:19:51.357]                     base::local({
[10:19:51.357]                       for (pkg in "future.apply") {
[10:19:51.357]                         base::loadNamespace(pkg)
[10:19:51.357]                         base::library(pkg, character.only = TRUE)
[10:19:51.357]                       }
[10:19:51.357]                     })
[10:19:51.357]                   }
[10:19:51.357]                   ...future.strategy.old <- future::plan("list")
[10:19:51.357]                   options(future.plan = NULL)
[10:19:51.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.357]                 }
[10:19:51.357]                 ...future.workdir <- getwd()
[10:19:51.357]             }
[10:19:51.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.357]         }
[10:19:51.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.357]             base::names(...future.oldOptions))
[10:19:51.357]     }
[10:19:51.357]     if (FALSE) {
[10:19:51.357]     }
[10:19:51.357]     else {
[10:19:51.357]         if (TRUE) {
[10:19:51.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.357]                 open = "w")
[10:19:51.357]         }
[10:19:51.357]         else {
[10:19:51.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.357]         }
[10:19:51.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.357]             base::sink(type = "output", split = FALSE)
[10:19:51.357]             base::close(...future.stdout)
[10:19:51.357]         }, add = TRUE)
[10:19:51.357]     }
[10:19:51.357]     ...future.frame <- base::sys.nframe()
[10:19:51.357]     ...future.conditions <- base::list()
[10:19:51.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.357]     if (FALSE) {
[10:19:51.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.357]     }
[10:19:51.357]     ...future.result <- base::tryCatch({
[10:19:51.357]         base::withCallingHandlers({
[10:19:51.357]             ...future.value <- base::withVisible(base::local({
[10:19:51.357]                 do.call(function(...) {
[10:19:51.357]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.357]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.357]                     ...future.globals.maxSize)) {
[10:19:51.357]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.357]                     on.exit(options(oopts), add = TRUE)
[10:19:51.357]                   }
[10:19:51.357]                   {
[10:19:51.357]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.357]                       FUN = function(jj) {
[10:19:51.357]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.357]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.357]                       })
[10:19:51.357]                   }
[10:19:51.357]                 }, args = future.call.arguments)
[10:19:51.357]             }))
[10:19:51.357]             future::FutureResult(value = ...future.value$value, 
[10:19:51.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.357]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.357]                     ...future.globalenv.names))
[10:19:51.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.357]         }, condition = base::local({
[10:19:51.357]             c <- base::c
[10:19:51.357]             inherits <- base::inherits
[10:19:51.357]             invokeRestart <- base::invokeRestart
[10:19:51.357]             length <- base::length
[10:19:51.357]             list <- base::list
[10:19:51.357]             seq.int <- base::seq.int
[10:19:51.357]             signalCondition <- base::signalCondition
[10:19:51.357]             sys.calls <- base::sys.calls
[10:19:51.357]             `[[` <- base::`[[`
[10:19:51.357]             `+` <- base::`+`
[10:19:51.357]             `<<-` <- base::`<<-`
[10:19:51.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.357]                   3L)]
[10:19:51.357]             }
[10:19:51.357]             function(cond) {
[10:19:51.357]                 is_error <- inherits(cond, "error")
[10:19:51.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.357]                   NULL)
[10:19:51.357]                 if (is_error) {
[10:19:51.357]                   sessionInformation <- function() {
[10:19:51.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.357]                       search = base::search(), system = base::Sys.info())
[10:19:51.357]                   }
[10:19:51.357]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.357]                     cond$call), session = sessionInformation(), 
[10:19:51.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.357]                   signalCondition(cond)
[10:19:51.357]                 }
[10:19:51.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.357]                 "immediateCondition"))) {
[10:19:51.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.357]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.357]                   if (TRUE && !signal) {
[10:19:51.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.357]                     {
[10:19:51.357]                       inherits <- base::inherits
[10:19:51.357]                       invokeRestart <- base::invokeRestart
[10:19:51.357]                       is.null <- base::is.null
[10:19:51.357]                       muffled <- FALSE
[10:19:51.357]                       if (inherits(cond, "message")) {
[10:19:51.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.357]                         if (muffled) 
[10:19:51.357]                           invokeRestart("muffleMessage")
[10:19:51.357]                       }
[10:19:51.357]                       else if (inherits(cond, "warning")) {
[10:19:51.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.357]                         if (muffled) 
[10:19:51.357]                           invokeRestart("muffleWarning")
[10:19:51.357]                       }
[10:19:51.357]                       else if (inherits(cond, "condition")) {
[10:19:51.357]                         if (!is.null(pattern)) {
[10:19:51.357]                           computeRestarts <- base::computeRestarts
[10:19:51.357]                           grepl <- base::grepl
[10:19:51.357]                           restarts <- computeRestarts(cond)
[10:19:51.357]                           for (restart in restarts) {
[10:19:51.357]                             name <- restart$name
[10:19:51.357]                             if (is.null(name)) 
[10:19:51.357]                               next
[10:19:51.357]                             if (!grepl(pattern, name)) 
[10:19:51.357]                               next
[10:19:51.357]                             invokeRestart(restart)
[10:19:51.357]                             muffled <- TRUE
[10:19:51.357]                             break
[10:19:51.357]                           }
[10:19:51.357]                         }
[10:19:51.357]                       }
[10:19:51.357]                       invisible(muffled)
[10:19:51.357]                     }
[10:19:51.357]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.357]                   }
[10:19:51.357]                 }
[10:19:51.357]                 else {
[10:19:51.357]                   if (TRUE) {
[10:19:51.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.357]                     {
[10:19:51.357]                       inherits <- base::inherits
[10:19:51.357]                       invokeRestart <- base::invokeRestart
[10:19:51.357]                       is.null <- base::is.null
[10:19:51.357]                       muffled <- FALSE
[10:19:51.357]                       if (inherits(cond, "message")) {
[10:19:51.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.357]                         if (muffled) 
[10:19:51.357]                           invokeRestart("muffleMessage")
[10:19:51.357]                       }
[10:19:51.357]                       else if (inherits(cond, "warning")) {
[10:19:51.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.357]                         if (muffled) 
[10:19:51.357]                           invokeRestart("muffleWarning")
[10:19:51.357]                       }
[10:19:51.357]                       else if (inherits(cond, "condition")) {
[10:19:51.357]                         if (!is.null(pattern)) {
[10:19:51.357]                           computeRestarts <- base::computeRestarts
[10:19:51.357]                           grepl <- base::grepl
[10:19:51.357]                           restarts <- computeRestarts(cond)
[10:19:51.357]                           for (restart in restarts) {
[10:19:51.357]                             name <- restart$name
[10:19:51.357]                             if (is.null(name)) 
[10:19:51.357]                               next
[10:19:51.357]                             if (!grepl(pattern, name)) 
[10:19:51.357]                               next
[10:19:51.357]                             invokeRestart(restart)
[10:19:51.357]                             muffled <- TRUE
[10:19:51.357]                             break
[10:19:51.357]                           }
[10:19:51.357]                         }
[10:19:51.357]                       }
[10:19:51.357]                       invisible(muffled)
[10:19:51.357]                     }
[10:19:51.357]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.357]                   }
[10:19:51.357]                 }
[10:19:51.357]             }
[10:19:51.357]         }))
[10:19:51.357]     }, error = function(ex) {
[10:19:51.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.357]                 ...future.rng), started = ...future.startTime, 
[10:19:51.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.357]             version = "1.8"), class = "FutureResult")
[10:19:51.357]     }, finally = {
[10:19:51.357]         if (!identical(...future.workdir, getwd())) 
[10:19:51.357]             setwd(...future.workdir)
[10:19:51.357]         {
[10:19:51.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.357]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.357]             }
[10:19:51.357]             base::options(...future.oldOptions)
[10:19:51.357]             if (.Platform$OS.type == "windows") {
[10:19:51.357]                 old_names <- names(...future.oldEnvVars)
[10:19:51.357]                 envs <- base::Sys.getenv()
[10:19:51.357]                 names <- names(envs)
[10:19:51.357]                 common <- intersect(names, old_names)
[10:19:51.357]                 added <- setdiff(names, old_names)
[10:19:51.357]                 removed <- setdiff(old_names, names)
[10:19:51.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.357]                   envs[common]]
[10:19:51.357]                 NAMES <- toupper(changed)
[10:19:51.357]                 args <- list()
[10:19:51.357]                 for (kk in seq_along(NAMES)) {
[10:19:51.357]                   name <- changed[[kk]]
[10:19:51.357]                   NAME <- NAMES[[kk]]
[10:19:51.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.357]                     next
[10:19:51.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.357]                 }
[10:19:51.357]                 NAMES <- toupper(added)
[10:19:51.357]                 for (kk in seq_along(NAMES)) {
[10:19:51.357]                   name <- added[[kk]]
[10:19:51.357]                   NAME <- NAMES[[kk]]
[10:19:51.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.357]                     next
[10:19:51.357]                   args[[name]] <- ""
[10:19:51.357]                 }
[10:19:51.357]                 NAMES <- toupper(removed)
[10:19:51.357]                 for (kk in seq_along(NAMES)) {
[10:19:51.357]                   name <- removed[[kk]]
[10:19:51.357]                   NAME <- NAMES[[kk]]
[10:19:51.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.357]                     next
[10:19:51.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.357]                 }
[10:19:51.357]                 if (length(args) > 0) 
[10:19:51.357]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.357]             }
[10:19:51.357]             else {
[10:19:51.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.357]             }
[10:19:51.357]             {
[10:19:51.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.357]                   0L) {
[10:19:51.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.357]                   base::options(opts)
[10:19:51.357]                 }
[10:19:51.357]                 {
[10:19:51.357]                   {
[10:19:51.357]                     NULL
[10:19:51.357]                     RNGkind("Mersenne-Twister")
[10:19:51.357]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.357]                       inherits = FALSE)
[10:19:51.357]                   }
[10:19:51.357]                   options(future.plan = NULL)
[10:19:51.357]                   if (is.na(NA_character_)) 
[10:19:51.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.357]                     .init = FALSE)
[10:19:51.357]                 }
[10:19:51.357]             }
[10:19:51.357]         }
[10:19:51.357]     })
[10:19:51.357]     if (TRUE) {
[10:19:51.357]         base::sink(type = "output", split = FALSE)
[10:19:51.357]         if (TRUE) {
[10:19:51.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.357]         }
[10:19:51.357]         else {
[10:19:51.357]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.357]         }
[10:19:51.357]         base::close(...future.stdout)
[10:19:51.357]         ...future.stdout <- NULL
[10:19:51.357]     }
[10:19:51.357]     ...future.result$conditions <- ...future.conditions
[10:19:51.357]     ...future.result$finished <- base::Sys.time()
[10:19:51.357]     ...future.result
[10:19:51.357] }
[10:19:51.359] assign_globals() ...
[10:19:51.359] List of 11
[10:19:51.359]  $ ...future.FUN            :function (x, ...)  
[10:19:51.359]  $ x_FUN                    :function (x)  
[10:19:51.359]  $ times                    : int 4
[10:19:51.359]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.359]  $ stop_if_not              :function (...)  
[10:19:51.359]  $ dim                      : int [1:2] 2 2
[10:19:51.359]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:51.359]  $ future.call.arguments    : list()
[10:19:51.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.359]  $ ...future.elements_ii    :List of 10
[10:19:51.359]   ..$ : int 1
[10:19:51.359]   ..$ : int 2
[10:19:51.359]   ..$ : int 3
[10:19:51.359]   ..$ : int 4
[10:19:51.359]   ..$ : int 5
[10:19:51.359]   ..$ : int 6
[10:19:51.359]   ..$ : int 7
[10:19:51.359]   ..$ : int 8
[10:19:51.359]   ..$ : int 9
[10:19:51.359]   ..$ : int 10
[10:19:51.359]  $ ...future.seeds_ii       : NULL
[10:19:51.359]  $ ...future.globals.maxSize: NULL
[10:19:51.359]  - attr(*, "where")=List of 11
[10:19:51.359]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.359]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.359]  - attr(*, "resolved")= logi FALSE
[10:19:51.359]  - attr(*, "total_size")= num 24886
[10:19:51.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.359]  - attr(*, "already-done")= logi TRUE
[10:19:51.369] - copied ‘...future.FUN’ to environment
[10:19:51.369] - reassign environment for ‘x_FUN’
[10:19:51.369] - copied ‘x_FUN’ to environment
[10:19:51.369] - copied ‘times’ to environment
[10:19:51.369] - copied ‘stopf’ to environment
[10:19:51.369] - copied ‘stop_if_not’ to environment
[10:19:51.370] - copied ‘dim’ to environment
[10:19:51.370] - copied ‘valid_types’ to environment
[10:19:51.370] - copied ‘future.call.arguments’ to environment
[10:19:51.370] - copied ‘...future.elements_ii’ to environment
[10:19:51.370] - copied ‘...future.seeds_ii’ to environment
[10:19:51.370] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.370] assign_globals() ... done
[10:19:51.370] plan(): Setting new future strategy stack:
[10:19:51.371] List of future strategies:
[10:19:51.371] 1. sequential:
[10:19:51.371]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.371]    - tweaked: FALSE
[10:19:51.371]    - call: NULL
[10:19:51.371] plan(): nbrOfWorkers() = 1
[10:19:51.372] plan(): Setting new future strategy stack:
[10:19:51.372] List of future strategies:
[10:19:51.372] 1. sequential:
[10:19:51.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.372]    - tweaked: FALSE
[10:19:51.372]    - call: plan(strategy)
[10:19:51.372] plan(): nbrOfWorkers() = 1
[10:19:51.372] SequentialFuture started (and completed)
[10:19:51.372] - Launch lazy future ... done
[10:19:51.373] run() for ‘SequentialFuture’ ... done
[10:19:51.373] Created future:
[10:19:51.373] SequentialFuture:
[10:19:51.373] Label: ‘future_vapply-1’
[10:19:51.373] Expression:
[10:19:51.373] {
[10:19:51.373]     do.call(function(...) {
[10:19:51.373]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.373]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.373]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.373]             on.exit(options(oopts), add = TRUE)
[10:19:51.373]         }
[10:19:51.373]         {
[10:19:51.373]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.373]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.373]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.373]             })
[10:19:51.373]         }
[10:19:51.373]     }, args = future.call.arguments)
[10:19:51.373] }
[10:19:51.373] Lazy evaluation: FALSE
[10:19:51.373] Asynchronous evaluation: FALSE
[10:19:51.373] Local evaluation: TRUE
[10:19:51.373] Environment: R_GlobalEnv
[10:19:51.373] Capture standard output: TRUE
[10:19:51.373] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.373] Globals: 11 objects totaling 13.88 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.373] Packages: 1 packages (‘future.apply’)
[10:19:51.373] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.373] Resolved: TRUE
[10:19:51.373] Value: 562 bytes of class ‘list’
[10:19:51.373] Early signaling: FALSE
[10:19:51.373] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.373] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.374] Chunk #1 of 1 ... DONE
[10:19:51.374] Launching 1 futures (chunks) ... DONE
[10:19:51.374] Resolving 1 futures (chunks) ...
[10:19:51.374] resolve() on list ...
[10:19:51.374]  recursive: 0
[10:19:51.374]  length: 1
[10:19:51.374] 
[10:19:51.374] resolved() for ‘SequentialFuture’ ...
[10:19:51.374] - state: ‘finished’
[10:19:51.374] - run: TRUE
[10:19:51.374] - result: ‘FutureResult’
[10:19:51.375] resolved() for ‘SequentialFuture’ ... done
[10:19:51.375] Future #1
[10:19:51.375] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.375] - nx: 1
[10:19:51.375] - relay: TRUE
[10:19:51.375] - stdout: TRUE
[10:19:51.375] - signal: TRUE
[10:19:51.375] - resignal: FALSE
[10:19:51.375] - force: TRUE
[10:19:51.375] - relayed: [n=1] FALSE
[10:19:51.375] - queued futures: [n=1] FALSE
[10:19:51.375]  - until=1
[10:19:51.375]  - relaying element #1
[10:19:51.376] - relayed: [n=1] TRUE
[10:19:51.376] - queued futures: [n=1] TRUE
[10:19:51.376] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.376]  length: 0 (resolved future 1)
[10:19:51.376] Relaying remaining futures
[10:19:51.376] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.376] - nx: 1
[10:19:51.376] - relay: TRUE
[10:19:51.376] - stdout: TRUE
[10:19:51.376] - signal: TRUE
[10:19:51.376] - resignal: FALSE
[10:19:51.376] - force: TRUE
[10:19:51.377] - relayed: [n=1] TRUE
[10:19:51.377] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.377] - relayed: [n=1] TRUE
[10:19:51.377] - queued futures: [n=1] TRUE
[10:19:51.377] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.377] resolve() on list ... DONE
[10:19:51.377]  - Number of value chunks collected: 1
[10:19:51.377] Resolving 1 futures (chunks) ... DONE
[10:19:51.377] Reducing values from 1 chunks ...
[10:19:51.377]  - Number of values collected after concatenation: 10
[10:19:51.377]  - Number of values expected: 10
[10:19:51.378] Reducing values from 1 chunks ... DONE
[10:19:51.378] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:19:51.378] future_lapply() ...
[10:19:51.380] Number of chunks: 1
[10:19:51.380] getGlobalsAndPackagesXApply() ...
[10:19:51.380]  - future.globals: TRUE
[10:19:51.380] getGlobalsAndPackages() ...
[10:19:51.380] Searching for globals...
[10:19:51.383] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:19:51.383] Searching for globals ... DONE
[10:19:51.384] Resolving globals: FALSE
[10:19:51.384] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[10:19:51.385] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.385] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.385] - packages: [1] ‘future.apply’
[10:19:51.385] getGlobalsAndPackages() ... DONE
[10:19:51.385]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.385]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.385] Finding globals ... DONE
[10:19:51.385]  - use_args: TRUE
[10:19:51.385]  - Getting '...' globals ...
[10:19:51.386] resolve() on list ...
[10:19:51.386]  recursive: 0
[10:19:51.386]  length: 1
[10:19:51.386]  elements: ‘...’
[10:19:51.386]  length: 0 (resolved future 1)
[10:19:51.386] resolve() on list ... DONE
[10:19:51.386]    - '...' content: [n=0] 
[10:19:51.386] List of 1
[10:19:51.386]  $ ...: list()
[10:19:51.386]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.386]  - attr(*, "where")=List of 1
[10:19:51.386]   ..$ ...:<environment: 0x55c69fab4b28> 
[10:19:51.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.386]  - attr(*, "resolved")= logi TRUE
[10:19:51.386]  - attr(*, "total_size")= num NA
[10:19:51.390]  - Getting '...' globals ... DONE
[10:19:51.390] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.390] List of 8
[10:19:51.390]  $ ...future.FUN:function (x, ...)  
[10:19:51.390]  $ x_FUN        :function (x)  
[10:19:51.390]  $ times        : int 4
[10:19:51.390]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.390]  $ stop_if_not  :function (...)  
[10:19:51.390]  $ dim          : int [1:2] 2 2
[10:19:51.390]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.390]  $ ...          : list()
[10:19:51.390]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.390]  - attr(*, "where")=List of 8
[10:19:51.390]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.390]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.390]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.390]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.390]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.390]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.390]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.390]   ..$ ...          :<environment: 0x55c69fab4b28> 
[10:19:51.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.390]  - attr(*, "resolved")= logi FALSE
[10:19:51.390]  - attr(*, "total_size")= num 24958
[10:19:51.395] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.395] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.395] Number of futures (= number of chunks): 1
[10:19:51.395] Launching 1 futures (chunks) ...
[10:19:51.395] Chunk #1 of 1 ...
[10:19:51.396]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.396] getGlobalsAndPackages() ...
[10:19:51.396] Searching for globals...
[10:19:51.396] 
[10:19:51.396] Searching for globals ... DONE
[10:19:51.396] - globals: [0] <none>
[10:19:51.396] getGlobalsAndPackages() ... DONE
[10:19:51.396]    + additional globals found: [n=0] 
[10:19:51.396]    + additional namespaces needed: [n=0] 
[10:19:51.396]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.397]  - seeds: <none>
[10:19:51.397]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.397] getGlobalsAndPackages() ...
[10:19:51.397] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.397] Resolving globals: FALSE
[10:19:51.397] Tweak future expression to call with '...' arguments ...
[10:19:51.397] {
[10:19:51.397]     do.call(function(...) {
[10:19:51.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.397]             on.exit(options(oopts), add = TRUE)
[10:19:51.397]         }
[10:19:51.397]         {
[10:19:51.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.397]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.397]             })
[10:19:51.397]         }
[10:19:51.397]     }, args = future.call.arguments)
[10:19:51.397] }
[10:19:51.397] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.398] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.398] - packages: [1] ‘future.apply’
[10:19:51.398] getGlobalsAndPackages() ... DONE
[10:19:51.398] run() for ‘Future’ ...
[10:19:51.398] - state: ‘created’
[10:19:51.398] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.399] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.399]   - Field: ‘label’
[10:19:51.399]   - Field: ‘local’
[10:19:51.399]   - Field: ‘owner’
[10:19:51.399]   - Field: ‘envir’
[10:19:51.399]   - Field: ‘packages’
[10:19:51.399]   - Field: ‘gc’
[10:19:51.399]   - Field: ‘conditions’
[10:19:51.399]   - Field: ‘expr’
[10:19:51.399]   - Field: ‘uuid’
[10:19:51.400]   - Field: ‘seed’
[10:19:51.400]   - Field: ‘version’
[10:19:51.400]   - Field: ‘result’
[10:19:51.400]   - Field: ‘asynchronous’
[10:19:51.400]   - Field: ‘calls’
[10:19:51.400]   - Field: ‘globals’
[10:19:51.400]   - Field: ‘stdout’
[10:19:51.400]   - Field: ‘earlySignal’
[10:19:51.400]   - Field: ‘lazy’
[10:19:51.400]   - Field: ‘state’
[10:19:51.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.400] - Launch lazy future ...
[10:19:51.401] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.401] Packages needed by future strategies (n = 0): <none>
[10:19:51.401] {
[10:19:51.401]     {
[10:19:51.401]         {
[10:19:51.401]             ...future.startTime <- base::Sys.time()
[10:19:51.401]             {
[10:19:51.401]                 {
[10:19:51.401]                   {
[10:19:51.401]                     {
[10:19:51.401]                       base::local({
[10:19:51.401]                         has_future <- base::requireNamespace("future", 
[10:19:51.401]                           quietly = TRUE)
[10:19:51.401]                         if (has_future) {
[10:19:51.401]                           ns <- base::getNamespace("future")
[10:19:51.401]                           version <- ns[[".package"]][["version"]]
[10:19:51.401]                           if (is.null(version)) 
[10:19:51.401]                             version <- utils::packageVersion("future")
[10:19:51.401]                         }
[10:19:51.401]                         else {
[10:19:51.401]                           version <- NULL
[10:19:51.401]                         }
[10:19:51.401]                         if (!has_future || version < "1.8.0") {
[10:19:51.401]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.401]                             "", base::R.version$version.string), 
[10:19:51.401]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.401]                               "release", "version")], collapse = " "), 
[10:19:51.401]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.401]                             info)
[10:19:51.401]                           info <- base::paste(info, collapse = "; ")
[10:19:51.401]                           if (!has_future) {
[10:19:51.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.401]                               info)
[10:19:51.401]                           }
[10:19:51.401]                           else {
[10:19:51.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.401]                               info, version)
[10:19:51.401]                           }
[10:19:51.401]                           base::stop(msg)
[10:19:51.401]                         }
[10:19:51.401]                       })
[10:19:51.401]                     }
[10:19:51.401]                     base::local({
[10:19:51.401]                       for (pkg in "future.apply") {
[10:19:51.401]                         base::loadNamespace(pkg)
[10:19:51.401]                         base::library(pkg, character.only = TRUE)
[10:19:51.401]                       }
[10:19:51.401]                     })
[10:19:51.401]                   }
[10:19:51.401]                   ...future.strategy.old <- future::plan("list")
[10:19:51.401]                   options(future.plan = NULL)
[10:19:51.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.401]                 }
[10:19:51.401]                 ...future.workdir <- getwd()
[10:19:51.401]             }
[10:19:51.401]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.401]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.401]         }
[10:19:51.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.401]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.401]             base::names(...future.oldOptions))
[10:19:51.401]     }
[10:19:51.401]     if (FALSE) {
[10:19:51.401]     }
[10:19:51.401]     else {
[10:19:51.401]         if (TRUE) {
[10:19:51.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.401]                 open = "w")
[10:19:51.401]         }
[10:19:51.401]         else {
[10:19:51.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.401]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.401]         }
[10:19:51.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.401]             base::sink(type = "output", split = FALSE)
[10:19:51.401]             base::close(...future.stdout)
[10:19:51.401]         }, add = TRUE)
[10:19:51.401]     }
[10:19:51.401]     ...future.frame <- base::sys.nframe()
[10:19:51.401]     ...future.conditions <- base::list()
[10:19:51.401]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.401]     if (FALSE) {
[10:19:51.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.401]     }
[10:19:51.401]     ...future.result <- base::tryCatch({
[10:19:51.401]         base::withCallingHandlers({
[10:19:51.401]             ...future.value <- base::withVisible(base::local({
[10:19:51.401]                 do.call(function(...) {
[10:19:51.401]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.401]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.401]                     ...future.globals.maxSize)) {
[10:19:51.401]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.401]                     on.exit(options(oopts), add = TRUE)
[10:19:51.401]                   }
[10:19:51.401]                   {
[10:19:51.401]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.401]                       FUN = function(jj) {
[10:19:51.401]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.401]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.401]                       })
[10:19:51.401]                   }
[10:19:51.401]                 }, args = future.call.arguments)
[10:19:51.401]             }))
[10:19:51.401]             future::FutureResult(value = ...future.value$value, 
[10:19:51.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.401]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.401]                     ...future.globalenv.names))
[10:19:51.401]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.401]         }, condition = base::local({
[10:19:51.401]             c <- base::c
[10:19:51.401]             inherits <- base::inherits
[10:19:51.401]             invokeRestart <- base::invokeRestart
[10:19:51.401]             length <- base::length
[10:19:51.401]             list <- base::list
[10:19:51.401]             seq.int <- base::seq.int
[10:19:51.401]             signalCondition <- base::signalCondition
[10:19:51.401]             sys.calls <- base::sys.calls
[10:19:51.401]             `[[` <- base::`[[`
[10:19:51.401]             `+` <- base::`+`
[10:19:51.401]             `<<-` <- base::`<<-`
[10:19:51.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.401]                   3L)]
[10:19:51.401]             }
[10:19:51.401]             function(cond) {
[10:19:51.401]                 is_error <- inherits(cond, "error")
[10:19:51.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.401]                   NULL)
[10:19:51.401]                 if (is_error) {
[10:19:51.401]                   sessionInformation <- function() {
[10:19:51.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.401]                       search = base::search(), system = base::Sys.info())
[10:19:51.401]                   }
[10:19:51.401]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.401]                     cond$call), session = sessionInformation(), 
[10:19:51.401]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.401]                   signalCondition(cond)
[10:19:51.401]                 }
[10:19:51.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.401]                 "immediateCondition"))) {
[10:19:51.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.401]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.401]                   if (TRUE && !signal) {
[10:19:51.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.401]                     {
[10:19:51.401]                       inherits <- base::inherits
[10:19:51.401]                       invokeRestart <- base::invokeRestart
[10:19:51.401]                       is.null <- base::is.null
[10:19:51.401]                       muffled <- FALSE
[10:19:51.401]                       if (inherits(cond, "message")) {
[10:19:51.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.401]                         if (muffled) 
[10:19:51.401]                           invokeRestart("muffleMessage")
[10:19:51.401]                       }
[10:19:51.401]                       else if (inherits(cond, "warning")) {
[10:19:51.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.401]                         if (muffled) 
[10:19:51.401]                           invokeRestart("muffleWarning")
[10:19:51.401]                       }
[10:19:51.401]                       else if (inherits(cond, "condition")) {
[10:19:51.401]                         if (!is.null(pattern)) {
[10:19:51.401]                           computeRestarts <- base::computeRestarts
[10:19:51.401]                           grepl <- base::grepl
[10:19:51.401]                           restarts <- computeRestarts(cond)
[10:19:51.401]                           for (restart in restarts) {
[10:19:51.401]                             name <- restart$name
[10:19:51.401]                             if (is.null(name)) 
[10:19:51.401]                               next
[10:19:51.401]                             if (!grepl(pattern, name)) 
[10:19:51.401]                               next
[10:19:51.401]                             invokeRestart(restart)
[10:19:51.401]                             muffled <- TRUE
[10:19:51.401]                             break
[10:19:51.401]                           }
[10:19:51.401]                         }
[10:19:51.401]                       }
[10:19:51.401]                       invisible(muffled)
[10:19:51.401]                     }
[10:19:51.401]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.401]                   }
[10:19:51.401]                 }
[10:19:51.401]                 else {
[10:19:51.401]                   if (TRUE) {
[10:19:51.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.401]                     {
[10:19:51.401]                       inherits <- base::inherits
[10:19:51.401]                       invokeRestart <- base::invokeRestart
[10:19:51.401]                       is.null <- base::is.null
[10:19:51.401]                       muffled <- FALSE
[10:19:51.401]                       if (inherits(cond, "message")) {
[10:19:51.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.401]                         if (muffled) 
[10:19:51.401]                           invokeRestart("muffleMessage")
[10:19:51.401]                       }
[10:19:51.401]                       else if (inherits(cond, "warning")) {
[10:19:51.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.401]                         if (muffled) 
[10:19:51.401]                           invokeRestart("muffleWarning")
[10:19:51.401]                       }
[10:19:51.401]                       else if (inherits(cond, "condition")) {
[10:19:51.401]                         if (!is.null(pattern)) {
[10:19:51.401]                           computeRestarts <- base::computeRestarts
[10:19:51.401]                           grepl <- base::grepl
[10:19:51.401]                           restarts <- computeRestarts(cond)
[10:19:51.401]                           for (restart in restarts) {
[10:19:51.401]                             name <- restart$name
[10:19:51.401]                             if (is.null(name)) 
[10:19:51.401]                               next
[10:19:51.401]                             if (!grepl(pattern, name)) 
[10:19:51.401]                               next
[10:19:51.401]                             invokeRestart(restart)
[10:19:51.401]                             muffled <- TRUE
[10:19:51.401]                             break
[10:19:51.401]                           }
[10:19:51.401]                         }
[10:19:51.401]                       }
[10:19:51.401]                       invisible(muffled)
[10:19:51.401]                     }
[10:19:51.401]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.401]                   }
[10:19:51.401]                 }
[10:19:51.401]             }
[10:19:51.401]         }))
[10:19:51.401]     }, error = function(ex) {
[10:19:51.401]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.401]                 ...future.rng), started = ...future.startTime, 
[10:19:51.401]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.401]             version = "1.8"), class = "FutureResult")
[10:19:51.401]     }, finally = {
[10:19:51.401]         if (!identical(...future.workdir, getwd())) 
[10:19:51.401]             setwd(...future.workdir)
[10:19:51.401]         {
[10:19:51.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.401]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.401]             }
[10:19:51.401]             base::options(...future.oldOptions)
[10:19:51.401]             if (.Platform$OS.type == "windows") {
[10:19:51.401]                 old_names <- names(...future.oldEnvVars)
[10:19:51.401]                 envs <- base::Sys.getenv()
[10:19:51.401]                 names <- names(envs)
[10:19:51.401]                 common <- intersect(names, old_names)
[10:19:51.401]                 added <- setdiff(names, old_names)
[10:19:51.401]                 removed <- setdiff(old_names, names)
[10:19:51.401]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.401]                   envs[common]]
[10:19:51.401]                 NAMES <- toupper(changed)
[10:19:51.401]                 args <- list()
[10:19:51.401]                 for (kk in seq_along(NAMES)) {
[10:19:51.401]                   name <- changed[[kk]]
[10:19:51.401]                   NAME <- NAMES[[kk]]
[10:19:51.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.401]                     next
[10:19:51.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.401]                 }
[10:19:51.401]                 NAMES <- toupper(added)
[10:19:51.401]                 for (kk in seq_along(NAMES)) {
[10:19:51.401]                   name <- added[[kk]]
[10:19:51.401]                   NAME <- NAMES[[kk]]
[10:19:51.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.401]                     next
[10:19:51.401]                   args[[name]] <- ""
[10:19:51.401]                 }
[10:19:51.401]                 NAMES <- toupper(removed)
[10:19:51.401]                 for (kk in seq_along(NAMES)) {
[10:19:51.401]                   name <- removed[[kk]]
[10:19:51.401]                   NAME <- NAMES[[kk]]
[10:19:51.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.401]                     next
[10:19:51.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.401]                 }
[10:19:51.401]                 if (length(args) > 0) 
[10:19:51.401]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.401]             }
[10:19:51.401]             else {
[10:19:51.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.401]             }
[10:19:51.401]             {
[10:19:51.401]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.401]                   0L) {
[10:19:51.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.401]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.401]                   base::options(opts)
[10:19:51.401]                 }
[10:19:51.401]                 {
[10:19:51.401]                   {
[10:19:51.401]                     NULL
[10:19:51.401]                     RNGkind("Mersenne-Twister")
[10:19:51.401]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.401]                       inherits = FALSE)
[10:19:51.401]                   }
[10:19:51.401]                   options(future.plan = NULL)
[10:19:51.401]                   if (is.na(NA_character_)) 
[10:19:51.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.401]                     .init = FALSE)
[10:19:51.401]                 }
[10:19:51.401]             }
[10:19:51.401]         }
[10:19:51.401]     })
[10:19:51.401]     if (TRUE) {
[10:19:51.401]         base::sink(type = "output", split = FALSE)
[10:19:51.401]         if (TRUE) {
[10:19:51.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.401]         }
[10:19:51.401]         else {
[10:19:51.401]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.401]         }
[10:19:51.401]         base::close(...future.stdout)
[10:19:51.401]         ...future.stdout <- NULL
[10:19:51.401]     }
[10:19:51.401]     ...future.result$conditions <- ...future.conditions
[10:19:51.401]     ...future.result$finished <- base::Sys.time()
[10:19:51.401]     ...future.result
[10:19:51.401] }
[10:19:51.403] assign_globals() ...
[10:19:51.403] List of 11
[10:19:51.403]  $ ...future.FUN            :function (x, ...)  
[10:19:51.403]  $ x_FUN                    :function (x)  
[10:19:51.403]  $ times                    : int 4
[10:19:51.403]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.403]  $ stop_if_not              :function (...)  
[10:19:51.403]  $ dim                      : int [1:2] 2 2
[10:19:51.403]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.403]  $ future.call.arguments    : list()
[10:19:51.403]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.403]  $ ...future.elements_ii    :List of 10
[10:19:51.403]   ..$ : int 1
[10:19:51.403]   ..$ : int 2
[10:19:51.403]   ..$ : int 3
[10:19:51.403]   ..$ : int 4
[10:19:51.403]   ..$ : int 5
[10:19:51.403]   ..$ : int 6
[10:19:51.403]   ..$ : int 7
[10:19:51.403]   ..$ : int 8
[10:19:51.403]   ..$ : int 9
[10:19:51.403]   ..$ : int 10
[10:19:51.403]  $ ...future.seeds_ii       : NULL
[10:19:51.403]  $ ...future.globals.maxSize: NULL
[10:19:51.403]  - attr(*, "where")=List of 11
[10:19:51.403]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.403]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.403]  - attr(*, "resolved")= logi FALSE
[10:19:51.403]  - attr(*, "total_size")= num 24958
[10:19:51.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.403]  - attr(*, "already-done")= logi TRUE
[10:19:51.414] - copied ‘...future.FUN’ to environment
[10:19:51.414] - reassign environment for ‘x_FUN’
[10:19:51.414] - copied ‘x_FUN’ to environment
[10:19:51.414] - copied ‘times’ to environment
[10:19:51.414] - copied ‘stopf’ to environment
[10:19:51.414] - copied ‘stop_if_not’ to environment
[10:19:51.414] - copied ‘dim’ to environment
[10:19:51.414] - copied ‘valid_types’ to environment
[10:19:51.414] - copied ‘future.call.arguments’ to environment
[10:19:51.414] - copied ‘...future.elements_ii’ to environment
[10:19:51.415] - copied ‘...future.seeds_ii’ to environment
[10:19:51.415] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.415] assign_globals() ... done
[10:19:51.415] plan(): Setting new future strategy stack:
[10:19:51.415] List of future strategies:
[10:19:51.415] 1. sequential:
[10:19:51.415]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.415]    - tweaked: FALSE
[10:19:51.415]    - call: NULL
[10:19:51.416] plan(): nbrOfWorkers() = 1
[10:19:51.416] plan(): Setting new future strategy stack:
[10:19:51.416] List of future strategies:
[10:19:51.416] 1. sequential:
[10:19:51.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.416]    - tweaked: FALSE
[10:19:51.416]    - call: plan(strategy)
[10:19:51.417] plan(): nbrOfWorkers() = 1
[10:19:51.417] SequentialFuture started (and completed)
[10:19:51.417] - Launch lazy future ... done
[10:19:51.417] run() for ‘SequentialFuture’ ... done
[10:19:51.417] Created future:
[10:19:51.417] SequentialFuture:
[10:19:51.417] Label: ‘future_vapply-1’
[10:19:51.417] Expression:
[10:19:51.417] {
[10:19:51.417]     do.call(function(...) {
[10:19:51.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.417]             on.exit(options(oopts), add = TRUE)
[10:19:51.417]         }
[10:19:51.417]         {
[10:19:51.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.417]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.417]             })
[10:19:51.417]         }
[10:19:51.417]     }, args = future.call.arguments)
[10:19:51.417] }
[10:19:51.417] Lazy evaluation: FALSE
[10:19:51.417] Asynchronous evaluation: FALSE
[10:19:51.417] Local evaluation: TRUE
[10:19:51.417] Environment: R_GlobalEnv
[10:19:51.417] Capture standard output: TRUE
[10:19:51.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.417] Globals: 11 objects totaling 13.92 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.417] Packages: 1 packages (‘future.apply’)
[10:19:51.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.417] Resolved: TRUE
[10:19:51.417] Value: 562 bytes of class ‘list’
[10:19:51.417] Early signaling: FALSE
[10:19:51.417] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.417] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.418] Chunk #1 of 1 ... DONE
[10:19:51.418] Launching 1 futures (chunks) ... DONE
[10:19:51.418] Resolving 1 futures (chunks) ...
[10:19:51.419] resolve() on list ...
[10:19:51.419]  recursive: 0
[10:19:51.419]  length: 1
[10:19:51.419] 
[10:19:51.419] resolved() for ‘SequentialFuture’ ...
[10:19:51.419] - state: ‘finished’
[10:19:51.419] - run: TRUE
[10:19:51.419] - result: ‘FutureResult’
[10:19:51.419] resolved() for ‘SequentialFuture’ ... done
[10:19:51.419] Future #1
[10:19:51.419] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.420] - nx: 1
[10:19:51.420] - relay: TRUE
[10:19:51.420] - stdout: TRUE
[10:19:51.420] - signal: TRUE
[10:19:51.420] - resignal: FALSE
[10:19:51.420] - force: TRUE
[10:19:51.420] - relayed: [n=1] FALSE
[10:19:51.420] - queued futures: [n=1] FALSE
[10:19:51.420]  - until=1
[10:19:51.420]  - relaying element #1
[10:19:51.420] - relayed: [n=1] TRUE
[10:19:51.420] - queued futures: [n=1] TRUE
[10:19:51.421] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.421]  length: 0 (resolved future 1)
[10:19:51.421] Relaying remaining futures
[10:19:51.421] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.421] - nx: 1
[10:19:51.421] - relay: TRUE
[10:19:51.421] - stdout: TRUE
[10:19:51.421] - signal: TRUE
[10:19:51.421] - resignal: FALSE
[10:19:51.421] - force: TRUE
[10:19:51.421] - relayed: [n=1] TRUE
[10:19:51.421] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.422] - relayed: [n=1] TRUE
[10:19:51.422] - queued futures: [n=1] TRUE
[10:19:51.422] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.422] resolve() on list ... DONE
[10:19:51.422]  - Number of value chunks collected: 1
[10:19:51.422] Resolving 1 futures (chunks) ... DONE
[10:19:51.422] Reducing values from 1 chunks ...
[10:19:51.422]  - Number of values collected after concatenation: 10
[10:19:51.422]  - Number of values expected: 10
[10:19:51.422] Reducing values from 1 chunks ... DONE
[10:19:51.422] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:19:51.424] future_lapply() ...
[10:19:51.426] Number of chunks: 1
[10:19:51.426] getGlobalsAndPackagesXApply() ...
[10:19:51.426]  - future.globals: TRUE
[10:19:51.426] getGlobalsAndPackages() ...
[10:19:51.426] Searching for globals...
[10:19:51.456] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:19:51.456] Searching for globals ... DONE
[10:19:51.456] Resolving globals: FALSE
[10:19:51.457] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[10:19:51.457] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.458] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.458] - packages: [1] ‘future.apply’
[10:19:51.458] getGlobalsAndPackages() ... DONE
[10:19:51.458]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.458]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.458] Finding globals ... DONE
[10:19:51.458]  - use_args: TRUE
[10:19:51.458]  - Getting '...' globals ...
[10:19:51.458] resolve() on list ...
[10:19:51.459]  recursive: 0
[10:19:51.459]  length: 1
[10:19:51.459]  elements: ‘...’
[10:19:51.459]  length: 0 (resolved future 1)
[10:19:51.459] resolve() on list ... DONE
[10:19:51.459]    - '...' content: [n=0] 
[10:19:51.459] List of 1
[10:19:51.459]  $ ...: list()
[10:19:51.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.459]  - attr(*, "where")=List of 1
[10:19:51.459]   ..$ ...:<environment: 0x55c69fdde518> 
[10:19:51.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.459]  - attr(*, "resolved")= logi TRUE
[10:19:51.459]  - attr(*, "total_size")= num NA
[10:19:51.461]  - Getting '...' globals ... DONE
[10:19:51.462] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.462] List of 8
[10:19:51.462]  $ ...future.FUN:function (x, ...)  
[10:19:51.462]  $ x_FUN        :function (x)  
[10:19:51.462]  $ times        : int 4
[10:19:51.462]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.462]  $ stop_if_not  :function (...)  
[10:19:51.462]  $ dim          : int [1:2] 2 2
[10:19:51.462]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.462]  $ ...          : list()
[10:19:51.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.462]  - attr(*, "where")=List of 8
[10:19:51.462]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.462]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.462]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.462]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.462]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.462]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.462]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.462]   ..$ ...          :<environment: 0x55c69fdde518> 
[10:19:51.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.462]  - attr(*, "resolved")= logi FALSE
[10:19:51.462]  - attr(*, "total_size")= num 29094
[10:19:51.467] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.467] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.467] Number of futures (= number of chunks): 1
[10:19:51.467] Launching 1 futures (chunks) ...
[10:19:51.467] Chunk #1 of 1 ...
[10:19:51.467]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.467] getGlobalsAndPackages() ...
[10:19:51.468] Searching for globals...
[10:19:51.468] 
[10:19:51.468] Searching for globals ... DONE
[10:19:51.468] - globals: [0] <none>
[10:19:51.468] getGlobalsAndPackages() ... DONE
[10:19:51.468]    + additional globals found: [n=0] 
[10:19:51.468]    + additional namespaces needed: [n=0] 
[10:19:51.468]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.468]  - seeds: <none>
[10:19:51.468]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.469] getGlobalsAndPackages() ...
[10:19:51.469] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.469] Resolving globals: FALSE
[10:19:51.469] Tweak future expression to call with '...' arguments ...
[10:19:51.469] {
[10:19:51.469]     do.call(function(...) {
[10:19:51.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.469]             on.exit(options(oopts), add = TRUE)
[10:19:51.469]         }
[10:19:51.469]         {
[10:19:51.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.469]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.469]             })
[10:19:51.469]         }
[10:19:51.469]     }, args = future.call.arguments)
[10:19:51.469] }
[10:19:51.469] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.470] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.470] - packages: [1] ‘future.apply’
[10:19:51.470] getGlobalsAndPackages() ... DONE
[10:19:51.470] run() for ‘Future’ ...
[10:19:51.470] - state: ‘created’
[10:19:51.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.471] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.471]   - Field: ‘label’
[10:19:51.471]   - Field: ‘local’
[10:19:51.471]   - Field: ‘owner’
[10:19:51.471]   - Field: ‘envir’
[10:19:51.471]   - Field: ‘packages’
[10:19:51.471]   - Field: ‘gc’
[10:19:51.471]   - Field: ‘conditions’
[10:19:51.471]   - Field: ‘expr’
[10:19:51.471]   - Field: ‘uuid’
[10:19:51.472]   - Field: ‘seed’
[10:19:51.472]   - Field: ‘version’
[10:19:51.472]   - Field: ‘result’
[10:19:51.472]   - Field: ‘asynchronous’
[10:19:51.472]   - Field: ‘calls’
[10:19:51.472]   - Field: ‘globals’
[10:19:51.472]   - Field: ‘stdout’
[10:19:51.472]   - Field: ‘earlySignal’
[10:19:51.472]   - Field: ‘lazy’
[10:19:51.472]   - Field: ‘state’
[10:19:51.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.472] - Launch lazy future ...
[10:19:51.473] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.473] Packages needed by future strategies (n = 0): <none>
[10:19:51.473] {
[10:19:51.473]     {
[10:19:51.473]         {
[10:19:51.473]             ...future.startTime <- base::Sys.time()
[10:19:51.473]             {
[10:19:51.473]                 {
[10:19:51.473]                   {
[10:19:51.473]                     {
[10:19:51.473]                       base::local({
[10:19:51.473]                         has_future <- base::requireNamespace("future", 
[10:19:51.473]                           quietly = TRUE)
[10:19:51.473]                         if (has_future) {
[10:19:51.473]                           ns <- base::getNamespace("future")
[10:19:51.473]                           version <- ns[[".package"]][["version"]]
[10:19:51.473]                           if (is.null(version)) 
[10:19:51.473]                             version <- utils::packageVersion("future")
[10:19:51.473]                         }
[10:19:51.473]                         else {
[10:19:51.473]                           version <- NULL
[10:19:51.473]                         }
[10:19:51.473]                         if (!has_future || version < "1.8.0") {
[10:19:51.473]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.473]                             "", base::R.version$version.string), 
[10:19:51.473]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.473]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.473]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.473]                               "release", "version")], collapse = " "), 
[10:19:51.473]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.473]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.473]                             info)
[10:19:51.473]                           info <- base::paste(info, collapse = "; ")
[10:19:51.473]                           if (!has_future) {
[10:19:51.473]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.473]                               info)
[10:19:51.473]                           }
[10:19:51.473]                           else {
[10:19:51.473]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.473]                               info, version)
[10:19:51.473]                           }
[10:19:51.473]                           base::stop(msg)
[10:19:51.473]                         }
[10:19:51.473]                       })
[10:19:51.473]                     }
[10:19:51.473]                     base::local({
[10:19:51.473]                       for (pkg in "future.apply") {
[10:19:51.473]                         base::loadNamespace(pkg)
[10:19:51.473]                         base::library(pkg, character.only = TRUE)
[10:19:51.473]                       }
[10:19:51.473]                     })
[10:19:51.473]                   }
[10:19:51.473]                   ...future.strategy.old <- future::plan("list")
[10:19:51.473]                   options(future.plan = NULL)
[10:19:51.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.473]                 }
[10:19:51.473]                 ...future.workdir <- getwd()
[10:19:51.473]             }
[10:19:51.473]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.473]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.473]         }
[10:19:51.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.473]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.473]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.473]             base::names(...future.oldOptions))
[10:19:51.473]     }
[10:19:51.473]     if (FALSE) {
[10:19:51.473]     }
[10:19:51.473]     else {
[10:19:51.473]         if (TRUE) {
[10:19:51.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.473]                 open = "w")
[10:19:51.473]         }
[10:19:51.473]         else {
[10:19:51.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.473]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.473]         }
[10:19:51.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.473]             base::sink(type = "output", split = FALSE)
[10:19:51.473]             base::close(...future.stdout)
[10:19:51.473]         }, add = TRUE)
[10:19:51.473]     }
[10:19:51.473]     ...future.frame <- base::sys.nframe()
[10:19:51.473]     ...future.conditions <- base::list()
[10:19:51.473]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.473]     if (FALSE) {
[10:19:51.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.473]     }
[10:19:51.473]     ...future.result <- base::tryCatch({
[10:19:51.473]         base::withCallingHandlers({
[10:19:51.473]             ...future.value <- base::withVisible(base::local({
[10:19:51.473]                 do.call(function(...) {
[10:19:51.473]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.473]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.473]                     ...future.globals.maxSize)) {
[10:19:51.473]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.473]                     on.exit(options(oopts), add = TRUE)
[10:19:51.473]                   }
[10:19:51.473]                   {
[10:19:51.473]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.473]                       FUN = function(jj) {
[10:19:51.473]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.473]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.473]                       })
[10:19:51.473]                   }
[10:19:51.473]                 }, args = future.call.arguments)
[10:19:51.473]             }))
[10:19:51.473]             future::FutureResult(value = ...future.value$value, 
[10:19:51.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.473]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.473]                     ...future.globalenv.names))
[10:19:51.473]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.473]         }, condition = base::local({
[10:19:51.473]             c <- base::c
[10:19:51.473]             inherits <- base::inherits
[10:19:51.473]             invokeRestart <- base::invokeRestart
[10:19:51.473]             length <- base::length
[10:19:51.473]             list <- base::list
[10:19:51.473]             seq.int <- base::seq.int
[10:19:51.473]             signalCondition <- base::signalCondition
[10:19:51.473]             sys.calls <- base::sys.calls
[10:19:51.473]             `[[` <- base::`[[`
[10:19:51.473]             `+` <- base::`+`
[10:19:51.473]             `<<-` <- base::`<<-`
[10:19:51.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.473]                   3L)]
[10:19:51.473]             }
[10:19:51.473]             function(cond) {
[10:19:51.473]                 is_error <- inherits(cond, "error")
[10:19:51.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.473]                   NULL)
[10:19:51.473]                 if (is_error) {
[10:19:51.473]                   sessionInformation <- function() {
[10:19:51.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.473]                       search = base::search(), system = base::Sys.info())
[10:19:51.473]                   }
[10:19:51.473]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.473]                     cond$call), session = sessionInformation(), 
[10:19:51.473]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.473]                   signalCondition(cond)
[10:19:51.473]                 }
[10:19:51.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.473]                 "immediateCondition"))) {
[10:19:51.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.473]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.473]                   if (TRUE && !signal) {
[10:19:51.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.473]                     {
[10:19:51.473]                       inherits <- base::inherits
[10:19:51.473]                       invokeRestart <- base::invokeRestart
[10:19:51.473]                       is.null <- base::is.null
[10:19:51.473]                       muffled <- FALSE
[10:19:51.473]                       if (inherits(cond, "message")) {
[10:19:51.473]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.473]                         if (muffled) 
[10:19:51.473]                           invokeRestart("muffleMessage")
[10:19:51.473]                       }
[10:19:51.473]                       else if (inherits(cond, "warning")) {
[10:19:51.473]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.473]                         if (muffled) 
[10:19:51.473]                           invokeRestart("muffleWarning")
[10:19:51.473]                       }
[10:19:51.473]                       else if (inherits(cond, "condition")) {
[10:19:51.473]                         if (!is.null(pattern)) {
[10:19:51.473]                           computeRestarts <- base::computeRestarts
[10:19:51.473]                           grepl <- base::grepl
[10:19:51.473]                           restarts <- computeRestarts(cond)
[10:19:51.473]                           for (restart in restarts) {
[10:19:51.473]                             name <- restart$name
[10:19:51.473]                             if (is.null(name)) 
[10:19:51.473]                               next
[10:19:51.473]                             if (!grepl(pattern, name)) 
[10:19:51.473]                               next
[10:19:51.473]                             invokeRestart(restart)
[10:19:51.473]                             muffled <- TRUE
[10:19:51.473]                             break
[10:19:51.473]                           }
[10:19:51.473]                         }
[10:19:51.473]                       }
[10:19:51.473]                       invisible(muffled)
[10:19:51.473]                     }
[10:19:51.473]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.473]                   }
[10:19:51.473]                 }
[10:19:51.473]                 else {
[10:19:51.473]                   if (TRUE) {
[10:19:51.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.473]                     {
[10:19:51.473]                       inherits <- base::inherits
[10:19:51.473]                       invokeRestart <- base::invokeRestart
[10:19:51.473]                       is.null <- base::is.null
[10:19:51.473]                       muffled <- FALSE
[10:19:51.473]                       if (inherits(cond, "message")) {
[10:19:51.473]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.473]                         if (muffled) 
[10:19:51.473]                           invokeRestart("muffleMessage")
[10:19:51.473]                       }
[10:19:51.473]                       else if (inherits(cond, "warning")) {
[10:19:51.473]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.473]                         if (muffled) 
[10:19:51.473]                           invokeRestart("muffleWarning")
[10:19:51.473]                       }
[10:19:51.473]                       else if (inherits(cond, "condition")) {
[10:19:51.473]                         if (!is.null(pattern)) {
[10:19:51.473]                           computeRestarts <- base::computeRestarts
[10:19:51.473]                           grepl <- base::grepl
[10:19:51.473]                           restarts <- computeRestarts(cond)
[10:19:51.473]                           for (restart in restarts) {
[10:19:51.473]                             name <- restart$name
[10:19:51.473]                             if (is.null(name)) 
[10:19:51.473]                               next
[10:19:51.473]                             if (!grepl(pattern, name)) 
[10:19:51.473]                               next
[10:19:51.473]                             invokeRestart(restart)
[10:19:51.473]                             muffled <- TRUE
[10:19:51.473]                             break
[10:19:51.473]                           }
[10:19:51.473]                         }
[10:19:51.473]                       }
[10:19:51.473]                       invisible(muffled)
[10:19:51.473]                     }
[10:19:51.473]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.473]                   }
[10:19:51.473]                 }
[10:19:51.473]             }
[10:19:51.473]         }))
[10:19:51.473]     }, error = function(ex) {
[10:19:51.473]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.473]                 ...future.rng), started = ...future.startTime, 
[10:19:51.473]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.473]             version = "1.8"), class = "FutureResult")
[10:19:51.473]     }, finally = {
[10:19:51.473]         if (!identical(...future.workdir, getwd())) 
[10:19:51.473]             setwd(...future.workdir)
[10:19:51.473]         {
[10:19:51.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.473]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.473]             }
[10:19:51.473]             base::options(...future.oldOptions)
[10:19:51.473]             if (.Platform$OS.type == "windows") {
[10:19:51.473]                 old_names <- names(...future.oldEnvVars)
[10:19:51.473]                 envs <- base::Sys.getenv()
[10:19:51.473]                 names <- names(envs)
[10:19:51.473]                 common <- intersect(names, old_names)
[10:19:51.473]                 added <- setdiff(names, old_names)
[10:19:51.473]                 removed <- setdiff(old_names, names)
[10:19:51.473]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.473]                   envs[common]]
[10:19:51.473]                 NAMES <- toupper(changed)
[10:19:51.473]                 args <- list()
[10:19:51.473]                 for (kk in seq_along(NAMES)) {
[10:19:51.473]                   name <- changed[[kk]]
[10:19:51.473]                   NAME <- NAMES[[kk]]
[10:19:51.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.473]                     next
[10:19:51.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.473]                 }
[10:19:51.473]                 NAMES <- toupper(added)
[10:19:51.473]                 for (kk in seq_along(NAMES)) {
[10:19:51.473]                   name <- added[[kk]]
[10:19:51.473]                   NAME <- NAMES[[kk]]
[10:19:51.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.473]                     next
[10:19:51.473]                   args[[name]] <- ""
[10:19:51.473]                 }
[10:19:51.473]                 NAMES <- toupper(removed)
[10:19:51.473]                 for (kk in seq_along(NAMES)) {
[10:19:51.473]                   name <- removed[[kk]]
[10:19:51.473]                   NAME <- NAMES[[kk]]
[10:19:51.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.473]                     next
[10:19:51.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.473]                 }
[10:19:51.473]                 if (length(args) > 0) 
[10:19:51.473]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.473]             }
[10:19:51.473]             else {
[10:19:51.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.473]             }
[10:19:51.473]             {
[10:19:51.473]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.473]                   0L) {
[10:19:51.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.473]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.473]                   base::options(opts)
[10:19:51.473]                 }
[10:19:51.473]                 {
[10:19:51.473]                   {
[10:19:51.473]                     NULL
[10:19:51.473]                     RNGkind("Mersenne-Twister")
[10:19:51.473]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.473]                       inherits = FALSE)
[10:19:51.473]                   }
[10:19:51.473]                   options(future.plan = NULL)
[10:19:51.473]                   if (is.na(NA_character_)) 
[10:19:51.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.473]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.473]                     .init = FALSE)
[10:19:51.473]                 }
[10:19:51.473]             }
[10:19:51.473]         }
[10:19:51.473]     })
[10:19:51.473]     if (TRUE) {
[10:19:51.473]         base::sink(type = "output", split = FALSE)
[10:19:51.473]         if (TRUE) {
[10:19:51.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.473]         }
[10:19:51.473]         else {
[10:19:51.473]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.473]         }
[10:19:51.473]         base::close(...future.stdout)
[10:19:51.473]         ...future.stdout <- NULL
[10:19:51.473]     }
[10:19:51.473]     ...future.result$conditions <- ...future.conditions
[10:19:51.473]     ...future.result$finished <- base::Sys.time()
[10:19:51.473]     ...future.result
[10:19:51.473] }
[10:19:51.475] assign_globals() ...
[10:19:51.475] List of 11
[10:19:51.475]  $ ...future.FUN            :function (x, ...)  
[10:19:51.475]  $ x_FUN                    :function (x)  
[10:19:51.475]  $ times                    : int 4
[10:19:51.475]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.475]  $ stop_if_not              :function (...)  
[10:19:51.475]  $ dim                      : int [1:2] 2 2
[10:19:51.475]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.475]  $ future.call.arguments    : list()
[10:19:51.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.475]  $ ...future.elements_ii    :List of 10
[10:19:51.475]   ..$ : int 1
[10:19:51.475]   ..$ : int 2
[10:19:51.475]   ..$ : int 3
[10:19:51.475]   ..$ : int 4
[10:19:51.475]   ..$ : int 5
[10:19:51.475]   ..$ : int 6
[10:19:51.475]   ..$ : int 7
[10:19:51.475]   ..$ : int 8
[10:19:51.475]   ..$ : int 9
[10:19:51.475]   ..$ : int 10
[10:19:51.475]  $ ...future.seeds_ii       : NULL
[10:19:51.475]  $ ...future.globals.maxSize: NULL
[10:19:51.475]  - attr(*, "where")=List of 11
[10:19:51.475]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.475]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.475]  - attr(*, "resolved")= logi FALSE
[10:19:51.475]  - attr(*, "total_size")= num 29094
[10:19:51.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.475]  - attr(*, "already-done")= logi TRUE
[10:19:51.485] - copied ‘...future.FUN’ to environment
[10:19:51.485] - reassign environment for ‘x_FUN’
[10:19:51.485] - copied ‘x_FUN’ to environment
[10:19:51.486] - copied ‘times’ to environment
[10:19:51.486] - copied ‘stopf’ to environment
[10:19:51.486] - copied ‘stop_if_not’ to environment
[10:19:51.486] - copied ‘dim’ to environment
[10:19:51.486] - copied ‘valid_types’ to environment
[10:19:51.486] - copied ‘future.call.arguments’ to environment
[10:19:51.486] - copied ‘...future.elements_ii’ to environment
[10:19:51.486] - copied ‘...future.seeds_ii’ to environment
[10:19:51.486] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.486] assign_globals() ... done
[10:19:51.487] plan(): Setting new future strategy stack:
[10:19:51.487] List of future strategies:
[10:19:51.487] 1. sequential:
[10:19:51.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.487]    - tweaked: FALSE
[10:19:51.487]    - call: NULL
[10:19:51.487] plan(): nbrOfWorkers() = 1
[10:19:51.488] plan(): Setting new future strategy stack:
[10:19:51.488] List of future strategies:
[10:19:51.488] 1. sequential:
[10:19:51.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.488]    - tweaked: FALSE
[10:19:51.488]    - call: plan(strategy)
[10:19:51.489] plan(): nbrOfWorkers() = 1
[10:19:51.489] SequentialFuture started (and completed)
[10:19:51.489] - Launch lazy future ... done
[10:19:51.489] run() for ‘SequentialFuture’ ... done
[10:19:51.489] Created future:
[10:19:51.489] SequentialFuture:
[10:19:51.489] Label: ‘future_vapply-1’
[10:19:51.489] Expression:
[10:19:51.489] {
[10:19:51.489]     do.call(function(...) {
[10:19:51.489]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.489]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.489]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.489]             on.exit(options(oopts), add = TRUE)
[10:19:51.489]         }
[10:19:51.489]         {
[10:19:51.489]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.489]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.489]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.489]             })
[10:19:51.489]         }
[10:19:51.489]     }, args = future.call.arguments)
[10:19:51.489] }
[10:19:51.489] Lazy evaluation: FALSE
[10:19:51.489] Asynchronous evaluation: FALSE
[10:19:51.489] Local evaluation: TRUE
[10:19:51.489] Environment: R_GlobalEnv
[10:19:51.489] Capture standard output: TRUE
[10:19:51.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.489] Globals: 11 objects totaling 16.34 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.489] Packages: 1 packages (‘future.apply’)
[10:19:51.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.489] Resolved: TRUE
[10:19:51.489] Value: 1.23 KiB of class ‘list’
[10:19:51.489] Early signaling: FALSE
[10:19:51.489] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.489] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.490] Chunk #1 of 1 ... DONE
[10:19:51.490] Launching 1 futures (chunks) ... DONE
[10:19:51.490] Resolving 1 futures (chunks) ...
[10:19:51.490] resolve() on list ...
[10:19:51.490]  recursive: 0
[10:19:51.490]  length: 1
[10:19:51.491] 
[10:19:51.491] resolved() for ‘SequentialFuture’ ...
[10:19:51.491] - state: ‘finished’
[10:19:51.491] - run: TRUE
[10:19:51.491] - result: ‘FutureResult’
[10:19:51.491] resolved() for ‘SequentialFuture’ ... done
[10:19:51.491] Future #1
[10:19:51.491] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.491] - nx: 1
[10:19:51.491] - relay: TRUE
[10:19:51.491] - stdout: TRUE
[10:19:51.491] - signal: TRUE
[10:19:51.492] - resignal: FALSE
[10:19:51.492] - force: TRUE
[10:19:51.492] - relayed: [n=1] FALSE
[10:19:51.492] - queued futures: [n=1] FALSE
[10:19:51.492]  - until=1
[10:19:51.492]  - relaying element #1
[10:19:51.492] - relayed: [n=1] TRUE
[10:19:51.492] - queued futures: [n=1] TRUE
[10:19:51.492] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.492]  length: 0 (resolved future 1)
[10:19:51.492] Relaying remaining futures
[10:19:51.493] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.493] - nx: 1
[10:19:51.493] - relay: TRUE
[10:19:51.493] - stdout: TRUE
[10:19:51.493] - signal: TRUE
[10:19:51.493] - resignal: FALSE
[10:19:51.493] - force: TRUE
[10:19:51.493] - relayed: [n=1] TRUE
[10:19:51.493] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.493] - relayed: [n=1] TRUE
[10:19:51.493] - queued futures: [n=1] TRUE
[10:19:51.493] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.493] resolve() on list ... DONE
[10:19:51.494]  - Number of value chunks collected: 1
[10:19:51.494] Resolving 1 futures (chunks) ... DONE
[10:19:51.494] Reducing values from 1 chunks ...
[10:19:51.494]  - Number of values collected after concatenation: 10
[10:19:51.494]  - Number of values expected: 10
[10:19:51.494] Reducing values from 1 chunks ... DONE
[10:19:51.494] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:19:51.497] future_lapply() ...
[10:19:51.499] Number of chunks: 1
[10:19:51.499] getGlobalsAndPackagesXApply() ...
[10:19:51.499]  - future.globals: TRUE
[10:19:51.499] getGlobalsAndPackages() ...
[10:19:51.499] Searching for globals...
[10:19:51.503] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:19:51.504] Searching for globals ... DONE
[10:19:51.504] Resolving globals: FALSE
[10:19:51.504] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[10:19:51.505] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.505] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.505] - packages: [2] ‘stats’, ‘future.apply’
[10:19:51.505] getGlobalsAndPackages() ... DONE
[10:19:51.505]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.505]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:19:51.505] Finding globals ... DONE
[10:19:51.506]  - use_args: TRUE
[10:19:51.506]  - Getting '...' globals ...
[10:19:51.506] resolve() on list ...
[10:19:51.506]  recursive: 0
[10:19:51.506]  length: 1
[10:19:51.506]  elements: ‘...’
[10:19:51.506]  length: 0 (resolved future 1)
[10:19:51.506] resolve() on list ... DONE
[10:19:51.506]    - '...' content: [n=0] 
[10:19:51.507] List of 1
[10:19:51.507]  $ ...: list()
[10:19:51.507]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.507]  - attr(*, "where")=List of 1
[10:19:51.507]   ..$ ...:<environment: 0x55c6a0001758> 
[10:19:51.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.507]  - attr(*, "resolved")= logi TRUE
[10:19:51.507]  - attr(*, "total_size")= num NA
[10:19:51.509]  - Getting '...' globals ... DONE
[10:19:51.509] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.509] List of 8
[10:19:51.509]  $ ...future.FUN:function (x, ...)  
[10:19:51.509]  $ x_FUN        :function (x, ...)  
[10:19:51.509]  $ times        : int 5
[10:19:51.509]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.509]  $ stop_if_not  :function (...)  
[10:19:51.509]  $ dim          : NULL
[10:19:51.509]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.509]  $ ...          : list()
[10:19:51.509]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.509]  - attr(*, "where")=List of 8
[10:19:51.509]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.509]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.509]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.509]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.509]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.509]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.509]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.509]   ..$ ...          :<environment: 0x55c6a0001758> 
[10:19:51.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.509]  - attr(*, "resolved")= logi FALSE
[10:19:51.509]  - attr(*, "total_size")= num 24127
[10:19:51.514] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:19:51.514] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.514] Number of futures (= number of chunks): 1
[10:19:51.514] Launching 1 futures (chunks) ...
[10:19:51.514] Chunk #1 of 1 ...
[10:19:51.514]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.514] getGlobalsAndPackages() ...
[10:19:51.515] Searching for globals...
[10:19:51.515] 
[10:19:51.515] Searching for globals ... DONE
[10:19:51.515] - globals: [0] <none>
[10:19:51.515] getGlobalsAndPackages() ... DONE
[10:19:51.515]    + additional globals found: [n=0] 
[10:19:51.515]    + additional namespaces needed: [n=0] 
[10:19:51.515]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.515]  - seeds: <none>
[10:19:51.515]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.516] getGlobalsAndPackages() ...
[10:19:51.516] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.516] Resolving globals: FALSE
[10:19:51.516] Tweak future expression to call with '...' arguments ...
[10:19:51.516] {
[10:19:51.516]     do.call(function(...) {
[10:19:51.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.516]             on.exit(options(oopts), add = TRUE)
[10:19:51.516]         }
[10:19:51.516]         {
[10:19:51.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.516]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.516]             })
[10:19:51.516]         }
[10:19:51.516]     }, args = future.call.arguments)
[10:19:51.516] }
[10:19:51.516] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.517] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.517] - packages: [2] ‘stats’, ‘future.apply’
[10:19:51.517] getGlobalsAndPackages() ... DONE
[10:19:51.517] run() for ‘Future’ ...
[10:19:51.517] - state: ‘created’
[10:19:51.517] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.518] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.518]   - Field: ‘label’
[10:19:51.518]   - Field: ‘local’
[10:19:51.518]   - Field: ‘owner’
[10:19:51.518]   - Field: ‘envir’
[10:19:51.518]   - Field: ‘packages’
[10:19:51.518]   - Field: ‘gc’
[10:19:51.518]   - Field: ‘conditions’
[10:19:51.518]   - Field: ‘expr’
[10:19:51.518]   - Field: ‘uuid’
[10:19:51.519]   - Field: ‘seed’
[10:19:51.519]   - Field: ‘version’
[10:19:51.519]   - Field: ‘result’
[10:19:51.519]   - Field: ‘asynchronous’
[10:19:51.519]   - Field: ‘calls’
[10:19:51.519]   - Field: ‘globals’
[10:19:51.519]   - Field: ‘stdout’
[10:19:51.519]   - Field: ‘earlySignal’
[10:19:51.519]   - Field: ‘lazy’
[10:19:51.519]   - Field: ‘state’
[10:19:51.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.519] - Launch lazy future ...
[10:19:51.520] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:51.520] Packages needed by future strategies (n = 0): <none>
[10:19:51.520] {
[10:19:51.520]     {
[10:19:51.520]         {
[10:19:51.520]             ...future.startTime <- base::Sys.time()
[10:19:51.520]             {
[10:19:51.520]                 {
[10:19:51.520]                   {
[10:19:51.520]                     {
[10:19:51.520]                       base::local({
[10:19:51.520]                         has_future <- base::requireNamespace("future", 
[10:19:51.520]                           quietly = TRUE)
[10:19:51.520]                         if (has_future) {
[10:19:51.520]                           ns <- base::getNamespace("future")
[10:19:51.520]                           version <- ns[[".package"]][["version"]]
[10:19:51.520]                           if (is.null(version)) 
[10:19:51.520]                             version <- utils::packageVersion("future")
[10:19:51.520]                         }
[10:19:51.520]                         else {
[10:19:51.520]                           version <- NULL
[10:19:51.520]                         }
[10:19:51.520]                         if (!has_future || version < "1.8.0") {
[10:19:51.520]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.520]                             "", base::R.version$version.string), 
[10:19:51.520]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.520]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.520]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.520]                               "release", "version")], collapse = " "), 
[10:19:51.520]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.520]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.520]                             info)
[10:19:51.520]                           info <- base::paste(info, collapse = "; ")
[10:19:51.520]                           if (!has_future) {
[10:19:51.520]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.520]                               info)
[10:19:51.520]                           }
[10:19:51.520]                           else {
[10:19:51.520]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.520]                               info, version)
[10:19:51.520]                           }
[10:19:51.520]                           base::stop(msg)
[10:19:51.520]                         }
[10:19:51.520]                       })
[10:19:51.520]                     }
[10:19:51.520]                     base::local({
[10:19:51.520]                       for (pkg in c("stats", "future.apply")) {
[10:19:51.520]                         base::loadNamespace(pkg)
[10:19:51.520]                         base::library(pkg, character.only = TRUE)
[10:19:51.520]                       }
[10:19:51.520]                     })
[10:19:51.520]                   }
[10:19:51.520]                   ...future.strategy.old <- future::plan("list")
[10:19:51.520]                   options(future.plan = NULL)
[10:19:51.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.520]                 }
[10:19:51.520]                 ...future.workdir <- getwd()
[10:19:51.520]             }
[10:19:51.520]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.520]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.520]         }
[10:19:51.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.520]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.520]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.520]             base::names(...future.oldOptions))
[10:19:51.520]     }
[10:19:51.520]     if (FALSE) {
[10:19:51.520]     }
[10:19:51.520]     else {
[10:19:51.520]         if (TRUE) {
[10:19:51.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.520]                 open = "w")
[10:19:51.520]         }
[10:19:51.520]         else {
[10:19:51.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.520]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.520]         }
[10:19:51.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.520]             base::sink(type = "output", split = FALSE)
[10:19:51.520]             base::close(...future.stdout)
[10:19:51.520]         }, add = TRUE)
[10:19:51.520]     }
[10:19:51.520]     ...future.frame <- base::sys.nframe()
[10:19:51.520]     ...future.conditions <- base::list()
[10:19:51.520]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.520]     if (FALSE) {
[10:19:51.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.520]     }
[10:19:51.520]     ...future.result <- base::tryCatch({
[10:19:51.520]         base::withCallingHandlers({
[10:19:51.520]             ...future.value <- base::withVisible(base::local({
[10:19:51.520]                 do.call(function(...) {
[10:19:51.520]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.520]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.520]                     ...future.globals.maxSize)) {
[10:19:51.520]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.520]                     on.exit(options(oopts), add = TRUE)
[10:19:51.520]                   }
[10:19:51.520]                   {
[10:19:51.520]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.520]                       FUN = function(jj) {
[10:19:51.520]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.520]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.520]                       })
[10:19:51.520]                   }
[10:19:51.520]                 }, args = future.call.arguments)
[10:19:51.520]             }))
[10:19:51.520]             future::FutureResult(value = ...future.value$value, 
[10:19:51.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.520]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.520]                     ...future.globalenv.names))
[10:19:51.520]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.520]         }, condition = base::local({
[10:19:51.520]             c <- base::c
[10:19:51.520]             inherits <- base::inherits
[10:19:51.520]             invokeRestart <- base::invokeRestart
[10:19:51.520]             length <- base::length
[10:19:51.520]             list <- base::list
[10:19:51.520]             seq.int <- base::seq.int
[10:19:51.520]             signalCondition <- base::signalCondition
[10:19:51.520]             sys.calls <- base::sys.calls
[10:19:51.520]             `[[` <- base::`[[`
[10:19:51.520]             `+` <- base::`+`
[10:19:51.520]             `<<-` <- base::`<<-`
[10:19:51.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.520]                   3L)]
[10:19:51.520]             }
[10:19:51.520]             function(cond) {
[10:19:51.520]                 is_error <- inherits(cond, "error")
[10:19:51.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.520]                   NULL)
[10:19:51.520]                 if (is_error) {
[10:19:51.520]                   sessionInformation <- function() {
[10:19:51.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.520]                       search = base::search(), system = base::Sys.info())
[10:19:51.520]                   }
[10:19:51.520]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.520]                     cond$call), session = sessionInformation(), 
[10:19:51.520]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.520]                   signalCondition(cond)
[10:19:51.520]                 }
[10:19:51.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.520]                 "immediateCondition"))) {
[10:19:51.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.520]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.520]                   if (TRUE && !signal) {
[10:19:51.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.520]                     {
[10:19:51.520]                       inherits <- base::inherits
[10:19:51.520]                       invokeRestart <- base::invokeRestart
[10:19:51.520]                       is.null <- base::is.null
[10:19:51.520]                       muffled <- FALSE
[10:19:51.520]                       if (inherits(cond, "message")) {
[10:19:51.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.520]                         if (muffled) 
[10:19:51.520]                           invokeRestart("muffleMessage")
[10:19:51.520]                       }
[10:19:51.520]                       else if (inherits(cond, "warning")) {
[10:19:51.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.520]                         if (muffled) 
[10:19:51.520]                           invokeRestart("muffleWarning")
[10:19:51.520]                       }
[10:19:51.520]                       else if (inherits(cond, "condition")) {
[10:19:51.520]                         if (!is.null(pattern)) {
[10:19:51.520]                           computeRestarts <- base::computeRestarts
[10:19:51.520]                           grepl <- base::grepl
[10:19:51.520]                           restarts <- computeRestarts(cond)
[10:19:51.520]                           for (restart in restarts) {
[10:19:51.520]                             name <- restart$name
[10:19:51.520]                             if (is.null(name)) 
[10:19:51.520]                               next
[10:19:51.520]                             if (!grepl(pattern, name)) 
[10:19:51.520]                               next
[10:19:51.520]                             invokeRestart(restart)
[10:19:51.520]                             muffled <- TRUE
[10:19:51.520]                             break
[10:19:51.520]                           }
[10:19:51.520]                         }
[10:19:51.520]                       }
[10:19:51.520]                       invisible(muffled)
[10:19:51.520]                     }
[10:19:51.520]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.520]                   }
[10:19:51.520]                 }
[10:19:51.520]                 else {
[10:19:51.520]                   if (TRUE) {
[10:19:51.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.520]                     {
[10:19:51.520]                       inherits <- base::inherits
[10:19:51.520]                       invokeRestart <- base::invokeRestart
[10:19:51.520]                       is.null <- base::is.null
[10:19:51.520]                       muffled <- FALSE
[10:19:51.520]                       if (inherits(cond, "message")) {
[10:19:51.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.520]                         if (muffled) 
[10:19:51.520]                           invokeRestart("muffleMessage")
[10:19:51.520]                       }
[10:19:51.520]                       else if (inherits(cond, "warning")) {
[10:19:51.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.520]                         if (muffled) 
[10:19:51.520]                           invokeRestart("muffleWarning")
[10:19:51.520]                       }
[10:19:51.520]                       else if (inherits(cond, "condition")) {
[10:19:51.520]                         if (!is.null(pattern)) {
[10:19:51.520]                           computeRestarts <- base::computeRestarts
[10:19:51.520]                           grepl <- base::grepl
[10:19:51.520]                           restarts <- computeRestarts(cond)
[10:19:51.520]                           for (restart in restarts) {
[10:19:51.520]                             name <- restart$name
[10:19:51.520]                             if (is.null(name)) 
[10:19:51.520]                               next
[10:19:51.520]                             if (!grepl(pattern, name)) 
[10:19:51.520]                               next
[10:19:51.520]                             invokeRestart(restart)
[10:19:51.520]                             muffled <- TRUE
[10:19:51.520]                             break
[10:19:51.520]                           }
[10:19:51.520]                         }
[10:19:51.520]                       }
[10:19:51.520]                       invisible(muffled)
[10:19:51.520]                     }
[10:19:51.520]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.520]                   }
[10:19:51.520]                 }
[10:19:51.520]             }
[10:19:51.520]         }))
[10:19:51.520]     }, error = function(ex) {
[10:19:51.520]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.520]                 ...future.rng), started = ...future.startTime, 
[10:19:51.520]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.520]             version = "1.8"), class = "FutureResult")
[10:19:51.520]     }, finally = {
[10:19:51.520]         if (!identical(...future.workdir, getwd())) 
[10:19:51.520]             setwd(...future.workdir)
[10:19:51.520]         {
[10:19:51.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.520]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.520]             }
[10:19:51.520]             base::options(...future.oldOptions)
[10:19:51.520]             if (.Platform$OS.type == "windows") {
[10:19:51.520]                 old_names <- names(...future.oldEnvVars)
[10:19:51.520]                 envs <- base::Sys.getenv()
[10:19:51.520]                 names <- names(envs)
[10:19:51.520]                 common <- intersect(names, old_names)
[10:19:51.520]                 added <- setdiff(names, old_names)
[10:19:51.520]                 removed <- setdiff(old_names, names)
[10:19:51.520]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.520]                   envs[common]]
[10:19:51.520]                 NAMES <- toupper(changed)
[10:19:51.520]                 args <- list()
[10:19:51.520]                 for (kk in seq_along(NAMES)) {
[10:19:51.520]                   name <- changed[[kk]]
[10:19:51.520]                   NAME <- NAMES[[kk]]
[10:19:51.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.520]                     next
[10:19:51.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.520]                 }
[10:19:51.520]                 NAMES <- toupper(added)
[10:19:51.520]                 for (kk in seq_along(NAMES)) {
[10:19:51.520]                   name <- added[[kk]]
[10:19:51.520]                   NAME <- NAMES[[kk]]
[10:19:51.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.520]                     next
[10:19:51.520]                   args[[name]] <- ""
[10:19:51.520]                 }
[10:19:51.520]                 NAMES <- toupper(removed)
[10:19:51.520]                 for (kk in seq_along(NAMES)) {
[10:19:51.520]                   name <- removed[[kk]]
[10:19:51.520]                   NAME <- NAMES[[kk]]
[10:19:51.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.520]                     next
[10:19:51.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.520]                 }
[10:19:51.520]                 if (length(args) > 0) 
[10:19:51.520]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.520]             }
[10:19:51.520]             else {
[10:19:51.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.520]             }
[10:19:51.520]             {
[10:19:51.520]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.520]                   0L) {
[10:19:51.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.520]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.520]                   base::options(opts)
[10:19:51.520]                 }
[10:19:51.520]                 {
[10:19:51.520]                   {
[10:19:51.520]                     NULL
[10:19:51.520]                     RNGkind("Mersenne-Twister")
[10:19:51.520]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.520]                       inherits = FALSE)
[10:19:51.520]                   }
[10:19:51.520]                   options(future.plan = NULL)
[10:19:51.520]                   if (is.na(NA_character_)) 
[10:19:51.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.520]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.520]                     .init = FALSE)
[10:19:51.520]                 }
[10:19:51.520]             }
[10:19:51.520]         }
[10:19:51.520]     })
[10:19:51.520]     if (TRUE) {
[10:19:51.520]         base::sink(type = "output", split = FALSE)
[10:19:51.520]         if (TRUE) {
[10:19:51.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.520]         }
[10:19:51.520]         else {
[10:19:51.520]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.520]         }
[10:19:51.520]         base::close(...future.stdout)
[10:19:51.520]         ...future.stdout <- NULL
[10:19:51.520]     }
[10:19:51.520]     ...future.result$conditions <- ...future.conditions
[10:19:51.520]     ...future.result$finished <- base::Sys.time()
[10:19:51.520]     ...future.result
[10:19:51.520] }
[10:19:51.522] assign_globals() ...
[10:19:51.522] List of 11
[10:19:51.522]  $ ...future.FUN            :function (x, ...)  
[10:19:51.522]  $ x_FUN                    :function (x, ...)  
[10:19:51.522]  $ times                    : int 5
[10:19:51.522]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.522]  $ stop_if_not              :function (...)  
[10:19:51.522]  $ dim                      : NULL
[10:19:51.522]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.522]  $ future.call.arguments    : list()
[10:19:51.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.522]  $ ...future.elements_ii    :List of 3
[10:19:51.522]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:19:51.522]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:19:51.522]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:19:51.522]  $ ...future.seeds_ii       : NULL
[10:19:51.522]  $ ...future.globals.maxSize: NULL
[10:19:51.522]  - attr(*, "where")=List of 11
[10:19:51.522]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.522]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.522]  - attr(*, "resolved")= logi FALSE
[10:19:51.522]  - attr(*, "total_size")= num 24127
[10:19:51.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.522]  - attr(*, "already-done")= logi TRUE
[10:19:51.530] - copied ‘...future.FUN’ to environment
[10:19:51.531] - copied ‘x_FUN’ to environment
[10:19:51.531] - copied ‘times’ to environment
[10:19:51.531] - copied ‘stopf’ to environment
[10:19:51.531] - copied ‘stop_if_not’ to environment
[10:19:51.531] - copied ‘dim’ to environment
[10:19:51.531] - copied ‘valid_types’ to environment
[10:19:51.531] - copied ‘future.call.arguments’ to environment
[10:19:51.531] - copied ‘...future.elements_ii’ to environment
[10:19:51.531] - copied ‘...future.seeds_ii’ to environment
[10:19:51.531] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.531] assign_globals() ... done
[10:19:51.532] plan(): Setting new future strategy stack:
[10:19:51.532] List of future strategies:
[10:19:51.532] 1. sequential:
[10:19:51.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.532]    - tweaked: FALSE
[10:19:51.532]    - call: NULL
[10:19:51.532] plan(): nbrOfWorkers() = 1
[10:19:51.533] plan(): Setting new future strategy stack:
[10:19:51.534] List of future strategies:
[10:19:51.534] 1. sequential:
[10:19:51.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.534]    - tweaked: FALSE
[10:19:51.534]    - call: plan(strategy)
[10:19:51.534] plan(): nbrOfWorkers() = 1
[10:19:51.534] SequentialFuture started (and completed)
[10:19:51.534] - Launch lazy future ... done
[10:19:51.534] run() for ‘SequentialFuture’ ... done
[10:19:51.534] Created future:
[10:19:51.534] SequentialFuture:
[10:19:51.534] Label: ‘future_vapply-1’
[10:19:51.534] Expression:
[10:19:51.534] {
[10:19:51.534]     do.call(function(...) {
[10:19:51.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.534]             on.exit(options(oopts), add = TRUE)
[10:19:51.534]         }
[10:19:51.534]         {
[10:19:51.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.534]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.534]             })
[10:19:51.534]         }
[10:19:51.534]     }, args = future.call.arguments)
[10:19:51.534] }
[10:19:51.534] Lazy evaluation: FALSE
[10:19:51.534] Asynchronous evaluation: FALSE
[10:19:51.534] Local evaluation: TRUE
[10:19:51.534] Environment: R_GlobalEnv
[10:19:51.534] Capture standard output: TRUE
[10:19:51.534] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.534] Globals: 11 objects totaling 13.46 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.534] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:51.534] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.534] Resolved: TRUE
[10:19:51.534] Value: 413 bytes of class ‘list’
[10:19:51.534] Early signaling: FALSE
[10:19:51.534] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.534] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.535] Chunk #1 of 1 ... DONE
[10:19:51.535] Launching 1 futures (chunks) ... DONE
[10:19:51.535] Resolving 1 futures (chunks) ...
[10:19:51.536] resolve() on list ...
[10:19:51.536]  recursive: 0
[10:19:51.536]  length: 1
[10:19:51.536] 
[10:19:51.536] resolved() for ‘SequentialFuture’ ...
[10:19:51.536] - state: ‘finished’
[10:19:51.536] - run: TRUE
[10:19:51.536] - result: ‘FutureResult’
[10:19:51.536] resolved() for ‘SequentialFuture’ ... done
[10:19:51.536] Future #1
[10:19:51.536] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.537] - nx: 1
[10:19:51.537] - relay: TRUE
[10:19:51.537] - stdout: TRUE
[10:19:51.537] - signal: TRUE
[10:19:51.537] - resignal: FALSE
[10:19:51.537] - force: TRUE
[10:19:51.537] - relayed: [n=1] FALSE
[10:19:51.537] - queued futures: [n=1] FALSE
[10:19:51.537]  - until=1
[10:19:51.537]  - relaying element #1
[10:19:51.537] - relayed: [n=1] TRUE
[10:19:51.537] - queued futures: [n=1] TRUE
[10:19:51.538] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.538]  length: 0 (resolved future 1)
[10:19:51.538] Relaying remaining futures
[10:19:51.538] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.538] - nx: 1
[10:19:51.538] - relay: TRUE
[10:19:51.538] - stdout: TRUE
[10:19:51.538] - signal: TRUE
[10:19:51.538] - resignal: FALSE
[10:19:51.538] - force: TRUE
[10:19:51.538] - relayed: [n=1] TRUE
[10:19:51.538] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.539] - relayed: [n=1] TRUE
[10:19:51.539] - queued futures: [n=1] TRUE
[10:19:51.539] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.539] resolve() on list ... DONE
[10:19:51.539]  - Number of value chunks collected: 1
[10:19:51.539] Resolving 1 futures (chunks) ... DONE
[10:19:51.539] Reducing values from 1 chunks ...
[10:19:51.539]  - Number of values collected after concatenation: 3
[10:19:51.539]  - Number of values expected: 3
[10:19:51.539] Reducing values from 1 chunks ... DONE
[10:19:51.539] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:19:51.541] future_lapply() ...
[10:19:51.545] Number of chunks: 1
[10:19:51.545] getGlobalsAndPackagesXApply() ...
[10:19:51.545]  - future.globals: TRUE
[10:19:51.545] getGlobalsAndPackages() ...
[10:19:51.545] Searching for globals...
[10:19:51.550] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:19:51.550] Searching for globals ... DONE
[10:19:51.550] Resolving globals: FALSE
[10:19:51.551] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[10:19:51.551] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[10:19:51.551] - globals: [1] ‘FUN’
[10:19:51.551] - packages: [1] ‘stats’
[10:19:51.551] getGlobalsAndPackages() ... DONE
[10:19:51.551]  - globals found/used: [n=1] ‘FUN’
[10:19:51.552]  - needed namespaces: [n=1] ‘stats’
[10:19:51.552] Finding globals ... DONE
[10:19:51.552]  - use_args: TRUE
[10:19:51.552]  - Getting '...' globals ...
[10:19:51.552] resolve() on list ...
[10:19:51.552]  recursive: 0
[10:19:51.552]  length: 1
[10:19:51.552]  elements: ‘...’
[10:19:51.553]  length: 0 (resolved future 1)
[10:19:51.553] resolve() on list ... DONE
[10:19:51.553]    - '...' content: [n=0] 
[10:19:51.553] List of 1
[10:19:51.553]  $ ...: list()
[10:19:51.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.553]  - attr(*, "where")=List of 1
[10:19:51.553]   ..$ ...:<environment: 0x55c6a0005238> 
[10:19:51.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.553]  - attr(*, "resolved")= logi TRUE
[10:19:51.553]  - attr(*, "total_size")= num NA
[10:19:51.555]  - Getting '...' globals ... DONE
[10:19:51.555] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:19:51.555] List of 2
[10:19:51.555]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:19:51.555]  $ ...          : list()
[10:19:51.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.555]  - attr(*, "where")=List of 2
[10:19:51.555]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.555]   ..$ ...          :<environment: 0x55c6a0005238> 
[10:19:51.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.555]  - attr(*, "resolved")= logi FALSE
[10:19:51.555]  - attr(*, "total_size")= num 18895
[10:19:51.558] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:51.558] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.558] Number of futures (= number of chunks): 1
[10:19:51.558] Launching 1 futures (chunks) ...
[10:19:51.558] Chunk #1 of 1 ...
[10:19:51.558]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.558] getGlobalsAndPackages() ...
[10:19:51.558] Searching for globals...
[10:19:51.559] 
[10:19:51.559] Searching for globals ... DONE
[10:19:51.559] - globals: [0] <none>
[10:19:51.559] getGlobalsAndPackages() ... DONE
[10:19:51.559]    + additional globals found: [n=0] 
[10:19:51.559]    + additional namespaces needed: [n=0] 
[10:19:51.559]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.559]  - seeds: <none>
[10:19:51.559]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.559] getGlobalsAndPackages() ...
[10:19:51.560] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.560] Resolving globals: FALSE
[10:19:51.560] Tweak future expression to call with '...' arguments ...
[10:19:51.560] {
[10:19:51.560]     do.call(function(...) {
[10:19:51.560]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.560]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.560]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.560]             on.exit(options(oopts), add = TRUE)
[10:19:51.560]         }
[10:19:51.560]         {
[10:19:51.560]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.560]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.560]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.560]             })
[10:19:51.560]         }
[10:19:51.560]     }, args = future.call.arguments)
[10:19:51.560] }
[10:19:51.560] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.560] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.561] - packages: [1] ‘stats’
[10:19:51.561] getGlobalsAndPackages() ... DONE
[10:19:51.561] run() for ‘Future’ ...
[10:19:51.561] - state: ‘created’
[10:19:51.561] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.561] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.562]   - Field: ‘label’
[10:19:51.562]   - Field: ‘local’
[10:19:51.562]   - Field: ‘owner’
[10:19:51.562]   - Field: ‘envir’
[10:19:51.562]   - Field: ‘packages’
[10:19:51.562]   - Field: ‘gc’
[10:19:51.562]   - Field: ‘conditions’
[10:19:51.562]   - Field: ‘expr’
[10:19:51.562]   - Field: ‘uuid’
[10:19:51.562]   - Field: ‘seed’
[10:19:51.562]   - Field: ‘version’
[10:19:51.562]   - Field: ‘result’
[10:19:51.563]   - Field: ‘asynchronous’
[10:19:51.563]   - Field: ‘calls’
[10:19:51.564]   - Field: ‘globals’
[10:19:51.564]   - Field: ‘stdout’
[10:19:51.564]   - Field: ‘earlySignal’
[10:19:51.564]   - Field: ‘lazy’
[10:19:51.564]   - Field: ‘state’
[10:19:51.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.564] - Launch lazy future ...
[10:19:51.564] Packages needed by the future expression (n = 1): ‘stats’
[10:19:51.564] Packages needed by future strategies (n = 0): <none>
[10:19:51.565] {
[10:19:51.565]     {
[10:19:51.565]         {
[10:19:51.565]             ...future.startTime <- base::Sys.time()
[10:19:51.565]             {
[10:19:51.565]                 {
[10:19:51.565]                   {
[10:19:51.565]                     {
[10:19:51.565]                       base::local({
[10:19:51.565]                         has_future <- base::requireNamespace("future", 
[10:19:51.565]                           quietly = TRUE)
[10:19:51.565]                         if (has_future) {
[10:19:51.565]                           ns <- base::getNamespace("future")
[10:19:51.565]                           version <- ns[[".package"]][["version"]]
[10:19:51.565]                           if (is.null(version)) 
[10:19:51.565]                             version <- utils::packageVersion("future")
[10:19:51.565]                         }
[10:19:51.565]                         else {
[10:19:51.565]                           version <- NULL
[10:19:51.565]                         }
[10:19:51.565]                         if (!has_future || version < "1.8.0") {
[10:19:51.565]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.565]                             "", base::R.version$version.string), 
[10:19:51.565]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.565]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.565]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.565]                               "release", "version")], collapse = " "), 
[10:19:51.565]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.565]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.565]                             info)
[10:19:51.565]                           info <- base::paste(info, collapse = "; ")
[10:19:51.565]                           if (!has_future) {
[10:19:51.565]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.565]                               info)
[10:19:51.565]                           }
[10:19:51.565]                           else {
[10:19:51.565]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.565]                               info, version)
[10:19:51.565]                           }
[10:19:51.565]                           base::stop(msg)
[10:19:51.565]                         }
[10:19:51.565]                       })
[10:19:51.565]                     }
[10:19:51.565]                     base::local({
[10:19:51.565]                       for (pkg in "stats") {
[10:19:51.565]                         base::loadNamespace(pkg)
[10:19:51.565]                         base::library(pkg, character.only = TRUE)
[10:19:51.565]                       }
[10:19:51.565]                     })
[10:19:51.565]                   }
[10:19:51.565]                   ...future.strategy.old <- future::plan("list")
[10:19:51.565]                   options(future.plan = NULL)
[10:19:51.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.565]                 }
[10:19:51.565]                 ...future.workdir <- getwd()
[10:19:51.565]             }
[10:19:51.565]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.565]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.565]         }
[10:19:51.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.565]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.565]             base::names(...future.oldOptions))
[10:19:51.565]     }
[10:19:51.565]     if (FALSE) {
[10:19:51.565]     }
[10:19:51.565]     else {
[10:19:51.565]         if (TRUE) {
[10:19:51.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.565]                 open = "w")
[10:19:51.565]         }
[10:19:51.565]         else {
[10:19:51.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.565]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.565]         }
[10:19:51.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.565]             base::sink(type = "output", split = FALSE)
[10:19:51.565]             base::close(...future.stdout)
[10:19:51.565]         }, add = TRUE)
[10:19:51.565]     }
[10:19:51.565]     ...future.frame <- base::sys.nframe()
[10:19:51.565]     ...future.conditions <- base::list()
[10:19:51.565]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.565]     if (FALSE) {
[10:19:51.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.565]     }
[10:19:51.565]     ...future.result <- base::tryCatch({
[10:19:51.565]         base::withCallingHandlers({
[10:19:51.565]             ...future.value <- base::withVisible(base::local({
[10:19:51.565]                 do.call(function(...) {
[10:19:51.565]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.565]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.565]                     ...future.globals.maxSize)) {
[10:19:51.565]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.565]                     on.exit(options(oopts), add = TRUE)
[10:19:51.565]                   }
[10:19:51.565]                   {
[10:19:51.565]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.565]                       FUN = function(jj) {
[10:19:51.565]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.565]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.565]                       })
[10:19:51.565]                   }
[10:19:51.565]                 }, args = future.call.arguments)
[10:19:51.565]             }))
[10:19:51.565]             future::FutureResult(value = ...future.value$value, 
[10:19:51.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.565]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.565]                     ...future.globalenv.names))
[10:19:51.565]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.565]         }, condition = base::local({
[10:19:51.565]             c <- base::c
[10:19:51.565]             inherits <- base::inherits
[10:19:51.565]             invokeRestart <- base::invokeRestart
[10:19:51.565]             length <- base::length
[10:19:51.565]             list <- base::list
[10:19:51.565]             seq.int <- base::seq.int
[10:19:51.565]             signalCondition <- base::signalCondition
[10:19:51.565]             sys.calls <- base::sys.calls
[10:19:51.565]             `[[` <- base::`[[`
[10:19:51.565]             `+` <- base::`+`
[10:19:51.565]             `<<-` <- base::`<<-`
[10:19:51.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.565]                   3L)]
[10:19:51.565]             }
[10:19:51.565]             function(cond) {
[10:19:51.565]                 is_error <- inherits(cond, "error")
[10:19:51.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.565]                   NULL)
[10:19:51.565]                 if (is_error) {
[10:19:51.565]                   sessionInformation <- function() {
[10:19:51.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.565]                       search = base::search(), system = base::Sys.info())
[10:19:51.565]                   }
[10:19:51.565]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.565]                     cond$call), session = sessionInformation(), 
[10:19:51.565]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.565]                   signalCondition(cond)
[10:19:51.565]                 }
[10:19:51.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.565]                 "immediateCondition"))) {
[10:19:51.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.565]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.565]                   if (TRUE && !signal) {
[10:19:51.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.565]                     {
[10:19:51.565]                       inherits <- base::inherits
[10:19:51.565]                       invokeRestart <- base::invokeRestart
[10:19:51.565]                       is.null <- base::is.null
[10:19:51.565]                       muffled <- FALSE
[10:19:51.565]                       if (inherits(cond, "message")) {
[10:19:51.565]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.565]                         if (muffled) 
[10:19:51.565]                           invokeRestart("muffleMessage")
[10:19:51.565]                       }
[10:19:51.565]                       else if (inherits(cond, "warning")) {
[10:19:51.565]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.565]                         if (muffled) 
[10:19:51.565]                           invokeRestart("muffleWarning")
[10:19:51.565]                       }
[10:19:51.565]                       else if (inherits(cond, "condition")) {
[10:19:51.565]                         if (!is.null(pattern)) {
[10:19:51.565]                           computeRestarts <- base::computeRestarts
[10:19:51.565]                           grepl <- base::grepl
[10:19:51.565]                           restarts <- computeRestarts(cond)
[10:19:51.565]                           for (restart in restarts) {
[10:19:51.565]                             name <- restart$name
[10:19:51.565]                             if (is.null(name)) 
[10:19:51.565]                               next
[10:19:51.565]                             if (!grepl(pattern, name)) 
[10:19:51.565]                               next
[10:19:51.565]                             invokeRestart(restart)
[10:19:51.565]                             muffled <- TRUE
[10:19:51.565]                             break
[10:19:51.565]                           }
[10:19:51.565]                         }
[10:19:51.565]                       }
[10:19:51.565]                       invisible(muffled)
[10:19:51.565]                     }
[10:19:51.565]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.565]                   }
[10:19:51.565]                 }
[10:19:51.565]                 else {
[10:19:51.565]                   if (TRUE) {
[10:19:51.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.565]                     {
[10:19:51.565]                       inherits <- base::inherits
[10:19:51.565]                       invokeRestart <- base::invokeRestart
[10:19:51.565]                       is.null <- base::is.null
[10:19:51.565]                       muffled <- FALSE
[10:19:51.565]                       if (inherits(cond, "message")) {
[10:19:51.565]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.565]                         if (muffled) 
[10:19:51.565]                           invokeRestart("muffleMessage")
[10:19:51.565]                       }
[10:19:51.565]                       else if (inherits(cond, "warning")) {
[10:19:51.565]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.565]                         if (muffled) 
[10:19:51.565]                           invokeRestart("muffleWarning")
[10:19:51.565]                       }
[10:19:51.565]                       else if (inherits(cond, "condition")) {
[10:19:51.565]                         if (!is.null(pattern)) {
[10:19:51.565]                           computeRestarts <- base::computeRestarts
[10:19:51.565]                           grepl <- base::grepl
[10:19:51.565]                           restarts <- computeRestarts(cond)
[10:19:51.565]                           for (restart in restarts) {
[10:19:51.565]                             name <- restart$name
[10:19:51.565]                             if (is.null(name)) 
[10:19:51.565]                               next
[10:19:51.565]                             if (!grepl(pattern, name)) 
[10:19:51.565]                               next
[10:19:51.565]                             invokeRestart(restart)
[10:19:51.565]                             muffled <- TRUE
[10:19:51.565]                             break
[10:19:51.565]                           }
[10:19:51.565]                         }
[10:19:51.565]                       }
[10:19:51.565]                       invisible(muffled)
[10:19:51.565]                     }
[10:19:51.565]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.565]                   }
[10:19:51.565]                 }
[10:19:51.565]             }
[10:19:51.565]         }))
[10:19:51.565]     }, error = function(ex) {
[10:19:51.565]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.565]                 ...future.rng), started = ...future.startTime, 
[10:19:51.565]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.565]             version = "1.8"), class = "FutureResult")
[10:19:51.565]     }, finally = {
[10:19:51.565]         if (!identical(...future.workdir, getwd())) 
[10:19:51.565]             setwd(...future.workdir)
[10:19:51.565]         {
[10:19:51.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.565]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.565]             }
[10:19:51.565]             base::options(...future.oldOptions)
[10:19:51.565]             if (.Platform$OS.type == "windows") {
[10:19:51.565]                 old_names <- names(...future.oldEnvVars)
[10:19:51.565]                 envs <- base::Sys.getenv()
[10:19:51.565]                 names <- names(envs)
[10:19:51.565]                 common <- intersect(names, old_names)
[10:19:51.565]                 added <- setdiff(names, old_names)
[10:19:51.565]                 removed <- setdiff(old_names, names)
[10:19:51.565]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.565]                   envs[common]]
[10:19:51.565]                 NAMES <- toupper(changed)
[10:19:51.565]                 args <- list()
[10:19:51.565]                 for (kk in seq_along(NAMES)) {
[10:19:51.565]                   name <- changed[[kk]]
[10:19:51.565]                   NAME <- NAMES[[kk]]
[10:19:51.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.565]                     next
[10:19:51.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.565]                 }
[10:19:51.565]                 NAMES <- toupper(added)
[10:19:51.565]                 for (kk in seq_along(NAMES)) {
[10:19:51.565]                   name <- added[[kk]]
[10:19:51.565]                   NAME <- NAMES[[kk]]
[10:19:51.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.565]                     next
[10:19:51.565]                   args[[name]] <- ""
[10:19:51.565]                 }
[10:19:51.565]                 NAMES <- toupper(removed)
[10:19:51.565]                 for (kk in seq_along(NAMES)) {
[10:19:51.565]                   name <- removed[[kk]]
[10:19:51.565]                   NAME <- NAMES[[kk]]
[10:19:51.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.565]                     next
[10:19:51.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.565]                 }
[10:19:51.565]                 if (length(args) > 0) 
[10:19:51.565]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.565]             }
[10:19:51.565]             else {
[10:19:51.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.565]             }
[10:19:51.565]             {
[10:19:51.565]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.565]                   0L) {
[10:19:51.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.565]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.565]                   base::options(opts)
[10:19:51.565]                 }
[10:19:51.565]                 {
[10:19:51.565]                   {
[10:19:51.565]                     NULL
[10:19:51.565]                     RNGkind("Mersenne-Twister")
[10:19:51.565]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.565]                       inherits = FALSE)
[10:19:51.565]                   }
[10:19:51.565]                   options(future.plan = NULL)
[10:19:51.565]                   if (is.na(NA_character_)) 
[10:19:51.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.565]                     .init = FALSE)
[10:19:51.565]                 }
[10:19:51.565]             }
[10:19:51.565]         }
[10:19:51.565]     })
[10:19:51.565]     if (TRUE) {
[10:19:51.565]         base::sink(type = "output", split = FALSE)
[10:19:51.565]         if (TRUE) {
[10:19:51.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.565]         }
[10:19:51.565]         else {
[10:19:51.565]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.565]         }
[10:19:51.565]         base::close(...future.stdout)
[10:19:51.565]         ...future.stdout <- NULL
[10:19:51.565]     }
[10:19:51.565]     ...future.result$conditions <- ...future.conditions
[10:19:51.565]     ...future.result$finished <- base::Sys.time()
[10:19:51.565]     ...future.result
[10:19:51.565] }
[10:19:51.567] assign_globals() ...
[10:19:51.567] List of 5
[10:19:51.567]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:19:51.567]  $ future.call.arguments    : list()
[10:19:51.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.567]  $ ...future.elements_ii    :List of 7
[10:19:51.567]   ..$ : int [1:3] 1 2 3
[10:19:51.567]   ..$ : int [1:4] 1 2 3 4
[10:19:51.567]   ..$ : int [1:5] 1 2 3 4 5
[10:19:51.567]   ..$ : int [1:6] 1 2 3 4 5 6
[10:19:51.567]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:19:51.567]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:19:51.567]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:19:51.567]  $ ...future.seeds_ii       : NULL
[10:19:51.567]  $ ...future.globals.maxSize: NULL
[10:19:51.567]  - attr(*, "where")=List of 5
[10:19:51.567]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.567]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.567]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.567]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.567]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.567]  - attr(*, "resolved")= logi FALSE
[10:19:51.567]  - attr(*, "total_size")= num 18895
[10:19:51.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.567]  - attr(*, "already-done")= logi TRUE
[10:19:51.573] - copied ‘...future.FUN’ to environment
[10:19:51.573] - copied ‘future.call.arguments’ to environment
[10:19:51.573] - copied ‘...future.elements_ii’ to environment
[10:19:51.573] - copied ‘...future.seeds_ii’ to environment
[10:19:51.573] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.573] assign_globals() ... done
[10:19:51.573] plan(): Setting new future strategy stack:
[10:19:51.574] List of future strategies:
[10:19:51.574] 1. sequential:
[10:19:51.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.574]    - tweaked: FALSE
[10:19:51.574]    - call: NULL
[10:19:51.574] plan(): nbrOfWorkers() = 1
[10:19:51.575] plan(): Setting new future strategy stack:
[10:19:51.575] List of future strategies:
[10:19:51.575] 1. sequential:
[10:19:51.575]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.575]    - tweaked: FALSE
[10:19:51.575]    - call: plan(strategy)
[10:19:51.575] plan(): nbrOfWorkers() = 1
[10:19:51.575] SequentialFuture started (and completed)
[10:19:51.576] - Launch lazy future ... done
[10:19:51.576] run() for ‘SequentialFuture’ ... done
[10:19:51.576] Created future:
[10:19:51.576] SequentialFuture:
[10:19:51.576] Label: ‘future_sapply-1’
[10:19:51.576] Expression:
[10:19:51.576] {
[10:19:51.576]     do.call(function(...) {
[10:19:51.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.576]             on.exit(options(oopts), add = TRUE)
[10:19:51.576]         }
[10:19:51.576]         {
[10:19:51.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.576]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.576]             })
[10:19:51.576]         }
[10:19:51.576]     }, args = future.call.arguments)
[10:19:51.576] }
[10:19:51.576] Lazy evaluation: FALSE
[10:19:51.576] Asynchronous evaluation: FALSE
[10:19:51.576] Local evaluation: TRUE
[10:19:51.576] Environment: R_GlobalEnv
[10:19:51.576] Capture standard output: TRUE
[10:19:51.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.576] Globals: 5 objects totaling 5.40 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 597 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:51.576] Packages: 1 packages (‘stats’)
[10:19:51.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.576] Resolved: TRUE
[10:19:51.576] Value: 367 bytes of class ‘list’
[10:19:51.576] Early signaling: FALSE
[10:19:51.576] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.576] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.577] Chunk #1 of 1 ... DONE
[10:19:51.577] Launching 1 futures (chunks) ... DONE
[10:19:51.577] Resolving 1 futures (chunks) ...
[10:19:51.577] resolve() on list ...
[10:19:51.577]  recursive: 0
[10:19:51.577]  length: 1
[10:19:51.577] 
[10:19:51.577] resolved() for ‘SequentialFuture’ ...
[10:19:51.577] - state: ‘finished’
[10:19:51.577] - run: TRUE
[10:19:51.577] - result: ‘FutureResult’
[10:19:51.578] resolved() for ‘SequentialFuture’ ... done
[10:19:51.578] Future #1
[10:19:51.578] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.578] - nx: 1
[10:19:51.578] - relay: TRUE
[10:19:51.578] - stdout: TRUE
[10:19:51.578] - signal: TRUE
[10:19:51.578] - resignal: FALSE
[10:19:51.578] - force: TRUE
[10:19:51.578] - relayed: [n=1] FALSE
[10:19:51.578] - queued futures: [n=1] FALSE
[10:19:51.578]  - until=1
[10:19:51.579]  - relaying element #1
[10:19:51.579] - relayed: [n=1] TRUE
[10:19:51.579] - queued futures: [n=1] TRUE
[10:19:51.579] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.579]  length: 0 (resolved future 1)
[10:19:51.579] Relaying remaining futures
[10:19:51.579] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.579] - nx: 1
[10:19:51.579] - relay: TRUE
[10:19:51.579] - stdout: TRUE
[10:19:51.579] - signal: TRUE
[10:19:51.579] - resignal: FALSE
[10:19:51.580] - force: TRUE
[10:19:51.580] - relayed: [n=1] TRUE
[10:19:51.580] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.580] - relayed: [n=1] TRUE
[10:19:51.580] - queued futures: [n=1] TRUE
[10:19:51.580] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.580] resolve() on list ... DONE
[10:19:51.580]  - Number of value chunks collected: 1
[10:19:51.580] Resolving 1 futures (chunks) ... DONE
[10:19:51.580] Reducing values from 1 chunks ...
[10:19:51.580]  - Number of values collected after concatenation: 7
[10:19:51.580]  - Number of values expected: 7
[10:19:51.581] Reducing values from 1 chunks ... DONE
[10:19:51.581] future_lapply() ... DONE
[10:19:51.581] future_lapply() ...
[10:19:51.582] Number of chunks: 1
[10:19:51.583] getGlobalsAndPackagesXApply() ...
[10:19:51.583]  - future.globals: TRUE
[10:19:51.583] getGlobalsAndPackages() ...
[10:19:51.583] Searching for globals...
[10:19:51.590] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:19:51.590] Searching for globals ... DONE
[10:19:51.590] Resolving globals: FALSE
[10:19:51.592] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[10:19:51.592] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[10:19:51.592] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.592] - packages: [2] ‘stats’, ‘future.apply’
[10:19:51.592] getGlobalsAndPackages() ... DONE
[10:19:51.592]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.592]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:19:51.593] Finding globals ... DONE
[10:19:51.593]  - use_args: TRUE
[10:19:51.593]  - Getting '...' globals ...
[10:19:51.593] resolve() on list ...
[10:19:51.593]  recursive: 0
[10:19:51.593]  length: 1
[10:19:51.593]  elements: ‘...’
[10:19:51.593]  length: 0 (resolved future 1)
[10:19:51.593] resolve() on list ... DONE
[10:19:51.594]    - '...' content: [n=0] 
[10:19:51.594] List of 1
[10:19:51.594]  $ ...: list()
[10:19:51.594]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.594]  - attr(*, "where")=List of 1
[10:19:51.594]   ..$ ...:<environment: 0x55c69fd97320> 
[10:19:51.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.594]  - attr(*, "resolved")= logi TRUE
[10:19:51.594]  - attr(*, "total_size")= num NA
[10:19:51.596]  - Getting '...' globals ... DONE
[10:19:51.596] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.596] List of 8
[10:19:51.596]  $ ...future.FUN:function (x, ...)  
[10:19:51.596]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:19:51.596]  $ times        : int 5
[10:19:51.596]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.596]  $ stop_if_not  :function (...)  
[10:19:51.596]  $ dim          : NULL
[10:19:51.596]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.596]  $ ...          : list()
[10:19:51.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.596]  - attr(*, "where")=List of 8
[10:19:51.596]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.596]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.596]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.596]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.596]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.596]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.596]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.596]   ..$ ...          :<environment: 0x55c69fd97320> 
[10:19:51.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.596]  - attr(*, "resolved")= logi FALSE
[10:19:51.596]  - attr(*, "total_size")= num 48005
[10:19:51.601] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:19:51.601] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.601] Number of futures (= number of chunks): 1
[10:19:51.601] Launching 1 futures (chunks) ...
[10:19:51.601] Chunk #1 of 1 ...
[10:19:51.601]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.602] getGlobalsAndPackages() ...
[10:19:51.602] Searching for globals...
[10:19:51.602] 
[10:19:51.602] Searching for globals ... DONE
[10:19:51.602] - globals: [0] <none>
[10:19:51.602] getGlobalsAndPackages() ... DONE
[10:19:51.602]    + additional globals found: [n=0] 
[10:19:51.602]    + additional namespaces needed: [n=0] 
[10:19:51.602]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.602]  - seeds: <none>
[10:19:51.602]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.603] getGlobalsAndPackages() ...
[10:19:51.603] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.603] Resolving globals: FALSE
[10:19:51.603] Tweak future expression to call with '...' arguments ...
[10:19:51.603] {
[10:19:51.603]     do.call(function(...) {
[10:19:51.603]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.603]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.603]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.603]             on.exit(options(oopts), add = TRUE)
[10:19:51.603]         }
[10:19:51.603]         {
[10:19:51.603]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.603]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.603]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.603]             })
[10:19:51.603]         }
[10:19:51.603]     }, args = future.call.arguments)
[10:19:51.603] }
[10:19:51.603] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.604] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.604] - packages: [2] ‘stats’, ‘future.apply’
[10:19:51.604] getGlobalsAndPackages() ... DONE
[10:19:51.605] run() for ‘Future’ ...
[10:19:51.605] - state: ‘created’
[10:19:51.605] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.605] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.606]   - Field: ‘label’
[10:19:51.606]   - Field: ‘local’
[10:19:51.606]   - Field: ‘owner’
[10:19:51.606]   - Field: ‘envir’
[10:19:51.606]   - Field: ‘packages’
[10:19:51.606]   - Field: ‘gc’
[10:19:51.606]   - Field: ‘conditions’
[10:19:51.606]   - Field: ‘expr’
[10:19:51.606]   - Field: ‘uuid’
[10:19:51.606]   - Field: ‘seed’
[10:19:51.606]   - Field: ‘version’
[10:19:51.607]   - Field: ‘result’
[10:19:51.607]   - Field: ‘asynchronous’
[10:19:51.607]   - Field: ‘calls’
[10:19:51.607]   - Field: ‘globals’
[10:19:51.607]   - Field: ‘stdout’
[10:19:51.607]   - Field: ‘earlySignal’
[10:19:51.607]   - Field: ‘lazy’
[10:19:51.607]   - Field: ‘state’
[10:19:51.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.607] - Launch lazy future ...
[10:19:51.607] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:51.608] Packages needed by future strategies (n = 0): <none>
[10:19:51.608] {
[10:19:51.608]     {
[10:19:51.608]         {
[10:19:51.608]             ...future.startTime <- base::Sys.time()
[10:19:51.608]             {
[10:19:51.608]                 {
[10:19:51.608]                   {
[10:19:51.608]                     {
[10:19:51.608]                       base::local({
[10:19:51.608]                         has_future <- base::requireNamespace("future", 
[10:19:51.608]                           quietly = TRUE)
[10:19:51.608]                         if (has_future) {
[10:19:51.608]                           ns <- base::getNamespace("future")
[10:19:51.608]                           version <- ns[[".package"]][["version"]]
[10:19:51.608]                           if (is.null(version)) 
[10:19:51.608]                             version <- utils::packageVersion("future")
[10:19:51.608]                         }
[10:19:51.608]                         else {
[10:19:51.608]                           version <- NULL
[10:19:51.608]                         }
[10:19:51.608]                         if (!has_future || version < "1.8.0") {
[10:19:51.608]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.608]                             "", base::R.version$version.string), 
[10:19:51.608]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.608]                               "release", "version")], collapse = " "), 
[10:19:51.608]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.608]                             info)
[10:19:51.608]                           info <- base::paste(info, collapse = "; ")
[10:19:51.608]                           if (!has_future) {
[10:19:51.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.608]                               info)
[10:19:51.608]                           }
[10:19:51.608]                           else {
[10:19:51.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.608]                               info, version)
[10:19:51.608]                           }
[10:19:51.608]                           base::stop(msg)
[10:19:51.608]                         }
[10:19:51.608]                       })
[10:19:51.608]                     }
[10:19:51.608]                     base::local({
[10:19:51.608]                       for (pkg in c("stats", "future.apply")) {
[10:19:51.608]                         base::loadNamespace(pkg)
[10:19:51.608]                         base::library(pkg, character.only = TRUE)
[10:19:51.608]                       }
[10:19:51.608]                     })
[10:19:51.608]                   }
[10:19:51.608]                   ...future.strategy.old <- future::plan("list")
[10:19:51.608]                   options(future.plan = NULL)
[10:19:51.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.608]                 }
[10:19:51.608]                 ...future.workdir <- getwd()
[10:19:51.608]             }
[10:19:51.608]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.608]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.608]         }
[10:19:51.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.608]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.608]             base::names(...future.oldOptions))
[10:19:51.608]     }
[10:19:51.608]     if (FALSE) {
[10:19:51.608]     }
[10:19:51.608]     else {
[10:19:51.608]         if (TRUE) {
[10:19:51.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.608]                 open = "w")
[10:19:51.608]         }
[10:19:51.608]         else {
[10:19:51.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.608]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.608]         }
[10:19:51.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.608]             base::sink(type = "output", split = FALSE)
[10:19:51.608]             base::close(...future.stdout)
[10:19:51.608]         }, add = TRUE)
[10:19:51.608]     }
[10:19:51.608]     ...future.frame <- base::sys.nframe()
[10:19:51.608]     ...future.conditions <- base::list()
[10:19:51.608]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.608]     if (FALSE) {
[10:19:51.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.608]     }
[10:19:51.608]     ...future.result <- base::tryCatch({
[10:19:51.608]         base::withCallingHandlers({
[10:19:51.608]             ...future.value <- base::withVisible(base::local({
[10:19:51.608]                 do.call(function(...) {
[10:19:51.608]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.608]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.608]                     ...future.globals.maxSize)) {
[10:19:51.608]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.608]                     on.exit(options(oopts), add = TRUE)
[10:19:51.608]                   }
[10:19:51.608]                   {
[10:19:51.608]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.608]                       FUN = function(jj) {
[10:19:51.608]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.608]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.608]                       })
[10:19:51.608]                   }
[10:19:51.608]                 }, args = future.call.arguments)
[10:19:51.608]             }))
[10:19:51.608]             future::FutureResult(value = ...future.value$value, 
[10:19:51.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.608]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.608]                     ...future.globalenv.names))
[10:19:51.608]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.608]         }, condition = base::local({
[10:19:51.608]             c <- base::c
[10:19:51.608]             inherits <- base::inherits
[10:19:51.608]             invokeRestart <- base::invokeRestart
[10:19:51.608]             length <- base::length
[10:19:51.608]             list <- base::list
[10:19:51.608]             seq.int <- base::seq.int
[10:19:51.608]             signalCondition <- base::signalCondition
[10:19:51.608]             sys.calls <- base::sys.calls
[10:19:51.608]             `[[` <- base::`[[`
[10:19:51.608]             `+` <- base::`+`
[10:19:51.608]             `<<-` <- base::`<<-`
[10:19:51.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.608]                   3L)]
[10:19:51.608]             }
[10:19:51.608]             function(cond) {
[10:19:51.608]                 is_error <- inherits(cond, "error")
[10:19:51.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.608]                   NULL)
[10:19:51.608]                 if (is_error) {
[10:19:51.608]                   sessionInformation <- function() {
[10:19:51.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.608]                       search = base::search(), system = base::Sys.info())
[10:19:51.608]                   }
[10:19:51.608]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.608]                     cond$call), session = sessionInformation(), 
[10:19:51.608]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.608]                   signalCondition(cond)
[10:19:51.608]                 }
[10:19:51.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.608]                 "immediateCondition"))) {
[10:19:51.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.608]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.608]                   if (TRUE && !signal) {
[10:19:51.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.608]                     {
[10:19:51.608]                       inherits <- base::inherits
[10:19:51.608]                       invokeRestart <- base::invokeRestart
[10:19:51.608]                       is.null <- base::is.null
[10:19:51.608]                       muffled <- FALSE
[10:19:51.608]                       if (inherits(cond, "message")) {
[10:19:51.608]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.608]                         if (muffled) 
[10:19:51.608]                           invokeRestart("muffleMessage")
[10:19:51.608]                       }
[10:19:51.608]                       else if (inherits(cond, "warning")) {
[10:19:51.608]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.608]                         if (muffled) 
[10:19:51.608]                           invokeRestart("muffleWarning")
[10:19:51.608]                       }
[10:19:51.608]                       else if (inherits(cond, "condition")) {
[10:19:51.608]                         if (!is.null(pattern)) {
[10:19:51.608]                           computeRestarts <- base::computeRestarts
[10:19:51.608]                           grepl <- base::grepl
[10:19:51.608]                           restarts <- computeRestarts(cond)
[10:19:51.608]                           for (restart in restarts) {
[10:19:51.608]                             name <- restart$name
[10:19:51.608]                             if (is.null(name)) 
[10:19:51.608]                               next
[10:19:51.608]                             if (!grepl(pattern, name)) 
[10:19:51.608]                               next
[10:19:51.608]                             invokeRestart(restart)
[10:19:51.608]                             muffled <- TRUE
[10:19:51.608]                             break
[10:19:51.608]                           }
[10:19:51.608]                         }
[10:19:51.608]                       }
[10:19:51.608]                       invisible(muffled)
[10:19:51.608]                     }
[10:19:51.608]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.608]                   }
[10:19:51.608]                 }
[10:19:51.608]                 else {
[10:19:51.608]                   if (TRUE) {
[10:19:51.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.608]                     {
[10:19:51.608]                       inherits <- base::inherits
[10:19:51.608]                       invokeRestart <- base::invokeRestart
[10:19:51.608]                       is.null <- base::is.null
[10:19:51.608]                       muffled <- FALSE
[10:19:51.608]                       if (inherits(cond, "message")) {
[10:19:51.608]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.608]                         if (muffled) 
[10:19:51.608]                           invokeRestart("muffleMessage")
[10:19:51.608]                       }
[10:19:51.608]                       else if (inherits(cond, "warning")) {
[10:19:51.608]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.608]                         if (muffled) 
[10:19:51.608]                           invokeRestart("muffleWarning")
[10:19:51.608]                       }
[10:19:51.608]                       else if (inherits(cond, "condition")) {
[10:19:51.608]                         if (!is.null(pattern)) {
[10:19:51.608]                           computeRestarts <- base::computeRestarts
[10:19:51.608]                           grepl <- base::grepl
[10:19:51.608]                           restarts <- computeRestarts(cond)
[10:19:51.608]                           for (restart in restarts) {
[10:19:51.608]                             name <- restart$name
[10:19:51.608]                             if (is.null(name)) 
[10:19:51.608]                               next
[10:19:51.608]                             if (!grepl(pattern, name)) 
[10:19:51.608]                               next
[10:19:51.608]                             invokeRestart(restart)
[10:19:51.608]                             muffled <- TRUE
[10:19:51.608]                             break
[10:19:51.608]                           }
[10:19:51.608]                         }
[10:19:51.608]                       }
[10:19:51.608]                       invisible(muffled)
[10:19:51.608]                     }
[10:19:51.608]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.608]                   }
[10:19:51.608]                 }
[10:19:51.608]             }
[10:19:51.608]         }))
[10:19:51.608]     }, error = function(ex) {
[10:19:51.608]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.608]                 ...future.rng), started = ...future.startTime, 
[10:19:51.608]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.608]             version = "1.8"), class = "FutureResult")
[10:19:51.608]     }, finally = {
[10:19:51.608]         if (!identical(...future.workdir, getwd())) 
[10:19:51.608]             setwd(...future.workdir)
[10:19:51.608]         {
[10:19:51.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.608]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.608]             }
[10:19:51.608]             base::options(...future.oldOptions)
[10:19:51.608]             if (.Platform$OS.type == "windows") {
[10:19:51.608]                 old_names <- names(...future.oldEnvVars)
[10:19:51.608]                 envs <- base::Sys.getenv()
[10:19:51.608]                 names <- names(envs)
[10:19:51.608]                 common <- intersect(names, old_names)
[10:19:51.608]                 added <- setdiff(names, old_names)
[10:19:51.608]                 removed <- setdiff(old_names, names)
[10:19:51.608]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.608]                   envs[common]]
[10:19:51.608]                 NAMES <- toupper(changed)
[10:19:51.608]                 args <- list()
[10:19:51.608]                 for (kk in seq_along(NAMES)) {
[10:19:51.608]                   name <- changed[[kk]]
[10:19:51.608]                   NAME <- NAMES[[kk]]
[10:19:51.608]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.608]                     next
[10:19:51.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.608]                 }
[10:19:51.608]                 NAMES <- toupper(added)
[10:19:51.608]                 for (kk in seq_along(NAMES)) {
[10:19:51.608]                   name <- added[[kk]]
[10:19:51.608]                   NAME <- NAMES[[kk]]
[10:19:51.608]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.608]                     next
[10:19:51.608]                   args[[name]] <- ""
[10:19:51.608]                 }
[10:19:51.608]                 NAMES <- toupper(removed)
[10:19:51.608]                 for (kk in seq_along(NAMES)) {
[10:19:51.608]                   name <- removed[[kk]]
[10:19:51.608]                   NAME <- NAMES[[kk]]
[10:19:51.608]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.608]                     next
[10:19:51.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.608]                 }
[10:19:51.608]                 if (length(args) > 0) 
[10:19:51.608]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.608]             }
[10:19:51.608]             else {
[10:19:51.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.608]             }
[10:19:51.608]             {
[10:19:51.608]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.608]                   0L) {
[10:19:51.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.608]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.608]                   base::options(opts)
[10:19:51.608]                 }
[10:19:51.608]                 {
[10:19:51.608]                   {
[10:19:51.608]                     NULL
[10:19:51.608]                     RNGkind("Mersenne-Twister")
[10:19:51.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.608]                       inherits = FALSE)
[10:19:51.608]                   }
[10:19:51.608]                   options(future.plan = NULL)
[10:19:51.608]                   if (is.na(NA_character_)) 
[10:19:51.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.608]                     .init = FALSE)
[10:19:51.608]                 }
[10:19:51.608]             }
[10:19:51.608]         }
[10:19:51.608]     })
[10:19:51.608]     if (TRUE) {
[10:19:51.608]         base::sink(type = "output", split = FALSE)
[10:19:51.608]         if (TRUE) {
[10:19:51.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.608]         }
[10:19:51.608]         else {
[10:19:51.608]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.608]         }
[10:19:51.608]         base::close(...future.stdout)
[10:19:51.608]         ...future.stdout <- NULL
[10:19:51.608]     }
[10:19:51.608]     ...future.result$conditions <- ...future.conditions
[10:19:51.608]     ...future.result$finished <- base::Sys.time()
[10:19:51.608]     ...future.result
[10:19:51.608] }
[10:19:51.610] assign_globals() ...
[10:19:51.610] List of 11
[10:19:51.610]  $ ...future.FUN            :function (x, ...)  
[10:19:51.610]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:19:51.610]  $ times                    : int 5
[10:19:51.610]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.610]  $ stop_if_not              :function (...)  
[10:19:51.610]  $ dim                      : NULL
[10:19:51.610]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.610]  $ future.call.arguments    : list()
[10:19:51.610]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.610]  $ ...future.elements_ii    :List of 7
[10:19:51.610]   ..$ : int [1:3] 1 2 3
[10:19:51.610]   ..$ : int [1:4] 1 2 3 4
[10:19:51.610]   ..$ : int [1:5] 1 2 3 4 5
[10:19:51.610]   ..$ : int [1:6] 1 2 3 4 5 6
[10:19:51.610]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:19:51.610]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:19:51.610]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:19:51.610]  $ ...future.seeds_ii       : NULL
[10:19:51.610]  $ ...future.globals.maxSize: NULL
[10:19:51.610]  - attr(*, "where")=List of 11
[10:19:51.610]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.610]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.610]  - attr(*, "resolved")= logi FALSE
[10:19:51.610]  - attr(*, "total_size")= num 48005
[10:19:51.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.610]  - attr(*, "already-done")= logi TRUE
[10:19:51.618] - copied ‘...future.FUN’ to environment
[10:19:51.618] - copied ‘x_FUN’ to environment
[10:19:51.618] - copied ‘times’ to environment
[10:19:51.618] - copied ‘stopf’ to environment
[10:19:51.618] - copied ‘stop_if_not’ to environment
[10:19:51.618] - copied ‘dim’ to environment
[10:19:51.619] - copied ‘valid_types’ to environment
[10:19:51.619] - copied ‘future.call.arguments’ to environment
[10:19:51.619] - copied ‘...future.elements_ii’ to environment
[10:19:51.619] - copied ‘...future.seeds_ii’ to environment
[10:19:51.619] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.619] assign_globals() ... done
[10:19:51.619] plan(): Setting new future strategy stack:
[10:19:51.619] List of future strategies:
[10:19:51.619] 1. sequential:
[10:19:51.619]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.619]    - tweaked: FALSE
[10:19:51.619]    - call: NULL
[10:19:51.620] plan(): nbrOfWorkers() = 1
[10:19:51.621] plan(): Setting new future strategy stack:
[10:19:51.621] List of future strategies:
[10:19:51.621] 1. sequential:
[10:19:51.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.621]    - tweaked: FALSE
[10:19:51.621]    - call: plan(strategy)
[10:19:51.621] plan(): nbrOfWorkers() = 1
[10:19:51.621] SequentialFuture started (and completed)
[10:19:51.621] - Launch lazy future ... done
[10:19:51.622] run() for ‘SequentialFuture’ ... done
[10:19:51.622] Created future:
[10:19:51.622] SequentialFuture:
[10:19:51.622] Label: ‘future_vapply-1’
[10:19:51.622] Expression:
[10:19:51.622] {
[10:19:51.622]     do.call(function(...) {
[10:19:51.622]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.622]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.622]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.622]             on.exit(options(oopts), add = TRUE)
[10:19:51.622]         }
[10:19:51.622]         {
[10:19:51.622]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.622]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.622]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.622]             })
[10:19:51.622]         }
[10:19:51.622]     }, args = future.call.arguments)
[10:19:51.622] }
[10:19:51.622] Lazy evaluation: FALSE
[10:19:51.622] Asynchronous evaluation: FALSE
[10:19:51.622] Local evaluation: TRUE
[10:19:51.622] Environment: R_GlobalEnv
[10:19:51.622] Capture standard output: TRUE
[10:19:51.622] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.622] Globals: 11 objects totaling 27.44 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.622] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:51.622] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.622] Resolved: TRUE
[10:19:51.622] Value: 367 bytes of class ‘list’
[10:19:51.622] Early signaling: FALSE
[10:19:51.622] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.622] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.623] Chunk #1 of 1 ... DONE
[10:19:51.623] Launching 1 futures (chunks) ... DONE
[10:19:51.623] Resolving 1 futures (chunks) ...
[10:19:51.623] resolve() on list ...
[10:19:51.623]  recursive: 0
[10:19:51.623]  length: 1
[10:19:51.623] 
[10:19:51.623] resolved() for ‘SequentialFuture’ ...
[10:19:51.623] - state: ‘finished’
[10:19:51.623] - run: TRUE
[10:19:51.624] - result: ‘FutureResult’
[10:19:51.624] resolved() for ‘SequentialFuture’ ... done
[10:19:51.624] Future #1
[10:19:51.624] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.624] - nx: 1
[10:19:51.624] - relay: TRUE
[10:19:51.624] - stdout: TRUE
[10:19:51.624] - signal: TRUE
[10:19:51.624] - resignal: FALSE
[10:19:51.624] - force: TRUE
[10:19:51.624] - relayed: [n=1] FALSE
[10:19:51.624] - queued futures: [n=1] FALSE
[10:19:51.625]  - until=1
[10:19:51.625]  - relaying element #1
[10:19:51.625] - relayed: [n=1] TRUE
[10:19:51.625] - queued futures: [n=1] TRUE
[10:19:51.625] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.625]  length: 0 (resolved future 1)
[10:19:51.625] Relaying remaining futures
[10:19:51.625] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.625] - nx: 1
[10:19:51.625] - relay: TRUE
[10:19:51.625] - stdout: TRUE
[10:19:51.626] - signal: TRUE
[10:19:51.627] - resignal: FALSE
[10:19:51.627] - force: TRUE
[10:19:51.627] - relayed: [n=1] TRUE
[10:19:51.627] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.627] - relayed: [n=1] TRUE
[10:19:51.627] - queued futures: [n=1] TRUE
[10:19:51.627] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.628] resolve() on list ... DONE
[10:19:51.628]  - Number of value chunks collected: 1
[10:19:51.628] Resolving 1 futures (chunks) ... DONE
[10:19:51.628] Reducing values from 1 chunks ...
[10:19:51.628]  - Number of values collected after concatenation: 7
[10:19:51.628]  - Number of values expected: 7
[10:19:51.628] Reducing values from 1 chunks ... DONE
[10:19:51.628] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:19:51.630] future_lapply() ...
[10:19:51.631] Number of chunks: 1
[10:19:51.631] getGlobalsAndPackagesXApply() ...
[10:19:51.631]  - future.globals: TRUE
[10:19:51.631] getGlobalsAndPackages() ...
[10:19:51.631] Searching for globals...
[10:19:51.632] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:19:51.632] Searching for globals ... DONE
[10:19:51.632] Resolving globals: FALSE
[10:19:51.633] The total size of the 1 globals is 680 bytes (680 bytes)
[10:19:51.633] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[10:19:51.633] - globals: [1] ‘FUN’
[10:19:51.633] 
[10:19:51.633] getGlobalsAndPackages() ... DONE
[10:19:51.633]  - globals found/used: [n=1] ‘FUN’
[10:19:51.633]  - needed namespaces: [n=0] 
[10:19:51.634] Finding globals ... DONE
[10:19:51.634]  - use_args: TRUE
[10:19:51.634]  - Getting '...' globals ...
[10:19:51.634] resolve() on list ...
[10:19:51.634]  recursive: 0
[10:19:51.634]  length: 1
[10:19:51.634]  elements: ‘...’
[10:19:51.634]  length: 0 (resolved future 1)
[10:19:51.634] resolve() on list ... DONE
[10:19:51.635]    - '...' content: [n=1] ‘y’
[10:19:51.635] List of 1
[10:19:51.635]  $ ...:List of 1
[10:19:51.635]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:51.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.635]  - attr(*, "where")=List of 1
[10:19:51.635]   ..$ ...:<environment: 0x55c69efe6810> 
[10:19:51.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.635]  - attr(*, "resolved")= logi TRUE
[10:19:51.635]  - attr(*, "total_size")= num NA
[10:19:51.637]  - Getting '...' globals ... DONE
[10:19:51.637] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:19:51.638] List of 2
[10:19:51.638]  $ ...future.FUN:function (x, y)  
[10:19:51.638]  $ ...          :List of 1
[10:19:51.638]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:51.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.638]  - attr(*, "where")=List of 2
[10:19:51.638]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.638]   ..$ ...          :<environment: 0x55c69efe6810> 
[10:19:51.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.638]  - attr(*, "resolved")= logi FALSE
[10:19:51.638]  - attr(*, "total_size")= num 7318
[10:19:51.640] Packages to be attached in all futures: [n=0] 
[10:19:51.641] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.641] Number of futures (= number of chunks): 1
[10:19:51.641] Launching 1 futures (chunks) ...
[10:19:51.641] Chunk #1 of 1 ...
[10:19:51.641]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.641] getGlobalsAndPackages() ...
[10:19:51.641] Searching for globals...
[10:19:51.641] 
[10:19:51.642] Searching for globals ... DONE
[10:19:51.642] - globals: [0] <none>
[10:19:51.642] getGlobalsAndPackages() ... DONE
[10:19:51.642]    + additional globals found: [n=0] 
[10:19:51.642]    + additional namespaces needed: [n=0] 
[10:19:51.642]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.642]  - seeds: <none>
[10:19:51.642]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.642] getGlobalsAndPackages() ...
[10:19:51.642] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.642] Resolving globals: FALSE
[10:19:51.642] Tweak future expression to call with '...' arguments ...
[10:19:51.643] {
[10:19:51.643]     do.call(function(...) {
[10:19:51.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.643]             on.exit(options(oopts), add = TRUE)
[10:19:51.643]         }
[10:19:51.643]         {
[10:19:51.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.643]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.643]             })
[10:19:51.643]         }
[10:19:51.643]     }, args = future.call.arguments)
[10:19:51.643] }
[10:19:51.643] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.643] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.643] 
[10:19:51.643] getGlobalsAndPackages() ... DONE
[10:19:51.644] run() for ‘Future’ ...
[10:19:51.644] - state: ‘created’
[10:19:51.644] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.644] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.644]   - Field: ‘label’
[10:19:51.644]   - Field: ‘local’
[10:19:51.644]   - Field: ‘owner’
[10:19:51.645]   - Field: ‘envir’
[10:19:51.645]   - Field: ‘packages’
[10:19:51.645]   - Field: ‘gc’
[10:19:51.645]   - Field: ‘conditions’
[10:19:51.645]   - Field: ‘expr’
[10:19:51.645]   - Field: ‘uuid’
[10:19:51.645]   - Field: ‘seed’
[10:19:51.645]   - Field: ‘version’
[10:19:51.645]   - Field: ‘result’
[10:19:51.645]   - Field: ‘asynchronous’
[10:19:51.645]   - Field: ‘calls’
[10:19:51.645]   - Field: ‘globals’
[10:19:51.645]   - Field: ‘stdout’
[10:19:51.646]   - Field: ‘earlySignal’
[10:19:51.646]   - Field: ‘lazy’
[10:19:51.646]   - Field: ‘state’
[10:19:51.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.646] - Launch lazy future ...
[10:19:51.646] Packages needed by the future expression (n = 0): <none>
[10:19:51.646] Packages needed by future strategies (n = 0): <none>
[10:19:51.647] {
[10:19:51.647]     {
[10:19:51.647]         {
[10:19:51.647]             ...future.startTime <- base::Sys.time()
[10:19:51.647]             {
[10:19:51.647]                 {
[10:19:51.647]                   {
[10:19:51.647]                     base::local({
[10:19:51.647]                       has_future <- base::requireNamespace("future", 
[10:19:51.647]                         quietly = TRUE)
[10:19:51.647]                       if (has_future) {
[10:19:51.647]                         ns <- base::getNamespace("future")
[10:19:51.647]                         version <- ns[[".package"]][["version"]]
[10:19:51.647]                         if (is.null(version)) 
[10:19:51.647]                           version <- utils::packageVersion("future")
[10:19:51.647]                       }
[10:19:51.647]                       else {
[10:19:51.647]                         version <- NULL
[10:19:51.647]                       }
[10:19:51.647]                       if (!has_future || version < "1.8.0") {
[10:19:51.647]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.647]                           "", base::R.version$version.string), 
[10:19:51.647]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:51.647]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.647]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.647]                             "release", "version")], collapse = " "), 
[10:19:51.647]                           hostname = base::Sys.info()[["nodename"]])
[10:19:51.647]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.647]                           info)
[10:19:51.647]                         info <- base::paste(info, collapse = "; ")
[10:19:51.647]                         if (!has_future) {
[10:19:51.647]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.647]                             info)
[10:19:51.647]                         }
[10:19:51.647]                         else {
[10:19:51.647]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.647]                             info, version)
[10:19:51.647]                         }
[10:19:51.647]                         base::stop(msg)
[10:19:51.647]                       }
[10:19:51.647]                     })
[10:19:51.647]                   }
[10:19:51.647]                   ...future.strategy.old <- future::plan("list")
[10:19:51.647]                   options(future.plan = NULL)
[10:19:51.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.647]                 }
[10:19:51.647]                 ...future.workdir <- getwd()
[10:19:51.647]             }
[10:19:51.647]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.647]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.647]         }
[10:19:51.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.647]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.647]             base::names(...future.oldOptions))
[10:19:51.647]     }
[10:19:51.647]     if (FALSE) {
[10:19:51.647]     }
[10:19:51.647]     else {
[10:19:51.647]         if (TRUE) {
[10:19:51.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.647]                 open = "w")
[10:19:51.647]         }
[10:19:51.647]         else {
[10:19:51.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.647]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.647]         }
[10:19:51.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.647]             base::sink(type = "output", split = FALSE)
[10:19:51.647]             base::close(...future.stdout)
[10:19:51.647]         }, add = TRUE)
[10:19:51.647]     }
[10:19:51.647]     ...future.frame <- base::sys.nframe()
[10:19:51.647]     ...future.conditions <- base::list()
[10:19:51.647]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.647]     if (FALSE) {
[10:19:51.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.647]     }
[10:19:51.647]     ...future.result <- base::tryCatch({
[10:19:51.647]         base::withCallingHandlers({
[10:19:51.647]             ...future.value <- base::withVisible(base::local({
[10:19:51.647]                 do.call(function(...) {
[10:19:51.647]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.647]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.647]                     ...future.globals.maxSize)) {
[10:19:51.647]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.647]                     on.exit(options(oopts), add = TRUE)
[10:19:51.647]                   }
[10:19:51.647]                   {
[10:19:51.647]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.647]                       FUN = function(jj) {
[10:19:51.647]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.647]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.647]                       })
[10:19:51.647]                   }
[10:19:51.647]                 }, args = future.call.arguments)
[10:19:51.647]             }))
[10:19:51.647]             future::FutureResult(value = ...future.value$value, 
[10:19:51.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.647]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.647]                     ...future.globalenv.names))
[10:19:51.647]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.647]         }, condition = base::local({
[10:19:51.647]             c <- base::c
[10:19:51.647]             inherits <- base::inherits
[10:19:51.647]             invokeRestart <- base::invokeRestart
[10:19:51.647]             length <- base::length
[10:19:51.647]             list <- base::list
[10:19:51.647]             seq.int <- base::seq.int
[10:19:51.647]             signalCondition <- base::signalCondition
[10:19:51.647]             sys.calls <- base::sys.calls
[10:19:51.647]             `[[` <- base::`[[`
[10:19:51.647]             `+` <- base::`+`
[10:19:51.647]             `<<-` <- base::`<<-`
[10:19:51.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.647]                   3L)]
[10:19:51.647]             }
[10:19:51.647]             function(cond) {
[10:19:51.647]                 is_error <- inherits(cond, "error")
[10:19:51.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.647]                   NULL)
[10:19:51.647]                 if (is_error) {
[10:19:51.647]                   sessionInformation <- function() {
[10:19:51.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.647]                       search = base::search(), system = base::Sys.info())
[10:19:51.647]                   }
[10:19:51.647]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.647]                     cond$call), session = sessionInformation(), 
[10:19:51.647]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.647]                   signalCondition(cond)
[10:19:51.647]                 }
[10:19:51.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.647]                 "immediateCondition"))) {
[10:19:51.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.647]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.647]                   if (TRUE && !signal) {
[10:19:51.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.647]                     {
[10:19:51.647]                       inherits <- base::inherits
[10:19:51.647]                       invokeRestart <- base::invokeRestart
[10:19:51.647]                       is.null <- base::is.null
[10:19:51.647]                       muffled <- FALSE
[10:19:51.647]                       if (inherits(cond, "message")) {
[10:19:51.647]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.647]                         if (muffled) 
[10:19:51.647]                           invokeRestart("muffleMessage")
[10:19:51.647]                       }
[10:19:51.647]                       else if (inherits(cond, "warning")) {
[10:19:51.647]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.647]                         if (muffled) 
[10:19:51.647]                           invokeRestart("muffleWarning")
[10:19:51.647]                       }
[10:19:51.647]                       else if (inherits(cond, "condition")) {
[10:19:51.647]                         if (!is.null(pattern)) {
[10:19:51.647]                           computeRestarts <- base::computeRestarts
[10:19:51.647]                           grepl <- base::grepl
[10:19:51.647]                           restarts <- computeRestarts(cond)
[10:19:51.647]                           for (restart in restarts) {
[10:19:51.647]                             name <- restart$name
[10:19:51.647]                             if (is.null(name)) 
[10:19:51.647]                               next
[10:19:51.647]                             if (!grepl(pattern, name)) 
[10:19:51.647]                               next
[10:19:51.647]                             invokeRestart(restart)
[10:19:51.647]                             muffled <- TRUE
[10:19:51.647]                             break
[10:19:51.647]                           }
[10:19:51.647]                         }
[10:19:51.647]                       }
[10:19:51.647]                       invisible(muffled)
[10:19:51.647]                     }
[10:19:51.647]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.647]                   }
[10:19:51.647]                 }
[10:19:51.647]                 else {
[10:19:51.647]                   if (TRUE) {
[10:19:51.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.647]                     {
[10:19:51.647]                       inherits <- base::inherits
[10:19:51.647]                       invokeRestart <- base::invokeRestart
[10:19:51.647]                       is.null <- base::is.null
[10:19:51.647]                       muffled <- FALSE
[10:19:51.647]                       if (inherits(cond, "message")) {
[10:19:51.647]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.647]                         if (muffled) 
[10:19:51.647]                           invokeRestart("muffleMessage")
[10:19:51.647]                       }
[10:19:51.647]                       else if (inherits(cond, "warning")) {
[10:19:51.647]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.647]                         if (muffled) 
[10:19:51.647]                           invokeRestart("muffleWarning")
[10:19:51.647]                       }
[10:19:51.647]                       else if (inherits(cond, "condition")) {
[10:19:51.647]                         if (!is.null(pattern)) {
[10:19:51.647]                           computeRestarts <- base::computeRestarts
[10:19:51.647]                           grepl <- base::grepl
[10:19:51.647]                           restarts <- computeRestarts(cond)
[10:19:51.647]                           for (restart in restarts) {
[10:19:51.647]                             name <- restart$name
[10:19:51.647]                             if (is.null(name)) 
[10:19:51.647]                               next
[10:19:51.647]                             if (!grepl(pattern, name)) 
[10:19:51.647]                               next
[10:19:51.647]                             invokeRestart(restart)
[10:19:51.647]                             muffled <- TRUE
[10:19:51.647]                             break
[10:19:51.647]                           }
[10:19:51.647]                         }
[10:19:51.647]                       }
[10:19:51.647]                       invisible(muffled)
[10:19:51.647]                     }
[10:19:51.647]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.647]                   }
[10:19:51.647]                 }
[10:19:51.647]             }
[10:19:51.647]         }))
[10:19:51.647]     }, error = function(ex) {
[10:19:51.647]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.647]                 ...future.rng), started = ...future.startTime, 
[10:19:51.647]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.647]             version = "1.8"), class = "FutureResult")
[10:19:51.647]     }, finally = {
[10:19:51.647]         if (!identical(...future.workdir, getwd())) 
[10:19:51.647]             setwd(...future.workdir)
[10:19:51.647]         {
[10:19:51.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.647]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.647]             }
[10:19:51.647]             base::options(...future.oldOptions)
[10:19:51.647]             if (.Platform$OS.type == "windows") {
[10:19:51.647]                 old_names <- names(...future.oldEnvVars)
[10:19:51.647]                 envs <- base::Sys.getenv()
[10:19:51.647]                 names <- names(envs)
[10:19:51.647]                 common <- intersect(names, old_names)
[10:19:51.647]                 added <- setdiff(names, old_names)
[10:19:51.647]                 removed <- setdiff(old_names, names)
[10:19:51.647]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.647]                   envs[common]]
[10:19:51.647]                 NAMES <- toupper(changed)
[10:19:51.647]                 args <- list()
[10:19:51.647]                 for (kk in seq_along(NAMES)) {
[10:19:51.647]                   name <- changed[[kk]]
[10:19:51.647]                   NAME <- NAMES[[kk]]
[10:19:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.647]                     next
[10:19:51.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.647]                 }
[10:19:51.647]                 NAMES <- toupper(added)
[10:19:51.647]                 for (kk in seq_along(NAMES)) {
[10:19:51.647]                   name <- added[[kk]]
[10:19:51.647]                   NAME <- NAMES[[kk]]
[10:19:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.647]                     next
[10:19:51.647]                   args[[name]] <- ""
[10:19:51.647]                 }
[10:19:51.647]                 NAMES <- toupper(removed)
[10:19:51.647]                 for (kk in seq_along(NAMES)) {
[10:19:51.647]                   name <- removed[[kk]]
[10:19:51.647]                   NAME <- NAMES[[kk]]
[10:19:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.647]                     next
[10:19:51.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.647]                 }
[10:19:51.647]                 if (length(args) > 0) 
[10:19:51.647]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.647]             }
[10:19:51.647]             else {
[10:19:51.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.647]             }
[10:19:51.647]             {
[10:19:51.647]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.647]                   0L) {
[10:19:51.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.647]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.647]                   base::options(opts)
[10:19:51.647]                 }
[10:19:51.647]                 {
[10:19:51.647]                   {
[10:19:51.647]                     NULL
[10:19:51.647]                     RNGkind("Mersenne-Twister")
[10:19:51.647]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.647]                       inherits = FALSE)
[10:19:51.647]                   }
[10:19:51.647]                   options(future.plan = NULL)
[10:19:51.647]                   if (is.na(NA_character_)) 
[10:19:51.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.647]                     .init = FALSE)
[10:19:51.647]                 }
[10:19:51.647]             }
[10:19:51.647]         }
[10:19:51.647]     })
[10:19:51.647]     if (TRUE) {
[10:19:51.647]         base::sink(type = "output", split = FALSE)
[10:19:51.647]         if (TRUE) {
[10:19:51.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.647]         }
[10:19:51.647]         else {
[10:19:51.647]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.647]         }
[10:19:51.647]         base::close(...future.stdout)
[10:19:51.647]         ...future.stdout <- NULL
[10:19:51.647]     }
[10:19:51.647]     ...future.result$conditions <- ...future.conditions
[10:19:51.647]     ...future.result$finished <- base::Sys.time()
[10:19:51.647]     ...future.result
[10:19:51.647] }
[10:19:51.648] assign_globals() ...
[10:19:51.648] List of 5
[10:19:51.648]  $ ...future.FUN            :function (x, y)  
[10:19:51.648]  $ future.call.arguments    :List of 1
[10:19:51.648]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:51.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.648]  $ ...future.elements_ii    :List of 4
[10:19:51.648]   ..$ A: num 50
[10:19:51.648]   ..$ B: num 60
[10:19:51.648]   ..$ C: num 70
[10:19:51.648]   ..$ D: num 80
[10:19:51.648]  $ ...future.seeds_ii       : NULL
[10:19:51.648]  $ ...future.globals.maxSize: NULL
[10:19:51.648]  - attr(*, "where")=List of 5
[10:19:51.648]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.648]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.648]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.648]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.648]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.648]  - attr(*, "resolved")= logi FALSE
[10:19:51.648]  - attr(*, "total_size")= num 7318
[10:19:51.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.648]  - attr(*, "already-done")= logi TRUE
[10:19:51.655] - reassign environment for ‘...future.FUN’
[10:19:51.655] - copied ‘...future.FUN’ to environment
[10:19:51.655] - copied ‘future.call.arguments’ to environment
[10:19:51.656] - copied ‘...future.elements_ii’ to environment
[10:19:51.656] - copied ‘...future.seeds_ii’ to environment
[10:19:51.656] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.656] assign_globals() ... done
[10:19:51.656] plan(): Setting new future strategy stack:
[10:19:51.656] List of future strategies:
[10:19:51.656] 1. sequential:
[10:19:51.656]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.656]    - tweaked: FALSE
[10:19:51.656]    - call: NULL
[10:19:51.656] plan(): nbrOfWorkers() = 1
[10:19:51.657] plan(): Setting new future strategy stack:
[10:19:51.657] List of future strategies:
[10:19:51.657] 1. sequential:
[10:19:51.657]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.657]    - tweaked: FALSE
[10:19:51.657]    - call: plan(strategy)
[10:19:51.658] plan(): nbrOfWorkers() = 1
[10:19:51.658] SequentialFuture started (and completed)
[10:19:51.658] - Launch lazy future ... done
[10:19:51.658] run() for ‘SequentialFuture’ ... done
[10:19:51.658] Created future:
[10:19:51.658] SequentialFuture:
[10:19:51.658] Label: ‘future_sapply-1’
[10:19:51.658] Expression:
[10:19:51.658] {
[10:19:51.658]     do.call(function(...) {
[10:19:51.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.658]             on.exit(options(oopts), add = TRUE)
[10:19:51.658]         }
[10:19:51.658]         {
[10:19:51.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.658]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.658]             })
[10:19:51.658]         }
[10:19:51.658]     }, args = future.call.arguments)
[10:19:51.658] }
[10:19:51.658] Lazy evaluation: FALSE
[10:19:51.658] Asynchronous evaluation: FALSE
[10:19:51.658] Local evaluation: TRUE
[10:19:51.658] Environment: R_GlobalEnv
[10:19:51.658] Capture standard output: TRUE
[10:19:51.658] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.658] Globals: 5 objects totaling 1.06 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 164 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:51.658] Packages: <none>
[10:19:51.658] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.658] Resolved: TRUE
[10:19:51.658] Value: 666 bytes of class ‘list’
[10:19:51.658] Early signaling: FALSE
[10:19:51.658] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.658] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.659] Chunk #1 of 1 ... DONE
[10:19:51.659] Launching 1 futures (chunks) ... DONE
[10:19:51.659] Resolving 1 futures (chunks) ...
[10:19:51.659] resolve() on list ...
[10:19:51.659]  recursive: 0
[10:19:51.660]  length: 1
[10:19:51.660] 
[10:19:51.660] resolved() for ‘SequentialFuture’ ...
[10:19:51.660] - state: ‘finished’
[10:19:51.660] - run: TRUE
[10:19:51.660] - result: ‘FutureResult’
[10:19:51.660] resolved() for ‘SequentialFuture’ ... done
[10:19:51.660] Future #1
[10:19:51.660] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.660] - nx: 1
[10:19:51.660] - relay: TRUE
[10:19:51.660] - stdout: TRUE
[10:19:51.661] - signal: TRUE
[10:19:51.661] - resignal: FALSE
[10:19:51.661] - force: TRUE
[10:19:51.661] - relayed: [n=1] FALSE
[10:19:51.661] - queued futures: [n=1] FALSE
[10:19:51.661]  - until=1
[10:19:51.661]  - relaying element #1
[10:19:51.661] - relayed: [n=1] TRUE
[10:19:51.661] - queued futures: [n=1] TRUE
[10:19:51.661] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.661]  length: 0 (resolved future 1)
[10:19:51.662] Relaying remaining futures
[10:19:51.662] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.662] - nx: 1
[10:19:51.662] - relay: TRUE
[10:19:51.662] - stdout: TRUE
[10:19:51.662] - signal: TRUE
[10:19:51.662] - resignal: FALSE
[10:19:51.662] - force: TRUE
[10:19:51.662] - relayed: [n=1] TRUE
[10:19:51.662] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.662] - relayed: [n=1] TRUE
[10:19:51.662] - queued futures: [n=1] TRUE
[10:19:51.662] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.663] resolve() on list ... DONE
[10:19:51.663]  - Number of value chunks collected: 1
[10:19:51.663] Resolving 1 futures (chunks) ... DONE
[10:19:51.663] Reducing values from 1 chunks ...
[10:19:51.663]  - Number of values collected after concatenation: 4
[10:19:51.663]  - Number of values expected: 4
[10:19:51.663] Reducing values from 1 chunks ... DONE
[10:19:51.663] future_lapply() ... DONE
[10:19:51.663] future_lapply() ...
[10:19:51.665] Number of chunks: 1
[10:19:51.665] getGlobalsAndPackagesXApply() ...
[10:19:51.665]  - future.globals: TRUE
[10:19:51.665] getGlobalsAndPackages() ...
[10:19:51.665] Searching for globals...
[10:19:51.669] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:19:51.669] Searching for globals ... DONE
[10:19:51.669] Resolving globals: FALSE
[10:19:51.671] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[10:19:51.671] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.671] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.671] - packages: [1] ‘future.apply’
[10:19:51.671] getGlobalsAndPackages() ... DONE
[10:19:51.671]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.672]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.672] Finding globals ... DONE
[10:19:51.672]  - use_args: TRUE
[10:19:51.672]  - Getting '...' globals ...
[10:19:51.672] resolve() on list ...
[10:19:51.672]  recursive: 0
[10:19:51.672]  length: 1
[10:19:51.672]  elements: ‘...’
[10:19:51.672]  length: 0 (resolved future 1)
[10:19:51.673] resolve() on list ... DONE
[10:19:51.673]    - '...' content: [n=1] ‘y’
[10:19:51.673] List of 1
[10:19:51.673]  $ ...:List of 1
[10:19:51.673]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:51.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.673]  - attr(*, "where")=List of 1
[10:19:51.673]   ..$ ...:<environment: 0x55c69fb83728> 
[10:19:51.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.673]  - attr(*, "resolved")= logi TRUE
[10:19:51.673]  - attr(*, "total_size")= num NA
[10:19:51.675]  - Getting '...' globals ... DONE
[10:19:51.675] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.676] List of 8
[10:19:51.676]  $ ...future.FUN:function (x, ...)  
[10:19:51.676]  $ x_FUN        :function (x, y)  
[10:19:51.676]  $ times        : int 15
[10:19:51.676]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.676]  $ stop_if_not  :function (...)  
[10:19:51.676]  $ dim          : int [1:2] 3 5
[10:19:51.676]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.676]  $ ...          :List of 1
[10:19:51.676]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:51.676]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.676]  - attr(*, "where")=List of 8
[10:19:51.676]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.676]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.676]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.676]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.676]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.676]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.676]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.676]   ..$ ...          :<environment: 0x55c69fb83728> 
[10:19:51.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.676]  - attr(*, "resolved")= logi FALSE
[10:19:51.676]  - attr(*, "total_size")= num 26659
[10:19:51.681] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.681] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.681] Number of futures (= number of chunks): 1
[10:19:51.681] Launching 1 futures (chunks) ...
[10:19:51.681] Chunk #1 of 1 ...
[10:19:51.682]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.682] getGlobalsAndPackages() ...
[10:19:51.682] Searching for globals...
[10:19:51.682] 
[10:19:51.682] Searching for globals ... DONE
[10:19:51.682] - globals: [0] <none>
[10:19:51.682] getGlobalsAndPackages() ... DONE
[10:19:51.682]    + additional globals found: [n=0] 
[10:19:51.682]    + additional namespaces needed: [n=0] 
[10:19:51.682]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.683]  - seeds: <none>
[10:19:51.683]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.683] getGlobalsAndPackages() ...
[10:19:51.683] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.683] Resolving globals: FALSE
[10:19:51.683] Tweak future expression to call with '...' arguments ...
[10:19:51.683] {
[10:19:51.683]     do.call(function(...) {
[10:19:51.683]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.683]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.683]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.683]             on.exit(options(oopts), add = TRUE)
[10:19:51.683]         }
[10:19:51.683]         {
[10:19:51.683]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.683]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.683]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.683]             })
[10:19:51.683]         }
[10:19:51.683]     }, args = future.call.arguments)
[10:19:51.683] }
[10:19:51.683] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.684] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.684] - packages: [1] ‘future.apply’
[10:19:51.684] getGlobalsAndPackages() ... DONE
[10:19:51.684] run() for ‘Future’ ...
[10:19:51.684] - state: ‘created’
[10:19:51.684] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.685] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.685] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.685]   - Field: ‘label’
[10:19:51.685]   - Field: ‘local’
[10:19:51.685]   - Field: ‘owner’
[10:19:51.685]   - Field: ‘envir’
[10:19:51.685]   - Field: ‘packages’
[10:19:51.685]   - Field: ‘gc’
[10:19:51.685]   - Field: ‘conditions’
[10:19:51.685]   - Field: ‘expr’
[10:19:51.686]   - Field: ‘uuid’
[10:19:51.686]   - Field: ‘seed’
[10:19:51.686]   - Field: ‘version’
[10:19:51.686]   - Field: ‘result’
[10:19:51.686]   - Field: ‘asynchronous’
[10:19:51.686]   - Field: ‘calls’
[10:19:51.686]   - Field: ‘globals’
[10:19:51.686]   - Field: ‘stdout’
[10:19:51.686]   - Field: ‘earlySignal’
[10:19:51.686]   - Field: ‘lazy’
[10:19:51.686]   - Field: ‘state’
[10:19:51.686] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.686] - Launch lazy future ...
[10:19:51.687] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.687] Packages needed by future strategies (n = 0): <none>
[10:19:51.687] {
[10:19:51.687]     {
[10:19:51.687]         {
[10:19:51.687]             ...future.startTime <- base::Sys.time()
[10:19:51.687]             {
[10:19:51.687]                 {
[10:19:51.687]                   {
[10:19:51.687]                     {
[10:19:51.687]                       base::local({
[10:19:51.687]                         has_future <- base::requireNamespace("future", 
[10:19:51.687]                           quietly = TRUE)
[10:19:51.687]                         if (has_future) {
[10:19:51.687]                           ns <- base::getNamespace("future")
[10:19:51.687]                           version <- ns[[".package"]][["version"]]
[10:19:51.687]                           if (is.null(version)) 
[10:19:51.687]                             version <- utils::packageVersion("future")
[10:19:51.687]                         }
[10:19:51.687]                         else {
[10:19:51.687]                           version <- NULL
[10:19:51.687]                         }
[10:19:51.687]                         if (!has_future || version < "1.8.0") {
[10:19:51.687]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.687]                             "", base::R.version$version.string), 
[10:19:51.687]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.687]                               "release", "version")], collapse = " "), 
[10:19:51.687]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.687]                             info)
[10:19:51.687]                           info <- base::paste(info, collapse = "; ")
[10:19:51.687]                           if (!has_future) {
[10:19:51.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.687]                               info)
[10:19:51.687]                           }
[10:19:51.687]                           else {
[10:19:51.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.687]                               info, version)
[10:19:51.687]                           }
[10:19:51.687]                           base::stop(msg)
[10:19:51.687]                         }
[10:19:51.687]                       })
[10:19:51.687]                     }
[10:19:51.687]                     base::local({
[10:19:51.687]                       for (pkg in "future.apply") {
[10:19:51.687]                         base::loadNamespace(pkg)
[10:19:51.687]                         base::library(pkg, character.only = TRUE)
[10:19:51.687]                       }
[10:19:51.687]                     })
[10:19:51.687]                   }
[10:19:51.687]                   ...future.strategy.old <- future::plan("list")
[10:19:51.687]                   options(future.plan = NULL)
[10:19:51.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.687]                 }
[10:19:51.687]                 ...future.workdir <- getwd()
[10:19:51.687]             }
[10:19:51.687]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.687]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.687]         }
[10:19:51.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.687]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.687]             base::names(...future.oldOptions))
[10:19:51.687]     }
[10:19:51.687]     if (FALSE) {
[10:19:51.687]     }
[10:19:51.687]     else {
[10:19:51.687]         if (TRUE) {
[10:19:51.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.687]                 open = "w")
[10:19:51.687]         }
[10:19:51.687]         else {
[10:19:51.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.687]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.687]         }
[10:19:51.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.687]             base::sink(type = "output", split = FALSE)
[10:19:51.687]             base::close(...future.stdout)
[10:19:51.687]         }, add = TRUE)
[10:19:51.687]     }
[10:19:51.687]     ...future.frame <- base::sys.nframe()
[10:19:51.687]     ...future.conditions <- base::list()
[10:19:51.687]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.687]     if (FALSE) {
[10:19:51.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.687]     }
[10:19:51.687]     ...future.result <- base::tryCatch({
[10:19:51.687]         base::withCallingHandlers({
[10:19:51.687]             ...future.value <- base::withVisible(base::local({
[10:19:51.687]                 do.call(function(...) {
[10:19:51.687]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.687]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.687]                     ...future.globals.maxSize)) {
[10:19:51.687]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.687]                     on.exit(options(oopts), add = TRUE)
[10:19:51.687]                   }
[10:19:51.687]                   {
[10:19:51.687]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.687]                       FUN = function(jj) {
[10:19:51.687]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.687]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.687]                       })
[10:19:51.687]                   }
[10:19:51.687]                 }, args = future.call.arguments)
[10:19:51.687]             }))
[10:19:51.687]             future::FutureResult(value = ...future.value$value, 
[10:19:51.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.687]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.687]                     ...future.globalenv.names))
[10:19:51.687]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.687]         }, condition = base::local({
[10:19:51.687]             c <- base::c
[10:19:51.687]             inherits <- base::inherits
[10:19:51.687]             invokeRestart <- base::invokeRestart
[10:19:51.687]             length <- base::length
[10:19:51.687]             list <- base::list
[10:19:51.687]             seq.int <- base::seq.int
[10:19:51.687]             signalCondition <- base::signalCondition
[10:19:51.687]             sys.calls <- base::sys.calls
[10:19:51.687]             `[[` <- base::`[[`
[10:19:51.687]             `+` <- base::`+`
[10:19:51.687]             `<<-` <- base::`<<-`
[10:19:51.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.687]                   3L)]
[10:19:51.687]             }
[10:19:51.687]             function(cond) {
[10:19:51.687]                 is_error <- inherits(cond, "error")
[10:19:51.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.687]                   NULL)
[10:19:51.687]                 if (is_error) {
[10:19:51.687]                   sessionInformation <- function() {
[10:19:51.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.687]                       search = base::search(), system = base::Sys.info())
[10:19:51.687]                   }
[10:19:51.687]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.687]                     cond$call), session = sessionInformation(), 
[10:19:51.687]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.687]                   signalCondition(cond)
[10:19:51.687]                 }
[10:19:51.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.687]                 "immediateCondition"))) {
[10:19:51.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.687]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.687]                   if (TRUE && !signal) {
[10:19:51.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.687]                     {
[10:19:51.687]                       inherits <- base::inherits
[10:19:51.687]                       invokeRestart <- base::invokeRestart
[10:19:51.687]                       is.null <- base::is.null
[10:19:51.687]                       muffled <- FALSE
[10:19:51.687]                       if (inherits(cond, "message")) {
[10:19:51.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.687]                         if (muffled) 
[10:19:51.687]                           invokeRestart("muffleMessage")
[10:19:51.687]                       }
[10:19:51.687]                       else if (inherits(cond, "warning")) {
[10:19:51.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.687]                         if (muffled) 
[10:19:51.687]                           invokeRestart("muffleWarning")
[10:19:51.687]                       }
[10:19:51.687]                       else if (inherits(cond, "condition")) {
[10:19:51.687]                         if (!is.null(pattern)) {
[10:19:51.687]                           computeRestarts <- base::computeRestarts
[10:19:51.687]                           grepl <- base::grepl
[10:19:51.687]                           restarts <- computeRestarts(cond)
[10:19:51.687]                           for (restart in restarts) {
[10:19:51.687]                             name <- restart$name
[10:19:51.687]                             if (is.null(name)) 
[10:19:51.687]                               next
[10:19:51.687]                             if (!grepl(pattern, name)) 
[10:19:51.687]                               next
[10:19:51.687]                             invokeRestart(restart)
[10:19:51.687]                             muffled <- TRUE
[10:19:51.687]                             break
[10:19:51.687]                           }
[10:19:51.687]                         }
[10:19:51.687]                       }
[10:19:51.687]                       invisible(muffled)
[10:19:51.687]                     }
[10:19:51.687]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.687]                   }
[10:19:51.687]                 }
[10:19:51.687]                 else {
[10:19:51.687]                   if (TRUE) {
[10:19:51.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.687]                     {
[10:19:51.687]                       inherits <- base::inherits
[10:19:51.687]                       invokeRestart <- base::invokeRestart
[10:19:51.687]                       is.null <- base::is.null
[10:19:51.687]                       muffled <- FALSE
[10:19:51.687]                       if (inherits(cond, "message")) {
[10:19:51.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.687]                         if (muffled) 
[10:19:51.687]                           invokeRestart("muffleMessage")
[10:19:51.687]                       }
[10:19:51.687]                       else if (inherits(cond, "warning")) {
[10:19:51.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.687]                         if (muffled) 
[10:19:51.687]                           invokeRestart("muffleWarning")
[10:19:51.687]                       }
[10:19:51.687]                       else if (inherits(cond, "condition")) {
[10:19:51.687]                         if (!is.null(pattern)) {
[10:19:51.687]                           computeRestarts <- base::computeRestarts
[10:19:51.687]                           grepl <- base::grepl
[10:19:51.687]                           restarts <- computeRestarts(cond)
[10:19:51.687]                           for (restart in restarts) {
[10:19:51.687]                             name <- restart$name
[10:19:51.687]                             if (is.null(name)) 
[10:19:51.687]                               next
[10:19:51.687]                             if (!grepl(pattern, name)) 
[10:19:51.687]                               next
[10:19:51.687]                             invokeRestart(restart)
[10:19:51.687]                             muffled <- TRUE
[10:19:51.687]                             break
[10:19:51.687]                           }
[10:19:51.687]                         }
[10:19:51.687]                       }
[10:19:51.687]                       invisible(muffled)
[10:19:51.687]                     }
[10:19:51.687]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.687]                   }
[10:19:51.687]                 }
[10:19:51.687]             }
[10:19:51.687]         }))
[10:19:51.687]     }, error = function(ex) {
[10:19:51.687]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.687]                 ...future.rng), started = ...future.startTime, 
[10:19:51.687]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.687]             version = "1.8"), class = "FutureResult")
[10:19:51.687]     }, finally = {
[10:19:51.687]         if (!identical(...future.workdir, getwd())) 
[10:19:51.687]             setwd(...future.workdir)
[10:19:51.687]         {
[10:19:51.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.687]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.687]             }
[10:19:51.687]             base::options(...future.oldOptions)
[10:19:51.687]             if (.Platform$OS.type == "windows") {
[10:19:51.687]                 old_names <- names(...future.oldEnvVars)
[10:19:51.687]                 envs <- base::Sys.getenv()
[10:19:51.687]                 names <- names(envs)
[10:19:51.687]                 common <- intersect(names, old_names)
[10:19:51.687]                 added <- setdiff(names, old_names)
[10:19:51.687]                 removed <- setdiff(old_names, names)
[10:19:51.687]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.687]                   envs[common]]
[10:19:51.687]                 NAMES <- toupper(changed)
[10:19:51.687]                 args <- list()
[10:19:51.687]                 for (kk in seq_along(NAMES)) {
[10:19:51.687]                   name <- changed[[kk]]
[10:19:51.687]                   NAME <- NAMES[[kk]]
[10:19:51.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.687]                     next
[10:19:51.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.687]                 }
[10:19:51.687]                 NAMES <- toupper(added)
[10:19:51.687]                 for (kk in seq_along(NAMES)) {
[10:19:51.687]                   name <- added[[kk]]
[10:19:51.687]                   NAME <- NAMES[[kk]]
[10:19:51.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.687]                     next
[10:19:51.687]                   args[[name]] <- ""
[10:19:51.687]                 }
[10:19:51.687]                 NAMES <- toupper(removed)
[10:19:51.687]                 for (kk in seq_along(NAMES)) {
[10:19:51.687]                   name <- removed[[kk]]
[10:19:51.687]                   NAME <- NAMES[[kk]]
[10:19:51.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.687]                     next
[10:19:51.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.687]                 }
[10:19:51.687]                 if (length(args) > 0) 
[10:19:51.687]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.687]             }
[10:19:51.687]             else {
[10:19:51.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.687]             }
[10:19:51.687]             {
[10:19:51.687]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.687]                   0L) {
[10:19:51.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.687]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.687]                   base::options(opts)
[10:19:51.687]                 }
[10:19:51.687]                 {
[10:19:51.687]                   {
[10:19:51.687]                     NULL
[10:19:51.687]                     RNGkind("Mersenne-Twister")
[10:19:51.687]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.687]                       inherits = FALSE)
[10:19:51.687]                   }
[10:19:51.687]                   options(future.plan = NULL)
[10:19:51.687]                   if (is.na(NA_character_)) 
[10:19:51.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.687]                     .init = FALSE)
[10:19:51.687]                 }
[10:19:51.687]             }
[10:19:51.687]         }
[10:19:51.687]     })
[10:19:51.687]     if (TRUE) {
[10:19:51.687]         base::sink(type = "output", split = FALSE)
[10:19:51.687]         if (TRUE) {
[10:19:51.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.687]         }
[10:19:51.687]         else {
[10:19:51.687]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.687]         }
[10:19:51.687]         base::close(...future.stdout)
[10:19:51.687]         ...future.stdout <- NULL
[10:19:51.687]     }
[10:19:51.687]     ...future.result$conditions <- ...future.conditions
[10:19:51.687]     ...future.result$finished <- base::Sys.time()
[10:19:51.687]     ...future.result
[10:19:51.687] }
[10:19:51.689] assign_globals() ...
[10:19:51.689] List of 11
[10:19:51.689]  $ ...future.FUN            :function (x, ...)  
[10:19:51.689]  $ x_FUN                    :function (x, y)  
[10:19:51.689]  $ times                    : int 15
[10:19:51.689]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.689]  $ stop_if_not              :function (...)  
[10:19:51.689]  $ dim                      : int [1:2] 3 5
[10:19:51.689]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.689]  $ future.call.arguments    :List of 1
[10:19:51.689]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:51.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.689]  $ ...future.elements_ii    :List of 4
[10:19:51.689]   ..$ A: num 50
[10:19:51.689]   ..$ B: num 60
[10:19:51.689]   ..$ C: num 70
[10:19:51.689]   ..$ D: num 80
[10:19:51.689]  $ ...future.seeds_ii       : NULL
[10:19:51.689]  $ ...future.globals.maxSize: NULL
[10:19:51.689]  - attr(*, "where")=List of 11
[10:19:51.689]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.689]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.689]  - attr(*, "resolved")= logi FALSE
[10:19:51.689]  - attr(*, "total_size")= num 26659
[10:19:51.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.689]  - attr(*, "already-done")= logi TRUE
[10:19:51.698] - copied ‘...future.FUN’ to environment
[10:19:51.698] - reassign environment for ‘x_FUN’
[10:19:51.698] - copied ‘x_FUN’ to environment
[10:19:51.698] - copied ‘times’ to environment
[10:19:51.699] - copied ‘stopf’ to environment
[10:19:51.699] - copied ‘stop_if_not’ to environment
[10:19:51.699] - copied ‘dim’ to environment
[10:19:51.699] - copied ‘valid_types’ to environment
[10:19:51.699] - copied ‘future.call.arguments’ to environment
[10:19:51.699] - copied ‘...future.elements_ii’ to environment
[10:19:51.699] - copied ‘...future.seeds_ii’ to environment
[10:19:51.699] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.699] assign_globals() ... done
[10:19:51.700] plan(): Setting new future strategy stack:
[10:19:51.700] List of future strategies:
[10:19:51.700] 1. sequential:
[10:19:51.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.700]    - tweaked: FALSE
[10:19:51.700]    - call: NULL
[10:19:51.700] plan(): nbrOfWorkers() = 1
[10:19:51.701] plan(): Setting new future strategy stack:
[10:19:51.701] List of future strategies:
[10:19:51.701] 1. sequential:
[10:19:51.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.701]    - tweaked: FALSE
[10:19:51.701]    - call: plan(strategy)
[10:19:51.701] plan(): nbrOfWorkers() = 1
[10:19:51.701] SequentialFuture started (and completed)
[10:19:51.702] - Launch lazy future ... done
[10:19:51.702] run() for ‘SequentialFuture’ ... done
[10:19:51.702] Created future:
[10:19:51.702] SequentialFuture:
[10:19:51.702] Label: ‘future_vapply-1’
[10:19:51.702] Expression:
[10:19:51.702] {
[10:19:51.702]     do.call(function(...) {
[10:19:51.702]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.702]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.702]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.702]             on.exit(options(oopts), add = TRUE)
[10:19:51.702]         }
[10:19:51.702]         {
[10:19:51.702]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.702]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.702]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.702]             })
[10:19:51.702]         }
[10:19:51.702]     }, args = future.call.arguments)
[10:19:51.702] }
[10:19:51.702] Lazy evaluation: FALSE
[10:19:51.702] Asynchronous evaluation: FALSE
[10:19:51.702] Local evaluation: TRUE
[10:19:51.702] Environment: R_GlobalEnv
[10:19:51.702] Capture standard output: TRUE
[10:19:51.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.702] Globals: 11 objects totaling 14.71 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.702] Packages: 1 packages (‘future.apply’)
[10:19:51.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.702] Resolved: TRUE
[10:19:51.702] Value: 666 bytes of class ‘list’
[10:19:51.702] Early signaling: FALSE
[10:19:51.702] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.702] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.703] Chunk #1 of 1 ... DONE
[10:19:51.703] Launching 1 futures (chunks) ... DONE
[10:19:51.703] Resolving 1 futures (chunks) ...
[10:19:51.703] resolve() on list ...
[10:19:51.703]  recursive: 0
[10:19:51.703]  length: 1
[10:19:51.703] 
[10:19:51.703] resolved() for ‘SequentialFuture’ ...
[10:19:51.703] - state: ‘finished’
[10:19:51.703] - run: TRUE
[10:19:51.704] - result: ‘FutureResult’
[10:19:51.704] resolved() for ‘SequentialFuture’ ... done
[10:19:51.704] Future #1
[10:19:51.704] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.704] - nx: 1
[10:19:51.704] - relay: TRUE
[10:19:51.704] - stdout: TRUE
[10:19:51.704] - signal: TRUE
[10:19:51.704] - resignal: FALSE
[10:19:51.704] - force: TRUE
[10:19:51.704] - relayed: [n=1] FALSE
[10:19:51.704] - queued futures: [n=1] FALSE
[10:19:51.705]  - until=1
[10:19:51.705]  - relaying element #1
[10:19:51.705] - relayed: [n=1] TRUE
[10:19:51.705] - queued futures: [n=1] TRUE
[10:19:51.705] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.705]  length: 0 (resolved future 1)
[10:19:51.705] Relaying remaining futures
[10:19:51.705] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.705] - nx: 1
[10:19:51.705] - relay: TRUE
[10:19:51.705] - stdout: TRUE
[10:19:51.705] - signal: TRUE
[10:19:51.706] - resignal: FALSE
[10:19:51.706] - force: TRUE
[10:19:51.706] - relayed: [n=1] TRUE
[10:19:51.706] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.706] - relayed: [n=1] TRUE
[10:19:51.706] - queued futures: [n=1] TRUE
[10:19:51.706] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.706] resolve() on list ... DONE
[10:19:51.706]  - Number of value chunks collected: 1
[10:19:51.706] Resolving 1 futures (chunks) ... DONE
[10:19:51.706] Reducing values from 1 chunks ...
[10:19:51.706]  - Number of values collected after concatenation: 4
[10:19:51.707]  - Number of values expected: 4
[10:19:51.707] Reducing values from 1 chunks ... DONE
[10:19:51.707] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:19:51.709] future_lapply() ...
[10:19:51.710] Number of chunks: 1
[10:19:51.710] getGlobalsAndPackagesXApply() ...
[10:19:51.710]  - future.globals: TRUE
[10:19:51.710] getGlobalsAndPackages() ...
[10:19:51.711] Searching for globals...
[10:19:51.715] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:51.715] Searching for globals ... DONE
[10:19:51.715] Resolving globals: FALSE
[10:19:51.716] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[10:19:51.717] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.717] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.717] - packages: [1] ‘future.apply’
[10:19:51.717] getGlobalsAndPackages() ... DONE
[10:19:51.717]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.717]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.717] Finding globals ... DONE
[10:19:51.717]  - use_args: TRUE
[10:19:51.717]  - Getting '...' globals ...
[10:19:51.718] resolve() on list ...
[10:19:51.718]  recursive: 0
[10:19:51.718]  length: 1
[10:19:51.718]  elements: ‘...’
[10:19:51.718]  length: 0 (resolved future 1)
[10:19:51.718] resolve() on list ... DONE
[10:19:51.718]    - '...' content: [n=0] 
[10:19:51.718] List of 1
[10:19:51.718]  $ ...: list()
[10:19:51.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.718]  - attr(*, "where")=List of 1
[10:19:51.718]   ..$ ...:<environment: 0x55c69fe0a8b8> 
[10:19:51.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.718]  - attr(*, "resolved")= logi TRUE
[10:19:51.718]  - attr(*, "total_size")= num NA
[10:19:51.721]  - Getting '...' globals ... DONE
[10:19:51.721] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.721] List of 8
[10:19:51.721]  $ ...future.FUN:function (x, ...)  
[10:19:51.721]  $ x_FUN        :function (x)  
[10:19:51.721]  $ times        : int 1
[10:19:51.721]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.721]  $ stop_if_not  :function (...)  
[10:19:51.721]  $ dim          : NULL
[10:19:51.721]  $ valid_types  : chr "logical"
[10:19:51.721]  $ ...          : list()
[10:19:51.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.721]  - attr(*, "where")=List of 8
[10:19:51.721]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.721]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.721]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.721]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.721]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.721]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.721]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.721]   ..$ ...          :<environment: 0x55c69fe0a8b8> 
[10:19:51.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.721]  - attr(*, "resolved")= logi FALSE
[10:19:51.721]  - attr(*, "total_size")= num 30734
[10:19:51.726] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.726] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.726] Number of futures (= number of chunks): 1
[10:19:51.726] Launching 1 futures (chunks) ...
[10:19:51.726] Chunk #1 of 1 ...
[10:19:51.727]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.727] getGlobalsAndPackages() ...
[10:19:51.727] Searching for globals...
[10:19:51.727] 
[10:19:51.727] Searching for globals ... DONE
[10:19:51.727] - globals: [0] <none>
[10:19:51.727] getGlobalsAndPackages() ... DONE
[10:19:51.727]    + additional globals found: [n=0] 
[10:19:51.727]    + additional namespaces needed: [n=0] 
[10:19:51.727]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.728]  - seeds: <none>
[10:19:51.728]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.728] getGlobalsAndPackages() ...
[10:19:51.728] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.728] Resolving globals: FALSE
[10:19:51.728] Tweak future expression to call with '...' arguments ...
[10:19:51.728] {
[10:19:51.728]     do.call(function(...) {
[10:19:51.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.728]             on.exit(options(oopts), add = TRUE)
[10:19:51.728]         }
[10:19:51.728]         {
[10:19:51.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.728]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.728]             })
[10:19:51.728]         }
[10:19:51.728]     }, args = future.call.arguments)
[10:19:51.728] }
[10:19:51.728] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.729] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.729] - packages: [1] ‘future.apply’
[10:19:51.729] getGlobalsAndPackages() ... DONE
[10:19:51.729] run() for ‘Future’ ...
[10:19:51.729] - state: ‘created’
[10:19:51.729] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.730] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.730]   - Field: ‘label’
[10:19:51.730]   - Field: ‘local’
[10:19:51.730]   - Field: ‘owner’
[10:19:51.730]   - Field: ‘envir’
[10:19:51.730]   - Field: ‘packages’
[10:19:51.730]   - Field: ‘gc’
[10:19:51.730]   - Field: ‘conditions’
[10:19:51.731]   - Field: ‘expr’
[10:19:51.731]   - Field: ‘uuid’
[10:19:51.731]   - Field: ‘seed’
[10:19:51.731]   - Field: ‘version’
[10:19:51.731]   - Field: ‘result’
[10:19:51.731]   - Field: ‘asynchronous’
[10:19:51.731]   - Field: ‘calls’
[10:19:51.731]   - Field: ‘globals’
[10:19:51.731]   - Field: ‘stdout’
[10:19:51.731]   - Field: ‘earlySignal’
[10:19:51.731]   - Field: ‘lazy’
[10:19:51.731]   - Field: ‘state’
[10:19:51.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.732] - Launch lazy future ...
[10:19:51.732] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.732] Packages needed by future strategies (n = 0): <none>
[10:19:51.732] {
[10:19:51.732]     {
[10:19:51.732]         {
[10:19:51.732]             ...future.startTime <- base::Sys.time()
[10:19:51.732]             {
[10:19:51.732]                 {
[10:19:51.732]                   {
[10:19:51.732]                     {
[10:19:51.732]                       base::local({
[10:19:51.732]                         has_future <- base::requireNamespace("future", 
[10:19:51.732]                           quietly = TRUE)
[10:19:51.732]                         if (has_future) {
[10:19:51.732]                           ns <- base::getNamespace("future")
[10:19:51.732]                           version <- ns[[".package"]][["version"]]
[10:19:51.732]                           if (is.null(version)) 
[10:19:51.732]                             version <- utils::packageVersion("future")
[10:19:51.732]                         }
[10:19:51.732]                         else {
[10:19:51.732]                           version <- NULL
[10:19:51.732]                         }
[10:19:51.732]                         if (!has_future || version < "1.8.0") {
[10:19:51.732]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.732]                             "", base::R.version$version.string), 
[10:19:51.732]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.732]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.732]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.732]                               "release", "version")], collapse = " "), 
[10:19:51.732]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.732]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.732]                             info)
[10:19:51.732]                           info <- base::paste(info, collapse = "; ")
[10:19:51.732]                           if (!has_future) {
[10:19:51.732]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.732]                               info)
[10:19:51.732]                           }
[10:19:51.732]                           else {
[10:19:51.732]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.732]                               info, version)
[10:19:51.732]                           }
[10:19:51.732]                           base::stop(msg)
[10:19:51.732]                         }
[10:19:51.732]                       })
[10:19:51.732]                     }
[10:19:51.732]                     base::local({
[10:19:51.732]                       for (pkg in "future.apply") {
[10:19:51.732]                         base::loadNamespace(pkg)
[10:19:51.732]                         base::library(pkg, character.only = TRUE)
[10:19:51.732]                       }
[10:19:51.732]                     })
[10:19:51.732]                   }
[10:19:51.732]                   ...future.strategy.old <- future::plan("list")
[10:19:51.732]                   options(future.plan = NULL)
[10:19:51.732]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.732]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.732]                 }
[10:19:51.732]                 ...future.workdir <- getwd()
[10:19:51.732]             }
[10:19:51.732]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.732]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.732]         }
[10:19:51.732]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.732]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.732]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.732]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.732]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.732]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.732]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.732]             base::names(...future.oldOptions))
[10:19:51.732]     }
[10:19:51.732]     if (FALSE) {
[10:19:51.732]     }
[10:19:51.732]     else {
[10:19:51.732]         if (TRUE) {
[10:19:51.732]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.732]                 open = "w")
[10:19:51.732]         }
[10:19:51.732]         else {
[10:19:51.732]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.732]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.732]         }
[10:19:51.732]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.732]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.732]             base::sink(type = "output", split = FALSE)
[10:19:51.732]             base::close(...future.stdout)
[10:19:51.732]         }, add = TRUE)
[10:19:51.732]     }
[10:19:51.732]     ...future.frame <- base::sys.nframe()
[10:19:51.732]     ...future.conditions <- base::list()
[10:19:51.732]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.732]     if (FALSE) {
[10:19:51.732]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.732]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.732]     }
[10:19:51.732]     ...future.result <- base::tryCatch({
[10:19:51.732]         base::withCallingHandlers({
[10:19:51.732]             ...future.value <- base::withVisible(base::local({
[10:19:51.732]                 do.call(function(...) {
[10:19:51.732]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.732]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.732]                     ...future.globals.maxSize)) {
[10:19:51.732]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.732]                     on.exit(options(oopts), add = TRUE)
[10:19:51.732]                   }
[10:19:51.732]                   {
[10:19:51.732]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.732]                       FUN = function(jj) {
[10:19:51.732]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.732]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.732]                       })
[10:19:51.732]                   }
[10:19:51.732]                 }, args = future.call.arguments)
[10:19:51.732]             }))
[10:19:51.732]             future::FutureResult(value = ...future.value$value, 
[10:19:51.732]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.732]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.732]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.732]                     ...future.globalenv.names))
[10:19:51.732]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.732]         }, condition = base::local({
[10:19:51.732]             c <- base::c
[10:19:51.732]             inherits <- base::inherits
[10:19:51.732]             invokeRestart <- base::invokeRestart
[10:19:51.732]             length <- base::length
[10:19:51.732]             list <- base::list
[10:19:51.732]             seq.int <- base::seq.int
[10:19:51.732]             signalCondition <- base::signalCondition
[10:19:51.732]             sys.calls <- base::sys.calls
[10:19:51.732]             `[[` <- base::`[[`
[10:19:51.732]             `+` <- base::`+`
[10:19:51.732]             `<<-` <- base::`<<-`
[10:19:51.732]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.732]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.732]                   3L)]
[10:19:51.732]             }
[10:19:51.732]             function(cond) {
[10:19:51.732]                 is_error <- inherits(cond, "error")
[10:19:51.732]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.732]                   NULL)
[10:19:51.732]                 if (is_error) {
[10:19:51.732]                   sessionInformation <- function() {
[10:19:51.732]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.732]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.732]                       search = base::search(), system = base::Sys.info())
[10:19:51.732]                   }
[10:19:51.732]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.732]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.732]                     cond$call), session = sessionInformation(), 
[10:19:51.732]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.732]                   signalCondition(cond)
[10:19:51.732]                 }
[10:19:51.732]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.732]                 "immediateCondition"))) {
[10:19:51.732]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.732]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.732]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.732]                   if (TRUE && !signal) {
[10:19:51.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.732]                     {
[10:19:51.732]                       inherits <- base::inherits
[10:19:51.732]                       invokeRestart <- base::invokeRestart
[10:19:51.732]                       is.null <- base::is.null
[10:19:51.732]                       muffled <- FALSE
[10:19:51.732]                       if (inherits(cond, "message")) {
[10:19:51.732]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.732]                         if (muffled) 
[10:19:51.732]                           invokeRestart("muffleMessage")
[10:19:51.732]                       }
[10:19:51.732]                       else if (inherits(cond, "warning")) {
[10:19:51.732]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.732]                         if (muffled) 
[10:19:51.732]                           invokeRestart("muffleWarning")
[10:19:51.732]                       }
[10:19:51.732]                       else if (inherits(cond, "condition")) {
[10:19:51.732]                         if (!is.null(pattern)) {
[10:19:51.732]                           computeRestarts <- base::computeRestarts
[10:19:51.732]                           grepl <- base::grepl
[10:19:51.732]                           restarts <- computeRestarts(cond)
[10:19:51.732]                           for (restart in restarts) {
[10:19:51.732]                             name <- restart$name
[10:19:51.732]                             if (is.null(name)) 
[10:19:51.732]                               next
[10:19:51.732]                             if (!grepl(pattern, name)) 
[10:19:51.732]                               next
[10:19:51.732]                             invokeRestart(restart)
[10:19:51.732]                             muffled <- TRUE
[10:19:51.732]                             break
[10:19:51.732]                           }
[10:19:51.732]                         }
[10:19:51.732]                       }
[10:19:51.732]                       invisible(muffled)
[10:19:51.732]                     }
[10:19:51.732]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.732]                   }
[10:19:51.732]                 }
[10:19:51.732]                 else {
[10:19:51.732]                   if (TRUE) {
[10:19:51.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.732]                     {
[10:19:51.732]                       inherits <- base::inherits
[10:19:51.732]                       invokeRestart <- base::invokeRestart
[10:19:51.732]                       is.null <- base::is.null
[10:19:51.732]                       muffled <- FALSE
[10:19:51.732]                       if (inherits(cond, "message")) {
[10:19:51.732]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.732]                         if (muffled) 
[10:19:51.732]                           invokeRestart("muffleMessage")
[10:19:51.732]                       }
[10:19:51.732]                       else if (inherits(cond, "warning")) {
[10:19:51.732]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.732]                         if (muffled) 
[10:19:51.732]                           invokeRestart("muffleWarning")
[10:19:51.732]                       }
[10:19:51.732]                       else if (inherits(cond, "condition")) {
[10:19:51.732]                         if (!is.null(pattern)) {
[10:19:51.732]                           computeRestarts <- base::computeRestarts
[10:19:51.732]                           grepl <- base::grepl
[10:19:51.732]                           restarts <- computeRestarts(cond)
[10:19:51.732]                           for (restart in restarts) {
[10:19:51.732]                             name <- restart$name
[10:19:51.732]                             if (is.null(name)) 
[10:19:51.732]                               next
[10:19:51.732]                             if (!grepl(pattern, name)) 
[10:19:51.732]                               next
[10:19:51.732]                             invokeRestart(restart)
[10:19:51.732]                             muffled <- TRUE
[10:19:51.732]                             break
[10:19:51.732]                           }
[10:19:51.732]                         }
[10:19:51.732]                       }
[10:19:51.732]                       invisible(muffled)
[10:19:51.732]                     }
[10:19:51.732]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.732]                   }
[10:19:51.732]                 }
[10:19:51.732]             }
[10:19:51.732]         }))
[10:19:51.732]     }, error = function(ex) {
[10:19:51.732]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.732]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.732]                 ...future.rng), started = ...future.startTime, 
[10:19:51.732]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.732]             version = "1.8"), class = "FutureResult")
[10:19:51.732]     }, finally = {
[10:19:51.732]         if (!identical(...future.workdir, getwd())) 
[10:19:51.732]             setwd(...future.workdir)
[10:19:51.732]         {
[10:19:51.732]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.732]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.732]             }
[10:19:51.732]             base::options(...future.oldOptions)
[10:19:51.732]             if (.Platform$OS.type == "windows") {
[10:19:51.732]                 old_names <- names(...future.oldEnvVars)
[10:19:51.732]                 envs <- base::Sys.getenv()
[10:19:51.732]                 names <- names(envs)
[10:19:51.732]                 common <- intersect(names, old_names)
[10:19:51.732]                 added <- setdiff(names, old_names)
[10:19:51.732]                 removed <- setdiff(old_names, names)
[10:19:51.732]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.732]                   envs[common]]
[10:19:51.732]                 NAMES <- toupper(changed)
[10:19:51.732]                 args <- list()
[10:19:51.732]                 for (kk in seq_along(NAMES)) {
[10:19:51.732]                   name <- changed[[kk]]
[10:19:51.732]                   NAME <- NAMES[[kk]]
[10:19:51.732]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.732]                     next
[10:19:51.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.732]                 }
[10:19:51.732]                 NAMES <- toupper(added)
[10:19:51.732]                 for (kk in seq_along(NAMES)) {
[10:19:51.732]                   name <- added[[kk]]
[10:19:51.732]                   NAME <- NAMES[[kk]]
[10:19:51.732]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.732]                     next
[10:19:51.732]                   args[[name]] <- ""
[10:19:51.732]                 }
[10:19:51.732]                 NAMES <- toupper(removed)
[10:19:51.732]                 for (kk in seq_along(NAMES)) {
[10:19:51.732]                   name <- removed[[kk]]
[10:19:51.732]                   NAME <- NAMES[[kk]]
[10:19:51.732]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.732]                     next
[10:19:51.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.732]                 }
[10:19:51.732]                 if (length(args) > 0) 
[10:19:51.732]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.732]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.732]             }
[10:19:51.732]             else {
[10:19:51.732]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.732]             }
[10:19:51.732]             {
[10:19:51.732]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.732]                   0L) {
[10:19:51.732]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.732]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.732]                   base::options(opts)
[10:19:51.732]                 }
[10:19:51.732]                 {
[10:19:51.732]                   {
[10:19:51.732]                     NULL
[10:19:51.732]                     RNGkind("Mersenne-Twister")
[10:19:51.732]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.732]                       inherits = FALSE)
[10:19:51.732]                   }
[10:19:51.732]                   options(future.plan = NULL)
[10:19:51.732]                   if (is.na(NA_character_)) 
[10:19:51.732]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.732]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.732]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.732]                     .init = FALSE)
[10:19:51.732]                 }
[10:19:51.732]             }
[10:19:51.732]         }
[10:19:51.732]     })
[10:19:51.732]     if (TRUE) {
[10:19:51.732]         base::sink(type = "output", split = FALSE)
[10:19:51.732]         if (TRUE) {
[10:19:51.732]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.732]         }
[10:19:51.732]         else {
[10:19:51.732]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.732]         }
[10:19:51.732]         base::close(...future.stdout)
[10:19:51.732]         ...future.stdout <- NULL
[10:19:51.732]     }
[10:19:51.732]     ...future.result$conditions <- ...future.conditions
[10:19:51.732]     ...future.result$finished <- base::Sys.time()
[10:19:51.732]     ...future.result
[10:19:51.732] }
[10:19:51.734] assign_globals() ...
[10:19:51.735] List of 11
[10:19:51.735]  $ ...future.FUN            :function (x, ...)  
[10:19:51.735]  $ x_FUN                    :function (x)  
[10:19:51.735]  $ times                    : int 1
[10:19:51.735]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.735]  $ stop_if_not              :function (...)  
[10:19:51.735]  $ dim                      : NULL
[10:19:51.735]  $ valid_types              : chr "logical"
[10:19:51.735]  $ future.call.arguments    : list()
[10:19:51.735]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.735]  $ ...future.elements_ii    :List of 11
[10:19:51.735]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[10:19:51.735]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[10:19:51.735]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[10:19:51.735]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[10:19:51.735]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[10:19:51.735]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[10:19:51.735]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[10:19:51.735]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[10:19:51.735]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[10:19:51.735]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[10:19:51.735]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[10:19:51.735]  $ ...future.seeds_ii       : NULL
[10:19:51.735]  $ ...future.globals.maxSize: NULL
[10:19:51.735]  - attr(*, "where")=List of 11
[10:19:51.735]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.735]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.735]  - attr(*, "resolved")= logi FALSE
[10:19:51.735]  - attr(*, "total_size")= num 30734
[10:19:51.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.735]  - attr(*, "already-done")= logi TRUE
[10:19:51.746] - copied ‘...future.FUN’ to environment
[10:19:51.746] - copied ‘x_FUN’ to environment
[10:19:51.746] - copied ‘times’ to environment
[10:19:51.746] - copied ‘stopf’ to environment
[10:19:51.746] - copied ‘stop_if_not’ to environment
[10:19:51.746] - copied ‘dim’ to environment
[10:19:51.746] - copied ‘valid_types’ to environment
[10:19:51.746] - copied ‘future.call.arguments’ to environment
[10:19:51.746] - copied ‘...future.elements_ii’ to environment
[10:19:51.746] - copied ‘...future.seeds_ii’ to environment
[10:19:51.746] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.747] assign_globals() ... done
[10:19:51.747] plan(): Setting new future strategy stack:
[10:19:51.747] List of future strategies:
[10:19:51.747] 1. sequential:
[10:19:51.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.747]    - tweaked: FALSE
[10:19:51.747]    - call: NULL
[10:19:51.747] plan(): nbrOfWorkers() = 1
[10:19:51.748] plan(): Setting new future strategy stack:
[10:19:51.748] List of future strategies:
[10:19:51.748] 1. sequential:
[10:19:51.748]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.748]    - tweaked: FALSE
[10:19:51.748]    - call: plan(strategy)
[10:19:51.749] plan(): nbrOfWorkers() = 1
[10:19:51.749] SequentialFuture started (and completed)
[10:19:51.749] - Launch lazy future ... done
[10:19:51.749] run() for ‘SequentialFuture’ ... done
[10:19:51.749] Created future:
[10:19:51.749] SequentialFuture:
[10:19:51.749] Label: ‘future_vapply-1’
[10:19:51.749] Expression:
[10:19:51.749] {
[10:19:51.749]     do.call(function(...) {
[10:19:51.749]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.749]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.749]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.749]             on.exit(options(oopts), add = TRUE)
[10:19:51.749]         }
[10:19:51.749]         {
[10:19:51.749]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.749]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.749]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.749]             })
[10:19:51.749]         }
[10:19:51.749]     }, args = future.call.arguments)
[10:19:51.749] }
[10:19:51.749] Lazy evaluation: FALSE
[10:19:51.749] Asynchronous evaluation: FALSE
[10:19:51.749] Local evaluation: TRUE
[10:19:51.749] Environment: R_GlobalEnv
[10:19:51.749] Capture standard output: TRUE
[10:19:51.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.749] Globals: 11 objects totaling 17.89 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.749] Packages: 1 packages (‘future.apply’)
[10:19:51.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.749] Resolved: TRUE
[10:19:51.749] Value: 163 bytes of class ‘list’
[10:19:51.749] Early signaling: FALSE
[10:19:51.749] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.749] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.750] Chunk #1 of 1 ... DONE
[10:19:51.750] Launching 1 futures (chunks) ... DONE
[10:19:51.750] Resolving 1 futures (chunks) ...
[10:19:51.750] resolve() on list ...
[10:19:51.750]  recursive: 0
[10:19:51.750]  length: 1
[10:19:51.751] 
[10:19:51.751] resolved() for ‘SequentialFuture’ ...
[10:19:51.751] - state: ‘finished’
[10:19:51.751] - run: TRUE
[10:19:51.751] - result: ‘FutureResult’
[10:19:51.751] resolved() for ‘SequentialFuture’ ... done
[10:19:51.751] Future #1
[10:19:51.751] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.751] - nx: 1
[10:19:51.751] - relay: TRUE
[10:19:51.751] - stdout: TRUE
[10:19:51.751] - signal: TRUE
[10:19:51.752] - resignal: FALSE
[10:19:51.752] - force: TRUE
[10:19:51.752] - relayed: [n=1] FALSE
[10:19:51.752] - queued futures: [n=1] FALSE
[10:19:51.752]  - until=1
[10:19:51.752]  - relaying element #1
[10:19:51.752] - relayed: [n=1] TRUE
[10:19:51.752] - queued futures: [n=1] TRUE
[10:19:51.752] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.752]  length: 0 (resolved future 1)
[10:19:51.752] Relaying remaining futures
[10:19:51.753] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.753] - nx: 1
[10:19:51.753] - relay: TRUE
[10:19:51.753] - stdout: TRUE
[10:19:51.753] - signal: TRUE
[10:19:51.753] - resignal: FALSE
[10:19:51.753] - force: TRUE
[10:19:51.753] - relayed: [n=1] TRUE
[10:19:51.753] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.753] - relayed: [n=1] TRUE
[10:19:51.753] - queued futures: [n=1] TRUE
[10:19:51.753] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.753] resolve() on list ... DONE
[10:19:51.754]  - Number of value chunks collected: 1
[10:19:51.754] Resolving 1 futures (chunks) ... DONE
[10:19:51.754] Reducing values from 1 chunks ...
[10:19:51.754]  - Number of values collected after concatenation: 11
[10:19:51.754]  - Number of values expected: 11
[10:19:51.754] Reducing values from 1 chunks ... DONE
[10:19:51.754] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:19:51.756] future_lapply() ...
[10:19:51.758] Number of chunks: 1
[10:19:51.758] getGlobalsAndPackagesXApply() ...
[10:19:51.758]  - future.globals: TRUE
[10:19:51.758] getGlobalsAndPackages() ...
[10:19:51.758] Searching for globals...
[10:19:51.761] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:51.761] Searching for globals ... DONE
[10:19:51.761] Resolving globals: FALSE
[10:19:51.762] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[10:19:51.762] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.762] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.762] - packages: [1] ‘future.apply’
[10:19:51.762] getGlobalsAndPackages() ... DONE
[10:19:51.762]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.763]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.763] Finding globals ... DONE
[10:19:51.763]  - use_args: TRUE
[10:19:51.763]  - Getting '...' globals ...
[10:19:51.763] resolve() on list ...
[10:19:51.763]  recursive: 0
[10:19:51.763]  length: 1
[10:19:51.763]  elements: ‘...’
[10:19:51.763]  length: 0 (resolved future 1)
[10:19:51.763] resolve() on list ... DONE
[10:19:51.764]    - '...' content: [n=0] 
[10:19:51.764] List of 1
[10:19:51.764]  $ ...: list()
[10:19:51.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.764]  - attr(*, "where")=List of 1
[10:19:51.764]   ..$ ...:<environment: 0x55c6a0497278> 
[10:19:51.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.764]  - attr(*, "resolved")= logi TRUE
[10:19:51.764]  - attr(*, "total_size")= num NA
[10:19:51.766]  - Getting '...' globals ... DONE
[10:19:51.766] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.766] List of 8
[10:19:51.766]  $ ...future.FUN:function (x, ...)  
[10:19:51.766]  $ x_FUN        :function (x)  
[10:19:51.766]  $ times        : int 1
[10:19:51.766]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.766]  $ stop_if_not  :function (...)  
[10:19:51.766]  $ dim          : NULL
[10:19:51.766]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:51.766]  $ ...          : list()
[10:19:51.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.766]  - attr(*, "where")=List of 8
[10:19:51.766]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.766]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.766]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.766]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.766]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.766]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.766]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.766]   ..$ ...          :<environment: 0x55c6a0497278> 
[10:19:51.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.766]  - attr(*, "resolved")= logi FALSE
[10:19:51.766]  - attr(*, "total_size")= num 22016
[10:19:51.771] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.771] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.771] Number of futures (= number of chunks): 1
[10:19:51.771] Launching 1 futures (chunks) ...
[10:19:51.771] Chunk #1 of 1 ...
[10:19:51.772]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.772] getGlobalsAndPackages() ...
[10:19:51.772] Searching for globals...
[10:19:51.772] 
[10:19:51.772] Searching for globals ... DONE
[10:19:51.772] - globals: [0] <none>
[10:19:51.772] getGlobalsAndPackages() ... DONE
[10:19:51.772]    + additional globals found: [n=0] 
[10:19:51.772]    + additional namespaces needed: [n=0] 
[10:19:51.772]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.772]  - seeds: <none>
[10:19:51.773]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.773] getGlobalsAndPackages() ...
[10:19:51.773] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.773] Resolving globals: FALSE
[10:19:51.773] Tweak future expression to call with '...' arguments ...
[10:19:51.773] {
[10:19:51.773]     do.call(function(...) {
[10:19:51.773]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.773]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.773]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.773]             on.exit(options(oopts), add = TRUE)
[10:19:51.773]         }
[10:19:51.773]         {
[10:19:51.773]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.773]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.773]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.773]             })
[10:19:51.773]         }
[10:19:51.773]     }, args = future.call.arguments)
[10:19:51.773] }
[10:19:51.773] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.774] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.774] - packages: [1] ‘future.apply’
[10:19:51.775] getGlobalsAndPackages() ... DONE
[10:19:51.775] run() for ‘Future’ ...
[10:19:51.775] - state: ‘created’
[10:19:51.775] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.776]   - Field: ‘label’
[10:19:51.776]   - Field: ‘local’
[10:19:51.776]   - Field: ‘owner’
[10:19:51.776]   - Field: ‘envir’
[10:19:51.776]   - Field: ‘packages’
[10:19:51.776]   - Field: ‘gc’
[10:19:51.776]   - Field: ‘conditions’
[10:19:51.777]   - Field: ‘expr’
[10:19:51.777]   - Field: ‘uuid’
[10:19:51.777]   - Field: ‘seed’
[10:19:51.777]   - Field: ‘version’
[10:19:51.777]   - Field: ‘result’
[10:19:51.777]   - Field: ‘asynchronous’
[10:19:51.777]   - Field: ‘calls’
[10:19:51.777]   - Field: ‘globals’
[10:19:51.777]   - Field: ‘stdout’
[10:19:51.777]   - Field: ‘earlySignal’
[10:19:51.777]   - Field: ‘lazy’
[10:19:51.777]   - Field: ‘state’
[10:19:51.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.778] - Launch lazy future ...
[10:19:51.778] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.778] Packages needed by future strategies (n = 0): <none>
[10:19:51.778] {
[10:19:51.778]     {
[10:19:51.778]         {
[10:19:51.778]             ...future.startTime <- base::Sys.time()
[10:19:51.778]             {
[10:19:51.778]                 {
[10:19:51.778]                   {
[10:19:51.778]                     {
[10:19:51.778]                       base::local({
[10:19:51.778]                         has_future <- base::requireNamespace("future", 
[10:19:51.778]                           quietly = TRUE)
[10:19:51.778]                         if (has_future) {
[10:19:51.778]                           ns <- base::getNamespace("future")
[10:19:51.778]                           version <- ns[[".package"]][["version"]]
[10:19:51.778]                           if (is.null(version)) 
[10:19:51.778]                             version <- utils::packageVersion("future")
[10:19:51.778]                         }
[10:19:51.778]                         else {
[10:19:51.778]                           version <- NULL
[10:19:51.778]                         }
[10:19:51.778]                         if (!has_future || version < "1.8.0") {
[10:19:51.778]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.778]                             "", base::R.version$version.string), 
[10:19:51.778]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.778]                               "release", "version")], collapse = " "), 
[10:19:51.778]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.778]                             info)
[10:19:51.778]                           info <- base::paste(info, collapse = "; ")
[10:19:51.778]                           if (!has_future) {
[10:19:51.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.778]                               info)
[10:19:51.778]                           }
[10:19:51.778]                           else {
[10:19:51.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.778]                               info, version)
[10:19:51.778]                           }
[10:19:51.778]                           base::stop(msg)
[10:19:51.778]                         }
[10:19:51.778]                       })
[10:19:51.778]                     }
[10:19:51.778]                     base::local({
[10:19:51.778]                       for (pkg in "future.apply") {
[10:19:51.778]                         base::loadNamespace(pkg)
[10:19:51.778]                         base::library(pkg, character.only = TRUE)
[10:19:51.778]                       }
[10:19:51.778]                     })
[10:19:51.778]                   }
[10:19:51.778]                   ...future.strategy.old <- future::plan("list")
[10:19:51.778]                   options(future.plan = NULL)
[10:19:51.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.778]                 }
[10:19:51.778]                 ...future.workdir <- getwd()
[10:19:51.778]             }
[10:19:51.778]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.778]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.778]         }
[10:19:51.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.778]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.778]             base::names(...future.oldOptions))
[10:19:51.778]     }
[10:19:51.778]     if (FALSE) {
[10:19:51.778]     }
[10:19:51.778]     else {
[10:19:51.778]         if (TRUE) {
[10:19:51.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.778]                 open = "w")
[10:19:51.778]         }
[10:19:51.778]         else {
[10:19:51.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.778]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.778]         }
[10:19:51.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.778]             base::sink(type = "output", split = FALSE)
[10:19:51.778]             base::close(...future.stdout)
[10:19:51.778]         }, add = TRUE)
[10:19:51.778]     }
[10:19:51.778]     ...future.frame <- base::sys.nframe()
[10:19:51.778]     ...future.conditions <- base::list()
[10:19:51.778]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.778]     if (FALSE) {
[10:19:51.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.778]     }
[10:19:51.778]     ...future.result <- base::tryCatch({
[10:19:51.778]         base::withCallingHandlers({
[10:19:51.778]             ...future.value <- base::withVisible(base::local({
[10:19:51.778]                 do.call(function(...) {
[10:19:51.778]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.778]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.778]                     ...future.globals.maxSize)) {
[10:19:51.778]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.778]                     on.exit(options(oopts), add = TRUE)
[10:19:51.778]                   }
[10:19:51.778]                   {
[10:19:51.778]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.778]                       FUN = function(jj) {
[10:19:51.778]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.778]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.778]                       })
[10:19:51.778]                   }
[10:19:51.778]                 }, args = future.call.arguments)
[10:19:51.778]             }))
[10:19:51.778]             future::FutureResult(value = ...future.value$value, 
[10:19:51.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.778]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.778]                     ...future.globalenv.names))
[10:19:51.778]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.778]         }, condition = base::local({
[10:19:51.778]             c <- base::c
[10:19:51.778]             inherits <- base::inherits
[10:19:51.778]             invokeRestart <- base::invokeRestart
[10:19:51.778]             length <- base::length
[10:19:51.778]             list <- base::list
[10:19:51.778]             seq.int <- base::seq.int
[10:19:51.778]             signalCondition <- base::signalCondition
[10:19:51.778]             sys.calls <- base::sys.calls
[10:19:51.778]             `[[` <- base::`[[`
[10:19:51.778]             `+` <- base::`+`
[10:19:51.778]             `<<-` <- base::`<<-`
[10:19:51.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.778]                   3L)]
[10:19:51.778]             }
[10:19:51.778]             function(cond) {
[10:19:51.778]                 is_error <- inherits(cond, "error")
[10:19:51.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.778]                   NULL)
[10:19:51.778]                 if (is_error) {
[10:19:51.778]                   sessionInformation <- function() {
[10:19:51.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.778]                       search = base::search(), system = base::Sys.info())
[10:19:51.778]                   }
[10:19:51.778]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.778]                     cond$call), session = sessionInformation(), 
[10:19:51.778]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.778]                   signalCondition(cond)
[10:19:51.778]                 }
[10:19:51.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.778]                 "immediateCondition"))) {
[10:19:51.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.778]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.778]                   if (TRUE && !signal) {
[10:19:51.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.778]                     {
[10:19:51.778]                       inherits <- base::inherits
[10:19:51.778]                       invokeRestart <- base::invokeRestart
[10:19:51.778]                       is.null <- base::is.null
[10:19:51.778]                       muffled <- FALSE
[10:19:51.778]                       if (inherits(cond, "message")) {
[10:19:51.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.778]                         if (muffled) 
[10:19:51.778]                           invokeRestart("muffleMessage")
[10:19:51.778]                       }
[10:19:51.778]                       else if (inherits(cond, "warning")) {
[10:19:51.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.778]                         if (muffled) 
[10:19:51.778]                           invokeRestart("muffleWarning")
[10:19:51.778]                       }
[10:19:51.778]                       else if (inherits(cond, "condition")) {
[10:19:51.778]                         if (!is.null(pattern)) {
[10:19:51.778]                           computeRestarts <- base::computeRestarts
[10:19:51.778]                           grepl <- base::grepl
[10:19:51.778]                           restarts <- computeRestarts(cond)
[10:19:51.778]                           for (restart in restarts) {
[10:19:51.778]                             name <- restart$name
[10:19:51.778]                             if (is.null(name)) 
[10:19:51.778]                               next
[10:19:51.778]                             if (!grepl(pattern, name)) 
[10:19:51.778]                               next
[10:19:51.778]                             invokeRestart(restart)
[10:19:51.778]                             muffled <- TRUE
[10:19:51.778]                             break
[10:19:51.778]                           }
[10:19:51.778]                         }
[10:19:51.778]                       }
[10:19:51.778]                       invisible(muffled)
[10:19:51.778]                     }
[10:19:51.778]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.778]                   }
[10:19:51.778]                 }
[10:19:51.778]                 else {
[10:19:51.778]                   if (TRUE) {
[10:19:51.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.778]                     {
[10:19:51.778]                       inherits <- base::inherits
[10:19:51.778]                       invokeRestart <- base::invokeRestart
[10:19:51.778]                       is.null <- base::is.null
[10:19:51.778]                       muffled <- FALSE
[10:19:51.778]                       if (inherits(cond, "message")) {
[10:19:51.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.778]                         if (muffled) 
[10:19:51.778]                           invokeRestart("muffleMessage")
[10:19:51.778]                       }
[10:19:51.778]                       else if (inherits(cond, "warning")) {
[10:19:51.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.778]                         if (muffled) 
[10:19:51.778]                           invokeRestart("muffleWarning")
[10:19:51.778]                       }
[10:19:51.778]                       else if (inherits(cond, "condition")) {
[10:19:51.778]                         if (!is.null(pattern)) {
[10:19:51.778]                           computeRestarts <- base::computeRestarts
[10:19:51.778]                           grepl <- base::grepl
[10:19:51.778]                           restarts <- computeRestarts(cond)
[10:19:51.778]                           for (restart in restarts) {
[10:19:51.778]                             name <- restart$name
[10:19:51.778]                             if (is.null(name)) 
[10:19:51.778]                               next
[10:19:51.778]                             if (!grepl(pattern, name)) 
[10:19:51.778]                               next
[10:19:51.778]                             invokeRestart(restart)
[10:19:51.778]                             muffled <- TRUE
[10:19:51.778]                             break
[10:19:51.778]                           }
[10:19:51.778]                         }
[10:19:51.778]                       }
[10:19:51.778]                       invisible(muffled)
[10:19:51.778]                     }
[10:19:51.778]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.778]                   }
[10:19:51.778]                 }
[10:19:51.778]             }
[10:19:51.778]         }))
[10:19:51.778]     }, error = function(ex) {
[10:19:51.778]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.778]                 ...future.rng), started = ...future.startTime, 
[10:19:51.778]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.778]             version = "1.8"), class = "FutureResult")
[10:19:51.778]     }, finally = {
[10:19:51.778]         if (!identical(...future.workdir, getwd())) 
[10:19:51.778]             setwd(...future.workdir)
[10:19:51.778]         {
[10:19:51.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.778]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.778]             }
[10:19:51.778]             base::options(...future.oldOptions)
[10:19:51.778]             if (.Platform$OS.type == "windows") {
[10:19:51.778]                 old_names <- names(...future.oldEnvVars)
[10:19:51.778]                 envs <- base::Sys.getenv()
[10:19:51.778]                 names <- names(envs)
[10:19:51.778]                 common <- intersect(names, old_names)
[10:19:51.778]                 added <- setdiff(names, old_names)
[10:19:51.778]                 removed <- setdiff(old_names, names)
[10:19:51.778]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.778]                   envs[common]]
[10:19:51.778]                 NAMES <- toupper(changed)
[10:19:51.778]                 args <- list()
[10:19:51.778]                 for (kk in seq_along(NAMES)) {
[10:19:51.778]                   name <- changed[[kk]]
[10:19:51.778]                   NAME <- NAMES[[kk]]
[10:19:51.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.778]                     next
[10:19:51.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.778]                 }
[10:19:51.778]                 NAMES <- toupper(added)
[10:19:51.778]                 for (kk in seq_along(NAMES)) {
[10:19:51.778]                   name <- added[[kk]]
[10:19:51.778]                   NAME <- NAMES[[kk]]
[10:19:51.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.778]                     next
[10:19:51.778]                   args[[name]] <- ""
[10:19:51.778]                 }
[10:19:51.778]                 NAMES <- toupper(removed)
[10:19:51.778]                 for (kk in seq_along(NAMES)) {
[10:19:51.778]                   name <- removed[[kk]]
[10:19:51.778]                   NAME <- NAMES[[kk]]
[10:19:51.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.778]                     next
[10:19:51.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.778]                 }
[10:19:51.778]                 if (length(args) > 0) 
[10:19:51.778]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.778]             }
[10:19:51.778]             else {
[10:19:51.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.778]             }
[10:19:51.778]             {
[10:19:51.778]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.778]                   0L) {
[10:19:51.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.778]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.778]                   base::options(opts)
[10:19:51.778]                 }
[10:19:51.778]                 {
[10:19:51.778]                   {
[10:19:51.778]                     NULL
[10:19:51.778]                     RNGkind("Mersenne-Twister")
[10:19:51.778]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.778]                       inherits = FALSE)
[10:19:51.778]                   }
[10:19:51.778]                   options(future.plan = NULL)
[10:19:51.778]                   if (is.na(NA_character_)) 
[10:19:51.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.778]                     .init = FALSE)
[10:19:51.778]                 }
[10:19:51.778]             }
[10:19:51.778]         }
[10:19:51.778]     })
[10:19:51.778]     if (TRUE) {
[10:19:51.778]         base::sink(type = "output", split = FALSE)
[10:19:51.778]         if (TRUE) {
[10:19:51.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.778]         }
[10:19:51.778]         else {
[10:19:51.778]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.778]         }
[10:19:51.778]         base::close(...future.stdout)
[10:19:51.778]         ...future.stdout <- NULL
[10:19:51.778]     }
[10:19:51.778]     ...future.result$conditions <- ...future.conditions
[10:19:51.778]     ...future.result$finished <- base::Sys.time()
[10:19:51.778]     ...future.result
[10:19:51.778] }
[10:19:51.780] assign_globals() ...
[10:19:51.780] List of 11
[10:19:51.780]  $ ...future.FUN            :function (x, ...)  
[10:19:51.780]  $ x_FUN                    :function (x)  
[10:19:51.780]  $ times                    : int 1
[10:19:51.780]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.780]  $ stop_if_not              :function (...)  
[10:19:51.780]  $ dim                      : NULL
[10:19:51.780]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:51.780]  $ future.call.arguments    : list()
[10:19:51.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.780]  $ ...future.elements_ii    :List of 3
[10:19:51.780]   ..$ a: num 1
[10:19:51.780]   ..$ b: num 2
[10:19:51.780]   ..$ c: num 3
[10:19:51.780]  $ ...future.seeds_ii       : NULL
[10:19:51.780]  $ ...future.globals.maxSize: NULL
[10:19:51.780]  - attr(*, "where")=List of 11
[10:19:51.780]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.780]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.780]  - attr(*, "resolved")= logi FALSE
[10:19:51.780]  - attr(*, "total_size")= num 22016
[10:19:51.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.780]  - attr(*, "already-done")= logi TRUE
[10:19:51.787] - copied ‘...future.FUN’ to environment
[10:19:51.787] - copied ‘x_FUN’ to environment
[10:19:51.787] - copied ‘times’ to environment
[10:19:51.788] - copied ‘stopf’ to environment
[10:19:51.788] - copied ‘stop_if_not’ to environment
[10:19:51.788] - copied ‘dim’ to environment
[10:19:51.788] - copied ‘valid_types’ to environment
[10:19:51.788] - copied ‘future.call.arguments’ to environment
[10:19:51.788] - copied ‘...future.elements_ii’ to environment
[10:19:51.788] - copied ‘...future.seeds_ii’ to environment
[10:19:51.788] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.788] assign_globals() ... done
[10:19:51.789] plan(): Setting new future strategy stack:
[10:19:51.789] List of future strategies:
[10:19:51.789] 1. sequential:
[10:19:51.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.789]    - tweaked: FALSE
[10:19:51.789]    - call: NULL
[10:19:51.789] plan(): nbrOfWorkers() = 1
[10:19:51.790] plan(): Setting new future strategy stack:
[10:19:51.790] List of future strategies:
[10:19:51.790] 1. sequential:
[10:19:51.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.790]    - tweaked: FALSE
[10:19:51.790]    - call: plan(strategy)
[10:19:51.790] plan(): nbrOfWorkers() = 1
[10:19:51.790] SequentialFuture started (and completed)
[10:19:51.791] - Launch lazy future ... done
[10:19:51.791] run() for ‘SequentialFuture’ ... done
[10:19:51.791] Created future:
[10:19:51.791] SequentialFuture:
[10:19:51.791] Label: ‘future_vapply-1’
[10:19:51.791] Expression:
[10:19:51.791] {
[10:19:51.791]     do.call(function(...) {
[10:19:51.791]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.791]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.791]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.791]             on.exit(options(oopts), add = TRUE)
[10:19:51.791]         }
[10:19:51.791]         {
[10:19:51.791]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.791]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.791]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.791]             })
[10:19:51.791]         }
[10:19:51.791]     }, args = future.call.arguments)
[10:19:51.791] }
[10:19:51.791] Lazy evaluation: FALSE
[10:19:51.791] Asynchronous evaluation: FALSE
[10:19:51.791] Local evaluation: TRUE
[10:19:51.791] Environment: R_GlobalEnv
[10:19:51.791] Capture standard output: TRUE
[10:19:51.791] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.791] Globals: 11 objects totaling 12.19 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.791] Packages: 1 packages (‘future.apply’)
[10:19:51.791] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.791] Resolved: TRUE
[10:19:51.791] Value: 67 bytes of class ‘list’
[10:19:51.791] Early signaling: FALSE
[10:19:51.791] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.791] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.792] Chunk #1 of 1 ... DONE
[10:19:51.792] Launching 1 futures (chunks) ... DONE
[10:19:51.792] Resolving 1 futures (chunks) ...
[10:19:51.792] resolve() on list ...
[10:19:51.792]  recursive: 0
[10:19:51.792]  length: 1
[10:19:51.792] 
[10:19:51.792] resolved() for ‘SequentialFuture’ ...
[10:19:51.792] - state: ‘finished’
[10:19:51.792] - run: TRUE
[10:19:51.792] - result: ‘FutureResult’
[10:19:51.793] resolved() for ‘SequentialFuture’ ... done
[10:19:51.793] Future #1
[10:19:51.793] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.793] - nx: 1
[10:19:51.793] - relay: TRUE
[10:19:51.793] - stdout: TRUE
[10:19:51.793] - signal: TRUE
[10:19:51.793] - resignal: FALSE
[10:19:51.793] - force: TRUE
[10:19:51.793] - relayed: [n=1] FALSE
[10:19:51.793] - queued futures: [n=1] FALSE
[10:19:51.793]  - until=1
[10:19:51.794]  - relaying element #1
[10:19:51.794] - relayed: [n=1] TRUE
[10:19:51.794] - queued futures: [n=1] TRUE
[10:19:51.794] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.794]  length: 0 (resolved future 1)
[10:19:51.794] Relaying remaining futures
[10:19:51.794] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.794] - nx: 1
[10:19:51.794] - relay: TRUE
[10:19:51.794] - stdout: TRUE
[10:19:51.794] - signal: TRUE
[10:19:51.794] - resignal: FALSE
[10:19:51.795] - force: TRUE
[10:19:51.795] - relayed: [n=1] TRUE
[10:19:51.795] - queued futures: [n=1] TRUE
 - flush all
[10:19:51.796] - relayed: [n=1] TRUE
[10:19:51.796] - queued futures: [n=1] TRUE
[10:19:51.796] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.796] resolve() on list ... DONE
[10:19:51.796]  - Number of value chunks collected: 1
[10:19:51.796] Resolving 1 futures (chunks) ... DONE
[10:19:51.796] Reducing values from 1 chunks ...
[10:19:51.797]  - Number of values collected after concatenation: 3
[10:19:51.797]  - Number of values expected: 3
[10:19:51.797] Reducing values from 1 chunks ... DONE
[10:19:51.797] future_lapply() ... DONE
- exceptions ...
[10:19:51.797] future_lapply() ...
[10:19:51.799] Number of chunks: 1
[10:19:51.799] getGlobalsAndPackagesXApply() ...
[10:19:51.799]  - future.globals: TRUE
[10:19:51.799] getGlobalsAndPackages() ...
[10:19:51.799] Searching for globals...
[10:19:51.802] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:51.802] Searching for globals ... DONE
[10:19:51.802] Resolving globals: FALSE
[10:19:51.803] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[10:19:51.803] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.803] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.803] - packages: [1] ‘future.apply’
[10:19:51.804] getGlobalsAndPackages() ... DONE
[10:19:51.804]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.804]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.804] Finding globals ... DONE
[10:19:51.804]  - use_args: TRUE
[10:19:51.804]  - Getting '...' globals ...
[10:19:51.804] resolve() on list ...
[10:19:51.804]  recursive: 0
[10:19:51.804]  length: 1
[10:19:51.805]  elements: ‘...’
[10:19:51.805]  length: 0 (resolved future 1)
[10:19:51.805] resolve() on list ... DONE
[10:19:51.805]    - '...' content: [n=0] 
[10:19:51.805] List of 1
[10:19:51.805]  $ ...: list()
[10:19:51.805]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.805]  - attr(*, "where")=List of 1
[10:19:51.805]   ..$ ...:<environment: 0x55c6a0093340> 
[10:19:51.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.805]  - attr(*, "resolved")= logi TRUE
[10:19:51.805]  - attr(*, "total_size")= num NA
[10:19:51.807]  - Getting '...' globals ... DONE
[10:19:51.807] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.807] List of 8
[10:19:51.807]  $ ...future.FUN:function (x, ...)  
[10:19:51.807]  $ x_FUN        :function (x)  
[10:19:51.807]  $ times        : int 2
[10:19:51.807]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.807]  $ stop_if_not  :function (...)  
[10:19:51.807]  $ dim          : NULL
[10:19:51.807]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.807]  $ ...          : list()
[10:19:51.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.807]  - attr(*, "where")=List of 8
[10:19:51.807]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.807]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.807]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.807]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.807]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.807]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.807]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.807]   ..$ ...          :<environment: 0x55c6a0093340> 
[10:19:51.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.807]  - attr(*, "resolved")= logi FALSE
[10:19:51.807]  - attr(*, "total_size")= num 23676
[10:19:51.812] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.812] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.812] Number of futures (= number of chunks): 1
[10:19:51.812] Launching 1 futures (chunks) ...
[10:19:51.813] Chunk #1 of 1 ...
[10:19:51.813]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.813] getGlobalsAndPackages() ...
[10:19:51.813] Searching for globals...
[10:19:51.813] 
[10:19:51.813] Searching for globals ... DONE
[10:19:51.813] - globals: [0] <none>
[10:19:51.813] getGlobalsAndPackages() ... DONE
[10:19:51.813]    + additional globals found: [n=0] 
[10:19:51.813]    + additional namespaces needed: [n=0] 
[10:19:51.814]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.815]  - seeds: <none>
[10:19:51.815]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.815] getGlobalsAndPackages() ...
[10:19:51.815] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.815] Resolving globals: FALSE
[10:19:51.815] Tweak future expression to call with '...' arguments ...
[10:19:51.815] {
[10:19:51.815]     do.call(function(...) {
[10:19:51.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.815]             on.exit(options(oopts), add = TRUE)
[10:19:51.815]         }
[10:19:51.815]         {
[10:19:51.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.815]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.815]             })
[10:19:51.815]         }
[10:19:51.815]     }, args = future.call.arguments)
[10:19:51.815] }
[10:19:51.815] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.816] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.816] - packages: [1] ‘future.apply’
[10:19:51.816] getGlobalsAndPackages() ... DONE
[10:19:51.816] run() for ‘Future’ ...
[10:19:51.816] - state: ‘created’
[10:19:51.817] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:51.817] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:51.817]   - Field: ‘label’
[10:19:51.817]   - Field: ‘local’
[10:19:51.817]   - Field: ‘owner’
[10:19:51.817]   - Field: ‘envir’
[10:19:51.817]   - Field: ‘packages’
[10:19:51.817]   - Field: ‘gc’
[10:19:51.818]   - Field: ‘conditions’
[10:19:51.818]   - Field: ‘expr’
[10:19:51.818]   - Field: ‘uuid’
[10:19:51.818]   - Field: ‘seed’
[10:19:51.818]   - Field: ‘version’
[10:19:51.818]   - Field: ‘result’
[10:19:51.818]   - Field: ‘asynchronous’
[10:19:51.818]   - Field: ‘calls’
[10:19:51.818]   - Field: ‘globals’
[10:19:51.818]   - Field: ‘stdout’
[10:19:51.818]   - Field: ‘earlySignal’
[10:19:51.818]   - Field: ‘lazy’
[10:19:51.818]   - Field: ‘state’
[10:19:51.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:51.819] - Launch lazy future ...
[10:19:51.819] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.819] Packages needed by future strategies (n = 0): <none>
[10:19:51.819] {
[10:19:51.819]     {
[10:19:51.819]         {
[10:19:51.819]             ...future.startTime <- base::Sys.time()
[10:19:51.819]             {
[10:19:51.819]                 {
[10:19:51.819]                   {
[10:19:51.819]                     {
[10:19:51.819]                       base::local({
[10:19:51.819]                         has_future <- base::requireNamespace("future", 
[10:19:51.819]                           quietly = TRUE)
[10:19:51.819]                         if (has_future) {
[10:19:51.819]                           ns <- base::getNamespace("future")
[10:19:51.819]                           version <- ns[[".package"]][["version"]]
[10:19:51.819]                           if (is.null(version)) 
[10:19:51.819]                             version <- utils::packageVersion("future")
[10:19:51.819]                         }
[10:19:51.819]                         else {
[10:19:51.819]                           version <- NULL
[10:19:51.819]                         }
[10:19:51.819]                         if (!has_future || version < "1.8.0") {
[10:19:51.819]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.819]                             "", base::R.version$version.string), 
[10:19:51.819]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:51.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:51.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.819]                               "release", "version")], collapse = " "), 
[10:19:51.819]                             hostname = base::Sys.info()[["nodename"]])
[10:19:51.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.819]                             info)
[10:19:51.819]                           info <- base::paste(info, collapse = "; ")
[10:19:51.819]                           if (!has_future) {
[10:19:51.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.819]                               info)
[10:19:51.819]                           }
[10:19:51.819]                           else {
[10:19:51.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.819]                               info, version)
[10:19:51.819]                           }
[10:19:51.819]                           base::stop(msg)
[10:19:51.819]                         }
[10:19:51.819]                       })
[10:19:51.819]                     }
[10:19:51.819]                     base::local({
[10:19:51.819]                       for (pkg in "future.apply") {
[10:19:51.819]                         base::loadNamespace(pkg)
[10:19:51.819]                         base::library(pkg, character.only = TRUE)
[10:19:51.819]                       }
[10:19:51.819]                     })
[10:19:51.819]                   }
[10:19:51.819]                   ...future.strategy.old <- future::plan("list")
[10:19:51.819]                   options(future.plan = NULL)
[10:19:51.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.819]                 }
[10:19:51.819]                 ...future.workdir <- getwd()
[10:19:51.819]             }
[10:19:51.819]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.819]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.819]         }
[10:19:51.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:51.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.819]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.819]             base::names(...future.oldOptions))
[10:19:51.819]     }
[10:19:51.819]     if (FALSE) {
[10:19:51.819]     }
[10:19:51.819]     else {
[10:19:51.819]         if (TRUE) {
[10:19:51.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.819]                 open = "w")
[10:19:51.819]         }
[10:19:51.819]         else {
[10:19:51.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.819]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.819]         }
[10:19:51.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.819]             base::sink(type = "output", split = FALSE)
[10:19:51.819]             base::close(...future.stdout)
[10:19:51.819]         }, add = TRUE)
[10:19:51.819]     }
[10:19:51.819]     ...future.frame <- base::sys.nframe()
[10:19:51.819]     ...future.conditions <- base::list()
[10:19:51.819]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.819]     if (FALSE) {
[10:19:51.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.819]     }
[10:19:51.819]     ...future.result <- base::tryCatch({
[10:19:51.819]         base::withCallingHandlers({
[10:19:51.819]             ...future.value <- base::withVisible(base::local({
[10:19:51.819]                 do.call(function(...) {
[10:19:51.819]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.819]                   if (!identical(...future.globals.maxSize.org, 
[10:19:51.819]                     ...future.globals.maxSize)) {
[10:19:51.819]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.819]                     on.exit(options(oopts), add = TRUE)
[10:19:51.819]                   }
[10:19:51.819]                   {
[10:19:51.819]                     lapply(seq_along(...future.elements_ii), 
[10:19:51.819]                       FUN = function(jj) {
[10:19:51.819]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.819]                         ...future.FUN(...future.X_jj, ...)
[10:19:51.819]                       })
[10:19:51.819]                   }
[10:19:51.819]                 }, args = future.call.arguments)
[10:19:51.819]             }))
[10:19:51.819]             future::FutureResult(value = ...future.value$value, 
[10:19:51.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.819]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.819]                     ...future.globalenv.names))
[10:19:51.819]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.819]         }, condition = base::local({
[10:19:51.819]             c <- base::c
[10:19:51.819]             inherits <- base::inherits
[10:19:51.819]             invokeRestart <- base::invokeRestart
[10:19:51.819]             length <- base::length
[10:19:51.819]             list <- base::list
[10:19:51.819]             seq.int <- base::seq.int
[10:19:51.819]             signalCondition <- base::signalCondition
[10:19:51.819]             sys.calls <- base::sys.calls
[10:19:51.819]             `[[` <- base::`[[`
[10:19:51.819]             `+` <- base::`+`
[10:19:51.819]             `<<-` <- base::`<<-`
[10:19:51.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.819]                   3L)]
[10:19:51.819]             }
[10:19:51.819]             function(cond) {
[10:19:51.819]                 is_error <- inherits(cond, "error")
[10:19:51.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.819]                   NULL)
[10:19:51.819]                 if (is_error) {
[10:19:51.819]                   sessionInformation <- function() {
[10:19:51.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.819]                       search = base::search(), system = base::Sys.info())
[10:19:51.819]                   }
[10:19:51.819]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.819]                     cond$call), session = sessionInformation(), 
[10:19:51.819]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.819]                   signalCondition(cond)
[10:19:51.819]                 }
[10:19:51.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.819]                 "immediateCondition"))) {
[10:19:51.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.819]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.819]                   if (TRUE && !signal) {
[10:19:51.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.819]                     {
[10:19:51.819]                       inherits <- base::inherits
[10:19:51.819]                       invokeRestart <- base::invokeRestart
[10:19:51.819]                       is.null <- base::is.null
[10:19:51.819]                       muffled <- FALSE
[10:19:51.819]                       if (inherits(cond, "message")) {
[10:19:51.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.819]                         if (muffled) 
[10:19:51.819]                           invokeRestart("muffleMessage")
[10:19:51.819]                       }
[10:19:51.819]                       else if (inherits(cond, "warning")) {
[10:19:51.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.819]                         if (muffled) 
[10:19:51.819]                           invokeRestart("muffleWarning")
[10:19:51.819]                       }
[10:19:51.819]                       else if (inherits(cond, "condition")) {
[10:19:51.819]                         if (!is.null(pattern)) {
[10:19:51.819]                           computeRestarts <- base::computeRestarts
[10:19:51.819]                           grepl <- base::grepl
[10:19:51.819]                           restarts <- computeRestarts(cond)
[10:19:51.819]                           for (restart in restarts) {
[10:19:51.819]                             name <- restart$name
[10:19:51.819]                             if (is.null(name)) 
[10:19:51.819]                               next
[10:19:51.819]                             if (!grepl(pattern, name)) 
[10:19:51.819]                               next
[10:19:51.819]                             invokeRestart(restart)
[10:19:51.819]                             muffled <- TRUE
[10:19:51.819]                             break
[10:19:51.819]                           }
[10:19:51.819]                         }
[10:19:51.819]                       }
[10:19:51.819]                       invisible(muffled)
[10:19:51.819]                     }
[10:19:51.819]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.819]                   }
[10:19:51.819]                 }
[10:19:51.819]                 else {
[10:19:51.819]                   if (TRUE) {
[10:19:51.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.819]                     {
[10:19:51.819]                       inherits <- base::inherits
[10:19:51.819]                       invokeRestart <- base::invokeRestart
[10:19:51.819]                       is.null <- base::is.null
[10:19:51.819]                       muffled <- FALSE
[10:19:51.819]                       if (inherits(cond, "message")) {
[10:19:51.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.819]                         if (muffled) 
[10:19:51.819]                           invokeRestart("muffleMessage")
[10:19:51.819]                       }
[10:19:51.819]                       else if (inherits(cond, "warning")) {
[10:19:51.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.819]                         if (muffled) 
[10:19:51.819]                           invokeRestart("muffleWarning")
[10:19:51.819]                       }
[10:19:51.819]                       else if (inherits(cond, "condition")) {
[10:19:51.819]                         if (!is.null(pattern)) {
[10:19:51.819]                           computeRestarts <- base::computeRestarts
[10:19:51.819]                           grepl <- base::grepl
[10:19:51.819]                           restarts <- computeRestarts(cond)
[10:19:51.819]                           for (restart in restarts) {
[10:19:51.819]                             name <- restart$name
[10:19:51.819]                             if (is.null(name)) 
[10:19:51.819]                               next
[10:19:51.819]                             if (!grepl(pattern, name)) 
[10:19:51.819]                               next
[10:19:51.819]                             invokeRestart(restart)
[10:19:51.819]                             muffled <- TRUE
[10:19:51.819]                             break
[10:19:51.819]                           }
[10:19:51.819]                         }
[10:19:51.819]                       }
[10:19:51.819]                       invisible(muffled)
[10:19:51.819]                     }
[10:19:51.819]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.819]                   }
[10:19:51.819]                 }
[10:19:51.819]             }
[10:19:51.819]         }))
[10:19:51.819]     }, error = function(ex) {
[10:19:51.819]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.819]                 ...future.rng), started = ...future.startTime, 
[10:19:51.819]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.819]             version = "1.8"), class = "FutureResult")
[10:19:51.819]     }, finally = {
[10:19:51.819]         if (!identical(...future.workdir, getwd())) 
[10:19:51.819]             setwd(...future.workdir)
[10:19:51.819]         {
[10:19:51.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.819]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.819]             }
[10:19:51.819]             base::options(...future.oldOptions)
[10:19:51.819]             if (.Platform$OS.type == "windows") {
[10:19:51.819]                 old_names <- names(...future.oldEnvVars)
[10:19:51.819]                 envs <- base::Sys.getenv()
[10:19:51.819]                 names <- names(envs)
[10:19:51.819]                 common <- intersect(names, old_names)
[10:19:51.819]                 added <- setdiff(names, old_names)
[10:19:51.819]                 removed <- setdiff(old_names, names)
[10:19:51.819]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.819]                   envs[common]]
[10:19:51.819]                 NAMES <- toupper(changed)
[10:19:51.819]                 args <- list()
[10:19:51.819]                 for (kk in seq_along(NAMES)) {
[10:19:51.819]                   name <- changed[[kk]]
[10:19:51.819]                   NAME <- NAMES[[kk]]
[10:19:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.819]                     next
[10:19:51.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.819]                 }
[10:19:51.819]                 NAMES <- toupper(added)
[10:19:51.819]                 for (kk in seq_along(NAMES)) {
[10:19:51.819]                   name <- added[[kk]]
[10:19:51.819]                   NAME <- NAMES[[kk]]
[10:19:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.819]                     next
[10:19:51.819]                   args[[name]] <- ""
[10:19:51.819]                 }
[10:19:51.819]                 NAMES <- toupper(removed)
[10:19:51.819]                 for (kk in seq_along(NAMES)) {
[10:19:51.819]                   name <- removed[[kk]]
[10:19:51.819]                   NAME <- NAMES[[kk]]
[10:19:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.819]                     next
[10:19:51.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.819]                 }
[10:19:51.819]                 if (length(args) > 0) 
[10:19:51.819]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.819]             }
[10:19:51.819]             else {
[10:19:51.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.819]             }
[10:19:51.819]             {
[10:19:51.819]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.819]                   0L) {
[10:19:51.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.819]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.819]                   base::options(opts)
[10:19:51.819]                 }
[10:19:51.819]                 {
[10:19:51.819]                   {
[10:19:51.819]                     NULL
[10:19:51.819]                     RNGkind("Mersenne-Twister")
[10:19:51.819]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:19:51.819]                       inherits = FALSE)
[10:19:51.819]                   }
[10:19:51.819]                   options(future.plan = NULL)
[10:19:51.819]                   if (is.na(NA_character_)) 
[10:19:51.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.819]                     .init = FALSE)
[10:19:51.819]                 }
[10:19:51.819]             }
[10:19:51.819]         }
[10:19:51.819]     })
[10:19:51.819]     if (TRUE) {
[10:19:51.819]         base::sink(type = "output", split = FALSE)
[10:19:51.819]         if (TRUE) {
[10:19:51.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.819]         }
[10:19:51.819]         else {
[10:19:51.819]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.819]         }
[10:19:51.819]         base::close(...future.stdout)
[10:19:51.819]         ...future.stdout <- NULL
[10:19:51.819]     }
[10:19:51.819]     ...future.result$conditions <- ...future.conditions
[10:19:51.819]     ...future.result$finished <- base::Sys.time()
[10:19:51.819]     ...future.result
[10:19:51.819] }
[10:19:51.821] assign_globals() ...
[10:19:51.821] List of 11
[10:19:51.821]  $ ...future.FUN            :function (x, ...)  
[10:19:51.821]  $ x_FUN                    :function (x)  
[10:19:51.821]  $ times                    : int 2
[10:19:51.821]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.821]  $ stop_if_not              :function (...)  
[10:19:51.821]  $ dim                      : NULL
[10:19:51.821]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:51.821]  $ future.call.arguments    : list()
[10:19:51.821]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.821]  $ ...future.elements_ii    :List of 3
[10:19:51.821]   ..$ : int 1
[10:19:51.821]   ..$ : int 2
[10:19:51.821]   ..$ : int 3
[10:19:51.821]  $ ...future.seeds_ii       : NULL
[10:19:51.821]  $ ...future.globals.maxSize: NULL
[10:19:51.821]  - attr(*, "where")=List of 11
[10:19:51.821]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.821]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.821]  - attr(*, "resolved")= logi FALSE
[10:19:51.821]  - attr(*, "total_size")= num 23676
[10:19:51.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.821]  - attr(*, "already-done")= logi TRUE
[10:19:51.828] - copied ‘...future.FUN’ to environment
[10:19:51.828] - copied ‘x_FUN’ to environment
[10:19:51.829] - copied ‘times’ to environment
[10:19:51.829] - copied ‘stopf’ to environment
[10:19:51.829] - copied ‘stop_if_not’ to environment
[10:19:51.829] - copied ‘dim’ to environment
[10:19:51.829] - copied ‘valid_types’ to environment
[10:19:51.829] - copied ‘future.call.arguments’ to environment
[10:19:51.829] - copied ‘...future.elements_ii’ to environment
[10:19:51.829] - copied ‘...future.seeds_ii’ to environment
[10:19:51.829] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.829] assign_globals() ... done
[10:19:51.830] plan(): Setting new future strategy stack:
[10:19:51.830] List of future strategies:
[10:19:51.830] 1. sequential:
[10:19:51.830]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.830]    - tweaked: FALSE
[10:19:51.830]    - call: NULL
[10:19:51.830] plan(): nbrOfWorkers() = 1
[10:19:51.831] plan(): Setting new future strategy stack:
[10:19:51.831] List of future strategies:
[10:19:51.831] 1. sequential:
[10:19:51.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.831]    - tweaked: FALSE
[10:19:51.831]    - call: plan(strategy)
[10:19:51.831] plan(): nbrOfWorkers() = 1
[10:19:51.832] SequentialFuture started (and completed)
[10:19:51.832] signalConditions() ...
[10:19:51.832]  - include = ‘immediateCondition’
[10:19:51.832]  - exclude = 
[10:19:51.832]  - resignal = FALSE
[10:19:51.832]  - Number of conditions: 1
[10:19:51.832] signalConditions() ... done
[10:19:51.832] - Launch lazy future ... done
[10:19:51.832] run() for ‘SequentialFuture’ ... done
[10:19:51.832] Created future:
[10:19:51.832] SequentialFuture:
[10:19:51.832] Label: ‘future_vapply-1’
[10:19:51.832] Expression:
[10:19:51.832] {
[10:19:51.832]     do.call(function(...) {
[10:19:51.832]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.832]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.832]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.832]             on.exit(options(oopts), add = TRUE)
[10:19:51.832]         }
[10:19:51.832]         {
[10:19:51.832]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.832]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.832]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.832]             })
[10:19:51.832]         }
[10:19:51.832]     }, args = future.call.arguments)
[10:19:51.832] }
[10:19:51.832] Lazy evaluation: FALSE
[10:19:51.832] Asynchronous evaluation: FALSE
[10:19:51.832] Local evaluation: TRUE
[10:19:51.832] Environment: R_GlobalEnv
[10:19:51.832] Capture standard output: TRUE
[10:19:51.832] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.832] Globals: 11 objects totaling 13.02 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.832] Packages: 1 packages (‘future.apply’)
[10:19:51.832] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.832] Resolved: TRUE
[10:19:51.832] Value: 27 bytes of class ‘NULL’
[10:19:51.832] Conditions captured: [n=1] ‘simpleError’
[10:19:51.832] Early signaling: FALSE
[10:19:51.832] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.832] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:51.833] Chunk #1 of 1 ... DONE
[10:19:51.833] Launching 1 futures (chunks) ... DONE
[10:19:51.833] Resolving 1 futures (chunks) ...
[10:19:51.834] resolve() on list ...
[10:19:51.834]  recursive: 0
[10:19:51.834]  length: 1
[10:19:51.834] 
[10:19:51.834] resolved() for ‘SequentialFuture’ ...
[10:19:51.834] - state: ‘finished’
[10:19:51.834] - run: TRUE
[10:19:51.834] - result: ‘FutureResult’
[10:19:51.834] resolved() for ‘SequentialFuture’ ... done
[10:19:51.834] Future #1
[10:19:51.834] signalConditions() ...
[10:19:51.834]  - include = ‘immediateCondition’
[10:19:51.836]  - exclude = 
[10:19:51.836]  - resignal = FALSE
[10:19:51.836]  - Number of conditions: 1
[10:19:51.836] signalConditions() ... done
[10:19:51.836] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:51.836] - nx: 1
[10:19:51.836] - relay: TRUE
[10:19:51.836] - stdout: TRUE
[10:19:51.836] - signal: TRUE
[10:19:51.836] - resignal: FALSE
[10:19:51.836] - force: TRUE
[10:19:51.836] - relayed: [n=1] FALSE
[10:19:51.837] - queued futures: [n=1] FALSE
[10:19:51.837]  - until=1
[10:19:51.837]  - relaying element #1
[10:19:51.837] signalConditions() ...
[10:19:51.837]  - include = ‘immediateCondition’
[10:19:51.837]  - exclude = 
[10:19:51.837]  - resignal = FALSE
[10:19:51.837]  - Number of conditions: 1
[10:19:51.837] signalConditions() ... done
[10:19:51.837] signalConditions() ...
[10:19:51.837]  - include = ‘immediateCondition’
[10:19:51.838]  - exclude = 
[10:19:51.838]  - resignal = FALSE
[10:19:51.838]  - Number of conditions: 1
[10:19:51.838] signalConditions() ... done
[10:19:51.838] signalConditions() ...
[10:19:51.838]  - include = ‘condition’
[10:19:51.838]  - exclude = ‘immediateCondition’
[10:19:51.838]  - resignal = TRUE
[10:19:51.838]  - Number of conditions: 1
[10:19:51.838]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:19:51.838] signalConditions() ... done
[10:19:51.838] - relayed: [n=1] FALSE
[10:19:51.838] - queued futures: [n=1] TRUE
[10:19:51.839] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:51.839] plan(): Setting new future strategy stack:
[10:19:51.839] List of future strategies:
[10:19:51.839] 1. sequential:
[10:19:51.839]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.839]    - tweaked: FALSE
[10:19:51.839]    - call: plan(sequential)
[10:19:51.839] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:19:51.840] plan(): Setting new future strategy stack:
[10:19:51.840] List of future strategies:
[10:19:51.840] 1. multicore:
[10:19:51.840]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:51.840]    - tweaked: FALSE
[10:19:51.840]    - call: plan(strategy)
[10:19:51.841] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:19:51.843] future_lapply() ...
[10:19:51.847] Number of chunks: 2
[10:19:51.847] getGlobalsAndPackagesXApply() ...
[10:19:51.847]  - future.globals: TRUE
[10:19:51.847] getGlobalsAndPackages() ...
[10:19:51.847] Searching for globals...
[10:19:51.850] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:51.850] Searching for globals ... DONE
[10:19:51.850] Resolving globals: FALSE
[10:19:51.851] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[10:19:51.851] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.851] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.851] - packages: [1] ‘future.apply’
[10:19:51.851] getGlobalsAndPackages() ... DONE
[10:19:51.851]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.851]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.852] Finding globals ... DONE
[10:19:51.852]  - use_args: TRUE
[10:19:51.852]  - Getting '...' globals ...
[10:19:51.852] resolve() on list ...
[10:19:51.852]  recursive: 0
[10:19:51.852]  length: 1
[10:19:51.852]  elements: ‘...’
[10:19:51.852]  length: 0 (resolved future 1)
[10:19:51.852] resolve() on list ... DONE
[10:19:51.852]    - '...' content: [n=0] 
[10:19:51.853] List of 1
[10:19:51.853]  $ ...: list()
[10:19:51.853]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.853]  - attr(*, "where")=List of 1
[10:19:51.853]   ..$ ...:<environment: 0x55c69f2e90e0> 
[10:19:51.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.853]  - attr(*, "resolved")= logi TRUE
[10:19:51.853]  - attr(*, "total_size")= num NA
[10:19:51.855]  - Getting '...' globals ... DONE
[10:19:51.856] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.856] List of 8
[10:19:51.856]  $ ...future.FUN:function (x, ...)  
[10:19:51.856]  $ x_FUN        :function (x)  
[10:19:51.856]  $ times        : int 1
[10:19:51.856]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.856]  $ stop_if_not  :function (...)  
[10:19:51.856]  $ dim          : NULL
[10:19:51.856]  $ valid_types  : chr "character"
[10:19:51.856]  $ ...          : list()
[10:19:51.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.856]  - attr(*, "where")=List of 8
[10:19:51.856]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.856]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.856]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.856]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.856]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.856]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.856]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.856]   ..$ ...          :<environment: 0x55c69f2e90e0> 
[10:19:51.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.856]  - attr(*, "resolved")= logi FALSE
[10:19:51.856]  - attr(*, "total_size")= num 22333
[10:19:51.861] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.861] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.861] Number of futures (= number of chunks): 2
[10:19:51.861] Launching 2 futures (chunks) ...
[10:19:51.862] Chunk #1 of 2 ...
[10:19:51.862]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.862] getGlobalsAndPackages() ...
[10:19:51.862] Searching for globals...
[10:19:51.862] 
[10:19:51.862] Searching for globals ... DONE
[10:19:51.862] - globals: [0] <none>
[10:19:51.862] getGlobalsAndPackages() ... DONE
[10:19:51.862]    + additional globals found: [n=0] 
[10:19:51.863]    + additional namespaces needed: [n=0] 
[10:19:51.863]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.863]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:51.863]  - seeds: <none>
[10:19:51.863]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.863] getGlobalsAndPackages() ...
[10:19:51.863] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.863] Resolving globals: FALSE
[10:19:51.863] Tweak future expression to call with '...' arguments ...
[10:19:51.863] {
[10:19:51.863]     do.call(function(...) {
[10:19:51.863]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.863]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.863]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.863]             on.exit(options(oopts), add = TRUE)
[10:19:51.863]         }
[10:19:51.863]         {
[10:19:51.863]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.863]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.863]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.863]             })
[10:19:51.863]         }
[10:19:51.863]     }, args = future.call.arguments)
[10:19:51.863] }
[10:19:51.864] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.864] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.864] - packages: [1] ‘future.apply’
[10:19:51.864] getGlobalsAndPackages() ... DONE
[10:19:51.864] run() for ‘Future’ ...
[10:19:51.865] - state: ‘created’
[10:19:51.865] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:51.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:51.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:51.866]   - Field: ‘label’
[10:19:51.867]   - Field: ‘local’
[10:19:51.867]   - Field: ‘owner’
[10:19:51.867]   - Field: ‘envir’
[10:19:51.867]   - Field: ‘workers’
[10:19:51.867]   - Field: ‘packages’
[10:19:51.867]   - Field: ‘gc’
[10:19:51.867]   - Field: ‘job’
[10:19:51.867]   - Field: ‘conditions’
[10:19:51.867]   - Field: ‘expr’
[10:19:51.867]   - Field: ‘uuid’
[10:19:51.867]   - Field: ‘seed’
[10:19:51.867]   - Field: ‘version’
[10:19:51.867]   - Field: ‘result’
[10:19:51.868]   - Field: ‘asynchronous’
[10:19:51.868]   - Field: ‘calls’
[10:19:51.868]   - Field: ‘globals’
[10:19:51.868]   - Field: ‘stdout’
[10:19:51.868]   - Field: ‘earlySignal’
[10:19:51.868]   - Field: ‘lazy’
[10:19:51.868]   - Field: ‘state’
[10:19:51.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:51.868] - Launch lazy future ...
[10:19:51.869] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.869] Packages needed by future strategies (n = 0): <none>
[10:19:51.870] {
[10:19:51.870]     {
[10:19:51.870]         {
[10:19:51.870]             ...future.startTime <- base::Sys.time()
[10:19:51.870]             {
[10:19:51.870]                 {
[10:19:51.870]                   {
[10:19:51.870]                     {
[10:19:51.870]                       {
[10:19:51.870]                         base::local({
[10:19:51.870]                           has_future <- base::requireNamespace("future", 
[10:19:51.870]                             quietly = TRUE)
[10:19:51.870]                           if (has_future) {
[10:19:51.870]                             ns <- base::getNamespace("future")
[10:19:51.870]                             version <- ns[[".package"]][["version"]]
[10:19:51.870]                             if (is.null(version)) 
[10:19:51.870]                               version <- utils::packageVersion("future")
[10:19:51.870]                           }
[10:19:51.870]                           else {
[10:19:51.870]                             version <- NULL
[10:19:51.870]                           }
[10:19:51.870]                           if (!has_future || version < "1.8.0") {
[10:19:51.870]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.870]                               "", base::R.version$version.string), 
[10:19:51.870]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:51.870]                                 base::R.version$platform, 8 * 
[10:19:51.870]                                   base::.Machine$sizeof.pointer), 
[10:19:51.870]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.870]                                 "release", "version")], collapse = " "), 
[10:19:51.870]                               hostname = base::Sys.info()[["nodename"]])
[10:19:51.870]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.870]                               info)
[10:19:51.870]                             info <- base::paste(info, collapse = "; ")
[10:19:51.870]                             if (!has_future) {
[10:19:51.870]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.870]                                 info)
[10:19:51.870]                             }
[10:19:51.870]                             else {
[10:19:51.870]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.870]                                 info, version)
[10:19:51.870]                             }
[10:19:51.870]                             base::stop(msg)
[10:19:51.870]                           }
[10:19:51.870]                         })
[10:19:51.870]                       }
[10:19:51.870]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:51.870]                       base::options(mc.cores = 1L)
[10:19:51.870]                     }
[10:19:51.870]                     base::local({
[10:19:51.870]                       for (pkg in "future.apply") {
[10:19:51.870]                         base::loadNamespace(pkg)
[10:19:51.870]                         base::library(pkg, character.only = TRUE)
[10:19:51.870]                       }
[10:19:51.870]                     })
[10:19:51.870]                   }
[10:19:51.870]                   ...future.strategy.old <- future::plan("list")
[10:19:51.870]                   options(future.plan = NULL)
[10:19:51.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.870]                 }
[10:19:51.870]                 ...future.workdir <- getwd()
[10:19:51.870]             }
[10:19:51.870]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.870]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.870]         }
[10:19:51.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.870]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:51.870]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.870]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.870]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.870]             base::names(...future.oldOptions))
[10:19:51.870]     }
[10:19:51.870]     if (FALSE) {
[10:19:51.870]     }
[10:19:51.870]     else {
[10:19:51.870]         if (TRUE) {
[10:19:51.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.870]                 open = "w")
[10:19:51.870]         }
[10:19:51.870]         else {
[10:19:51.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.870]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.870]         }
[10:19:51.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.870]             base::sink(type = "output", split = FALSE)
[10:19:51.870]             base::close(...future.stdout)
[10:19:51.870]         }, add = TRUE)
[10:19:51.870]     }
[10:19:51.870]     ...future.frame <- base::sys.nframe()
[10:19:51.870]     ...future.conditions <- base::list()
[10:19:51.870]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.870]     if (FALSE) {
[10:19:51.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.870]     }
[10:19:51.870]     ...future.result <- base::tryCatch({
[10:19:51.870]         base::withCallingHandlers({
[10:19:51.870]             ...future.value <- base::withVisible(base::local({
[10:19:51.870]                 withCallingHandlers({
[10:19:51.870]                   {
[10:19:51.870]                     do.call(function(...) {
[10:19:51.870]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.870]                       if (!identical(...future.globals.maxSize.org, 
[10:19:51.870]                         ...future.globals.maxSize)) {
[10:19:51.870]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.870]                         on.exit(options(oopts), add = TRUE)
[10:19:51.870]                       }
[10:19:51.870]                       {
[10:19:51.870]                         lapply(seq_along(...future.elements_ii), 
[10:19:51.870]                           FUN = function(jj) {
[10:19:51.870]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.870]                             ...future.FUN(...future.X_jj, ...)
[10:19:51.870]                           })
[10:19:51.870]                       }
[10:19:51.870]                     }, args = future.call.arguments)
[10:19:51.870]                   }
[10:19:51.870]                 }, immediateCondition = function(cond) {
[10:19:51.870]                   save_rds <- function (object, pathname, ...) 
[10:19:51.870]                   {
[10:19:51.870]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:51.870]                     if (file_test("-f", pathname_tmp)) {
[10:19:51.870]                       fi_tmp <- file.info(pathname_tmp)
[10:19:51.870]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:51.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:51.870]                         fi_tmp[["mtime"]])
[10:19:51.870]                     }
[10:19:51.870]                     tryCatch({
[10:19:51.870]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:51.870]                     }, error = function(ex) {
[10:19:51.870]                       msg <- conditionMessage(ex)
[10:19:51.870]                       fi_tmp <- file.info(pathname_tmp)
[10:19:51.870]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:51.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:51.870]                         fi_tmp[["mtime"]], msg)
[10:19:51.870]                       ex$message <- msg
[10:19:51.870]                       stop(ex)
[10:19:51.870]                     })
[10:19:51.870]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:51.870]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:51.870]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:51.870]                       fi_tmp <- file.info(pathname_tmp)
[10:19:51.870]                       fi <- file.info(pathname)
[10:19:51.870]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:51.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:51.870]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:51.870]                         fi[["size"]], fi[["mtime"]])
[10:19:51.870]                       stop(msg)
[10:19:51.870]                     }
[10:19:51.870]                     invisible(pathname)
[10:19:51.870]                   }
[10:19:51.870]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:51.870]                     rootPath = tempdir()) 
[10:19:51.870]                   {
[10:19:51.870]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:51.870]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:51.870]                       tmpdir = path, fileext = ".rds")
[10:19:51.870]                     save_rds(obj, file)
[10:19:51.870]                   }
[10:19:51.870]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:51.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.870]                   {
[10:19:51.870]                     inherits <- base::inherits
[10:19:51.870]                     invokeRestart <- base::invokeRestart
[10:19:51.870]                     is.null <- base::is.null
[10:19:51.870]                     muffled <- FALSE
[10:19:51.870]                     if (inherits(cond, "message")) {
[10:19:51.870]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:51.870]                       if (muffled) 
[10:19:51.870]                         invokeRestart("muffleMessage")
[10:19:51.870]                     }
[10:19:51.870]                     else if (inherits(cond, "warning")) {
[10:19:51.870]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:51.870]                       if (muffled) 
[10:19:51.870]                         invokeRestart("muffleWarning")
[10:19:51.870]                     }
[10:19:51.870]                     else if (inherits(cond, "condition")) {
[10:19:51.870]                       if (!is.null(pattern)) {
[10:19:51.870]                         computeRestarts <- base::computeRestarts
[10:19:51.870]                         grepl <- base::grepl
[10:19:51.870]                         restarts <- computeRestarts(cond)
[10:19:51.870]                         for (restart in restarts) {
[10:19:51.870]                           name <- restart$name
[10:19:51.870]                           if (is.null(name)) 
[10:19:51.870]                             next
[10:19:51.870]                           if (!grepl(pattern, name)) 
[10:19:51.870]                             next
[10:19:51.870]                           invokeRestart(restart)
[10:19:51.870]                           muffled <- TRUE
[10:19:51.870]                           break
[10:19:51.870]                         }
[10:19:51.870]                       }
[10:19:51.870]                     }
[10:19:51.870]                     invisible(muffled)
[10:19:51.870]                   }
[10:19:51.870]                   muffleCondition(cond)
[10:19:51.870]                 })
[10:19:51.870]             }))
[10:19:51.870]             future::FutureResult(value = ...future.value$value, 
[10:19:51.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.870]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.870]                     ...future.globalenv.names))
[10:19:51.870]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.870]         }, condition = base::local({
[10:19:51.870]             c <- base::c
[10:19:51.870]             inherits <- base::inherits
[10:19:51.870]             invokeRestart <- base::invokeRestart
[10:19:51.870]             length <- base::length
[10:19:51.870]             list <- base::list
[10:19:51.870]             seq.int <- base::seq.int
[10:19:51.870]             signalCondition <- base::signalCondition
[10:19:51.870]             sys.calls <- base::sys.calls
[10:19:51.870]             `[[` <- base::`[[`
[10:19:51.870]             `+` <- base::`+`
[10:19:51.870]             `<<-` <- base::`<<-`
[10:19:51.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.870]                   3L)]
[10:19:51.870]             }
[10:19:51.870]             function(cond) {
[10:19:51.870]                 is_error <- inherits(cond, "error")
[10:19:51.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.870]                   NULL)
[10:19:51.870]                 if (is_error) {
[10:19:51.870]                   sessionInformation <- function() {
[10:19:51.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.870]                       search = base::search(), system = base::Sys.info())
[10:19:51.870]                   }
[10:19:51.870]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.870]                     cond$call), session = sessionInformation(), 
[10:19:51.870]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.870]                   signalCondition(cond)
[10:19:51.870]                 }
[10:19:51.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.870]                 "immediateCondition"))) {
[10:19:51.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.870]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.870]                   if (TRUE && !signal) {
[10:19:51.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.870]                     {
[10:19:51.870]                       inherits <- base::inherits
[10:19:51.870]                       invokeRestart <- base::invokeRestart
[10:19:51.870]                       is.null <- base::is.null
[10:19:51.870]                       muffled <- FALSE
[10:19:51.870]                       if (inherits(cond, "message")) {
[10:19:51.870]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.870]                         if (muffled) 
[10:19:51.870]                           invokeRestart("muffleMessage")
[10:19:51.870]                       }
[10:19:51.870]                       else if (inherits(cond, "warning")) {
[10:19:51.870]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.870]                         if (muffled) 
[10:19:51.870]                           invokeRestart("muffleWarning")
[10:19:51.870]                       }
[10:19:51.870]                       else if (inherits(cond, "condition")) {
[10:19:51.870]                         if (!is.null(pattern)) {
[10:19:51.870]                           computeRestarts <- base::computeRestarts
[10:19:51.870]                           grepl <- base::grepl
[10:19:51.870]                           restarts <- computeRestarts(cond)
[10:19:51.870]                           for (restart in restarts) {
[10:19:51.870]                             name <- restart$name
[10:19:51.870]                             if (is.null(name)) 
[10:19:51.870]                               next
[10:19:51.870]                             if (!grepl(pattern, name)) 
[10:19:51.870]                               next
[10:19:51.870]                             invokeRestart(restart)
[10:19:51.870]                             muffled <- TRUE
[10:19:51.870]                             break
[10:19:51.870]                           }
[10:19:51.870]                         }
[10:19:51.870]                       }
[10:19:51.870]                       invisible(muffled)
[10:19:51.870]                     }
[10:19:51.870]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.870]                   }
[10:19:51.870]                 }
[10:19:51.870]                 else {
[10:19:51.870]                   if (TRUE) {
[10:19:51.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.870]                     {
[10:19:51.870]                       inherits <- base::inherits
[10:19:51.870]                       invokeRestart <- base::invokeRestart
[10:19:51.870]                       is.null <- base::is.null
[10:19:51.870]                       muffled <- FALSE
[10:19:51.870]                       if (inherits(cond, "message")) {
[10:19:51.870]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.870]                         if (muffled) 
[10:19:51.870]                           invokeRestart("muffleMessage")
[10:19:51.870]                       }
[10:19:51.870]                       else if (inherits(cond, "warning")) {
[10:19:51.870]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.870]                         if (muffled) 
[10:19:51.870]                           invokeRestart("muffleWarning")
[10:19:51.870]                       }
[10:19:51.870]                       else if (inherits(cond, "condition")) {
[10:19:51.870]                         if (!is.null(pattern)) {
[10:19:51.870]                           computeRestarts <- base::computeRestarts
[10:19:51.870]                           grepl <- base::grepl
[10:19:51.870]                           restarts <- computeRestarts(cond)
[10:19:51.870]                           for (restart in restarts) {
[10:19:51.870]                             name <- restart$name
[10:19:51.870]                             if (is.null(name)) 
[10:19:51.870]                               next
[10:19:51.870]                             if (!grepl(pattern, name)) 
[10:19:51.870]                               next
[10:19:51.870]                             invokeRestart(restart)
[10:19:51.870]                             muffled <- TRUE
[10:19:51.870]                             break
[10:19:51.870]                           }
[10:19:51.870]                         }
[10:19:51.870]                       }
[10:19:51.870]                       invisible(muffled)
[10:19:51.870]                     }
[10:19:51.870]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.870]                   }
[10:19:51.870]                 }
[10:19:51.870]             }
[10:19:51.870]         }))
[10:19:51.870]     }, error = function(ex) {
[10:19:51.870]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.870]                 ...future.rng), started = ...future.startTime, 
[10:19:51.870]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.870]             version = "1.8"), class = "FutureResult")
[10:19:51.870]     }, finally = {
[10:19:51.870]         if (!identical(...future.workdir, getwd())) 
[10:19:51.870]             setwd(...future.workdir)
[10:19:51.870]         {
[10:19:51.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.870]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.870]             }
[10:19:51.870]             base::options(...future.oldOptions)
[10:19:51.870]             if (.Platform$OS.type == "windows") {
[10:19:51.870]                 old_names <- names(...future.oldEnvVars)
[10:19:51.870]                 envs <- base::Sys.getenv()
[10:19:51.870]                 names <- names(envs)
[10:19:51.870]                 common <- intersect(names, old_names)
[10:19:51.870]                 added <- setdiff(names, old_names)
[10:19:51.870]                 removed <- setdiff(old_names, names)
[10:19:51.870]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.870]                   envs[common]]
[10:19:51.870]                 NAMES <- toupper(changed)
[10:19:51.870]                 args <- list()
[10:19:51.870]                 for (kk in seq_along(NAMES)) {
[10:19:51.870]                   name <- changed[[kk]]
[10:19:51.870]                   NAME <- NAMES[[kk]]
[10:19:51.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.870]                     next
[10:19:51.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.870]                 }
[10:19:51.870]                 NAMES <- toupper(added)
[10:19:51.870]                 for (kk in seq_along(NAMES)) {
[10:19:51.870]                   name <- added[[kk]]
[10:19:51.870]                   NAME <- NAMES[[kk]]
[10:19:51.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.870]                     next
[10:19:51.870]                   args[[name]] <- ""
[10:19:51.870]                 }
[10:19:51.870]                 NAMES <- toupper(removed)
[10:19:51.870]                 for (kk in seq_along(NAMES)) {
[10:19:51.870]                   name <- removed[[kk]]
[10:19:51.870]                   NAME <- NAMES[[kk]]
[10:19:51.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.870]                     next
[10:19:51.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.870]                 }
[10:19:51.870]                 if (length(args) > 0) 
[10:19:51.870]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.870]             }
[10:19:51.870]             else {
[10:19:51.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.870]             }
[10:19:51.870]             {
[10:19:51.870]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.870]                   0L) {
[10:19:51.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.870]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.870]                   base::options(opts)
[10:19:51.870]                 }
[10:19:51.870]                 {
[10:19:51.870]                   {
[10:19:51.870]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:51.870]                     NULL
[10:19:51.870]                   }
[10:19:51.870]                   options(future.plan = NULL)
[10:19:51.870]                   if (is.na(NA_character_)) 
[10:19:51.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.870]                     .init = FALSE)
[10:19:51.870]                 }
[10:19:51.870]             }
[10:19:51.870]         }
[10:19:51.870]     })
[10:19:51.870]     if (TRUE) {
[10:19:51.870]         base::sink(type = "output", split = FALSE)
[10:19:51.870]         if (TRUE) {
[10:19:51.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.870]         }
[10:19:51.870]         else {
[10:19:51.870]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.870]         }
[10:19:51.870]         base::close(...future.stdout)
[10:19:51.870]         ...future.stdout <- NULL
[10:19:51.870]     }
[10:19:51.870]     ...future.result$conditions <- ...future.conditions
[10:19:51.870]     ...future.result$finished <- base::Sys.time()
[10:19:51.870]     ...future.result
[10:19:51.870] }
[10:19:51.872] assign_globals() ...
[10:19:51.872] List of 11
[10:19:51.872]  $ ...future.FUN            :function (x, ...)  
[10:19:51.872]  $ x_FUN                    :function (x)  
[10:19:51.872]  $ times                    : int 1
[10:19:51.872]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.872]  $ stop_if_not              :function (...)  
[10:19:51.872]  $ dim                      : NULL
[10:19:51.872]  $ valid_types              : chr "character"
[10:19:51.872]  $ future.call.arguments    : list()
[10:19:51.872]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.872]  $ ...future.elements_ii    :List of 1
[10:19:51.872]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:19:51.872]  $ ...future.seeds_ii       : NULL
[10:19:51.872]  $ ...future.globals.maxSize: NULL
[10:19:51.872]  - attr(*, "where")=List of 11
[10:19:51.872]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.872]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.872]  - attr(*, "resolved")= logi FALSE
[10:19:51.872]  - attr(*, "total_size")= num 22333
[10:19:51.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.872]  - attr(*, "already-done")= logi TRUE
[10:19:51.880] - copied ‘...future.FUN’ to environment
[10:19:51.880] - copied ‘x_FUN’ to environment
[10:19:51.880] - copied ‘times’ to environment
[10:19:51.880] - copied ‘stopf’ to environment
[10:19:51.880] - copied ‘stop_if_not’ to environment
[10:19:51.881] - copied ‘dim’ to environment
[10:19:51.881] - copied ‘valid_types’ to environment
[10:19:51.881] - copied ‘future.call.arguments’ to environment
[10:19:51.881] - copied ‘...future.elements_ii’ to environment
[10:19:51.881] - copied ‘...future.seeds_ii’ to environment
[10:19:51.881] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.881] assign_globals() ... done
[10:19:51.881] requestCore(): workers = 2
[10:19:51.884] MulticoreFuture started
[10:19:51.885] - Launch lazy future ... done
[10:19:51.885] run() for ‘MulticoreFuture’ ... done
[10:19:51.885] plan(): Setting new future strategy stack:
[10:19:51.886] Created future:
[10:19:51.886] List of future strategies:
[10:19:51.886] 1. sequential:
[10:19:51.886]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.886]    - tweaked: FALSE
[10:19:51.886]    - call: NULL
[10:19:51.887] plan(): nbrOfWorkers() = 1
[10:19:51.889] plan(): Setting new future strategy stack:
[10:19:51.889] List of future strategies:
[10:19:51.889] 1. multicore:
[10:19:51.889]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:51.889]    - tweaked: FALSE
[10:19:51.889]    - call: plan(strategy)
[10:19:51.893] plan(): nbrOfWorkers() = 2
[10:19:51.886] MulticoreFuture:
[10:19:51.886] Label: ‘future_vapply-1’
[10:19:51.886] Expression:
[10:19:51.886] {
[10:19:51.886]     do.call(function(...) {
[10:19:51.886]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.886]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.886]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.886]             on.exit(options(oopts), add = TRUE)
[10:19:51.886]         }
[10:19:51.886]         {
[10:19:51.886]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.886]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.886]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.886]             })
[10:19:51.886]         }
[10:19:51.886]     }, args = future.call.arguments)
[10:19:51.886] }
[10:19:51.886] Lazy evaluation: FALSE
[10:19:51.886] Asynchronous evaluation: TRUE
[10:19:51.886] Local evaluation: TRUE
[10:19:51.886] Environment: R_GlobalEnv
[10:19:51.886] Capture standard output: TRUE
[10:19:51.886] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.886] Globals: 11 objects totaling 12.33 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.886] Packages: 1 packages (‘future.apply’)
[10:19:51.886] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.886] Resolved: TRUE
[10:19:51.886] Value: <not collected>
[10:19:51.886] Conditions captured: <none>
[10:19:51.886] Early signaling: FALSE
[10:19:51.886] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.886] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:51.894] Chunk #1 of 2 ... DONE
[10:19:51.894] Chunk #2 of 2 ...
[10:19:51.895]  - Finding globals in 'X' for chunk #2 ...
[10:19:51.895] getGlobalsAndPackages() ...
[10:19:51.895] Searching for globals...
[10:19:51.895] 
[10:19:51.896] Searching for globals ... DONE
[10:19:51.896] - globals: [0] <none>
[10:19:51.896] getGlobalsAndPackages() ... DONE
[10:19:51.896]    + additional globals found: [n=0] 
[10:19:51.896]    + additional namespaces needed: [n=0] 
[10:19:51.896]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:51.897]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:51.897]  - seeds: <none>
[10:19:51.897]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.897] getGlobalsAndPackages() ...
[10:19:51.897] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.898] Resolving globals: FALSE
[10:19:51.898] Tweak future expression to call with '...' arguments ...
[10:19:51.898] {
[10:19:51.898]     do.call(function(...) {
[10:19:51.898]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.898]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.898]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.898]             on.exit(options(oopts), add = TRUE)
[10:19:51.898]         }
[10:19:51.898]         {
[10:19:51.898]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.898]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.898]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.898]             })
[10:19:51.898]         }
[10:19:51.898]     }, args = future.call.arguments)
[10:19:51.898] }
[10:19:51.898] Tweak future expression to call with '...' arguments ... DONE
[10:19:51.900] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:51.900] - packages: [1] ‘future.apply’
[10:19:51.900] getGlobalsAndPackages() ... DONE
[10:19:51.901] run() for ‘Future’ ...
[10:19:51.901] - state: ‘created’
[10:19:51.901] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:51.904] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:51.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:51.904]   - Field: ‘label’
[10:19:51.905]   - Field: ‘local’
[10:19:51.905]   - Field: ‘owner’
[10:19:51.905]   - Field: ‘envir’
[10:19:51.905]   - Field: ‘workers’
[10:19:51.905]   - Field: ‘packages’
[10:19:51.906]   - Field: ‘gc’
[10:19:51.906]   - Field: ‘job’
[10:19:51.906]   - Field: ‘conditions’
[10:19:51.906]   - Field: ‘expr’
[10:19:51.906]   - Field: ‘uuid’
[10:19:51.906]   - Field: ‘seed’
[10:19:51.907]   - Field: ‘version’
[10:19:51.907]   - Field: ‘result’
[10:19:51.907]   - Field: ‘asynchronous’
[10:19:51.907]   - Field: ‘calls’
[10:19:51.907]   - Field: ‘globals’
[10:19:51.907]   - Field: ‘stdout’
[10:19:51.908]   - Field: ‘earlySignal’
[10:19:51.908]   - Field: ‘lazy’
[10:19:51.908]   - Field: ‘state’
[10:19:51.908] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:51.908] - Launch lazy future ...
[10:19:51.909] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:51.909] Packages needed by future strategies (n = 0): <none>
[10:19:51.910] {
[10:19:51.910]     {
[10:19:51.910]         {
[10:19:51.910]             ...future.startTime <- base::Sys.time()
[10:19:51.910]             {
[10:19:51.910]                 {
[10:19:51.910]                   {
[10:19:51.910]                     {
[10:19:51.910]                       {
[10:19:51.910]                         base::local({
[10:19:51.910]                           has_future <- base::requireNamespace("future", 
[10:19:51.910]                             quietly = TRUE)
[10:19:51.910]                           if (has_future) {
[10:19:51.910]                             ns <- base::getNamespace("future")
[10:19:51.910]                             version <- ns[[".package"]][["version"]]
[10:19:51.910]                             if (is.null(version)) 
[10:19:51.910]                               version <- utils::packageVersion("future")
[10:19:51.910]                           }
[10:19:51.910]                           else {
[10:19:51.910]                             version <- NULL
[10:19:51.910]                           }
[10:19:51.910]                           if (!has_future || version < "1.8.0") {
[10:19:51.910]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:51.910]                               "", base::R.version$version.string), 
[10:19:51.910]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:51.910]                                 base::R.version$platform, 8 * 
[10:19:51.910]                                   base::.Machine$sizeof.pointer), 
[10:19:51.910]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:51.910]                                 "release", "version")], collapse = " "), 
[10:19:51.910]                               hostname = base::Sys.info()[["nodename"]])
[10:19:51.910]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:51.910]                               info)
[10:19:51.910]                             info <- base::paste(info, collapse = "; ")
[10:19:51.910]                             if (!has_future) {
[10:19:51.910]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:51.910]                                 info)
[10:19:51.910]                             }
[10:19:51.910]                             else {
[10:19:51.910]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:51.910]                                 info, version)
[10:19:51.910]                             }
[10:19:51.910]                             base::stop(msg)
[10:19:51.910]                           }
[10:19:51.910]                         })
[10:19:51.910]                       }
[10:19:51.910]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:51.910]                       base::options(mc.cores = 1L)
[10:19:51.910]                     }
[10:19:51.910]                     base::local({
[10:19:51.910]                       for (pkg in "future.apply") {
[10:19:51.910]                         base::loadNamespace(pkg)
[10:19:51.910]                         base::library(pkg, character.only = TRUE)
[10:19:51.910]                       }
[10:19:51.910]                     })
[10:19:51.910]                   }
[10:19:51.910]                   ...future.strategy.old <- future::plan("list")
[10:19:51.910]                   options(future.plan = NULL)
[10:19:51.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:51.910]                 }
[10:19:51.910]                 ...future.workdir <- getwd()
[10:19:51.910]             }
[10:19:51.910]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:51.910]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:51.910]         }
[10:19:51.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:51.910]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:51.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:51.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:51.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:51.910]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:51.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:51.910]             base::names(...future.oldOptions))
[10:19:51.910]     }
[10:19:51.910]     if (FALSE) {
[10:19:51.910]     }
[10:19:51.910]     else {
[10:19:51.910]         if (TRUE) {
[10:19:51.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:51.910]                 open = "w")
[10:19:51.910]         }
[10:19:51.910]         else {
[10:19:51.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:51.910]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:51.910]         }
[10:19:51.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:51.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:51.910]             base::sink(type = "output", split = FALSE)
[10:19:51.910]             base::close(...future.stdout)
[10:19:51.910]         }, add = TRUE)
[10:19:51.910]     }
[10:19:51.910]     ...future.frame <- base::sys.nframe()
[10:19:51.910]     ...future.conditions <- base::list()
[10:19:51.910]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:51.910]     if (FALSE) {
[10:19:51.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:51.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:51.910]     }
[10:19:51.910]     ...future.result <- base::tryCatch({
[10:19:51.910]         base::withCallingHandlers({
[10:19:51.910]             ...future.value <- base::withVisible(base::local({
[10:19:51.910]                 withCallingHandlers({
[10:19:51.910]                   {
[10:19:51.910]                     do.call(function(...) {
[10:19:51.910]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.910]                       if (!identical(...future.globals.maxSize.org, 
[10:19:51.910]                         ...future.globals.maxSize)) {
[10:19:51.910]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.910]                         on.exit(options(oopts), add = TRUE)
[10:19:51.910]                       }
[10:19:51.910]                       {
[10:19:51.910]                         lapply(seq_along(...future.elements_ii), 
[10:19:51.910]                           FUN = function(jj) {
[10:19:51.910]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.910]                             ...future.FUN(...future.X_jj, ...)
[10:19:51.910]                           })
[10:19:51.910]                       }
[10:19:51.910]                     }, args = future.call.arguments)
[10:19:51.910]                   }
[10:19:51.910]                 }, immediateCondition = function(cond) {
[10:19:51.910]                   save_rds <- function (object, pathname, ...) 
[10:19:51.910]                   {
[10:19:51.910]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:51.910]                     if (file_test("-f", pathname_tmp)) {
[10:19:51.910]                       fi_tmp <- file.info(pathname_tmp)
[10:19:51.910]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:51.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:51.910]                         fi_tmp[["mtime"]])
[10:19:51.910]                     }
[10:19:51.910]                     tryCatch({
[10:19:51.910]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:51.910]                     }, error = function(ex) {
[10:19:51.910]                       msg <- conditionMessage(ex)
[10:19:51.910]                       fi_tmp <- file.info(pathname_tmp)
[10:19:51.910]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:51.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:51.910]                         fi_tmp[["mtime"]], msg)
[10:19:51.910]                       ex$message <- msg
[10:19:51.910]                       stop(ex)
[10:19:51.910]                     })
[10:19:51.910]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:51.910]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:51.910]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:51.910]                       fi_tmp <- file.info(pathname_tmp)
[10:19:51.910]                       fi <- file.info(pathname)
[10:19:51.910]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:51.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:51.910]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:51.910]                         fi[["size"]], fi[["mtime"]])
[10:19:51.910]                       stop(msg)
[10:19:51.910]                     }
[10:19:51.910]                     invisible(pathname)
[10:19:51.910]                   }
[10:19:51.910]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:51.910]                     rootPath = tempdir()) 
[10:19:51.910]                   {
[10:19:51.910]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:51.910]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:51.910]                       tmpdir = path, fileext = ".rds")
[10:19:51.910]                     save_rds(obj, file)
[10:19:51.910]                   }
[10:19:51.910]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:51.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.910]                   {
[10:19:51.910]                     inherits <- base::inherits
[10:19:51.910]                     invokeRestart <- base::invokeRestart
[10:19:51.910]                     is.null <- base::is.null
[10:19:51.910]                     muffled <- FALSE
[10:19:51.910]                     if (inherits(cond, "message")) {
[10:19:51.910]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:51.910]                       if (muffled) 
[10:19:51.910]                         invokeRestart("muffleMessage")
[10:19:51.910]                     }
[10:19:51.910]                     else if (inherits(cond, "warning")) {
[10:19:51.910]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:51.910]                       if (muffled) 
[10:19:51.910]                         invokeRestart("muffleWarning")
[10:19:51.910]                     }
[10:19:51.910]                     else if (inherits(cond, "condition")) {
[10:19:51.910]                       if (!is.null(pattern)) {
[10:19:51.910]                         computeRestarts <- base::computeRestarts
[10:19:51.910]                         grepl <- base::grepl
[10:19:51.910]                         restarts <- computeRestarts(cond)
[10:19:51.910]                         for (restart in restarts) {
[10:19:51.910]                           name <- restart$name
[10:19:51.910]                           if (is.null(name)) 
[10:19:51.910]                             next
[10:19:51.910]                           if (!grepl(pattern, name)) 
[10:19:51.910]                             next
[10:19:51.910]                           invokeRestart(restart)
[10:19:51.910]                           muffled <- TRUE
[10:19:51.910]                           break
[10:19:51.910]                         }
[10:19:51.910]                       }
[10:19:51.910]                     }
[10:19:51.910]                     invisible(muffled)
[10:19:51.910]                   }
[10:19:51.910]                   muffleCondition(cond)
[10:19:51.910]                 })
[10:19:51.910]             }))
[10:19:51.910]             future::FutureResult(value = ...future.value$value, 
[10:19:51.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.910]                   ...future.rng), globalenv = if (FALSE) 
[10:19:51.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:51.910]                     ...future.globalenv.names))
[10:19:51.910]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:51.910]         }, condition = base::local({
[10:19:51.910]             c <- base::c
[10:19:51.910]             inherits <- base::inherits
[10:19:51.910]             invokeRestart <- base::invokeRestart
[10:19:51.910]             length <- base::length
[10:19:51.910]             list <- base::list
[10:19:51.910]             seq.int <- base::seq.int
[10:19:51.910]             signalCondition <- base::signalCondition
[10:19:51.910]             sys.calls <- base::sys.calls
[10:19:51.910]             `[[` <- base::`[[`
[10:19:51.910]             `+` <- base::`+`
[10:19:51.910]             `<<-` <- base::`<<-`
[10:19:51.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:51.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:51.910]                   3L)]
[10:19:51.910]             }
[10:19:51.910]             function(cond) {
[10:19:51.910]                 is_error <- inherits(cond, "error")
[10:19:51.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:51.910]                   NULL)
[10:19:51.910]                 if (is_error) {
[10:19:51.910]                   sessionInformation <- function() {
[10:19:51.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:51.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:51.910]                       search = base::search(), system = base::Sys.info())
[10:19:51.910]                   }
[10:19:51.910]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:51.910]                     cond$call), session = sessionInformation(), 
[10:19:51.910]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:51.910]                   signalCondition(cond)
[10:19:51.910]                 }
[10:19:51.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:51.910]                 "immediateCondition"))) {
[10:19:51.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:51.910]                   ...future.conditions[[length(...future.conditions) + 
[10:19:51.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:51.910]                   if (TRUE && !signal) {
[10:19:51.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.910]                     {
[10:19:51.910]                       inherits <- base::inherits
[10:19:51.910]                       invokeRestart <- base::invokeRestart
[10:19:51.910]                       is.null <- base::is.null
[10:19:51.910]                       muffled <- FALSE
[10:19:51.910]                       if (inherits(cond, "message")) {
[10:19:51.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.910]                         if (muffled) 
[10:19:51.910]                           invokeRestart("muffleMessage")
[10:19:51.910]                       }
[10:19:51.910]                       else if (inherits(cond, "warning")) {
[10:19:51.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.910]                         if (muffled) 
[10:19:51.910]                           invokeRestart("muffleWarning")
[10:19:51.910]                       }
[10:19:51.910]                       else if (inherits(cond, "condition")) {
[10:19:51.910]                         if (!is.null(pattern)) {
[10:19:51.910]                           computeRestarts <- base::computeRestarts
[10:19:51.910]                           grepl <- base::grepl
[10:19:51.910]                           restarts <- computeRestarts(cond)
[10:19:51.910]                           for (restart in restarts) {
[10:19:51.910]                             name <- restart$name
[10:19:51.910]                             if (is.null(name)) 
[10:19:51.910]                               next
[10:19:51.910]                             if (!grepl(pattern, name)) 
[10:19:51.910]                               next
[10:19:51.910]                             invokeRestart(restart)
[10:19:51.910]                             muffled <- TRUE
[10:19:51.910]                             break
[10:19:51.910]                           }
[10:19:51.910]                         }
[10:19:51.910]                       }
[10:19:51.910]                       invisible(muffled)
[10:19:51.910]                     }
[10:19:51.910]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.910]                   }
[10:19:51.910]                 }
[10:19:51.910]                 else {
[10:19:51.910]                   if (TRUE) {
[10:19:51.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:51.910]                     {
[10:19:51.910]                       inherits <- base::inherits
[10:19:51.910]                       invokeRestart <- base::invokeRestart
[10:19:51.910]                       is.null <- base::is.null
[10:19:51.910]                       muffled <- FALSE
[10:19:51.910]                       if (inherits(cond, "message")) {
[10:19:51.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:51.910]                         if (muffled) 
[10:19:51.910]                           invokeRestart("muffleMessage")
[10:19:51.910]                       }
[10:19:51.910]                       else if (inherits(cond, "warning")) {
[10:19:51.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:51.910]                         if (muffled) 
[10:19:51.910]                           invokeRestart("muffleWarning")
[10:19:51.910]                       }
[10:19:51.910]                       else if (inherits(cond, "condition")) {
[10:19:51.910]                         if (!is.null(pattern)) {
[10:19:51.910]                           computeRestarts <- base::computeRestarts
[10:19:51.910]                           grepl <- base::grepl
[10:19:51.910]                           restarts <- computeRestarts(cond)
[10:19:51.910]                           for (restart in restarts) {
[10:19:51.910]                             name <- restart$name
[10:19:51.910]                             if (is.null(name)) 
[10:19:51.910]                               next
[10:19:51.910]                             if (!grepl(pattern, name)) 
[10:19:51.910]                               next
[10:19:51.910]                             invokeRestart(restart)
[10:19:51.910]                             muffled <- TRUE
[10:19:51.910]                             break
[10:19:51.910]                           }
[10:19:51.910]                         }
[10:19:51.910]                       }
[10:19:51.910]                       invisible(muffled)
[10:19:51.910]                     }
[10:19:51.910]                     muffleCondition(cond, pattern = "^muffle")
[10:19:51.910]                   }
[10:19:51.910]                 }
[10:19:51.910]             }
[10:19:51.910]         }))
[10:19:51.910]     }, error = function(ex) {
[10:19:51.910]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:51.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:51.910]                 ...future.rng), started = ...future.startTime, 
[10:19:51.910]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:51.910]             version = "1.8"), class = "FutureResult")
[10:19:51.910]     }, finally = {
[10:19:51.910]         if (!identical(...future.workdir, getwd())) 
[10:19:51.910]             setwd(...future.workdir)
[10:19:51.910]         {
[10:19:51.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:51.910]                 ...future.oldOptions$nwarnings <- NULL
[10:19:51.910]             }
[10:19:51.910]             base::options(...future.oldOptions)
[10:19:51.910]             if (.Platform$OS.type == "windows") {
[10:19:51.910]                 old_names <- names(...future.oldEnvVars)
[10:19:51.910]                 envs <- base::Sys.getenv()
[10:19:51.910]                 names <- names(envs)
[10:19:51.910]                 common <- intersect(names, old_names)
[10:19:51.910]                 added <- setdiff(names, old_names)
[10:19:51.910]                 removed <- setdiff(old_names, names)
[10:19:51.910]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:51.910]                   envs[common]]
[10:19:51.910]                 NAMES <- toupper(changed)
[10:19:51.910]                 args <- list()
[10:19:51.910]                 for (kk in seq_along(NAMES)) {
[10:19:51.910]                   name <- changed[[kk]]
[10:19:51.910]                   NAME <- NAMES[[kk]]
[10:19:51.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.910]                     next
[10:19:51.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.910]                 }
[10:19:51.910]                 NAMES <- toupper(added)
[10:19:51.910]                 for (kk in seq_along(NAMES)) {
[10:19:51.910]                   name <- added[[kk]]
[10:19:51.910]                   NAME <- NAMES[[kk]]
[10:19:51.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.910]                     next
[10:19:51.910]                   args[[name]] <- ""
[10:19:51.910]                 }
[10:19:51.910]                 NAMES <- toupper(removed)
[10:19:51.910]                 for (kk in seq_along(NAMES)) {
[10:19:51.910]                   name <- removed[[kk]]
[10:19:51.910]                   NAME <- NAMES[[kk]]
[10:19:51.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:51.910]                     next
[10:19:51.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:51.910]                 }
[10:19:51.910]                 if (length(args) > 0) 
[10:19:51.910]                   base::do.call(base::Sys.setenv, args = args)
[10:19:51.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:51.910]             }
[10:19:51.910]             else {
[10:19:51.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:51.910]             }
[10:19:51.910]             {
[10:19:51.910]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:51.910]                   0L) {
[10:19:51.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:51.910]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:51.910]                   base::options(opts)
[10:19:51.910]                 }
[10:19:51.910]                 {
[10:19:51.910]                   {
[10:19:51.910]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:51.910]                     NULL
[10:19:51.910]                   }
[10:19:51.910]                   options(future.plan = NULL)
[10:19:51.910]                   if (is.na(NA_character_)) 
[10:19:51.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:51.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:51.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:51.910]                     .init = FALSE)
[10:19:51.910]                 }
[10:19:51.910]             }
[10:19:51.910]         }
[10:19:51.910]     })
[10:19:51.910]     if (TRUE) {
[10:19:51.910]         base::sink(type = "output", split = FALSE)
[10:19:51.910]         if (TRUE) {
[10:19:51.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:51.910]         }
[10:19:51.910]         else {
[10:19:51.910]             ...future.result["stdout"] <- base::list(NULL)
[10:19:51.910]         }
[10:19:51.910]         base::close(...future.stdout)
[10:19:51.910]         ...future.stdout <- NULL
[10:19:51.910]     }
[10:19:51.910]     ...future.result$conditions <- ...future.conditions
[10:19:51.910]     ...future.result$finished <- base::Sys.time()
[10:19:51.910]     ...future.result
[10:19:51.910] }
[10:19:51.914] assign_globals() ...
[10:19:51.914] List of 11
[10:19:51.914]  $ ...future.FUN            :function (x, ...)  
[10:19:51.914]  $ x_FUN                    :function (x)  
[10:19:51.914]  $ times                    : int 1
[10:19:51.914]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.914]  $ stop_if_not              :function (...)  
[10:19:51.914]  $ dim                      : NULL
[10:19:51.914]  $ valid_types              : chr "character"
[10:19:51.914]  $ future.call.arguments    : list()
[10:19:51.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.914]  $ ...future.elements_ii    :List of 1
[10:19:51.914]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[10:19:51.914]  $ ...future.seeds_ii       : NULL
[10:19:51.914]  $ ...future.globals.maxSize: NULL
[10:19:51.914]  - attr(*, "where")=List of 11
[10:19:51.914]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:51.914]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:51.914]  - attr(*, "resolved")= logi FALSE
[10:19:51.914]  - attr(*, "total_size")= num 22333
[10:19:51.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.914]  - attr(*, "already-done")= logi TRUE
[10:19:51.937] - copied ‘...future.FUN’ to environment
[10:19:51.937] - copied ‘x_FUN’ to environment
[10:19:51.937] - copied ‘times’ to environment
[10:19:51.937] - copied ‘stopf’ to environment
[10:19:51.938] - copied ‘stop_if_not’ to environment
[10:19:51.938] - copied ‘dim’ to environment
[10:19:51.938] - copied ‘valid_types’ to environment
[10:19:51.938] - copied ‘future.call.arguments’ to environment
[10:19:51.938] - copied ‘...future.elements_ii’ to environment
[10:19:51.938] - copied ‘...future.seeds_ii’ to environment
[10:19:51.938] - copied ‘...future.globals.maxSize’ to environment
[10:19:51.939] assign_globals() ... done
[10:19:51.939] requestCore(): workers = 2
[10:19:51.945] MulticoreFuture started
[10:19:51.946] - Launch lazy future ... done
[10:19:51.946] run() for ‘MulticoreFuture’ ... done
[10:19:51.946] Created future:
[10:19:51.946] plan(): Setting new future strategy stack:
[10:19:51.947] List of future strategies:
[10:19:51.947] 1. sequential:
[10:19:51.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:51.947]    - tweaked: FALSE
[10:19:51.947]    - call: NULL
[10:19:51.948] plan(): nbrOfWorkers() = 1
[10:19:51.950] plan(): Setting new future strategy stack:
[10:19:51.950] List of future strategies:
[10:19:51.950] 1. multicore:
[10:19:51.950]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:51.950]    - tweaked: FALSE
[10:19:51.950]    - call: plan(strategy)
[10:19:51.954] plan(): nbrOfWorkers() = 2
[10:19:51.947] MulticoreFuture:
[10:19:51.947] Label: ‘future_vapply-2’
[10:19:51.947] Expression:
[10:19:51.947] {
[10:19:51.947]     do.call(function(...) {
[10:19:51.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:51.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:51.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:51.947]             on.exit(options(oopts), add = TRUE)
[10:19:51.947]         }
[10:19:51.947]         {
[10:19:51.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:51.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:51.947]                 ...future.FUN(...future.X_jj, ...)
[10:19:51.947]             })
[10:19:51.947]         }
[10:19:51.947]     }, args = future.call.arguments)
[10:19:51.947] }
[10:19:51.947] Lazy evaluation: FALSE
[10:19:51.947] Asynchronous evaluation: TRUE
[10:19:51.947] Local evaluation: TRUE
[10:19:51.947] Environment: R_GlobalEnv
[10:19:51.947] Capture standard output: TRUE
[10:19:51.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:51.947] Globals: 11 objects totaling 12.32 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:51.947] Packages: 1 packages (‘future.apply’)
[10:19:51.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:51.947] Resolved: TRUE
[10:19:51.947] Value: <not collected>
[10:19:51.947] Conditions captured: <none>
[10:19:51.947] Early signaling: FALSE
[10:19:51.947] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:51.947] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:51.955] Chunk #2 of 2 ... DONE
[10:19:51.955] Launching 2 futures (chunks) ... DONE
[10:19:51.955] Resolving 2 futures (chunks) ...
[10:19:51.956] resolve() on list ...
[10:19:51.956]  recursive: 0
[10:19:51.956]  length: 2
[10:19:51.956] 
[10:19:51.956] Future #1
[10:19:51.957] result() for MulticoreFuture ...
[10:19:51.959] result() for MulticoreFuture ...
[10:19:51.959] result() for MulticoreFuture ... done
[10:19:51.960] result() for MulticoreFuture ... done
[10:19:51.960] result() for MulticoreFuture ...
[10:19:51.960] result() for MulticoreFuture ... done
[10:19:51.960] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:51.961] - nx: 2
[10:19:51.961] - relay: TRUE
[10:19:51.961] - stdout: TRUE
[10:19:51.961] - signal: TRUE
[10:19:51.961] - resignal: FALSE
[10:19:51.961] - force: TRUE
[10:19:51.962] - relayed: [n=2] FALSE, FALSE
[10:19:51.962] - queued futures: [n=2] FALSE, FALSE
[10:19:51.962]  - until=1
[10:19:51.962]  - relaying element #1
[10:19:51.962] result() for MulticoreFuture ...
[10:19:51.963] result() for MulticoreFuture ... done
[10:19:51.963] result() for MulticoreFuture ...
[10:19:51.963] result() for MulticoreFuture ... done
[10:19:51.963] result() for MulticoreFuture ...
[10:19:51.963] result() for MulticoreFuture ... done
[10:19:51.964] result() for MulticoreFuture ...
[10:19:51.964] result() for MulticoreFuture ... done
[10:19:51.964] - relayed: [n=2] TRUE, FALSE
[10:19:51.964] - queued futures: [n=2] TRUE, FALSE
[10:19:51.964] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:51.965]  length: 1 (resolved future 1)
[10:19:51.965] Future #2
[10:19:51.965] result() for MulticoreFuture ...
[10:19:51.966] result() for MulticoreFuture ...
[10:19:51.966] result() for MulticoreFuture ... done
[10:19:51.966] result() for MulticoreFuture ... done
[10:19:51.967] result() for MulticoreFuture ...
[10:19:51.967] result() for MulticoreFuture ... done
[10:19:51.967] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:51.967] - nx: 2
[10:19:51.967] - relay: TRUE
[10:19:51.967] - stdout: TRUE
[10:19:51.967] - signal: TRUE
[10:19:51.968] - resignal: FALSE
[10:19:51.968] - force: TRUE
[10:19:51.968] - relayed: [n=2] TRUE, FALSE
[10:19:51.968] - queued futures: [n=2] TRUE, FALSE
[10:19:51.968]  - until=2
[10:19:51.968]  - relaying element #2
[10:19:51.968] result() for MulticoreFuture ...
[10:19:51.968] result() for MulticoreFuture ... done
[10:19:51.969] result() for MulticoreFuture ...
[10:19:51.969] result() for MulticoreFuture ... done
[10:19:51.969] result() for MulticoreFuture ...
[10:19:51.969] result() for MulticoreFuture ... done
[10:19:51.969] result() for MulticoreFuture ...
[10:19:51.969] result() for MulticoreFuture ... done
[10:19:51.969] - relayed: [n=2] TRUE, TRUE
[10:19:51.969] - queued futures: [n=2] TRUE, TRUE
[10:19:51.970] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:51.970]  length: 0 (resolved future 2)
[10:19:51.970] Relaying remaining futures
[10:19:51.970] signalConditionsASAP(NULL, pos=0) ...
[10:19:51.970] - nx: 2
[10:19:51.970] - relay: TRUE
[10:19:51.970] - stdout: TRUE
[10:19:51.970] - signal: TRUE
[10:19:51.970] - resignal: FALSE
[10:19:51.970] - force: TRUE
[10:19:51.971] - relayed: [n=2] TRUE, TRUE
[10:19:51.971] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:51.971] - relayed: [n=2] TRUE, TRUE
[10:19:51.971] - queued futures: [n=2] TRUE, TRUE
[10:19:51.971] signalConditionsASAP(NULL, pos=0) ... done
[10:19:51.971] resolve() on list ... DONE
[10:19:51.971] result() for MulticoreFuture ...
[10:19:51.971] result() for MulticoreFuture ... done
[10:19:51.971] result() for MulticoreFuture ...
[10:19:51.972] result() for MulticoreFuture ... done
[10:19:51.972] result() for MulticoreFuture ...
[10:19:51.972] result() for MulticoreFuture ... done
[10:19:51.972] result() for MulticoreFuture ...
[10:19:51.972] result() for MulticoreFuture ... done
[10:19:51.972]  - Number of value chunks collected: 2
[10:19:51.972] Resolving 2 futures (chunks) ... DONE
[10:19:51.972] Reducing values from 2 chunks ...
[10:19:51.972]  - Number of values collected after concatenation: 2
[10:19:51.973]  - Number of values expected: 2
[10:19:51.973] Reducing values from 2 chunks ... DONE
[10:19:51.973] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:19:51.974] future_lapply() ...
[10:19:51.981] Number of chunks: 2
[10:19:51.981] getGlobalsAndPackagesXApply() ...
[10:19:51.981]  - future.globals: TRUE
[10:19:51.981] getGlobalsAndPackages() ...
[10:19:51.981] Searching for globals...
[10:19:51.986] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:19:51.986] Searching for globals ... DONE
[10:19:51.986] Resolving globals: FALSE
[10:19:51.987] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[10:19:51.988] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:51.988] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.988] - packages: [1] ‘future.apply’
[10:19:51.988] getGlobalsAndPackages() ... DONE
[10:19:51.988]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:51.988]  - needed namespaces: [n=1] ‘future.apply’
[10:19:51.988] Finding globals ... DONE
[10:19:51.989]  - use_args: TRUE
[10:19:51.989]  - Getting '...' globals ...
[10:19:51.989] resolve() on list ...
[10:19:51.989]  recursive: 0
[10:19:51.989]  length: 1
[10:19:51.989]  elements: ‘...’
[10:19:51.989]  length: 0 (resolved future 1)
[10:19:51.990] resolve() on list ... DONE
[10:19:51.990]    - '...' content: [n=0] 
[10:19:51.990] List of 1
[10:19:51.990]  $ ...: list()
[10:19:51.990]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.990]  - attr(*, "where")=List of 1
[10:19:51.990]   ..$ ...:<environment: 0x55c69fe50cc8> 
[10:19:51.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.990]  - attr(*, "resolved")= logi TRUE
[10:19:51.990]  - attr(*, "total_size")= num NA
[10:19:51.992]  - Getting '...' globals ... DONE
[10:19:51.992] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:51.992] List of 8
[10:19:51.992]  $ ...future.FUN:function (x, ...)  
[10:19:51.992]  $ x_FUN        :function (x)  
[10:19:51.992]  $ times        : int 0
[10:19:51.992]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:51.992]  $ stop_if_not  :function (...)  
[10:19:51.992]  $ dim          : NULL
[10:19:51.992]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:51.992]  $ ...          : list()
[10:19:51.992]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:51.992]  - attr(*, "where")=List of 8
[10:19:51.992]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:51.992]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:51.992]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:51.992]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:51.992]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:51.992]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:51.992]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:51.992]   ..$ ...          :<environment: 0x55c69fe50cc8> 
[10:19:51.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:51.992]  - attr(*, "resolved")= logi FALSE
[10:19:51.992]  - attr(*, "total_size")= num 23490
[10:19:51.998] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:51.998] getGlobalsAndPackagesXApply() ... DONE
[10:19:51.998] Number of futures (= number of chunks): 2
[10:19:51.998] Launching 2 futures (chunks) ...
[10:19:51.998] Chunk #1 of 2 ...
[10:19:51.998]  - Finding globals in 'X' for chunk #1 ...
[10:19:51.998] getGlobalsAndPackages() ...
[10:19:51.998] Searching for globals...
[10:19:51.999] 
[10:19:51.999] Searching for globals ... DONE
[10:19:51.999] - globals: [0] <none>
[10:19:51.999] getGlobalsAndPackages() ... DONE
[10:19:51.999]    + additional globals found: [n=0] 
[10:19:51.999]    + additional namespaces needed: [n=0] 
[10:19:51.999]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:51.999]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:51.999]  - seeds: <none>
[10:19:51.999]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.000] getGlobalsAndPackages() ...
[10:19:52.000] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.000] Resolving globals: FALSE
[10:19:52.000] Tweak future expression to call with '...' arguments ...
[10:19:52.000] {
[10:19:52.000]     do.call(function(...) {
[10:19:52.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.000]             on.exit(options(oopts), add = TRUE)
[10:19:52.000]         }
[10:19:52.000]         {
[10:19:52.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.000]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.000]             })
[10:19:52.000]         }
[10:19:52.000]     }, args = future.call.arguments)
[10:19:52.000] }
[10:19:52.000] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.001] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.001] - packages: [1] ‘future.apply’
[10:19:52.001] getGlobalsAndPackages() ... DONE
[10:19:52.001] run() for ‘Future’ ...
[10:19:52.003] - state: ‘created’
[10:19:52.003] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.005] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.005]   - Field: ‘label’
[10:19:52.005]   - Field: ‘local’
[10:19:52.006]   - Field: ‘owner’
[10:19:52.006]   - Field: ‘envir’
[10:19:52.006]   - Field: ‘workers’
[10:19:52.006]   - Field: ‘packages’
[10:19:52.006]   - Field: ‘gc’
[10:19:52.006]   - Field: ‘job’
[10:19:52.006]   - Field: ‘conditions’
[10:19:52.006]   - Field: ‘expr’
[10:19:52.006]   - Field: ‘uuid’
[10:19:52.006]   - Field: ‘seed’
[10:19:52.007]   - Field: ‘version’
[10:19:52.007]   - Field: ‘result’
[10:19:52.007]   - Field: ‘asynchronous’
[10:19:52.007]   - Field: ‘calls’
[10:19:52.007]   - Field: ‘globals’
[10:19:52.007]   - Field: ‘stdout’
[10:19:52.007]   - Field: ‘earlySignal’
[10:19:52.007]   - Field: ‘lazy’
[10:19:52.007]   - Field: ‘state’
[10:19:52.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.008] - Launch lazy future ...
[10:19:52.008] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.008] Packages needed by future strategies (n = 0): <none>
[10:19:52.008] {
[10:19:52.008]     {
[10:19:52.008]         {
[10:19:52.008]             ...future.startTime <- base::Sys.time()
[10:19:52.008]             {
[10:19:52.008]                 {
[10:19:52.008]                   {
[10:19:52.008]                     {
[10:19:52.008]                       {
[10:19:52.008]                         base::local({
[10:19:52.008]                           has_future <- base::requireNamespace("future", 
[10:19:52.008]                             quietly = TRUE)
[10:19:52.008]                           if (has_future) {
[10:19:52.008]                             ns <- base::getNamespace("future")
[10:19:52.008]                             version <- ns[[".package"]][["version"]]
[10:19:52.008]                             if (is.null(version)) 
[10:19:52.008]                               version <- utils::packageVersion("future")
[10:19:52.008]                           }
[10:19:52.008]                           else {
[10:19:52.008]                             version <- NULL
[10:19:52.008]                           }
[10:19:52.008]                           if (!has_future || version < "1.8.0") {
[10:19:52.008]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.008]                               "", base::R.version$version.string), 
[10:19:52.008]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.008]                                 base::R.version$platform, 8 * 
[10:19:52.008]                                   base::.Machine$sizeof.pointer), 
[10:19:52.008]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.008]                                 "release", "version")], collapse = " "), 
[10:19:52.008]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.008]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.008]                               info)
[10:19:52.008]                             info <- base::paste(info, collapse = "; ")
[10:19:52.008]                             if (!has_future) {
[10:19:52.008]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.008]                                 info)
[10:19:52.008]                             }
[10:19:52.008]                             else {
[10:19:52.008]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.008]                                 info, version)
[10:19:52.008]                             }
[10:19:52.008]                             base::stop(msg)
[10:19:52.008]                           }
[10:19:52.008]                         })
[10:19:52.008]                       }
[10:19:52.008]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.008]                       base::options(mc.cores = 1L)
[10:19:52.008]                     }
[10:19:52.008]                     base::local({
[10:19:52.008]                       for (pkg in "future.apply") {
[10:19:52.008]                         base::loadNamespace(pkg)
[10:19:52.008]                         base::library(pkg, character.only = TRUE)
[10:19:52.008]                       }
[10:19:52.008]                     })
[10:19:52.008]                   }
[10:19:52.008]                   ...future.strategy.old <- future::plan("list")
[10:19:52.008]                   options(future.plan = NULL)
[10:19:52.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.008]                 }
[10:19:52.008]                 ...future.workdir <- getwd()
[10:19:52.008]             }
[10:19:52.008]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.008]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.008]         }
[10:19:52.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.008]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.008]             base::names(...future.oldOptions))
[10:19:52.008]     }
[10:19:52.008]     if (FALSE) {
[10:19:52.008]     }
[10:19:52.008]     else {
[10:19:52.008]         if (TRUE) {
[10:19:52.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.008]                 open = "w")
[10:19:52.008]         }
[10:19:52.008]         else {
[10:19:52.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.008]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.008]         }
[10:19:52.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.008]             base::sink(type = "output", split = FALSE)
[10:19:52.008]             base::close(...future.stdout)
[10:19:52.008]         }, add = TRUE)
[10:19:52.008]     }
[10:19:52.008]     ...future.frame <- base::sys.nframe()
[10:19:52.008]     ...future.conditions <- base::list()
[10:19:52.008]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.008]     if (FALSE) {
[10:19:52.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.008]     }
[10:19:52.008]     ...future.result <- base::tryCatch({
[10:19:52.008]         base::withCallingHandlers({
[10:19:52.008]             ...future.value <- base::withVisible(base::local({
[10:19:52.008]                 withCallingHandlers({
[10:19:52.008]                   {
[10:19:52.008]                     do.call(function(...) {
[10:19:52.008]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.008]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.008]                         ...future.globals.maxSize)) {
[10:19:52.008]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.008]                         on.exit(options(oopts), add = TRUE)
[10:19:52.008]                       }
[10:19:52.008]                       {
[10:19:52.008]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.008]                           FUN = function(jj) {
[10:19:52.008]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.008]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.008]                           })
[10:19:52.008]                       }
[10:19:52.008]                     }, args = future.call.arguments)
[10:19:52.008]                   }
[10:19:52.008]                 }, immediateCondition = function(cond) {
[10:19:52.008]                   save_rds <- function (object, pathname, ...) 
[10:19:52.008]                   {
[10:19:52.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.008]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.008]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.008]                         fi_tmp[["mtime"]])
[10:19:52.008]                     }
[10:19:52.008]                     tryCatch({
[10:19:52.008]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.008]                     }, error = function(ex) {
[10:19:52.008]                       msg <- conditionMessage(ex)
[10:19:52.008]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.008]                         fi_tmp[["mtime"]], msg)
[10:19:52.008]                       ex$message <- msg
[10:19:52.008]                       stop(ex)
[10:19:52.008]                     })
[10:19:52.008]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.008]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.008]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.008]                       fi <- file.info(pathname)
[10:19:52.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.008]                         fi[["size"]], fi[["mtime"]])
[10:19:52.008]                       stop(msg)
[10:19:52.008]                     }
[10:19:52.008]                     invisible(pathname)
[10:19:52.008]                   }
[10:19:52.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.008]                     rootPath = tempdir()) 
[10:19:52.008]                   {
[10:19:52.008]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.008]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.008]                       tmpdir = path, fileext = ".rds")
[10:19:52.008]                     save_rds(obj, file)
[10:19:52.008]                   }
[10:19:52.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.008]                   {
[10:19:52.008]                     inherits <- base::inherits
[10:19:52.008]                     invokeRestart <- base::invokeRestart
[10:19:52.008]                     is.null <- base::is.null
[10:19:52.008]                     muffled <- FALSE
[10:19:52.008]                     if (inherits(cond, "message")) {
[10:19:52.008]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.008]                       if (muffled) 
[10:19:52.008]                         invokeRestart("muffleMessage")
[10:19:52.008]                     }
[10:19:52.008]                     else if (inherits(cond, "warning")) {
[10:19:52.008]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.008]                       if (muffled) 
[10:19:52.008]                         invokeRestart("muffleWarning")
[10:19:52.008]                     }
[10:19:52.008]                     else if (inherits(cond, "condition")) {
[10:19:52.008]                       if (!is.null(pattern)) {
[10:19:52.008]                         computeRestarts <- base::computeRestarts
[10:19:52.008]                         grepl <- base::grepl
[10:19:52.008]                         restarts <- computeRestarts(cond)
[10:19:52.008]                         for (restart in restarts) {
[10:19:52.008]                           name <- restart$name
[10:19:52.008]                           if (is.null(name)) 
[10:19:52.008]                             next
[10:19:52.008]                           if (!grepl(pattern, name)) 
[10:19:52.008]                             next
[10:19:52.008]                           invokeRestart(restart)
[10:19:52.008]                           muffled <- TRUE
[10:19:52.008]                           break
[10:19:52.008]                         }
[10:19:52.008]                       }
[10:19:52.008]                     }
[10:19:52.008]                     invisible(muffled)
[10:19:52.008]                   }
[10:19:52.008]                   muffleCondition(cond)
[10:19:52.008]                 })
[10:19:52.008]             }))
[10:19:52.008]             future::FutureResult(value = ...future.value$value, 
[10:19:52.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.008]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.008]                     ...future.globalenv.names))
[10:19:52.008]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.008]         }, condition = base::local({
[10:19:52.008]             c <- base::c
[10:19:52.008]             inherits <- base::inherits
[10:19:52.008]             invokeRestart <- base::invokeRestart
[10:19:52.008]             length <- base::length
[10:19:52.008]             list <- base::list
[10:19:52.008]             seq.int <- base::seq.int
[10:19:52.008]             signalCondition <- base::signalCondition
[10:19:52.008]             sys.calls <- base::sys.calls
[10:19:52.008]             `[[` <- base::`[[`
[10:19:52.008]             `+` <- base::`+`
[10:19:52.008]             `<<-` <- base::`<<-`
[10:19:52.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.008]                   3L)]
[10:19:52.008]             }
[10:19:52.008]             function(cond) {
[10:19:52.008]                 is_error <- inherits(cond, "error")
[10:19:52.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.008]                   NULL)
[10:19:52.008]                 if (is_error) {
[10:19:52.008]                   sessionInformation <- function() {
[10:19:52.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.008]                       search = base::search(), system = base::Sys.info())
[10:19:52.008]                   }
[10:19:52.008]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.008]                     cond$call), session = sessionInformation(), 
[10:19:52.008]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.008]                   signalCondition(cond)
[10:19:52.008]                 }
[10:19:52.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.008]                 "immediateCondition"))) {
[10:19:52.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.008]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.008]                   if (TRUE && !signal) {
[10:19:52.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.008]                     {
[10:19:52.008]                       inherits <- base::inherits
[10:19:52.008]                       invokeRestart <- base::invokeRestart
[10:19:52.008]                       is.null <- base::is.null
[10:19:52.008]                       muffled <- FALSE
[10:19:52.008]                       if (inherits(cond, "message")) {
[10:19:52.008]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.008]                         if (muffled) 
[10:19:52.008]                           invokeRestart("muffleMessage")
[10:19:52.008]                       }
[10:19:52.008]                       else if (inherits(cond, "warning")) {
[10:19:52.008]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.008]                         if (muffled) 
[10:19:52.008]                           invokeRestart("muffleWarning")
[10:19:52.008]                       }
[10:19:52.008]                       else if (inherits(cond, "condition")) {
[10:19:52.008]                         if (!is.null(pattern)) {
[10:19:52.008]                           computeRestarts <- base::computeRestarts
[10:19:52.008]                           grepl <- base::grepl
[10:19:52.008]                           restarts <- computeRestarts(cond)
[10:19:52.008]                           for (restart in restarts) {
[10:19:52.008]                             name <- restart$name
[10:19:52.008]                             if (is.null(name)) 
[10:19:52.008]                               next
[10:19:52.008]                             if (!grepl(pattern, name)) 
[10:19:52.008]                               next
[10:19:52.008]                             invokeRestart(restart)
[10:19:52.008]                             muffled <- TRUE
[10:19:52.008]                             break
[10:19:52.008]                           }
[10:19:52.008]                         }
[10:19:52.008]                       }
[10:19:52.008]                       invisible(muffled)
[10:19:52.008]                     }
[10:19:52.008]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.008]                   }
[10:19:52.008]                 }
[10:19:52.008]                 else {
[10:19:52.008]                   if (TRUE) {
[10:19:52.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.008]                     {
[10:19:52.008]                       inherits <- base::inherits
[10:19:52.008]                       invokeRestart <- base::invokeRestart
[10:19:52.008]                       is.null <- base::is.null
[10:19:52.008]                       muffled <- FALSE
[10:19:52.008]                       if (inherits(cond, "message")) {
[10:19:52.008]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.008]                         if (muffled) 
[10:19:52.008]                           invokeRestart("muffleMessage")
[10:19:52.008]                       }
[10:19:52.008]                       else if (inherits(cond, "warning")) {
[10:19:52.008]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.008]                         if (muffled) 
[10:19:52.008]                           invokeRestart("muffleWarning")
[10:19:52.008]                       }
[10:19:52.008]                       else if (inherits(cond, "condition")) {
[10:19:52.008]                         if (!is.null(pattern)) {
[10:19:52.008]                           computeRestarts <- base::computeRestarts
[10:19:52.008]                           grepl <- base::grepl
[10:19:52.008]                           restarts <- computeRestarts(cond)
[10:19:52.008]                           for (restart in restarts) {
[10:19:52.008]                             name <- restart$name
[10:19:52.008]                             if (is.null(name)) 
[10:19:52.008]                               next
[10:19:52.008]                             if (!grepl(pattern, name)) 
[10:19:52.008]                               next
[10:19:52.008]                             invokeRestart(restart)
[10:19:52.008]                             muffled <- TRUE
[10:19:52.008]                             break
[10:19:52.008]                           }
[10:19:52.008]                         }
[10:19:52.008]                       }
[10:19:52.008]                       invisible(muffled)
[10:19:52.008]                     }
[10:19:52.008]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.008]                   }
[10:19:52.008]                 }
[10:19:52.008]             }
[10:19:52.008]         }))
[10:19:52.008]     }, error = function(ex) {
[10:19:52.008]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.008]                 ...future.rng), started = ...future.startTime, 
[10:19:52.008]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.008]             version = "1.8"), class = "FutureResult")
[10:19:52.008]     }, finally = {
[10:19:52.008]         if (!identical(...future.workdir, getwd())) 
[10:19:52.008]             setwd(...future.workdir)
[10:19:52.008]         {
[10:19:52.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.008]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.008]             }
[10:19:52.008]             base::options(...future.oldOptions)
[10:19:52.008]             if (.Platform$OS.type == "windows") {
[10:19:52.008]                 old_names <- names(...future.oldEnvVars)
[10:19:52.008]                 envs <- base::Sys.getenv()
[10:19:52.008]                 names <- names(envs)
[10:19:52.008]                 common <- intersect(names, old_names)
[10:19:52.008]                 added <- setdiff(names, old_names)
[10:19:52.008]                 removed <- setdiff(old_names, names)
[10:19:52.008]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.008]                   envs[common]]
[10:19:52.008]                 NAMES <- toupper(changed)
[10:19:52.008]                 args <- list()
[10:19:52.008]                 for (kk in seq_along(NAMES)) {
[10:19:52.008]                   name <- changed[[kk]]
[10:19:52.008]                   NAME <- NAMES[[kk]]
[10:19:52.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.008]                     next
[10:19:52.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.008]                 }
[10:19:52.008]                 NAMES <- toupper(added)
[10:19:52.008]                 for (kk in seq_along(NAMES)) {
[10:19:52.008]                   name <- added[[kk]]
[10:19:52.008]                   NAME <- NAMES[[kk]]
[10:19:52.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.008]                     next
[10:19:52.008]                   args[[name]] <- ""
[10:19:52.008]                 }
[10:19:52.008]                 NAMES <- toupper(removed)
[10:19:52.008]                 for (kk in seq_along(NAMES)) {
[10:19:52.008]                   name <- removed[[kk]]
[10:19:52.008]                   NAME <- NAMES[[kk]]
[10:19:52.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.008]                     next
[10:19:52.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.008]                 }
[10:19:52.008]                 if (length(args) > 0) 
[10:19:52.008]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.008]             }
[10:19:52.008]             else {
[10:19:52.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.008]             }
[10:19:52.008]             {
[10:19:52.008]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.008]                   0L) {
[10:19:52.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.008]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.008]                   base::options(opts)
[10:19:52.008]                 }
[10:19:52.008]                 {
[10:19:52.008]                   {
[10:19:52.008]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.008]                     NULL
[10:19:52.008]                   }
[10:19:52.008]                   options(future.plan = NULL)
[10:19:52.008]                   if (is.na(NA_character_)) 
[10:19:52.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.008]                     .init = FALSE)
[10:19:52.008]                 }
[10:19:52.008]             }
[10:19:52.008]         }
[10:19:52.008]     })
[10:19:52.008]     if (TRUE) {
[10:19:52.008]         base::sink(type = "output", split = FALSE)
[10:19:52.008]         if (TRUE) {
[10:19:52.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.008]         }
[10:19:52.008]         else {
[10:19:52.008]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.008]         }
[10:19:52.008]         base::close(...future.stdout)
[10:19:52.008]         ...future.stdout <- NULL
[10:19:52.008]     }
[10:19:52.008]     ...future.result$conditions <- ...future.conditions
[10:19:52.008]     ...future.result$finished <- base::Sys.time()
[10:19:52.008]     ...future.result
[10:19:52.008] }
[10:19:52.011] assign_globals() ...
[10:19:52.011] List of 11
[10:19:52.011]  $ ...future.FUN            :function (x, ...)  
[10:19:52.011]  $ x_FUN                    :function (x)  
[10:19:52.011]  $ times                    : int 0
[10:19:52.011]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.011]  $ stop_if_not              :function (...)  
[10:19:52.011]  $ dim                      : NULL
[10:19:52.011]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.011]  $ future.call.arguments    : list()
[10:19:52.011]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.011]  $ ...future.elements_ii    :List of 5
[10:19:52.011]   ..$ : int 1
[10:19:52.011]   ..$ : int 2
[10:19:52.011]   ..$ : int 3
[10:19:52.011]   ..$ : int 4
[10:19:52.011]   ..$ : int 5
[10:19:52.011]  $ ...future.seeds_ii       : NULL
[10:19:52.011]  $ ...future.globals.maxSize: NULL
[10:19:52.011]  - attr(*, "where")=List of 11
[10:19:52.011]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.011]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.011]  - attr(*, "resolved")= logi FALSE
[10:19:52.011]  - attr(*, "total_size")= num 23490
[10:19:52.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.011]  - attr(*, "already-done")= logi TRUE
[10:19:52.019] - copied ‘...future.FUN’ to environment
[10:19:52.019] - reassign environment for ‘x_FUN’
[10:19:52.019] - copied ‘x_FUN’ to environment
[10:19:52.019] - copied ‘times’ to environment
[10:19:52.020] - copied ‘stopf’ to environment
[10:19:52.020] - copied ‘stop_if_not’ to environment
[10:19:52.020] - copied ‘dim’ to environment
[10:19:52.020] - copied ‘valid_types’ to environment
[10:19:52.020] - copied ‘future.call.arguments’ to environment
[10:19:52.020] - copied ‘...future.elements_ii’ to environment
[10:19:52.020] - copied ‘...future.seeds_ii’ to environment
[10:19:52.020] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.020] assign_globals() ... done
[10:19:52.020] requestCore(): workers = 2
[10:19:52.022] MulticoreFuture started
[10:19:52.023] - Launch lazy future ... done
[10:19:52.023] run() for ‘MulticoreFuture’ ... done
[10:19:52.024] Created future:
[10:19:52.024] plan(): Setting new future strategy stack:
[10:19:52.024] List of future strategies:
[10:19:52.024] 1. sequential:
[10:19:52.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.024]    - tweaked: FALSE
[10:19:52.024]    - call: NULL
[10:19:52.025] plan(): nbrOfWorkers() = 1
[10:19:52.027] plan(): Setting new future strategy stack:
[10:19:52.027] List of future strategies:
[10:19:52.027] 1. multicore:
[10:19:52.027]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.027]    - tweaked: FALSE
[10:19:52.027]    - call: plan(strategy)
[10:19:52.030] plan(): nbrOfWorkers() = 2
[10:19:52.024] MulticoreFuture:
[10:19:52.024] Label: ‘future_vapply-1’
[10:19:52.024] Expression:
[10:19:52.024] {
[10:19:52.024]     do.call(function(...) {
[10:19:52.024]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.024]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.024]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.024]             on.exit(options(oopts), add = TRUE)
[10:19:52.024]         }
[10:19:52.024]         {
[10:19:52.024]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.024]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.024]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.024]             })
[10:19:52.024]         }
[10:19:52.024]     }, args = future.call.arguments)
[10:19:52.024] }
[10:19:52.024] Lazy evaluation: FALSE
[10:19:52.024] Asynchronous evaluation: TRUE
[10:19:52.024] Local evaluation: TRUE
[10:19:52.024] Environment: R_GlobalEnv
[10:19:52.024] Capture standard output: TRUE
[10:19:52.024] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.024] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.024] Packages: 1 packages (‘future.apply’)
[10:19:52.024] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.024] Resolved: TRUE
[10:19:52.024] Value: <not collected>
[10:19:52.024] Conditions captured: <none>
[10:19:52.024] Early signaling: FALSE
[10:19:52.024] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.024] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.031] Chunk #1 of 2 ... DONE
[10:19:52.031] Chunk #2 of 2 ...
[10:19:52.032]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.032] getGlobalsAndPackages() ...
[10:19:52.032] Searching for globals...
[10:19:52.032] 
[10:19:52.032] Searching for globals ... DONE
[10:19:52.033] - globals: [0] <none>
[10:19:52.033] getGlobalsAndPackages() ... DONE
[10:19:52.033]    + additional globals found: [n=0] 
[10:19:52.033]    + additional namespaces needed: [n=0] 
[10:19:52.033]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.033]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.033]  - seeds: <none>
[10:19:52.033]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.034] getGlobalsAndPackages() ...
[10:19:52.034] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.034] Resolving globals: FALSE
[10:19:52.034] Tweak future expression to call with '...' arguments ...
[10:19:52.034] {
[10:19:52.034]     do.call(function(...) {
[10:19:52.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.034]             on.exit(options(oopts), add = TRUE)
[10:19:52.034]         }
[10:19:52.034]         {
[10:19:52.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.034]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.034]             })
[10:19:52.034]         }
[10:19:52.034]     }, args = future.call.arguments)
[10:19:52.034] }
[10:19:52.035] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.036] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.036] - packages: [1] ‘future.apply’
[10:19:52.036] getGlobalsAndPackages() ... DONE
[10:19:52.037] run() for ‘Future’ ...
[10:19:52.037] - state: ‘created’
[10:19:52.037] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.045] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.045]   - Field: ‘label’
[10:19:52.046]   - Field: ‘local’
[10:19:52.046]   - Field: ‘owner’
[10:19:52.046]   - Field: ‘envir’
[10:19:52.046]   - Field: ‘workers’
[10:19:52.047]   - Field: ‘packages’
[10:19:52.047]   - Field: ‘gc’
[10:19:52.047]   - Field: ‘job’
[10:19:52.047]   - Field: ‘conditions’
[10:19:52.048]   - Field: ‘expr’
[10:19:52.048]   - Field: ‘uuid’
[10:19:52.048]   - Field: ‘seed’
[10:19:52.048]   - Field: ‘version’
[10:19:52.048]   - Field: ‘result’
[10:19:52.049]   - Field: ‘asynchronous’
[10:19:52.049]   - Field: ‘calls’
[10:19:52.049]   - Field: ‘globals’
[10:19:52.049]   - Field: ‘stdout’
[10:19:52.050]   - Field: ‘earlySignal’
[10:19:52.050]   - Field: ‘lazy’
[10:19:52.050]   - Field: ‘state’
[10:19:52.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.051] - Launch lazy future ...
[10:19:52.051] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.051] Packages needed by future strategies (n = 0): <none>
[10:19:52.052] {
[10:19:52.052]     {
[10:19:52.052]         {
[10:19:52.052]             ...future.startTime <- base::Sys.time()
[10:19:52.052]             {
[10:19:52.052]                 {
[10:19:52.052]                   {
[10:19:52.052]                     {
[10:19:52.052]                       {
[10:19:52.052]                         base::local({
[10:19:52.052]                           has_future <- base::requireNamespace("future", 
[10:19:52.052]                             quietly = TRUE)
[10:19:52.052]                           if (has_future) {
[10:19:52.052]                             ns <- base::getNamespace("future")
[10:19:52.052]                             version <- ns[[".package"]][["version"]]
[10:19:52.052]                             if (is.null(version)) 
[10:19:52.052]                               version <- utils::packageVersion("future")
[10:19:52.052]                           }
[10:19:52.052]                           else {
[10:19:52.052]                             version <- NULL
[10:19:52.052]                           }
[10:19:52.052]                           if (!has_future || version < "1.8.0") {
[10:19:52.052]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.052]                               "", base::R.version$version.string), 
[10:19:52.052]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.052]                                 base::R.version$platform, 8 * 
[10:19:52.052]                                   base::.Machine$sizeof.pointer), 
[10:19:52.052]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.052]                                 "release", "version")], collapse = " "), 
[10:19:52.052]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.052]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.052]                               info)
[10:19:52.052]                             info <- base::paste(info, collapse = "; ")
[10:19:52.052]                             if (!has_future) {
[10:19:52.052]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.052]                                 info)
[10:19:52.052]                             }
[10:19:52.052]                             else {
[10:19:52.052]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.052]                                 info, version)
[10:19:52.052]                             }
[10:19:52.052]                             base::stop(msg)
[10:19:52.052]                           }
[10:19:52.052]                         })
[10:19:52.052]                       }
[10:19:52.052]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.052]                       base::options(mc.cores = 1L)
[10:19:52.052]                     }
[10:19:52.052]                     base::local({
[10:19:52.052]                       for (pkg in "future.apply") {
[10:19:52.052]                         base::loadNamespace(pkg)
[10:19:52.052]                         base::library(pkg, character.only = TRUE)
[10:19:52.052]                       }
[10:19:52.052]                     })
[10:19:52.052]                   }
[10:19:52.052]                   ...future.strategy.old <- future::plan("list")
[10:19:52.052]                   options(future.plan = NULL)
[10:19:52.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.052]                 }
[10:19:52.052]                 ...future.workdir <- getwd()
[10:19:52.052]             }
[10:19:52.052]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.052]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.052]         }
[10:19:52.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.052]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.052]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.052]             base::names(...future.oldOptions))
[10:19:52.052]     }
[10:19:52.052]     if (FALSE) {
[10:19:52.052]     }
[10:19:52.052]     else {
[10:19:52.052]         if (TRUE) {
[10:19:52.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.052]                 open = "w")
[10:19:52.052]         }
[10:19:52.052]         else {
[10:19:52.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.052]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.052]         }
[10:19:52.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.052]             base::sink(type = "output", split = FALSE)
[10:19:52.052]             base::close(...future.stdout)
[10:19:52.052]         }, add = TRUE)
[10:19:52.052]     }
[10:19:52.052]     ...future.frame <- base::sys.nframe()
[10:19:52.052]     ...future.conditions <- base::list()
[10:19:52.052]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.052]     if (FALSE) {
[10:19:52.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.052]     }
[10:19:52.052]     ...future.result <- base::tryCatch({
[10:19:52.052]         base::withCallingHandlers({
[10:19:52.052]             ...future.value <- base::withVisible(base::local({
[10:19:52.052]                 withCallingHandlers({
[10:19:52.052]                   {
[10:19:52.052]                     do.call(function(...) {
[10:19:52.052]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.052]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.052]                         ...future.globals.maxSize)) {
[10:19:52.052]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.052]                         on.exit(options(oopts), add = TRUE)
[10:19:52.052]                       }
[10:19:52.052]                       {
[10:19:52.052]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.052]                           FUN = function(jj) {
[10:19:52.052]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.052]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.052]                           })
[10:19:52.052]                       }
[10:19:52.052]                     }, args = future.call.arguments)
[10:19:52.052]                   }
[10:19:52.052]                 }, immediateCondition = function(cond) {
[10:19:52.052]                   save_rds <- function (object, pathname, ...) 
[10:19:52.052]                   {
[10:19:52.052]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.052]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.052]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.052]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.052]                         fi_tmp[["mtime"]])
[10:19:52.052]                     }
[10:19:52.052]                     tryCatch({
[10:19:52.052]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.052]                     }, error = function(ex) {
[10:19:52.052]                       msg <- conditionMessage(ex)
[10:19:52.052]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.052]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.052]                         fi_tmp[["mtime"]], msg)
[10:19:52.052]                       ex$message <- msg
[10:19:52.052]                       stop(ex)
[10:19:52.052]                     })
[10:19:52.052]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.052]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.052]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.052]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.052]                       fi <- file.info(pathname)
[10:19:52.052]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.052]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.052]                         fi[["size"]], fi[["mtime"]])
[10:19:52.052]                       stop(msg)
[10:19:52.052]                     }
[10:19:52.052]                     invisible(pathname)
[10:19:52.052]                   }
[10:19:52.052]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.052]                     rootPath = tempdir()) 
[10:19:52.052]                   {
[10:19:52.052]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.052]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.052]                       tmpdir = path, fileext = ".rds")
[10:19:52.052]                     save_rds(obj, file)
[10:19:52.052]                   }
[10:19:52.052]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.052]                   {
[10:19:52.052]                     inherits <- base::inherits
[10:19:52.052]                     invokeRestart <- base::invokeRestart
[10:19:52.052]                     is.null <- base::is.null
[10:19:52.052]                     muffled <- FALSE
[10:19:52.052]                     if (inherits(cond, "message")) {
[10:19:52.052]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.052]                       if (muffled) 
[10:19:52.052]                         invokeRestart("muffleMessage")
[10:19:52.052]                     }
[10:19:52.052]                     else if (inherits(cond, "warning")) {
[10:19:52.052]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.052]                       if (muffled) 
[10:19:52.052]                         invokeRestart("muffleWarning")
[10:19:52.052]                     }
[10:19:52.052]                     else if (inherits(cond, "condition")) {
[10:19:52.052]                       if (!is.null(pattern)) {
[10:19:52.052]                         computeRestarts <- base::computeRestarts
[10:19:52.052]                         grepl <- base::grepl
[10:19:52.052]                         restarts <- computeRestarts(cond)
[10:19:52.052]                         for (restart in restarts) {
[10:19:52.052]                           name <- restart$name
[10:19:52.052]                           if (is.null(name)) 
[10:19:52.052]                             next
[10:19:52.052]                           if (!grepl(pattern, name)) 
[10:19:52.052]                             next
[10:19:52.052]                           invokeRestart(restart)
[10:19:52.052]                           muffled <- TRUE
[10:19:52.052]                           break
[10:19:52.052]                         }
[10:19:52.052]                       }
[10:19:52.052]                     }
[10:19:52.052]                     invisible(muffled)
[10:19:52.052]                   }
[10:19:52.052]                   muffleCondition(cond)
[10:19:52.052]                 })
[10:19:52.052]             }))
[10:19:52.052]             future::FutureResult(value = ...future.value$value, 
[10:19:52.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.052]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.052]                     ...future.globalenv.names))
[10:19:52.052]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.052]         }, condition = base::local({
[10:19:52.052]             c <- base::c
[10:19:52.052]             inherits <- base::inherits
[10:19:52.052]             invokeRestart <- base::invokeRestart
[10:19:52.052]             length <- base::length
[10:19:52.052]             list <- base::list
[10:19:52.052]             seq.int <- base::seq.int
[10:19:52.052]             signalCondition <- base::signalCondition
[10:19:52.052]             sys.calls <- base::sys.calls
[10:19:52.052]             `[[` <- base::`[[`
[10:19:52.052]             `+` <- base::`+`
[10:19:52.052]             `<<-` <- base::`<<-`
[10:19:52.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.052]                   3L)]
[10:19:52.052]             }
[10:19:52.052]             function(cond) {
[10:19:52.052]                 is_error <- inherits(cond, "error")
[10:19:52.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.052]                   NULL)
[10:19:52.052]                 if (is_error) {
[10:19:52.052]                   sessionInformation <- function() {
[10:19:52.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.052]                       search = base::search(), system = base::Sys.info())
[10:19:52.052]                   }
[10:19:52.052]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.052]                     cond$call), session = sessionInformation(), 
[10:19:52.052]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.052]                   signalCondition(cond)
[10:19:52.052]                 }
[10:19:52.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.052]                 "immediateCondition"))) {
[10:19:52.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.052]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.052]                   if (TRUE && !signal) {
[10:19:52.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.052]                     {
[10:19:52.052]                       inherits <- base::inherits
[10:19:52.052]                       invokeRestart <- base::invokeRestart
[10:19:52.052]                       is.null <- base::is.null
[10:19:52.052]                       muffled <- FALSE
[10:19:52.052]                       if (inherits(cond, "message")) {
[10:19:52.052]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.052]                         if (muffled) 
[10:19:52.052]                           invokeRestart("muffleMessage")
[10:19:52.052]                       }
[10:19:52.052]                       else if (inherits(cond, "warning")) {
[10:19:52.052]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.052]                         if (muffled) 
[10:19:52.052]                           invokeRestart("muffleWarning")
[10:19:52.052]                       }
[10:19:52.052]                       else if (inherits(cond, "condition")) {
[10:19:52.052]                         if (!is.null(pattern)) {
[10:19:52.052]                           computeRestarts <- base::computeRestarts
[10:19:52.052]                           grepl <- base::grepl
[10:19:52.052]                           restarts <- computeRestarts(cond)
[10:19:52.052]                           for (restart in restarts) {
[10:19:52.052]                             name <- restart$name
[10:19:52.052]                             if (is.null(name)) 
[10:19:52.052]                               next
[10:19:52.052]                             if (!grepl(pattern, name)) 
[10:19:52.052]                               next
[10:19:52.052]                             invokeRestart(restart)
[10:19:52.052]                             muffled <- TRUE
[10:19:52.052]                             break
[10:19:52.052]                           }
[10:19:52.052]                         }
[10:19:52.052]                       }
[10:19:52.052]                       invisible(muffled)
[10:19:52.052]                     }
[10:19:52.052]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.052]                   }
[10:19:52.052]                 }
[10:19:52.052]                 else {
[10:19:52.052]                   if (TRUE) {
[10:19:52.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.052]                     {
[10:19:52.052]                       inherits <- base::inherits
[10:19:52.052]                       invokeRestart <- base::invokeRestart
[10:19:52.052]                       is.null <- base::is.null
[10:19:52.052]                       muffled <- FALSE
[10:19:52.052]                       if (inherits(cond, "message")) {
[10:19:52.052]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.052]                         if (muffled) 
[10:19:52.052]                           invokeRestart("muffleMessage")
[10:19:52.052]                       }
[10:19:52.052]                       else if (inherits(cond, "warning")) {
[10:19:52.052]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.052]                         if (muffled) 
[10:19:52.052]                           invokeRestart("muffleWarning")
[10:19:52.052]                       }
[10:19:52.052]                       else if (inherits(cond, "condition")) {
[10:19:52.052]                         if (!is.null(pattern)) {
[10:19:52.052]                           computeRestarts <- base::computeRestarts
[10:19:52.052]                           grepl <- base::grepl
[10:19:52.052]                           restarts <- computeRestarts(cond)
[10:19:52.052]                           for (restart in restarts) {
[10:19:52.052]                             name <- restart$name
[10:19:52.052]                             if (is.null(name)) 
[10:19:52.052]                               next
[10:19:52.052]                             if (!grepl(pattern, name)) 
[10:19:52.052]                               next
[10:19:52.052]                             invokeRestart(restart)
[10:19:52.052]                             muffled <- TRUE
[10:19:52.052]                             break
[10:19:52.052]                           }
[10:19:52.052]                         }
[10:19:52.052]                       }
[10:19:52.052]                       invisible(muffled)
[10:19:52.052]                     }
[10:19:52.052]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.052]                   }
[10:19:52.052]                 }
[10:19:52.052]             }
[10:19:52.052]         }))
[10:19:52.052]     }, error = function(ex) {
[10:19:52.052]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.052]                 ...future.rng), started = ...future.startTime, 
[10:19:52.052]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.052]             version = "1.8"), class = "FutureResult")
[10:19:52.052]     }, finally = {
[10:19:52.052]         if (!identical(...future.workdir, getwd())) 
[10:19:52.052]             setwd(...future.workdir)
[10:19:52.052]         {
[10:19:52.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.052]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.052]             }
[10:19:52.052]             base::options(...future.oldOptions)
[10:19:52.052]             if (.Platform$OS.type == "windows") {
[10:19:52.052]                 old_names <- names(...future.oldEnvVars)
[10:19:52.052]                 envs <- base::Sys.getenv()
[10:19:52.052]                 names <- names(envs)
[10:19:52.052]                 common <- intersect(names, old_names)
[10:19:52.052]                 added <- setdiff(names, old_names)
[10:19:52.052]                 removed <- setdiff(old_names, names)
[10:19:52.052]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.052]                   envs[common]]
[10:19:52.052]                 NAMES <- toupper(changed)
[10:19:52.052]                 args <- list()
[10:19:52.052]                 for (kk in seq_along(NAMES)) {
[10:19:52.052]                   name <- changed[[kk]]
[10:19:52.052]                   NAME <- NAMES[[kk]]
[10:19:52.052]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.052]                     next
[10:19:52.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.052]                 }
[10:19:52.052]                 NAMES <- toupper(added)
[10:19:52.052]                 for (kk in seq_along(NAMES)) {
[10:19:52.052]                   name <- added[[kk]]
[10:19:52.052]                   NAME <- NAMES[[kk]]
[10:19:52.052]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.052]                     next
[10:19:52.052]                   args[[name]] <- ""
[10:19:52.052]                 }
[10:19:52.052]                 NAMES <- toupper(removed)
[10:19:52.052]                 for (kk in seq_along(NAMES)) {
[10:19:52.052]                   name <- removed[[kk]]
[10:19:52.052]                   NAME <- NAMES[[kk]]
[10:19:52.052]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.052]                     next
[10:19:52.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.052]                 }
[10:19:52.052]                 if (length(args) > 0) 
[10:19:52.052]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.052]             }
[10:19:52.052]             else {
[10:19:52.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.052]             }
[10:19:52.052]             {
[10:19:52.052]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.052]                   0L) {
[10:19:52.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.052]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.052]                   base::options(opts)
[10:19:52.052]                 }
[10:19:52.052]                 {
[10:19:52.052]                   {
[10:19:52.052]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.052]                     NULL
[10:19:52.052]                   }
[10:19:52.052]                   options(future.plan = NULL)
[10:19:52.052]                   if (is.na(NA_character_)) 
[10:19:52.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.052]                     .init = FALSE)
[10:19:52.052]                 }
[10:19:52.052]             }
[10:19:52.052]         }
[10:19:52.052]     })
[10:19:52.052]     if (TRUE) {
[10:19:52.052]         base::sink(type = "output", split = FALSE)
[10:19:52.052]         if (TRUE) {
[10:19:52.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.052]         }
[10:19:52.052]         else {
[10:19:52.052]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.052]         }
[10:19:52.052]         base::close(...future.stdout)
[10:19:52.052]         ...future.stdout <- NULL
[10:19:52.052]     }
[10:19:52.052]     ...future.result$conditions <- ...future.conditions
[10:19:52.052]     ...future.result$finished <- base::Sys.time()
[10:19:52.052]     ...future.result
[10:19:52.052] }
[10:19:52.055] assign_globals() ...
[10:19:52.055] List of 11
[10:19:52.055]  $ ...future.FUN            :function (x, ...)  
[10:19:52.055]  $ x_FUN                    :function (x)  
[10:19:52.055]  $ times                    : int 0
[10:19:52.055]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.055]  $ stop_if_not              :function (...)  
[10:19:52.055]  $ dim                      : NULL
[10:19:52.055]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.055]  $ future.call.arguments    : list()
[10:19:52.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.055]  $ ...future.elements_ii    :List of 5
[10:19:52.055]   ..$ : int 6
[10:19:52.055]   ..$ : int 7
[10:19:52.055]   ..$ : int 8
[10:19:52.055]   ..$ : int 9
[10:19:52.055]   ..$ : int 10
[10:19:52.055]  $ ...future.seeds_ii       : NULL
[10:19:52.055]  $ ...future.globals.maxSize: NULL
[10:19:52.055]  - attr(*, "where")=List of 11
[10:19:52.055]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.055]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.055]  - attr(*, "resolved")= logi FALSE
[10:19:52.055]  - attr(*, "total_size")= num 23490
[10:19:52.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.055]  - attr(*, "already-done")= logi TRUE
[10:19:52.066] - copied ‘...future.FUN’ to environment
[10:19:52.067] - reassign environment for ‘x_FUN’
[10:19:52.067] - copied ‘x_FUN’ to environment
[10:19:52.067] - copied ‘times’ to environment
[10:19:52.067] - copied ‘stopf’ to environment
[10:19:52.067] - copied ‘stop_if_not’ to environment
[10:19:52.067] - copied ‘dim’ to environment
[10:19:52.067] - copied ‘valid_types’ to environment
[10:19:52.067] - copied ‘future.call.arguments’ to environment
[10:19:52.067] - copied ‘...future.elements_ii’ to environment
[10:19:52.068] - copied ‘...future.seeds_ii’ to environment
[10:19:52.068] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.068] assign_globals() ... done
[10:19:52.068] requestCore(): workers = 2
[10:19:52.070] MulticoreFuture started
[10:19:52.070] - Launch lazy future ... done
[10:19:52.071] run() for ‘MulticoreFuture’ ... done
[10:19:52.071] Created future:
[10:19:52.071] plan(): Setting new future strategy stack:
[10:19:52.072] List of future strategies:
[10:19:52.072] 1. sequential:
[10:19:52.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.072]    - tweaked: FALSE
[10:19:52.072]    - call: NULL
[10:19:52.072] plan(): nbrOfWorkers() = 1
[10:19:52.075] plan(): Setting new future strategy stack:
[10:19:52.075] List of future strategies:
[10:19:52.075] 1. multicore:
[10:19:52.075]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.075]    - tweaked: FALSE
[10:19:52.075]    - call: plan(strategy)
[10:19:52.078] plan(): nbrOfWorkers() = 2
[10:19:52.071] MulticoreFuture:
[10:19:52.071] Label: ‘future_vapply-2’
[10:19:52.071] Expression:
[10:19:52.071] {
[10:19:52.071]     do.call(function(...) {
[10:19:52.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.071]             on.exit(options(oopts), add = TRUE)
[10:19:52.071]         }
[10:19:52.071]         {
[10:19:52.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.071]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.071]             })
[10:19:52.071]         }
[10:19:52.071]     }, args = future.call.arguments)
[10:19:52.071] }
[10:19:52.071] Lazy evaluation: FALSE
[10:19:52.071] Asynchronous evaluation: TRUE
[10:19:52.071] Local evaluation: TRUE
[10:19:52.071] Environment: R_GlobalEnv
[10:19:52.071] Capture standard output: TRUE
[10:19:52.071] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.071] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.071] Packages: 1 packages (‘future.apply’)
[10:19:52.071] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.071] Resolved: TRUE
[10:19:52.071] Value: <not collected>
[10:19:52.071] Conditions captured: <none>
[10:19:52.071] Early signaling: FALSE
[10:19:52.071] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.071] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.079] Chunk #2 of 2 ... DONE
[10:19:52.079] Launching 2 futures (chunks) ... DONE
[10:19:52.079] Resolving 2 futures (chunks) ...
[10:19:52.079] resolve() on list ...
[10:19:52.079]  recursive: 0
[10:19:52.079]  length: 2
[10:19:52.080] 
[10:19:52.080] Future #1
[10:19:52.080] result() for MulticoreFuture ...
[10:19:52.081] result() for MulticoreFuture ...
[10:19:52.081] result() for MulticoreFuture ... done
[10:19:52.081] result() for MulticoreFuture ... done
[10:19:52.081] result() for MulticoreFuture ...
[10:19:52.081] result() for MulticoreFuture ... done
[10:19:52.082] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.082] - nx: 2
[10:19:52.082] - relay: TRUE
[10:19:52.082] - stdout: TRUE
[10:19:52.082] - signal: TRUE
[10:19:52.082] - resignal: FALSE
[10:19:52.082] - force: TRUE
[10:19:52.082] - relayed: [n=2] FALSE, FALSE
[10:19:52.083] - queued futures: [n=2] FALSE, FALSE
[10:19:52.083]  - until=1
[10:19:52.083]  - relaying element #1
[10:19:52.083] result() for MulticoreFuture ...
[10:19:52.083] result() for MulticoreFuture ... done
[10:19:52.083] result() for MulticoreFuture ...
[10:19:52.083] result() for MulticoreFuture ... done
[10:19:52.084] result() for MulticoreFuture ...
[10:19:52.084] result() for MulticoreFuture ... done
[10:19:52.084] result() for MulticoreFuture ...
[10:19:52.084] result() for MulticoreFuture ... done
[10:19:52.084] - relayed: [n=2] TRUE, FALSE
[10:19:52.084] - queued futures: [n=2] TRUE, FALSE
[10:19:52.088] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.089]  length: 1 (resolved future 1)
[10:19:52.089] Future #2
[10:19:52.090] result() for MulticoreFuture ...
[10:19:52.091] result() for MulticoreFuture ...
[10:19:52.091] result() for MulticoreFuture ... done
[10:19:52.091] result() for MulticoreFuture ... done
[10:19:52.092] result() for MulticoreFuture ...
[10:19:52.092] result() for MulticoreFuture ... done
[10:19:52.092] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.092] - nx: 2
[10:19:52.093] - relay: TRUE
[10:19:52.093] - stdout: TRUE
[10:19:52.093] - signal: TRUE
[10:19:52.093] - resignal: FALSE
[10:19:52.093] - force: TRUE
[10:19:52.093] - relayed: [n=2] TRUE, FALSE
[10:19:52.094] - queued futures: [n=2] TRUE, FALSE
[10:19:52.094]  - until=2
[10:19:52.094]  - relaying element #2
[10:19:52.094] result() for MulticoreFuture ...
[10:19:52.094] result() for MulticoreFuture ... done
[10:19:52.094] result() for MulticoreFuture ...
[10:19:52.095] result() for MulticoreFuture ... done
[10:19:52.095] result() for MulticoreFuture ...
[10:19:52.095] result() for MulticoreFuture ... done
[10:19:52.095] result() for MulticoreFuture ...
[10:19:52.095] result() for MulticoreFuture ... done
[10:19:52.095] - relayed: [n=2] TRUE, TRUE
[10:19:52.096] - queued futures: [n=2] TRUE, TRUE
[10:19:52.096] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.096]  length: 0 (resolved future 2)
[10:19:52.096] Relaying remaining futures
[10:19:52.096] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.096] - nx: 2
[10:19:52.096] - relay: TRUE
[10:19:52.096] - stdout: TRUE
[10:19:52.097] - signal: TRUE
[10:19:52.097] - resignal: FALSE
[10:19:52.097] - force: TRUE
[10:19:52.097] - relayed: [n=2] TRUE, TRUE
[10:19:52.097] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:52.097] - relayed: [n=2] TRUE, TRUE
[10:19:52.097] - queued futures: [n=2] TRUE, TRUE
[10:19:52.097] signalConditionsASAP(NULL, pos=0) ... done
[10:19:52.097] resolve() on list ... DONE
[10:19:52.097] result() for MulticoreFuture ...
[10:19:52.098] result() for MulticoreFuture ... done
[10:19:52.098] result() for MulticoreFuture ...
[10:19:52.098] result() for MulticoreFuture ... done
[10:19:52.098] result() for MulticoreFuture ...
[10:19:52.098] result() for MulticoreFuture ... done
[10:19:52.098] result() for MulticoreFuture ...
[10:19:52.098] result() for MulticoreFuture ... done
[10:19:52.098]  - Number of value chunks collected: 2
[10:19:52.099] Resolving 2 futures (chunks) ... DONE
[10:19:52.099] Reducing values from 2 chunks ...
[10:19:52.099]  - Number of values collected after concatenation: 10
[10:19:52.099]  - Number of values expected: 10
[10:19:52.099] Reducing values from 2 chunks ... DONE
[10:19:52.099] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:19:52.100] future_lapply() ...
[10:19:52.104] Number of chunks: 2
[10:19:52.104] getGlobalsAndPackagesXApply() ...
[10:19:52.104]  - future.globals: TRUE
[10:19:52.105] getGlobalsAndPackages() ...
[10:19:52.105] Searching for globals...
[10:19:52.109] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:19:52.110] Searching for globals ... DONE
[10:19:52.110] Resolving globals: FALSE
[10:19:52.111] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[10:19:52.111] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:52.111] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.112] - packages: [1] ‘future.apply’
[10:19:52.112] getGlobalsAndPackages() ... DONE
[10:19:52.112]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.112]  - needed namespaces: [n=1] ‘future.apply’
[10:19:52.112] Finding globals ... DONE
[10:19:52.112]  - use_args: TRUE
[10:19:52.112]  - Getting '...' globals ...
[10:19:52.112] resolve() on list ...
[10:19:52.113]  recursive: 0
[10:19:52.113]  length: 1
[10:19:52.113]  elements: ‘...’
[10:19:52.113]  length: 0 (resolved future 1)
[10:19:52.113] resolve() on list ... DONE
[10:19:52.113]    - '...' content: [n=0] 
[10:19:52.113] List of 1
[10:19:52.113]  $ ...: list()
[10:19:52.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.113]  - attr(*, "where")=List of 1
[10:19:52.113]   ..$ ...:<environment: 0x55c69d88ec18> 
[10:19:52.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.113]  - attr(*, "resolved")= logi TRUE
[10:19:52.113]  - attr(*, "total_size")= num NA
[10:19:52.116]  - Getting '...' globals ... DONE
[10:19:52.116] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:52.116] List of 8
[10:19:52.116]  $ ...future.FUN:function (x, ...)  
[10:19:52.116]  $ x_FUN        :function (x)  
[10:19:52.116]  $ times        : int 0
[10:19:52.116]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.116]  $ stop_if_not  :function (...)  
[10:19:52.116]  $ dim          : NULL
[10:19:52.116]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:52.116]  $ ...          : list()
[10:19:52.116]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.116]  - attr(*, "where")=List of 8
[10:19:52.116]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:52.116]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:52.116]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:52.116]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:52.116]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:52.116]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:52.116]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:52.116]   ..$ ...          :<environment: 0x55c69d88ec18> 
[10:19:52.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.116]  - attr(*, "resolved")= logi FALSE
[10:19:52.116]  - attr(*, "total_size")= num 23453
[10:19:52.124] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:52.124] getGlobalsAndPackagesXApply() ... DONE
[10:19:52.124] Number of futures (= number of chunks): 2
[10:19:52.124] Launching 2 futures (chunks) ...
[10:19:52.125] Chunk #1 of 2 ...
[10:19:52.125]  - Finding globals in 'X' for chunk #1 ...
[10:19:52.125] getGlobalsAndPackages() ...
[10:19:52.125] Searching for globals...
[10:19:52.125] 
[10:19:52.125] Searching for globals ... DONE
[10:19:52.125] - globals: [0] <none>
[10:19:52.125] getGlobalsAndPackages() ... DONE
[10:19:52.125]    + additional globals found: [n=0] 
[10:19:52.126]    + additional namespaces needed: [n=0] 
[10:19:52.126]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:52.126]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.126]  - seeds: <none>
[10:19:52.126]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.126] getGlobalsAndPackages() ...
[10:19:52.126] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.126] Resolving globals: FALSE
[10:19:52.126] Tweak future expression to call with '...' arguments ...
[10:19:52.127] {
[10:19:52.127]     do.call(function(...) {
[10:19:52.127]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.127]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.127]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.127]             on.exit(options(oopts), add = TRUE)
[10:19:52.127]         }
[10:19:52.127]         {
[10:19:52.127]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.127]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.127]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.127]             })
[10:19:52.127]         }
[10:19:52.127]     }, args = future.call.arguments)
[10:19:52.127] }
[10:19:52.127] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.127] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.127] - packages: [1] ‘future.apply’
[10:19:52.128] getGlobalsAndPackages() ... DONE
[10:19:52.128] run() for ‘Future’ ...
[10:19:52.128] - state: ‘created’
[10:19:52.128] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.130] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.130]   - Field: ‘label’
[10:19:52.130]   - Field: ‘local’
[10:19:52.130]   - Field: ‘owner’
[10:19:52.130]   - Field: ‘envir’
[10:19:52.130]   - Field: ‘workers’
[10:19:52.131]   - Field: ‘packages’
[10:19:52.131]   - Field: ‘gc’
[10:19:52.131]   - Field: ‘job’
[10:19:52.131]   - Field: ‘conditions’
[10:19:52.131]   - Field: ‘expr’
[10:19:52.131]   - Field: ‘uuid’
[10:19:52.131]   - Field: ‘seed’
[10:19:52.131]   - Field: ‘version’
[10:19:52.131]   - Field: ‘result’
[10:19:52.131]   - Field: ‘asynchronous’
[10:19:52.131]   - Field: ‘calls’
[10:19:52.132]   - Field: ‘globals’
[10:19:52.132]   - Field: ‘stdout’
[10:19:52.132]   - Field: ‘earlySignal’
[10:19:52.132]   - Field: ‘lazy’
[10:19:52.132]   - Field: ‘state’
[10:19:52.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.132] - Launch lazy future ...
[10:19:52.132] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.132] Packages needed by future strategies (n = 0): <none>
[10:19:52.133] {
[10:19:52.133]     {
[10:19:52.133]         {
[10:19:52.133]             ...future.startTime <- base::Sys.time()
[10:19:52.133]             {
[10:19:52.133]                 {
[10:19:52.133]                   {
[10:19:52.133]                     {
[10:19:52.133]                       {
[10:19:52.133]                         base::local({
[10:19:52.133]                           has_future <- base::requireNamespace("future", 
[10:19:52.133]                             quietly = TRUE)
[10:19:52.133]                           if (has_future) {
[10:19:52.133]                             ns <- base::getNamespace("future")
[10:19:52.133]                             version <- ns[[".package"]][["version"]]
[10:19:52.133]                             if (is.null(version)) 
[10:19:52.133]                               version <- utils::packageVersion("future")
[10:19:52.133]                           }
[10:19:52.133]                           else {
[10:19:52.133]                             version <- NULL
[10:19:52.133]                           }
[10:19:52.133]                           if (!has_future || version < "1.8.0") {
[10:19:52.133]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.133]                               "", base::R.version$version.string), 
[10:19:52.133]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.133]                                 base::R.version$platform, 8 * 
[10:19:52.133]                                   base::.Machine$sizeof.pointer), 
[10:19:52.133]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.133]                                 "release", "version")], collapse = " "), 
[10:19:52.133]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.133]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.133]                               info)
[10:19:52.133]                             info <- base::paste(info, collapse = "; ")
[10:19:52.133]                             if (!has_future) {
[10:19:52.133]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.133]                                 info)
[10:19:52.133]                             }
[10:19:52.133]                             else {
[10:19:52.133]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.133]                                 info, version)
[10:19:52.133]                             }
[10:19:52.133]                             base::stop(msg)
[10:19:52.133]                           }
[10:19:52.133]                         })
[10:19:52.133]                       }
[10:19:52.133]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.133]                       base::options(mc.cores = 1L)
[10:19:52.133]                     }
[10:19:52.133]                     base::local({
[10:19:52.133]                       for (pkg in "future.apply") {
[10:19:52.133]                         base::loadNamespace(pkg)
[10:19:52.133]                         base::library(pkg, character.only = TRUE)
[10:19:52.133]                       }
[10:19:52.133]                     })
[10:19:52.133]                   }
[10:19:52.133]                   ...future.strategy.old <- future::plan("list")
[10:19:52.133]                   options(future.plan = NULL)
[10:19:52.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.133]                 }
[10:19:52.133]                 ...future.workdir <- getwd()
[10:19:52.133]             }
[10:19:52.133]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.133]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.133]         }
[10:19:52.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.133]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.133]             base::names(...future.oldOptions))
[10:19:52.133]     }
[10:19:52.133]     if (FALSE) {
[10:19:52.133]     }
[10:19:52.133]     else {
[10:19:52.133]         if (TRUE) {
[10:19:52.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.133]                 open = "w")
[10:19:52.133]         }
[10:19:52.133]         else {
[10:19:52.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.133]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.133]         }
[10:19:52.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.133]             base::sink(type = "output", split = FALSE)
[10:19:52.133]             base::close(...future.stdout)
[10:19:52.133]         }, add = TRUE)
[10:19:52.133]     }
[10:19:52.133]     ...future.frame <- base::sys.nframe()
[10:19:52.133]     ...future.conditions <- base::list()
[10:19:52.133]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.133]     if (FALSE) {
[10:19:52.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.133]     }
[10:19:52.133]     ...future.result <- base::tryCatch({
[10:19:52.133]         base::withCallingHandlers({
[10:19:52.133]             ...future.value <- base::withVisible(base::local({
[10:19:52.133]                 withCallingHandlers({
[10:19:52.133]                   {
[10:19:52.133]                     do.call(function(...) {
[10:19:52.133]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.133]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.133]                         ...future.globals.maxSize)) {
[10:19:52.133]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.133]                         on.exit(options(oopts), add = TRUE)
[10:19:52.133]                       }
[10:19:52.133]                       {
[10:19:52.133]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.133]                           FUN = function(jj) {
[10:19:52.133]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.133]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.133]                           })
[10:19:52.133]                       }
[10:19:52.133]                     }, args = future.call.arguments)
[10:19:52.133]                   }
[10:19:52.133]                 }, immediateCondition = function(cond) {
[10:19:52.133]                   save_rds <- function (object, pathname, ...) 
[10:19:52.133]                   {
[10:19:52.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.133]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.133]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.133]                         fi_tmp[["mtime"]])
[10:19:52.133]                     }
[10:19:52.133]                     tryCatch({
[10:19:52.133]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.133]                     }, error = function(ex) {
[10:19:52.133]                       msg <- conditionMessage(ex)
[10:19:52.133]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.133]                         fi_tmp[["mtime"]], msg)
[10:19:52.133]                       ex$message <- msg
[10:19:52.133]                       stop(ex)
[10:19:52.133]                     })
[10:19:52.133]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.133]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.133]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.133]                       fi <- file.info(pathname)
[10:19:52.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.133]                         fi[["size"]], fi[["mtime"]])
[10:19:52.133]                       stop(msg)
[10:19:52.133]                     }
[10:19:52.133]                     invisible(pathname)
[10:19:52.133]                   }
[10:19:52.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.133]                     rootPath = tempdir()) 
[10:19:52.133]                   {
[10:19:52.133]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.133]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.133]                       tmpdir = path, fileext = ".rds")
[10:19:52.133]                     save_rds(obj, file)
[10:19:52.133]                   }
[10:19:52.133]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.133]                   {
[10:19:52.133]                     inherits <- base::inherits
[10:19:52.133]                     invokeRestart <- base::invokeRestart
[10:19:52.133]                     is.null <- base::is.null
[10:19:52.133]                     muffled <- FALSE
[10:19:52.133]                     if (inherits(cond, "message")) {
[10:19:52.133]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.133]                       if (muffled) 
[10:19:52.133]                         invokeRestart("muffleMessage")
[10:19:52.133]                     }
[10:19:52.133]                     else if (inherits(cond, "warning")) {
[10:19:52.133]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.133]                       if (muffled) 
[10:19:52.133]                         invokeRestart("muffleWarning")
[10:19:52.133]                     }
[10:19:52.133]                     else if (inherits(cond, "condition")) {
[10:19:52.133]                       if (!is.null(pattern)) {
[10:19:52.133]                         computeRestarts <- base::computeRestarts
[10:19:52.133]                         grepl <- base::grepl
[10:19:52.133]                         restarts <- computeRestarts(cond)
[10:19:52.133]                         for (restart in restarts) {
[10:19:52.133]                           name <- restart$name
[10:19:52.133]                           if (is.null(name)) 
[10:19:52.133]                             next
[10:19:52.133]                           if (!grepl(pattern, name)) 
[10:19:52.133]                             next
[10:19:52.133]                           invokeRestart(restart)
[10:19:52.133]                           muffled <- TRUE
[10:19:52.133]                           break
[10:19:52.133]                         }
[10:19:52.133]                       }
[10:19:52.133]                     }
[10:19:52.133]                     invisible(muffled)
[10:19:52.133]                   }
[10:19:52.133]                   muffleCondition(cond)
[10:19:52.133]                 })
[10:19:52.133]             }))
[10:19:52.133]             future::FutureResult(value = ...future.value$value, 
[10:19:52.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.133]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.133]                     ...future.globalenv.names))
[10:19:52.133]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.133]         }, condition = base::local({
[10:19:52.133]             c <- base::c
[10:19:52.133]             inherits <- base::inherits
[10:19:52.133]             invokeRestart <- base::invokeRestart
[10:19:52.133]             length <- base::length
[10:19:52.133]             list <- base::list
[10:19:52.133]             seq.int <- base::seq.int
[10:19:52.133]             signalCondition <- base::signalCondition
[10:19:52.133]             sys.calls <- base::sys.calls
[10:19:52.133]             `[[` <- base::`[[`
[10:19:52.133]             `+` <- base::`+`
[10:19:52.133]             `<<-` <- base::`<<-`
[10:19:52.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.133]                   3L)]
[10:19:52.133]             }
[10:19:52.133]             function(cond) {
[10:19:52.133]                 is_error <- inherits(cond, "error")
[10:19:52.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.133]                   NULL)
[10:19:52.133]                 if (is_error) {
[10:19:52.133]                   sessionInformation <- function() {
[10:19:52.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.133]                       search = base::search(), system = base::Sys.info())
[10:19:52.133]                   }
[10:19:52.133]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.133]                     cond$call), session = sessionInformation(), 
[10:19:52.133]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.133]                   signalCondition(cond)
[10:19:52.133]                 }
[10:19:52.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.133]                 "immediateCondition"))) {
[10:19:52.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.133]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.133]                   if (TRUE && !signal) {
[10:19:52.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.133]                     {
[10:19:52.133]                       inherits <- base::inherits
[10:19:52.133]                       invokeRestart <- base::invokeRestart
[10:19:52.133]                       is.null <- base::is.null
[10:19:52.133]                       muffled <- FALSE
[10:19:52.133]                       if (inherits(cond, "message")) {
[10:19:52.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.133]                         if (muffled) 
[10:19:52.133]                           invokeRestart("muffleMessage")
[10:19:52.133]                       }
[10:19:52.133]                       else if (inherits(cond, "warning")) {
[10:19:52.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.133]                         if (muffled) 
[10:19:52.133]                           invokeRestart("muffleWarning")
[10:19:52.133]                       }
[10:19:52.133]                       else if (inherits(cond, "condition")) {
[10:19:52.133]                         if (!is.null(pattern)) {
[10:19:52.133]                           computeRestarts <- base::computeRestarts
[10:19:52.133]                           grepl <- base::grepl
[10:19:52.133]                           restarts <- computeRestarts(cond)
[10:19:52.133]                           for (restart in restarts) {
[10:19:52.133]                             name <- restart$name
[10:19:52.133]                             if (is.null(name)) 
[10:19:52.133]                               next
[10:19:52.133]                             if (!grepl(pattern, name)) 
[10:19:52.133]                               next
[10:19:52.133]                             invokeRestart(restart)
[10:19:52.133]                             muffled <- TRUE
[10:19:52.133]                             break
[10:19:52.133]                           }
[10:19:52.133]                         }
[10:19:52.133]                       }
[10:19:52.133]                       invisible(muffled)
[10:19:52.133]                     }
[10:19:52.133]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.133]                   }
[10:19:52.133]                 }
[10:19:52.133]                 else {
[10:19:52.133]                   if (TRUE) {
[10:19:52.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.133]                     {
[10:19:52.133]                       inherits <- base::inherits
[10:19:52.133]                       invokeRestart <- base::invokeRestart
[10:19:52.133]                       is.null <- base::is.null
[10:19:52.133]                       muffled <- FALSE
[10:19:52.133]                       if (inherits(cond, "message")) {
[10:19:52.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.133]                         if (muffled) 
[10:19:52.133]                           invokeRestart("muffleMessage")
[10:19:52.133]                       }
[10:19:52.133]                       else if (inherits(cond, "warning")) {
[10:19:52.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.133]                         if (muffled) 
[10:19:52.133]                           invokeRestart("muffleWarning")
[10:19:52.133]                       }
[10:19:52.133]                       else if (inherits(cond, "condition")) {
[10:19:52.133]                         if (!is.null(pattern)) {
[10:19:52.133]                           computeRestarts <- base::computeRestarts
[10:19:52.133]                           grepl <- base::grepl
[10:19:52.133]                           restarts <- computeRestarts(cond)
[10:19:52.133]                           for (restart in restarts) {
[10:19:52.133]                             name <- restart$name
[10:19:52.133]                             if (is.null(name)) 
[10:19:52.133]                               next
[10:19:52.133]                             if (!grepl(pattern, name)) 
[10:19:52.133]                               next
[10:19:52.133]                             invokeRestart(restart)
[10:19:52.133]                             muffled <- TRUE
[10:19:52.133]                             break
[10:19:52.133]                           }
[10:19:52.133]                         }
[10:19:52.133]                       }
[10:19:52.133]                       invisible(muffled)
[10:19:52.133]                     }
[10:19:52.133]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.133]                   }
[10:19:52.133]                 }
[10:19:52.133]             }
[10:19:52.133]         }))
[10:19:52.133]     }, error = function(ex) {
[10:19:52.133]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.133]                 ...future.rng), started = ...future.startTime, 
[10:19:52.133]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.133]             version = "1.8"), class = "FutureResult")
[10:19:52.133]     }, finally = {
[10:19:52.133]         if (!identical(...future.workdir, getwd())) 
[10:19:52.133]             setwd(...future.workdir)
[10:19:52.133]         {
[10:19:52.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.133]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.133]             }
[10:19:52.133]             base::options(...future.oldOptions)
[10:19:52.133]             if (.Platform$OS.type == "windows") {
[10:19:52.133]                 old_names <- names(...future.oldEnvVars)
[10:19:52.133]                 envs <- base::Sys.getenv()
[10:19:52.133]                 names <- names(envs)
[10:19:52.133]                 common <- intersect(names, old_names)
[10:19:52.133]                 added <- setdiff(names, old_names)
[10:19:52.133]                 removed <- setdiff(old_names, names)
[10:19:52.133]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.133]                   envs[common]]
[10:19:52.133]                 NAMES <- toupper(changed)
[10:19:52.133]                 args <- list()
[10:19:52.133]                 for (kk in seq_along(NAMES)) {
[10:19:52.133]                   name <- changed[[kk]]
[10:19:52.133]                   NAME <- NAMES[[kk]]
[10:19:52.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.133]                     next
[10:19:52.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.133]                 }
[10:19:52.133]                 NAMES <- toupper(added)
[10:19:52.133]                 for (kk in seq_along(NAMES)) {
[10:19:52.133]                   name <- added[[kk]]
[10:19:52.133]                   NAME <- NAMES[[kk]]
[10:19:52.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.133]                     next
[10:19:52.133]                   args[[name]] <- ""
[10:19:52.133]                 }
[10:19:52.133]                 NAMES <- toupper(removed)
[10:19:52.133]                 for (kk in seq_along(NAMES)) {
[10:19:52.133]                   name <- removed[[kk]]
[10:19:52.133]                   NAME <- NAMES[[kk]]
[10:19:52.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.133]                     next
[10:19:52.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.133]                 }
[10:19:52.133]                 if (length(args) > 0) 
[10:19:52.133]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.133]             }
[10:19:52.133]             else {
[10:19:52.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.133]             }
[10:19:52.133]             {
[10:19:52.133]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.133]                   0L) {
[10:19:52.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.133]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.133]                   base::options(opts)
[10:19:52.133]                 }
[10:19:52.133]                 {
[10:19:52.133]                   {
[10:19:52.133]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.133]                     NULL
[10:19:52.133]                   }
[10:19:52.133]                   options(future.plan = NULL)
[10:19:52.133]                   if (is.na(NA_character_)) 
[10:19:52.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.133]                     .init = FALSE)
[10:19:52.133]                 }
[10:19:52.133]             }
[10:19:52.133]         }
[10:19:52.133]     })
[10:19:52.133]     if (TRUE) {
[10:19:52.133]         base::sink(type = "output", split = FALSE)
[10:19:52.133]         if (TRUE) {
[10:19:52.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.133]         }
[10:19:52.133]         else {
[10:19:52.133]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.133]         }
[10:19:52.133]         base::close(...future.stdout)
[10:19:52.133]         ...future.stdout <- NULL
[10:19:52.133]     }
[10:19:52.133]     ...future.result$conditions <- ...future.conditions
[10:19:52.133]     ...future.result$finished <- base::Sys.time()
[10:19:52.133]     ...future.result
[10:19:52.133] }
[10:19:52.135] assign_globals() ...
[10:19:52.136] List of 11
[10:19:52.136]  $ ...future.FUN            :function (x, ...)  
[10:19:52.136]  $ x_FUN                    :function (x)  
[10:19:52.136]  $ times                    : int 0
[10:19:52.136]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.136]  $ stop_if_not              :function (...)  
[10:19:52.136]  $ dim                      : NULL
[10:19:52.136]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:52.136]  $ future.call.arguments    : list()
[10:19:52.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.136]  $ ...future.elements_ii    :List of 5
[10:19:52.136]   ..$ : int 1
[10:19:52.136]   ..$ : int 2
[10:19:52.136]   ..$ : int 3
[10:19:52.136]   ..$ : int 4
[10:19:52.136]   ..$ : int 5
[10:19:52.136]  $ ...future.seeds_ii       : NULL
[10:19:52.136]  $ ...future.globals.maxSize: NULL
[10:19:52.136]  - attr(*, "where")=List of 11
[10:19:52.136]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.136]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.136]  - attr(*, "resolved")= logi FALSE
[10:19:52.136]  - attr(*, "total_size")= num 23453
[10:19:52.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.136]  - attr(*, "already-done")= logi TRUE
[10:19:52.147] - copied ‘...future.FUN’ to environment
[10:19:52.147] - reassign environment for ‘x_FUN’
[10:19:52.147] - copied ‘x_FUN’ to environment
[10:19:52.147] - copied ‘times’ to environment
[10:19:52.147] - copied ‘stopf’ to environment
[10:19:52.147] - copied ‘stop_if_not’ to environment
[10:19:52.147] - copied ‘dim’ to environment
[10:19:52.147] - copied ‘valid_types’ to environment
[10:19:52.147] - copied ‘future.call.arguments’ to environment
[10:19:52.147] - copied ‘...future.elements_ii’ to environment
[10:19:52.148] - copied ‘...future.seeds_ii’ to environment
[10:19:52.148] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.148] assign_globals() ... done
[10:19:52.148] requestCore(): workers = 2
[10:19:52.150] MulticoreFuture started
[10:19:52.151] - Launch lazy future ... done
[10:19:52.151] run() for ‘MulticoreFuture’ ... done
[10:19:52.152] Created future:
[10:19:52.152] plan(): Setting new future strategy stack:
[10:19:52.152] List of future strategies:
[10:19:52.152] 1. sequential:
[10:19:52.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.152]    - tweaked: FALSE
[10:19:52.152]    - call: NULL
[10:19:52.153] plan(): nbrOfWorkers() = 1
[10:19:52.156] plan(): Setting new future strategy stack:
[10:19:52.156] List of future strategies:
[10:19:52.156] 1. multicore:
[10:19:52.156]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.156]    - tweaked: FALSE
[10:19:52.156]    - call: plan(strategy)
[10:19:52.159] plan(): nbrOfWorkers() = 2
[10:19:52.152] MulticoreFuture:
[10:19:52.152] Label: ‘future_vapply-1’
[10:19:52.152] Expression:
[10:19:52.152] {
[10:19:52.152]     do.call(function(...) {
[10:19:52.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.152]             on.exit(options(oopts), add = TRUE)
[10:19:52.152]         }
[10:19:52.152]         {
[10:19:52.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.152]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.152]             })
[10:19:52.152]         }
[10:19:52.152]     }, args = future.call.arguments)
[10:19:52.152] }
[10:19:52.152] Lazy evaluation: FALSE
[10:19:52.152] Asynchronous evaluation: TRUE
[10:19:52.152] Local evaluation: TRUE
[10:19:52.152] Environment: R_GlobalEnv
[10:19:52.152] Capture standard output: TRUE
[10:19:52.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.152] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.152] Packages: 1 packages (‘future.apply’)
[10:19:52.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.152] Resolved: TRUE
[10:19:52.152] Value: <not collected>
[10:19:52.152] Conditions captured: <none>
[10:19:52.152] Early signaling: FALSE
[10:19:52.152] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.152] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.161] Chunk #1 of 2 ... DONE
[10:19:52.161] Chunk #2 of 2 ...
[10:19:52.161]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.161] getGlobalsAndPackages() ...
[10:19:52.161] Searching for globals...
[10:19:52.162] 
[10:19:52.162] Searching for globals ... DONE
[10:19:52.162] - globals: [0] <none>
[10:19:52.162] getGlobalsAndPackages() ... DONE
[10:19:52.162]    + additional globals found: [n=0] 
[10:19:52.163]    + additional namespaces needed: [n=0] 
[10:19:52.163]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.163]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.163]  - seeds: <none>
[10:19:52.163]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.163] getGlobalsAndPackages() ...
[10:19:52.163] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.164] Resolving globals: FALSE
[10:19:52.164] Tweak future expression to call with '...' arguments ...
[10:19:52.164] {
[10:19:52.164]     do.call(function(...) {
[10:19:52.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.164]             on.exit(options(oopts), add = TRUE)
[10:19:52.164]         }
[10:19:52.164]         {
[10:19:52.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.164]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.164]             })
[10:19:52.164]         }
[10:19:52.164]     }, args = future.call.arguments)
[10:19:52.164] }
[10:19:52.165] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.165] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.166] - packages: [1] ‘future.apply’
[10:19:52.166] getGlobalsAndPackages() ... DONE
[10:19:52.166] run() for ‘Future’ ...
[10:19:52.167] - state: ‘created’
[10:19:52.167] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.170]   - Field: ‘label’
[10:19:52.170]   - Field: ‘local’
[10:19:52.170]   - Field: ‘owner’
[10:19:52.170]   - Field: ‘envir’
[10:19:52.170]   - Field: ‘workers’
[10:19:52.170]   - Field: ‘packages’
[10:19:52.171]   - Field: ‘gc’
[10:19:52.171]   - Field: ‘job’
[10:19:52.171]   - Field: ‘conditions’
[10:19:52.171]   - Field: ‘expr’
[10:19:52.171]   - Field: ‘uuid’
[10:19:52.171]   - Field: ‘seed’
[10:19:52.171]   - Field: ‘version’
[10:19:52.172]   - Field: ‘result’
[10:19:52.172]   - Field: ‘asynchronous’
[10:19:52.172]   - Field: ‘calls’
[10:19:52.172]   - Field: ‘globals’
[10:19:52.172]   - Field: ‘stdout’
[10:19:52.172]   - Field: ‘earlySignal’
[10:19:52.172]   - Field: ‘lazy’
[10:19:52.173]   - Field: ‘state’
[10:19:52.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.173] - Launch lazy future ...
[10:19:52.173] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.174] Packages needed by future strategies (n = 0): <none>
[10:19:52.174] {
[10:19:52.174]     {
[10:19:52.174]         {
[10:19:52.174]             ...future.startTime <- base::Sys.time()
[10:19:52.174]             {
[10:19:52.174]                 {
[10:19:52.174]                   {
[10:19:52.174]                     {
[10:19:52.174]                       {
[10:19:52.174]                         base::local({
[10:19:52.174]                           has_future <- base::requireNamespace("future", 
[10:19:52.174]                             quietly = TRUE)
[10:19:52.174]                           if (has_future) {
[10:19:52.174]                             ns <- base::getNamespace("future")
[10:19:52.174]                             version <- ns[[".package"]][["version"]]
[10:19:52.174]                             if (is.null(version)) 
[10:19:52.174]                               version <- utils::packageVersion("future")
[10:19:52.174]                           }
[10:19:52.174]                           else {
[10:19:52.174]                             version <- NULL
[10:19:52.174]                           }
[10:19:52.174]                           if (!has_future || version < "1.8.0") {
[10:19:52.174]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.174]                               "", base::R.version$version.string), 
[10:19:52.174]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.174]                                 base::R.version$platform, 8 * 
[10:19:52.174]                                   base::.Machine$sizeof.pointer), 
[10:19:52.174]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.174]                                 "release", "version")], collapse = " "), 
[10:19:52.174]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.174]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.174]                               info)
[10:19:52.174]                             info <- base::paste(info, collapse = "; ")
[10:19:52.174]                             if (!has_future) {
[10:19:52.174]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.174]                                 info)
[10:19:52.174]                             }
[10:19:52.174]                             else {
[10:19:52.174]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.174]                                 info, version)
[10:19:52.174]                             }
[10:19:52.174]                             base::stop(msg)
[10:19:52.174]                           }
[10:19:52.174]                         })
[10:19:52.174]                       }
[10:19:52.174]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.174]                       base::options(mc.cores = 1L)
[10:19:52.174]                     }
[10:19:52.174]                     base::local({
[10:19:52.174]                       for (pkg in "future.apply") {
[10:19:52.174]                         base::loadNamespace(pkg)
[10:19:52.174]                         base::library(pkg, character.only = TRUE)
[10:19:52.174]                       }
[10:19:52.174]                     })
[10:19:52.174]                   }
[10:19:52.174]                   ...future.strategy.old <- future::plan("list")
[10:19:52.174]                   options(future.plan = NULL)
[10:19:52.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.174]                 }
[10:19:52.174]                 ...future.workdir <- getwd()
[10:19:52.174]             }
[10:19:52.174]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.174]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.174]         }
[10:19:52.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.174]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.174]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.174]             base::names(...future.oldOptions))
[10:19:52.174]     }
[10:19:52.174]     if (FALSE) {
[10:19:52.174]     }
[10:19:52.174]     else {
[10:19:52.174]         if (TRUE) {
[10:19:52.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.174]                 open = "w")
[10:19:52.174]         }
[10:19:52.174]         else {
[10:19:52.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.174]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.174]         }
[10:19:52.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.174]             base::sink(type = "output", split = FALSE)
[10:19:52.174]             base::close(...future.stdout)
[10:19:52.174]         }, add = TRUE)
[10:19:52.174]     }
[10:19:52.174]     ...future.frame <- base::sys.nframe()
[10:19:52.174]     ...future.conditions <- base::list()
[10:19:52.174]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.174]     if (FALSE) {
[10:19:52.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.174]     }
[10:19:52.174]     ...future.result <- base::tryCatch({
[10:19:52.174]         base::withCallingHandlers({
[10:19:52.174]             ...future.value <- base::withVisible(base::local({
[10:19:52.174]                 withCallingHandlers({
[10:19:52.174]                   {
[10:19:52.174]                     do.call(function(...) {
[10:19:52.174]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.174]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.174]                         ...future.globals.maxSize)) {
[10:19:52.174]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.174]                         on.exit(options(oopts), add = TRUE)
[10:19:52.174]                       }
[10:19:52.174]                       {
[10:19:52.174]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.174]                           FUN = function(jj) {
[10:19:52.174]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.174]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.174]                           })
[10:19:52.174]                       }
[10:19:52.174]                     }, args = future.call.arguments)
[10:19:52.174]                   }
[10:19:52.174]                 }, immediateCondition = function(cond) {
[10:19:52.174]                   save_rds <- function (object, pathname, ...) 
[10:19:52.174]                   {
[10:19:52.174]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.174]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.174]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.174]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.174]                         fi_tmp[["mtime"]])
[10:19:52.174]                     }
[10:19:52.174]                     tryCatch({
[10:19:52.174]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.174]                     }, error = function(ex) {
[10:19:52.174]                       msg <- conditionMessage(ex)
[10:19:52.174]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.174]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.174]                         fi_tmp[["mtime"]], msg)
[10:19:52.174]                       ex$message <- msg
[10:19:52.174]                       stop(ex)
[10:19:52.174]                     })
[10:19:52.174]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.174]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.174]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.174]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.174]                       fi <- file.info(pathname)
[10:19:52.174]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.174]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.174]                         fi[["size"]], fi[["mtime"]])
[10:19:52.174]                       stop(msg)
[10:19:52.174]                     }
[10:19:52.174]                     invisible(pathname)
[10:19:52.174]                   }
[10:19:52.174]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.174]                     rootPath = tempdir()) 
[10:19:52.174]                   {
[10:19:52.174]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.174]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.174]                       tmpdir = path, fileext = ".rds")
[10:19:52.174]                     save_rds(obj, file)
[10:19:52.174]                   }
[10:19:52.174]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.174]                   {
[10:19:52.174]                     inherits <- base::inherits
[10:19:52.174]                     invokeRestart <- base::invokeRestart
[10:19:52.174]                     is.null <- base::is.null
[10:19:52.174]                     muffled <- FALSE
[10:19:52.174]                     if (inherits(cond, "message")) {
[10:19:52.174]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.174]                       if (muffled) 
[10:19:52.174]                         invokeRestart("muffleMessage")
[10:19:52.174]                     }
[10:19:52.174]                     else if (inherits(cond, "warning")) {
[10:19:52.174]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.174]                       if (muffled) 
[10:19:52.174]                         invokeRestart("muffleWarning")
[10:19:52.174]                     }
[10:19:52.174]                     else if (inherits(cond, "condition")) {
[10:19:52.174]                       if (!is.null(pattern)) {
[10:19:52.174]                         computeRestarts <- base::computeRestarts
[10:19:52.174]                         grepl <- base::grepl
[10:19:52.174]                         restarts <- computeRestarts(cond)
[10:19:52.174]                         for (restart in restarts) {
[10:19:52.174]                           name <- restart$name
[10:19:52.174]                           if (is.null(name)) 
[10:19:52.174]                             next
[10:19:52.174]                           if (!grepl(pattern, name)) 
[10:19:52.174]                             next
[10:19:52.174]                           invokeRestart(restart)
[10:19:52.174]                           muffled <- TRUE
[10:19:52.174]                           break
[10:19:52.174]                         }
[10:19:52.174]                       }
[10:19:52.174]                     }
[10:19:52.174]                     invisible(muffled)
[10:19:52.174]                   }
[10:19:52.174]                   muffleCondition(cond)
[10:19:52.174]                 })
[10:19:52.174]             }))
[10:19:52.174]             future::FutureResult(value = ...future.value$value, 
[10:19:52.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.174]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.174]                     ...future.globalenv.names))
[10:19:52.174]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.174]         }, condition = base::local({
[10:19:52.174]             c <- base::c
[10:19:52.174]             inherits <- base::inherits
[10:19:52.174]             invokeRestart <- base::invokeRestart
[10:19:52.174]             length <- base::length
[10:19:52.174]             list <- base::list
[10:19:52.174]             seq.int <- base::seq.int
[10:19:52.174]             signalCondition <- base::signalCondition
[10:19:52.174]             sys.calls <- base::sys.calls
[10:19:52.174]             `[[` <- base::`[[`
[10:19:52.174]             `+` <- base::`+`
[10:19:52.174]             `<<-` <- base::`<<-`
[10:19:52.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.174]                   3L)]
[10:19:52.174]             }
[10:19:52.174]             function(cond) {
[10:19:52.174]                 is_error <- inherits(cond, "error")
[10:19:52.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.174]                   NULL)
[10:19:52.174]                 if (is_error) {
[10:19:52.174]                   sessionInformation <- function() {
[10:19:52.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.174]                       search = base::search(), system = base::Sys.info())
[10:19:52.174]                   }
[10:19:52.174]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.174]                     cond$call), session = sessionInformation(), 
[10:19:52.174]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.174]                   signalCondition(cond)
[10:19:52.174]                 }
[10:19:52.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.174]                 "immediateCondition"))) {
[10:19:52.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.174]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.174]                   if (TRUE && !signal) {
[10:19:52.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.174]                     {
[10:19:52.174]                       inherits <- base::inherits
[10:19:52.174]                       invokeRestart <- base::invokeRestart
[10:19:52.174]                       is.null <- base::is.null
[10:19:52.174]                       muffled <- FALSE
[10:19:52.174]                       if (inherits(cond, "message")) {
[10:19:52.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.174]                         if (muffled) 
[10:19:52.174]                           invokeRestart("muffleMessage")
[10:19:52.174]                       }
[10:19:52.174]                       else if (inherits(cond, "warning")) {
[10:19:52.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.174]                         if (muffled) 
[10:19:52.174]                           invokeRestart("muffleWarning")
[10:19:52.174]                       }
[10:19:52.174]                       else if (inherits(cond, "condition")) {
[10:19:52.174]                         if (!is.null(pattern)) {
[10:19:52.174]                           computeRestarts <- base::computeRestarts
[10:19:52.174]                           grepl <- base::grepl
[10:19:52.174]                           restarts <- computeRestarts(cond)
[10:19:52.174]                           for (restart in restarts) {
[10:19:52.174]                             name <- restart$name
[10:19:52.174]                             if (is.null(name)) 
[10:19:52.174]                               next
[10:19:52.174]                             if (!grepl(pattern, name)) 
[10:19:52.174]                               next
[10:19:52.174]                             invokeRestart(restart)
[10:19:52.174]                             muffled <- TRUE
[10:19:52.174]                             break
[10:19:52.174]                           }
[10:19:52.174]                         }
[10:19:52.174]                       }
[10:19:52.174]                       invisible(muffled)
[10:19:52.174]                     }
[10:19:52.174]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.174]                   }
[10:19:52.174]                 }
[10:19:52.174]                 else {
[10:19:52.174]                   if (TRUE) {
[10:19:52.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.174]                     {
[10:19:52.174]                       inherits <- base::inherits
[10:19:52.174]                       invokeRestart <- base::invokeRestart
[10:19:52.174]                       is.null <- base::is.null
[10:19:52.174]                       muffled <- FALSE
[10:19:52.174]                       if (inherits(cond, "message")) {
[10:19:52.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.174]                         if (muffled) 
[10:19:52.174]                           invokeRestart("muffleMessage")
[10:19:52.174]                       }
[10:19:52.174]                       else if (inherits(cond, "warning")) {
[10:19:52.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.174]                         if (muffled) 
[10:19:52.174]                           invokeRestart("muffleWarning")
[10:19:52.174]                       }
[10:19:52.174]                       else if (inherits(cond, "condition")) {
[10:19:52.174]                         if (!is.null(pattern)) {
[10:19:52.174]                           computeRestarts <- base::computeRestarts
[10:19:52.174]                           grepl <- base::grepl
[10:19:52.174]                           restarts <- computeRestarts(cond)
[10:19:52.174]                           for (restart in restarts) {
[10:19:52.174]                             name <- restart$name
[10:19:52.174]                             if (is.null(name)) 
[10:19:52.174]                               next
[10:19:52.174]                             if (!grepl(pattern, name)) 
[10:19:52.174]                               next
[10:19:52.174]                             invokeRestart(restart)
[10:19:52.174]                             muffled <- TRUE
[10:19:52.174]                             break
[10:19:52.174]                           }
[10:19:52.174]                         }
[10:19:52.174]                       }
[10:19:52.174]                       invisible(muffled)
[10:19:52.174]                     }
[10:19:52.174]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.174]                   }
[10:19:52.174]                 }
[10:19:52.174]             }
[10:19:52.174]         }))
[10:19:52.174]     }, error = function(ex) {
[10:19:52.174]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.174]                 ...future.rng), started = ...future.startTime, 
[10:19:52.174]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.174]             version = "1.8"), class = "FutureResult")
[10:19:52.174]     }, finally = {
[10:19:52.174]         if (!identical(...future.workdir, getwd())) 
[10:19:52.174]             setwd(...future.workdir)
[10:19:52.174]         {
[10:19:52.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.174]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.174]             }
[10:19:52.174]             base::options(...future.oldOptions)
[10:19:52.174]             if (.Platform$OS.type == "windows") {
[10:19:52.174]                 old_names <- names(...future.oldEnvVars)
[10:19:52.174]                 envs <- base::Sys.getenv()
[10:19:52.174]                 names <- names(envs)
[10:19:52.174]                 common <- intersect(names, old_names)
[10:19:52.174]                 added <- setdiff(names, old_names)
[10:19:52.174]                 removed <- setdiff(old_names, names)
[10:19:52.174]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.174]                   envs[common]]
[10:19:52.174]                 NAMES <- toupper(changed)
[10:19:52.174]                 args <- list()
[10:19:52.174]                 for (kk in seq_along(NAMES)) {
[10:19:52.174]                   name <- changed[[kk]]
[10:19:52.174]                   NAME <- NAMES[[kk]]
[10:19:52.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.174]                     next
[10:19:52.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.174]                 }
[10:19:52.174]                 NAMES <- toupper(added)
[10:19:52.174]                 for (kk in seq_along(NAMES)) {
[10:19:52.174]                   name <- added[[kk]]
[10:19:52.174]                   NAME <- NAMES[[kk]]
[10:19:52.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.174]                     next
[10:19:52.174]                   args[[name]] <- ""
[10:19:52.174]                 }
[10:19:52.174]                 NAMES <- toupper(removed)
[10:19:52.174]                 for (kk in seq_along(NAMES)) {
[10:19:52.174]                   name <- removed[[kk]]
[10:19:52.174]                   NAME <- NAMES[[kk]]
[10:19:52.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.174]                     next
[10:19:52.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.174]                 }
[10:19:52.174]                 if (length(args) > 0) 
[10:19:52.174]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.174]             }
[10:19:52.174]             else {
[10:19:52.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.174]             }
[10:19:52.174]             {
[10:19:52.174]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.174]                   0L) {
[10:19:52.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.174]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.174]                   base::options(opts)
[10:19:52.174]                 }
[10:19:52.174]                 {
[10:19:52.174]                   {
[10:19:52.174]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.174]                     NULL
[10:19:52.174]                   }
[10:19:52.174]                   options(future.plan = NULL)
[10:19:52.174]                   if (is.na(NA_character_)) 
[10:19:52.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.174]                     .init = FALSE)
[10:19:52.174]                 }
[10:19:52.174]             }
[10:19:52.174]         }
[10:19:52.174]     })
[10:19:52.174]     if (TRUE) {
[10:19:52.174]         base::sink(type = "output", split = FALSE)
[10:19:52.174]         if (TRUE) {
[10:19:52.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.174]         }
[10:19:52.174]         else {
[10:19:52.174]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.174]         }
[10:19:52.174]         base::close(...future.stdout)
[10:19:52.174]         ...future.stdout <- NULL
[10:19:52.174]     }
[10:19:52.174]     ...future.result$conditions <- ...future.conditions
[10:19:52.174]     ...future.result$finished <- base::Sys.time()
[10:19:52.174]     ...future.result
[10:19:52.174] }
[10:19:52.178] assign_globals() ...
[10:19:52.178] List of 11
[10:19:52.178]  $ ...future.FUN            :function (x, ...)  
[10:19:52.178]  $ x_FUN                    :function (x)  
[10:19:52.178]  $ times                    : int 0
[10:19:52.178]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.178]  $ stop_if_not              :function (...)  
[10:19:52.178]  $ dim                      : NULL
[10:19:52.178]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:52.178]  $ future.call.arguments    : list()
[10:19:52.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.178]  $ ...future.elements_ii    :List of 5
[10:19:52.178]   ..$ : int 6
[10:19:52.178]   ..$ : int 7
[10:19:52.178]   ..$ : int 8
[10:19:52.178]   ..$ : int 9
[10:19:52.178]   ..$ : int 10
[10:19:52.178]  $ ...future.seeds_ii       : NULL
[10:19:52.178]  $ ...future.globals.maxSize: NULL
[10:19:52.178]  - attr(*, "where")=List of 11
[10:19:52.178]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.178]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.178]  - attr(*, "resolved")= logi FALSE
[10:19:52.178]  - attr(*, "total_size")= num 23453
[10:19:52.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.178]  - attr(*, "already-done")= logi TRUE
[10:19:52.196] - copied ‘...future.FUN’ to environment
[10:19:52.196] - reassign environment for ‘x_FUN’
[10:19:52.196] - copied ‘x_FUN’ to environment
[10:19:52.196] - copied ‘times’ to environment
[10:19:52.196] - copied ‘stopf’ to environment
[10:19:52.196] - copied ‘stop_if_not’ to environment
[10:19:52.196] - copied ‘dim’ to environment
[10:19:52.197] - copied ‘valid_types’ to environment
[10:19:52.197] - copied ‘future.call.arguments’ to environment
[10:19:52.197] - copied ‘...future.elements_ii’ to environment
[10:19:52.197] - copied ‘...future.seeds_ii’ to environment
[10:19:52.197] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.197] assign_globals() ... done
[10:19:52.197] requestCore(): workers = 2
[10:19:52.200] MulticoreFuture started
[10:19:52.200] - Launch lazy future ... done
[10:19:52.201] run() for ‘MulticoreFuture’ ... done
[10:19:52.201] Created future:
[10:19:52.202] plan(): Setting new future strategy stack:
[10:19:52.202] List of future strategies:
[10:19:52.202] 1. sequential:
[10:19:52.202]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.202]    - tweaked: FALSE
[10:19:52.202]    - call: NULL
[10:19:52.203] plan(): nbrOfWorkers() = 1
[10:19:52.205] plan(): Setting new future strategy stack:
[10:19:52.206] List of future strategies:
[10:19:52.206] 1. multicore:
[10:19:52.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.206]    - tweaked: FALSE
[10:19:52.206]    - call: plan(strategy)
[10:19:52.209] plan(): nbrOfWorkers() = 2
[10:19:52.201] MulticoreFuture:
[10:19:52.201] Label: ‘future_vapply-2’
[10:19:52.201] Expression:
[10:19:52.201] {
[10:19:52.201]     do.call(function(...) {
[10:19:52.201]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.201]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.201]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.201]             on.exit(options(oopts), add = TRUE)
[10:19:52.201]         }
[10:19:52.201]         {
[10:19:52.201]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.201]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.201]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.201]             })
[10:19:52.201]         }
[10:19:52.201]     }, args = future.call.arguments)
[10:19:52.201] }
[10:19:52.201] Lazy evaluation: FALSE
[10:19:52.201] Asynchronous evaluation: TRUE
[10:19:52.201] Local evaluation: TRUE
[10:19:52.201] Environment: R_GlobalEnv
[10:19:52.201] Capture standard output: TRUE
[10:19:52.201] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.201] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.201] Packages: 1 packages (‘future.apply’)
[10:19:52.201] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.201] Resolved: TRUE
[10:19:52.201] Value: <not collected>
[10:19:52.201] Conditions captured: <none>
[10:19:52.201] Early signaling: FALSE
[10:19:52.201] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.201] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.210] Chunk #2 of 2 ... DONE
[10:19:52.210] Launching 2 futures (chunks) ... DONE
[10:19:52.210] Resolving 2 futures (chunks) ...
[10:19:52.211] resolve() on list ...
[10:19:52.211]  recursive: 0
[10:19:52.211]  length: 2
[10:19:52.211] 
[10:19:52.211] Future #1
[10:19:52.212] result() for MulticoreFuture ...
[10:19:52.213] result() for MulticoreFuture ...
[10:19:52.213] result() for MulticoreFuture ... done
[10:19:52.213] result() for MulticoreFuture ... done
[10:19:52.213] result() for MulticoreFuture ...
[10:19:52.213] result() for MulticoreFuture ... done
[10:19:52.213] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.213] - nx: 2
[10:19:52.214] - relay: TRUE
[10:19:52.214] - stdout: TRUE
[10:19:52.214] - signal: TRUE
[10:19:52.214] - resignal: FALSE
[10:19:52.214] - force: TRUE
[10:19:52.214] - relayed: [n=2] FALSE, FALSE
[10:19:52.215] - queued futures: [n=2] FALSE, FALSE
[10:19:52.215]  - until=1
[10:19:52.215]  - relaying element #1
[10:19:52.215] result() for MulticoreFuture ...
[10:19:52.215] result() for MulticoreFuture ... done
[10:19:52.215] result() for MulticoreFuture ...
[10:19:52.215] result() for MulticoreFuture ... done
[10:19:52.216] result() for MulticoreFuture ...
[10:19:52.216] result() for MulticoreFuture ... done
[10:19:52.216] result() for MulticoreFuture ...
[10:19:52.216] result() for MulticoreFuture ... done
[10:19:52.216] - relayed: [n=2] TRUE, FALSE
[10:19:52.216] - queued futures: [n=2] TRUE, FALSE
[10:19:52.217] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.217]  length: 1 (resolved future 1)
[10:19:52.217] Future #2
[10:19:52.217] result() for MulticoreFuture ...
[10:19:52.218] result() for MulticoreFuture ...
[10:19:52.218] result() for MulticoreFuture ... done
[10:19:52.218] result() for MulticoreFuture ... done
[10:19:52.218] result() for MulticoreFuture ...
[10:19:52.219] result() for MulticoreFuture ... done
[10:19:52.219] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.219] - nx: 2
[10:19:52.219] - relay: TRUE
[10:19:52.219] - stdout: TRUE
[10:19:52.219] - signal: TRUE
[10:19:52.219] - resignal: FALSE
[10:19:52.220] - force: TRUE
[10:19:52.220] - relayed: [n=2] TRUE, FALSE
[10:19:52.220] - queued futures: [n=2] TRUE, FALSE
[10:19:52.220]  - until=2
[10:19:52.220]  - relaying element #2
[10:19:52.220] result() for MulticoreFuture ...
[10:19:52.220] result() for MulticoreFuture ... done
[10:19:52.220] result() for MulticoreFuture ...
[10:19:52.220] result() for MulticoreFuture ... done
[10:19:52.221] result() for MulticoreFuture ...
[10:19:52.221] result() for MulticoreFuture ... done
[10:19:52.221] result() for MulticoreFuture ...
[10:19:52.221] result() for MulticoreFuture ... done
[10:19:52.221] - relayed: [n=2] TRUE, TRUE
[10:19:52.221] - queued futures: [n=2] TRUE, TRUE
[10:19:52.221] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.221]  length: 0 (resolved future 2)
[10:19:52.222] Relaying remaining futures
[10:19:52.222] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.222] - nx: 2
[10:19:52.222] - relay: TRUE
[10:19:52.222] - stdout: TRUE
[10:19:52.222] - signal: TRUE
[10:19:52.222] - resignal: FALSE
[10:19:52.222] - force: TRUE
[10:19:52.222] - relayed: [n=2] TRUE, TRUE
[10:19:52.222] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:52.223] - relayed: [n=2] TRUE, TRUE
[10:19:52.223] - queued futures: [n=2] TRUE, TRUE
[10:19:52.223] signalConditionsASAP(NULL, pos=0) ... done
[10:19:52.223] resolve() on list ... DONE
[10:19:52.223] result() for MulticoreFuture ...
[10:19:52.223] result() for MulticoreFuture ... done
[10:19:52.223] result() for MulticoreFuture ...
[10:19:52.223] result() for MulticoreFuture ... done
[10:19:52.224] result() for MulticoreFuture ...
[10:19:52.224] result() for MulticoreFuture ... done
[10:19:52.224] result() for MulticoreFuture ...
[10:19:52.224] result() for MulticoreFuture ... done
[10:19:52.224]  - Number of value chunks collected: 2
[10:19:52.224] Resolving 2 futures (chunks) ... DONE
[10:19:52.224] Reducing values from 2 chunks ...
[10:19:52.224]  - Number of values collected after concatenation: 10
[10:19:52.224]  - Number of values expected: 10
[10:19:52.224] Reducing values from 2 chunks ... DONE
[10:19:52.225] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:19:52.226] future_lapply() ...
[10:19:52.230] Number of chunks: 2
[10:19:52.233] getGlobalsAndPackagesXApply() ...
[10:19:52.233]  - future.globals: TRUE
[10:19:52.233] getGlobalsAndPackages() ...
[10:19:52.233] Searching for globals...
[10:19:52.238] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:52.238] Searching for globals ... DONE
[10:19:52.238] Resolving globals: FALSE
[10:19:52.239] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[10:19:52.240] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:52.240] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.240] - packages: [1] ‘future.apply’
[10:19:52.240] getGlobalsAndPackages() ... DONE
[10:19:52.240]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.240]  - needed namespaces: [n=1] ‘future.apply’
[10:19:52.241] Finding globals ... DONE
[10:19:52.241]  - use_args: TRUE
[10:19:52.241]  - Getting '...' globals ...
[10:19:52.241] resolve() on list ...
[10:19:52.241]  recursive: 0
[10:19:52.241]  length: 1
[10:19:52.241]  elements: ‘...’
[10:19:52.242]  length: 0 (resolved future 1)
[10:19:52.242] resolve() on list ... DONE
[10:19:52.242]    - '...' content: [n=0] 
[10:19:52.242] List of 1
[10:19:52.242]  $ ...: list()
[10:19:52.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.242]  - attr(*, "where")=List of 1
[10:19:52.242]   ..$ ...:<environment: 0x55c69fd46760> 
[10:19:52.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.242]  - attr(*, "resolved")= logi TRUE
[10:19:52.242]  - attr(*, "total_size")= num NA
[10:19:52.244]  - Getting '...' globals ... DONE
[10:19:52.245] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:52.245] List of 8
[10:19:52.245]  $ ...future.FUN:function (x, ...)  
[10:19:52.245]  $ x_FUN        :function (x)  
[10:19:52.245]  $ times        : int 1
[10:19:52.245]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.245]  $ stop_if_not  :function (...)  
[10:19:52.245]  $ dim          : NULL
[10:19:52.245]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:52.245]  $ ...          : list()
[10:19:52.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.245]  - attr(*, "where")=List of 8
[10:19:52.245]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:52.245]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:52.245]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:52.245]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:52.245]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:52.245]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:52.245]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:52.245]   ..$ ...          :<environment: 0x55c69fd46760> 
[10:19:52.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.245]  - attr(*, "resolved")= logi FALSE
[10:19:52.245]  - attr(*, "total_size")= num 22322
[10:19:52.250] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:52.250] getGlobalsAndPackagesXApply() ... DONE
[10:19:52.250] Number of futures (= number of chunks): 2
[10:19:52.251] Launching 2 futures (chunks) ...
[10:19:52.251] Chunk #1 of 2 ...
[10:19:52.251]  - Finding globals in 'X' for chunk #1 ...
[10:19:52.251] getGlobalsAndPackages() ...
[10:19:52.251] Searching for globals...
[10:19:52.251] 
[10:19:52.251] Searching for globals ... DONE
[10:19:52.251] - globals: [0] <none>
[10:19:52.252] getGlobalsAndPackages() ... DONE
[10:19:52.252]    + additional globals found: [n=0] 
[10:19:52.252]    + additional namespaces needed: [n=0] 
[10:19:52.252]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:52.252]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.252]  - seeds: <none>
[10:19:52.252]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.252] getGlobalsAndPackages() ...
[10:19:52.252] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.252] Resolving globals: FALSE
[10:19:52.253] Tweak future expression to call with '...' arguments ...
[10:19:52.253] {
[10:19:52.253]     do.call(function(...) {
[10:19:52.253]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.253]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.253]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.253]             on.exit(options(oopts), add = TRUE)
[10:19:52.253]         }
[10:19:52.253]         {
[10:19:52.253]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.253]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.253]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.253]             })
[10:19:52.253]         }
[10:19:52.253]     }, args = future.call.arguments)
[10:19:52.253] }
[10:19:52.253] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.253] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.254] - packages: [1] ‘future.apply’
[10:19:52.254] getGlobalsAndPackages() ... DONE
[10:19:52.254] run() for ‘Future’ ...
[10:19:52.254] - state: ‘created’
[10:19:52.254] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.258] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.259]   - Field: ‘label’
[10:19:52.259]   - Field: ‘local’
[10:19:52.259]   - Field: ‘owner’
[10:19:52.259]   - Field: ‘envir’
[10:19:52.259]   - Field: ‘workers’
[10:19:52.259]   - Field: ‘packages’
[10:19:52.259]   - Field: ‘gc’
[10:19:52.260]   - Field: ‘job’
[10:19:52.260]   - Field: ‘conditions’
[10:19:52.260]   - Field: ‘expr’
[10:19:52.260]   - Field: ‘uuid’
[10:19:52.260]   - Field: ‘seed’
[10:19:52.260]   - Field: ‘version’
[10:19:52.260]   - Field: ‘result’
[10:19:52.260]   - Field: ‘asynchronous’
[10:19:52.260]   - Field: ‘calls’
[10:19:52.261]   - Field: ‘globals’
[10:19:52.261]   - Field: ‘stdout’
[10:19:52.261]   - Field: ‘earlySignal’
[10:19:52.261]   - Field: ‘lazy’
[10:19:52.261]   - Field: ‘state’
[10:19:52.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.261] - Launch lazy future ...
[10:19:52.262] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.262] Packages needed by future strategies (n = 0): <none>
[10:19:52.262] {
[10:19:52.262]     {
[10:19:52.262]         {
[10:19:52.262]             ...future.startTime <- base::Sys.time()
[10:19:52.262]             {
[10:19:52.262]                 {
[10:19:52.262]                   {
[10:19:52.262]                     {
[10:19:52.262]                       {
[10:19:52.262]                         base::local({
[10:19:52.262]                           has_future <- base::requireNamespace("future", 
[10:19:52.262]                             quietly = TRUE)
[10:19:52.262]                           if (has_future) {
[10:19:52.262]                             ns <- base::getNamespace("future")
[10:19:52.262]                             version <- ns[[".package"]][["version"]]
[10:19:52.262]                             if (is.null(version)) 
[10:19:52.262]                               version <- utils::packageVersion("future")
[10:19:52.262]                           }
[10:19:52.262]                           else {
[10:19:52.262]                             version <- NULL
[10:19:52.262]                           }
[10:19:52.262]                           if (!has_future || version < "1.8.0") {
[10:19:52.262]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.262]                               "", base::R.version$version.string), 
[10:19:52.262]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.262]                                 base::R.version$platform, 8 * 
[10:19:52.262]                                   base::.Machine$sizeof.pointer), 
[10:19:52.262]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.262]                                 "release", "version")], collapse = " "), 
[10:19:52.262]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.262]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.262]                               info)
[10:19:52.262]                             info <- base::paste(info, collapse = "; ")
[10:19:52.262]                             if (!has_future) {
[10:19:52.262]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.262]                                 info)
[10:19:52.262]                             }
[10:19:52.262]                             else {
[10:19:52.262]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.262]                                 info, version)
[10:19:52.262]                             }
[10:19:52.262]                             base::stop(msg)
[10:19:52.262]                           }
[10:19:52.262]                         })
[10:19:52.262]                       }
[10:19:52.262]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.262]                       base::options(mc.cores = 1L)
[10:19:52.262]                     }
[10:19:52.262]                     base::local({
[10:19:52.262]                       for (pkg in "future.apply") {
[10:19:52.262]                         base::loadNamespace(pkg)
[10:19:52.262]                         base::library(pkg, character.only = TRUE)
[10:19:52.262]                       }
[10:19:52.262]                     })
[10:19:52.262]                   }
[10:19:52.262]                   ...future.strategy.old <- future::plan("list")
[10:19:52.262]                   options(future.plan = NULL)
[10:19:52.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.262]                 }
[10:19:52.262]                 ...future.workdir <- getwd()
[10:19:52.262]             }
[10:19:52.262]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.262]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.262]         }
[10:19:52.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.262]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.262]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.262]             base::names(...future.oldOptions))
[10:19:52.262]     }
[10:19:52.262]     if (FALSE) {
[10:19:52.262]     }
[10:19:52.262]     else {
[10:19:52.262]         if (TRUE) {
[10:19:52.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.262]                 open = "w")
[10:19:52.262]         }
[10:19:52.262]         else {
[10:19:52.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.262]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.262]         }
[10:19:52.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.262]             base::sink(type = "output", split = FALSE)
[10:19:52.262]             base::close(...future.stdout)
[10:19:52.262]         }, add = TRUE)
[10:19:52.262]     }
[10:19:52.262]     ...future.frame <- base::sys.nframe()
[10:19:52.262]     ...future.conditions <- base::list()
[10:19:52.262]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.262]     if (FALSE) {
[10:19:52.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.262]     }
[10:19:52.262]     ...future.result <- base::tryCatch({
[10:19:52.262]         base::withCallingHandlers({
[10:19:52.262]             ...future.value <- base::withVisible(base::local({
[10:19:52.262]                 withCallingHandlers({
[10:19:52.262]                   {
[10:19:52.262]                     do.call(function(...) {
[10:19:52.262]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.262]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.262]                         ...future.globals.maxSize)) {
[10:19:52.262]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.262]                         on.exit(options(oopts), add = TRUE)
[10:19:52.262]                       }
[10:19:52.262]                       {
[10:19:52.262]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.262]                           FUN = function(jj) {
[10:19:52.262]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.262]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.262]                           })
[10:19:52.262]                       }
[10:19:52.262]                     }, args = future.call.arguments)
[10:19:52.262]                   }
[10:19:52.262]                 }, immediateCondition = function(cond) {
[10:19:52.262]                   save_rds <- function (object, pathname, ...) 
[10:19:52.262]                   {
[10:19:52.262]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.262]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.262]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.262]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.262]                         fi_tmp[["mtime"]])
[10:19:52.262]                     }
[10:19:52.262]                     tryCatch({
[10:19:52.262]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.262]                     }, error = function(ex) {
[10:19:52.262]                       msg <- conditionMessage(ex)
[10:19:52.262]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.262]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.262]                         fi_tmp[["mtime"]], msg)
[10:19:52.262]                       ex$message <- msg
[10:19:52.262]                       stop(ex)
[10:19:52.262]                     })
[10:19:52.262]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.262]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.262]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.262]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.262]                       fi <- file.info(pathname)
[10:19:52.262]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.262]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.262]                         fi[["size"]], fi[["mtime"]])
[10:19:52.262]                       stop(msg)
[10:19:52.262]                     }
[10:19:52.262]                     invisible(pathname)
[10:19:52.262]                   }
[10:19:52.262]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.262]                     rootPath = tempdir()) 
[10:19:52.262]                   {
[10:19:52.262]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.262]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.262]                       tmpdir = path, fileext = ".rds")
[10:19:52.262]                     save_rds(obj, file)
[10:19:52.262]                   }
[10:19:52.262]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.262]                   {
[10:19:52.262]                     inherits <- base::inherits
[10:19:52.262]                     invokeRestart <- base::invokeRestart
[10:19:52.262]                     is.null <- base::is.null
[10:19:52.262]                     muffled <- FALSE
[10:19:52.262]                     if (inherits(cond, "message")) {
[10:19:52.262]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.262]                       if (muffled) 
[10:19:52.262]                         invokeRestart("muffleMessage")
[10:19:52.262]                     }
[10:19:52.262]                     else if (inherits(cond, "warning")) {
[10:19:52.262]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.262]                       if (muffled) 
[10:19:52.262]                         invokeRestart("muffleWarning")
[10:19:52.262]                     }
[10:19:52.262]                     else if (inherits(cond, "condition")) {
[10:19:52.262]                       if (!is.null(pattern)) {
[10:19:52.262]                         computeRestarts <- base::computeRestarts
[10:19:52.262]                         grepl <- base::grepl
[10:19:52.262]                         restarts <- computeRestarts(cond)
[10:19:52.262]                         for (restart in restarts) {
[10:19:52.262]                           name <- restart$name
[10:19:52.262]                           if (is.null(name)) 
[10:19:52.262]                             next
[10:19:52.262]                           if (!grepl(pattern, name)) 
[10:19:52.262]                             next
[10:19:52.262]                           invokeRestart(restart)
[10:19:52.262]                           muffled <- TRUE
[10:19:52.262]                           break
[10:19:52.262]                         }
[10:19:52.262]                       }
[10:19:52.262]                     }
[10:19:52.262]                     invisible(muffled)
[10:19:52.262]                   }
[10:19:52.262]                   muffleCondition(cond)
[10:19:52.262]                 })
[10:19:52.262]             }))
[10:19:52.262]             future::FutureResult(value = ...future.value$value, 
[10:19:52.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.262]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.262]                     ...future.globalenv.names))
[10:19:52.262]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.262]         }, condition = base::local({
[10:19:52.262]             c <- base::c
[10:19:52.262]             inherits <- base::inherits
[10:19:52.262]             invokeRestart <- base::invokeRestart
[10:19:52.262]             length <- base::length
[10:19:52.262]             list <- base::list
[10:19:52.262]             seq.int <- base::seq.int
[10:19:52.262]             signalCondition <- base::signalCondition
[10:19:52.262]             sys.calls <- base::sys.calls
[10:19:52.262]             `[[` <- base::`[[`
[10:19:52.262]             `+` <- base::`+`
[10:19:52.262]             `<<-` <- base::`<<-`
[10:19:52.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.262]                   3L)]
[10:19:52.262]             }
[10:19:52.262]             function(cond) {
[10:19:52.262]                 is_error <- inherits(cond, "error")
[10:19:52.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.262]                   NULL)
[10:19:52.262]                 if (is_error) {
[10:19:52.262]                   sessionInformation <- function() {
[10:19:52.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.262]                       search = base::search(), system = base::Sys.info())
[10:19:52.262]                   }
[10:19:52.262]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.262]                     cond$call), session = sessionInformation(), 
[10:19:52.262]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.262]                   signalCondition(cond)
[10:19:52.262]                 }
[10:19:52.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.262]                 "immediateCondition"))) {
[10:19:52.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.262]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.262]                   if (TRUE && !signal) {
[10:19:52.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.262]                     {
[10:19:52.262]                       inherits <- base::inherits
[10:19:52.262]                       invokeRestart <- base::invokeRestart
[10:19:52.262]                       is.null <- base::is.null
[10:19:52.262]                       muffled <- FALSE
[10:19:52.262]                       if (inherits(cond, "message")) {
[10:19:52.262]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.262]                         if (muffled) 
[10:19:52.262]                           invokeRestart("muffleMessage")
[10:19:52.262]                       }
[10:19:52.262]                       else if (inherits(cond, "warning")) {
[10:19:52.262]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.262]                         if (muffled) 
[10:19:52.262]                           invokeRestart("muffleWarning")
[10:19:52.262]                       }
[10:19:52.262]                       else if (inherits(cond, "condition")) {
[10:19:52.262]                         if (!is.null(pattern)) {
[10:19:52.262]                           computeRestarts <- base::computeRestarts
[10:19:52.262]                           grepl <- base::grepl
[10:19:52.262]                           restarts <- computeRestarts(cond)
[10:19:52.262]                           for (restart in restarts) {
[10:19:52.262]                             name <- restart$name
[10:19:52.262]                             if (is.null(name)) 
[10:19:52.262]                               next
[10:19:52.262]                             if (!grepl(pattern, name)) 
[10:19:52.262]                               next
[10:19:52.262]                             invokeRestart(restart)
[10:19:52.262]                             muffled <- TRUE
[10:19:52.262]                             break
[10:19:52.262]                           }
[10:19:52.262]                         }
[10:19:52.262]                       }
[10:19:52.262]                       invisible(muffled)
[10:19:52.262]                     }
[10:19:52.262]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.262]                   }
[10:19:52.262]                 }
[10:19:52.262]                 else {
[10:19:52.262]                   if (TRUE) {
[10:19:52.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.262]                     {
[10:19:52.262]                       inherits <- base::inherits
[10:19:52.262]                       invokeRestart <- base::invokeRestart
[10:19:52.262]                       is.null <- base::is.null
[10:19:52.262]                       muffled <- FALSE
[10:19:52.262]                       if (inherits(cond, "message")) {
[10:19:52.262]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.262]                         if (muffled) 
[10:19:52.262]                           invokeRestart("muffleMessage")
[10:19:52.262]                       }
[10:19:52.262]                       else if (inherits(cond, "warning")) {
[10:19:52.262]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.262]                         if (muffled) 
[10:19:52.262]                           invokeRestart("muffleWarning")
[10:19:52.262]                       }
[10:19:52.262]                       else if (inherits(cond, "condition")) {
[10:19:52.262]                         if (!is.null(pattern)) {
[10:19:52.262]                           computeRestarts <- base::computeRestarts
[10:19:52.262]                           grepl <- base::grepl
[10:19:52.262]                           restarts <- computeRestarts(cond)
[10:19:52.262]                           for (restart in restarts) {
[10:19:52.262]                             name <- restart$name
[10:19:52.262]                             if (is.null(name)) 
[10:19:52.262]                               next
[10:19:52.262]                             if (!grepl(pattern, name)) 
[10:19:52.262]                               next
[10:19:52.262]                             invokeRestart(restart)
[10:19:52.262]                             muffled <- TRUE
[10:19:52.262]                             break
[10:19:52.262]                           }
[10:19:52.262]                         }
[10:19:52.262]                       }
[10:19:52.262]                       invisible(muffled)
[10:19:52.262]                     }
[10:19:52.262]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.262]                   }
[10:19:52.262]                 }
[10:19:52.262]             }
[10:19:52.262]         }))
[10:19:52.262]     }, error = function(ex) {
[10:19:52.262]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.262]                 ...future.rng), started = ...future.startTime, 
[10:19:52.262]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.262]             version = "1.8"), class = "FutureResult")
[10:19:52.262]     }, finally = {
[10:19:52.262]         if (!identical(...future.workdir, getwd())) 
[10:19:52.262]             setwd(...future.workdir)
[10:19:52.262]         {
[10:19:52.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.262]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.262]             }
[10:19:52.262]             base::options(...future.oldOptions)
[10:19:52.262]             if (.Platform$OS.type == "windows") {
[10:19:52.262]                 old_names <- names(...future.oldEnvVars)
[10:19:52.262]                 envs <- base::Sys.getenv()
[10:19:52.262]                 names <- names(envs)
[10:19:52.262]                 common <- intersect(names, old_names)
[10:19:52.262]                 added <- setdiff(names, old_names)
[10:19:52.262]                 removed <- setdiff(old_names, names)
[10:19:52.262]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.262]                   envs[common]]
[10:19:52.262]                 NAMES <- toupper(changed)
[10:19:52.262]                 args <- list()
[10:19:52.262]                 for (kk in seq_along(NAMES)) {
[10:19:52.262]                   name <- changed[[kk]]
[10:19:52.262]                   NAME <- NAMES[[kk]]
[10:19:52.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.262]                     next
[10:19:52.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.262]                 }
[10:19:52.262]                 NAMES <- toupper(added)
[10:19:52.262]                 for (kk in seq_along(NAMES)) {
[10:19:52.262]                   name <- added[[kk]]
[10:19:52.262]                   NAME <- NAMES[[kk]]
[10:19:52.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.262]                     next
[10:19:52.262]                   args[[name]] <- ""
[10:19:52.262]                 }
[10:19:52.262]                 NAMES <- toupper(removed)
[10:19:52.262]                 for (kk in seq_along(NAMES)) {
[10:19:52.262]                   name <- removed[[kk]]
[10:19:52.262]                   NAME <- NAMES[[kk]]
[10:19:52.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.262]                     next
[10:19:52.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.262]                 }
[10:19:52.262]                 if (length(args) > 0) 
[10:19:52.262]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.262]             }
[10:19:52.262]             else {
[10:19:52.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.262]             }
[10:19:52.262]             {
[10:19:52.262]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.262]                   0L) {
[10:19:52.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.262]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.262]                   base::options(opts)
[10:19:52.262]                 }
[10:19:52.262]                 {
[10:19:52.262]                   {
[10:19:52.262]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.262]                     NULL
[10:19:52.262]                   }
[10:19:52.262]                   options(future.plan = NULL)
[10:19:52.262]                   if (is.na(NA_character_)) 
[10:19:52.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.262]                     .init = FALSE)
[10:19:52.262]                 }
[10:19:52.262]             }
[10:19:52.262]         }
[10:19:52.262]     })
[10:19:52.262]     if (TRUE) {
[10:19:52.262]         base::sink(type = "output", split = FALSE)
[10:19:52.262]         if (TRUE) {
[10:19:52.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.262]         }
[10:19:52.262]         else {
[10:19:52.262]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.262]         }
[10:19:52.262]         base::close(...future.stdout)
[10:19:52.262]         ...future.stdout <- NULL
[10:19:52.262]     }
[10:19:52.262]     ...future.result$conditions <- ...future.conditions
[10:19:52.262]     ...future.result$finished <- base::Sys.time()
[10:19:52.262]     ...future.result
[10:19:52.262] }
[10:19:52.265] assign_globals() ...
[10:19:52.265] List of 11
[10:19:52.265]  $ ...future.FUN            :function (x, ...)  
[10:19:52.265]  $ x_FUN                    :function (x)  
[10:19:52.265]  $ times                    : int 1
[10:19:52.265]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.265]  $ stop_if_not              :function (...)  
[10:19:52.265]  $ dim                      : NULL
[10:19:52.265]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.265]  $ future.call.arguments    : list()
[10:19:52.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.265]  $ ...future.elements_ii    :List of 5
[10:19:52.265]   ..$ : int 1
[10:19:52.265]   ..$ : int 2
[10:19:52.265]   ..$ : int 3
[10:19:52.265]   ..$ : int 4
[10:19:52.265]   ..$ : int 5
[10:19:52.265]  $ ...future.seeds_ii       : NULL
[10:19:52.265]  $ ...future.globals.maxSize: NULL
[10:19:52.265]  - attr(*, "where")=List of 11
[10:19:52.265]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.265]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.265]  - attr(*, "resolved")= logi FALSE
[10:19:52.265]  - attr(*, "total_size")= num 22322
[10:19:52.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.265]  - attr(*, "already-done")= logi TRUE
[10:19:52.274] - copied ‘...future.FUN’ to environment
[10:19:52.274] - copied ‘x_FUN’ to environment
[10:19:52.274] - copied ‘times’ to environment
[10:19:52.274] - copied ‘stopf’ to environment
[10:19:52.274] - copied ‘stop_if_not’ to environment
[10:19:52.274] - copied ‘dim’ to environment
[10:19:52.274] - copied ‘valid_types’ to environment
[10:19:52.274] - copied ‘future.call.arguments’ to environment
[10:19:52.274] - copied ‘...future.elements_ii’ to environment
[10:19:52.275] - copied ‘...future.seeds_ii’ to environment
[10:19:52.275] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.275] assign_globals() ... done
[10:19:52.275] requestCore(): workers = 2
[10:19:52.277] MulticoreFuture started
[10:19:52.278] - Launch lazy future ... done
[10:19:52.278] run() for ‘MulticoreFuture’ ... done
[10:19:52.278] Created future:
[10:19:52.279] plan(): Setting new future strategy stack:
[10:19:52.279] List of future strategies:
[10:19:52.279] 1. sequential:
[10:19:52.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.279]    - tweaked: FALSE
[10:19:52.279]    - call: NULL
[10:19:52.280] plan(): nbrOfWorkers() = 1
[10:19:52.283] plan(): Setting new future strategy stack:
[10:19:52.283] List of future strategies:
[10:19:52.283] 1. multicore:
[10:19:52.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.283]    - tweaked: FALSE
[10:19:52.283]    - call: plan(strategy)
[10:19:52.287] plan(): nbrOfWorkers() = 2
[10:19:52.278] MulticoreFuture:
[10:19:52.278] Label: ‘future_vapply-1’
[10:19:52.278] Expression:
[10:19:52.278] {
[10:19:52.278]     do.call(function(...) {
[10:19:52.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.278]             on.exit(options(oopts), add = TRUE)
[10:19:52.278]         }
[10:19:52.278]         {
[10:19:52.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.278]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.278]             })
[10:19:52.278]         }
[10:19:52.278]     }, args = future.call.arguments)
[10:19:52.278] }
[10:19:52.278] Lazy evaluation: FALSE
[10:19:52.278] Asynchronous evaluation: TRUE
[10:19:52.278] Local evaluation: TRUE
[10:19:52.278] Environment: R_GlobalEnv
[10:19:52.278] Capture standard output: TRUE
[10:19:52.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.278] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.278] Packages: 1 packages (‘future.apply’)
[10:19:52.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.278] Resolved: TRUE
[10:19:52.278] Value: <not collected>
[10:19:52.278] Conditions captured: <none>
[10:19:52.278] Early signaling: FALSE
[10:19:52.278] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.278] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.288] Chunk #1 of 2 ... DONE
[10:19:52.288] Chunk #2 of 2 ...
[10:19:52.289]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.289] getGlobalsAndPackages() ...
[10:19:52.289] Searching for globals...
[10:19:52.289] 
[10:19:52.290] Searching for globals ... DONE
[10:19:52.290] - globals: [0] <none>
[10:19:52.290] getGlobalsAndPackages() ... DONE
[10:19:52.290]    + additional globals found: [n=0] 
[10:19:52.290]    + additional namespaces needed: [n=0] 
[10:19:52.290]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.290]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.290]  - seeds: <none>
[10:19:52.291]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.291] getGlobalsAndPackages() ...
[10:19:52.291] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.291] Resolving globals: FALSE
[10:19:52.291] Tweak future expression to call with '...' arguments ...
[10:19:52.291] {
[10:19:52.291]     do.call(function(...) {
[10:19:52.291]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.291]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.291]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.291]             on.exit(options(oopts), add = TRUE)
[10:19:52.291]         }
[10:19:52.291]         {
[10:19:52.291]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.291]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.291]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.291]             })
[10:19:52.291]         }
[10:19:52.291]     }, args = future.call.arguments)
[10:19:52.291] }
[10:19:52.292] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.293] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.293] - packages: [1] ‘future.apply’
[10:19:52.293] getGlobalsAndPackages() ... DONE
[10:19:52.294] run() for ‘Future’ ...
[10:19:52.298] - state: ‘created’
[10:19:52.298] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.303]   - Field: ‘label’
[10:19:52.304]   - Field: ‘local’
[10:19:52.304]   - Field: ‘owner’
[10:19:52.304]   - Field: ‘envir’
[10:19:52.305]   - Field: ‘workers’
[10:19:52.305]   - Field: ‘packages’
[10:19:52.305]   - Field: ‘gc’
[10:19:52.305]   - Field: ‘job’
[10:19:52.305]   - Field: ‘conditions’
[10:19:52.306]   - Field: ‘expr’
[10:19:52.306]   - Field: ‘uuid’
[10:19:52.306]   - Field: ‘seed’
[10:19:52.306]   - Field: ‘version’
[10:19:52.307]   - Field: ‘result’
[10:19:52.307]   - Field: ‘asynchronous’
[10:19:52.307]   - Field: ‘calls’
[10:19:52.307]   - Field: ‘globals’
[10:19:52.308]   - Field: ‘stdout’
[10:19:52.308]   - Field: ‘earlySignal’
[10:19:52.308]   - Field: ‘lazy’
[10:19:52.308]   - Field: ‘state’
[10:19:52.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.309] - Launch lazy future ...
[10:19:52.309] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.309] Packages needed by future strategies (n = 0): <none>
[10:19:52.310] {
[10:19:52.310]     {
[10:19:52.310]         {
[10:19:52.310]             ...future.startTime <- base::Sys.time()
[10:19:52.310]             {
[10:19:52.310]                 {
[10:19:52.310]                   {
[10:19:52.310]                     {
[10:19:52.310]                       {
[10:19:52.310]                         base::local({
[10:19:52.310]                           has_future <- base::requireNamespace("future", 
[10:19:52.310]                             quietly = TRUE)
[10:19:52.310]                           if (has_future) {
[10:19:52.310]                             ns <- base::getNamespace("future")
[10:19:52.310]                             version <- ns[[".package"]][["version"]]
[10:19:52.310]                             if (is.null(version)) 
[10:19:52.310]                               version <- utils::packageVersion("future")
[10:19:52.310]                           }
[10:19:52.310]                           else {
[10:19:52.310]                             version <- NULL
[10:19:52.310]                           }
[10:19:52.310]                           if (!has_future || version < "1.8.0") {
[10:19:52.310]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.310]                               "", base::R.version$version.string), 
[10:19:52.310]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.310]                                 base::R.version$platform, 8 * 
[10:19:52.310]                                   base::.Machine$sizeof.pointer), 
[10:19:52.310]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.310]                                 "release", "version")], collapse = " "), 
[10:19:52.310]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.310]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.310]                               info)
[10:19:52.310]                             info <- base::paste(info, collapse = "; ")
[10:19:52.310]                             if (!has_future) {
[10:19:52.310]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.310]                                 info)
[10:19:52.310]                             }
[10:19:52.310]                             else {
[10:19:52.310]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.310]                                 info, version)
[10:19:52.310]                             }
[10:19:52.310]                             base::stop(msg)
[10:19:52.310]                           }
[10:19:52.310]                         })
[10:19:52.310]                       }
[10:19:52.310]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.310]                       base::options(mc.cores = 1L)
[10:19:52.310]                     }
[10:19:52.310]                     base::local({
[10:19:52.310]                       for (pkg in "future.apply") {
[10:19:52.310]                         base::loadNamespace(pkg)
[10:19:52.310]                         base::library(pkg, character.only = TRUE)
[10:19:52.310]                       }
[10:19:52.310]                     })
[10:19:52.310]                   }
[10:19:52.310]                   ...future.strategy.old <- future::plan("list")
[10:19:52.310]                   options(future.plan = NULL)
[10:19:52.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.310]                 }
[10:19:52.310]                 ...future.workdir <- getwd()
[10:19:52.310]             }
[10:19:52.310]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.310]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.310]         }
[10:19:52.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.310]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.310]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.310]             base::names(...future.oldOptions))
[10:19:52.310]     }
[10:19:52.310]     if (FALSE) {
[10:19:52.310]     }
[10:19:52.310]     else {
[10:19:52.310]         if (TRUE) {
[10:19:52.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.310]                 open = "w")
[10:19:52.310]         }
[10:19:52.310]         else {
[10:19:52.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.310]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.310]         }
[10:19:52.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.310]             base::sink(type = "output", split = FALSE)
[10:19:52.310]             base::close(...future.stdout)
[10:19:52.310]         }, add = TRUE)
[10:19:52.310]     }
[10:19:52.310]     ...future.frame <- base::sys.nframe()
[10:19:52.310]     ...future.conditions <- base::list()
[10:19:52.310]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.310]     if (FALSE) {
[10:19:52.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.310]     }
[10:19:52.310]     ...future.result <- base::tryCatch({
[10:19:52.310]         base::withCallingHandlers({
[10:19:52.310]             ...future.value <- base::withVisible(base::local({
[10:19:52.310]                 withCallingHandlers({
[10:19:52.310]                   {
[10:19:52.310]                     do.call(function(...) {
[10:19:52.310]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.310]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.310]                         ...future.globals.maxSize)) {
[10:19:52.310]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.310]                         on.exit(options(oopts), add = TRUE)
[10:19:52.310]                       }
[10:19:52.310]                       {
[10:19:52.310]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.310]                           FUN = function(jj) {
[10:19:52.310]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.310]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.310]                           })
[10:19:52.310]                       }
[10:19:52.310]                     }, args = future.call.arguments)
[10:19:52.310]                   }
[10:19:52.310]                 }, immediateCondition = function(cond) {
[10:19:52.310]                   save_rds <- function (object, pathname, ...) 
[10:19:52.310]                   {
[10:19:52.310]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.310]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.310]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.310]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.310]                         fi_tmp[["mtime"]])
[10:19:52.310]                     }
[10:19:52.310]                     tryCatch({
[10:19:52.310]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.310]                     }, error = function(ex) {
[10:19:52.310]                       msg <- conditionMessage(ex)
[10:19:52.310]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.310]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.310]                         fi_tmp[["mtime"]], msg)
[10:19:52.310]                       ex$message <- msg
[10:19:52.310]                       stop(ex)
[10:19:52.310]                     })
[10:19:52.310]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.310]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.310]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.310]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.310]                       fi <- file.info(pathname)
[10:19:52.310]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.310]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.310]                         fi[["size"]], fi[["mtime"]])
[10:19:52.310]                       stop(msg)
[10:19:52.310]                     }
[10:19:52.310]                     invisible(pathname)
[10:19:52.310]                   }
[10:19:52.310]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.310]                     rootPath = tempdir()) 
[10:19:52.310]                   {
[10:19:52.310]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.310]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.310]                       tmpdir = path, fileext = ".rds")
[10:19:52.310]                     save_rds(obj, file)
[10:19:52.310]                   }
[10:19:52.310]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.310]                   {
[10:19:52.310]                     inherits <- base::inherits
[10:19:52.310]                     invokeRestart <- base::invokeRestart
[10:19:52.310]                     is.null <- base::is.null
[10:19:52.310]                     muffled <- FALSE
[10:19:52.310]                     if (inherits(cond, "message")) {
[10:19:52.310]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.310]                       if (muffled) 
[10:19:52.310]                         invokeRestart("muffleMessage")
[10:19:52.310]                     }
[10:19:52.310]                     else if (inherits(cond, "warning")) {
[10:19:52.310]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.310]                       if (muffled) 
[10:19:52.310]                         invokeRestart("muffleWarning")
[10:19:52.310]                     }
[10:19:52.310]                     else if (inherits(cond, "condition")) {
[10:19:52.310]                       if (!is.null(pattern)) {
[10:19:52.310]                         computeRestarts <- base::computeRestarts
[10:19:52.310]                         grepl <- base::grepl
[10:19:52.310]                         restarts <- computeRestarts(cond)
[10:19:52.310]                         for (restart in restarts) {
[10:19:52.310]                           name <- restart$name
[10:19:52.310]                           if (is.null(name)) 
[10:19:52.310]                             next
[10:19:52.310]                           if (!grepl(pattern, name)) 
[10:19:52.310]                             next
[10:19:52.310]                           invokeRestart(restart)
[10:19:52.310]                           muffled <- TRUE
[10:19:52.310]                           break
[10:19:52.310]                         }
[10:19:52.310]                       }
[10:19:52.310]                     }
[10:19:52.310]                     invisible(muffled)
[10:19:52.310]                   }
[10:19:52.310]                   muffleCondition(cond)
[10:19:52.310]                 })
[10:19:52.310]             }))
[10:19:52.310]             future::FutureResult(value = ...future.value$value, 
[10:19:52.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.310]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.310]                     ...future.globalenv.names))
[10:19:52.310]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.310]         }, condition = base::local({
[10:19:52.310]             c <- base::c
[10:19:52.310]             inherits <- base::inherits
[10:19:52.310]             invokeRestart <- base::invokeRestart
[10:19:52.310]             length <- base::length
[10:19:52.310]             list <- base::list
[10:19:52.310]             seq.int <- base::seq.int
[10:19:52.310]             signalCondition <- base::signalCondition
[10:19:52.310]             sys.calls <- base::sys.calls
[10:19:52.310]             `[[` <- base::`[[`
[10:19:52.310]             `+` <- base::`+`
[10:19:52.310]             `<<-` <- base::`<<-`
[10:19:52.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.310]                   3L)]
[10:19:52.310]             }
[10:19:52.310]             function(cond) {
[10:19:52.310]                 is_error <- inherits(cond, "error")
[10:19:52.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.310]                   NULL)
[10:19:52.310]                 if (is_error) {
[10:19:52.310]                   sessionInformation <- function() {
[10:19:52.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.310]                       search = base::search(), system = base::Sys.info())
[10:19:52.310]                   }
[10:19:52.310]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.310]                     cond$call), session = sessionInformation(), 
[10:19:52.310]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.310]                   signalCondition(cond)
[10:19:52.310]                 }
[10:19:52.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.310]                 "immediateCondition"))) {
[10:19:52.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.310]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.310]                   if (TRUE && !signal) {
[10:19:52.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.310]                     {
[10:19:52.310]                       inherits <- base::inherits
[10:19:52.310]                       invokeRestart <- base::invokeRestart
[10:19:52.310]                       is.null <- base::is.null
[10:19:52.310]                       muffled <- FALSE
[10:19:52.310]                       if (inherits(cond, "message")) {
[10:19:52.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.310]                         if (muffled) 
[10:19:52.310]                           invokeRestart("muffleMessage")
[10:19:52.310]                       }
[10:19:52.310]                       else if (inherits(cond, "warning")) {
[10:19:52.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.310]                         if (muffled) 
[10:19:52.310]                           invokeRestart("muffleWarning")
[10:19:52.310]                       }
[10:19:52.310]                       else if (inherits(cond, "condition")) {
[10:19:52.310]                         if (!is.null(pattern)) {
[10:19:52.310]                           computeRestarts <- base::computeRestarts
[10:19:52.310]                           grepl <- base::grepl
[10:19:52.310]                           restarts <- computeRestarts(cond)
[10:19:52.310]                           for (restart in restarts) {
[10:19:52.310]                             name <- restart$name
[10:19:52.310]                             if (is.null(name)) 
[10:19:52.310]                               next
[10:19:52.310]                             if (!grepl(pattern, name)) 
[10:19:52.310]                               next
[10:19:52.310]                             invokeRestart(restart)
[10:19:52.310]                             muffled <- TRUE
[10:19:52.310]                             break
[10:19:52.310]                           }
[10:19:52.310]                         }
[10:19:52.310]                       }
[10:19:52.310]                       invisible(muffled)
[10:19:52.310]                     }
[10:19:52.310]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.310]                   }
[10:19:52.310]                 }
[10:19:52.310]                 else {
[10:19:52.310]                   if (TRUE) {
[10:19:52.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.310]                     {
[10:19:52.310]                       inherits <- base::inherits
[10:19:52.310]                       invokeRestart <- base::invokeRestart
[10:19:52.310]                       is.null <- base::is.null
[10:19:52.310]                       muffled <- FALSE
[10:19:52.310]                       if (inherits(cond, "message")) {
[10:19:52.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.310]                         if (muffled) 
[10:19:52.310]                           invokeRestart("muffleMessage")
[10:19:52.310]                       }
[10:19:52.310]                       else if (inherits(cond, "warning")) {
[10:19:52.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.310]                         if (muffled) 
[10:19:52.310]                           invokeRestart("muffleWarning")
[10:19:52.310]                       }
[10:19:52.310]                       else if (inherits(cond, "condition")) {
[10:19:52.310]                         if (!is.null(pattern)) {
[10:19:52.310]                           computeRestarts <- base::computeRestarts
[10:19:52.310]                           grepl <- base::grepl
[10:19:52.310]                           restarts <- computeRestarts(cond)
[10:19:52.310]                           for (restart in restarts) {
[10:19:52.310]                             name <- restart$name
[10:19:52.310]                             if (is.null(name)) 
[10:19:52.310]                               next
[10:19:52.310]                             if (!grepl(pattern, name)) 
[10:19:52.310]                               next
[10:19:52.310]                             invokeRestart(restart)
[10:19:52.310]                             muffled <- TRUE
[10:19:52.310]                             break
[10:19:52.310]                           }
[10:19:52.310]                         }
[10:19:52.310]                       }
[10:19:52.310]                       invisible(muffled)
[10:19:52.310]                     }
[10:19:52.310]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.310]                   }
[10:19:52.310]                 }
[10:19:52.310]             }
[10:19:52.310]         }))
[10:19:52.310]     }, error = function(ex) {
[10:19:52.310]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.310]                 ...future.rng), started = ...future.startTime, 
[10:19:52.310]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.310]             version = "1.8"), class = "FutureResult")
[10:19:52.310]     }, finally = {
[10:19:52.310]         if (!identical(...future.workdir, getwd())) 
[10:19:52.310]             setwd(...future.workdir)
[10:19:52.310]         {
[10:19:52.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.310]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.310]             }
[10:19:52.310]             base::options(...future.oldOptions)
[10:19:52.310]             if (.Platform$OS.type == "windows") {
[10:19:52.310]                 old_names <- names(...future.oldEnvVars)
[10:19:52.310]                 envs <- base::Sys.getenv()
[10:19:52.310]                 names <- names(envs)
[10:19:52.310]                 common <- intersect(names, old_names)
[10:19:52.310]                 added <- setdiff(names, old_names)
[10:19:52.310]                 removed <- setdiff(old_names, names)
[10:19:52.310]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.310]                   envs[common]]
[10:19:52.310]                 NAMES <- toupper(changed)
[10:19:52.310]                 args <- list()
[10:19:52.310]                 for (kk in seq_along(NAMES)) {
[10:19:52.310]                   name <- changed[[kk]]
[10:19:52.310]                   NAME <- NAMES[[kk]]
[10:19:52.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.310]                     next
[10:19:52.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.310]                 }
[10:19:52.310]                 NAMES <- toupper(added)
[10:19:52.310]                 for (kk in seq_along(NAMES)) {
[10:19:52.310]                   name <- added[[kk]]
[10:19:52.310]                   NAME <- NAMES[[kk]]
[10:19:52.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.310]                     next
[10:19:52.310]                   args[[name]] <- ""
[10:19:52.310]                 }
[10:19:52.310]                 NAMES <- toupper(removed)
[10:19:52.310]                 for (kk in seq_along(NAMES)) {
[10:19:52.310]                   name <- removed[[kk]]
[10:19:52.310]                   NAME <- NAMES[[kk]]
[10:19:52.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.310]                     next
[10:19:52.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.310]                 }
[10:19:52.310]                 if (length(args) > 0) 
[10:19:52.310]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.310]             }
[10:19:52.310]             else {
[10:19:52.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.310]             }
[10:19:52.310]             {
[10:19:52.310]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.310]                   0L) {
[10:19:52.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.310]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.310]                   base::options(opts)
[10:19:52.310]                 }
[10:19:52.310]                 {
[10:19:52.310]                   {
[10:19:52.310]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.310]                     NULL
[10:19:52.310]                   }
[10:19:52.310]                   options(future.plan = NULL)
[10:19:52.310]                   if (is.na(NA_character_)) 
[10:19:52.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.310]                     .init = FALSE)
[10:19:52.310]                 }
[10:19:52.310]             }
[10:19:52.310]         }
[10:19:52.310]     })
[10:19:52.310]     if (TRUE) {
[10:19:52.310]         base::sink(type = "output", split = FALSE)
[10:19:52.310]         if (TRUE) {
[10:19:52.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.310]         }
[10:19:52.310]         else {
[10:19:52.310]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.310]         }
[10:19:52.310]         base::close(...future.stdout)
[10:19:52.310]         ...future.stdout <- NULL
[10:19:52.310]     }
[10:19:52.310]     ...future.result$conditions <- ...future.conditions
[10:19:52.310]     ...future.result$finished <- base::Sys.time()
[10:19:52.310]     ...future.result
[10:19:52.310] }
[10:19:52.313] assign_globals() ...
[10:19:52.313] List of 11
[10:19:52.313]  $ ...future.FUN            :function (x, ...)  
[10:19:52.313]  $ x_FUN                    :function (x)  
[10:19:52.313]  $ times                    : int 1
[10:19:52.313]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.313]  $ stop_if_not              :function (...)  
[10:19:52.313]  $ dim                      : NULL
[10:19:52.313]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.313]  $ future.call.arguments    : list()
[10:19:52.313]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.313]  $ ...future.elements_ii    :List of 5
[10:19:52.313]   ..$ : int 6
[10:19:52.313]   ..$ : int 7
[10:19:52.313]   ..$ : int 8
[10:19:52.313]   ..$ : int 9
[10:19:52.313]   ..$ : int 10
[10:19:52.313]  $ ...future.seeds_ii       : NULL
[10:19:52.313]  $ ...future.globals.maxSize: NULL
[10:19:52.313]  - attr(*, "where")=List of 11
[10:19:52.313]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.313]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.313]  - attr(*, "resolved")= logi FALSE
[10:19:52.313]  - attr(*, "total_size")= num 22322
[10:19:52.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.313]  - attr(*, "already-done")= logi TRUE
[10:19:52.325] - copied ‘...future.FUN’ to environment
[10:19:52.325] - copied ‘x_FUN’ to environment
[10:19:52.325] - copied ‘times’ to environment
[10:19:52.325] - copied ‘stopf’ to environment
[10:19:52.325] - copied ‘stop_if_not’ to environment
[10:19:52.326] - copied ‘dim’ to environment
[10:19:52.326] - copied ‘valid_types’ to environment
[10:19:52.326] - copied ‘future.call.arguments’ to environment
[10:19:52.326] - copied ‘...future.elements_ii’ to environment
[10:19:52.326] - copied ‘...future.seeds_ii’ to environment
[10:19:52.326] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.326] assign_globals() ... done
[10:19:52.326] requestCore(): workers = 2
[10:19:52.329] MulticoreFuture started
[10:19:52.329] - Launch lazy future ... done
[10:19:52.329] run() for ‘MulticoreFuture’ ... done
[10:19:52.330] Created future:
[10:19:52.330] plan(): Setting new future strategy stack:
[10:19:52.331] List of future strategies:
[10:19:52.331] 1. sequential:
[10:19:52.331]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.331]    - tweaked: FALSE
[10:19:52.331]    - call: NULL
[10:19:52.332] plan(): nbrOfWorkers() = 1
[10:19:52.334] plan(): Setting new future strategy stack:
[10:19:52.334] List of future strategies:
[10:19:52.334] 1. multicore:
[10:19:52.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.334]    - tweaked: FALSE
[10:19:52.334]    - call: plan(strategy)
[10:19:52.337] plan(): nbrOfWorkers() = 2
[10:19:52.330] MulticoreFuture:
[10:19:52.330] Label: ‘future_vapply-2’
[10:19:52.330] Expression:
[10:19:52.330] {
[10:19:52.330]     do.call(function(...) {
[10:19:52.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.330]             on.exit(options(oopts), add = TRUE)
[10:19:52.330]         }
[10:19:52.330]         {
[10:19:52.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.330]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.330]             })
[10:19:52.330]         }
[10:19:52.330]     }, args = future.call.arguments)
[10:19:52.330] }
[10:19:52.330] Lazy evaluation: FALSE
[10:19:52.330] Asynchronous evaluation: TRUE
[10:19:52.330] Local evaluation: TRUE
[10:19:52.330] Environment: R_GlobalEnv
[10:19:52.330] Capture standard output: TRUE
[10:19:52.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.330] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.330] Packages: 1 packages (‘future.apply’)
[10:19:52.330] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.330] Resolved: TRUE
[10:19:52.330] Value: <not collected>
[10:19:52.330] Conditions captured: <none>
[10:19:52.330] Early signaling: FALSE
[10:19:52.330] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.330] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.338] Chunk #2 of 2 ... DONE
[10:19:52.338] Launching 2 futures (chunks) ... DONE
[10:19:52.338] Resolving 2 futures (chunks) ...
[10:19:52.339] resolve() on list ...
[10:19:52.339]  recursive: 0
[10:19:52.339]  length: 2
[10:19:52.339] 
[10:19:52.339] Future #1
[10:19:52.340] result() for MulticoreFuture ...
[10:19:52.341] result() for MulticoreFuture ...
[10:19:52.341] result() for MulticoreFuture ... done
[10:19:52.341] result() for MulticoreFuture ... done
[10:19:52.341] result() for MulticoreFuture ...
[10:19:52.341] result() for MulticoreFuture ... done
[10:19:52.341] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.341] - nx: 2
[10:19:52.341] - relay: TRUE
[10:19:52.342] - stdout: TRUE
[10:19:52.342] - signal: TRUE
[10:19:52.342] - resignal: FALSE
[10:19:52.342] - force: TRUE
[10:19:52.342] - relayed: [n=2] FALSE, FALSE
[10:19:52.342] - queued futures: [n=2] FALSE, FALSE
[10:19:52.342]  - until=1
[10:19:52.346]  - relaying element #1
[10:19:52.347] result() for MulticoreFuture ...
[10:19:52.347] result() for MulticoreFuture ... done
[10:19:52.347] result() for MulticoreFuture ...
[10:19:52.348] result() for MulticoreFuture ... done
[10:19:52.348] result() for MulticoreFuture ...
[10:19:52.349] result() for MulticoreFuture ... done
[10:19:52.349] result() for MulticoreFuture ...
[10:19:52.349] result() for MulticoreFuture ... done
[10:19:52.349] - relayed: [n=2] TRUE, FALSE
[10:19:52.350] - queued futures: [n=2] TRUE, FALSE
[10:19:52.350] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.350]  length: 1 (resolved future 1)
[10:19:52.351] Future #2
[10:19:52.351] result() for MulticoreFuture ...
[10:19:52.353] result() for MulticoreFuture ...
[10:19:52.353] result() for MulticoreFuture ... done
[10:19:52.353] result() for MulticoreFuture ... done
[10:19:52.353] result() for MulticoreFuture ...
[10:19:52.354] result() for MulticoreFuture ... done
[10:19:52.354] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.354] - nx: 2
[10:19:52.354] - relay: TRUE
[10:19:52.354] - stdout: TRUE
[10:19:52.355] - signal: TRUE
[10:19:52.355] - resignal: FALSE
[10:19:52.355] - force: TRUE
[10:19:52.355] - relayed: [n=2] TRUE, FALSE
[10:19:52.355] - queued futures: [n=2] TRUE, FALSE
[10:19:52.355]  - until=2
[10:19:52.356]  - relaying element #2
[10:19:52.356] result() for MulticoreFuture ...
[10:19:52.356] result() for MulticoreFuture ... done
[10:19:52.356] result() for MulticoreFuture ...
[10:19:52.356] result() for MulticoreFuture ... done
[10:19:52.356] result() for MulticoreFuture ...
[10:19:52.356] result() for MulticoreFuture ... done
[10:19:52.356] result() for MulticoreFuture ...
[10:19:52.357] result() for MulticoreFuture ... done
[10:19:52.357] - relayed: [n=2] TRUE, TRUE
[10:19:52.357] - queued futures: [n=2] TRUE, TRUE
[10:19:52.357] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.357]  length: 0 (resolved future 2)
[10:19:52.357] Relaying remaining futures
[10:19:52.357] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.357] - nx: 2
[10:19:52.357] - relay: TRUE
[10:19:52.357] - stdout: TRUE
[10:19:52.358] - signal: TRUE
[10:19:52.358] - resignal: FALSE
[10:19:52.358] - force: TRUE
[10:19:52.358] - relayed: [n=2] TRUE, TRUE
[10:19:52.358] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:52.358] - relayed: [n=2] TRUE, TRUE
[10:19:52.358] - queued futures: [n=2] TRUE, TRUE
[10:19:52.358] signalConditionsASAP(NULL, pos=0) ... done
[10:19:52.359] resolve() on list ... DONE
[10:19:52.359] result() for MulticoreFuture ...
[10:19:52.359] result() for MulticoreFuture ... done
[10:19:52.359] result() for MulticoreFuture ...
[10:19:52.359] result() for MulticoreFuture ... done
[10:19:52.359] result() for MulticoreFuture ...
[10:19:52.359] result() for MulticoreFuture ... done
[10:19:52.359] result() for MulticoreFuture ...
[10:19:52.359] result() for MulticoreFuture ... done
[10:19:52.360]  - Number of value chunks collected: 2
[10:19:52.360] Resolving 2 futures (chunks) ... DONE
[10:19:52.360] Reducing values from 2 chunks ...
[10:19:52.360]  - Number of values collected after concatenation: 10
[10:19:52.360]  - Number of values expected: 10
[10:19:52.360] Reducing values from 2 chunks ... DONE
[10:19:52.360] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:19:52.361] future_lapply() ...
[10:19:52.365] Number of chunks: 2
[10:19:52.365] getGlobalsAndPackagesXApply() ...
[10:19:52.365]  - future.globals: TRUE
[10:19:52.365] getGlobalsAndPackages() ...
[10:19:52.366] Searching for globals...
[10:19:52.370] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:19:52.370] Searching for globals ... DONE
[10:19:52.370] Resolving globals: FALSE
[10:19:52.371] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[10:19:52.371] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:52.371] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.372] - packages: [1] ‘future.apply’
[10:19:52.372] getGlobalsAndPackages() ... DONE
[10:19:52.372]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.372]  - needed namespaces: [n=1] ‘future.apply’
[10:19:52.372] Finding globals ... DONE
[10:19:52.372]  - use_args: TRUE
[10:19:52.372]  - Getting '...' globals ...
[10:19:52.372] resolve() on list ...
[10:19:52.373]  recursive: 0
[10:19:52.373]  length: 1
[10:19:52.373]  elements: ‘...’
[10:19:52.373]  length: 0 (resolved future 1)
[10:19:52.373] resolve() on list ... DONE
[10:19:52.373]    - '...' content: [n=0] 
[10:19:52.373] List of 1
[10:19:52.373]  $ ...: list()
[10:19:52.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.373]  - attr(*, "where")=List of 1
[10:19:52.373]   ..$ ...:<environment: 0x55c69d7c0328> 
[10:19:52.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.373]  - attr(*, "resolved")= logi TRUE
[10:19:52.373]  - attr(*, "total_size")= num NA
[10:19:52.378]  - Getting '...' globals ... DONE
[10:19:52.378] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:52.378] List of 8
[10:19:52.378]  $ ...future.FUN:function (x, ...)  
[10:19:52.378]  $ x_FUN        :function (x)  
[10:19:52.378]  $ times        : int 2
[10:19:52.378]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.378]  $ stop_if_not  :function (...)  
[10:19:52.378]  $ dim          : NULL
[10:19:52.378]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:52.378]  $ ...          : list()
[10:19:52.378]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.378]  - attr(*, "where")=List of 8
[10:19:52.378]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:52.378]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:52.378]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:52.378]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:52.378]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:52.378]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:52.378]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:52.378]   ..$ ...          :<environment: 0x55c69d7c0328> 
[10:19:52.378]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.378]  - attr(*, "resolved")= logi FALSE
[10:19:52.378]  - attr(*, "total_size")= num 24454
[10:19:52.384] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:52.384] getGlobalsAndPackagesXApply() ... DONE
[10:19:52.384] Number of futures (= number of chunks): 2
[10:19:52.384] Launching 2 futures (chunks) ...
[10:19:52.384] Chunk #1 of 2 ...
[10:19:52.384]  - Finding globals in 'X' for chunk #1 ...
[10:19:52.385] getGlobalsAndPackages() ...
[10:19:52.385] Searching for globals...
[10:19:52.385] 
[10:19:52.385] Searching for globals ... DONE
[10:19:52.385] - globals: [0] <none>
[10:19:52.385] getGlobalsAndPackages() ... DONE
[10:19:52.385]    + additional globals found: [n=0] 
[10:19:52.385]    + additional namespaces needed: [n=0] 
[10:19:52.385]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:52.386]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.386]  - seeds: <none>
[10:19:52.386]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.386] getGlobalsAndPackages() ...
[10:19:52.386] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.386] Resolving globals: FALSE
[10:19:52.386] Tweak future expression to call with '...' arguments ...
[10:19:52.386] {
[10:19:52.386]     do.call(function(...) {
[10:19:52.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.386]             on.exit(options(oopts), add = TRUE)
[10:19:52.386]         }
[10:19:52.386]         {
[10:19:52.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.386]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.386]             })
[10:19:52.386]         }
[10:19:52.386]     }, args = future.call.arguments)
[10:19:52.386] }
[10:19:52.386] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.387] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.387] - packages: [1] ‘future.apply’
[10:19:52.387] getGlobalsAndPackages() ... DONE
[10:19:52.388] run() for ‘Future’ ...
[10:19:52.388] - state: ‘created’
[10:19:52.388] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.389] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.390]   - Field: ‘label’
[10:19:52.390]   - Field: ‘local’
[10:19:52.390]   - Field: ‘owner’
[10:19:52.390]   - Field: ‘envir’
[10:19:52.390]   - Field: ‘workers’
[10:19:52.390]   - Field: ‘packages’
[10:19:52.390]   - Field: ‘gc’
[10:19:52.390]   - Field: ‘job’
[10:19:52.390]   - Field: ‘conditions’
[10:19:52.391]   - Field: ‘expr’
[10:19:52.391]   - Field: ‘uuid’
[10:19:52.391]   - Field: ‘seed’
[10:19:52.391]   - Field: ‘version’
[10:19:52.391]   - Field: ‘result’
[10:19:52.391]   - Field: ‘asynchronous’
[10:19:52.391]   - Field: ‘calls’
[10:19:52.391]   - Field: ‘globals’
[10:19:52.391]   - Field: ‘stdout’
[10:19:52.391]   - Field: ‘earlySignal’
[10:19:52.391]   - Field: ‘lazy’
[10:19:52.391]   - Field: ‘state’
[10:19:52.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.392] - Launch lazy future ...
[10:19:52.392] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.392] Packages needed by future strategies (n = 0): <none>
[10:19:52.393] {
[10:19:52.393]     {
[10:19:52.393]         {
[10:19:52.393]             ...future.startTime <- base::Sys.time()
[10:19:52.393]             {
[10:19:52.393]                 {
[10:19:52.393]                   {
[10:19:52.393]                     {
[10:19:52.393]                       {
[10:19:52.393]                         base::local({
[10:19:52.393]                           has_future <- base::requireNamespace("future", 
[10:19:52.393]                             quietly = TRUE)
[10:19:52.393]                           if (has_future) {
[10:19:52.393]                             ns <- base::getNamespace("future")
[10:19:52.393]                             version <- ns[[".package"]][["version"]]
[10:19:52.393]                             if (is.null(version)) 
[10:19:52.393]                               version <- utils::packageVersion("future")
[10:19:52.393]                           }
[10:19:52.393]                           else {
[10:19:52.393]                             version <- NULL
[10:19:52.393]                           }
[10:19:52.393]                           if (!has_future || version < "1.8.0") {
[10:19:52.393]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.393]                               "", base::R.version$version.string), 
[10:19:52.393]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.393]                                 base::R.version$platform, 8 * 
[10:19:52.393]                                   base::.Machine$sizeof.pointer), 
[10:19:52.393]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.393]                                 "release", "version")], collapse = " "), 
[10:19:52.393]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.393]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.393]                               info)
[10:19:52.393]                             info <- base::paste(info, collapse = "; ")
[10:19:52.393]                             if (!has_future) {
[10:19:52.393]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.393]                                 info)
[10:19:52.393]                             }
[10:19:52.393]                             else {
[10:19:52.393]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.393]                                 info, version)
[10:19:52.393]                             }
[10:19:52.393]                             base::stop(msg)
[10:19:52.393]                           }
[10:19:52.393]                         })
[10:19:52.393]                       }
[10:19:52.393]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.393]                       base::options(mc.cores = 1L)
[10:19:52.393]                     }
[10:19:52.393]                     base::local({
[10:19:52.393]                       for (pkg in "future.apply") {
[10:19:52.393]                         base::loadNamespace(pkg)
[10:19:52.393]                         base::library(pkg, character.only = TRUE)
[10:19:52.393]                       }
[10:19:52.393]                     })
[10:19:52.393]                   }
[10:19:52.393]                   ...future.strategy.old <- future::plan("list")
[10:19:52.393]                   options(future.plan = NULL)
[10:19:52.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.393]                 }
[10:19:52.393]                 ...future.workdir <- getwd()
[10:19:52.393]             }
[10:19:52.393]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.393]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.393]         }
[10:19:52.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.393]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.393]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.393]             base::names(...future.oldOptions))
[10:19:52.393]     }
[10:19:52.393]     if (FALSE) {
[10:19:52.393]     }
[10:19:52.393]     else {
[10:19:52.393]         if (TRUE) {
[10:19:52.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.393]                 open = "w")
[10:19:52.393]         }
[10:19:52.393]         else {
[10:19:52.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.393]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.393]         }
[10:19:52.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.393]             base::sink(type = "output", split = FALSE)
[10:19:52.393]             base::close(...future.stdout)
[10:19:52.393]         }, add = TRUE)
[10:19:52.393]     }
[10:19:52.393]     ...future.frame <- base::sys.nframe()
[10:19:52.393]     ...future.conditions <- base::list()
[10:19:52.393]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.393]     if (FALSE) {
[10:19:52.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.393]     }
[10:19:52.393]     ...future.result <- base::tryCatch({
[10:19:52.393]         base::withCallingHandlers({
[10:19:52.393]             ...future.value <- base::withVisible(base::local({
[10:19:52.393]                 withCallingHandlers({
[10:19:52.393]                   {
[10:19:52.393]                     do.call(function(...) {
[10:19:52.393]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.393]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.393]                         ...future.globals.maxSize)) {
[10:19:52.393]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.393]                         on.exit(options(oopts), add = TRUE)
[10:19:52.393]                       }
[10:19:52.393]                       {
[10:19:52.393]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.393]                           FUN = function(jj) {
[10:19:52.393]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.393]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.393]                           })
[10:19:52.393]                       }
[10:19:52.393]                     }, args = future.call.arguments)
[10:19:52.393]                   }
[10:19:52.393]                 }, immediateCondition = function(cond) {
[10:19:52.393]                   save_rds <- function (object, pathname, ...) 
[10:19:52.393]                   {
[10:19:52.393]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.393]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.393]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.393]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.393]                         fi_tmp[["mtime"]])
[10:19:52.393]                     }
[10:19:52.393]                     tryCatch({
[10:19:52.393]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.393]                     }, error = function(ex) {
[10:19:52.393]                       msg <- conditionMessage(ex)
[10:19:52.393]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.393]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.393]                         fi_tmp[["mtime"]], msg)
[10:19:52.393]                       ex$message <- msg
[10:19:52.393]                       stop(ex)
[10:19:52.393]                     })
[10:19:52.393]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.393]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.393]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.393]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.393]                       fi <- file.info(pathname)
[10:19:52.393]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.393]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.393]                         fi[["size"]], fi[["mtime"]])
[10:19:52.393]                       stop(msg)
[10:19:52.393]                     }
[10:19:52.393]                     invisible(pathname)
[10:19:52.393]                   }
[10:19:52.393]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.393]                     rootPath = tempdir()) 
[10:19:52.393]                   {
[10:19:52.393]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.393]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.393]                       tmpdir = path, fileext = ".rds")
[10:19:52.393]                     save_rds(obj, file)
[10:19:52.393]                   }
[10:19:52.393]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.393]                   {
[10:19:52.393]                     inherits <- base::inherits
[10:19:52.393]                     invokeRestart <- base::invokeRestart
[10:19:52.393]                     is.null <- base::is.null
[10:19:52.393]                     muffled <- FALSE
[10:19:52.393]                     if (inherits(cond, "message")) {
[10:19:52.393]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.393]                       if (muffled) 
[10:19:52.393]                         invokeRestart("muffleMessage")
[10:19:52.393]                     }
[10:19:52.393]                     else if (inherits(cond, "warning")) {
[10:19:52.393]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.393]                       if (muffled) 
[10:19:52.393]                         invokeRestart("muffleWarning")
[10:19:52.393]                     }
[10:19:52.393]                     else if (inherits(cond, "condition")) {
[10:19:52.393]                       if (!is.null(pattern)) {
[10:19:52.393]                         computeRestarts <- base::computeRestarts
[10:19:52.393]                         grepl <- base::grepl
[10:19:52.393]                         restarts <- computeRestarts(cond)
[10:19:52.393]                         for (restart in restarts) {
[10:19:52.393]                           name <- restart$name
[10:19:52.393]                           if (is.null(name)) 
[10:19:52.393]                             next
[10:19:52.393]                           if (!grepl(pattern, name)) 
[10:19:52.393]                             next
[10:19:52.393]                           invokeRestart(restart)
[10:19:52.393]                           muffled <- TRUE
[10:19:52.393]                           break
[10:19:52.393]                         }
[10:19:52.393]                       }
[10:19:52.393]                     }
[10:19:52.393]                     invisible(muffled)
[10:19:52.393]                   }
[10:19:52.393]                   muffleCondition(cond)
[10:19:52.393]                 })
[10:19:52.393]             }))
[10:19:52.393]             future::FutureResult(value = ...future.value$value, 
[10:19:52.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.393]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.393]                     ...future.globalenv.names))
[10:19:52.393]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.393]         }, condition = base::local({
[10:19:52.393]             c <- base::c
[10:19:52.393]             inherits <- base::inherits
[10:19:52.393]             invokeRestart <- base::invokeRestart
[10:19:52.393]             length <- base::length
[10:19:52.393]             list <- base::list
[10:19:52.393]             seq.int <- base::seq.int
[10:19:52.393]             signalCondition <- base::signalCondition
[10:19:52.393]             sys.calls <- base::sys.calls
[10:19:52.393]             `[[` <- base::`[[`
[10:19:52.393]             `+` <- base::`+`
[10:19:52.393]             `<<-` <- base::`<<-`
[10:19:52.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.393]                   3L)]
[10:19:52.393]             }
[10:19:52.393]             function(cond) {
[10:19:52.393]                 is_error <- inherits(cond, "error")
[10:19:52.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.393]                   NULL)
[10:19:52.393]                 if (is_error) {
[10:19:52.393]                   sessionInformation <- function() {
[10:19:52.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.393]                       search = base::search(), system = base::Sys.info())
[10:19:52.393]                   }
[10:19:52.393]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.393]                     cond$call), session = sessionInformation(), 
[10:19:52.393]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.393]                   signalCondition(cond)
[10:19:52.393]                 }
[10:19:52.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.393]                 "immediateCondition"))) {
[10:19:52.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.393]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.393]                   if (TRUE && !signal) {
[10:19:52.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.393]                     {
[10:19:52.393]                       inherits <- base::inherits
[10:19:52.393]                       invokeRestart <- base::invokeRestart
[10:19:52.393]                       is.null <- base::is.null
[10:19:52.393]                       muffled <- FALSE
[10:19:52.393]                       if (inherits(cond, "message")) {
[10:19:52.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.393]                         if (muffled) 
[10:19:52.393]                           invokeRestart("muffleMessage")
[10:19:52.393]                       }
[10:19:52.393]                       else if (inherits(cond, "warning")) {
[10:19:52.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.393]                         if (muffled) 
[10:19:52.393]                           invokeRestart("muffleWarning")
[10:19:52.393]                       }
[10:19:52.393]                       else if (inherits(cond, "condition")) {
[10:19:52.393]                         if (!is.null(pattern)) {
[10:19:52.393]                           computeRestarts <- base::computeRestarts
[10:19:52.393]                           grepl <- base::grepl
[10:19:52.393]                           restarts <- computeRestarts(cond)
[10:19:52.393]                           for (restart in restarts) {
[10:19:52.393]                             name <- restart$name
[10:19:52.393]                             if (is.null(name)) 
[10:19:52.393]                               next
[10:19:52.393]                             if (!grepl(pattern, name)) 
[10:19:52.393]                               next
[10:19:52.393]                             invokeRestart(restart)
[10:19:52.393]                             muffled <- TRUE
[10:19:52.393]                             break
[10:19:52.393]                           }
[10:19:52.393]                         }
[10:19:52.393]                       }
[10:19:52.393]                       invisible(muffled)
[10:19:52.393]                     }
[10:19:52.393]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.393]                   }
[10:19:52.393]                 }
[10:19:52.393]                 else {
[10:19:52.393]                   if (TRUE) {
[10:19:52.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.393]                     {
[10:19:52.393]                       inherits <- base::inherits
[10:19:52.393]                       invokeRestart <- base::invokeRestart
[10:19:52.393]                       is.null <- base::is.null
[10:19:52.393]                       muffled <- FALSE
[10:19:52.393]                       if (inherits(cond, "message")) {
[10:19:52.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.393]                         if (muffled) 
[10:19:52.393]                           invokeRestart("muffleMessage")
[10:19:52.393]                       }
[10:19:52.393]                       else if (inherits(cond, "warning")) {
[10:19:52.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.393]                         if (muffled) 
[10:19:52.393]                           invokeRestart("muffleWarning")
[10:19:52.393]                       }
[10:19:52.393]                       else if (inherits(cond, "condition")) {
[10:19:52.393]                         if (!is.null(pattern)) {
[10:19:52.393]                           computeRestarts <- base::computeRestarts
[10:19:52.393]                           grepl <- base::grepl
[10:19:52.393]                           restarts <- computeRestarts(cond)
[10:19:52.393]                           for (restart in restarts) {
[10:19:52.393]                             name <- restart$name
[10:19:52.393]                             if (is.null(name)) 
[10:19:52.393]                               next
[10:19:52.393]                             if (!grepl(pattern, name)) 
[10:19:52.393]                               next
[10:19:52.393]                             invokeRestart(restart)
[10:19:52.393]                             muffled <- TRUE
[10:19:52.393]                             break
[10:19:52.393]                           }
[10:19:52.393]                         }
[10:19:52.393]                       }
[10:19:52.393]                       invisible(muffled)
[10:19:52.393]                     }
[10:19:52.393]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.393]                   }
[10:19:52.393]                 }
[10:19:52.393]             }
[10:19:52.393]         }))
[10:19:52.393]     }, error = function(ex) {
[10:19:52.393]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.393]                 ...future.rng), started = ...future.startTime, 
[10:19:52.393]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.393]             version = "1.8"), class = "FutureResult")
[10:19:52.393]     }, finally = {
[10:19:52.393]         if (!identical(...future.workdir, getwd())) 
[10:19:52.393]             setwd(...future.workdir)
[10:19:52.393]         {
[10:19:52.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.393]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.393]             }
[10:19:52.393]             base::options(...future.oldOptions)
[10:19:52.393]             if (.Platform$OS.type == "windows") {
[10:19:52.393]                 old_names <- names(...future.oldEnvVars)
[10:19:52.393]                 envs <- base::Sys.getenv()
[10:19:52.393]                 names <- names(envs)
[10:19:52.393]                 common <- intersect(names, old_names)
[10:19:52.393]                 added <- setdiff(names, old_names)
[10:19:52.393]                 removed <- setdiff(old_names, names)
[10:19:52.393]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.393]                   envs[common]]
[10:19:52.393]                 NAMES <- toupper(changed)
[10:19:52.393]                 args <- list()
[10:19:52.393]                 for (kk in seq_along(NAMES)) {
[10:19:52.393]                   name <- changed[[kk]]
[10:19:52.393]                   NAME <- NAMES[[kk]]
[10:19:52.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.393]                     next
[10:19:52.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.393]                 }
[10:19:52.393]                 NAMES <- toupper(added)
[10:19:52.393]                 for (kk in seq_along(NAMES)) {
[10:19:52.393]                   name <- added[[kk]]
[10:19:52.393]                   NAME <- NAMES[[kk]]
[10:19:52.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.393]                     next
[10:19:52.393]                   args[[name]] <- ""
[10:19:52.393]                 }
[10:19:52.393]                 NAMES <- toupper(removed)
[10:19:52.393]                 for (kk in seq_along(NAMES)) {
[10:19:52.393]                   name <- removed[[kk]]
[10:19:52.393]                   NAME <- NAMES[[kk]]
[10:19:52.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.393]                     next
[10:19:52.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.393]                 }
[10:19:52.393]                 if (length(args) > 0) 
[10:19:52.393]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.393]             }
[10:19:52.393]             else {
[10:19:52.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.393]             }
[10:19:52.393]             {
[10:19:52.393]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.393]                   0L) {
[10:19:52.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.393]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.393]                   base::options(opts)
[10:19:52.393]                 }
[10:19:52.393]                 {
[10:19:52.393]                   {
[10:19:52.393]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.393]                     NULL
[10:19:52.393]                   }
[10:19:52.393]                   options(future.plan = NULL)
[10:19:52.393]                   if (is.na(NA_character_)) 
[10:19:52.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.393]                     .init = FALSE)
[10:19:52.393]                 }
[10:19:52.393]             }
[10:19:52.393]         }
[10:19:52.393]     })
[10:19:52.393]     if (TRUE) {
[10:19:52.393]         base::sink(type = "output", split = FALSE)
[10:19:52.393]         if (TRUE) {
[10:19:52.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.393]         }
[10:19:52.393]         else {
[10:19:52.393]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.393]         }
[10:19:52.393]         base::close(...future.stdout)
[10:19:52.393]         ...future.stdout <- NULL
[10:19:52.393]     }
[10:19:52.393]     ...future.result$conditions <- ...future.conditions
[10:19:52.393]     ...future.result$finished <- base::Sys.time()
[10:19:52.393]     ...future.result
[10:19:52.393] }
[10:19:52.395] assign_globals() ...
[10:19:52.395] List of 11
[10:19:52.395]  $ ...future.FUN            :function (x, ...)  
[10:19:52.395]  $ x_FUN                    :function (x)  
[10:19:52.395]  $ times                    : int 2
[10:19:52.395]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.395]  $ stop_if_not              :function (...)  
[10:19:52.395]  $ dim                      : NULL
[10:19:52.395]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.395]  $ future.call.arguments    : list()
[10:19:52.395]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.395]  $ ...future.elements_ii    :List of 5
[10:19:52.395]   ..$ : int 1
[10:19:52.395]   ..$ : int 2
[10:19:52.395]   ..$ : int 3
[10:19:52.395]   ..$ : int 4
[10:19:52.395]   ..$ : int 5
[10:19:52.395]  $ ...future.seeds_ii       : NULL
[10:19:52.395]  $ ...future.globals.maxSize: NULL
[10:19:52.395]  - attr(*, "where")=List of 11
[10:19:52.395]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.395]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.395]  - attr(*, "resolved")= logi FALSE
[10:19:52.395]  - attr(*, "total_size")= num 24454
[10:19:52.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.395]  - attr(*, "already-done")= logi TRUE
[10:19:52.406] - copied ‘...future.FUN’ to environment
[10:19:52.406] - reassign environment for ‘x_FUN’
[10:19:52.406] - copied ‘x_FUN’ to environment
[10:19:52.406] - copied ‘times’ to environment
[10:19:52.406] - copied ‘stopf’ to environment
[10:19:52.406] - copied ‘stop_if_not’ to environment
[10:19:52.406] - copied ‘dim’ to environment
[10:19:52.406] - copied ‘valid_types’ to environment
[10:19:52.406] - copied ‘future.call.arguments’ to environment
[10:19:52.406] - copied ‘...future.elements_ii’ to environment
[10:19:52.407] - copied ‘...future.seeds_ii’ to environment
[10:19:52.407] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.407] assign_globals() ... done
[10:19:52.407] requestCore(): workers = 2
[10:19:52.409] MulticoreFuture started
[10:19:52.410] - Launch lazy future ... done
[10:19:52.410] run() for ‘MulticoreFuture’ ... done
[10:19:52.410] Created future:
[10:19:52.411] plan(): Setting new future strategy stack:
[10:19:52.411] List of future strategies:
[10:19:52.411] 1. sequential:
[10:19:52.411]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.411]    - tweaked: FALSE
[10:19:52.411]    - call: NULL
[10:19:52.412] plan(): nbrOfWorkers() = 1
[10:19:52.414] plan(): Setting new future strategy stack:
[10:19:52.414] List of future strategies:
[10:19:52.414] 1. multicore:
[10:19:52.414]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.414]    - tweaked: FALSE
[10:19:52.414]    - call: plan(strategy)
[10:19:52.417] plan(): nbrOfWorkers() = 2
[10:19:52.410] MulticoreFuture:
[10:19:52.410] Label: ‘future_vapply-1’
[10:19:52.410] Expression:
[10:19:52.410] {
[10:19:52.410]     do.call(function(...) {
[10:19:52.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.410]             on.exit(options(oopts), add = TRUE)
[10:19:52.410]         }
[10:19:52.410]         {
[10:19:52.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.410]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.410]             })
[10:19:52.410]         }
[10:19:52.410]     }, args = future.call.arguments)
[10:19:52.410] }
[10:19:52.410] Lazy evaluation: FALSE
[10:19:52.410] Asynchronous evaluation: TRUE
[10:19:52.410] Local evaluation: TRUE
[10:19:52.410] Environment: R_GlobalEnv
[10:19:52.410] Capture standard output: TRUE
[10:19:52.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.410] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.410] Packages: 1 packages (‘future.apply’)
[10:19:52.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.410] Resolved: TRUE
[10:19:52.410] Value: <not collected>
[10:19:52.410] Conditions captured: <none>
[10:19:52.410] Early signaling: FALSE
[10:19:52.410] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.410] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.418] Chunk #1 of 2 ... DONE
[10:19:52.419] Chunk #2 of 2 ...
[10:19:52.419]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.419] getGlobalsAndPackages() ...
[10:19:52.419] Searching for globals...
[10:19:52.420] 
[10:19:52.420] Searching for globals ... DONE
[10:19:52.420] - globals: [0] <none>
[10:19:52.420] getGlobalsAndPackages() ... DONE
[10:19:52.420]    + additional globals found: [n=0] 
[10:19:52.420]    + additional namespaces needed: [n=0] 
[10:19:52.420]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.421]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.421]  - seeds: <none>
[10:19:52.421]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.421] getGlobalsAndPackages() ...
[10:19:52.421] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.421] Resolving globals: FALSE
[10:19:52.422] Tweak future expression to call with '...' arguments ...
[10:19:52.422] {
[10:19:52.422]     do.call(function(...) {
[10:19:52.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.422]             on.exit(options(oopts), add = TRUE)
[10:19:52.422]         }
[10:19:52.422]         {
[10:19:52.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.422]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.422]             })
[10:19:52.422]         }
[10:19:52.422]     }, args = future.call.arguments)
[10:19:52.422] }
[10:19:52.422] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.423] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.423] - packages: [1] ‘future.apply’
[10:19:52.423] getGlobalsAndPackages() ... DONE
[10:19:52.424] run() for ‘Future’ ...
[10:19:52.424] - state: ‘created’
[10:19:52.424] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.427] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.427]   - Field: ‘label’
[10:19:52.427]   - Field: ‘local’
[10:19:52.428]   - Field: ‘owner’
[10:19:52.428]   - Field: ‘envir’
[10:19:52.428]   - Field: ‘workers’
[10:19:52.428]   - Field: ‘packages’
[10:19:52.428]   - Field: ‘gc’
[10:19:52.428]   - Field: ‘job’
[10:19:52.429]   - Field: ‘conditions’
[10:19:52.429]   - Field: ‘expr’
[10:19:52.429]   - Field: ‘uuid’
[10:19:52.429]   - Field: ‘seed’
[10:19:52.429]   - Field: ‘version’
[10:19:52.429]   - Field: ‘result’
[10:19:52.429]   - Field: ‘asynchronous’
[10:19:52.429]   - Field: ‘calls’
[10:19:52.430]   - Field: ‘globals’
[10:19:52.430]   - Field: ‘stdout’
[10:19:52.430]   - Field: ‘earlySignal’
[10:19:52.430]   - Field: ‘lazy’
[10:19:52.430]   - Field: ‘state’
[10:19:52.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.430] - Launch lazy future ...
[10:19:52.431] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.431] Packages needed by future strategies (n = 0): <none>
[10:19:52.432] {
[10:19:52.432]     {
[10:19:52.432]         {
[10:19:52.432]             ...future.startTime <- base::Sys.time()
[10:19:52.432]             {
[10:19:52.432]                 {
[10:19:52.432]                   {
[10:19:52.432]                     {
[10:19:52.432]                       {
[10:19:52.432]                         base::local({
[10:19:52.432]                           has_future <- base::requireNamespace("future", 
[10:19:52.432]                             quietly = TRUE)
[10:19:52.432]                           if (has_future) {
[10:19:52.432]                             ns <- base::getNamespace("future")
[10:19:52.432]                             version <- ns[[".package"]][["version"]]
[10:19:52.432]                             if (is.null(version)) 
[10:19:52.432]                               version <- utils::packageVersion("future")
[10:19:52.432]                           }
[10:19:52.432]                           else {
[10:19:52.432]                             version <- NULL
[10:19:52.432]                           }
[10:19:52.432]                           if (!has_future || version < "1.8.0") {
[10:19:52.432]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.432]                               "", base::R.version$version.string), 
[10:19:52.432]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.432]                                 base::R.version$platform, 8 * 
[10:19:52.432]                                   base::.Machine$sizeof.pointer), 
[10:19:52.432]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.432]                                 "release", "version")], collapse = " "), 
[10:19:52.432]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.432]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.432]                               info)
[10:19:52.432]                             info <- base::paste(info, collapse = "; ")
[10:19:52.432]                             if (!has_future) {
[10:19:52.432]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.432]                                 info)
[10:19:52.432]                             }
[10:19:52.432]                             else {
[10:19:52.432]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.432]                                 info, version)
[10:19:52.432]                             }
[10:19:52.432]                             base::stop(msg)
[10:19:52.432]                           }
[10:19:52.432]                         })
[10:19:52.432]                       }
[10:19:52.432]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.432]                       base::options(mc.cores = 1L)
[10:19:52.432]                     }
[10:19:52.432]                     base::local({
[10:19:52.432]                       for (pkg in "future.apply") {
[10:19:52.432]                         base::loadNamespace(pkg)
[10:19:52.432]                         base::library(pkg, character.only = TRUE)
[10:19:52.432]                       }
[10:19:52.432]                     })
[10:19:52.432]                   }
[10:19:52.432]                   ...future.strategy.old <- future::plan("list")
[10:19:52.432]                   options(future.plan = NULL)
[10:19:52.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.432]                 }
[10:19:52.432]                 ...future.workdir <- getwd()
[10:19:52.432]             }
[10:19:52.432]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.432]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.432]         }
[10:19:52.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.432]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.432]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.432]             base::names(...future.oldOptions))
[10:19:52.432]     }
[10:19:52.432]     if (FALSE) {
[10:19:52.432]     }
[10:19:52.432]     else {
[10:19:52.432]         if (TRUE) {
[10:19:52.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.432]                 open = "w")
[10:19:52.432]         }
[10:19:52.432]         else {
[10:19:52.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.432]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.432]         }
[10:19:52.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.432]             base::sink(type = "output", split = FALSE)
[10:19:52.432]             base::close(...future.stdout)
[10:19:52.432]         }, add = TRUE)
[10:19:52.432]     }
[10:19:52.432]     ...future.frame <- base::sys.nframe()
[10:19:52.432]     ...future.conditions <- base::list()
[10:19:52.432]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.432]     if (FALSE) {
[10:19:52.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.432]     }
[10:19:52.432]     ...future.result <- base::tryCatch({
[10:19:52.432]         base::withCallingHandlers({
[10:19:52.432]             ...future.value <- base::withVisible(base::local({
[10:19:52.432]                 withCallingHandlers({
[10:19:52.432]                   {
[10:19:52.432]                     do.call(function(...) {
[10:19:52.432]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.432]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.432]                         ...future.globals.maxSize)) {
[10:19:52.432]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.432]                         on.exit(options(oopts), add = TRUE)
[10:19:52.432]                       }
[10:19:52.432]                       {
[10:19:52.432]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.432]                           FUN = function(jj) {
[10:19:52.432]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.432]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.432]                           })
[10:19:52.432]                       }
[10:19:52.432]                     }, args = future.call.arguments)
[10:19:52.432]                   }
[10:19:52.432]                 }, immediateCondition = function(cond) {
[10:19:52.432]                   save_rds <- function (object, pathname, ...) 
[10:19:52.432]                   {
[10:19:52.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.432]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.432]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.432]                         fi_tmp[["mtime"]])
[10:19:52.432]                     }
[10:19:52.432]                     tryCatch({
[10:19:52.432]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.432]                     }, error = function(ex) {
[10:19:52.432]                       msg <- conditionMessage(ex)
[10:19:52.432]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.432]                         fi_tmp[["mtime"]], msg)
[10:19:52.432]                       ex$message <- msg
[10:19:52.432]                       stop(ex)
[10:19:52.432]                     })
[10:19:52.432]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.432]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.432]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.432]                       fi <- file.info(pathname)
[10:19:52.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.432]                         fi[["size"]], fi[["mtime"]])
[10:19:52.432]                       stop(msg)
[10:19:52.432]                     }
[10:19:52.432]                     invisible(pathname)
[10:19:52.432]                   }
[10:19:52.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.432]                     rootPath = tempdir()) 
[10:19:52.432]                   {
[10:19:52.432]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.432]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.432]                       tmpdir = path, fileext = ".rds")
[10:19:52.432]                     save_rds(obj, file)
[10:19:52.432]                   }
[10:19:52.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.432]                   {
[10:19:52.432]                     inherits <- base::inherits
[10:19:52.432]                     invokeRestart <- base::invokeRestart
[10:19:52.432]                     is.null <- base::is.null
[10:19:52.432]                     muffled <- FALSE
[10:19:52.432]                     if (inherits(cond, "message")) {
[10:19:52.432]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.432]                       if (muffled) 
[10:19:52.432]                         invokeRestart("muffleMessage")
[10:19:52.432]                     }
[10:19:52.432]                     else if (inherits(cond, "warning")) {
[10:19:52.432]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.432]                       if (muffled) 
[10:19:52.432]                         invokeRestart("muffleWarning")
[10:19:52.432]                     }
[10:19:52.432]                     else if (inherits(cond, "condition")) {
[10:19:52.432]                       if (!is.null(pattern)) {
[10:19:52.432]                         computeRestarts <- base::computeRestarts
[10:19:52.432]                         grepl <- base::grepl
[10:19:52.432]                         restarts <- computeRestarts(cond)
[10:19:52.432]                         for (restart in restarts) {
[10:19:52.432]                           name <- restart$name
[10:19:52.432]                           if (is.null(name)) 
[10:19:52.432]                             next
[10:19:52.432]                           if (!grepl(pattern, name)) 
[10:19:52.432]                             next
[10:19:52.432]                           invokeRestart(restart)
[10:19:52.432]                           muffled <- TRUE
[10:19:52.432]                           break
[10:19:52.432]                         }
[10:19:52.432]                       }
[10:19:52.432]                     }
[10:19:52.432]                     invisible(muffled)
[10:19:52.432]                   }
[10:19:52.432]                   muffleCondition(cond)
[10:19:52.432]                 })
[10:19:52.432]             }))
[10:19:52.432]             future::FutureResult(value = ...future.value$value, 
[10:19:52.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.432]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.432]                     ...future.globalenv.names))
[10:19:52.432]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.432]         }, condition = base::local({
[10:19:52.432]             c <- base::c
[10:19:52.432]             inherits <- base::inherits
[10:19:52.432]             invokeRestart <- base::invokeRestart
[10:19:52.432]             length <- base::length
[10:19:52.432]             list <- base::list
[10:19:52.432]             seq.int <- base::seq.int
[10:19:52.432]             signalCondition <- base::signalCondition
[10:19:52.432]             sys.calls <- base::sys.calls
[10:19:52.432]             `[[` <- base::`[[`
[10:19:52.432]             `+` <- base::`+`
[10:19:52.432]             `<<-` <- base::`<<-`
[10:19:52.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.432]                   3L)]
[10:19:52.432]             }
[10:19:52.432]             function(cond) {
[10:19:52.432]                 is_error <- inherits(cond, "error")
[10:19:52.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.432]                   NULL)
[10:19:52.432]                 if (is_error) {
[10:19:52.432]                   sessionInformation <- function() {
[10:19:52.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.432]                       search = base::search(), system = base::Sys.info())
[10:19:52.432]                   }
[10:19:52.432]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.432]                     cond$call), session = sessionInformation(), 
[10:19:52.432]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.432]                   signalCondition(cond)
[10:19:52.432]                 }
[10:19:52.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.432]                 "immediateCondition"))) {
[10:19:52.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.432]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.432]                   if (TRUE && !signal) {
[10:19:52.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.432]                     {
[10:19:52.432]                       inherits <- base::inherits
[10:19:52.432]                       invokeRestart <- base::invokeRestart
[10:19:52.432]                       is.null <- base::is.null
[10:19:52.432]                       muffled <- FALSE
[10:19:52.432]                       if (inherits(cond, "message")) {
[10:19:52.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.432]                         if (muffled) 
[10:19:52.432]                           invokeRestart("muffleMessage")
[10:19:52.432]                       }
[10:19:52.432]                       else if (inherits(cond, "warning")) {
[10:19:52.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.432]                         if (muffled) 
[10:19:52.432]                           invokeRestart("muffleWarning")
[10:19:52.432]                       }
[10:19:52.432]                       else if (inherits(cond, "condition")) {
[10:19:52.432]                         if (!is.null(pattern)) {
[10:19:52.432]                           computeRestarts <- base::computeRestarts
[10:19:52.432]                           grepl <- base::grepl
[10:19:52.432]                           restarts <- computeRestarts(cond)
[10:19:52.432]                           for (restart in restarts) {
[10:19:52.432]                             name <- restart$name
[10:19:52.432]                             if (is.null(name)) 
[10:19:52.432]                               next
[10:19:52.432]                             if (!grepl(pattern, name)) 
[10:19:52.432]                               next
[10:19:52.432]                             invokeRestart(restart)
[10:19:52.432]                             muffled <- TRUE
[10:19:52.432]                             break
[10:19:52.432]                           }
[10:19:52.432]                         }
[10:19:52.432]                       }
[10:19:52.432]                       invisible(muffled)
[10:19:52.432]                     }
[10:19:52.432]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.432]                   }
[10:19:52.432]                 }
[10:19:52.432]                 else {
[10:19:52.432]                   if (TRUE) {
[10:19:52.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.432]                     {
[10:19:52.432]                       inherits <- base::inherits
[10:19:52.432]                       invokeRestart <- base::invokeRestart
[10:19:52.432]                       is.null <- base::is.null
[10:19:52.432]                       muffled <- FALSE
[10:19:52.432]                       if (inherits(cond, "message")) {
[10:19:52.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.432]                         if (muffled) 
[10:19:52.432]                           invokeRestart("muffleMessage")
[10:19:52.432]                       }
[10:19:52.432]                       else if (inherits(cond, "warning")) {
[10:19:52.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.432]                         if (muffled) 
[10:19:52.432]                           invokeRestart("muffleWarning")
[10:19:52.432]                       }
[10:19:52.432]                       else if (inherits(cond, "condition")) {
[10:19:52.432]                         if (!is.null(pattern)) {
[10:19:52.432]                           computeRestarts <- base::computeRestarts
[10:19:52.432]                           grepl <- base::grepl
[10:19:52.432]                           restarts <- computeRestarts(cond)
[10:19:52.432]                           for (restart in restarts) {
[10:19:52.432]                             name <- restart$name
[10:19:52.432]                             if (is.null(name)) 
[10:19:52.432]                               next
[10:19:52.432]                             if (!grepl(pattern, name)) 
[10:19:52.432]                               next
[10:19:52.432]                             invokeRestart(restart)
[10:19:52.432]                             muffled <- TRUE
[10:19:52.432]                             break
[10:19:52.432]                           }
[10:19:52.432]                         }
[10:19:52.432]                       }
[10:19:52.432]                       invisible(muffled)
[10:19:52.432]                     }
[10:19:52.432]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.432]                   }
[10:19:52.432]                 }
[10:19:52.432]             }
[10:19:52.432]         }))
[10:19:52.432]     }, error = function(ex) {
[10:19:52.432]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.432]                 ...future.rng), started = ...future.startTime, 
[10:19:52.432]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.432]             version = "1.8"), class = "FutureResult")
[10:19:52.432]     }, finally = {
[10:19:52.432]         if (!identical(...future.workdir, getwd())) 
[10:19:52.432]             setwd(...future.workdir)
[10:19:52.432]         {
[10:19:52.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.432]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.432]             }
[10:19:52.432]             base::options(...future.oldOptions)
[10:19:52.432]             if (.Platform$OS.type == "windows") {
[10:19:52.432]                 old_names <- names(...future.oldEnvVars)
[10:19:52.432]                 envs <- base::Sys.getenv()
[10:19:52.432]                 names <- names(envs)
[10:19:52.432]                 common <- intersect(names, old_names)
[10:19:52.432]                 added <- setdiff(names, old_names)
[10:19:52.432]                 removed <- setdiff(old_names, names)
[10:19:52.432]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.432]                   envs[common]]
[10:19:52.432]                 NAMES <- toupper(changed)
[10:19:52.432]                 args <- list()
[10:19:52.432]                 for (kk in seq_along(NAMES)) {
[10:19:52.432]                   name <- changed[[kk]]
[10:19:52.432]                   NAME <- NAMES[[kk]]
[10:19:52.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.432]                     next
[10:19:52.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.432]                 }
[10:19:52.432]                 NAMES <- toupper(added)
[10:19:52.432]                 for (kk in seq_along(NAMES)) {
[10:19:52.432]                   name <- added[[kk]]
[10:19:52.432]                   NAME <- NAMES[[kk]]
[10:19:52.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.432]                     next
[10:19:52.432]                   args[[name]] <- ""
[10:19:52.432]                 }
[10:19:52.432]                 NAMES <- toupper(removed)
[10:19:52.432]                 for (kk in seq_along(NAMES)) {
[10:19:52.432]                   name <- removed[[kk]]
[10:19:52.432]                   NAME <- NAMES[[kk]]
[10:19:52.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.432]                     next
[10:19:52.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.432]                 }
[10:19:52.432]                 if (length(args) > 0) 
[10:19:52.432]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.432]             }
[10:19:52.432]             else {
[10:19:52.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.432]             }
[10:19:52.432]             {
[10:19:52.432]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.432]                   0L) {
[10:19:52.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.432]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.432]                   base::options(opts)
[10:19:52.432]                 }
[10:19:52.432]                 {
[10:19:52.432]                   {
[10:19:52.432]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.432]                     NULL
[10:19:52.432]                   }
[10:19:52.432]                   options(future.plan = NULL)
[10:19:52.432]                   if (is.na(NA_character_)) 
[10:19:52.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.432]                     .init = FALSE)
[10:19:52.432]                 }
[10:19:52.432]             }
[10:19:52.432]         }
[10:19:52.432]     })
[10:19:52.432]     if (TRUE) {
[10:19:52.432]         base::sink(type = "output", split = FALSE)
[10:19:52.432]         if (TRUE) {
[10:19:52.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.432]         }
[10:19:52.432]         else {
[10:19:52.432]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.432]         }
[10:19:52.432]         base::close(...future.stdout)
[10:19:52.432]         ...future.stdout <- NULL
[10:19:52.432]     }
[10:19:52.432]     ...future.result$conditions <- ...future.conditions
[10:19:52.432]     ...future.result$finished <- base::Sys.time()
[10:19:52.432]     ...future.result
[10:19:52.432] }
[10:19:52.435] assign_globals() ...
[10:19:52.436] List of 11
[10:19:52.436]  $ ...future.FUN            :function (x, ...)  
[10:19:52.436]  $ x_FUN                    :function (x)  
[10:19:52.436]  $ times                    : int 2
[10:19:52.436]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.436]  $ stop_if_not              :function (...)  
[10:19:52.436]  $ dim                      : NULL
[10:19:52.436]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.436]  $ future.call.arguments    : list()
[10:19:52.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.436]  $ ...future.elements_ii    :List of 5
[10:19:52.436]   ..$ : int 6
[10:19:52.436]   ..$ : int 7
[10:19:52.436]   ..$ : int 8
[10:19:52.436]   ..$ : int 9
[10:19:52.436]   ..$ : int 10
[10:19:52.436]  $ ...future.seeds_ii       : NULL
[10:19:52.436]  $ ...future.globals.maxSize: NULL
[10:19:52.436]  - attr(*, "where")=List of 11
[10:19:52.436]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.436]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.436]  - attr(*, "resolved")= logi FALSE
[10:19:52.436]  - attr(*, "total_size")= num 24454
[10:19:52.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.436]  - attr(*, "already-done")= logi TRUE
[10:19:52.454] - copied ‘...future.FUN’ to environment
[10:19:52.454] - reassign environment for ‘x_FUN’
[10:19:52.454] - copied ‘x_FUN’ to environment
[10:19:52.454] - copied ‘times’ to environment
[10:19:52.454] - copied ‘stopf’ to environment
[10:19:52.454] - copied ‘stop_if_not’ to environment
[10:19:52.455] - copied ‘dim’ to environment
[10:19:52.455] - copied ‘valid_types’ to environment
[10:19:52.455] - copied ‘future.call.arguments’ to environment
[10:19:52.455] - copied ‘...future.elements_ii’ to environment
[10:19:52.455] - copied ‘...future.seeds_ii’ to environment
[10:19:52.455] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.455] assign_globals() ... done
[10:19:52.455] requestCore(): workers = 2
[10:19:52.458] MulticoreFuture started
[10:19:52.458] - Launch lazy future ... done
[10:19:52.458] run() for ‘MulticoreFuture’ ... done
[10:19:52.458] Created future:
[10:19:52.459] plan(): Setting new future strategy stack:
[10:19:52.459] List of future strategies:
[10:19:52.459] 1. sequential:
[10:19:52.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.459]    - tweaked: FALSE
[10:19:52.459]    - call: NULL
[10:19:52.460] plan(): nbrOfWorkers() = 1
[10:19:52.462] plan(): Setting new future strategy stack:
[10:19:52.463] List of future strategies:
[10:19:52.463] 1. multicore:
[10:19:52.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.463]    - tweaked: FALSE
[10:19:52.463]    - call: plan(strategy)
[10:19:52.466] plan(): nbrOfWorkers() = 2
[10:19:52.459] MulticoreFuture:
[10:19:52.459] Label: ‘future_vapply-2’
[10:19:52.459] Expression:
[10:19:52.459] {
[10:19:52.459]     do.call(function(...) {
[10:19:52.459]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.459]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.459]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.459]             on.exit(options(oopts), add = TRUE)
[10:19:52.459]         }
[10:19:52.459]         {
[10:19:52.459]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.459]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.459]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.459]             })
[10:19:52.459]         }
[10:19:52.459]     }, args = future.call.arguments)
[10:19:52.459] }
[10:19:52.459] Lazy evaluation: FALSE
[10:19:52.459] Asynchronous evaluation: TRUE
[10:19:52.459] Local evaluation: TRUE
[10:19:52.459] Environment: R_GlobalEnv
[10:19:52.459] Capture standard output: TRUE
[10:19:52.459] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.459] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.459] Packages: 1 packages (‘future.apply’)
[10:19:52.459] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.459] Resolved: TRUE
[10:19:52.459] Value: <not collected>
[10:19:52.459] Conditions captured: <none>
[10:19:52.459] Early signaling: FALSE
[10:19:52.459] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.459] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.467] Chunk #2 of 2 ... DONE
[10:19:52.467] Launching 2 futures (chunks) ... DONE
[10:19:52.467] Resolving 2 futures (chunks) ...
[10:19:52.467] resolve() on list ...
[10:19:52.467]  recursive: 0
[10:19:52.467]  length: 2
[10:19:52.468] 
[10:19:52.468] Future #1
[10:19:52.468] result() for MulticoreFuture ...
[10:19:52.469] result() for MulticoreFuture ...
[10:19:52.469] result() for MulticoreFuture ... done
[10:19:52.469] result() for MulticoreFuture ... done
[10:19:52.469] result() for MulticoreFuture ...
[10:19:52.469] result() for MulticoreFuture ... done
[10:19:52.470] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.470] - nx: 2
[10:19:52.470] - relay: TRUE
[10:19:52.470] - stdout: TRUE
[10:19:52.470] - signal: TRUE
[10:19:52.470] - resignal: FALSE
[10:19:52.470] - force: TRUE
[10:19:52.471] - relayed: [n=2] FALSE, FALSE
[10:19:52.471] - queued futures: [n=2] FALSE, FALSE
[10:19:52.471]  - until=1
[10:19:52.471]  - relaying element #1
[10:19:52.471] result() for MulticoreFuture ...
[10:19:52.471] result() for MulticoreFuture ... done
[10:19:52.472] result() for MulticoreFuture ...
[10:19:52.472] result() for MulticoreFuture ... done
[10:19:52.472] result() for MulticoreFuture ...
[10:19:52.472] result() for MulticoreFuture ... done
[10:19:52.472] result() for MulticoreFuture ...
[10:19:52.472] result() for MulticoreFuture ... done
[10:19:52.472] - relayed: [n=2] TRUE, FALSE
[10:19:52.473] - queued futures: [n=2] TRUE, FALSE
[10:19:52.473] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.473]  length: 1 (resolved future 1)
[10:19:52.473] Future #2
[10:19:52.473] result() for MulticoreFuture ...
[10:19:52.474] result() for MulticoreFuture ...
[10:19:52.474] result() for MulticoreFuture ... done
[10:19:52.474] result() for MulticoreFuture ... done
[10:19:52.475] result() for MulticoreFuture ...
[10:19:52.475] result() for MulticoreFuture ... done
[10:19:52.475] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.475] - nx: 2
[10:19:52.475] - relay: TRUE
[10:19:52.475] - stdout: TRUE
[10:19:52.475] - signal: TRUE
[10:19:52.475] - resignal: FALSE
[10:19:52.476] - force: TRUE
[10:19:52.476] - relayed: [n=2] TRUE, FALSE
[10:19:52.476] - queued futures: [n=2] TRUE, FALSE
[10:19:52.476]  - until=2
[10:19:52.476]  - relaying element #2
[10:19:52.476] result() for MulticoreFuture ...
[10:19:52.476] result() for MulticoreFuture ... done
[10:19:52.476] result() for MulticoreFuture ...
[10:19:52.477] result() for MulticoreFuture ... done
[10:19:52.477] result() for MulticoreFuture ...
[10:19:52.477] result() for MulticoreFuture ... done
[10:19:52.477] result() for MulticoreFuture ...
[10:19:52.477] result() for MulticoreFuture ... done
[10:19:52.477] - relayed: [n=2] TRUE, TRUE
[10:19:52.477] - queued futures: [n=2] TRUE, TRUE
[10:19:52.477] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.478]  length: 0 (resolved future 2)
[10:19:52.478] Relaying remaining futures
[10:19:52.478] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.478] - nx: 2
[10:19:52.478] - relay: TRUE
[10:19:52.478] - stdout: TRUE
[10:19:52.478] - signal: TRUE
[10:19:52.478] - resignal: FALSE
[10:19:52.478] - force: TRUE
[10:19:52.478] - relayed: [n=2] TRUE, TRUE
[10:19:52.478] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:52.479] - relayed: [n=2] TRUE, TRUE
[10:19:52.479] - queued futures: [n=2] TRUE, TRUE
[10:19:52.479] signalConditionsASAP(NULL, pos=0) ... done
[10:19:52.479] resolve() on list ... DONE
[10:19:52.479] result() for MulticoreFuture ...
[10:19:52.482] result() for MulticoreFuture ... done
[10:19:52.482] result() for MulticoreFuture ...
[10:19:52.482] result() for MulticoreFuture ... done
[10:19:52.482] result() for MulticoreFuture ...
[10:19:52.482] result() for MulticoreFuture ... done
[10:19:52.483] result() for MulticoreFuture ...
[10:19:52.483] result() for MulticoreFuture ... done
[10:19:52.483]  - Number of value chunks collected: 2
[10:19:52.483] Resolving 2 futures (chunks) ... DONE
[10:19:52.483] Reducing values from 2 chunks ...
[10:19:52.483]  - Number of values collected after concatenation: 10
[10:19:52.484]  - Number of values expected: 10
[10:19:52.484] Reducing values from 2 chunks ... DONE
[10:19:52.484] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:19:52.486] future_lapply() ...
[10:19:52.490] Number of chunks: 2
[10:19:52.490] getGlobalsAndPackagesXApply() ...
[10:19:52.490]  - future.globals: TRUE
[10:19:52.491] getGlobalsAndPackages() ...
[10:19:52.491] Searching for globals...
[10:19:52.495] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:19:52.495] Searching for globals ... DONE
[10:19:52.495] Resolving globals: FALSE
[10:19:52.496] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[10:19:52.496] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:52.497] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.497] - packages: [1] ‘future.apply’
[10:19:52.497] getGlobalsAndPackages() ... DONE
[10:19:52.497]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.497]  - needed namespaces: [n=1] ‘future.apply’
[10:19:52.497] Finding globals ... DONE
[10:19:52.497]  - use_args: TRUE
[10:19:52.497]  - Getting '...' globals ...
[10:19:52.498] resolve() on list ...
[10:19:52.498]  recursive: 0
[10:19:52.498]  length: 1
[10:19:52.498]  elements: ‘...’
[10:19:52.498]  length: 0 (resolved future 1)
[10:19:52.498] resolve() on list ... DONE
[10:19:52.498]    - '...' content: [n=0] 
[10:19:52.498] List of 1
[10:19:52.498]  $ ...: list()
[10:19:52.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.498]  - attr(*, "where")=List of 1
[10:19:52.498]   ..$ ...:<environment: 0x55c69fddd830> 
[10:19:52.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.498]  - attr(*, "resolved")= logi TRUE
[10:19:52.498]  - attr(*, "total_size")= num NA
[10:19:52.501]  - Getting '...' globals ... DONE
[10:19:52.501] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:52.501] List of 8
[10:19:52.501]  $ ...future.FUN:function (x, ...)  
[10:19:52.501]  $ x_FUN        :function (x)  
[10:19:52.501]  $ times        : int 4
[10:19:52.501]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.501]  $ stop_if_not  :function (...)  
[10:19:52.501]  $ dim          : int [1:2] 2 2
[10:19:52.501]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:52.501]  $ ...          : list()
[10:19:52.501]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.501]  - attr(*, "where")=List of 8
[10:19:52.501]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:52.501]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:52.501]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:52.501]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:52.501]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:52.501]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:52.501]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:52.501]   ..$ ...          :<environment: 0x55c69fddd830> 
[10:19:52.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.501]  - attr(*, "resolved")= logi FALSE
[10:19:52.501]  - attr(*, "total_size")= num 24886
[10:19:52.509] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:52.509] getGlobalsAndPackagesXApply() ... DONE
[10:19:52.509] Number of futures (= number of chunks): 2
[10:19:52.509] Launching 2 futures (chunks) ...
[10:19:52.510] Chunk #1 of 2 ...
[10:19:52.510]  - Finding globals in 'X' for chunk #1 ...
[10:19:52.510] getGlobalsAndPackages() ...
[10:19:52.510] Searching for globals...
[10:19:52.510] 
[10:19:52.510] Searching for globals ... DONE
[10:19:52.510] - globals: [0] <none>
[10:19:52.510] getGlobalsAndPackages() ... DONE
[10:19:52.511]    + additional globals found: [n=0] 
[10:19:52.511]    + additional namespaces needed: [n=0] 
[10:19:52.511]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:52.511]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.511]  - seeds: <none>
[10:19:52.511]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.511] getGlobalsAndPackages() ...
[10:19:52.511] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.511] Resolving globals: FALSE
[10:19:52.511] Tweak future expression to call with '...' arguments ...
[10:19:52.512] {
[10:19:52.512]     do.call(function(...) {
[10:19:52.512]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.512]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.512]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.512]             on.exit(options(oopts), add = TRUE)
[10:19:52.512]         }
[10:19:52.512]         {
[10:19:52.512]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.512]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.512]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.512]             })
[10:19:52.512]         }
[10:19:52.512]     }, args = future.call.arguments)
[10:19:52.512] }
[10:19:52.512] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.512] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.512] - packages: [1] ‘future.apply’
[10:19:52.513] getGlobalsAndPackages() ... DONE
[10:19:52.513] run() for ‘Future’ ...
[10:19:52.513] - state: ‘created’
[10:19:52.513] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.515] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.515]   - Field: ‘label’
[10:19:52.515]   - Field: ‘local’
[10:19:52.515]   - Field: ‘owner’
[10:19:52.515]   - Field: ‘envir’
[10:19:52.515]   - Field: ‘workers’
[10:19:52.516]   - Field: ‘packages’
[10:19:52.516]   - Field: ‘gc’
[10:19:52.516]   - Field: ‘job’
[10:19:52.516]   - Field: ‘conditions’
[10:19:52.516]   - Field: ‘expr’
[10:19:52.516]   - Field: ‘uuid’
[10:19:52.516]   - Field: ‘seed’
[10:19:52.516]   - Field: ‘version’
[10:19:52.516]   - Field: ‘result’
[10:19:52.516]   - Field: ‘asynchronous’
[10:19:52.516]   - Field: ‘calls’
[10:19:52.516]   - Field: ‘globals’
[10:19:52.517]   - Field: ‘stdout’
[10:19:52.517]   - Field: ‘earlySignal’
[10:19:52.517]   - Field: ‘lazy’
[10:19:52.517]   - Field: ‘state’
[10:19:52.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.517] - Launch lazy future ...
[10:19:52.517] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.517] Packages needed by future strategies (n = 0): <none>
[10:19:52.518] {
[10:19:52.518]     {
[10:19:52.518]         {
[10:19:52.518]             ...future.startTime <- base::Sys.time()
[10:19:52.518]             {
[10:19:52.518]                 {
[10:19:52.518]                   {
[10:19:52.518]                     {
[10:19:52.518]                       {
[10:19:52.518]                         base::local({
[10:19:52.518]                           has_future <- base::requireNamespace("future", 
[10:19:52.518]                             quietly = TRUE)
[10:19:52.518]                           if (has_future) {
[10:19:52.518]                             ns <- base::getNamespace("future")
[10:19:52.518]                             version <- ns[[".package"]][["version"]]
[10:19:52.518]                             if (is.null(version)) 
[10:19:52.518]                               version <- utils::packageVersion("future")
[10:19:52.518]                           }
[10:19:52.518]                           else {
[10:19:52.518]                             version <- NULL
[10:19:52.518]                           }
[10:19:52.518]                           if (!has_future || version < "1.8.0") {
[10:19:52.518]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.518]                               "", base::R.version$version.string), 
[10:19:52.518]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.518]                                 base::R.version$platform, 8 * 
[10:19:52.518]                                   base::.Machine$sizeof.pointer), 
[10:19:52.518]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.518]                                 "release", "version")], collapse = " "), 
[10:19:52.518]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.518]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.518]                               info)
[10:19:52.518]                             info <- base::paste(info, collapse = "; ")
[10:19:52.518]                             if (!has_future) {
[10:19:52.518]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.518]                                 info)
[10:19:52.518]                             }
[10:19:52.518]                             else {
[10:19:52.518]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.518]                                 info, version)
[10:19:52.518]                             }
[10:19:52.518]                             base::stop(msg)
[10:19:52.518]                           }
[10:19:52.518]                         })
[10:19:52.518]                       }
[10:19:52.518]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.518]                       base::options(mc.cores = 1L)
[10:19:52.518]                     }
[10:19:52.518]                     base::local({
[10:19:52.518]                       for (pkg in "future.apply") {
[10:19:52.518]                         base::loadNamespace(pkg)
[10:19:52.518]                         base::library(pkg, character.only = TRUE)
[10:19:52.518]                       }
[10:19:52.518]                     })
[10:19:52.518]                   }
[10:19:52.518]                   ...future.strategy.old <- future::plan("list")
[10:19:52.518]                   options(future.plan = NULL)
[10:19:52.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.518]                 }
[10:19:52.518]                 ...future.workdir <- getwd()
[10:19:52.518]             }
[10:19:52.518]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.518]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.518]         }
[10:19:52.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.518]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.518]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.518]             base::names(...future.oldOptions))
[10:19:52.518]     }
[10:19:52.518]     if (FALSE) {
[10:19:52.518]     }
[10:19:52.518]     else {
[10:19:52.518]         if (TRUE) {
[10:19:52.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.518]                 open = "w")
[10:19:52.518]         }
[10:19:52.518]         else {
[10:19:52.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.518]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.518]         }
[10:19:52.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.518]             base::sink(type = "output", split = FALSE)
[10:19:52.518]             base::close(...future.stdout)
[10:19:52.518]         }, add = TRUE)
[10:19:52.518]     }
[10:19:52.518]     ...future.frame <- base::sys.nframe()
[10:19:52.518]     ...future.conditions <- base::list()
[10:19:52.518]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.518]     if (FALSE) {
[10:19:52.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.518]     }
[10:19:52.518]     ...future.result <- base::tryCatch({
[10:19:52.518]         base::withCallingHandlers({
[10:19:52.518]             ...future.value <- base::withVisible(base::local({
[10:19:52.518]                 withCallingHandlers({
[10:19:52.518]                   {
[10:19:52.518]                     do.call(function(...) {
[10:19:52.518]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.518]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.518]                         ...future.globals.maxSize)) {
[10:19:52.518]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.518]                         on.exit(options(oopts), add = TRUE)
[10:19:52.518]                       }
[10:19:52.518]                       {
[10:19:52.518]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.518]                           FUN = function(jj) {
[10:19:52.518]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.518]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.518]                           })
[10:19:52.518]                       }
[10:19:52.518]                     }, args = future.call.arguments)
[10:19:52.518]                   }
[10:19:52.518]                 }, immediateCondition = function(cond) {
[10:19:52.518]                   save_rds <- function (object, pathname, ...) 
[10:19:52.518]                   {
[10:19:52.518]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.518]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.518]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.518]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.518]                         fi_tmp[["mtime"]])
[10:19:52.518]                     }
[10:19:52.518]                     tryCatch({
[10:19:52.518]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.518]                     }, error = function(ex) {
[10:19:52.518]                       msg <- conditionMessage(ex)
[10:19:52.518]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.518]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.518]                         fi_tmp[["mtime"]], msg)
[10:19:52.518]                       ex$message <- msg
[10:19:52.518]                       stop(ex)
[10:19:52.518]                     })
[10:19:52.518]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.518]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.518]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.518]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.518]                       fi <- file.info(pathname)
[10:19:52.518]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.518]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.518]                         fi[["size"]], fi[["mtime"]])
[10:19:52.518]                       stop(msg)
[10:19:52.518]                     }
[10:19:52.518]                     invisible(pathname)
[10:19:52.518]                   }
[10:19:52.518]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.518]                     rootPath = tempdir()) 
[10:19:52.518]                   {
[10:19:52.518]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.518]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.518]                       tmpdir = path, fileext = ".rds")
[10:19:52.518]                     save_rds(obj, file)
[10:19:52.518]                   }
[10:19:52.518]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.518]                   {
[10:19:52.518]                     inherits <- base::inherits
[10:19:52.518]                     invokeRestart <- base::invokeRestart
[10:19:52.518]                     is.null <- base::is.null
[10:19:52.518]                     muffled <- FALSE
[10:19:52.518]                     if (inherits(cond, "message")) {
[10:19:52.518]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.518]                       if (muffled) 
[10:19:52.518]                         invokeRestart("muffleMessage")
[10:19:52.518]                     }
[10:19:52.518]                     else if (inherits(cond, "warning")) {
[10:19:52.518]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.518]                       if (muffled) 
[10:19:52.518]                         invokeRestart("muffleWarning")
[10:19:52.518]                     }
[10:19:52.518]                     else if (inherits(cond, "condition")) {
[10:19:52.518]                       if (!is.null(pattern)) {
[10:19:52.518]                         computeRestarts <- base::computeRestarts
[10:19:52.518]                         grepl <- base::grepl
[10:19:52.518]                         restarts <- computeRestarts(cond)
[10:19:52.518]                         for (restart in restarts) {
[10:19:52.518]                           name <- restart$name
[10:19:52.518]                           if (is.null(name)) 
[10:19:52.518]                             next
[10:19:52.518]                           if (!grepl(pattern, name)) 
[10:19:52.518]                             next
[10:19:52.518]                           invokeRestart(restart)
[10:19:52.518]                           muffled <- TRUE
[10:19:52.518]                           break
[10:19:52.518]                         }
[10:19:52.518]                       }
[10:19:52.518]                     }
[10:19:52.518]                     invisible(muffled)
[10:19:52.518]                   }
[10:19:52.518]                   muffleCondition(cond)
[10:19:52.518]                 })
[10:19:52.518]             }))
[10:19:52.518]             future::FutureResult(value = ...future.value$value, 
[10:19:52.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.518]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.518]                     ...future.globalenv.names))
[10:19:52.518]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.518]         }, condition = base::local({
[10:19:52.518]             c <- base::c
[10:19:52.518]             inherits <- base::inherits
[10:19:52.518]             invokeRestart <- base::invokeRestart
[10:19:52.518]             length <- base::length
[10:19:52.518]             list <- base::list
[10:19:52.518]             seq.int <- base::seq.int
[10:19:52.518]             signalCondition <- base::signalCondition
[10:19:52.518]             sys.calls <- base::sys.calls
[10:19:52.518]             `[[` <- base::`[[`
[10:19:52.518]             `+` <- base::`+`
[10:19:52.518]             `<<-` <- base::`<<-`
[10:19:52.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.518]                   3L)]
[10:19:52.518]             }
[10:19:52.518]             function(cond) {
[10:19:52.518]                 is_error <- inherits(cond, "error")
[10:19:52.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.518]                   NULL)
[10:19:52.518]                 if (is_error) {
[10:19:52.518]                   sessionInformation <- function() {
[10:19:52.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.518]                       search = base::search(), system = base::Sys.info())
[10:19:52.518]                   }
[10:19:52.518]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.518]                     cond$call), session = sessionInformation(), 
[10:19:52.518]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.518]                   signalCondition(cond)
[10:19:52.518]                 }
[10:19:52.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.518]                 "immediateCondition"))) {
[10:19:52.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.518]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.518]                   if (TRUE && !signal) {
[10:19:52.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.518]                     {
[10:19:52.518]                       inherits <- base::inherits
[10:19:52.518]                       invokeRestart <- base::invokeRestart
[10:19:52.518]                       is.null <- base::is.null
[10:19:52.518]                       muffled <- FALSE
[10:19:52.518]                       if (inherits(cond, "message")) {
[10:19:52.518]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.518]                         if (muffled) 
[10:19:52.518]                           invokeRestart("muffleMessage")
[10:19:52.518]                       }
[10:19:52.518]                       else if (inherits(cond, "warning")) {
[10:19:52.518]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.518]                         if (muffled) 
[10:19:52.518]                           invokeRestart("muffleWarning")
[10:19:52.518]                       }
[10:19:52.518]                       else if (inherits(cond, "condition")) {
[10:19:52.518]                         if (!is.null(pattern)) {
[10:19:52.518]                           computeRestarts <- base::computeRestarts
[10:19:52.518]                           grepl <- base::grepl
[10:19:52.518]                           restarts <- computeRestarts(cond)
[10:19:52.518]                           for (restart in restarts) {
[10:19:52.518]                             name <- restart$name
[10:19:52.518]                             if (is.null(name)) 
[10:19:52.518]                               next
[10:19:52.518]                             if (!grepl(pattern, name)) 
[10:19:52.518]                               next
[10:19:52.518]                             invokeRestart(restart)
[10:19:52.518]                             muffled <- TRUE
[10:19:52.518]                             break
[10:19:52.518]                           }
[10:19:52.518]                         }
[10:19:52.518]                       }
[10:19:52.518]                       invisible(muffled)
[10:19:52.518]                     }
[10:19:52.518]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.518]                   }
[10:19:52.518]                 }
[10:19:52.518]                 else {
[10:19:52.518]                   if (TRUE) {
[10:19:52.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.518]                     {
[10:19:52.518]                       inherits <- base::inherits
[10:19:52.518]                       invokeRestart <- base::invokeRestart
[10:19:52.518]                       is.null <- base::is.null
[10:19:52.518]                       muffled <- FALSE
[10:19:52.518]                       if (inherits(cond, "message")) {
[10:19:52.518]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.518]                         if (muffled) 
[10:19:52.518]                           invokeRestart("muffleMessage")
[10:19:52.518]                       }
[10:19:52.518]                       else if (inherits(cond, "warning")) {
[10:19:52.518]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.518]                         if (muffled) 
[10:19:52.518]                           invokeRestart("muffleWarning")
[10:19:52.518]                       }
[10:19:52.518]                       else if (inherits(cond, "condition")) {
[10:19:52.518]                         if (!is.null(pattern)) {
[10:19:52.518]                           computeRestarts <- base::computeRestarts
[10:19:52.518]                           grepl <- base::grepl
[10:19:52.518]                           restarts <- computeRestarts(cond)
[10:19:52.518]                           for (restart in restarts) {
[10:19:52.518]                             name <- restart$name
[10:19:52.518]                             if (is.null(name)) 
[10:19:52.518]                               next
[10:19:52.518]                             if (!grepl(pattern, name)) 
[10:19:52.518]                               next
[10:19:52.518]                             invokeRestart(restart)
[10:19:52.518]                             muffled <- TRUE
[10:19:52.518]                             break
[10:19:52.518]                           }
[10:19:52.518]                         }
[10:19:52.518]                       }
[10:19:52.518]                       invisible(muffled)
[10:19:52.518]                     }
[10:19:52.518]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.518]                   }
[10:19:52.518]                 }
[10:19:52.518]             }
[10:19:52.518]         }))
[10:19:52.518]     }, error = function(ex) {
[10:19:52.518]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.518]                 ...future.rng), started = ...future.startTime, 
[10:19:52.518]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.518]             version = "1.8"), class = "FutureResult")
[10:19:52.518]     }, finally = {
[10:19:52.518]         if (!identical(...future.workdir, getwd())) 
[10:19:52.518]             setwd(...future.workdir)
[10:19:52.518]         {
[10:19:52.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.518]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.518]             }
[10:19:52.518]             base::options(...future.oldOptions)
[10:19:52.518]             if (.Platform$OS.type == "windows") {
[10:19:52.518]                 old_names <- names(...future.oldEnvVars)
[10:19:52.518]                 envs <- base::Sys.getenv()
[10:19:52.518]                 names <- names(envs)
[10:19:52.518]                 common <- intersect(names, old_names)
[10:19:52.518]                 added <- setdiff(names, old_names)
[10:19:52.518]                 removed <- setdiff(old_names, names)
[10:19:52.518]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.518]                   envs[common]]
[10:19:52.518]                 NAMES <- toupper(changed)
[10:19:52.518]                 args <- list()
[10:19:52.518]                 for (kk in seq_along(NAMES)) {
[10:19:52.518]                   name <- changed[[kk]]
[10:19:52.518]                   NAME <- NAMES[[kk]]
[10:19:52.518]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.518]                     next
[10:19:52.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.518]                 }
[10:19:52.518]                 NAMES <- toupper(added)
[10:19:52.518]                 for (kk in seq_along(NAMES)) {
[10:19:52.518]                   name <- added[[kk]]
[10:19:52.518]                   NAME <- NAMES[[kk]]
[10:19:52.518]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.518]                     next
[10:19:52.518]                   args[[name]] <- ""
[10:19:52.518]                 }
[10:19:52.518]                 NAMES <- toupper(removed)
[10:19:52.518]                 for (kk in seq_along(NAMES)) {
[10:19:52.518]                   name <- removed[[kk]]
[10:19:52.518]                   NAME <- NAMES[[kk]]
[10:19:52.518]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.518]                     next
[10:19:52.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.518]                 }
[10:19:52.518]                 if (length(args) > 0) 
[10:19:52.518]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.518]             }
[10:19:52.518]             else {
[10:19:52.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.518]             }
[10:19:52.518]             {
[10:19:52.518]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.518]                   0L) {
[10:19:52.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.518]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.518]                   base::options(opts)
[10:19:52.518]                 }
[10:19:52.518]                 {
[10:19:52.518]                   {
[10:19:52.518]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.518]                     NULL
[10:19:52.518]                   }
[10:19:52.518]                   options(future.plan = NULL)
[10:19:52.518]                   if (is.na(NA_character_)) 
[10:19:52.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.518]                     .init = FALSE)
[10:19:52.518]                 }
[10:19:52.518]             }
[10:19:52.518]         }
[10:19:52.518]     })
[10:19:52.518]     if (TRUE) {
[10:19:52.518]         base::sink(type = "output", split = FALSE)
[10:19:52.518]         if (TRUE) {
[10:19:52.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.518]         }
[10:19:52.518]         else {
[10:19:52.518]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.518]         }
[10:19:52.518]         base::close(...future.stdout)
[10:19:52.518]         ...future.stdout <- NULL
[10:19:52.518]     }
[10:19:52.518]     ...future.result$conditions <- ...future.conditions
[10:19:52.518]     ...future.result$finished <- base::Sys.time()
[10:19:52.518]     ...future.result
[10:19:52.518] }
[10:19:52.520] assign_globals() ...
[10:19:52.521] List of 11
[10:19:52.521]  $ ...future.FUN            :function (x, ...)  
[10:19:52.521]  $ x_FUN                    :function (x)  
[10:19:52.521]  $ times                    : int 4
[10:19:52.521]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.521]  $ stop_if_not              :function (...)  
[10:19:52.521]  $ dim                      : int [1:2] 2 2
[10:19:52.521]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:52.521]  $ future.call.arguments    : list()
[10:19:52.521]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.521]  $ ...future.elements_ii    :List of 5
[10:19:52.521]   ..$ : int 1
[10:19:52.521]   ..$ : int 2
[10:19:52.521]   ..$ : int 3
[10:19:52.521]   ..$ : int 4
[10:19:52.521]   ..$ : int 5
[10:19:52.521]  $ ...future.seeds_ii       : NULL
[10:19:52.521]  $ ...future.globals.maxSize: NULL
[10:19:52.521]  - attr(*, "where")=List of 11
[10:19:52.521]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.521]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.521]  - attr(*, "resolved")= logi FALSE
[10:19:52.521]  - attr(*, "total_size")= num 24886
[10:19:52.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.521]  - attr(*, "already-done")= logi TRUE
[10:19:52.531] - copied ‘...future.FUN’ to environment
[10:19:52.531] - reassign environment for ‘x_FUN’
[10:19:52.531] - copied ‘x_FUN’ to environment
[10:19:52.531] - copied ‘times’ to environment
[10:19:52.531] - copied ‘stopf’ to environment
[10:19:52.532] - copied ‘stop_if_not’ to environment
[10:19:52.532] - copied ‘dim’ to environment
[10:19:52.532] - copied ‘valid_types’ to environment
[10:19:52.532] - copied ‘future.call.arguments’ to environment
[10:19:52.532] - copied ‘...future.elements_ii’ to environment
[10:19:52.532] - copied ‘...future.seeds_ii’ to environment
[10:19:52.532] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.532] assign_globals() ... done
[10:19:52.532] requestCore(): workers = 2
[10:19:52.535] MulticoreFuture started
[10:19:52.535] - Launch lazy future ... done
[10:19:52.536] run() for ‘MulticoreFuture’ ... done
[10:19:52.536] Created future:
[10:19:52.536] plan(): Setting new future strategy stack:
[10:19:52.536] List of future strategies:
[10:19:52.536] 1. sequential:
[10:19:52.536]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.536]    - tweaked: FALSE
[10:19:52.536]    - call: NULL
[10:19:52.538] plan(): nbrOfWorkers() = 1
[10:19:52.540] plan(): Setting new future strategy stack:
[10:19:52.540] List of future strategies:
[10:19:52.540] 1. multicore:
[10:19:52.540]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.540]    - tweaked: FALSE
[10:19:52.540]    - call: plan(strategy)
[10:19:52.544] plan(): nbrOfWorkers() = 2
[10:19:52.536] MulticoreFuture:
[10:19:52.536] Label: ‘future_vapply-1’
[10:19:52.536] Expression:
[10:19:52.536] {
[10:19:52.536]     do.call(function(...) {
[10:19:52.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.536]             on.exit(options(oopts), add = TRUE)
[10:19:52.536]         }
[10:19:52.536]         {
[10:19:52.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.536]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.536]             })
[10:19:52.536]         }
[10:19:52.536]     }, args = future.call.arguments)
[10:19:52.536] }
[10:19:52.536] Lazy evaluation: FALSE
[10:19:52.536] Asynchronous evaluation: TRUE
[10:19:52.536] Local evaluation: TRUE
[10:19:52.536] Environment: R_GlobalEnv
[10:19:52.536] Capture standard output: TRUE
[10:19:52.536] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.536] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.536] Packages: 1 packages (‘future.apply’)
[10:19:52.536] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.536] Resolved: TRUE
[10:19:52.536] Value: <not collected>
[10:19:52.536] Conditions captured: <none>
[10:19:52.536] Early signaling: FALSE
[10:19:52.536] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.536] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.545] Chunk #1 of 2 ... DONE
[10:19:52.545] Chunk #2 of 2 ...
[10:19:52.545]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.546] getGlobalsAndPackages() ...
[10:19:52.546] Searching for globals...
[10:19:52.546] 
[10:19:52.546] Searching for globals ... DONE
[10:19:52.547] - globals: [0] <none>
[10:19:52.547] getGlobalsAndPackages() ... DONE
[10:19:52.547]    + additional globals found: [n=0] 
[10:19:52.547]    + additional namespaces needed: [n=0] 
[10:19:52.547]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.547]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.547]  - seeds: <none>
[10:19:52.547]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.548] getGlobalsAndPackages() ...
[10:19:52.548] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.548] Resolving globals: FALSE
[10:19:52.548] Tweak future expression to call with '...' arguments ...
[10:19:52.548] {
[10:19:52.548]     do.call(function(...) {
[10:19:52.548]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.548]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.548]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.548]             on.exit(options(oopts), add = TRUE)
[10:19:52.548]         }
[10:19:52.548]         {
[10:19:52.548]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.548]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.548]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.548]             })
[10:19:52.548]         }
[10:19:52.548]     }, args = future.call.arguments)
[10:19:52.548] }
[10:19:52.549] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.550] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.550] - packages: [1] ‘future.apply’
[10:19:52.550] getGlobalsAndPackages() ... DONE
[10:19:52.551] run() for ‘Future’ ...
[10:19:52.551] - state: ‘created’
[10:19:52.551] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.554] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.554]   - Field: ‘label’
[10:19:52.554]   - Field: ‘local’
[10:19:52.554]   - Field: ‘owner’
[10:19:52.555]   - Field: ‘envir’
[10:19:52.555]   - Field: ‘workers’
[10:19:52.555]   - Field: ‘packages’
[10:19:52.555]   - Field: ‘gc’
[10:19:52.555]   - Field: ‘job’
[10:19:52.555]   - Field: ‘conditions’
[10:19:52.555]   - Field: ‘expr’
[10:19:52.556]   - Field: ‘uuid’
[10:19:52.556]   - Field: ‘seed’
[10:19:52.556]   - Field: ‘version’
[10:19:52.556]   - Field: ‘result’
[10:19:52.556]   - Field: ‘asynchronous’
[10:19:52.556]   - Field: ‘calls’
[10:19:52.556]   - Field: ‘globals’
[10:19:52.557]   - Field: ‘stdout’
[10:19:52.557]   - Field: ‘earlySignal’
[10:19:52.557]   - Field: ‘lazy’
[10:19:52.557]   - Field: ‘state’
[10:19:52.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.557] - Launch lazy future ...
[10:19:52.558] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.558] Packages needed by future strategies (n = 0): <none>
[10:19:52.559] {
[10:19:52.559]     {
[10:19:52.559]         {
[10:19:52.559]             ...future.startTime <- base::Sys.time()
[10:19:52.559]             {
[10:19:52.559]                 {
[10:19:52.559]                   {
[10:19:52.559]                     {
[10:19:52.559]                       {
[10:19:52.559]                         base::local({
[10:19:52.559]                           has_future <- base::requireNamespace("future", 
[10:19:52.559]                             quietly = TRUE)
[10:19:52.559]                           if (has_future) {
[10:19:52.559]                             ns <- base::getNamespace("future")
[10:19:52.559]                             version <- ns[[".package"]][["version"]]
[10:19:52.559]                             if (is.null(version)) 
[10:19:52.559]                               version <- utils::packageVersion("future")
[10:19:52.559]                           }
[10:19:52.559]                           else {
[10:19:52.559]                             version <- NULL
[10:19:52.559]                           }
[10:19:52.559]                           if (!has_future || version < "1.8.0") {
[10:19:52.559]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.559]                               "", base::R.version$version.string), 
[10:19:52.559]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.559]                                 base::R.version$platform, 8 * 
[10:19:52.559]                                   base::.Machine$sizeof.pointer), 
[10:19:52.559]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.559]                                 "release", "version")], collapse = " "), 
[10:19:52.559]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.559]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.559]                               info)
[10:19:52.559]                             info <- base::paste(info, collapse = "; ")
[10:19:52.559]                             if (!has_future) {
[10:19:52.559]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.559]                                 info)
[10:19:52.559]                             }
[10:19:52.559]                             else {
[10:19:52.559]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.559]                                 info, version)
[10:19:52.559]                             }
[10:19:52.559]                             base::stop(msg)
[10:19:52.559]                           }
[10:19:52.559]                         })
[10:19:52.559]                       }
[10:19:52.559]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.559]                       base::options(mc.cores = 1L)
[10:19:52.559]                     }
[10:19:52.559]                     base::local({
[10:19:52.559]                       for (pkg in "future.apply") {
[10:19:52.559]                         base::loadNamespace(pkg)
[10:19:52.559]                         base::library(pkg, character.only = TRUE)
[10:19:52.559]                       }
[10:19:52.559]                     })
[10:19:52.559]                   }
[10:19:52.559]                   ...future.strategy.old <- future::plan("list")
[10:19:52.559]                   options(future.plan = NULL)
[10:19:52.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.559]                 }
[10:19:52.559]                 ...future.workdir <- getwd()
[10:19:52.559]             }
[10:19:52.559]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.559]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.559]         }
[10:19:52.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.559]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.559]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.559]             base::names(...future.oldOptions))
[10:19:52.559]     }
[10:19:52.559]     if (FALSE) {
[10:19:52.559]     }
[10:19:52.559]     else {
[10:19:52.559]         if (TRUE) {
[10:19:52.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.559]                 open = "w")
[10:19:52.559]         }
[10:19:52.559]         else {
[10:19:52.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.559]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.559]         }
[10:19:52.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.559]             base::sink(type = "output", split = FALSE)
[10:19:52.559]             base::close(...future.stdout)
[10:19:52.559]         }, add = TRUE)
[10:19:52.559]     }
[10:19:52.559]     ...future.frame <- base::sys.nframe()
[10:19:52.559]     ...future.conditions <- base::list()
[10:19:52.559]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.559]     if (FALSE) {
[10:19:52.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.559]     }
[10:19:52.559]     ...future.result <- base::tryCatch({
[10:19:52.559]         base::withCallingHandlers({
[10:19:52.559]             ...future.value <- base::withVisible(base::local({
[10:19:52.559]                 withCallingHandlers({
[10:19:52.559]                   {
[10:19:52.559]                     do.call(function(...) {
[10:19:52.559]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.559]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.559]                         ...future.globals.maxSize)) {
[10:19:52.559]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.559]                         on.exit(options(oopts), add = TRUE)
[10:19:52.559]                       }
[10:19:52.559]                       {
[10:19:52.559]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.559]                           FUN = function(jj) {
[10:19:52.559]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.559]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.559]                           })
[10:19:52.559]                       }
[10:19:52.559]                     }, args = future.call.arguments)
[10:19:52.559]                   }
[10:19:52.559]                 }, immediateCondition = function(cond) {
[10:19:52.559]                   save_rds <- function (object, pathname, ...) 
[10:19:52.559]                   {
[10:19:52.559]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.559]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.559]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.559]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.559]                         fi_tmp[["mtime"]])
[10:19:52.559]                     }
[10:19:52.559]                     tryCatch({
[10:19:52.559]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.559]                     }, error = function(ex) {
[10:19:52.559]                       msg <- conditionMessage(ex)
[10:19:52.559]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.559]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.559]                         fi_tmp[["mtime"]], msg)
[10:19:52.559]                       ex$message <- msg
[10:19:52.559]                       stop(ex)
[10:19:52.559]                     })
[10:19:52.559]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.559]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.559]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.559]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.559]                       fi <- file.info(pathname)
[10:19:52.559]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.559]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.559]                         fi[["size"]], fi[["mtime"]])
[10:19:52.559]                       stop(msg)
[10:19:52.559]                     }
[10:19:52.559]                     invisible(pathname)
[10:19:52.559]                   }
[10:19:52.559]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.559]                     rootPath = tempdir()) 
[10:19:52.559]                   {
[10:19:52.559]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.559]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.559]                       tmpdir = path, fileext = ".rds")
[10:19:52.559]                     save_rds(obj, file)
[10:19:52.559]                   }
[10:19:52.559]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.559]                   {
[10:19:52.559]                     inherits <- base::inherits
[10:19:52.559]                     invokeRestart <- base::invokeRestart
[10:19:52.559]                     is.null <- base::is.null
[10:19:52.559]                     muffled <- FALSE
[10:19:52.559]                     if (inherits(cond, "message")) {
[10:19:52.559]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.559]                       if (muffled) 
[10:19:52.559]                         invokeRestart("muffleMessage")
[10:19:52.559]                     }
[10:19:52.559]                     else if (inherits(cond, "warning")) {
[10:19:52.559]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.559]                       if (muffled) 
[10:19:52.559]                         invokeRestart("muffleWarning")
[10:19:52.559]                     }
[10:19:52.559]                     else if (inherits(cond, "condition")) {
[10:19:52.559]                       if (!is.null(pattern)) {
[10:19:52.559]                         computeRestarts <- base::computeRestarts
[10:19:52.559]                         grepl <- base::grepl
[10:19:52.559]                         restarts <- computeRestarts(cond)
[10:19:52.559]                         for (restart in restarts) {
[10:19:52.559]                           name <- restart$name
[10:19:52.559]                           if (is.null(name)) 
[10:19:52.559]                             next
[10:19:52.559]                           if (!grepl(pattern, name)) 
[10:19:52.559]                             next
[10:19:52.559]                           invokeRestart(restart)
[10:19:52.559]                           muffled <- TRUE
[10:19:52.559]                           break
[10:19:52.559]                         }
[10:19:52.559]                       }
[10:19:52.559]                     }
[10:19:52.559]                     invisible(muffled)
[10:19:52.559]                   }
[10:19:52.559]                   muffleCondition(cond)
[10:19:52.559]                 })
[10:19:52.559]             }))
[10:19:52.559]             future::FutureResult(value = ...future.value$value, 
[10:19:52.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.559]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.559]                     ...future.globalenv.names))
[10:19:52.559]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.559]         }, condition = base::local({
[10:19:52.559]             c <- base::c
[10:19:52.559]             inherits <- base::inherits
[10:19:52.559]             invokeRestart <- base::invokeRestart
[10:19:52.559]             length <- base::length
[10:19:52.559]             list <- base::list
[10:19:52.559]             seq.int <- base::seq.int
[10:19:52.559]             signalCondition <- base::signalCondition
[10:19:52.559]             sys.calls <- base::sys.calls
[10:19:52.559]             `[[` <- base::`[[`
[10:19:52.559]             `+` <- base::`+`
[10:19:52.559]             `<<-` <- base::`<<-`
[10:19:52.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.559]                   3L)]
[10:19:52.559]             }
[10:19:52.559]             function(cond) {
[10:19:52.559]                 is_error <- inherits(cond, "error")
[10:19:52.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.559]                   NULL)
[10:19:52.559]                 if (is_error) {
[10:19:52.559]                   sessionInformation <- function() {
[10:19:52.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.559]                       search = base::search(), system = base::Sys.info())
[10:19:52.559]                   }
[10:19:52.559]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.559]                     cond$call), session = sessionInformation(), 
[10:19:52.559]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.559]                   signalCondition(cond)
[10:19:52.559]                 }
[10:19:52.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.559]                 "immediateCondition"))) {
[10:19:52.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.559]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.559]                   if (TRUE && !signal) {
[10:19:52.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.559]                     {
[10:19:52.559]                       inherits <- base::inherits
[10:19:52.559]                       invokeRestart <- base::invokeRestart
[10:19:52.559]                       is.null <- base::is.null
[10:19:52.559]                       muffled <- FALSE
[10:19:52.559]                       if (inherits(cond, "message")) {
[10:19:52.559]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.559]                         if (muffled) 
[10:19:52.559]                           invokeRestart("muffleMessage")
[10:19:52.559]                       }
[10:19:52.559]                       else if (inherits(cond, "warning")) {
[10:19:52.559]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.559]                         if (muffled) 
[10:19:52.559]                           invokeRestart("muffleWarning")
[10:19:52.559]                       }
[10:19:52.559]                       else if (inherits(cond, "condition")) {
[10:19:52.559]                         if (!is.null(pattern)) {
[10:19:52.559]                           computeRestarts <- base::computeRestarts
[10:19:52.559]                           grepl <- base::grepl
[10:19:52.559]                           restarts <- computeRestarts(cond)
[10:19:52.559]                           for (restart in restarts) {
[10:19:52.559]                             name <- restart$name
[10:19:52.559]                             if (is.null(name)) 
[10:19:52.559]                               next
[10:19:52.559]                             if (!grepl(pattern, name)) 
[10:19:52.559]                               next
[10:19:52.559]                             invokeRestart(restart)
[10:19:52.559]                             muffled <- TRUE
[10:19:52.559]                             break
[10:19:52.559]                           }
[10:19:52.559]                         }
[10:19:52.559]                       }
[10:19:52.559]                       invisible(muffled)
[10:19:52.559]                     }
[10:19:52.559]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.559]                   }
[10:19:52.559]                 }
[10:19:52.559]                 else {
[10:19:52.559]                   if (TRUE) {
[10:19:52.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.559]                     {
[10:19:52.559]                       inherits <- base::inherits
[10:19:52.559]                       invokeRestart <- base::invokeRestart
[10:19:52.559]                       is.null <- base::is.null
[10:19:52.559]                       muffled <- FALSE
[10:19:52.559]                       if (inherits(cond, "message")) {
[10:19:52.559]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.559]                         if (muffled) 
[10:19:52.559]                           invokeRestart("muffleMessage")
[10:19:52.559]                       }
[10:19:52.559]                       else if (inherits(cond, "warning")) {
[10:19:52.559]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.559]                         if (muffled) 
[10:19:52.559]                           invokeRestart("muffleWarning")
[10:19:52.559]                       }
[10:19:52.559]                       else if (inherits(cond, "condition")) {
[10:19:52.559]                         if (!is.null(pattern)) {
[10:19:52.559]                           computeRestarts <- base::computeRestarts
[10:19:52.559]                           grepl <- base::grepl
[10:19:52.559]                           restarts <- computeRestarts(cond)
[10:19:52.559]                           for (restart in restarts) {
[10:19:52.559]                             name <- restart$name
[10:19:52.559]                             if (is.null(name)) 
[10:19:52.559]                               next
[10:19:52.559]                             if (!grepl(pattern, name)) 
[10:19:52.559]                               next
[10:19:52.559]                             invokeRestart(restart)
[10:19:52.559]                             muffled <- TRUE
[10:19:52.559]                             break
[10:19:52.559]                           }
[10:19:52.559]                         }
[10:19:52.559]                       }
[10:19:52.559]                       invisible(muffled)
[10:19:52.559]                     }
[10:19:52.559]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.559]                   }
[10:19:52.559]                 }
[10:19:52.559]             }
[10:19:52.559]         }))
[10:19:52.559]     }, error = function(ex) {
[10:19:52.559]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.559]                 ...future.rng), started = ...future.startTime, 
[10:19:52.559]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.559]             version = "1.8"), class = "FutureResult")
[10:19:52.559]     }, finally = {
[10:19:52.559]         if (!identical(...future.workdir, getwd())) 
[10:19:52.559]             setwd(...future.workdir)
[10:19:52.559]         {
[10:19:52.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.559]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.559]             }
[10:19:52.559]             base::options(...future.oldOptions)
[10:19:52.559]             if (.Platform$OS.type == "windows") {
[10:19:52.559]                 old_names <- names(...future.oldEnvVars)
[10:19:52.559]                 envs <- base::Sys.getenv()
[10:19:52.559]                 names <- names(envs)
[10:19:52.559]                 common <- intersect(names, old_names)
[10:19:52.559]                 added <- setdiff(names, old_names)
[10:19:52.559]                 removed <- setdiff(old_names, names)
[10:19:52.559]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.559]                   envs[common]]
[10:19:52.559]                 NAMES <- toupper(changed)
[10:19:52.559]                 args <- list()
[10:19:52.559]                 for (kk in seq_along(NAMES)) {
[10:19:52.559]                   name <- changed[[kk]]
[10:19:52.559]                   NAME <- NAMES[[kk]]
[10:19:52.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.559]                     next
[10:19:52.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.559]                 }
[10:19:52.559]                 NAMES <- toupper(added)
[10:19:52.559]                 for (kk in seq_along(NAMES)) {
[10:19:52.559]                   name <- added[[kk]]
[10:19:52.559]                   NAME <- NAMES[[kk]]
[10:19:52.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.559]                     next
[10:19:52.559]                   args[[name]] <- ""
[10:19:52.559]                 }
[10:19:52.559]                 NAMES <- toupper(removed)
[10:19:52.559]                 for (kk in seq_along(NAMES)) {
[10:19:52.559]                   name <- removed[[kk]]
[10:19:52.559]                   NAME <- NAMES[[kk]]
[10:19:52.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.559]                     next
[10:19:52.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.559]                 }
[10:19:52.559]                 if (length(args) > 0) 
[10:19:52.559]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.559]             }
[10:19:52.559]             else {
[10:19:52.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.559]             }
[10:19:52.559]             {
[10:19:52.559]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.559]                   0L) {
[10:19:52.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.559]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.559]                   base::options(opts)
[10:19:52.559]                 }
[10:19:52.559]                 {
[10:19:52.559]                   {
[10:19:52.559]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.559]                     NULL
[10:19:52.559]                   }
[10:19:52.559]                   options(future.plan = NULL)
[10:19:52.559]                   if (is.na(NA_character_)) 
[10:19:52.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.559]                     .init = FALSE)
[10:19:52.559]                 }
[10:19:52.559]             }
[10:19:52.559]         }
[10:19:52.559]     })
[10:19:52.559]     if (TRUE) {
[10:19:52.559]         base::sink(type = "output", split = FALSE)
[10:19:52.559]         if (TRUE) {
[10:19:52.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.559]         }
[10:19:52.559]         else {
[10:19:52.559]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.559]         }
[10:19:52.559]         base::close(...future.stdout)
[10:19:52.559]         ...future.stdout <- NULL
[10:19:52.559]     }
[10:19:52.559]     ...future.result$conditions <- ...future.conditions
[10:19:52.559]     ...future.result$finished <- base::Sys.time()
[10:19:52.559]     ...future.result
[10:19:52.559] }
[10:19:52.562] assign_globals() ...
[10:19:52.562] List of 11
[10:19:52.562]  $ ...future.FUN            :function (x, ...)  
[10:19:52.562]  $ x_FUN                    :function (x)  
[10:19:52.562]  $ times                    : int 4
[10:19:52.562]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.562]  $ stop_if_not              :function (...)  
[10:19:52.562]  $ dim                      : int [1:2] 2 2
[10:19:52.562]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:52.562]  $ future.call.arguments    : list()
[10:19:52.562]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.562]  $ ...future.elements_ii    :List of 5
[10:19:52.562]   ..$ : int 6
[10:19:52.562]   ..$ : int 7
[10:19:52.562]   ..$ : int 8
[10:19:52.562]   ..$ : int 9
[10:19:52.562]   ..$ : int 10
[10:19:52.562]  $ ...future.seeds_ii       : NULL
[10:19:52.562]  $ ...future.globals.maxSize: NULL
[10:19:52.562]  - attr(*, "where")=List of 11
[10:19:52.562]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.562]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.562]  - attr(*, "resolved")= logi FALSE
[10:19:52.562]  - attr(*, "total_size")= num 24886
[10:19:52.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.562]  - attr(*, "already-done")= logi TRUE
[10:19:52.580] - copied ‘...future.FUN’ to environment
[10:19:52.580] - reassign environment for ‘x_FUN’
[10:19:52.580] - copied ‘x_FUN’ to environment
[10:19:52.580] - copied ‘times’ to environment
[10:19:52.580] - copied ‘stopf’ to environment
[10:19:52.580] - copied ‘stop_if_not’ to environment
[10:19:52.580] - copied ‘dim’ to environment
[10:19:52.580] - copied ‘valid_types’ to environment
[10:19:52.580] - copied ‘future.call.arguments’ to environment
[10:19:52.581] - copied ‘...future.elements_ii’ to environment
[10:19:52.581] - copied ‘...future.seeds_ii’ to environment
[10:19:52.581] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.581] assign_globals() ... done
[10:19:52.581] requestCore(): workers = 2
[10:19:52.583] MulticoreFuture started
[10:19:52.584] - Launch lazy future ... done
[10:19:52.584] run() for ‘MulticoreFuture’ ... done
[10:19:52.584] Created future:
[10:19:52.585] plan(): Setting new future strategy stack:
[10:19:52.585] List of future strategies:
[10:19:52.585] 1. sequential:
[10:19:52.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.585]    - tweaked: FALSE
[10:19:52.585]    - call: NULL
[10:19:52.586] plan(): nbrOfWorkers() = 1
[10:19:52.589] plan(): Setting new future strategy stack:
[10:19:52.589] List of future strategies:
[10:19:52.589] 1. multicore:
[10:19:52.589]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.589]    - tweaked: FALSE
[10:19:52.589]    - call: plan(strategy)
[10:19:52.592] plan(): nbrOfWorkers() = 2
[10:19:52.585] MulticoreFuture:
[10:19:52.585] Label: ‘future_vapply-2’
[10:19:52.585] Expression:
[10:19:52.585] {
[10:19:52.585]     do.call(function(...) {
[10:19:52.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.585]             on.exit(options(oopts), add = TRUE)
[10:19:52.585]         }
[10:19:52.585]         {
[10:19:52.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.585]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.585]             })
[10:19:52.585]         }
[10:19:52.585]     }, args = future.call.arguments)
[10:19:52.585] }
[10:19:52.585] Lazy evaluation: FALSE
[10:19:52.585] Asynchronous evaluation: TRUE
[10:19:52.585] Local evaluation: TRUE
[10:19:52.585] Environment: R_GlobalEnv
[10:19:52.585] Capture standard output: TRUE
[10:19:52.585] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.585] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.585] Packages: 1 packages (‘future.apply’)
[10:19:52.585] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.585] Resolved: TRUE
[10:19:52.585] Value: <not collected>
[10:19:52.585] Conditions captured: <none>
[10:19:52.585] Early signaling: FALSE
[10:19:52.585] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.585] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.593] Chunk #2 of 2 ... DONE
[10:19:52.594] Launching 2 futures (chunks) ... DONE
[10:19:52.594] Resolving 2 futures (chunks) ...
[10:19:52.594] resolve() on list ...
[10:19:52.594]  recursive: 0
[10:19:52.594]  length: 2
[10:19:52.594] 
[10:19:52.595] Future #1
[10:19:52.595] result() for MulticoreFuture ...
[10:19:52.596] result() for MulticoreFuture ...
[10:19:52.596] result() for MulticoreFuture ... done
[10:19:52.596] result() for MulticoreFuture ... done
[10:19:52.596] result() for MulticoreFuture ...
[10:19:52.596] result() for MulticoreFuture ... done
[10:19:52.596] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.597] - nx: 2
[10:19:52.597] - relay: TRUE
[10:19:52.597] - stdout: TRUE
[10:19:52.597] - signal: TRUE
[10:19:52.597] - resignal: FALSE
[10:19:52.597] - force: TRUE
[10:19:52.597] - relayed: [n=2] FALSE, FALSE
[10:19:52.598] - queued futures: [n=2] FALSE, FALSE
[10:19:52.598]  - until=1
[10:19:52.598]  - relaying element #1
[10:19:52.598] result() for MulticoreFuture ...
[10:19:52.598] result() for MulticoreFuture ... done
[10:19:52.598] result() for MulticoreFuture ...
[10:19:52.599] result() for MulticoreFuture ... done
[10:19:52.599] result() for MulticoreFuture ...
[10:19:52.599] result() for MulticoreFuture ... done
[10:19:52.599] result() for MulticoreFuture ...
[10:19:52.599] result() for MulticoreFuture ... done
[10:19:52.599] - relayed: [n=2] TRUE, FALSE
[10:19:52.599] - queued futures: [n=2] TRUE, FALSE
[10:19:52.600] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.600]  length: 1 (resolved future 1)
[10:19:52.600] Future #2
[10:19:52.600] result() for MulticoreFuture ...
[10:19:52.601] result() for MulticoreFuture ...
[10:19:52.601] result() for MulticoreFuture ... done
[10:19:52.601] result() for MulticoreFuture ... done
[10:19:52.602] result() for MulticoreFuture ...
[10:19:52.602] result() for MulticoreFuture ... done
[10:19:52.602] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.602] - nx: 2
[10:19:52.602] - relay: TRUE
[10:19:52.602] - stdout: TRUE
[10:19:52.602] - signal: TRUE
[10:19:52.603] - resignal: FALSE
[10:19:52.603] - force: TRUE
[10:19:52.603] - relayed: [n=2] TRUE, FALSE
[10:19:52.603] - queued futures: [n=2] TRUE, FALSE
[10:19:52.603]  - until=2
[10:19:52.603]  - relaying element #2
[10:19:52.603] result() for MulticoreFuture ...
[10:19:52.603] result() for MulticoreFuture ... done
[10:19:52.604] result() for MulticoreFuture ...
[10:19:52.604] result() for MulticoreFuture ... done
[10:19:52.604] result() for MulticoreFuture ...
[10:19:52.604] result() for MulticoreFuture ... done
[10:19:52.604] result() for MulticoreFuture ...
[10:19:52.604] result() for MulticoreFuture ... done
[10:19:52.604] - relayed: [n=2] TRUE, TRUE
[10:19:52.604] - queued futures: [n=2] TRUE, TRUE
[10:19:52.605] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.605]  length: 0 (resolved future 2)
[10:19:52.605] Relaying remaining futures
[10:19:52.605] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.605] - nx: 2
[10:19:52.605] - relay: TRUE
[10:19:52.605] - stdout: TRUE
[10:19:52.605] - signal: TRUE
[10:19:52.605] - resignal: FALSE
[10:19:52.606] - force: TRUE
[10:19:52.606] - relayed: [n=2] TRUE, TRUE
[10:19:52.606] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:52.606] - relayed: [n=2] TRUE, TRUE
[10:19:52.606] - queued futures: [n=2] TRUE, TRUE
[10:19:52.606] signalConditionsASAP(NULL, pos=0) ... done
[10:19:52.606] resolve() on list ... DONE
[10:19:52.606] result() for MulticoreFuture ...
[10:19:52.606] result() for MulticoreFuture ... done
[10:19:52.607] result() for MulticoreFuture ...
[10:19:52.607] result() for MulticoreFuture ... done
[10:19:52.607] result() for MulticoreFuture ...
[10:19:52.607] result() for MulticoreFuture ... done
[10:19:52.607] result() for MulticoreFuture ...
[10:19:52.607] result() for MulticoreFuture ... done
[10:19:52.607]  - Number of value chunks collected: 2
[10:19:52.607] Resolving 2 futures (chunks) ... DONE
[10:19:52.607] Reducing values from 2 chunks ...
[10:19:52.608]  - Number of values collected after concatenation: 10
[10:19:52.608]  - Number of values expected: 10
[10:19:52.608] Reducing values from 2 chunks ... DONE
[10:19:52.608] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:19:52.609] future_lapply() ...
[10:19:52.617] Number of chunks: 2
[10:19:52.617] getGlobalsAndPackagesXApply() ...
[10:19:52.617]  - future.globals: TRUE
[10:19:52.617] getGlobalsAndPackages() ...
[10:19:52.618] Searching for globals...
[10:19:52.622] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:19:52.622] Searching for globals ... DONE
[10:19:52.622] Resolving globals: FALSE
[10:19:52.623] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[10:19:52.624] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:52.624] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.624] - packages: [1] ‘future.apply’
[10:19:52.624] getGlobalsAndPackages() ... DONE
[10:19:52.624]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.624]  - needed namespaces: [n=1] ‘future.apply’
[10:19:52.624] Finding globals ... DONE
[10:19:52.624]  - use_args: TRUE
[10:19:52.624]  - Getting '...' globals ...
[10:19:52.625] resolve() on list ...
[10:19:52.625]  recursive: 0
[10:19:52.625]  length: 1
[10:19:52.625]  elements: ‘...’
[10:19:52.625]  length: 0 (resolved future 1)
[10:19:52.625] resolve() on list ... DONE
[10:19:52.625]    - '...' content: [n=0] 
[10:19:52.625] List of 1
[10:19:52.625]  $ ...: list()
[10:19:52.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.625]  - attr(*, "where")=List of 1
[10:19:52.625]   ..$ ...:<environment: 0x55c69fdd6420> 
[10:19:52.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.625]  - attr(*, "resolved")= logi TRUE
[10:19:52.625]  - attr(*, "total_size")= num NA
[10:19:52.628]  - Getting '...' globals ... DONE
[10:19:52.628] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:52.628] List of 8
[10:19:52.628]  $ ...future.FUN:function (x, ...)  
[10:19:52.628]  $ x_FUN        :function (x)  
[10:19:52.628]  $ times        : int 4
[10:19:52.628]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.628]  $ stop_if_not  :function (...)  
[10:19:52.628]  $ dim          : int [1:2] 2 2
[10:19:52.628]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:52.628]  $ ...          : list()
[10:19:52.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.628]  - attr(*, "where")=List of 8
[10:19:52.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:52.628]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:52.628]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:52.628]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:52.628]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:52.628]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:52.628]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:52.628]   ..$ ...          :<environment: 0x55c69fdd6420> 
[10:19:52.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.628]  - attr(*, "resolved")= logi FALSE
[10:19:52.628]  - attr(*, "total_size")= num 24958
[10:19:52.636] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:52.636] getGlobalsAndPackagesXApply() ... DONE
[10:19:52.636] Number of futures (= number of chunks): 2
[10:19:52.637] Launching 2 futures (chunks) ...
[10:19:52.637] Chunk #1 of 2 ...
[10:19:52.637]  - Finding globals in 'X' for chunk #1 ...
[10:19:52.637] getGlobalsAndPackages() ...
[10:19:52.637] Searching for globals...
[10:19:52.637] 
[10:19:52.638] Searching for globals ... DONE
[10:19:52.638] - globals: [0] <none>
[10:19:52.638] getGlobalsAndPackages() ... DONE
[10:19:52.638]    + additional globals found: [n=0] 
[10:19:52.638]    + additional namespaces needed: [n=0] 
[10:19:52.638]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:52.638]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.638]  - seeds: <none>
[10:19:52.638]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.639] getGlobalsAndPackages() ...
[10:19:52.639] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.639] Resolving globals: FALSE
[10:19:52.639] Tweak future expression to call with '...' arguments ...
[10:19:52.639] {
[10:19:52.639]     do.call(function(...) {
[10:19:52.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.639]             on.exit(options(oopts), add = TRUE)
[10:19:52.639]         }
[10:19:52.639]         {
[10:19:52.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.639]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.639]             })
[10:19:52.639]         }
[10:19:52.639]     }, args = future.call.arguments)
[10:19:52.639] }
[10:19:52.639] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.640] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.640] - packages: [1] ‘future.apply’
[10:19:52.640] getGlobalsAndPackages() ... DONE
[10:19:52.641] run() for ‘Future’ ...
[10:19:52.641] - state: ‘created’
[10:19:52.641] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.643] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.643]   - Field: ‘label’
[10:19:52.643]   - Field: ‘local’
[10:19:52.643]   - Field: ‘owner’
[10:19:52.643]   - Field: ‘envir’
[10:19:52.643]   - Field: ‘workers’
[10:19:52.643]   - Field: ‘packages’
[10:19:52.643]   - Field: ‘gc’
[10:19:52.644]   - Field: ‘job’
[10:19:52.644]   - Field: ‘conditions’
[10:19:52.644]   - Field: ‘expr’
[10:19:52.644]   - Field: ‘uuid’
[10:19:52.644]   - Field: ‘seed’
[10:19:52.644]   - Field: ‘version’
[10:19:52.644]   - Field: ‘result’
[10:19:52.644]   - Field: ‘asynchronous’
[10:19:52.644]   - Field: ‘calls’
[10:19:52.644]   - Field: ‘globals’
[10:19:52.644]   - Field: ‘stdout’
[10:19:52.644]   - Field: ‘earlySignal’
[10:19:52.645]   - Field: ‘lazy’
[10:19:52.645]   - Field: ‘state’
[10:19:52.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.645] - Launch lazy future ...
[10:19:52.645] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.645] Packages needed by future strategies (n = 0): <none>
[10:19:52.646] {
[10:19:52.646]     {
[10:19:52.646]         {
[10:19:52.646]             ...future.startTime <- base::Sys.time()
[10:19:52.646]             {
[10:19:52.646]                 {
[10:19:52.646]                   {
[10:19:52.646]                     {
[10:19:52.646]                       {
[10:19:52.646]                         base::local({
[10:19:52.646]                           has_future <- base::requireNamespace("future", 
[10:19:52.646]                             quietly = TRUE)
[10:19:52.646]                           if (has_future) {
[10:19:52.646]                             ns <- base::getNamespace("future")
[10:19:52.646]                             version <- ns[[".package"]][["version"]]
[10:19:52.646]                             if (is.null(version)) 
[10:19:52.646]                               version <- utils::packageVersion("future")
[10:19:52.646]                           }
[10:19:52.646]                           else {
[10:19:52.646]                             version <- NULL
[10:19:52.646]                           }
[10:19:52.646]                           if (!has_future || version < "1.8.0") {
[10:19:52.646]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.646]                               "", base::R.version$version.string), 
[10:19:52.646]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.646]                                 base::R.version$platform, 8 * 
[10:19:52.646]                                   base::.Machine$sizeof.pointer), 
[10:19:52.646]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.646]                                 "release", "version")], collapse = " "), 
[10:19:52.646]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.646]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.646]                               info)
[10:19:52.646]                             info <- base::paste(info, collapse = "; ")
[10:19:52.646]                             if (!has_future) {
[10:19:52.646]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.646]                                 info)
[10:19:52.646]                             }
[10:19:52.646]                             else {
[10:19:52.646]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.646]                                 info, version)
[10:19:52.646]                             }
[10:19:52.646]                             base::stop(msg)
[10:19:52.646]                           }
[10:19:52.646]                         })
[10:19:52.646]                       }
[10:19:52.646]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.646]                       base::options(mc.cores = 1L)
[10:19:52.646]                     }
[10:19:52.646]                     base::local({
[10:19:52.646]                       for (pkg in "future.apply") {
[10:19:52.646]                         base::loadNamespace(pkg)
[10:19:52.646]                         base::library(pkg, character.only = TRUE)
[10:19:52.646]                       }
[10:19:52.646]                     })
[10:19:52.646]                   }
[10:19:52.646]                   ...future.strategy.old <- future::plan("list")
[10:19:52.646]                   options(future.plan = NULL)
[10:19:52.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.646]                 }
[10:19:52.646]                 ...future.workdir <- getwd()
[10:19:52.646]             }
[10:19:52.646]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.646]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.646]         }
[10:19:52.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.646]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.646]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.646]             base::names(...future.oldOptions))
[10:19:52.646]     }
[10:19:52.646]     if (FALSE) {
[10:19:52.646]     }
[10:19:52.646]     else {
[10:19:52.646]         if (TRUE) {
[10:19:52.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.646]                 open = "w")
[10:19:52.646]         }
[10:19:52.646]         else {
[10:19:52.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.646]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.646]         }
[10:19:52.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.646]             base::sink(type = "output", split = FALSE)
[10:19:52.646]             base::close(...future.stdout)
[10:19:52.646]         }, add = TRUE)
[10:19:52.646]     }
[10:19:52.646]     ...future.frame <- base::sys.nframe()
[10:19:52.646]     ...future.conditions <- base::list()
[10:19:52.646]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.646]     if (FALSE) {
[10:19:52.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.646]     }
[10:19:52.646]     ...future.result <- base::tryCatch({
[10:19:52.646]         base::withCallingHandlers({
[10:19:52.646]             ...future.value <- base::withVisible(base::local({
[10:19:52.646]                 withCallingHandlers({
[10:19:52.646]                   {
[10:19:52.646]                     do.call(function(...) {
[10:19:52.646]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.646]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.646]                         ...future.globals.maxSize)) {
[10:19:52.646]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.646]                         on.exit(options(oopts), add = TRUE)
[10:19:52.646]                       }
[10:19:52.646]                       {
[10:19:52.646]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.646]                           FUN = function(jj) {
[10:19:52.646]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.646]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.646]                           })
[10:19:52.646]                       }
[10:19:52.646]                     }, args = future.call.arguments)
[10:19:52.646]                   }
[10:19:52.646]                 }, immediateCondition = function(cond) {
[10:19:52.646]                   save_rds <- function (object, pathname, ...) 
[10:19:52.646]                   {
[10:19:52.646]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.646]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.646]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.646]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.646]                         fi_tmp[["mtime"]])
[10:19:52.646]                     }
[10:19:52.646]                     tryCatch({
[10:19:52.646]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.646]                     }, error = function(ex) {
[10:19:52.646]                       msg <- conditionMessage(ex)
[10:19:52.646]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.646]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.646]                         fi_tmp[["mtime"]], msg)
[10:19:52.646]                       ex$message <- msg
[10:19:52.646]                       stop(ex)
[10:19:52.646]                     })
[10:19:52.646]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.646]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.646]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.646]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.646]                       fi <- file.info(pathname)
[10:19:52.646]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.646]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.646]                         fi[["size"]], fi[["mtime"]])
[10:19:52.646]                       stop(msg)
[10:19:52.646]                     }
[10:19:52.646]                     invisible(pathname)
[10:19:52.646]                   }
[10:19:52.646]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.646]                     rootPath = tempdir()) 
[10:19:52.646]                   {
[10:19:52.646]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.646]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.646]                       tmpdir = path, fileext = ".rds")
[10:19:52.646]                     save_rds(obj, file)
[10:19:52.646]                   }
[10:19:52.646]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.646]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.646]                   {
[10:19:52.646]                     inherits <- base::inherits
[10:19:52.646]                     invokeRestart <- base::invokeRestart
[10:19:52.646]                     is.null <- base::is.null
[10:19:52.646]                     muffled <- FALSE
[10:19:52.646]                     if (inherits(cond, "message")) {
[10:19:52.646]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.646]                       if (muffled) 
[10:19:52.646]                         invokeRestart("muffleMessage")
[10:19:52.646]                     }
[10:19:52.646]                     else if (inherits(cond, "warning")) {
[10:19:52.646]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.646]                       if (muffled) 
[10:19:52.646]                         invokeRestart("muffleWarning")
[10:19:52.646]                     }
[10:19:52.646]                     else if (inherits(cond, "condition")) {
[10:19:52.646]                       if (!is.null(pattern)) {
[10:19:52.646]                         computeRestarts <- base::computeRestarts
[10:19:52.646]                         grepl <- base::grepl
[10:19:52.646]                         restarts <- computeRestarts(cond)
[10:19:52.646]                         for (restart in restarts) {
[10:19:52.646]                           name <- restart$name
[10:19:52.646]                           if (is.null(name)) 
[10:19:52.646]                             next
[10:19:52.646]                           if (!grepl(pattern, name)) 
[10:19:52.646]                             next
[10:19:52.646]                           invokeRestart(restart)
[10:19:52.646]                           muffled <- TRUE
[10:19:52.646]                           break
[10:19:52.646]                         }
[10:19:52.646]                       }
[10:19:52.646]                     }
[10:19:52.646]                     invisible(muffled)
[10:19:52.646]                   }
[10:19:52.646]                   muffleCondition(cond)
[10:19:52.646]                 })
[10:19:52.646]             }))
[10:19:52.646]             future::FutureResult(value = ...future.value$value, 
[10:19:52.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.646]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.646]                     ...future.globalenv.names))
[10:19:52.646]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.646]         }, condition = base::local({
[10:19:52.646]             c <- base::c
[10:19:52.646]             inherits <- base::inherits
[10:19:52.646]             invokeRestart <- base::invokeRestart
[10:19:52.646]             length <- base::length
[10:19:52.646]             list <- base::list
[10:19:52.646]             seq.int <- base::seq.int
[10:19:52.646]             signalCondition <- base::signalCondition
[10:19:52.646]             sys.calls <- base::sys.calls
[10:19:52.646]             `[[` <- base::`[[`
[10:19:52.646]             `+` <- base::`+`
[10:19:52.646]             `<<-` <- base::`<<-`
[10:19:52.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.646]                   3L)]
[10:19:52.646]             }
[10:19:52.646]             function(cond) {
[10:19:52.646]                 is_error <- inherits(cond, "error")
[10:19:52.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.646]                   NULL)
[10:19:52.646]                 if (is_error) {
[10:19:52.646]                   sessionInformation <- function() {
[10:19:52.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.646]                       search = base::search(), system = base::Sys.info())
[10:19:52.646]                   }
[10:19:52.646]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.646]                     cond$call), session = sessionInformation(), 
[10:19:52.646]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.646]                   signalCondition(cond)
[10:19:52.646]                 }
[10:19:52.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.646]                 "immediateCondition"))) {
[10:19:52.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.646]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.646]                   if (TRUE && !signal) {
[10:19:52.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.646]                     {
[10:19:52.646]                       inherits <- base::inherits
[10:19:52.646]                       invokeRestart <- base::invokeRestart
[10:19:52.646]                       is.null <- base::is.null
[10:19:52.646]                       muffled <- FALSE
[10:19:52.646]                       if (inherits(cond, "message")) {
[10:19:52.646]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.646]                         if (muffled) 
[10:19:52.646]                           invokeRestart("muffleMessage")
[10:19:52.646]                       }
[10:19:52.646]                       else if (inherits(cond, "warning")) {
[10:19:52.646]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.646]                         if (muffled) 
[10:19:52.646]                           invokeRestart("muffleWarning")
[10:19:52.646]                       }
[10:19:52.646]                       else if (inherits(cond, "condition")) {
[10:19:52.646]                         if (!is.null(pattern)) {
[10:19:52.646]                           computeRestarts <- base::computeRestarts
[10:19:52.646]                           grepl <- base::grepl
[10:19:52.646]                           restarts <- computeRestarts(cond)
[10:19:52.646]                           for (restart in restarts) {
[10:19:52.646]                             name <- restart$name
[10:19:52.646]                             if (is.null(name)) 
[10:19:52.646]                               next
[10:19:52.646]                             if (!grepl(pattern, name)) 
[10:19:52.646]                               next
[10:19:52.646]                             invokeRestart(restart)
[10:19:52.646]                             muffled <- TRUE
[10:19:52.646]                             break
[10:19:52.646]                           }
[10:19:52.646]                         }
[10:19:52.646]                       }
[10:19:52.646]                       invisible(muffled)
[10:19:52.646]                     }
[10:19:52.646]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.646]                   }
[10:19:52.646]                 }
[10:19:52.646]                 else {
[10:19:52.646]                   if (TRUE) {
[10:19:52.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.646]                     {
[10:19:52.646]                       inherits <- base::inherits
[10:19:52.646]                       invokeRestart <- base::invokeRestart
[10:19:52.646]                       is.null <- base::is.null
[10:19:52.646]                       muffled <- FALSE
[10:19:52.646]                       if (inherits(cond, "message")) {
[10:19:52.646]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.646]                         if (muffled) 
[10:19:52.646]                           invokeRestart("muffleMessage")
[10:19:52.646]                       }
[10:19:52.646]                       else if (inherits(cond, "warning")) {
[10:19:52.646]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.646]                         if (muffled) 
[10:19:52.646]                           invokeRestart("muffleWarning")
[10:19:52.646]                       }
[10:19:52.646]                       else if (inherits(cond, "condition")) {
[10:19:52.646]                         if (!is.null(pattern)) {
[10:19:52.646]                           computeRestarts <- base::computeRestarts
[10:19:52.646]                           grepl <- base::grepl
[10:19:52.646]                           restarts <- computeRestarts(cond)
[10:19:52.646]                           for (restart in restarts) {
[10:19:52.646]                             name <- restart$name
[10:19:52.646]                             if (is.null(name)) 
[10:19:52.646]                               next
[10:19:52.646]                             if (!grepl(pattern, name)) 
[10:19:52.646]                               next
[10:19:52.646]                             invokeRestart(restart)
[10:19:52.646]                             muffled <- TRUE
[10:19:52.646]                             break
[10:19:52.646]                           }
[10:19:52.646]                         }
[10:19:52.646]                       }
[10:19:52.646]                       invisible(muffled)
[10:19:52.646]                     }
[10:19:52.646]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.646]                   }
[10:19:52.646]                 }
[10:19:52.646]             }
[10:19:52.646]         }))
[10:19:52.646]     }, error = function(ex) {
[10:19:52.646]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.646]                 ...future.rng), started = ...future.startTime, 
[10:19:52.646]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.646]             version = "1.8"), class = "FutureResult")
[10:19:52.646]     }, finally = {
[10:19:52.646]         if (!identical(...future.workdir, getwd())) 
[10:19:52.646]             setwd(...future.workdir)
[10:19:52.646]         {
[10:19:52.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.646]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.646]             }
[10:19:52.646]             base::options(...future.oldOptions)
[10:19:52.646]             if (.Platform$OS.type == "windows") {
[10:19:52.646]                 old_names <- names(...future.oldEnvVars)
[10:19:52.646]                 envs <- base::Sys.getenv()
[10:19:52.646]                 names <- names(envs)
[10:19:52.646]                 common <- intersect(names, old_names)
[10:19:52.646]                 added <- setdiff(names, old_names)
[10:19:52.646]                 removed <- setdiff(old_names, names)
[10:19:52.646]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.646]                   envs[common]]
[10:19:52.646]                 NAMES <- toupper(changed)
[10:19:52.646]                 args <- list()
[10:19:52.646]                 for (kk in seq_along(NAMES)) {
[10:19:52.646]                   name <- changed[[kk]]
[10:19:52.646]                   NAME <- NAMES[[kk]]
[10:19:52.646]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.646]                     next
[10:19:52.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.646]                 }
[10:19:52.646]                 NAMES <- toupper(added)
[10:19:52.646]                 for (kk in seq_along(NAMES)) {
[10:19:52.646]                   name <- added[[kk]]
[10:19:52.646]                   NAME <- NAMES[[kk]]
[10:19:52.646]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.646]                     next
[10:19:52.646]                   args[[name]] <- ""
[10:19:52.646]                 }
[10:19:52.646]                 NAMES <- toupper(removed)
[10:19:52.646]                 for (kk in seq_along(NAMES)) {
[10:19:52.646]                   name <- removed[[kk]]
[10:19:52.646]                   NAME <- NAMES[[kk]]
[10:19:52.646]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.646]                     next
[10:19:52.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.646]                 }
[10:19:52.646]                 if (length(args) > 0) 
[10:19:52.646]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.646]             }
[10:19:52.646]             else {
[10:19:52.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.646]             }
[10:19:52.646]             {
[10:19:52.646]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.646]                   0L) {
[10:19:52.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.646]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.646]                   base::options(opts)
[10:19:52.646]                 }
[10:19:52.646]                 {
[10:19:52.646]                   {
[10:19:52.646]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.646]                     NULL
[10:19:52.646]                   }
[10:19:52.646]                   options(future.plan = NULL)
[10:19:52.646]                   if (is.na(NA_character_)) 
[10:19:52.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.646]                     .init = FALSE)
[10:19:52.646]                 }
[10:19:52.646]             }
[10:19:52.646]         }
[10:19:52.646]     })
[10:19:52.646]     if (TRUE) {
[10:19:52.646]         base::sink(type = "output", split = FALSE)
[10:19:52.646]         if (TRUE) {
[10:19:52.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.646]         }
[10:19:52.646]         else {
[10:19:52.646]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.646]         }
[10:19:52.646]         base::close(...future.stdout)
[10:19:52.646]         ...future.stdout <- NULL
[10:19:52.646]     }
[10:19:52.646]     ...future.result$conditions <- ...future.conditions
[10:19:52.646]     ...future.result$finished <- base::Sys.time()
[10:19:52.646]     ...future.result
[10:19:52.646] }
[10:19:52.648] assign_globals() ...
[10:19:52.648] List of 11
[10:19:52.648]  $ ...future.FUN            :function (x, ...)  
[10:19:52.648]  $ x_FUN                    :function (x)  
[10:19:52.648]  $ times                    : int 4
[10:19:52.648]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.648]  $ stop_if_not              :function (...)  
[10:19:52.648]  $ dim                      : int [1:2] 2 2
[10:19:52.648]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.648]  $ future.call.arguments    : list()
[10:19:52.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.648]  $ ...future.elements_ii    :List of 5
[10:19:52.648]   ..$ : int 1
[10:19:52.648]   ..$ : int 2
[10:19:52.648]   ..$ : int 3
[10:19:52.648]   ..$ : int 4
[10:19:52.648]   ..$ : int 5
[10:19:52.648]  $ ...future.seeds_ii       : NULL
[10:19:52.648]  $ ...future.globals.maxSize: NULL
[10:19:52.648]  - attr(*, "where")=List of 11
[10:19:52.648]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.648]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.648]  - attr(*, "resolved")= logi FALSE
[10:19:52.648]  - attr(*, "total_size")= num 24958
[10:19:52.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.648]  - attr(*, "already-done")= logi TRUE
[10:19:52.662] - copied ‘...future.FUN’ to environment
[10:19:52.662] - reassign environment for ‘x_FUN’
[10:19:52.662] - copied ‘x_FUN’ to environment
[10:19:52.662] - copied ‘times’ to environment
[10:19:52.662] - copied ‘stopf’ to environment
[10:19:52.662] - copied ‘stop_if_not’ to environment
[10:19:52.662] - copied ‘dim’ to environment
[10:19:52.662] - copied ‘valid_types’ to environment
[10:19:52.662] - copied ‘future.call.arguments’ to environment
[10:19:52.663] - copied ‘...future.elements_ii’ to environment
[10:19:52.663] - copied ‘...future.seeds_ii’ to environment
[10:19:52.663] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.663] assign_globals() ... done
[10:19:52.663] requestCore(): workers = 2
[10:19:52.666] MulticoreFuture started
[10:19:52.666] - Launch lazy future ... done
[10:19:52.667] run() for ‘MulticoreFuture’ ... done
[10:19:52.668] Created future:
[10:19:52.668] plan(): Setting new future strategy stack:
[10:19:52.668] List of future strategies:
[10:19:52.668] 1. sequential:
[10:19:52.668]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.668]    - tweaked: FALSE
[10:19:52.668]    - call: NULL
[10:19:52.670] plan(): nbrOfWorkers() = 1
[10:19:52.673] plan(): Setting new future strategy stack:
[10:19:52.674] List of future strategies:
[10:19:52.674] 1. multicore:
[10:19:52.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.674]    - tweaked: FALSE
[10:19:52.674]    - call: plan(strategy)
[10:19:52.678] plan(): nbrOfWorkers() = 2
[10:19:52.668] MulticoreFuture:
[10:19:52.668] Label: ‘future_vapply-1’
[10:19:52.668] Expression:
[10:19:52.668] {
[10:19:52.668]     do.call(function(...) {
[10:19:52.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.668]             on.exit(options(oopts), add = TRUE)
[10:19:52.668]         }
[10:19:52.668]         {
[10:19:52.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.668]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.668]             })
[10:19:52.668]         }
[10:19:52.668]     }, args = future.call.arguments)
[10:19:52.668] }
[10:19:52.668] Lazy evaluation: FALSE
[10:19:52.668] Asynchronous evaluation: TRUE
[10:19:52.668] Local evaluation: TRUE
[10:19:52.668] Environment: R_GlobalEnv
[10:19:52.668] Capture standard output: TRUE
[10:19:52.668] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.668] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.668] Packages: 1 packages (‘future.apply’)
[10:19:52.668] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.668] Resolved: TRUE
[10:19:52.668] Value: <not collected>
[10:19:52.668] Conditions captured: <none>
[10:19:52.668] Early signaling: FALSE
[10:19:52.668] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.668] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.679] Chunk #1 of 2 ... DONE
[10:19:52.680] Chunk #2 of 2 ...
[10:19:52.680]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.680] getGlobalsAndPackages() ...
[10:19:52.680] Searching for globals...
[10:19:52.681] 
[10:19:52.681] Searching for globals ... DONE
[10:19:52.681] - globals: [0] <none>
[10:19:52.682] getGlobalsAndPackages() ... DONE
[10:19:52.682]    + additional globals found: [n=0] 
[10:19:52.682]    + additional namespaces needed: [n=0] 
[10:19:52.682]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.682]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.683]  - seeds: <none>
[10:19:52.683]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.683] getGlobalsAndPackages() ...
[10:19:52.683] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.684] Resolving globals: FALSE
[10:19:52.684] Tweak future expression to call with '...' arguments ...
[10:19:52.684] {
[10:19:52.684]     do.call(function(...) {
[10:19:52.684]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.684]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.684]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.684]             on.exit(options(oopts), add = TRUE)
[10:19:52.684]         }
[10:19:52.684]         {
[10:19:52.684]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.684]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.684]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.684]             })
[10:19:52.684]         }
[10:19:52.684]     }, args = future.call.arguments)
[10:19:52.684] }
[10:19:52.685] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.686] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.686] - packages: [1] ‘future.apply’
[10:19:52.686] getGlobalsAndPackages() ... DONE
[10:19:52.686] run() for ‘Future’ ...
[10:19:52.687] - state: ‘created’
[10:19:52.687] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.689] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.690] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.690]   - Field: ‘label’
[10:19:52.690]   - Field: ‘local’
[10:19:52.690]   - Field: ‘owner’
[10:19:52.690]   - Field: ‘envir’
[10:19:52.690]   - Field: ‘workers’
[10:19:52.691]   - Field: ‘packages’
[10:19:52.691]   - Field: ‘gc’
[10:19:52.691]   - Field: ‘job’
[10:19:52.691]   - Field: ‘conditions’
[10:19:52.691]   - Field: ‘expr’
[10:19:52.691]   - Field: ‘uuid’
[10:19:52.691]   - Field: ‘seed’
[10:19:52.691]   - Field: ‘version’
[10:19:52.692]   - Field: ‘result’
[10:19:52.692]   - Field: ‘asynchronous’
[10:19:52.692]   - Field: ‘calls’
[10:19:52.692]   - Field: ‘globals’
[10:19:52.692]   - Field: ‘stdout’
[10:19:52.692]   - Field: ‘earlySignal’
[10:19:52.692]   - Field: ‘lazy’
[10:19:52.692]   - Field: ‘state’
[10:19:52.693] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.693] - Launch lazy future ...
[10:19:52.693] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.693] Packages needed by future strategies (n = 0): <none>
[10:19:52.694] {
[10:19:52.694]     {
[10:19:52.694]         {
[10:19:52.694]             ...future.startTime <- base::Sys.time()
[10:19:52.694]             {
[10:19:52.694]                 {
[10:19:52.694]                   {
[10:19:52.694]                     {
[10:19:52.694]                       {
[10:19:52.694]                         base::local({
[10:19:52.694]                           has_future <- base::requireNamespace("future", 
[10:19:52.694]                             quietly = TRUE)
[10:19:52.694]                           if (has_future) {
[10:19:52.694]                             ns <- base::getNamespace("future")
[10:19:52.694]                             version <- ns[[".package"]][["version"]]
[10:19:52.694]                             if (is.null(version)) 
[10:19:52.694]                               version <- utils::packageVersion("future")
[10:19:52.694]                           }
[10:19:52.694]                           else {
[10:19:52.694]                             version <- NULL
[10:19:52.694]                           }
[10:19:52.694]                           if (!has_future || version < "1.8.0") {
[10:19:52.694]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.694]                               "", base::R.version$version.string), 
[10:19:52.694]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.694]                                 base::R.version$platform, 8 * 
[10:19:52.694]                                   base::.Machine$sizeof.pointer), 
[10:19:52.694]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.694]                                 "release", "version")], collapse = " "), 
[10:19:52.694]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.694]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.694]                               info)
[10:19:52.694]                             info <- base::paste(info, collapse = "; ")
[10:19:52.694]                             if (!has_future) {
[10:19:52.694]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.694]                                 info)
[10:19:52.694]                             }
[10:19:52.694]                             else {
[10:19:52.694]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.694]                                 info, version)
[10:19:52.694]                             }
[10:19:52.694]                             base::stop(msg)
[10:19:52.694]                           }
[10:19:52.694]                         })
[10:19:52.694]                       }
[10:19:52.694]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.694]                       base::options(mc.cores = 1L)
[10:19:52.694]                     }
[10:19:52.694]                     base::local({
[10:19:52.694]                       for (pkg in "future.apply") {
[10:19:52.694]                         base::loadNamespace(pkg)
[10:19:52.694]                         base::library(pkg, character.only = TRUE)
[10:19:52.694]                       }
[10:19:52.694]                     })
[10:19:52.694]                   }
[10:19:52.694]                   ...future.strategy.old <- future::plan("list")
[10:19:52.694]                   options(future.plan = NULL)
[10:19:52.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.694]                 }
[10:19:52.694]                 ...future.workdir <- getwd()
[10:19:52.694]             }
[10:19:52.694]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.694]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.694]         }
[10:19:52.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.694]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.694]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.694]             base::names(...future.oldOptions))
[10:19:52.694]     }
[10:19:52.694]     if (FALSE) {
[10:19:52.694]     }
[10:19:52.694]     else {
[10:19:52.694]         if (TRUE) {
[10:19:52.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.694]                 open = "w")
[10:19:52.694]         }
[10:19:52.694]         else {
[10:19:52.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.694]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.694]         }
[10:19:52.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.694]             base::sink(type = "output", split = FALSE)
[10:19:52.694]             base::close(...future.stdout)
[10:19:52.694]         }, add = TRUE)
[10:19:52.694]     }
[10:19:52.694]     ...future.frame <- base::sys.nframe()
[10:19:52.694]     ...future.conditions <- base::list()
[10:19:52.694]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.694]     if (FALSE) {
[10:19:52.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.694]     }
[10:19:52.694]     ...future.result <- base::tryCatch({
[10:19:52.694]         base::withCallingHandlers({
[10:19:52.694]             ...future.value <- base::withVisible(base::local({
[10:19:52.694]                 withCallingHandlers({
[10:19:52.694]                   {
[10:19:52.694]                     do.call(function(...) {
[10:19:52.694]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.694]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.694]                         ...future.globals.maxSize)) {
[10:19:52.694]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.694]                         on.exit(options(oopts), add = TRUE)
[10:19:52.694]                       }
[10:19:52.694]                       {
[10:19:52.694]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.694]                           FUN = function(jj) {
[10:19:52.694]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.694]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.694]                           })
[10:19:52.694]                       }
[10:19:52.694]                     }, args = future.call.arguments)
[10:19:52.694]                   }
[10:19:52.694]                 }, immediateCondition = function(cond) {
[10:19:52.694]                   save_rds <- function (object, pathname, ...) 
[10:19:52.694]                   {
[10:19:52.694]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.694]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.694]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.694]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.694]                         fi_tmp[["mtime"]])
[10:19:52.694]                     }
[10:19:52.694]                     tryCatch({
[10:19:52.694]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.694]                     }, error = function(ex) {
[10:19:52.694]                       msg <- conditionMessage(ex)
[10:19:52.694]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.694]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.694]                         fi_tmp[["mtime"]], msg)
[10:19:52.694]                       ex$message <- msg
[10:19:52.694]                       stop(ex)
[10:19:52.694]                     })
[10:19:52.694]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.694]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.694]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.694]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.694]                       fi <- file.info(pathname)
[10:19:52.694]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.694]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.694]                         fi[["size"]], fi[["mtime"]])
[10:19:52.694]                       stop(msg)
[10:19:52.694]                     }
[10:19:52.694]                     invisible(pathname)
[10:19:52.694]                   }
[10:19:52.694]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.694]                     rootPath = tempdir()) 
[10:19:52.694]                   {
[10:19:52.694]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.694]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.694]                       tmpdir = path, fileext = ".rds")
[10:19:52.694]                     save_rds(obj, file)
[10:19:52.694]                   }
[10:19:52.694]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.694]                   {
[10:19:52.694]                     inherits <- base::inherits
[10:19:52.694]                     invokeRestart <- base::invokeRestart
[10:19:52.694]                     is.null <- base::is.null
[10:19:52.694]                     muffled <- FALSE
[10:19:52.694]                     if (inherits(cond, "message")) {
[10:19:52.694]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.694]                       if (muffled) 
[10:19:52.694]                         invokeRestart("muffleMessage")
[10:19:52.694]                     }
[10:19:52.694]                     else if (inherits(cond, "warning")) {
[10:19:52.694]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.694]                       if (muffled) 
[10:19:52.694]                         invokeRestart("muffleWarning")
[10:19:52.694]                     }
[10:19:52.694]                     else if (inherits(cond, "condition")) {
[10:19:52.694]                       if (!is.null(pattern)) {
[10:19:52.694]                         computeRestarts <- base::computeRestarts
[10:19:52.694]                         grepl <- base::grepl
[10:19:52.694]                         restarts <- computeRestarts(cond)
[10:19:52.694]                         for (restart in restarts) {
[10:19:52.694]                           name <- restart$name
[10:19:52.694]                           if (is.null(name)) 
[10:19:52.694]                             next
[10:19:52.694]                           if (!grepl(pattern, name)) 
[10:19:52.694]                             next
[10:19:52.694]                           invokeRestart(restart)
[10:19:52.694]                           muffled <- TRUE
[10:19:52.694]                           break
[10:19:52.694]                         }
[10:19:52.694]                       }
[10:19:52.694]                     }
[10:19:52.694]                     invisible(muffled)
[10:19:52.694]                   }
[10:19:52.694]                   muffleCondition(cond)
[10:19:52.694]                 })
[10:19:52.694]             }))
[10:19:52.694]             future::FutureResult(value = ...future.value$value, 
[10:19:52.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.694]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.694]                     ...future.globalenv.names))
[10:19:52.694]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.694]         }, condition = base::local({
[10:19:52.694]             c <- base::c
[10:19:52.694]             inherits <- base::inherits
[10:19:52.694]             invokeRestart <- base::invokeRestart
[10:19:52.694]             length <- base::length
[10:19:52.694]             list <- base::list
[10:19:52.694]             seq.int <- base::seq.int
[10:19:52.694]             signalCondition <- base::signalCondition
[10:19:52.694]             sys.calls <- base::sys.calls
[10:19:52.694]             `[[` <- base::`[[`
[10:19:52.694]             `+` <- base::`+`
[10:19:52.694]             `<<-` <- base::`<<-`
[10:19:52.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.694]                   3L)]
[10:19:52.694]             }
[10:19:52.694]             function(cond) {
[10:19:52.694]                 is_error <- inherits(cond, "error")
[10:19:52.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.694]                   NULL)
[10:19:52.694]                 if (is_error) {
[10:19:52.694]                   sessionInformation <- function() {
[10:19:52.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.694]                       search = base::search(), system = base::Sys.info())
[10:19:52.694]                   }
[10:19:52.694]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.694]                     cond$call), session = sessionInformation(), 
[10:19:52.694]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.694]                   signalCondition(cond)
[10:19:52.694]                 }
[10:19:52.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.694]                 "immediateCondition"))) {
[10:19:52.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.694]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.694]                   if (TRUE && !signal) {
[10:19:52.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.694]                     {
[10:19:52.694]                       inherits <- base::inherits
[10:19:52.694]                       invokeRestart <- base::invokeRestart
[10:19:52.694]                       is.null <- base::is.null
[10:19:52.694]                       muffled <- FALSE
[10:19:52.694]                       if (inherits(cond, "message")) {
[10:19:52.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.694]                         if (muffled) 
[10:19:52.694]                           invokeRestart("muffleMessage")
[10:19:52.694]                       }
[10:19:52.694]                       else if (inherits(cond, "warning")) {
[10:19:52.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.694]                         if (muffled) 
[10:19:52.694]                           invokeRestart("muffleWarning")
[10:19:52.694]                       }
[10:19:52.694]                       else if (inherits(cond, "condition")) {
[10:19:52.694]                         if (!is.null(pattern)) {
[10:19:52.694]                           computeRestarts <- base::computeRestarts
[10:19:52.694]                           grepl <- base::grepl
[10:19:52.694]                           restarts <- computeRestarts(cond)
[10:19:52.694]                           for (restart in restarts) {
[10:19:52.694]                             name <- restart$name
[10:19:52.694]                             if (is.null(name)) 
[10:19:52.694]                               next
[10:19:52.694]                             if (!grepl(pattern, name)) 
[10:19:52.694]                               next
[10:19:52.694]                             invokeRestart(restart)
[10:19:52.694]                             muffled <- TRUE
[10:19:52.694]                             break
[10:19:52.694]                           }
[10:19:52.694]                         }
[10:19:52.694]                       }
[10:19:52.694]                       invisible(muffled)
[10:19:52.694]                     }
[10:19:52.694]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.694]                   }
[10:19:52.694]                 }
[10:19:52.694]                 else {
[10:19:52.694]                   if (TRUE) {
[10:19:52.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.694]                     {
[10:19:52.694]                       inherits <- base::inherits
[10:19:52.694]                       invokeRestart <- base::invokeRestart
[10:19:52.694]                       is.null <- base::is.null
[10:19:52.694]                       muffled <- FALSE
[10:19:52.694]                       if (inherits(cond, "message")) {
[10:19:52.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.694]                         if (muffled) 
[10:19:52.694]                           invokeRestart("muffleMessage")
[10:19:52.694]                       }
[10:19:52.694]                       else if (inherits(cond, "warning")) {
[10:19:52.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.694]                         if (muffled) 
[10:19:52.694]                           invokeRestart("muffleWarning")
[10:19:52.694]                       }
[10:19:52.694]                       else if (inherits(cond, "condition")) {
[10:19:52.694]                         if (!is.null(pattern)) {
[10:19:52.694]                           computeRestarts <- base::computeRestarts
[10:19:52.694]                           grepl <- base::grepl
[10:19:52.694]                           restarts <- computeRestarts(cond)
[10:19:52.694]                           for (restart in restarts) {
[10:19:52.694]                             name <- restart$name
[10:19:52.694]                             if (is.null(name)) 
[10:19:52.694]                               next
[10:19:52.694]                             if (!grepl(pattern, name)) 
[10:19:52.694]                               next
[10:19:52.694]                             invokeRestart(restart)
[10:19:52.694]                             muffled <- TRUE
[10:19:52.694]                             break
[10:19:52.694]                           }
[10:19:52.694]                         }
[10:19:52.694]                       }
[10:19:52.694]                       invisible(muffled)
[10:19:52.694]                     }
[10:19:52.694]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.694]                   }
[10:19:52.694]                 }
[10:19:52.694]             }
[10:19:52.694]         }))
[10:19:52.694]     }, error = function(ex) {
[10:19:52.694]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.694]                 ...future.rng), started = ...future.startTime, 
[10:19:52.694]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.694]             version = "1.8"), class = "FutureResult")
[10:19:52.694]     }, finally = {
[10:19:52.694]         if (!identical(...future.workdir, getwd())) 
[10:19:52.694]             setwd(...future.workdir)
[10:19:52.694]         {
[10:19:52.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.694]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.694]             }
[10:19:52.694]             base::options(...future.oldOptions)
[10:19:52.694]             if (.Platform$OS.type == "windows") {
[10:19:52.694]                 old_names <- names(...future.oldEnvVars)
[10:19:52.694]                 envs <- base::Sys.getenv()
[10:19:52.694]                 names <- names(envs)
[10:19:52.694]                 common <- intersect(names, old_names)
[10:19:52.694]                 added <- setdiff(names, old_names)
[10:19:52.694]                 removed <- setdiff(old_names, names)
[10:19:52.694]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.694]                   envs[common]]
[10:19:52.694]                 NAMES <- toupper(changed)
[10:19:52.694]                 args <- list()
[10:19:52.694]                 for (kk in seq_along(NAMES)) {
[10:19:52.694]                   name <- changed[[kk]]
[10:19:52.694]                   NAME <- NAMES[[kk]]
[10:19:52.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.694]                     next
[10:19:52.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.694]                 }
[10:19:52.694]                 NAMES <- toupper(added)
[10:19:52.694]                 for (kk in seq_along(NAMES)) {
[10:19:52.694]                   name <- added[[kk]]
[10:19:52.694]                   NAME <- NAMES[[kk]]
[10:19:52.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.694]                     next
[10:19:52.694]                   args[[name]] <- ""
[10:19:52.694]                 }
[10:19:52.694]                 NAMES <- toupper(removed)
[10:19:52.694]                 for (kk in seq_along(NAMES)) {
[10:19:52.694]                   name <- removed[[kk]]
[10:19:52.694]                   NAME <- NAMES[[kk]]
[10:19:52.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.694]                     next
[10:19:52.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.694]                 }
[10:19:52.694]                 if (length(args) > 0) 
[10:19:52.694]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.694]             }
[10:19:52.694]             else {
[10:19:52.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.694]             }
[10:19:52.694]             {
[10:19:52.694]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.694]                   0L) {
[10:19:52.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.694]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.694]                   base::options(opts)
[10:19:52.694]                 }
[10:19:52.694]                 {
[10:19:52.694]                   {
[10:19:52.694]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.694]                     NULL
[10:19:52.694]                   }
[10:19:52.694]                   options(future.plan = NULL)
[10:19:52.694]                   if (is.na(NA_character_)) 
[10:19:52.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.694]                     .init = FALSE)
[10:19:52.694]                 }
[10:19:52.694]             }
[10:19:52.694]         }
[10:19:52.694]     })
[10:19:52.694]     if (TRUE) {
[10:19:52.694]         base::sink(type = "output", split = FALSE)
[10:19:52.694]         if (TRUE) {
[10:19:52.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.694]         }
[10:19:52.694]         else {
[10:19:52.694]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.694]         }
[10:19:52.694]         base::close(...future.stdout)
[10:19:52.694]         ...future.stdout <- NULL
[10:19:52.694]     }
[10:19:52.694]     ...future.result$conditions <- ...future.conditions
[10:19:52.694]     ...future.result$finished <- base::Sys.time()
[10:19:52.694]     ...future.result
[10:19:52.694] }
[10:19:52.698] assign_globals() ...
[10:19:52.698] List of 11
[10:19:52.698]  $ ...future.FUN            :function (x, ...)  
[10:19:52.698]  $ x_FUN                    :function (x)  
[10:19:52.698]  $ times                    : int 4
[10:19:52.698]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.698]  $ stop_if_not              :function (...)  
[10:19:52.698]  $ dim                      : int [1:2] 2 2
[10:19:52.698]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.698]  $ future.call.arguments    : list()
[10:19:52.698]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.698]  $ ...future.elements_ii    :List of 5
[10:19:52.698]   ..$ : int 6
[10:19:52.698]   ..$ : int 7
[10:19:52.698]   ..$ : int 8
[10:19:52.698]   ..$ : int 9
[10:19:52.698]   ..$ : int 10
[10:19:52.698]  $ ...future.seeds_ii       : NULL
[10:19:52.698]  $ ...future.globals.maxSize: NULL
[10:19:52.698]  - attr(*, "where")=List of 11
[10:19:52.698]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.698]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.698]  - attr(*, "resolved")= logi FALSE
[10:19:52.698]  - attr(*, "total_size")= num 24958
[10:19:52.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.698]  - attr(*, "already-done")= logi TRUE
[10:19:52.711] - copied ‘...future.FUN’ to environment
[10:19:52.711] - reassign environment for ‘x_FUN’
[10:19:52.711] - copied ‘x_FUN’ to environment
[10:19:52.711] - copied ‘times’ to environment
[10:19:52.711] - copied ‘stopf’ to environment
[10:19:52.712] - copied ‘stop_if_not’ to environment
[10:19:52.712] - copied ‘dim’ to environment
[10:19:52.712] - copied ‘valid_types’ to environment
[10:19:52.712] - copied ‘future.call.arguments’ to environment
[10:19:52.712] - copied ‘...future.elements_ii’ to environment
[10:19:52.712] - copied ‘...future.seeds_ii’ to environment
[10:19:52.712] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.712] assign_globals() ... done
[10:19:52.713] requestCore(): workers = 2
[10:19:52.715] MulticoreFuture started
[10:19:52.716] - Launch lazy future ... done
[10:19:52.716] run() for ‘MulticoreFuture’ ... done
[10:19:52.717] Created future:
[10:19:52.717] plan(): Setting new future strategy stack:
[10:19:52.717] List of future strategies:
[10:19:52.717] 1. sequential:
[10:19:52.717]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.717]    - tweaked: FALSE
[10:19:52.717]    - call: NULL
[10:19:52.719] plan(): nbrOfWorkers() = 1
[10:19:52.723] plan(): Setting new future strategy stack:
[10:19:52.723] List of future strategies:
[10:19:52.723] 1. multicore:
[10:19:52.723]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.723]    - tweaked: FALSE
[10:19:52.723]    - call: plan(strategy)
[10:19:52.727] plan(): nbrOfWorkers() = 2
[10:19:52.717] MulticoreFuture:
[10:19:52.717] Label: ‘future_vapply-2’
[10:19:52.717] Expression:
[10:19:52.717] {
[10:19:52.717]     do.call(function(...) {
[10:19:52.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.717]             on.exit(options(oopts), add = TRUE)
[10:19:52.717]         }
[10:19:52.717]         {
[10:19:52.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.717]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.717]             })
[10:19:52.717]         }
[10:19:52.717]     }, args = future.call.arguments)
[10:19:52.717] }
[10:19:52.717] Lazy evaluation: FALSE
[10:19:52.717] Asynchronous evaluation: TRUE
[10:19:52.717] Local evaluation: TRUE
[10:19:52.717] Environment: R_GlobalEnv
[10:19:52.717] Capture standard output: TRUE
[10:19:52.717] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.717] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.717] Packages: 1 packages (‘future.apply’)
[10:19:52.717] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.717] Resolved: TRUE
[10:19:52.717] Value: <not collected>
[10:19:52.717] Conditions captured: <none>
[10:19:52.717] Early signaling: FALSE
[10:19:52.717] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.717] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.729] Chunk #2 of 2 ... DONE
[10:19:52.729] Launching 2 futures (chunks) ... DONE
[10:19:52.729] Resolving 2 futures (chunks) ...
[10:19:52.729] resolve() on list ...
[10:19:52.730]  recursive: 0
[10:19:52.730]  length: 2
[10:19:52.730] 
[10:19:52.730] Future #1
[10:19:52.731] result() for MulticoreFuture ...
[10:19:52.732] result() for MulticoreFuture ...
[10:19:52.732] result() for MulticoreFuture ... done
[10:19:52.732] result() for MulticoreFuture ... done
[10:19:52.732] result() for MulticoreFuture ...
[10:19:52.733] result() for MulticoreFuture ... done
[10:19:52.733] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.733] - nx: 2
[10:19:52.733] - relay: TRUE
[10:19:52.733] - stdout: TRUE
[10:19:52.733] - signal: TRUE
[10:19:52.734] - resignal: FALSE
[10:19:52.734] - force: TRUE
[10:19:52.734] - relayed: [n=2] FALSE, FALSE
[10:19:52.734] - queued futures: [n=2] FALSE, FALSE
[10:19:52.734]  - until=1
[10:19:52.734]  - relaying element #1
[10:19:52.734] result() for MulticoreFuture ...
[10:19:52.734] result() for MulticoreFuture ... done
[10:19:52.735] result() for MulticoreFuture ...
[10:19:52.735] result() for MulticoreFuture ... done
[10:19:52.735] result() for MulticoreFuture ...
[10:19:52.735] result() for MulticoreFuture ... done
[10:19:52.735] result() for MulticoreFuture ...
[10:19:52.736] result() for MulticoreFuture ... done
[10:19:52.736] - relayed: [n=2] TRUE, FALSE
[10:19:52.736] - queued futures: [n=2] TRUE, FALSE
[10:19:52.736] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.736]  length: 1 (resolved future 1)
[10:19:52.737] Future #2
[10:19:52.737] result() for MulticoreFuture ...
[10:19:52.737] result() for MulticoreFuture ...
[10:19:52.738] result() for MulticoreFuture ... done
[10:19:52.738] result() for MulticoreFuture ... done
[10:19:52.738] result() for MulticoreFuture ...
[10:19:52.738] result() for MulticoreFuture ... done
[10:19:52.738] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.738] - nx: 2
[10:19:52.738] - relay: TRUE
[10:19:52.739] - stdout: TRUE
[10:19:52.739] - signal: TRUE
[10:19:52.739] - resignal: FALSE
[10:19:52.739] - force: TRUE
[10:19:52.739] - relayed: [n=2] TRUE, FALSE
[10:19:52.739] - queued futures: [n=2] TRUE, FALSE
[10:19:52.739]  - until=2
[10:19:52.739]  - relaying element #2
[10:19:52.739] result() for MulticoreFuture ...
[10:19:52.739] result() for MulticoreFuture ... done
[10:19:52.740] result() for MulticoreFuture ...
[10:19:52.740] result() for MulticoreFuture ... done
[10:19:52.740] result() for MulticoreFuture ...
[10:19:52.740] result() for MulticoreFuture ... done
[10:19:52.740] result() for MulticoreFuture ...
[10:19:52.740] result() for MulticoreFuture ... done
[10:19:52.740] - relayed: [n=2] TRUE, TRUE
[10:19:52.740] - queued futures: [n=2] TRUE, TRUE
[10:19:52.741] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.741]  length: 0 (resolved future 2)
[10:19:52.741] Relaying remaining futures
[10:19:52.741] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.741] - nx: 2
[10:19:52.741] - relay: TRUE
[10:19:52.741] - stdout: TRUE
[10:19:52.741] - signal: TRUE
[10:19:52.741] - resignal: FALSE
[10:19:52.741] - force: TRUE
[10:19:52.742] - relayed: [n=2] TRUE, TRUE
[10:19:52.742] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:52.742] - relayed: [n=2] TRUE, TRUE
[10:19:52.742] - queued futures: [n=2] TRUE, TRUE
[10:19:52.742] signalConditionsASAP(NULL, pos=0) ... done
[10:19:52.742] resolve() on list ... DONE
[10:19:52.742] result() for MulticoreFuture ...
[10:19:52.742] result() for MulticoreFuture ... done
[10:19:52.742] result() for MulticoreFuture ...
[10:19:52.743] result() for MulticoreFuture ... done
[10:19:52.743] result() for MulticoreFuture ...
[10:19:52.743] result() for MulticoreFuture ... done
[10:19:52.743] result() for MulticoreFuture ...
[10:19:52.743] result() for MulticoreFuture ... done
[10:19:52.743]  - Number of value chunks collected: 2
[10:19:52.743] Resolving 2 futures (chunks) ... DONE
[10:19:52.743] Reducing values from 2 chunks ...
[10:19:52.743]  - Number of values collected after concatenation: 10
[10:19:52.743]  - Number of values expected: 10
[10:19:52.744] Reducing values from 2 chunks ... DONE
[10:19:52.744] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:19:52.746] future_lapply() ...
[10:19:52.750] Number of chunks: 2
[10:19:52.750] getGlobalsAndPackagesXApply() ...
[10:19:52.750]  - future.globals: TRUE
[10:19:52.750] getGlobalsAndPackages() ...
[10:19:52.751] Searching for globals...
[10:19:52.758] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:19:52.758] Searching for globals ... DONE
[10:19:52.758] Resolving globals: FALSE
[10:19:52.759] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[10:19:52.760] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:52.760] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.760] - packages: [1] ‘future.apply’
[10:19:52.760] getGlobalsAndPackages() ... DONE
[10:19:52.760]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.760]  - needed namespaces: [n=1] ‘future.apply’
[10:19:52.760] Finding globals ... DONE
[10:19:52.760]  - use_args: TRUE
[10:19:52.761]  - Getting '...' globals ...
[10:19:52.761] resolve() on list ...
[10:19:52.761]  recursive: 0
[10:19:52.761]  length: 1
[10:19:52.761]  elements: ‘...’
[10:19:52.761]  length: 0 (resolved future 1)
[10:19:52.761] resolve() on list ... DONE
[10:19:52.761]    - '...' content: [n=0] 
[10:19:52.762] List of 1
[10:19:52.762]  $ ...: list()
[10:19:52.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.762]  - attr(*, "where")=List of 1
[10:19:52.762]   ..$ ...:<environment: 0x55c69fb0b1f0> 
[10:19:52.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.762]  - attr(*, "resolved")= logi TRUE
[10:19:52.762]  - attr(*, "total_size")= num NA
[10:19:52.764]  - Getting '...' globals ... DONE
[10:19:52.764] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:52.764] List of 8
[10:19:52.764]  $ ...future.FUN:function (x, ...)  
[10:19:52.764]  $ x_FUN        :function (x)  
[10:19:52.764]  $ times        : int 4
[10:19:52.764]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.764]  $ stop_if_not  :function (...)  
[10:19:52.764]  $ dim          : int [1:2] 2 2
[10:19:52.764]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:52.764]  $ ...          : list()
[10:19:52.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.764]  - attr(*, "where")=List of 8
[10:19:52.764]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:52.764]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:52.764]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:52.764]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:52.764]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:52.764]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:52.764]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:52.764]   ..$ ...          :<environment: 0x55c69fb0b1f0> 
[10:19:52.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.764]  - attr(*, "resolved")= logi FALSE
[10:19:52.764]  - attr(*, "total_size")= num 29094
[10:19:52.770] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:52.770] getGlobalsAndPackagesXApply() ... DONE
[10:19:52.770] Number of futures (= number of chunks): 2
[10:19:52.770] Launching 2 futures (chunks) ...
[10:19:52.770] Chunk #1 of 2 ...
[10:19:52.770]  - Finding globals in 'X' for chunk #1 ...
[10:19:52.771] getGlobalsAndPackages() ...
[10:19:52.771] Searching for globals...
[10:19:52.771] 
[10:19:52.771] Searching for globals ... DONE
[10:19:52.771] - globals: [0] <none>
[10:19:52.771] getGlobalsAndPackages() ... DONE
[10:19:52.771]    + additional globals found: [n=0] 
[10:19:52.771]    + additional namespaces needed: [n=0] 
[10:19:52.771]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:52.772]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.772]  - seeds: <none>
[10:19:52.772]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.772] getGlobalsAndPackages() ...
[10:19:52.772] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.772] Resolving globals: FALSE
[10:19:52.772] Tweak future expression to call with '...' arguments ...
[10:19:52.772] {
[10:19:52.772]     do.call(function(...) {
[10:19:52.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.772]             on.exit(options(oopts), add = TRUE)
[10:19:52.772]         }
[10:19:52.772]         {
[10:19:52.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.772]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.772]             })
[10:19:52.772]         }
[10:19:52.772]     }, args = future.call.arguments)
[10:19:52.772] }
[10:19:52.772] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.773] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.773] - packages: [1] ‘future.apply’
[10:19:52.773] getGlobalsAndPackages() ... DONE
[10:19:52.774] run() for ‘Future’ ...
[10:19:52.774] - state: ‘created’
[10:19:52.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.778]   - Field: ‘label’
[10:19:52.778]   - Field: ‘local’
[10:19:52.778]   - Field: ‘owner’
[10:19:52.778]   - Field: ‘envir’
[10:19:52.778]   - Field: ‘workers’
[10:19:52.778]   - Field: ‘packages’
[10:19:52.779]   - Field: ‘gc’
[10:19:52.779]   - Field: ‘job’
[10:19:52.779]   - Field: ‘conditions’
[10:19:52.779]   - Field: ‘expr’
[10:19:52.779]   - Field: ‘uuid’
[10:19:52.779]   - Field: ‘seed’
[10:19:52.779]   - Field: ‘version’
[10:19:52.779]   - Field: ‘result’
[10:19:52.779]   - Field: ‘asynchronous’
[10:19:52.779]   - Field: ‘calls’
[10:19:52.780]   - Field: ‘globals’
[10:19:52.780]   - Field: ‘stdout’
[10:19:52.780]   - Field: ‘earlySignal’
[10:19:52.780]   - Field: ‘lazy’
[10:19:52.780]   - Field: ‘state’
[10:19:52.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.780] - Launch lazy future ...
[10:19:52.780] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.781] Packages needed by future strategies (n = 0): <none>
[10:19:52.781] {
[10:19:52.781]     {
[10:19:52.781]         {
[10:19:52.781]             ...future.startTime <- base::Sys.time()
[10:19:52.781]             {
[10:19:52.781]                 {
[10:19:52.781]                   {
[10:19:52.781]                     {
[10:19:52.781]                       {
[10:19:52.781]                         base::local({
[10:19:52.781]                           has_future <- base::requireNamespace("future", 
[10:19:52.781]                             quietly = TRUE)
[10:19:52.781]                           if (has_future) {
[10:19:52.781]                             ns <- base::getNamespace("future")
[10:19:52.781]                             version <- ns[[".package"]][["version"]]
[10:19:52.781]                             if (is.null(version)) 
[10:19:52.781]                               version <- utils::packageVersion("future")
[10:19:52.781]                           }
[10:19:52.781]                           else {
[10:19:52.781]                             version <- NULL
[10:19:52.781]                           }
[10:19:52.781]                           if (!has_future || version < "1.8.0") {
[10:19:52.781]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.781]                               "", base::R.version$version.string), 
[10:19:52.781]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.781]                                 base::R.version$platform, 8 * 
[10:19:52.781]                                   base::.Machine$sizeof.pointer), 
[10:19:52.781]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.781]                                 "release", "version")], collapse = " "), 
[10:19:52.781]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.781]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.781]                               info)
[10:19:52.781]                             info <- base::paste(info, collapse = "; ")
[10:19:52.781]                             if (!has_future) {
[10:19:52.781]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.781]                                 info)
[10:19:52.781]                             }
[10:19:52.781]                             else {
[10:19:52.781]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.781]                                 info, version)
[10:19:52.781]                             }
[10:19:52.781]                             base::stop(msg)
[10:19:52.781]                           }
[10:19:52.781]                         })
[10:19:52.781]                       }
[10:19:52.781]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.781]                       base::options(mc.cores = 1L)
[10:19:52.781]                     }
[10:19:52.781]                     base::local({
[10:19:52.781]                       for (pkg in "future.apply") {
[10:19:52.781]                         base::loadNamespace(pkg)
[10:19:52.781]                         base::library(pkg, character.only = TRUE)
[10:19:52.781]                       }
[10:19:52.781]                     })
[10:19:52.781]                   }
[10:19:52.781]                   ...future.strategy.old <- future::plan("list")
[10:19:52.781]                   options(future.plan = NULL)
[10:19:52.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.781]                 }
[10:19:52.781]                 ...future.workdir <- getwd()
[10:19:52.781]             }
[10:19:52.781]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.781]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.781]         }
[10:19:52.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.781]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.781]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.781]             base::names(...future.oldOptions))
[10:19:52.781]     }
[10:19:52.781]     if (FALSE) {
[10:19:52.781]     }
[10:19:52.781]     else {
[10:19:52.781]         if (TRUE) {
[10:19:52.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.781]                 open = "w")
[10:19:52.781]         }
[10:19:52.781]         else {
[10:19:52.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.781]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.781]         }
[10:19:52.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.781]             base::sink(type = "output", split = FALSE)
[10:19:52.781]             base::close(...future.stdout)
[10:19:52.781]         }, add = TRUE)
[10:19:52.781]     }
[10:19:52.781]     ...future.frame <- base::sys.nframe()
[10:19:52.781]     ...future.conditions <- base::list()
[10:19:52.781]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.781]     if (FALSE) {
[10:19:52.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.781]     }
[10:19:52.781]     ...future.result <- base::tryCatch({
[10:19:52.781]         base::withCallingHandlers({
[10:19:52.781]             ...future.value <- base::withVisible(base::local({
[10:19:52.781]                 withCallingHandlers({
[10:19:52.781]                   {
[10:19:52.781]                     do.call(function(...) {
[10:19:52.781]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.781]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.781]                         ...future.globals.maxSize)) {
[10:19:52.781]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.781]                         on.exit(options(oopts), add = TRUE)
[10:19:52.781]                       }
[10:19:52.781]                       {
[10:19:52.781]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.781]                           FUN = function(jj) {
[10:19:52.781]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.781]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.781]                           })
[10:19:52.781]                       }
[10:19:52.781]                     }, args = future.call.arguments)
[10:19:52.781]                   }
[10:19:52.781]                 }, immediateCondition = function(cond) {
[10:19:52.781]                   save_rds <- function (object, pathname, ...) 
[10:19:52.781]                   {
[10:19:52.781]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.781]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.781]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.781]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.781]                         fi_tmp[["mtime"]])
[10:19:52.781]                     }
[10:19:52.781]                     tryCatch({
[10:19:52.781]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.781]                     }, error = function(ex) {
[10:19:52.781]                       msg <- conditionMessage(ex)
[10:19:52.781]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.781]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.781]                         fi_tmp[["mtime"]], msg)
[10:19:52.781]                       ex$message <- msg
[10:19:52.781]                       stop(ex)
[10:19:52.781]                     })
[10:19:52.781]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.781]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.781]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.781]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.781]                       fi <- file.info(pathname)
[10:19:52.781]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.781]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.781]                         fi[["size"]], fi[["mtime"]])
[10:19:52.781]                       stop(msg)
[10:19:52.781]                     }
[10:19:52.781]                     invisible(pathname)
[10:19:52.781]                   }
[10:19:52.781]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.781]                     rootPath = tempdir()) 
[10:19:52.781]                   {
[10:19:52.781]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.781]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.781]                       tmpdir = path, fileext = ".rds")
[10:19:52.781]                     save_rds(obj, file)
[10:19:52.781]                   }
[10:19:52.781]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.781]                   {
[10:19:52.781]                     inherits <- base::inherits
[10:19:52.781]                     invokeRestart <- base::invokeRestart
[10:19:52.781]                     is.null <- base::is.null
[10:19:52.781]                     muffled <- FALSE
[10:19:52.781]                     if (inherits(cond, "message")) {
[10:19:52.781]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.781]                       if (muffled) 
[10:19:52.781]                         invokeRestart("muffleMessage")
[10:19:52.781]                     }
[10:19:52.781]                     else if (inherits(cond, "warning")) {
[10:19:52.781]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.781]                       if (muffled) 
[10:19:52.781]                         invokeRestart("muffleWarning")
[10:19:52.781]                     }
[10:19:52.781]                     else if (inherits(cond, "condition")) {
[10:19:52.781]                       if (!is.null(pattern)) {
[10:19:52.781]                         computeRestarts <- base::computeRestarts
[10:19:52.781]                         grepl <- base::grepl
[10:19:52.781]                         restarts <- computeRestarts(cond)
[10:19:52.781]                         for (restart in restarts) {
[10:19:52.781]                           name <- restart$name
[10:19:52.781]                           if (is.null(name)) 
[10:19:52.781]                             next
[10:19:52.781]                           if (!grepl(pattern, name)) 
[10:19:52.781]                             next
[10:19:52.781]                           invokeRestart(restart)
[10:19:52.781]                           muffled <- TRUE
[10:19:52.781]                           break
[10:19:52.781]                         }
[10:19:52.781]                       }
[10:19:52.781]                     }
[10:19:52.781]                     invisible(muffled)
[10:19:52.781]                   }
[10:19:52.781]                   muffleCondition(cond)
[10:19:52.781]                 })
[10:19:52.781]             }))
[10:19:52.781]             future::FutureResult(value = ...future.value$value, 
[10:19:52.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.781]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.781]                     ...future.globalenv.names))
[10:19:52.781]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.781]         }, condition = base::local({
[10:19:52.781]             c <- base::c
[10:19:52.781]             inherits <- base::inherits
[10:19:52.781]             invokeRestart <- base::invokeRestart
[10:19:52.781]             length <- base::length
[10:19:52.781]             list <- base::list
[10:19:52.781]             seq.int <- base::seq.int
[10:19:52.781]             signalCondition <- base::signalCondition
[10:19:52.781]             sys.calls <- base::sys.calls
[10:19:52.781]             `[[` <- base::`[[`
[10:19:52.781]             `+` <- base::`+`
[10:19:52.781]             `<<-` <- base::`<<-`
[10:19:52.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.781]                   3L)]
[10:19:52.781]             }
[10:19:52.781]             function(cond) {
[10:19:52.781]                 is_error <- inherits(cond, "error")
[10:19:52.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.781]                   NULL)
[10:19:52.781]                 if (is_error) {
[10:19:52.781]                   sessionInformation <- function() {
[10:19:52.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.781]                       search = base::search(), system = base::Sys.info())
[10:19:52.781]                   }
[10:19:52.781]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.781]                     cond$call), session = sessionInformation(), 
[10:19:52.781]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.781]                   signalCondition(cond)
[10:19:52.781]                 }
[10:19:52.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.781]                 "immediateCondition"))) {
[10:19:52.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.781]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.781]                   if (TRUE && !signal) {
[10:19:52.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.781]                     {
[10:19:52.781]                       inherits <- base::inherits
[10:19:52.781]                       invokeRestart <- base::invokeRestart
[10:19:52.781]                       is.null <- base::is.null
[10:19:52.781]                       muffled <- FALSE
[10:19:52.781]                       if (inherits(cond, "message")) {
[10:19:52.781]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.781]                         if (muffled) 
[10:19:52.781]                           invokeRestart("muffleMessage")
[10:19:52.781]                       }
[10:19:52.781]                       else if (inherits(cond, "warning")) {
[10:19:52.781]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.781]                         if (muffled) 
[10:19:52.781]                           invokeRestart("muffleWarning")
[10:19:52.781]                       }
[10:19:52.781]                       else if (inherits(cond, "condition")) {
[10:19:52.781]                         if (!is.null(pattern)) {
[10:19:52.781]                           computeRestarts <- base::computeRestarts
[10:19:52.781]                           grepl <- base::grepl
[10:19:52.781]                           restarts <- computeRestarts(cond)
[10:19:52.781]                           for (restart in restarts) {
[10:19:52.781]                             name <- restart$name
[10:19:52.781]                             if (is.null(name)) 
[10:19:52.781]                               next
[10:19:52.781]                             if (!grepl(pattern, name)) 
[10:19:52.781]                               next
[10:19:52.781]                             invokeRestart(restart)
[10:19:52.781]                             muffled <- TRUE
[10:19:52.781]                             break
[10:19:52.781]                           }
[10:19:52.781]                         }
[10:19:52.781]                       }
[10:19:52.781]                       invisible(muffled)
[10:19:52.781]                     }
[10:19:52.781]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.781]                   }
[10:19:52.781]                 }
[10:19:52.781]                 else {
[10:19:52.781]                   if (TRUE) {
[10:19:52.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.781]                     {
[10:19:52.781]                       inherits <- base::inherits
[10:19:52.781]                       invokeRestart <- base::invokeRestart
[10:19:52.781]                       is.null <- base::is.null
[10:19:52.781]                       muffled <- FALSE
[10:19:52.781]                       if (inherits(cond, "message")) {
[10:19:52.781]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.781]                         if (muffled) 
[10:19:52.781]                           invokeRestart("muffleMessage")
[10:19:52.781]                       }
[10:19:52.781]                       else if (inherits(cond, "warning")) {
[10:19:52.781]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.781]                         if (muffled) 
[10:19:52.781]                           invokeRestart("muffleWarning")
[10:19:52.781]                       }
[10:19:52.781]                       else if (inherits(cond, "condition")) {
[10:19:52.781]                         if (!is.null(pattern)) {
[10:19:52.781]                           computeRestarts <- base::computeRestarts
[10:19:52.781]                           grepl <- base::grepl
[10:19:52.781]                           restarts <- computeRestarts(cond)
[10:19:52.781]                           for (restart in restarts) {
[10:19:52.781]                             name <- restart$name
[10:19:52.781]                             if (is.null(name)) 
[10:19:52.781]                               next
[10:19:52.781]                             if (!grepl(pattern, name)) 
[10:19:52.781]                               next
[10:19:52.781]                             invokeRestart(restart)
[10:19:52.781]                             muffled <- TRUE
[10:19:52.781]                             break
[10:19:52.781]                           }
[10:19:52.781]                         }
[10:19:52.781]                       }
[10:19:52.781]                       invisible(muffled)
[10:19:52.781]                     }
[10:19:52.781]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.781]                   }
[10:19:52.781]                 }
[10:19:52.781]             }
[10:19:52.781]         }))
[10:19:52.781]     }, error = function(ex) {
[10:19:52.781]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.781]                 ...future.rng), started = ...future.startTime, 
[10:19:52.781]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.781]             version = "1.8"), class = "FutureResult")
[10:19:52.781]     }, finally = {
[10:19:52.781]         if (!identical(...future.workdir, getwd())) 
[10:19:52.781]             setwd(...future.workdir)
[10:19:52.781]         {
[10:19:52.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.781]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.781]             }
[10:19:52.781]             base::options(...future.oldOptions)
[10:19:52.781]             if (.Platform$OS.type == "windows") {
[10:19:52.781]                 old_names <- names(...future.oldEnvVars)
[10:19:52.781]                 envs <- base::Sys.getenv()
[10:19:52.781]                 names <- names(envs)
[10:19:52.781]                 common <- intersect(names, old_names)
[10:19:52.781]                 added <- setdiff(names, old_names)
[10:19:52.781]                 removed <- setdiff(old_names, names)
[10:19:52.781]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.781]                   envs[common]]
[10:19:52.781]                 NAMES <- toupper(changed)
[10:19:52.781]                 args <- list()
[10:19:52.781]                 for (kk in seq_along(NAMES)) {
[10:19:52.781]                   name <- changed[[kk]]
[10:19:52.781]                   NAME <- NAMES[[kk]]
[10:19:52.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.781]                     next
[10:19:52.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.781]                 }
[10:19:52.781]                 NAMES <- toupper(added)
[10:19:52.781]                 for (kk in seq_along(NAMES)) {
[10:19:52.781]                   name <- added[[kk]]
[10:19:52.781]                   NAME <- NAMES[[kk]]
[10:19:52.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.781]                     next
[10:19:52.781]                   args[[name]] <- ""
[10:19:52.781]                 }
[10:19:52.781]                 NAMES <- toupper(removed)
[10:19:52.781]                 for (kk in seq_along(NAMES)) {
[10:19:52.781]                   name <- removed[[kk]]
[10:19:52.781]                   NAME <- NAMES[[kk]]
[10:19:52.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.781]                     next
[10:19:52.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.781]                 }
[10:19:52.781]                 if (length(args) > 0) 
[10:19:52.781]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.781]             }
[10:19:52.781]             else {
[10:19:52.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.781]             }
[10:19:52.781]             {
[10:19:52.781]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.781]                   0L) {
[10:19:52.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.781]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.781]                   base::options(opts)
[10:19:52.781]                 }
[10:19:52.781]                 {
[10:19:52.781]                   {
[10:19:52.781]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.781]                     NULL
[10:19:52.781]                   }
[10:19:52.781]                   options(future.plan = NULL)
[10:19:52.781]                   if (is.na(NA_character_)) 
[10:19:52.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.781]                     .init = FALSE)
[10:19:52.781]                 }
[10:19:52.781]             }
[10:19:52.781]         }
[10:19:52.781]     })
[10:19:52.781]     if (TRUE) {
[10:19:52.781]         base::sink(type = "output", split = FALSE)
[10:19:52.781]         if (TRUE) {
[10:19:52.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.781]         }
[10:19:52.781]         else {
[10:19:52.781]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.781]         }
[10:19:52.781]         base::close(...future.stdout)
[10:19:52.781]         ...future.stdout <- NULL
[10:19:52.781]     }
[10:19:52.781]     ...future.result$conditions <- ...future.conditions
[10:19:52.781]     ...future.result$finished <- base::Sys.time()
[10:19:52.781]     ...future.result
[10:19:52.781] }
[10:19:52.784] assign_globals() ...
[10:19:52.784] List of 11
[10:19:52.784]  $ ...future.FUN            :function (x, ...)  
[10:19:52.784]  $ x_FUN                    :function (x)  
[10:19:52.784]  $ times                    : int 4
[10:19:52.784]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.784]  $ stop_if_not              :function (...)  
[10:19:52.784]  $ dim                      : int [1:2] 2 2
[10:19:52.784]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.784]  $ future.call.arguments    : list()
[10:19:52.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.784]  $ ...future.elements_ii    :List of 5
[10:19:52.784]   ..$ : int 1
[10:19:52.784]   ..$ : int 2
[10:19:52.784]   ..$ : int 3
[10:19:52.784]   ..$ : int 4
[10:19:52.784]   ..$ : int 5
[10:19:52.784]  $ ...future.seeds_ii       : NULL
[10:19:52.784]  $ ...future.globals.maxSize: NULL
[10:19:52.784]  - attr(*, "where")=List of 11
[10:19:52.784]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.784]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.784]  - attr(*, "resolved")= logi FALSE
[10:19:52.784]  - attr(*, "total_size")= num 29094
[10:19:52.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.784]  - attr(*, "already-done")= logi TRUE
[10:19:52.792] - copied ‘...future.FUN’ to environment
[10:19:52.792] - reassign environment for ‘x_FUN’
[10:19:52.792] - copied ‘x_FUN’ to environment
[10:19:52.793] - copied ‘times’ to environment
[10:19:52.793] - copied ‘stopf’ to environment
[10:19:52.793] - copied ‘stop_if_not’ to environment
[10:19:52.793] - copied ‘dim’ to environment
[10:19:52.793] - copied ‘valid_types’ to environment
[10:19:52.793] - copied ‘future.call.arguments’ to environment
[10:19:52.793] - copied ‘...future.elements_ii’ to environment
[10:19:52.793] - copied ‘...future.seeds_ii’ to environment
[10:19:52.793] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.793] assign_globals() ... done
[10:19:52.794] requestCore(): workers = 2
[10:19:52.796] MulticoreFuture started
[10:19:52.796] - Launch lazy future ... done
[10:19:52.796] run() for ‘MulticoreFuture’ ... done
[10:19:52.797] Created future:
[10:19:52.797] plan(): Setting new future strategy stack:
[10:19:52.797] List of future strategies:
[10:19:52.797] 1. sequential:
[10:19:52.797]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.797]    - tweaked: FALSE
[10:19:52.797]    - call: NULL
[10:19:52.798] plan(): nbrOfWorkers() = 1
[10:19:52.801] plan(): Setting new future strategy stack:
[10:19:52.801] List of future strategies:
[10:19:52.801] 1. multicore:
[10:19:52.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.801]    - tweaked: FALSE
[10:19:52.801]    - call: plan(strategy)
[10:19:52.804] plan(): nbrOfWorkers() = 2
[10:19:52.797] MulticoreFuture:
[10:19:52.797] Label: ‘future_vapply-1’
[10:19:52.797] Expression:
[10:19:52.797] {
[10:19:52.797]     do.call(function(...) {
[10:19:52.797]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.797]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.797]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.797]             on.exit(options(oopts), add = TRUE)
[10:19:52.797]         }
[10:19:52.797]         {
[10:19:52.797]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.797]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.797]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.797]             })
[10:19:52.797]         }
[10:19:52.797]     }, args = future.call.arguments)
[10:19:52.797] }
[10:19:52.797] Lazy evaluation: FALSE
[10:19:52.797] Asynchronous evaluation: TRUE
[10:19:52.797] Local evaluation: TRUE
[10:19:52.797] Environment: R_GlobalEnv
[10:19:52.797] Capture standard output: TRUE
[10:19:52.797] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.797] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.797] Packages: 1 packages (‘future.apply’)
[10:19:52.797] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.797] Resolved: TRUE
[10:19:52.797] Value: <not collected>
[10:19:52.797] Conditions captured: <none>
[10:19:52.797] Early signaling: FALSE
[10:19:52.797] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.797] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.805] Chunk #1 of 2 ... DONE
[10:19:52.805] Chunk #2 of 2 ...
[10:19:52.805]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.805] getGlobalsAndPackages() ...
[10:19:52.805] Searching for globals...
[10:19:52.806] 
[10:19:52.806] Searching for globals ... DONE
[10:19:52.806] - globals: [0] <none>
[10:19:52.806] getGlobalsAndPackages() ... DONE
[10:19:52.806]    + additional globals found: [n=0] 
[10:19:52.807]    + additional namespaces needed: [n=0] 
[10:19:52.807]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.807]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.807]  - seeds: <none>
[10:19:52.807]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.807] getGlobalsAndPackages() ...
[10:19:52.807] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.807] Resolving globals: FALSE
[10:19:52.808] Tweak future expression to call with '...' arguments ...
[10:19:52.808] {
[10:19:52.808]     do.call(function(...) {
[10:19:52.808]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.808]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.808]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.808]             on.exit(options(oopts), add = TRUE)
[10:19:52.808]         }
[10:19:52.808]         {
[10:19:52.808]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.808]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.808]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.808]             })
[10:19:52.808]         }
[10:19:52.808]     }, args = future.call.arguments)
[10:19:52.808] }
[10:19:52.808] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.813] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.813] - packages: [1] ‘future.apply’
[10:19:52.814] getGlobalsAndPackages() ... DONE
[10:19:52.815] run() for ‘Future’ ...
[10:19:52.815] - state: ‘created’
[10:19:52.816] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.819] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.820]   - Field: ‘label’
[10:19:52.820]   - Field: ‘local’
[10:19:52.821]   - Field: ‘owner’
[10:19:52.821]   - Field: ‘envir’
[10:19:52.821]   - Field: ‘workers’
[10:19:52.821]   - Field: ‘packages’
[10:19:52.821]   - Field: ‘gc’
[10:19:52.822]   - Field: ‘job’
[10:19:52.822]   - Field: ‘conditions’
[10:19:52.822]   - Field: ‘expr’
[10:19:52.822]   - Field: ‘uuid’
[10:19:52.823]   - Field: ‘seed’
[10:19:52.823]   - Field: ‘version’
[10:19:52.823]   - Field: ‘result’
[10:19:52.823]   - Field: ‘asynchronous’
[10:19:52.823]   - Field: ‘calls’
[10:19:52.824]   - Field: ‘globals’
[10:19:52.824]   - Field: ‘stdout’
[10:19:52.824]   - Field: ‘earlySignal’
[10:19:52.824]   - Field: ‘lazy’
[10:19:52.825]   - Field: ‘state’
[10:19:52.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.825] - Launch lazy future ...
[10:19:52.826] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:52.826] Packages needed by future strategies (n = 0): <none>
[10:19:52.827] {
[10:19:52.827]     {
[10:19:52.827]         {
[10:19:52.827]             ...future.startTime <- base::Sys.time()
[10:19:52.827]             {
[10:19:52.827]                 {
[10:19:52.827]                   {
[10:19:52.827]                     {
[10:19:52.827]                       {
[10:19:52.827]                         base::local({
[10:19:52.827]                           has_future <- base::requireNamespace("future", 
[10:19:52.827]                             quietly = TRUE)
[10:19:52.827]                           if (has_future) {
[10:19:52.827]                             ns <- base::getNamespace("future")
[10:19:52.827]                             version <- ns[[".package"]][["version"]]
[10:19:52.827]                             if (is.null(version)) 
[10:19:52.827]                               version <- utils::packageVersion("future")
[10:19:52.827]                           }
[10:19:52.827]                           else {
[10:19:52.827]                             version <- NULL
[10:19:52.827]                           }
[10:19:52.827]                           if (!has_future || version < "1.8.0") {
[10:19:52.827]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.827]                               "", base::R.version$version.string), 
[10:19:52.827]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.827]                                 base::R.version$platform, 8 * 
[10:19:52.827]                                   base::.Machine$sizeof.pointer), 
[10:19:52.827]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.827]                                 "release", "version")], collapse = " "), 
[10:19:52.827]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.827]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.827]                               info)
[10:19:52.827]                             info <- base::paste(info, collapse = "; ")
[10:19:52.827]                             if (!has_future) {
[10:19:52.827]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.827]                                 info)
[10:19:52.827]                             }
[10:19:52.827]                             else {
[10:19:52.827]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.827]                                 info, version)
[10:19:52.827]                             }
[10:19:52.827]                             base::stop(msg)
[10:19:52.827]                           }
[10:19:52.827]                         })
[10:19:52.827]                       }
[10:19:52.827]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.827]                       base::options(mc.cores = 1L)
[10:19:52.827]                     }
[10:19:52.827]                     base::local({
[10:19:52.827]                       for (pkg in "future.apply") {
[10:19:52.827]                         base::loadNamespace(pkg)
[10:19:52.827]                         base::library(pkg, character.only = TRUE)
[10:19:52.827]                       }
[10:19:52.827]                     })
[10:19:52.827]                   }
[10:19:52.827]                   ...future.strategy.old <- future::plan("list")
[10:19:52.827]                   options(future.plan = NULL)
[10:19:52.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.827]                 }
[10:19:52.827]                 ...future.workdir <- getwd()
[10:19:52.827]             }
[10:19:52.827]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.827]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.827]         }
[10:19:52.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.827]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.827]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.827]             base::names(...future.oldOptions))
[10:19:52.827]     }
[10:19:52.827]     if (FALSE) {
[10:19:52.827]     }
[10:19:52.827]     else {
[10:19:52.827]         if (TRUE) {
[10:19:52.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.827]                 open = "w")
[10:19:52.827]         }
[10:19:52.827]         else {
[10:19:52.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.827]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.827]         }
[10:19:52.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.827]             base::sink(type = "output", split = FALSE)
[10:19:52.827]             base::close(...future.stdout)
[10:19:52.827]         }, add = TRUE)
[10:19:52.827]     }
[10:19:52.827]     ...future.frame <- base::sys.nframe()
[10:19:52.827]     ...future.conditions <- base::list()
[10:19:52.827]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.827]     if (FALSE) {
[10:19:52.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.827]     }
[10:19:52.827]     ...future.result <- base::tryCatch({
[10:19:52.827]         base::withCallingHandlers({
[10:19:52.827]             ...future.value <- base::withVisible(base::local({
[10:19:52.827]                 withCallingHandlers({
[10:19:52.827]                   {
[10:19:52.827]                     do.call(function(...) {
[10:19:52.827]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.827]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.827]                         ...future.globals.maxSize)) {
[10:19:52.827]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.827]                         on.exit(options(oopts), add = TRUE)
[10:19:52.827]                       }
[10:19:52.827]                       {
[10:19:52.827]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.827]                           FUN = function(jj) {
[10:19:52.827]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.827]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.827]                           })
[10:19:52.827]                       }
[10:19:52.827]                     }, args = future.call.arguments)
[10:19:52.827]                   }
[10:19:52.827]                 }, immediateCondition = function(cond) {
[10:19:52.827]                   save_rds <- function (object, pathname, ...) 
[10:19:52.827]                   {
[10:19:52.827]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.827]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.827]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.827]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.827]                         fi_tmp[["mtime"]])
[10:19:52.827]                     }
[10:19:52.827]                     tryCatch({
[10:19:52.827]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.827]                     }, error = function(ex) {
[10:19:52.827]                       msg <- conditionMessage(ex)
[10:19:52.827]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.827]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.827]                         fi_tmp[["mtime"]], msg)
[10:19:52.827]                       ex$message <- msg
[10:19:52.827]                       stop(ex)
[10:19:52.827]                     })
[10:19:52.827]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.827]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.827]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.827]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.827]                       fi <- file.info(pathname)
[10:19:52.827]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.827]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.827]                         fi[["size"]], fi[["mtime"]])
[10:19:52.827]                       stop(msg)
[10:19:52.827]                     }
[10:19:52.827]                     invisible(pathname)
[10:19:52.827]                   }
[10:19:52.827]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.827]                     rootPath = tempdir()) 
[10:19:52.827]                   {
[10:19:52.827]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.827]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.827]                       tmpdir = path, fileext = ".rds")
[10:19:52.827]                     save_rds(obj, file)
[10:19:52.827]                   }
[10:19:52.827]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.827]                   {
[10:19:52.827]                     inherits <- base::inherits
[10:19:52.827]                     invokeRestart <- base::invokeRestart
[10:19:52.827]                     is.null <- base::is.null
[10:19:52.827]                     muffled <- FALSE
[10:19:52.827]                     if (inherits(cond, "message")) {
[10:19:52.827]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.827]                       if (muffled) 
[10:19:52.827]                         invokeRestart("muffleMessage")
[10:19:52.827]                     }
[10:19:52.827]                     else if (inherits(cond, "warning")) {
[10:19:52.827]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.827]                       if (muffled) 
[10:19:52.827]                         invokeRestart("muffleWarning")
[10:19:52.827]                     }
[10:19:52.827]                     else if (inherits(cond, "condition")) {
[10:19:52.827]                       if (!is.null(pattern)) {
[10:19:52.827]                         computeRestarts <- base::computeRestarts
[10:19:52.827]                         grepl <- base::grepl
[10:19:52.827]                         restarts <- computeRestarts(cond)
[10:19:52.827]                         for (restart in restarts) {
[10:19:52.827]                           name <- restart$name
[10:19:52.827]                           if (is.null(name)) 
[10:19:52.827]                             next
[10:19:52.827]                           if (!grepl(pattern, name)) 
[10:19:52.827]                             next
[10:19:52.827]                           invokeRestart(restart)
[10:19:52.827]                           muffled <- TRUE
[10:19:52.827]                           break
[10:19:52.827]                         }
[10:19:52.827]                       }
[10:19:52.827]                     }
[10:19:52.827]                     invisible(muffled)
[10:19:52.827]                   }
[10:19:52.827]                   muffleCondition(cond)
[10:19:52.827]                 })
[10:19:52.827]             }))
[10:19:52.827]             future::FutureResult(value = ...future.value$value, 
[10:19:52.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.827]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.827]                     ...future.globalenv.names))
[10:19:52.827]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.827]         }, condition = base::local({
[10:19:52.827]             c <- base::c
[10:19:52.827]             inherits <- base::inherits
[10:19:52.827]             invokeRestart <- base::invokeRestart
[10:19:52.827]             length <- base::length
[10:19:52.827]             list <- base::list
[10:19:52.827]             seq.int <- base::seq.int
[10:19:52.827]             signalCondition <- base::signalCondition
[10:19:52.827]             sys.calls <- base::sys.calls
[10:19:52.827]             `[[` <- base::`[[`
[10:19:52.827]             `+` <- base::`+`
[10:19:52.827]             `<<-` <- base::`<<-`
[10:19:52.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.827]                   3L)]
[10:19:52.827]             }
[10:19:52.827]             function(cond) {
[10:19:52.827]                 is_error <- inherits(cond, "error")
[10:19:52.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.827]                   NULL)
[10:19:52.827]                 if (is_error) {
[10:19:52.827]                   sessionInformation <- function() {
[10:19:52.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.827]                       search = base::search(), system = base::Sys.info())
[10:19:52.827]                   }
[10:19:52.827]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.827]                     cond$call), session = sessionInformation(), 
[10:19:52.827]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.827]                   signalCondition(cond)
[10:19:52.827]                 }
[10:19:52.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.827]                 "immediateCondition"))) {
[10:19:52.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.827]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.827]                   if (TRUE && !signal) {
[10:19:52.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.827]                     {
[10:19:52.827]                       inherits <- base::inherits
[10:19:52.827]                       invokeRestart <- base::invokeRestart
[10:19:52.827]                       is.null <- base::is.null
[10:19:52.827]                       muffled <- FALSE
[10:19:52.827]                       if (inherits(cond, "message")) {
[10:19:52.827]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.827]                         if (muffled) 
[10:19:52.827]                           invokeRestart("muffleMessage")
[10:19:52.827]                       }
[10:19:52.827]                       else if (inherits(cond, "warning")) {
[10:19:52.827]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.827]                         if (muffled) 
[10:19:52.827]                           invokeRestart("muffleWarning")
[10:19:52.827]                       }
[10:19:52.827]                       else if (inherits(cond, "condition")) {
[10:19:52.827]                         if (!is.null(pattern)) {
[10:19:52.827]                           computeRestarts <- base::computeRestarts
[10:19:52.827]                           grepl <- base::grepl
[10:19:52.827]                           restarts <- computeRestarts(cond)
[10:19:52.827]                           for (restart in restarts) {
[10:19:52.827]                             name <- restart$name
[10:19:52.827]                             if (is.null(name)) 
[10:19:52.827]                               next
[10:19:52.827]                             if (!grepl(pattern, name)) 
[10:19:52.827]                               next
[10:19:52.827]                             invokeRestart(restart)
[10:19:52.827]                             muffled <- TRUE
[10:19:52.827]                             break
[10:19:52.827]                           }
[10:19:52.827]                         }
[10:19:52.827]                       }
[10:19:52.827]                       invisible(muffled)
[10:19:52.827]                     }
[10:19:52.827]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.827]                   }
[10:19:52.827]                 }
[10:19:52.827]                 else {
[10:19:52.827]                   if (TRUE) {
[10:19:52.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.827]                     {
[10:19:52.827]                       inherits <- base::inherits
[10:19:52.827]                       invokeRestart <- base::invokeRestart
[10:19:52.827]                       is.null <- base::is.null
[10:19:52.827]                       muffled <- FALSE
[10:19:52.827]                       if (inherits(cond, "message")) {
[10:19:52.827]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.827]                         if (muffled) 
[10:19:52.827]                           invokeRestart("muffleMessage")
[10:19:52.827]                       }
[10:19:52.827]                       else if (inherits(cond, "warning")) {
[10:19:52.827]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.827]                         if (muffled) 
[10:19:52.827]                           invokeRestart("muffleWarning")
[10:19:52.827]                       }
[10:19:52.827]                       else if (inherits(cond, "condition")) {
[10:19:52.827]                         if (!is.null(pattern)) {
[10:19:52.827]                           computeRestarts <- base::computeRestarts
[10:19:52.827]                           grepl <- base::grepl
[10:19:52.827]                           restarts <- computeRestarts(cond)
[10:19:52.827]                           for (restart in restarts) {
[10:19:52.827]                             name <- restart$name
[10:19:52.827]                             if (is.null(name)) 
[10:19:52.827]                               next
[10:19:52.827]                             if (!grepl(pattern, name)) 
[10:19:52.827]                               next
[10:19:52.827]                             invokeRestart(restart)
[10:19:52.827]                             muffled <- TRUE
[10:19:52.827]                             break
[10:19:52.827]                           }
[10:19:52.827]                         }
[10:19:52.827]                       }
[10:19:52.827]                       invisible(muffled)
[10:19:52.827]                     }
[10:19:52.827]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.827]                   }
[10:19:52.827]                 }
[10:19:52.827]             }
[10:19:52.827]         }))
[10:19:52.827]     }, error = function(ex) {
[10:19:52.827]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.827]                 ...future.rng), started = ...future.startTime, 
[10:19:52.827]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.827]             version = "1.8"), class = "FutureResult")
[10:19:52.827]     }, finally = {
[10:19:52.827]         if (!identical(...future.workdir, getwd())) 
[10:19:52.827]             setwd(...future.workdir)
[10:19:52.827]         {
[10:19:52.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.827]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.827]             }
[10:19:52.827]             base::options(...future.oldOptions)
[10:19:52.827]             if (.Platform$OS.type == "windows") {
[10:19:52.827]                 old_names <- names(...future.oldEnvVars)
[10:19:52.827]                 envs <- base::Sys.getenv()
[10:19:52.827]                 names <- names(envs)
[10:19:52.827]                 common <- intersect(names, old_names)
[10:19:52.827]                 added <- setdiff(names, old_names)
[10:19:52.827]                 removed <- setdiff(old_names, names)
[10:19:52.827]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.827]                   envs[common]]
[10:19:52.827]                 NAMES <- toupper(changed)
[10:19:52.827]                 args <- list()
[10:19:52.827]                 for (kk in seq_along(NAMES)) {
[10:19:52.827]                   name <- changed[[kk]]
[10:19:52.827]                   NAME <- NAMES[[kk]]
[10:19:52.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.827]                     next
[10:19:52.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.827]                 }
[10:19:52.827]                 NAMES <- toupper(added)
[10:19:52.827]                 for (kk in seq_along(NAMES)) {
[10:19:52.827]                   name <- added[[kk]]
[10:19:52.827]                   NAME <- NAMES[[kk]]
[10:19:52.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.827]                     next
[10:19:52.827]                   args[[name]] <- ""
[10:19:52.827]                 }
[10:19:52.827]                 NAMES <- toupper(removed)
[10:19:52.827]                 for (kk in seq_along(NAMES)) {
[10:19:52.827]                   name <- removed[[kk]]
[10:19:52.827]                   NAME <- NAMES[[kk]]
[10:19:52.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.827]                     next
[10:19:52.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.827]                 }
[10:19:52.827]                 if (length(args) > 0) 
[10:19:52.827]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.827]             }
[10:19:52.827]             else {
[10:19:52.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.827]             }
[10:19:52.827]             {
[10:19:52.827]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.827]                   0L) {
[10:19:52.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.827]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.827]                   base::options(opts)
[10:19:52.827]                 }
[10:19:52.827]                 {
[10:19:52.827]                   {
[10:19:52.827]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.827]                     NULL
[10:19:52.827]                   }
[10:19:52.827]                   options(future.plan = NULL)
[10:19:52.827]                   if (is.na(NA_character_)) 
[10:19:52.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.827]                     .init = FALSE)
[10:19:52.827]                 }
[10:19:52.827]             }
[10:19:52.827]         }
[10:19:52.827]     })
[10:19:52.827]     if (TRUE) {
[10:19:52.827]         base::sink(type = "output", split = FALSE)
[10:19:52.827]         if (TRUE) {
[10:19:52.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.827]         }
[10:19:52.827]         else {
[10:19:52.827]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.827]         }
[10:19:52.827]         base::close(...future.stdout)
[10:19:52.827]         ...future.stdout <- NULL
[10:19:52.827]     }
[10:19:52.827]     ...future.result$conditions <- ...future.conditions
[10:19:52.827]     ...future.result$finished <- base::Sys.time()
[10:19:52.827]     ...future.result
[10:19:52.827] }
[10:19:52.830] assign_globals() ...
[10:19:52.830] List of 11
[10:19:52.830]  $ ...future.FUN            :function (x, ...)  
[10:19:52.830]  $ x_FUN                    :function (x)  
[10:19:52.830]  $ times                    : int 4
[10:19:52.830]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.830]  $ stop_if_not              :function (...)  
[10:19:52.830]  $ dim                      : int [1:2] 2 2
[10:19:52.830]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.830]  $ future.call.arguments    : list()
[10:19:52.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.830]  $ ...future.elements_ii    :List of 5
[10:19:52.830]   ..$ : int 6
[10:19:52.830]   ..$ : int 7
[10:19:52.830]   ..$ : int 8
[10:19:52.830]   ..$ : int 9
[10:19:52.830]   ..$ : int 10
[10:19:52.830]  $ ...future.seeds_ii       : NULL
[10:19:52.830]  $ ...future.globals.maxSize: NULL
[10:19:52.830]  - attr(*, "where")=List of 11
[10:19:52.830]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.830]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.830]  - attr(*, "resolved")= logi FALSE
[10:19:52.830]  - attr(*, "total_size")= num 29094
[10:19:52.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.830]  - attr(*, "already-done")= logi TRUE
[10:19:52.841] - copied ‘...future.FUN’ to environment
[10:19:52.841] - reassign environment for ‘x_FUN’
[10:19:52.841] - copied ‘x_FUN’ to environment
[10:19:52.841] - copied ‘times’ to environment
[10:19:52.842] - copied ‘stopf’ to environment
[10:19:52.842] - copied ‘stop_if_not’ to environment
[10:19:52.842] - copied ‘dim’ to environment
[10:19:52.842] - copied ‘valid_types’ to environment
[10:19:52.842] - copied ‘future.call.arguments’ to environment
[10:19:52.842] - copied ‘...future.elements_ii’ to environment
[10:19:52.842] - copied ‘...future.seeds_ii’ to environment
[10:19:52.842] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.842] assign_globals() ... done
[10:19:52.842] requestCore(): workers = 2
[10:19:52.845] MulticoreFuture started
[10:19:52.845] - Launch lazy future ... done
[10:19:52.845] run() for ‘MulticoreFuture’ ... done
[10:19:52.846] Created future:
[10:19:52.846] plan(): Setting new future strategy stack:
[10:19:52.847] List of future strategies:
[10:19:52.847] 1. sequential:
[10:19:52.847]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.847]    - tweaked: FALSE
[10:19:52.847]    - call: NULL
[10:19:52.847] plan(): nbrOfWorkers() = 1
[10:19:52.850] plan(): Setting new future strategy stack:
[10:19:52.850] List of future strategies:
[10:19:52.850] 1. multicore:
[10:19:52.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.850]    - tweaked: FALSE
[10:19:52.850]    - call: plan(strategy)
[10:19:52.857] plan(): nbrOfWorkers() = 2
[10:19:52.846] MulticoreFuture:
[10:19:52.846] Label: ‘future_vapply-2’
[10:19:52.846] Expression:
[10:19:52.846] {
[10:19:52.846]     do.call(function(...) {
[10:19:52.846]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.846]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.846]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.846]             on.exit(options(oopts), add = TRUE)
[10:19:52.846]         }
[10:19:52.846]         {
[10:19:52.846]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.846]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.846]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.846]             })
[10:19:52.846]         }
[10:19:52.846]     }, args = future.call.arguments)
[10:19:52.846] }
[10:19:52.846] Lazy evaluation: FALSE
[10:19:52.846] Asynchronous evaluation: TRUE
[10:19:52.846] Local evaluation: TRUE
[10:19:52.846] Environment: R_GlobalEnv
[10:19:52.846] Capture standard output: TRUE
[10:19:52.846] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.846] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.846] Packages: 1 packages (‘future.apply’)
[10:19:52.846] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.846] Resolved: TRUE
[10:19:52.846] Value: <not collected>
[10:19:52.846] Conditions captured: <none>
[10:19:52.846] Early signaling: FALSE
[10:19:52.846] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.846] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.858] Chunk #2 of 2 ... DONE
[10:19:52.858] Launching 2 futures (chunks) ... DONE
[10:19:52.859] Resolving 2 futures (chunks) ...
[10:19:52.859] resolve() on list ...
[10:19:52.859]  recursive: 0
[10:19:52.859]  length: 2
[10:19:52.859] 
[10:19:52.860] Future #1
[10:19:52.860] result() for MulticoreFuture ...
[10:19:52.861] result() for MulticoreFuture ...
[10:19:52.861] result() for MulticoreFuture ... done
[10:19:52.861] result() for MulticoreFuture ... done
[10:19:52.863] result() for MulticoreFuture ...
[10:19:52.864] result() for MulticoreFuture ... done
[10:19:52.864] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.865] - nx: 2
[10:19:52.865] - relay: TRUE
[10:19:52.865] - stdout: TRUE
[10:19:52.865] - signal: TRUE
[10:19:52.866] - resignal: FALSE
[10:19:52.866] - force: TRUE
[10:19:52.866] - relayed: [n=2] FALSE, FALSE
[10:19:52.867] - queued futures: [n=2] FALSE, FALSE
[10:19:52.867]  - until=1
[10:19:52.867]  - relaying element #1
[10:19:52.867] result() for MulticoreFuture ...
[10:19:52.868] result() for MulticoreFuture ... done
[10:19:52.868] result() for MulticoreFuture ...
[10:19:52.868] result() for MulticoreFuture ... done
[10:19:52.869] result() for MulticoreFuture ...
[10:19:52.869] result() for MulticoreFuture ... done
[10:19:52.869] result() for MulticoreFuture ...
[10:19:52.869] result() for MulticoreFuture ... done
[10:19:52.870] - relayed: [n=2] TRUE, FALSE
[10:19:52.870] - queued futures: [n=2] TRUE, FALSE
[10:19:52.870] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.870]  length: 1 (resolved future 1)
[10:19:52.871] Future #2
[10:19:52.871] result() for MulticoreFuture ...
[10:19:52.872] result() for MulticoreFuture ...
[10:19:52.872] result() for MulticoreFuture ... done
[10:19:52.873] result() for MulticoreFuture ... done
[10:19:52.873] result() for MulticoreFuture ...
[10:19:52.873] result() for MulticoreFuture ... done
[10:19:52.873] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.874] - nx: 2
[10:19:52.874] - relay: TRUE
[10:19:52.874] - stdout: TRUE
[10:19:52.874] - signal: TRUE
[10:19:52.874] - resignal: FALSE
[10:19:52.874] - force: TRUE
[10:19:52.875] - relayed: [n=2] TRUE, FALSE
[10:19:52.875] - queued futures: [n=2] TRUE, FALSE
[10:19:52.875]  - until=2
[10:19:52.875]  - relaying element #2
[10:19:52.875] result() for MulticoreFuture ...
[10:19:52.875] result() for MulticoreFuture ... done
[10:19:52.876] result() for MulticoreFuture ...
[10:19:52.876] result() for MulticoreFuture ... done
[10:19:52.876] result() for MulticoreFuture ...
[10:19:52.876] result() for MulticoreFuture ... done
[10:19:52.876] result() for MulticoreFuture ...
[10:19:52.876] result() for MulticoreFuture ... done
[10:19:52.876] - relayed: [n=2] TRUE, TRUE
[10:19:52.876] - queued futures: [n=2] TRUE, TRUE
[10:19:52.877] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.877]  length: 0 (resolved future 2)
[10:19:52.877] Relaying remaining futures
[10:19:52.877] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.877] - nx: 2
[10:19:52.877] - relay: TRUE
[10:19:52.877] - stdout: TRUE
[10:19:52.877] - signal: TRUE
[10:19:52.877] - resignal: FALSE
[10:19:52.877] - force: TRUE
[10:19:52.878] - relayed: [n=2] TRUE, TRUE
[10:19:52.878] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:52.878] - relayed: [n=2] TRUE, TRUE
[10:19:52.878] - queued futures: [n=2] TRUE, TRUE
[10:19:52.878] signalConditionsASAP(NULL, pos=0) ... done
[10:19:52.878] resolve() on list ... DONE
[10:19:52.878] result() for MulticoreFuture ...
[10:19:52.878] result() for MulticoreFuture ... done
[10:19:52.879] result() for MulticoreFuture ...
[10:19:52.879] result() for MulticoreFuture ... done
[10:19:52.879] result() for MulticoreFuture ...
[10:19:52.879] result() for MulticoreFuture ... done
[10:19:52.879] result() for MulticoreFuture ...
[10:19:52.879] result() for MulticoreFuture ... done
[10:19:52.879]  - Number of value chunks collected: 2
[10:19:52.879] Resolving 2 futures (chunks) ... DONE
[10:19:52.879] Reducing values from 2 chunks ...
[10:19:52.879]  - Number of values collected after concatenation: 10
[10:19:52.880]  - Number of values expected: 10
[10:19:52.880] Reducing values from 2 chunks ... DONE
[10:19:52.880] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:19:52.883] future_lapply() ...
[10:19:52.886] Number of chunks: 2
[10:19:52.886] getGlobalsAndPackagesXApply() ...
[10:19:52.887]  - future.globals: TRUE
[10:19:52.887] getGlobalsAndPackages() ...
[10:19:52.887] Searching for globals...
[10:19:52.890] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:19:52.891] Searching for globals ... DONE
[10:19:52.891] Resolving globals: FALSE
[10:19:52.891] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[10:19:52.892] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:52.894] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.894] - packages: [2] ‘stats’, ‘future.apply’
[10:19:52.894] getGlobalsAndPackages() ... DONE
[10:19:52.894]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:52.894]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:19:52.894] Finding globals ... DONE
[10:19:52.895]  - use_args: TRUE
[10:19:52.895]  - Getting '...' globals ...
[10:19:52.895] resolve() on list ...
[10:19:52.895]  recursive: 0
[10:19:52.895]  length: 1
[10:19:52.895]  elements: ‘...’
[10:19:52.895]  length: 0 (resolved future 1)
[10:19:52.896] resolve() on list ... DONE
[10:19:52.896]    - '...' content: [n=0] 
[10:19:52.896] List of 1
[10:19:52.896]  $ ...: list()
[10:19:52.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.896]  - attr(*, "where")=List of 1
[10:19:52.896]   ..$ ...:<environment: 0x55c69e028620> 
[10:19:52.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.896]  - attr(*, "resolved")= logi TRUE
[10:19:52.896]  - attr(*, "total_size")= num NA
[10:19:52.898]  - Getting '...' globals ... DONE
[10:19:52.899] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:52.899] List of 8
[10:19:52.899]  $ ...future.FUN:function (x, ...)  
[10:19:52.899]  $ x_FUN        :function (x, ...)  
[10:19:52.899]  $ times        : int 5
[10:19:52.899]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.899]  $ stop_if_not  :function (...)  
[10:19:52.899]  $ dim          : NULL
[10:19:52.899]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:52.899]  $ ...          : list()
[10:19:52.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.899]  - attr(*, "where")=List of 8
[10:19:52.899]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:52.899]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:52.899]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:52.899]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:52.899]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:52.899]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:52.899]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:52.899]   ..$ ...          :<environment: 0x55c69e028620> 
[10:19:52.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.899]  - attr(*, "resolved")= logi FALSE
[10:19:52.899]  - attr(*, "total_size")= num 24127
[10:19:52.904] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:19:52.904] getGlobalsAndPackagesXApply() ... DONE
[10:19:52.904] Number of futures (= number of chunks): 2
[10:19:52.905] Launching 2 futures (chunks) ...
[10:19:52.905] Chunk #1 of 2 ...
[10:19:52.905]  - Finding globals in 'X' for chunk #1 ...
[10:19:52.905] getGlobalsAndPackages() ...
[10:19:52.905] Searching for globals...
[10:19:52.905] 
[10:19:52.905] Searching for globals ... DONE
[10:19:52.905] - globals: [0] <none>
[10:19:52.905] getGlobalsAndPackages() ... DONE
[10:19:52.906]    + additional globals found: [n=0] 
[10:19:52.906]    + additional namespaces needed: [n=0] 
[10:19:52.906]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:52.906]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.906]  - seeds: <none>
[10:19:52.906]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.906] getGlobalsAndPackages() ...
[10:19:52.906] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.906] Resolving globals: FALSE
[10:19:52.906] Tweak future expression to call with '...' arguments ...
[10:19:52.907] {
[10:19:52.907]     do.call(function(...) {
[10:19:52.907]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.907]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.907]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.907]             on.exit(options(oopts), add = TRUE)
[10:19:52.907]         }
[10:19:52.907]         {
[10:19:52.907]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.907]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.907]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.907]             })
[10:19:52.907]         }
[10:19:52.907]     }, args = future.call.arguments)
[10:19:52.907] }
[10:19:52.907] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.907] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.907] - packages: [2] ‘stats’, ‘future.apply’
[10:19:52.907] getGlobalsAndPackages() ... DONE
[10:19:52.908] run() for ‘Future’ ...
[10:19:52.908] - state: ‘created’
[10:19:52.908] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.910]   - Field: ‘label’
[10:19:52.910]   - Field: ‘local’
[10:19:52.910]   - Field: ‘owner’
[10:19:52.910]   - Field: ‘envir’
[10:19:52.910]   - Field: ‘workers’
[10:19:52.910]   - Field: ‘packages’
[10:19:52.910]   - Field: ‘gc’
[10:19:52.911]   - Field: ‘job’
[10:19:52.911]   - Field: ‘conditions’
[10:19:52.911]   - Field: ‘expr’
[10:19:52.911]   - Field: ‘uuid’
[10:19:52.911]   - Field: ‘seed’
[10:19:52.911]   - Field: ‘version’
[10:19:52.911]   - Field: ‘result’
[10:19:52.911]   - Field: ‘asynchronous’
[10:19:52.911]   - Field: ‘calls’
[10:19:52.911]   - Field: ‘globals’
[10:19:52.911]   - Field: ‘stdout’
[10:19:52.911]   - Field: ‘earlySignal’
[10:19:52.912]   - Field: ‘lazy’
[10:19:52.912]   - Field: ‘state’
[10:19:52.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.912] - Launch lazy future ...
[10:19:52.912] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:52.912] Packages needed by future strategies (n = 0): <none>
[10:19:52.913] {
[10:19:52.913]     {
[10:19:52.913]         {
[10:19:52.913]             ...future.startTime <- base::Sys.time()
[10:19:52.913]             {
[10:19:52.913]                 {
[10:19:52.913]                   {
[10:19:52.913]                     {
[10:19:52.913]                       {
[10:19:52.913]                         base::local({
[10:19:52.913]                           has_future <- base::requireNamespace("future", 
[10:19:52.913]                             quietly = TRUE)
[10:19:52.913]                           if (has_future) {
[10:19:52.913]                             ns <- base::getNamespace("future")
[10:19:52.913]                             version <- ns[[".package"]][["version"]]
[10:19:52.913]                             if (is.null(version)) 
[10:19:52.913]                               version <- utils::packageVersion("future")
[10:19:52.913]                           }
[10:19:52.913]                           else {
[10:19:52.913]                             version <- NULL
[10:19:52.913]                           }
[10:19:52.913]                           if (!has_future || version < "1.8.0") {
[10:19:52.913]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.913]                               "", base::R.version$version.string), 
[10:19:52.913]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.913]                                 base::R.version$platform, 8 * 
[10:19:52.913]                                   base::.Machine$sizeof.pointer), 
[10:19:52.913]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.913]                                 "release", "version")], collapse = " "), 
[10:19:52.913]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.913]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.913]                               info)
[10:19:52.913]                             info <- base::paste(info, collapse = "; ")
[10:19:52.913]                             if (!has_future) {
[10:19:52.913]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.913]                                 info)
[10:19:52.913]                             }
[10:19:52.913]                             else {
[10:19:52.913]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.913]                                 info, version)
[10:19:52.913]                             }
[10:19:52.913]                             base::stop(msg)
[10:19:52.913]                           }
[10:19:52.913]                         })
[10:19:52.913]                       }
[10:19:52.913]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.913]                       base::options(mc.cores = 1L)
[10:19:52.913]                     }
[10:19:52.913]                     base::local({
[10:19:52.913]                       for (pkg in c("stats", "future.apply")) {
[10:19:52.913]                         base::loadNamespace(pkg)
[10:19:52.913]                         base::library(pkg, character.only = TRUE)
[10:19:52.913]                       }
[10:19:52.913]                     })
[10:19:52.913]                   }
[10:19:52.913]                   ...future.strategy.old <- future::plan("list")
[10:19:52.913]                   options(future.plan = NULL)
[10:19:52.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.913]                 }
[10:19:52.913]                 ...future.workdir <- getwd()
[10:19:52.913]             }
[10:19:52.913]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.913]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.913]         }
[10:19:52.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.913]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.913]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.913]             base::names(...future.oldOptions))
[10:19:52.913]     }
[10:19:52.913]     if (FALSE) {
[10:19:52.913]     }
[10:19:52.913]     else {
[10:19:52.913]         if (TRUE) {
[10:19:52.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.913]                 open = "w")
[10:19:52.913]         }
[10:19:52.913]         else {
[10:19:52.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.913]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.913]         }
[10:19:52.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.913]             base::sink(type = "output", split = FALSE)
[10:19:52.913]             base::close(...future.stdout)
[10:19:52.913]         }, add = TRUE)
[10:19:52.913]     }
[10:19:52.913]     ...future.frame <- base::sys.nframe()
[10:19:52.913]     ...future.conditions <- base::list()
[10:19:52.913]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.913]     if (FALSE) {
[10:19:52.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.913]     }
[10:19:52.913]     ...future.result <- base::tryCatch({
[10:19:52.913]         base::withCallingHandlers({
[10:19:52.913]             ...future.value <- base::withVisible(base::local({
[10:19:52.913]                 withCallingHandlers({
[10:19:52.913]                   {
[10:19:52.913]                     do.call(function(...) {
[10:19:52.913]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.913]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.913]                         ...future.globals.maxSize)) {
[10:19:52.913]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.913]                         on.exit(options(oopts), add = TRUE)
[10:19:52.913]                       }
[10:19:52.913]                       {
[10:19:52.913]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.913]                           FUN = function(jj) {
[10:19:52.913]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.913]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.913]                           })
[10:19:52.913]                       }
[10:19:52.913]                     }, args = future.call.arguments)
[10:19:52.913]                   }
[10:19:52.913]                 }, immediateCondition = function(cond) {
[10:19:52.913]                   save_rds <- function (object, pathname, ...) 
[10:19:52.913]                   {
[10:19:52.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.913]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.913]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.913]                         fi_tmp[["mtime"]])
[10:19:52.913]                     }
[10:19:52.913]                     tryCatch({
[10:19:52.913]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.913]                     }, error = function(ex) {
[10:19:52.913]                       msg <- conditionMessage(ex)
[10:19:52.913]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.913]                         fi_tmp[["mtime"]], msg)
[10:19:52.913]                       ex$message <- msg
[10:19:52.913]                       stop(ex)
[10:19:52.913]                     })
[10:19:52.913]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.913]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.913]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.913]                       fi <- file.info(pathname)
[10:19:52.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.913]                         fi[["size"]], fi[["mtime"]])
[10:19:52.913]                       stop(msg)
[10:19:52.913]                     }
[10:19:52.913]                     invisible(pathname)
[10:19:52.913]                   }
[10:19:52.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.913]                     rootPath = tempdir()) 
[10:19:52.913]                   {
[10:19:52.913]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.913]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.913]                       tmpdir = path, fileext = ".rds")
[10:19:52.913]                     save_rds(obj, file)
[10:19:52.913]                   }
[10:19:52.913]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.913]                   {
[10:19:52.913]                     inherits <- base::inherits
[10:19:52.913]                     invokeRestart <- base::invokeRestart
[10:19:52.913]                     is.null <- base::is.null
[10:19:52.913]                     muffled <- FALSE
[10:19:52.913]                     if (inherits(cond, "message")) {
[10:19:52.913]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.913]                       if (muffled) 
[10:19:52.913]                         invokeRestart("muffleMessage")
[10:19:52.913]                     }
[10:19:52.913]                     else if (inherits(cond, "warning")) {
[10:19:52.913]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.913]                       if (muffled) 
[10:19:52.913]                         invokeRestart("muffleWarning")
[10:19:52.913]                     }
[10:19:52.913]                     else if (inherits(cond, "condition")) {
[10:19:52.913]                       if (!is.null(pattern)) {
[10:19:52.913]                         computeRestarts <- base::computeRestarts
[10:19:52.913]                         grepl <- base::grepl
[10:19:52.913]                         restarts <- computeRestarts(cond)
[10:19:52.913]                         for (restart in restarts) {
[10:19:52.913]                           name <- restart$name
[10:19:52.913]                           if (is.null(name)) 
[10:19:52.913]                             next
[10:19:52.913]                           if (!grepl(pattern, name)) 
[10:19:52.913]                             next
[10:19:52.913]                           invokeRestart(restart)
[10:19:52.913]                           muffled <- TRUE
[10:19:52.913]                           break
[10:19:52.913]                         }
[10:19:52.913]                       }
[10:19:52.913]                     }
[10:19:52.913]                     invisible(muffled)
[10:19:52.913]                   }
[10:19:52.913]                   muffleCondition(cond)
[10:19:52.913]                 })
[10:19:52.913]             }))
[10:19:52.913]             future::FutureResult(value = ...future.value$value, 
[10:19:52.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.913]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.913]                     ...future.globalenv.names))
[10:19:52.913]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.913]         }, condition = base::local({
[10:19:52.913]             c <- base::c
[10:19:52.913]             inherits <- base::inherits
[10:19:52.913]             invokeRestart <- base::invokeRestart
[10:19:52.913]             length <- base::length
[10:19:52.913]             list <- base::list
[10:19:52.913]             seq.int <- base::seq.int
[10:19:52.913]             signalCondition <- base::signalCondition
[10:19:52.913]             sys.calls <- base::sys.calls
[10:19:52.913]             `[[` <- base::`[[`
[10:19:52.913]             `+` <- base::`+`
[10:19:52.913]             `<<-` <- base::`<<-`
[10:19:52.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.913]                   3L)]
[10:19:52.913]             }
[10:19:52.913]             function(cond) {
[10:19:52.913]                 is_error <- inherits(cond, "error")
[10:19:52.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.913]                   NULL)
[10:19:52.913]                 if (is_error) {
[10:19:52.913]                   sessionInformation <- function() {
[10:19:52.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.913]                       search = base::search(), system = base::Sys.info())
[10:19:52.913]                   }
[10:19:52.913]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.913]                     cond$call), session = sessionInformation(), 
[10:19:52.913]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.913]                   signalCondition(cond)
[10:19:52.913]                 }
[10:19:52.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.913]                 "immediateCondition"))) {
[10:19:52.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.913]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.913]                   if (TRUE && !signal) {
[10:19:52.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.913]                     {
[10:19:52.913]                       inherits <- base::inherits
[10:19:52.913]                       invokeRestart <- base::invokeRestart
[10:19:52.913]                       is.null <- base::is.null
[10:19:52.913]                       muffled <- FALSE
[10:19:52.913]                       if (inherits(cond, "message")) {
[10:19:52.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.913]                         if (muffled) 
[10:19:52.913]                           invokeRestart("muffleMessage")
[10:19:52.913]                       }
[10:19:52.913]                       else if (inherits(cond, "warning")) {
[10:19:52.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.913]                         if (muffled) 
[10:19:52.913]                           invokeRestart("muffleWarning")
[10:19:52.913]                       }
[10:19:52.913]                       else if (inherits(cond, "condition")) {
[10:19:52.913]                         if (!is.null(pattern)) {
[10:19:52.913]                           computeRestarts <- base::computeRestarts
[10:19:52.913]                           grepl <- base::grepl
[10:19:52.913]                           restarts <- computeRestarts(cond)
[10:19:52.913]                           for (restart in restarts) {
[10:19:52.913]                             name <- restart$name
[10:19:52.913]                             if (is.null(name)) 
[10:19:52.913]                               next
[10:19:52.913]                             if (!grepl(pattern, name)) 
[10:19:52.913]                               next
[10:19:52.913]                             invokeRestart(restart)
[10:19:52.913]                             muffled <- TRUE
[10:19:52.913]                             break
[10:19:52.913]                           }
[10:19:52.913]                         }
[10:19:52.913]                       }
[10:19:52.913]                       invisible(muffled)
[10:19:52.913]                     }
[10:19:52.913]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.913]                   }
[10:19:52.913]                 }
[10:19:52.913]                 else {
[10:19:52.913]                   if (TRUE) {
[10:19:52.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.913]                     {
[10:19:52.913]                       inherits <- base::inherits
[10:19:52.913]                       invokeRestart <- base::invokeRestart
[10:19:52.913]                       is.null <- base::is.null
[10:19:52.913]                       muffled <- FALSE
[10:19:52.913]                       if (inherits(cond, "message")) {
[10:19:52.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.913]                         if (muffled) 
[10:19:52.913]                           invokeRestart("muffleMessage")
[10:19:52.913]                       }
[10:19:52.913]                       else if (inherits(cond, "warning")) {
[10:19:52.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.913]                         if (muffled) 
[10:19:52.913]                           invokeRestart("muffleWarning")
[10:19:52.913]                       }
[10:19:52.913]                       else if (inherits(cond, "condition")) {
[10:19:52.913]                         if (!is.null(pattern)) {
[10:19:52.913]                           computeRestarts <- base::computeRestarts
[10:19:52.913]                           grepl <- base::grepl
[10:19:52.913]                           restarts <- computeRestarts(cond)
[10:19:52.913]                           for (restart in restarts) {
[10:19:52.913]                             name <- restart$name
[10:19:52.913]                             if (is.null(name)) 
[10:19:52.913]                               next
[10:19:52.913]                             if (!grepl(pattern, name)) 
[10:19:52.913]                               next
[10:19:52.913]                             invokeRestart(restart)
[10:19:52.913]                             muffled <- TRUE
[10:19:52.913]                             break
[10:19:52.913]                           }
[10:19:52.913]                         }
[10:19:52.913]                       }
[10:19:52.913]                       invisible(muffled)
[10:19:52.913]                     }
[10:19:52.913]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.913]                   }
[10:19:52.913]                 }
[10:19:52.913]             }
[10:19:52.913]         }))
[10:19:52.913]     }, error = function(ex) {
[10:19:52.913]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.913]                 ...future.rng), started = ...future.startTime, 
[10:19:52.913]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.913]             version = "1.8"), class = "FutureResult")
[10:19:52.913]     }, finally = {
[10:19:52.913]         if (!identical(...future.workdir, getwd())) 
[10:19:52.913]             setwd(...future.workdir)
[10:19:52.913]         {
[10:19:52.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.913]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.913]             }
[10:19:52.913]             base::options(...future.oldOptions)
[10:19:52.913]             if (.Platform$OS.type == "windows") {
[10:19:52.913]                 old_names <- names(...future.oldEnvVars)
[10:19:52.913]                 envs <- base::Sys.getenv()
[10:19:52.913]                 names <- names(envs)
[10:19:52.913]                 common <- intersect(names, old_names)
[10:19:52.913]                 added <- setdiff(names, old_names)
[10:19:52.913]                 removed <- setdiff(old_names, names)
[10:19:52.913]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.913]                   envs[common]]
[10:19:52.913]                 NAMES <- toupper(changed)
[10:19:52.913]                 args <- list()
[10:19:52.913]                 for (kk in seq_along(NAMES)) {
[10:19:52.913]                   name <- changed[[kk]]
[10:19:52.913]                   NAME <- NAMES[[kk]]
[10:19:52.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.913]                     next
[10:19:52.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.913]                 }
[10:19:52.913]                 NAMES <- toupper(added)
[10:19:52.913]                 for (kk in seq_along(NAMES)) {
[10:19:52.913]                   name <- added[[kk]]
[10:19:52.913]                   NAME <- NAMES[[kk]]
[10:19:52.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.913]                     next
[10:19:52.913]                   args[[name]] <- ""
[10:19:52.913]                 }
[10:19:52.913]                 NAMES <- toupper(removed)
[10:19:52.913]                 for (kk in seq_along(NAMES)) {
[10:19:52.913]                   name <- removed[[kk]]
[10:19:52.913]                   NAME <- NAMES[[kk]]
[10:19:52.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.913]                     next
[10:19:52.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.913]                 }
[10:19:52.913]                 if (length(args) > 0) 
[10:19:52.913]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.913]             }
[10:19:52.913]             else {
[10:19:52.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.913]             }
[10:19:52.913]             {
[10:19:52.913]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.913]                   0L) {
[10:19:52.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.913]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.913]                   base::options(opts)
[10:19:52.913]                 }
[10:19:52.913]                 {
[10:19:52.913]                   {
[10:19:52.913]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.913]                     NULL
[10:19:52.913]                   }
[10:19:52.913]                   options(future.plan = NULL)
[10:19:52.913]                   if (is.na(NA_character_)) 
[10:19:52.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.913]                     .init = FALSE)
[10:19:52.913]                 }
[10:19:52.913]             }
[10:19:52.913]         }
[10:19:52.913]     })
[10:19:52.913]     if (TRUE) {
[10:19:52.913]         base::sink(type = "output", split = FALSE)
[10:19:52.913]         if (TRUE) {
[10:19:52.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.913]         }
[10:19:52.913]         else {
[10:19:52.913]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.913]         }
[10:19:52.913]         base::close(...future.stdout)
[10:19:52.913]         ...future.stdout <- NULL
[10:19:52.913]     }
[10:19:52.913]     ...future.result$conditions <- ...future.conditions
[10:19:52.913]     ...future.result$finished <- base::Sys.time()
[10:19:52.913]     ...future.result
[10:19:52.913] }
[10:19:52.915] assign_globals() ...
[10:19:52.915] List of 11
[10:19:52.915]  $ ...future.FUN            :function (x, ...)  
[10:19:52.915]  $ x_FUN                    :function (x, ...)  
[10:19:52.915]  $ times                    : int 5
[10:19:52.915]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.915]  $ stop_if_not              :function (...)  
[10:19:52.915]  $ dim                      : NULL
[10:19:52.915]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.915]  $ future.call.arguments    : list()
[10:19:52.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.915]  $ ...future.elements_ii    :List of 1
[10:19:52.915]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:19:52.915]  $ ...future.seeds_ii       : NULL
[10:19:52.915]  $ ...future.globals.maxSize: NULL
[10:19:52.915]  - attr(*, "where")=List of 11
[10:19:52.915]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.915]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.915]  - attr(*, "resolved")= logi FALSE
[10:19:52.915]  - attr(*, "total_size")= num 24127
[10:19:52.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.915]  - attr(*, "already-done")= logi TRUE
[10:19:52.925] - copied ‘...future.FUN’ to environment
[10:19:52.925] - copied ‘x_FUN’ to environment
[10:19:52.925] - copied ‘times’ to environment
[10:19:52.925] - copied ‘stopf’ to environment
[10:19:52.925] - copied ‘stop_if_not’ to environment
[10:19:52.925] - copied ‘dim’ to environment
[10:19:52.925] - copied ‘valid_types’ to environment
[10:19:52.925] - copied ‘future.call.arguments’ to environment
[10:19:52.926] - copied ‘...future.elements_ii’ to environment
[10:19:52.926] - copied ‘...future.seeds_ii’ to environment
[10:19:52.926] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.926] assign_globals() ... done
[10:19:52.926] requestCore(): workers = 2
[10:19:52.928] MulticoreFuture started
[10:19:52.929] - Launch lazy future ... done
[10:19:52.929] run() for ‘MulticoreFuture’ ... done
[10:19:52.929] Created future:
[10:19:52.930] plan(): Setting new future strategy stack:
[10:19:52.930] List of future strategies:
[10:19:52.930] 1. sequential:
[10:19:52.930]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.930]    - tweaked: FALSE
[10:19:52.930]    - call: NULL
[10:19:52.931] plan(): nbrOfWorkers() = 1
[10:19:52.934] plan(): Setting new future strategy stack:
[10:19:52.934] List of future strategies:
[10:19:52.934] 1. multicore:
[10:19:52.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.934]    - tweaked: FALSE
[10:19:52.934]    - call: plan(strategy)
[10:19:52.937] plan(): nbrOfWorkers() = 2
[10:19:52.929] MulticoreFuture:
[10:19:52.929] Label: ‘future_vapply-1’
[10:19:52.929] Expression:
[10:19:52.929] {
[10:19:52.929]     do.call(function(...) {
[10:19:52.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.929]             on.exit(options(oopts), add = TRUE)
[10:19:52.929]         }
[10:19:52.929]         {
[10:19:52.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.929]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.929]             })
[10:19:52.929]         }
[10:19:52.929]     }, args = future.call.arguments)
[10:19:52.929] }
[10:19:52.929] Lazy evaluation: FALSE
[10:19:52.929] Asynchronous evaluation: TRUE
[10:19:52.929] Local evaluation: TRUE
[10:19:52.929] Environment: R_GlobalEnv
[10:19:52.929] Capture standard output: TRUE
[10:19:52.929] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.929] Globals: 11 objects totaling 13.35 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.929] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:52.929] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.929] Resolved: TRUE
[10:19:52.929] Value: <not collected>
[10:19:52.929] Conditions captured: <none>
[10:19:52.929] Early signaling: FALSE
[10:19:52.929] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.929] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.938] Chunk #1 of 2 ... DONE
[10:19:52.938] Chunk #2 of 2 ...
[10:19:52.939]  - Finding globals in 'X' for chunk #2 ...
[10:19:52.939] getGlobalsAndPackages() ...
[10:19:52.939] Searching for globals...
[10:19:52.939] 
[10:19:52.940] Searching for globals ... DONE
[10:19:52.940] - globals: [0] <none>
[10:19:52.940] getGlobalsAndPackages() ... DONE
[10:19:52.940]    + additional globals found: [n=0] 
[10:19:52.940]    + additional namespaces needed: [n=0] 
[10:19:52.940]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:52.940]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:52.940]  - seeds: <none>
[10:19:52.941]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.941] getGlobalsAndPackages() ...
[10:19:52.941] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.941] Resolving globals: FALSE
[10:19:52.941] Tweak future expression to call with '...' arguments ...
[10:19:52.941] {
[10:19:52.941]     do.call(function(...) {
[10:19:52.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.941]             on.exit(options(oopts), add = TRUE)
[10:19:52.941]         }
[10:19:52.941]         {
[10:19:52.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.941]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.941]             })
[10:19:52.941]         }
[10:19:52.941]     }, args = future.call.arguments)
[10:19:52.941] }
[10:19:52.942] Tweak future expression to call with '...' arguments ... DONE
[10:19:52.943] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:52.943] - packages: [2] ‘stats’, ‘future.apply’
[10:19:52.943] getGlobalsAndPackages() ... DONE
[10:19:52.944] run() for ‘Future’ ...
[10:19:52.944] - state: ‘created’
[10:19:52.944] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:52.947] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:52.947]   - Field: ‘label’
[10:19:52.947]   - Field: ‘local’
[10:19:52.947]   - Field: ‘owner’
[10:19:52.948]   - Field: ‘envir’
[10:19:52.948]   - Field: ‘workers’
[10:19:52.948]   - Field: ‘packages’
[10:19:52.948]   - Field: ‘gc’
[10:19:52.948]   - Field: ‘job’
[10:19:52.948]   - Field: ‘conditions’
[10:19:52.948]   - Field: ‘expr’
[10:19:52.949]   - Field: ‘uuid’
[10:19:52.949]   - Field: ‘seed’
[10:19:52.949]   - Field: ‘version’
[10:19:52.949]   - Field: ‘result’
[10:19:52.949]   - Field: ‘asynchronous’
[10:19:52.949]   - Field: ‘calls’
[10:19:52.949]   - Field: ‘globals’
[10:19:52.949]   - Field: ‘stdout’
[10:19:52.950]   - Field: ‘earlySignal’
[10:19:52.950]   - Field: ‘lazy’
[10:19:52.950]   - Field: ‘state’
[10:19:52.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:52.950] - Launch lazy future ...
[10:19:52.951] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:52.951] Packages needed by future strategies (n = 0): <none>
[10:19:52.952] {
[10:19:52.952]     {
[10:19:52.952]         {
[10:19:52.952]             ...future.startTime <- base::Sys.time()
[10:19:52.952]             {
[10:19:52.952]                 {
[10:19:52.952]                   {
[10:19:52.952]                     {
[10:19:52.952]                       {
[10:19:52.952]                         base::local({
[10:19:52.952]                           has_future <- base::requireNamespace("future", 
[10:19:52.952]                             quietly = TRUE)
[10:19:52.952]                           if (has_future) {
[10:19:52.952]                             ns <- base::getNamespace("future")
[10:19:52.952]                             version <- ns[[".package"]][["version"]]
[10:19:52.952]                             if (is.null(version)) 
[10:19:52.952]                               version <- utils::packageVersion("future")
[10:19:52.952]                           }
[10:19:52.952]                           else {
[10:19:52.952]                             version <- NULL
[10:19:52.952]                           }
[10:19:52.952]                           if (!has_future || version < "1.8.0") {
[10:19:52.952]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:52.952]                               "", base::R.version$version.string), 
[10:19:52.952]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:52.952]                                 base::R.version$platform, 8 * 
[10:19:52.952]                                   base::.Machine$sizeof.pointer), 
[10:19:52.952]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:52.952]                                 "release", "version")], collapse = " "), 
[10:19:52.952]                               hostname = base::Sys.info()[["nodename"]])
[10:19:52.952]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:52.952]                               info)
[10:19:52.952]                             info <- base::paste(info, collapse = "; ")
[10:19:52.952]                             if (!has_future) {
[10:19:52.952]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:52.952]                                 info)
[10:19:52.952]                             }
[10:19:52.952]                             else {
[10:19:52.952]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:52.952]                                 info, version)
[10:19:52.952]                             }
[10:19:52.952]                             base::stop(msg)
[10:19:52.952]                           }
[10:19:52.952]                         })
[10:19:52.952]                       }
[10:19:52.952]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:52.952]                       base::options(mc.cores = 1L)
[10:19:52.952]                     }
[10:19:52.952]                     base::local({
[10:19:52.952]                       for (pkg in c("stats", "future.apply")) {
[10:19:52.952]                         base::loadNamespace(pkg)
[10:19:52.952]                         base::library(pkg, character.only = TRUE)
[10:19:52.952]                       }
[10:19:52.952]                     })
[10:19:52.952]                   }
[10:19:52.952]                   ...future.strategy.old <- future::plan("list")
[10:19:52.952]                   options(future.plan = NULL)
[10:19:52.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:52.952]                 }
[10:19:52.952]                 ...future.workdir <- getwd()
[10:19:52.952]             }
[10:19:52.952]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:52.952]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:52.952]         }
[10:19:52.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:52.952]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:52.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:52.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:52.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:52.952]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:52.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:52.952]             base::names(...future.oldOptions))
[10:19:52.952]     }
[10:19:52.952]     if (FALSE) {
[10:19:52.952]     }
[10:19:52.952]     else {
[10:19:52.952]         if (TRUE) {
[10:19:52.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:52.952]                 open = "w")
[10:19:52.952]         }
[10:19:52.952]         else {
[10:19:52.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:52.952]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:52.952]         }
[10:19:52.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:52.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:52.952]             base::sink(type = "output", split = FALSE)
[10:19:52.952]             base::close(...future.stdout)
[10:19:52.952]         }, add = TRUE)
[10:19:52.952]     }
[10:19:52.952]     ...future.frame <- base::sys.nframe()
[10:19:52.952]     ...future.conditions <- base::list()
[10:19:52.952]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:52.952]     if (FALSE) {
[10:19:52.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:52.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:52.952]     }
[10:19:52.952]     ...future.result <- base::tryCatch({
[10:19:52.952]         base::withCallingHandlers({
[10:19:52.952]             ...future.value <- base::withVisible(base::local({
[10:19:52.952]                 withCallingHandlers({
[10:19:52.952]                   {
[10:19:52.952]                     do.call(function(...) {
[10:19:52.952]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.952]                       if (!identical(...future.globals.maxSize.org, 
[10:19:52.952]                         ...future.globals.maxSize)) {
[10:19:52.952]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.952]                         on.exit(options(oopts), add = TRUE)
[10:19:52.952]                       }
[10:19:52.952]                       {
[10:19:52.952]                         lapply(seq_along(...future.elements_ii), 
[10:19:52.952]                           FUN = function(jj) {
[10:19:52.952]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.952]                             ...future.FUN(...future.X_jj, ...)
[10:19:52.952]                           })
[10:19:52.952]                       }
[10:19:52.952]                     }, args = future.call.arguments)
[10:19:52.952]                   }
[10:19:52.952]                 }, immediateCondition = function(cond) {
[10:19:52.952]                   save_rds <- function (object, pathname, ...) 
[10:19:52.952]                   {
[10:19:52.952]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:52.952]                     if (file_test("-f", pathname_tmp)) {
[10:19:52.952]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.952]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:52.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.952]                         fi_tmp[["mtime"]])
[10:19:52.952]                     }
[10:19:52.952]                     tryCatch({
[10:19:52.952]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:52.952]                     }, error = function(ex) {
[10:19:52.952]                       msg <- conditionMessage(ex)
[10:19:52.952]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.952]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:52.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.952]                         fi_tmp[["mtime"]], msg)
[10:19:52.952]                       ex$message <- msg
[10:19:52.952]                       stop(ex)
[10:19:52.952]                     })
[10:19:52.952]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:52.952]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:52.952]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:52.952]                       fi_tmp <- file.info(pathname_tmp)
[10:19:52.952]                       fi <- file.info(pathname)
[10:19:52.952]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:52.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:52.952]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:52.952]                         fi[["size"]], fi[["mtime"]])
[10:19:52.952]                       stop(msg)
[10:19:52.952]                     }
[10:19:52.952]                     invisible(pathname)
[10:19:52.952]                   }
[10:19:52.952]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:52.952]                     rootPath = tempdir()) 
[10:19:52.952]                   {
[10:19:52.952]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:52.952]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:52.952]                       tmpdir = path, fileext = ".rds")
[10:19:52.952]                     save_rds(obj, file)
[10:19:52.952]                   }
[10:19:52.952]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:52.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.952]                   {
[10:19:52.952]                     inherits <- base::inherits
[10:19:52.952]                     invokeRestart <- base::invokeRestart
[10:19:52.952]                     is.null <- base::is.null
[10:19:52.952]                     muffled <- FALSE
[10:19:52.952]                     if (inherits(cond, "message")) {
[10:19:52.952]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:52.952]                       if (muffled) 
[10:19:52.952]                         invokeRestart("muffleMessage")
[10:19:52.952]                     }
[10:19:52.952]                     else if (inherits(cond, "warning")) {
[10:19:52.952]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:52.952]                       if (muffled) 
[10:19:52.952]                         invokeRestart("muffleWarning")
[10:19:52.952]                     }
[10:19:52.952]                     else if (inherits(cond, "condition")) {
[10:19:52.952]                       if (!is.null(pattern)) {
[10:19:52.952]                         computeRestarts <- base::computeRestarts
[10:19:52.952]                         grepl <- base::grepl
[10:19:52.952]                         restarts <- computeRestarts(cond)
[10:19:52.952]                         for (restart in restarts) {
[10:19:52.952]                           name <- restart$name
[10:19:52.952]                           if (is.null(name)) 
[10:19:52.952]                             next
[10:19:52.952]                           if (!grepl(pattern, name)) 
[10:19:52.952]                             next
[10:19:52.952]                           invokeRestart(restart)
[10:19:52.952]                           muffled <- TRUE
[10:19:52.952]                           break
[10:19:52.952]                         }
[10:19:52.952]                       }
[10:19:52.952]                     }
[10:19:52.952]                     invisible(muffled)
[10:19:52.952]                   }
[10:19:52.952]                   muffleCondition(cond)
[10:19:52.952]                 })
[10:19:52.952]             }))
[10:19:52.952]             future::FutureResult(value = ...future.value$value, 
[10:19:52.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.952]                   ...future.rng), globalenv = if (FALSE) 
[10:19:52.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:52.952]                     ...future.globalenv.names))
[10:19:52.952]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:52.952]         }, condition = base::local({
[10:19:52.952]             c <- base::c
[10:19:52.952]             inherits <- base::inherits
[10:19:52.952]             invokeRestart <- base::invokeRestart
[10:19:52.952]             length <- base::length
[10:19:52.952]             list <- base::list
[10:19:52.952]             seq.int <- base::seq.int
[10:19:52.952]             signalCondition <- base::signalCondition
[10:19:52.952]             sys.calls <- base::sys.calls
[10:19:52.952]             `[[` <- base::`[[`
[10:19:52.952]             `+` <- base::`+`
[10:19:52.952]             `<<-` <- base::`<<-`
[10:19:52.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:52.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:52.952]                   3L)]
[10:19:52.952]             }
[10:19:52.952]             function(cond) {
[10:19:52.952]                 is_error <- inherits(cond, "error")
[10:19:52.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:52.952]                   NULL)
[10:19:52.952]                 if (is_error) {
[10:19:52.952]                   sessionInformation <- function() {
[10:19:52.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:52.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:52.952]                       search = base::search(), system = base::Sys.info())
[10:19:52.952]                   }
[10:19:52.952]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:52.952]                     cond$call), session = sessionInformation(), 
[10:19:52.952]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:52.952]                   signalCondition(cond)
[10:19:52.952]                 }
[10:19:52.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:52.952]                 "immediateCondition"))) {
[10:19:52.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:52.952]                   ...future.conditions[[length(...future.conditions) + 
[10:19:52.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:52.952]                   if (TRUE && !signal) {
[10:19:52.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.952]                     {
[10:19:52.952]                       inherits <- base::inherits
[10:19:52.952]                       invokeRestart <- base::invokeRestart
[10:19:52.952]                       is.null <- base::is.null
[10:19:52.952]                       muffled <- FALSE
[10:19:52.952]                       if (inherits(cond, "message")) {
[10:19:52.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.952]                         if (muffled) 
[10:19:52.952]                           invokeRestart("muffleMessage")
[10:19:52.952]                       }
[10:19:52.952]                       else if (inherits(cond, "warning")) {
[10:19:52.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.952]                         if (muffled) 
[10:19:52.952]                           invokeRestart("muffleWarning")
[10:19:52.952]                       }
[10:19:52.952]                       else if (inherits(cond, "condition")) {
[10:19:52.952]                         if (!is.null(pattern)) {
[10:19:52.952]                           computeRestarts <- base::computeRestarts
[10:19:52.952]                           grepl <- base::grepl
[10:19:52.952]                           restarts <- computeRestarts(cond)
[10:19:52.952]                           for (restart in restarts) {
[10:19:52.952]                             name <- restart$name
[10:19:52.952]                             if (is.null(name)) 
[10:19:52.952]                               next
[10:19:52.952]                             if (!grepl(pattern, name)) 
[10:19:52.952]                               next
[10:19:52.952]                             invokeRestart(restart)
[10:19:52.952]                             muffled <- TRUE
[10:19:52.952]                             break
[10:19:52.952]                           }
[10:19:52.952]                         }
[10:19:52.952]                       }
[10:19:52.952]                       invisible(muffled)
[10:19:52.952]                     }
[10:19:52.952]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.952]                   }
[10:19:52.952]                 }
[10:19:52.952]                 else {
[10:19:52.952]                   if (TRUE) {
[10:19:52.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:52.952]                     {
[10:19:52.952]                       inherits <- base::inherits
[10:19:52.952]                       invokeRestart <- base::invokeRestart
[10:19:52.952]                       is.null <- base::is.null
[10:19:52.952]                       muffled <- FALSE
[10:19:52.952]                       if (inherits(cond, "message")) {
[10:19:52.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:52.952]                         if (muffled) 
[10:19:52.952]                           invokeRestart("muffleMessage")
[10:19:52.952]                       }
[10:19:52.952]                       else if (inherits(cond, "warning")) {
[10:19:52.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:52.952]                         if (muffled) 
[10:19:52.952]                           invokeRestart("muffleWarning")
[10:19:52.952]                       }
[10:19:52.952]                       else if (inherits(cond, "condition")) {
[10:19:52.952]                         if (!is.null(pattern)) {
[10:19:52.952]                           computeRestarts <- base::computeRestarts
[10:19:52.952]                           grepl <- base::grepl
[10:19:52.952]                           restarts <- computeRestarts(cond)
[10:19:52.952]                           for (restart in restarts) {
[10:19:52.952]                             name <- restart$name
[10:19:52.952]                             if (is.null(name)) 
[10:19:52.952]                               next
[10:19:52.952]                             if (!grepl(pattern, name)) 
[10:19:52.952]                               next
[10:19:52.952]                             invokeRestart(restart)
[10:19:52.952]                             muffled <- TRUE
[10:19:52.952]                             break
[10:19:52.952]                           }
[10:19:52.952]                         }
[10:19:52.952]                       }
[10:19:52.952]                       invisible(muffled)
[10:19:52.952]                     }
[10:19:52.952]                     muffleCondition(cond, pattern = "^muffle")
[10:19:52.952]                   }
[10:19:52.952]                 }
[10:19:52.952]             }
[10:19:52.952]         }))
[10:19:52.952]     }, error = function(ex) {
[10:19:52.952]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:52.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:52.952]                 ...future.rng), started = ...future.startTime, 
[10:19:52.952]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:52.952]             version = "1.8"), class = "FutureResult")
[10:19:52.952]     }, finally = {
[10:19:52.952]         if (!identical(...future.workdir, getwd())) 
[10:19:52.952]             setwd(...future.workdir)
[10:19:52.952]         {
[10:19:52.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:52.952]                 ...future.oldOptions$nwarnings <- NULL
[10:19:52.952]             }
[10:19:52.952]             base::options(...future.oldOptions)
[10:19:52.952]             if (.Platform$OS.type == "windows") {
[10:19:52.952]                 old_names <- names(...future.oldEnvVars)
[10:19:52.952]                 envs <- base::Sys.getenv()
[10:19:52.952]                 names <- names(envs)
[10:19:52.952]                 common <- intersect(names, old_names)
[10:19:52.952]                 added <- setdiff(names, old_names)
[10:19:52.952]                 removed <- setdiff(old_names, names)
[10:19:52.952]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:52.952]                   envs[common]]
[10:19:52.952]                 NAMES <- toupper(changed)
[10:19:52.952]                 args <- list()
[10:19:52.952]                 for (kk in seq_along(NAMES)) {
[10:19:52.952]                   name <- changed[[kk]]
[10:19:52.952]                   NAME <- NAMES[[kk]]
[10:19:52.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.952]                     next
[10:19:52.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.952]                 }
[10:19:52.952]                 NAMES <- toupper(added)
[10:19:52.952]                 for (kk in seq_along(NAMES)) {
[10:19:52.952]                   name <- added[[kk]]
[10:19:52.952]                   NAME <- NAMES[[kk]]
[10:19:52.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.952]                     next
[10:19:52.952]                   args[[name]] <- ""
[10:19:52.952]                 }
[10:19:52.952]                 NAMES <- toupper(removed)
[10:19:52.952]                 for (kk in seq_along(NAMES)) {
[10:19:52.952]                   name <- removed[[kk]]
[10:19:52.952]                   NAME <- NAMES[[kk]]
[10:19:52.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:52.952]                     next
[10:19:52.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:52.952]                 }
[10:19:52.952]                 if (length(args) > 0) 
[10:19:52.952]                   base::do.call(base::Sys.setenv, args = args)
[10:19:52.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:52.952]             }
[10:19:52.952]             else {
[10:19:52.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:52.952]             }
[10:19:52.952]             {
[10:19:52.952]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:52.952]                   0L) {
[10:19:52.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:52.952]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:52.952]                   base::options(opts)
[10:19:52.952]                 }
[10:19:52.952]                 {
[10:19:52.952]                   {
[10:19:52.952]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:52.952]                     NULL
[10:19:52.952]                   }
[10:19:52.952]                   options(future.plan = NULL)
[10:19:52.952]                   if (is.na(NA_character_)) 
[10:19:52.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:52.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:52.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:52.952]                     .init = FALSE)
[10:19:52.952]                 }
[10:19:52.952]             }
[10:19:52.952]         }
[10:19:52.952]     })
[10:19:52.952]     if (TRUE) {
[10:19:52.952]         base::sink(type = "output", split = FALSE)
[10:19:52.952]         if (TRUE) {
[10:19:52.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:52.952]         }
[10:19:52.952]         else {
[10:19:52.952]             ...future.result["stdout"] <- base::list(NULL)
[10:19:52.952]         }
[10:19:52.952]         base::close(...future.stdout)
[10:19:52.952]         ...future.stdout <- NULL
[10:19:52.952]     }
[10:19:52.952]     ...future.result$conditions <- ...future.conditions
[10:19:52.952]     ...future.result$finished <- base::Sys.time()
[10:19:52.952]     ...future.result
[10:19:52.952] }
[10:19:52.955] assign_globals() ...
[10:19:52.958] List of 11
[10:19:52.958]  $ ...future.FUN            :function (x, ...)  
[10:19:52.958]  $ x_FUN                    :function (x, ...)  
[10:19:52.958]  $ times                    : int 5
[10:19:52.958]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:52.958]  $ stop_if_not              :function (...)  
[10:19:52.958]  $ dim                      : NULL
[10:19:52.958]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:52.958]  $ future.call.arguments    : list()
[10:19:52.958]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:52.958]  $ ...future.elements_ii    :List of 2
[10:19:52.958]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:19:52.958]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:19:52.958]  $ ...future.seeds_ii       : NULL
[10:19:52.958]  $ ...future.globals.maxSize: NULL
[10:19:52.958]  - attr(*, "where")=List of 11
[10:19:52.958]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:52.958]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:52.958]  - attr(*, "resolved")= logi FALSE
[10:19:52.958]  - attr(*, "total_size")= num 24127
[10:19:52.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:52.958]  - attr(*, "already-done")= logi TRUE
[10:19:52.973] - copied ‘...future.FUN’ to environment
[10:19:52.973] - copied ‘x_FUN’ to environment
[10:19:52.973] - copied ‘times’ to environment
[10:19:52.973] - copied ‘stopf’ to environment
[10:19:52.973] - copied ‘stop_if_not’ to environment
[10:19:52.973] - copied ‘dim’ to environment
[10:19:52.974] - copied ‘valid_types’ to environment
[10:19:52.974] - copied ‘future.call.arguments’ to environment
[10:19:52.974] - copied ‘...future.elements_ii’ to environment
[10:19:52.974] - copied ‘...future.seeds_ii’ to environment
[10:19:52.974] - copied ‘...future.globals.maxSize’ to environment
[10:19:52.974] assign_globals() ... done
[10:19:52.974] requestCore(): workers = 2
[10:19:52.976] MulticoreFuture started
[10:19:52.977] - Launch lazy future ... done
[10:19:52.977] run() for ‘MulticoreFuture’ ... done
[10:19:52.977] Created future:
[10:19:52.978] plan(): Setting new future strategy stack:
[10:19:52.978] List of future strategies:
[10:19:52.978] 1. sequential:
[10:19:52.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:52.978]    - tweaked: FALSE
[10:19:52.978]    - call: NULL
[10:19:52.979] plan(): nbrOfWorkers() = 1
[10:19:52.982] plan(): Setting new future strategy stack:
[10:19:52.982] List of future strategies:
[10:19:52.982] 1. multicore:
[10:19:52.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:52.982]    - tweaked: FALSE
[10:19:52.982]    - call: plan(strategy)
[10:19:52.985] plan(): nbrOfWorkers() = 2
[10:19:52.977] MulticoreFuture:
[10:19:52.977] Label: ‘future_vapply-2’
[10:19:52.977] Expression:
[10:19:52.977] {
[10:19:52.977]     do.call(function(...) {
[10:19:52.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:52.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:52.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:52.977]             on.exit(options(oopts), add = TRUE)
[10:19:52.977]         }
[10:19:52.977]         {
[10:19:52.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:52.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:52.977]                 ...future.FUN(...future.X_jj, ...)
[10:19:52.977]             })
[10:19:52.977]         }
[10:19:52.977]     }, args = future.call.arguments)
[10:19:52.977] }
[10:19:52.977] Lazy evaluation: FALSE
[10:19:52.977] Asynchronous evaluation: TRUE
[10:19:52.977] Local evaluation: TRUE
[10:19:52.977] Environment: R_GlobalEnv
[10:19:52.977] Capture standard output: TRUE
[10:19:52.977] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:52.977] Globals: 11 objects totaling 13.34 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:52.977] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:52.977] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:52.977] Resolved: TRUE
[10:19:52.977] Value: <not collected>
[10:19:52.977] Conditions captured: <none>
[10:19:52.977] Early signaling: FALSE
[10:19:52.977] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:52.977] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:52.986] Chunk #2 of 2 ... DONE
[10:19:52.987] Launching 2 futures (chunks) ... DONE
[10:19:52.987] Resolving 2 futures (chunks) ...
[10:19:52.987] resolve() on list ...
[10:19:52.987]  recursive: 0
[10:19:52.987]  length: 2
[10:19:52.987] 
[10:19:52.988] Future #1
[10:19:52.988] result() for MulticoreFuture ...
[10:19:52.989] result() for MulticoreFuture ...
[10:19:52.989] result() for MulticoreFuture ... done
[10:19:52.989] result() for MulticoreFuture ... done
[10:19:52.989] result() for MulticoreFuture ...
[10:19:52.989] result() for MulticoreFuture ... done
[10:19:52.989] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:52.990] - nx: 2
[10:19:52.990] - relay: TRUE
[10:19:52.990] - stdout: TRUE
[10:19:52.990] - signal: TRUE
[10:19:52.990] - resignal: FALSE
[10:19:52.990] - force: TRUE
[10:19:52.990] - relayed: [n=2] FALSE, FALSE
[10:19:52.990] - queued futures: [n=2] FALSE, FALSE
[10:19:52.991]  - until=1
[10:19:52.991]  - relaying element #1
[10:19:52.991] result() for MulticoreFuture ...
[10:19:52.991] result() for MulticoreFuture ... done
[10:19:52.991] result() for MulticoreFuture ...
[10:19:52.991] result() for MulticoreFuture ... done
[10:19:52.991] result() for MulticoreFuture ...
[10:19:52.992] result() for MulticoreFuture ... done
[10:19:52.992] result() for MulticoreFuture ...
[10:19:52.992] result() for MulticoreFuture ... done
[10:19:52.992] - relayed: [n=2] TRUE, FALSE
[10:19:52.992] - queued futures: [n=2] TRUE, FALSE
[10:19:52.992] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:52.993]  length: 1 (resolved future 1)
[10:19:52.993] Future #2
[10:19:52.993] result() for MulticoreFuture ...
[10:19:52.994] result() for MulticoreFuture ...
[10:19:52.994] result() for MulticoreFuture ... done
[10:19:52.994] result() for MulticoreFuture ... done
[10:19:52.994] result() for MulticoreFuture ...
[10:19:52.994] result() for MulticoreFuture ... done
[10:19:52.994] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:52.995] - nx: 2
[10:19:52.995] - relay: TRUE
[10:19:52.995] - stdout: TRUE
[10:19:52.995] - signal: TRUE
[10:19:52.995] - resignal: FALSE
[10:19:52.995] - force: TRUE
[10:19:52.995] - relayed: [n=2] TRUE, FALSE
[10:19:52.995] - queued futures: [n=2] TRUE, FALSE
[10:19:52.996]  - until=2
[10:19:52.996]  - relaying element #2
[10:19:52.996] result() for MulticoreFuture ...
[10:19:52.996] result() for MulticoreFuture ... done
[10:19:52.996] result() for MulticoreFuture ...
[10:19:52.996] result() for MulticoreFuture ... done
[10:19:52.996] result() for MulticoreFuture ...
[10:19:52.996] result() for MulticoreFuture ... done
[10:19:52.997] result() for MulticoreFuture ...
[10:19:52.997] result() for MulticoreFuture ... done
[10:19:52.997] - relayed: [n=2] TRUE, TRUE
[10:19:52.997] - queued futures: [n=2] TRUE, TRUE
[10:19:52.997] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:52.997]  length: 0 (resolved future 2)
[10:19:52.997] Relaying remaining futures
[10:19:52.997] signalConditionsASAP(NULL, pos=0) ...
[10:19:52.997] - nx: 2
[10:19:52.998] - relay: TRUE
[10:19:52.998] - stdout: TRUE
[10:19:53.000] - signal: TRUE
[10:19:53.000] - resignal: FALSE
[10:19:53.000] - force: TRUE
[10:19:53.001] - relayed: [n=2] TRUE, TRUE
[10:19:53.001] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:53.001] - relayed: [n=2] TRUE, TRUE
[10:19:53.001] - queued futures: [n=2] TRUE, TRUE
[10:19:53.001] signalConditionsASAP(NULL, pos=0) ... done
[10:19:53.001] resolve() on list ... DONE
[10:19:53.002] result() for MulticoreFuture ...
[10:19:53.002] result() for MulticoreFuture ... done
[10:19:53.002] result() for MulticoreFuture ...
[10:19:53.002] result() for MulticoreFuture ... done
[10:19:53.002] result() for MulticoreFuture ...
[10:19:53.002] result() for MulticoreFuture ... done
[10:19:53.003] result() for MulticoreFuture ...
[10:19:53.003] result() for MulticoreFuture ... done
[10:19:53.003]  - Number of value chunks collected: 2
[10:19:53.003] Resolving 2 futures (chunks) ... DONE
[10:19:53.003] Reducing values from 2 chunks ...
[10:19:53.003]  - Number of values collected after concatenation: 3
[10:19:53.003]  - Number of values expected: 3
[10:19:53.004] Reducing values from 2 chunks ... DONE
[10:19:53.004] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:19:53.007] future_lapply() ...
[10:19:53.013] Number of chunks: 2
[10:19:53.013] getGlobalsAndPackagesXApply() ...
[10:19:53.013]  - future.globals: TRUE
[10:19:53.014] getGlobalsAndPackages() ...
[10:19:53.014] Searching for globals...
[10:19:53.018] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:19:53.019] Searching for globals ... DONE
[10:19:53.019] Resolving globals: FALSE
[10:19:53.020] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[10:19:53.020] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[10:19:53.020] - globals: [1] ‘FUN’
[10:19:53.020] - packages: [1] ‘stats’
[10:19:53.020] getGlobalsAndPackages() ... DONE
[10:19:53.020]  - globals found/used: [n=1] ‘FUN’
[10:19:53.020]  - needed namespaces: [n=1] ‘stats’
[10:19:53.021] Finding globals ... DONE
[10:19:53.021]  - use_args: TRUE
[10:19:53.021]  - Getting '...' globals ...
[10:19:53.021] resolve() on list ...
[10:19:53.021]  recursive: 0
[10:19:53.021]  length: 1
[10:19:53.021]  elements: ‘...’
[10:19:53.023]  length: 0 (resolved future 1)
[10:19:53.024] resolve() on list ... DONE
[10:19:53.024]    - '...' content: [n=0] 
[10:19:53.024] List of 1
[10:19:53.024]  $ ...: list()
[10:19:53.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.024]  - attr(*, "where")=List of 1
[10:19:53.024]   ..$ ...:<environment: 0x55c69ff8de98> 
[10:19:53.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.024]  - attr(*, "resolved")= logi TRUE
[10:19:53.024]  - attr(*, "total_size")= num NA
[10:19:53.026]  - Getting '...' globals ... DONE
[10:19:53.027] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:19:53.027] List of 2
[10:19:53.027]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:19:53.027]  $ ...          : list()
[10:19:53.027]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.027]  - attr(*, "where")=List of 2
[10:19:53.027]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:53.027]   ..$ ...          :<environment: 0x55c69ff8de98> 
[10:19:53.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.027]  - attr(*, "resolved")= logi FALSE
[10:19:53.027]  - attr(*, "total_size")= num 18895
[10:19:53.030] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:53.030] getGlobalsAndPackagesXApply() ... DONE
[10:19:53.030] Number of futures (= number of chunks): 2
[10:19:53.030] Launching 2 futures (chunks) ...
[10:19:53.030] Chunk #1 of 2 ...
[10:19:53.030]  - Finding globals in 'X' for chunk #1 ...
[10:19:53.030] getGlobalsAndPackages() ...
[10:19:53.030] Searching for globals...
[10:19:53.031] 
[10:19:53.031] Searching for globals ... DONE
[10:19:53.031] - globals: [0] <none>
[10:19:53.031] getGlobalsAndPackages() ... DONE
[10:19:53.031]    + additional globals found: [n=0] 
[10:19:53.031]    + additional namespaces needed: [n=0] 
[10:19:53.031]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:53.031]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.032]  - seeds: <none>
[10:19:53.032]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.032] getGlobalsAndPackages() ...
[10:19:53.032] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.032] Resolving globals: FALSE
[10:19:53.032] Tweak future expression to call with '...' arguments ...
[10:19:53.032] {
[10:19:53.032]     do.call(function(...) {
[10:19:53.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.032]             on.exit(options(oopts), add = TRUE)
[10:19:53.032]         }
[10:19:53.032]         {
[10:19:53.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.032]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.032]             })
[10:19:53.032]         }
[10:19:53.032]     }, args = future.call.arguments)
[10:19:53.032] }
[10:19:53.032] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.033] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.033] - packages: [1] ‘stats’
[10:19:53.033] getGlobalsAndPackages() ... DONE
[10:19:53.033] run() for ‘Future’ ...
[10:19:53.033] - state: ‘created’
[10:19:53.033] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.035] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.035]   - Field: ‘label’
[10:19:53.035]   - Field: ‘local’
[10:19:53.036]   - Field: ‘owner’
[10:19:53.036]   - Field: ‘envir’
[10:19:53.036]   - Field: ‘workers’
[10:19:53.036]   - Field: ‘packages’
[10:19:53.036]   - Field: ‘gc’
[10:19:53.036]   - Field: ‘job’
[10:19:53.036]   - Field: ‘conditions’
[10:19:53.036]   - Field: ‘expr’
[10:19:53.036]   - Field: ‘uuid’
[10:19:53.036]   - Field: ‘seed’
[10:19:53.036]   - Field: ‘version’
[10:19:53.036]   - Field: ‘result’
[10:19:53.037]   - Field: ‘asynchronous’
[10:19:53.037]   - Field: ‘calls’
[10:19:53.037]   - Field: ‘globals’
[10:19:53.037]   - Field: ‘stdout’
[10:19:53.037]   - Field: ‘earlySignal’
[10:19:53.037]   - Field: ‘lazy’
[10:19:53.037]   - Field: ‘state’
[10:19:53.037] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.037] - Launch lazy future ...
[10:19:53.038] Packages needed by the future expression (n = 1): ‘stats’
[10:19:53.038] Packages needed by future strategies (n = 0): <none>
[10:19:53.038] {
[10:19:53.038]     {
[10:19:53.038]         {
[10:19:53.038]             ...future.startTime <- base::Sys.time()
[10:19:53.038]             {
[10:19:53.038]                 {
[10:19:53.038]                   {
[10:19:53.038]                     {
[10:19:53.038]                       {
[10:19:53.038]                         base::local({
[10:19:53.038]                           has_future <- base::requireNamespace("future", 
[10:19:53.038]                             quietly = TRUE)
[10:19:53.038]                           if (has_future) {
[10:19:53.038]                             ns <- base::getNamespace("future")
[10:19:53.038]                             version <- ns[[".package"]][["version"]]
[10:19:53.038]                             if (is.null(version)) 
[10:19:53.038]                               version <- utils::packageVersion("future")
[10:19:53.038]                           }
[10:19:53.038]                           else {
[10:19:53.038]                             version <- NULL
[10:19:53.038]                           }
[10:19:53.038]                           if (!has_future || version < "1.8.0") {
[10:19:53.038]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.038]                               "", base::R.version$version.string), 
[10:19:53.038]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.038]                                 base::R.version$platform, 8 * 
[10:19:53.038]                                   base::.Machine$sizeof.pointer), 
[10:19:53.038]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.038]                                 "release", "version")], collapse = " "), 
[10:19:53.038]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.038]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.038]                               info)
[10:19:53.038]                             info <- base::paste(info, collapse = "; ")
[10:19:53.038]                             if (!has_future) {
[10:19:53.038]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.038]                                 info)
[10:19:53.038]                             }
[10:19:53.038]                             else {
[10:19:53.038]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.038]                                 info, version)
[10:19:53.038]                             }
[10:19:53.038]                             base::stop(msg)
[10:19:53.038]                           }
[10:19:53.038]                         })
[10:19:53.038]                       }
[10:19:53.038]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.038]                       base::options(mc.cores = 1L)
[10:19:53.038]                     }
[10:19:53.038]                     base::local({
[10:19:53.038]                       for (pkg in "stats") {
[10:19:53.038]                         base::loadNamespace(pkg)
[10:19:53.038]                         base::library(pkg, character.only = TRUE)
[10:19:53.038]                       }
[10:19:53.038]                     })
[10:19:53.038]                   }
[10:19:53.038]                   ...future.strategy.old <- future::plan("list")
[10:19:53.038]                   options(future.plan = NULL)
[10:19:53.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.038]                 }
[10:19:53.038]                 ...future.workdir <- getwd()
[10:19:53.038]             }
[10:19:53.038]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.038]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.038]         }
[10:19:53.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.038]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.038]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.038]             base::names(...future.oldOptions))
[10:19:53.038]     }
[10:19:53.038]     if (FALSE) {
[10:19:53.038]     }
[10:19:53.038]     else {
[10:19:53.038]         if (TRUE) {
[10:19:53.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.038]                 open = "w")
[10:19:53.038]         }
[10:19:53.038]         else {
[10:19:53.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.038]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.038]         }
[10:19:53.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.038]             base::sink(type = "output", split = FALSE)
[10:19:53.038]             base::close(...future.stdout)
[10:19:53.038]         }, add = TRUE)
[10:19:53.038]     }
[10:19:53.038]     ...future.frame <- base::sys.nframe()
[10:19:53.038]     ...future.conditions <- base::list()
[10:19:53.038]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.038]     if (FALSE) {
[10:19:53.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.038]     }
[10:19:53.038]     ...future.result <- base::tryCatch({
[10:19:53.038]         base::withCallingHandlers({
[10:19:53.038]             ...future.value <- base::withVisible(base::local({
[10:19:53.038]                 withCallingHandlers({
[10:19:53.038]                   {
[10:19:53.038]                     do.call(function(...) {
[10:19:53.038]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.038]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.038]                         ...future.globals.maxSize)) {
[10:19:53.038]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.038]                         on.exit(options(oopts), add = TRUE)
[10:19:53.038]                       }
[10:19:53.038]                       {
[10:19:53.038]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.038]                           FUN = function(jj) {
[10:19:53.038]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.038]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.038]                           })
[10:19:53.038]                       }
[10:19:53.038]                     }, args = future.call.arguments)
[10:19:53.038]                   }
[10:19:53.038]                 }, immediateCondition = function(cond) {
[10:19:53.038]                   save_rds <- function (object, pathname, ...) 
[10:19:53.038]                   {
[10:19:53.038]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.038]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.038]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.038]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.038]                         fi_tmp[["mtime"]])
[10:19:53.038]                     }
[10:19:53.038]                     tryCatch({
[10:19:53.038]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.038]                     }, error = function(ex) {
[10:19:53.038]                       msg <- conditionMessage(ex)
[10:19:53.038]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.038]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.038]                         fi_tmp[["mtime"]], msg)
[10:19:53.038]                       ex$message <- msg
[10:19:53.038]                       stop(ex)
[10:19:53.038]                     })
[10:19:53.038]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.038]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.038]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.038]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.038]                       fi <- file.info(pathname)
[10:19:53.038]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.038]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.038]                         fi[["size"]], fi[["mtime"]])
[10:19:53.038]                       stop(msg)
[10:19:53.038]                     }
[10:19:53.038]                     invisible(pathname)
[10:19:53.038]                   }
[10:19:53.038]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.038]                     rootPath = tempdir()) 
[10:19:53.038]                   {
[10:19:53.038]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.038]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.038]                       tmpdir = path, fileext = ".rds")
[10:19:53.038]                     save_rds(obj, file)
[10:19:53.038]                   }
[10:19:53.038]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.038]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.038]                   {
[10:19:53.038]                     inherits <- base::inherits
[10:19:53.038]                     invokeRestart <- base::invokeRestart
[10:19:53.038]                     is.null <- base::is.null
[10:19:53.038]                     muffled <- FALSE
[10:19:53.038]                     if (inherits(cond, "message")) {
[10:19:53.038]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.038]                       if (muffled) 
[10:19:53.038]                         invokeRestart("muffleMessage")
[10:19:53.038]                     }
[10:19:53.038]                     else if (inherits(cond, "warning")) {
[10:19:53.038]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.038]                       if (muffled) 
[10:19:53.038]                         invokeRestart("muffleWarning")
[10:19:53.038]                     }
[10:19:53.038]                     else if (inherits(cond, "condition")) {
[10:19:53.038]                       if (!is.null(pattern)) {
[10:19:53.038]                         computeRestarts <- base::computeRestarts
[10:19:53.038]                         grepl <- base::grepl
[10:19:53.038]                         restarts <- computeRestarts(cond)
[10:19:53.038]                         for (restart in restarts) {
[10:19:53.038]                           name <- restart$name
[10:19:53.038]                           if (is.null(name)) 
[10:19:53.038]                             next
[10:19:53.038]                           if (!grepl(pattern, name)) 
[10:19:53.038]                             next
[10:19:53.038]                           invokeRestart(restart)
[10:19:53.038]                           muffled <- TRUE
[10:19:53.038]                           break
[10:19:53.038]                         }
[10:19:53.038]                       }
[10:19:53.038]                     }
[10:19:53.038]                     invisible(muffled)
[10:19:53.038]                   }
[10:19:53.038]                   muffleCondition(cond)
[10:19:53.038]                 })
[10:19:53.038]             }))
[10:19:53.038]             future::FutureResult(value = ...future.value$value, 
[10:19:53.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.038]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.038]                     ...future.globalenv.names))
[10:19:53.038]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.038]         }, condition = base::local({
[10:19:53.038]             c <- base::c
[10:19:53.038]             inherits <- base::inherits
[10:19:53.038]             invokeRestart <- base::invokeRestart
[10:19:53.038]             length <- base::length
[10:19:53.038]             list <- base::list
[10:19:53.038]             seq.int <- base::seq.int
[10:19:53.038]             signalCondition <- base::signalCondition
[10:19:53.038]             sys.calls <- base::sys.calls
[10:19:53.038]             `[[` <- base::`[[`
[10:19:53.038]             `+` <- base::`+`
[10:19:53.038]             `<<-` <- base::`<<-`
[10:19:53.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.038]                   3L)]
[10:19:53.038]             }
[10:19:53.038]             function(cond) {
[10:19:53.038]                 is_error <- inherits(cond, "error")
[10:19:53.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.038]                   NULL)
[10:19:53.038]                 if (is_error) {
[10:19:53.038]                   sessionInformation <- function() {
[10:19:53.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.038]                       search = base::search(), system = base::Sys.info())
[10:19:53.038]                   }
[10:19:53.038]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.038]                     cond$call), session = sessionInformation(), 
[10:19:53.038]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.038]                   signalCondition(cond)
[10:19:53.038]                 }
[10:19:53.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.038]                 "immediateCondition"))) {
[10:19:53.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.038]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.038]                   if (TRUE && !signal) {
[10:19:53.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.038]                     {
[10:19:53.038]                       inherits <- base::inherits
[10:19:53.038]                       invokeRestart <- base::invokeRestart
[10:19:53.038]                       is.null <- base::is.null
[10:19:53.038]                       muffled <- FALSE
[10:19:53.038]                       if (inherits(cond, "message")) {
[10:19:53.038]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.038]                         if (muffled) 
[10:19:53.038]                           invokeRestart("muffleMessage")
[10:19:53.038]                       }
[10:19:53.038]                       else if (inherits(cond, "warning")) {
[10:19:53.038]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.038]                         if (muffled) 
[10:19:53.038]                           invokeRestart("muffleWarning")
[10:19:53.038]                       }
[10:19:53.038]                       else if (inherits(cond, "condition")) {
[10:19:53.038]                         if (!is.null(pattern)) {
[10:19:53.038]                           computeRestarts <- base::computeRestarts
[10:19:53.038]                           grepl <- base::grepl
[10:19:53.038]                           restarts <- computeRestarts(cond)
[10:19:53.038]                           for (restart in restarts) {
[10:19:53.038]                             name <- restart$name
[10:19:53.038]                             if (is.null(name)) 
[10:19:53.038]                               next
[10:19:53.038]                             if (!grepl(pattern, name)) 
[10:19:53.038]                               next
[10:19:53.038]                             invokeRestart(restart)
[10:19:53.038]                             muffled <- TRUE
[10:19:53.038]                             break
[10:19:53.038]                           }
[10:19:53.038]                         }
[10:19:53.038]                       }
[10:19:53.038]                       invisible(muffled)
[10:19:53.038]                     }
[10:19:53.038]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.038]                   }
[10:19:53.038]                 }
[10:19:53.038]                 else {
[10:19:53.038]                   if (TRUE) {
[10:19:53.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.038]                     {
[10:19:53.038]                       inherits <- base::inherits
[10:19:53.038]                       invokeRestart <- base::invokeRestart
[10:19:53.038]                       is.null <- base::is.null
[10:19:53.038]                       muffled <- FALSE
[10:19:53.038]                       if (inherits(cond, "message")) {
[10:19:53.038]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.038]                         if (muffled) 
[10:19:53.038]                           invokeRestart("muffleMessage")
[10:19:53.038]                       }
[10:19:53.038]                       else if (inherits(cond, "warning")) {
[10:19:53.038]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.038]                         if (muffled) 
[10:19:53.038]                           invokeRestart("muffleWarning")
[10:19:53.038]                       }
[10:19:53.038]                       else if (inherits(cond, "condition")) {
[10:19:53.038]                         if (!is.null(pattern)) {
[10:19:53.038]                           computeRestarts <- base::computeRestarts
[10:19:53.038]                           grepl <- base::grepl
[10:19:53.038]                           restarts <- computeRestarts(cond)
[10:19:53.038]                           for (restart in restarts) {
[10:19:53.038]                             name <- restart$name
[10:19:53.038]                             if (is.null(name)) 
[10:19:53.038]                               next
[10:19:53.038]                             if (!grepl(pattern, name)) 
[10:19:53.038]                               next
[10:19:53.038]                             invokeRestart(restart)
[10:19:53.038]                             muffled <- TRUE
[10:19:53.038]                             break
[10:19:53.038]                           }
[10:19:53.038]                         }
[10:19:53.038]                       }
[10:19:53.038]                       invisible(muffled)
[10:19:53.038]                     }
[10:19:53.038]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.038]                   }
[10:19:53.038]                 }
[10:19:53.038]             }
[10:19:53.038]         }))
[10:19:53.038]     }, error = function(ex) {
[10:19:53.038]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.038]                 ...future.rng), started = ...future.startTime, 
[10:19:53.038]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.038]             version = "1.8"), class = "FutureResult")
[10:19:53.038]     }, finally = {
[10:19:53.038]         if (!identical(...future.workdir, getwd())) 
[10:19:53.038]             setwd(...future.workdir)
[10:19:53.038]         {
[10:19:53.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.038]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.038]             }
[10:19:53.038]             base::options(...future.oldOptions)
[10:19:53.038]             if (.Platform$OS.type == "windows") {
[10:19:53.038]                 old_names <- names(...future.oldEnvVars)
[10:19:53.038]                 envs <- base::Sys.getenv()
[10:19:53.038]                 names <- names(envs)
[10:19:53.038]                 common <- intersect(names, old_names)
[10:19:53.038]                 added <- setdiff(names, old_names)
[10:19:53.038]                 removed <- setdiff(old_names, names)
[10:19:53.038]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.038]                   envs[common]]
[10:19:53.038]                 NAMES <- toupper(changed)
[10:19:53.038]                 args <- list()
[10:19:53.038]                 for (kk in seq_along(NAMES)) {
[10:19:53.038]                   name <- changed[[kk]]
[10:19:53.038]                   NAME <- NAMES[[kk]]
[10:19:53.038]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.038]                     next
[10:19:53.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.038]                 }
[10:19:53.038]                 NAMES <- toupper(added)
[10:19:53.038]                 for (kk in seq_along(NAMES)) {
[10:19:53.038]                   name <- added[[kk]]
[10:19:53.038]                   NAME <- NAMES[[kk]]
[10:19:53.038]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.038]                     next
[10:19:53.038]                   args[[name]] <- ""
[10:19:53.038]                 }
[10:19:53.038]                 NAMES <- toupper(removed)
[10:19:53.038]                 for (kk in seq_along(NAMES)) {
[10:19:53.038]                   name <- removed[[kk]]
[10:19:53.038]                   NAME <- NAMES[[kk]]
[10:19:53.038]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.038]                     next
[10:19:53.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.038]                 }
[10:19:53.038]                 if (length(args) > 0) 
[10:19:53.038]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.038]             }
[10:19:53.038]             else {
[10:19:53.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.038]             }
[10:19:53.038]             {
[10:19:53.038]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.038]                   0L) {
[10:19:53.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.038]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.038]                   base::options(opts)
[10:19:53.038]                 }
[10:19:53.038]                 {
[10:19:53.038]                   {
[10:19:53.038]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.038]                     NULL
[10:19:53.038]                   }
[10:19:53.038]                   options(future.plan = NULL)
[10:19:53.038]                   if (is.na(NA_character_)) 
[10:19:53.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.038]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.038]                     .init = FALSE)
[10:19:53.038]                 }
[10:19:53.038]             }
[10:19:53.038]         }
[10:19:53.038]     })
[10:19:53.038]     if (TRUE) {
[10:19:53.038]         base::sink(type = "output", split = FALSE)
[10:19:53.038]         if (TRUE) {
[10:19:53.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.038]         }
[10:19:53.038]         else {
[10:19:53.038]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.038]         }
[10:19:53.038]         base::close(...future.stdout)
[10:19:53.038]         ...future.stdout <- NULL
[10:19:53.038]     }
[10:19:53.038]     ...future.result$conditions <- ...future.conditions
[10:19:53.038]     ...future.result$finished <- base::Sys.time()
[10:19:53.038]     ...future.result
[10:19:53.038] }
[10:19:53.041] assign_globals() ...
[10:19:53.041] List of 5
[10:19:53.041]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:19:53.041]  $ future.call.arguments    : list()
[10:19:53.041]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.041]  $ ...future.elements_ii    :List of 4
[10:19:53.041]   ..$ : int [1:3] 1 2 3
[10:19:53.041]   ..$ : int [1:4] 1 2 3 4
[10:19:53.041]   ..$ : int [1:5] 1 2 3 4 5
[10:19:53.041]   ..$ : int [1:6] 1 2 3 4 5 6
[10:19:53.041]  $ ...future.seeds_ii       : NULL
[10:19:53.041]  $ ...future.globals.maxSize: NULL
[10:19:53.041]  - attr(*, "where")=List of 5
[10:19:53.041]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.041]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.041]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.041]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.041]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.041]  - attr(*, "resolved")= logi FALSE
[10:19:53.041]  - attr(*, "total_size")= num 18895
[10:19:53.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.041]  - attr(*, "already-done")= logi TRUE
[10:19:53.048] - copied ‘...future.FUN’ to environment
[10:19:53.048] - copied ‘future.call.arguments’ to environment
[10:19:53.048] - copied ‘...future.elements_ii’ to environment
[10:19:53.048] - copied ‘...future.seeds_ii’ to environment
[10:19:53.049] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.049] assign_globals() ... done
[10:19:53.049] requestCore(): workers = 2
[10:19:53.051] MulticoreFuture started
[10:19:53.052] - Launch lazy future ... done
[10:19:53.052] run() for ‘MulticoreFuture’ ... done
[10:19:53.053] Created future:
[10:19:53.053] plan(): Setting new future strategy stack:
[10:19:53.053] List of future strategies:
[10:19:53.053] 1. sequential:
[10:19:53.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.053]    - tweaked: FALSE
[10:19:53.053]    - call: NULL
[10:19:53.055] plan(): nbrOfWorkers() = 1
[10:19:53.058] plan(): Setting new future strategy stack:
[10:19:53.058] List of future strategies:
[10:19:53.058] 1. multicore:
[10:19:53.058]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.058]    - tweaked: FALSE
[10:19:53.058]    - call: plan(strategy)
[10:19:53.063] plan(): nbrOfWorkers() = 2
[10:19:53.053] MulticoreFuture:
[10:19:53.053] Label: ‘future_sapply-1’
[10:19:53.053] Expression:
[10:19:53.053] {
[10:19:53.053]     do.call(function(...) {
[10:19:53.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.053]             on.exit(options(oopts), add = TRUE)
[10:19:53.053]         }
[10:19:53.053]         {
[10:19:53.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.053]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.053]             })
[10:19:53.053]         }
[10:19:53.053]     }, args = future.call.arguments)
[10:19:53.053] }
[10:19:53.053] Lazy evaluation: FALSE
[10:19:53.053] Asynchronous evaluation: TRUE
[10:19:53.053] Local evaluation: TRUE
[10:19:53.053] Environment: R_GlobalEnv
[10:19:53.053] Capture standard output: TRUE
[10:19:53.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.053] Globals: 5 objects totaling 5.17 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 369 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:53.053] Packages: 1 packages (‘stats’)
[10:19:53.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.053] Resolved: TRUE
[10:19:53.053] Value: <not collected>
[10:19:53.053] Conditions captured: <none>
[10:19:53.053] Early signaling: FALSE
[10:19:53.053] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.053] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.064] Chunk #1 of 2 ... DONE
[10:19:53.064] Chunk #2 of 2 ...
[10:19:53.065]  - Finding globals in 'X' for chunk #2 ...
[10:19:53.065] getGlobalsAndPackages() ...
[10:19:53.065] Searching for globals...
[10:19:53.066] 
[10:19:53.066] Searching for globals ... DONE
[10:19:53.066] - globals: [0] <none>
[10:19:53.066] getGlobalsAndPackages() ... DONE
[10:19:53.067]    + additional globals found: [n=0] 
[10:19:53.067]    + additional namespaces needed: [n=0] 
[10:19:53.067]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:53.067]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.067]  - seeds: <none>
[10:19:53.067]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.068] getGlobalsAndPackages() ...
[10:19:53.068] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.068] Resolving globals: FALSE
[10:19:53.068] Tweak future expression to call with '...' arguments ...
[10:19:53.068] {
[10:19:53.068]     do.call(function(...) {
[10:19:53.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.068]             on.exit(options(oopts), add = TRUE)
[10:19:53.068]         }
[10:19:53.068]         {
[10:19:53.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.068]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.068]             })
[10:19:53.068]         }
[10:19:53.068]     }, args = future.call.arguments)
[10:19:53.068] }
[10:19:53.069] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.069] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.070] - packages: [1] ‘stats’
[10:19:53.070] getGlobalsAndPackages() ... DONE
[10:19:53.070] run() for ‘Future’ ...
[10:19:53.070] - state: ‘created’
[10:19:53.071] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.073] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.074]   - Field: ‘label’
[10:19:53.074]   - Field: ‘local’
[10:19:53.074]   - Field: ‘owner’
[10:19:53.074]   - Field: ‘envir’
[10:19:53.074]   - Field: ‘workers’
[10:19:53.074]   - Field: ‘packages’
[10:19:53.074]   - Field: ‘gc’
[10:19:53.075]   - Field: ‘job’
[10:19:53.075]   - Field: ‘conditions’
[10:19:53.075]   - Field: ‘expr’
[10:19:53.075]   - Field: ‘uuid’
[10:19:53.075]   - Field: ‘seed’
[10:19:53.075]   - Field: ‘version’
[10:19:53.075]   - Field: ‘result’
[10:19:53.076]   - Field: ‘asynchronous’
[10:19:53.076]   - Field: ‘calls’
[10:19:53.076]   - Field: ‘globals’
[10:19:53.076]   - Field: ‘stdout’
[10:19:53.076]   - Field: ‘earlySignal’
[10:19:53.076]   - Field: ‘lazy’
[10:19:53.076]   - Field: ‘state’
[10:19:53.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.077] - Launch lazy future ...
[10:19:53.077] Packages needed by the future expression (n = 1): ‘stats’
[10:19:53.077] Packages needed by future strategies (n = 0): <none>
[10:19:53.078] {
[10:19:53.078]     {
[10:19:53.078]         {
[10:19:53.078]             ...future.startTime <- base::Sys.time()
[10:19:53.078]             {
[10:19:53.078]                 {
[10:19:53.078]                   {
[10:19:53.078]                     {
[10:19:53.078]                       {
[10:19:53.078]                         base::local({
[10:19:53.078]                           has_future <- base::requireNamespace("future", 
[10:19:53.078]                             quietly = TRUE)
[10:19:53.078]                           if (has_future) {
[10:19:53.078]                             ns <- base::getNamespace("future")
[10:19:53.078]                             version <- ns[[".package"]][["version"]]
[10:19:53.078]                             if (is.null(version)) 
[10:19:53.078]                               version <- utils::packageVersion("future")
[10:19:53.078]                           }
[10:19:53.078]                           else {
[10:19:53.078]                             version <- NULL
[10:19:53.078]                           }
[10:19:53.078]                           if (!has_future || version < "1.8.0") {
[10:19:53.078]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.078]                               "", base::R.version$version.string), 
[10:19:53.078]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.078]                                 base::R.version$platform, 8 * 
[10:19:53.078]                                   base::.Machine$sizeof.pointer), 
[10:19:53.078]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.078]                                 "release", "version")], collapse = " "), 
[10:19:53.078]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.078]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.078]                               info)
[10:19:53.078]                             info <- base::paste(info, collapse = "; ")
[10:19:53.078]                             if (!has_future) {
[10:19:53.078]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.078]                                 info)
[10:19:53.078]                             }
[10:19:53.078]                             else {
[10:19:53.078]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.078]                                 info, version)
[10:19:53.078]                             }
[10:19:53.078]                             base::stop(msg)
[10:19:53.078]                           }
[10:19:53.078]                         })
[10:19:53.078]                       }
[10:19:53.078]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.078]                       base::options(mc.cores = 1L)
[10:19:53.078]                     }
[10:19:53.078]                     base::local({
[10:19:53.078]                       for (pkg in "stats") {
[10:19:53.078]                         base::loadNamespace(pkg)
[10:19:53.078]                         base::library(pkg, character.only = TRUE)
[10:19:53.078]                       }
[10:19:53.078]                     })
[10:19:53.078]                   }
[10:19:53.078]                   ...future.strategy.old <- future::plan("list")
[10:19:53.078]                   options(future.plan = NULL)
[10:19:53.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.078]                 }
[10:19:53.078]                 ...future.workdir <- getwd()
[10:19:53.078]             }
[10:19:53.078]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.078]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.078]         }
[10:19:53.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.078]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.078]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.078]             base::names(...future.oldOptions))
[10:19:53.078]     }
[10:19:53.078]     if (FALSE) {
[10:19:53.078]     }
[10:19:53.078]     else {
[10:19:53.078]         if (TRUE) {
[10:19:53.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.078]                 open = "w")
[10:19:53.078]         }
[10:19:53.078]         else {
[10:19:53.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.078]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.078]         }
[10:19:53.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.078]             base::sink(type = "output", split = FALSE)
[10:19:53.078]             base::close(...future.stdout)
[10:19:53.078]         }, add = TRUE)
[10:19:53.078]     }
[10:19:53.078]     ...future.frame <- base::sys.nframe()
[10:19:53.078]     ...future.conditions <- base::list()
[10:19:53.078]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.078]     if (FALSE) {
[10:19:53.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.078]     }
[10:19:53.078]     ...future.result <- base::tryCatch({
[10:19:53.078]         base::withCallingHandlers({
[10:19:53.078]             ...future.value <- base::withVisible(base::local({
[10:19:53.078]                 withCallingHandlers({
[10:19:53.078]                   {
[10:19:53.078]                     do.call(function(...) {
[10:19:53.078]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.078]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.078]                         ...future.globals.maxSize)) {
[10:19:53.078]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.078]                         on.exit(options(oopts), add = TRUE)
[10:19:53.078]                       }
[10:19:53.078]                       {
[10:19:53.078]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.078]                           FUN = function(jj) {
[10:19:53.078]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.078]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.078]                           })
[10:19:53.078]                       }
[10:19:53.078]                     }, args = future.call.arguments)
[10:19:53.078]                   }
[10:19:53.078]                 }, immediateCondition = function(cond) {
[10:19:53.078]                   save_rds <- function (object, pathname, ...) 
[10:19:53.078]                   {
[10:19:53.078]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.078]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.078]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.078]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.078]                         fi_tmp[["mtime"]])
[10:19:53.078]                     }
[10:19:53.078]                     tryCatch({
[10:19:53.078]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.078]                     }, error = function(ex) {
[10:19:53.078]                       msg <- conditionMessage(ex)
[10:19:53.078]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.078]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.078]                         fi_tmp[["mtime"]], msg)
[10:19:53.078]                       ex$message <- msg
[10:19:53.078]                       stop(ex)
[10:19:53.078]                     })
[10:19:53.078]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.078]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.078]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.078]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.078]                       fi <- file.info(pathname)
[10:19:53.078]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.078]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.078]                         fi[["size"]], fi[["mtime"]])
[10:19:53.078]                       stop(msg)
[10:19:53.078]                     }
[10:19:53.078]                     invisible(pathname)
[10:19:53.078]                   }
[10:19:53.078]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.078]                     rootPath = tempdir()) 
[10:19:53.078]                   {
[10:19:53.078]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.078]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.078]                       tmpdir = path, fileext = ".rds")
[10:19:53.078]                     save_rds(obj, file)
[10:19:53.078]                   }
[10:19:53.078]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.078]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.078]                   {
[10:19:53.078]                     inherits <- base::inherits
[10:19:53.078]                     invokeRestart <- base::invokeRestart
[10:19:53.078]                     is.null <- base::is.null
[10:19:53.078]                     muffled <- FALSE
[10:19:53.078]                     if (inherits(cond, "message")) {
[10:19:53.078]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.078]                       if (muffled) 
[10:19:53.078]                         invokeRestart("muffleMessage")
[10:19:53.078]                     }
[10:19:53.078]                     else if (inherits(cond, "warning")) {
[10:19:53.078]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.078]                       if (muffled) 
[10:19:53.078]                         invokeRestart("muffleWarning")
[10:19:53.078]                     }
[10:19:53.078]                     else if (inherits(cond, "condition")) {
[10:19:53.078]                       if (!is.null(pattern)) {
[10:19:53.078]                         computeRestarts <- base::computeRestarts
[10:19:53.078]                         grepl <- base::grepl
[10:19:53.078]                         restarts <- computeRestarts(cond)
[10:19:53.078]                         for (restart in restarts) {
[10:19:53.078]                           name <- restart$name
[10:19:53.078]                           if (is.null(name)) 
[10:19:53.078]                             next
[10:19:53.078]                           if (!grepl(pattern, name)) 
[10:19:53.078]                             next
[10:19:53.078]                           invokeRestart(restart)
[10:19:53.078]                           muffled <- TRUE
[10:19:53.078]                           break
[10:19:53.078]                         }
[10:19:53.078]                       }
[10:19:53.078]                     }
[10:19:53.078]                     invisible(muffled)
[10:19:53.078]                   }
[10:19:53.078]                   muffleCondition(cond)
[10:19:53.078]                 })
[10:19:53.078]             }))
[10:19:53.078]             future::FutureResult(value = ...future.value$value, 
[10:19:53.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.078]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.078]                     ...future.globalenv.names))
[10:19:53.078]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.078]         }, condition = base::local({
[10:19:53.078]             c <- base::c
[10:19:53.078]             inherits <- base::inherits
[10:19:53.078]             invokeRestart <- base::invokeRestart
[10:19:53.078]             length <- base::length
[10:19:53.078]             list <- base::list
[10:19:53.078]             seq.int <- base::seq.int
[10:19:53.078]             signalCondition <- base::signalCondition
[10:19:53.078]             sys.calls <- base::sys.calls
[10:19:53.078]             `[[` <- base::`[[`
[10:19:53.078]             `+` <- base::`+`
[10:19:53.078]             `<<-` <- base::`<<-`
[10:19:53.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.078]                   3L)]
[10:19:53.078]             }
[10:19:53.078]             function(cond) {
[10:19:53.078]                 is_error <- inherits(cond, "error")
[10:19:53.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.078]                   NULL)
[10:19:53.078]                 if (is_error) {
[10:19:53.078]                   sessionInformation <- function() {
[10:19:53.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.078]                       search = base::search(), system = base::Sys.info())
[10:19:53.078]                   }
[10:19:53.078]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.078]                     cond$call), session = sessionInformation(), 
[10:19:53.078]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.078]                   signalCondition(cond)
[10:19:53.078]                 }
[10:19:53.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.078]                 "immediateCondition"))) {
[10:19:53.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.078]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.078]                   if (TRUE && !signal) {
[10:19:53.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.078]                     {
[10:19:53.078]                       inherits <- base::inherits
[10:19:53.078]                       invokeRestart <- base::invokeRestart
[10:19:53.078]                       is.null <- base::is.null
[10:19:53.078]                       muffled <- FALSE
[10:19:53.078]                       if (inherits(cond, "message")) {
[10:19:53.078]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.078]                         if (muffled) 
[10:19:53.078]                           invokeRestart("muffleMessage")
[10:19:53.078]                       }
[10:19:53.078]                       else if (inherits(cond, "warning")) {
[10:19:53.078]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.078]                         if (muffled) 
[10:19:53.078]                           invokeRestart("muffleWarning")
[10:19:53.078]                       }
[10:19:53.078]                       else if (inherits(cond, "condition")) {
[10:19:53.078]                         if (!is.null(pattern)) {
[10:19:53.078]                           computeRestarts <- base::computeRestarts
[10:19:53.078]                           grepl <- base::grepl
[10:19:53.078]                           restarts <- computeRestarts(cond)
[10:19:53.078]                           for (restart in restarts) {
[10:19:53.078]                             name <- restart$name
[10:19:53.078]                             if (is.null(name)) 
[10:19:53.078]                               next
[10:19:53.078]                             if (!grepl(pattern, name)) 
[10:19:53.078]                               next
[10:19:53.078]                             invokeRestart(restart)
[10:19:53.078]                             muffled <- TRUE
[10:19:53.078]                             break
[10:19:53.078]                           }
[10:19:53.078]                         }
[10:19:53.078]                       }
[10:19:53.078]                       invisible(muffled)
[10:19:53.078]                     }
[10:19:53.078]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.078]                   }
[10:19:53.078]                 }
[10:19:53.078]                 else {
[10:19:53.078]                   if (TRUE) {
[10:19:53.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.078]                     {
[10:19:53.078]                       inherits <- base::inherits
[10:19:53.078]                       invokeRestart <- base::invokeRestart
[10:19:53.078]                       is.null <- base::is.null
[10:19:53.078]                       muffled <- FALSE
[10:19:53.078]                       if (inherits(cond, "message")) {
[10:19:53.078]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.078]                         if (muffled) 
[10:19:53.078]                           invokeRestart("muffleMessage")
[10:19:53.078]                       }
[10:19:53.078]                       else if (inherits(cond, "warning")) {
[10:19:53.078]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.078]                         if (muffled) 
[10:19:53.078]                           invokeRestart("muffleWarning")
[10:19:53.078]                       }
[10:19:53.078]                       else if (inherits(cond, "condition")) {
[10:19:53.078]                         if (!is.null(pattern)) {
[10:19:53.078]                           computeRestarts <- base::computeRestarts
[10:19:53.078]                           grepl <- base::grepl
[10:19:53.078]                           restarts <- computeRestarts(cond)
[10:19:53.078]                           for (restart in restarts) {
[10:19:53.078]                             name <- restart$name
[10:19:53.078]                             if (is.null(name)) 
[10:19:53.078]                               next
[10:19:53.078]                             if (!grepl(pattern, name)) 
[10:19:53.078]                               next
[10:19:53.078]                             invokeRestart(restart)
[10:19:53.078]                             muffled <- TRUE
[10:19:53.078]                             break
[10:19:53.078]                           }
[10:19:53.078]                         }
[10:19:53.078]                       }
[10:19:53.078]                       invisible(muffled)
[10:19:53.078]                     }
[10:19:53.078]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.078]                   }
[10:19:53.078]                 }
[10:19:53.078]             }
[10:19:53.078]         }))
[10:19:53.078]     }, error = function(ex) {
[10:19:53.078]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.078]                 ...future.rng), started = ...future.startTime, 
[10:19:53.078]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.078]             version = "1.8"), class = "FutureResult")
[10:19:53.078]     }, finally = {
[10:19:53.078]         if (!identical(...future.workdir, getwd())) 
[10:19:53.078]             setwd(...future.workdir)
[10:19:53.078]         {
[10:19:53.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.078]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.078]             }
[10:19:53.078]             base::options(...future.oldOptions)
[10:19:53.078]             if (.Platform$OS.type == "windows") {
[10:19:53.078]                 old_names <- names(...future.oldEnvVars)
[10:19:53.078]                 envs <- base::Sys.getenv()
[10:19:53.078]                 names <- names(envs)
[10:19:53.078]                 common <- intersect(names, old_names)
[10:19:53.078]                 added <- setdiff(names, old_names)
[10:19:53.078]                 removed <- setdiff(old_names, names)
[10:19:53.078]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.078]                   envs[common]]
[10:19:53.078]                 NAMES <- toupper(changed)
[10:19:53.078]                 args <- list()
[10:19:53.078]                 for (kk in seq_along(NAMES)) {
[10:19:53.078]                   name <- changed[[kk]]
[10:19:53.078]                   NAME <- NAMES[[kk]]
[10:19:53.078]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.078]                     next
[10:19:53.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.078]                 }
[10:19:53.078]                 NAMES <- toupper(added)
[10:19:53.078]                 for (kk in seq_along(NAMES)) {
[10:19:53.078]                   name <- added[[kk]]
[10:19:53.078]                   NAME <- NAMES[[kk]]
[10:19:53.078]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.078]                     next
[10:19:53.078]                   args[[name]] <- ""
[10:19:53.078]                 }
[10:19:53.078]                 NAMES <- toupper(removed)
[10:19:53.078]                 for (kk in seq_along(NAMES)) {
[10:19:53.078]                   name <- removed[[kk]]
[10:19:53.078]                   NAME <- NAMES[[kk]]
[10:19:53.078]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.078]                     next
[10:19:53.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.078]                 }
[10:19:53.078]                 if (length(args) > 0) 
[10:19:53.078]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.078]             }
[10:19:53.078]             else {
[10:19:53.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.078]             }
[10:19:53.078]             {
[10:19:53.078]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.078]                   0L) {
[10:19:53.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.078]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.078]                   base::options(opts)
[10:19:53.078]                 }
[10:19:53.078]                 {
[10:19:53.078]                   {
[10:19:53.078]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.078]                     NULL
[10:19:53.078]                   }
[10:19:53.078]                   options(future.plan = NULL)
[10:19:53.078]                   if (is.na(NA_character_)) 
[10:19:53.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.078]                     .init = FALSE)
[10:19:53.078]                 }
[10:19:53.078]             }
[10:19:53.078]         }
[10:19:53.078]     })
[10:19:53.078]     if (TRUE) {
[10:19:53.078]         base::sink(type = "output", split = FALSE)
[10:19:53.078]         if (TRUE) {
[10:19:53.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.078]         }
[10:19:53.078]         else {
[10:19:53.078]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.078]         }
[10:19:53.078]         base::close(...future.stdout)
[10:19:53.078]         ...future.stdout <- NULL
[10:19:53.078]     }
[10:19:53.078]     ...future.result$conditions <- ...future.conditions
[10:19:53.078]     ...future.result$finished <- base::Sys.time()
[10:19:53.078]     ...future.result
[10:19:53.078] }
[10:19:53.081] assign_globals() ...
[10:19:53.082] List of 5
[10:19:53.082]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:19:53.082]  $ future.call.arguments    : list()
[10:19:53.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.082]  $ ...future.elements_ii    :List of 3
[10:19:53.082]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:19:53.082]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:19:53.082]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:19:53.082]  $ ...future.seeds_ii       : NULL
[10:19:53.082]  $ ...future.globals.maxSize: NULL
[10:19:53.082]  - attr(*, "where")=List of 5
[10:19:53.082]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.082]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.082]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.082]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.082]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.082]  - attr(*, "resolved")= logi FALSE
[10:19:53.082]  - attr(*, "total_size")= num 18895
[10:19:53.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.082]  - attr(*, "already-done")= logi TRUE
[10:19:53.089] - copied ‘...future.FUN’ to environment
[10:19:53.089] - copied ‘future.call.arguments’ to environment
[10:19:53.089] - copied ‘...future.elements_ii’ to environment
[10:19:53.089] - copied ‘...future.seeds_ii’ to environment
[10:19:53.089] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.089] assign_globals() ... done
[10:19:53.089] requestCore(): workers = 2
[10:19:53.092] MulticoreFuture started
[10:19:53.092] - Launch lazy future ... done
[10:19:53.092] run() for ‘MulticoreFuture’ ... done
[10:19:53.093] Created future:
[10:19:53.093] plan(): Setting new future strategy stack:
[10:19:53.097] List of future strategies:
[10:19:53.097] 1. sequential:
[10:19:53.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.097]    - tweaked: FALSE
[10:19:53.097]    - call: NULL
[10:19:53.099] plan(): nbrOfWorkers() = 1
[10:19:53.102] plan(): Setting new future strategy stack:
[10:19:53.102] List of future strategies:
[10:19:53.102] 1. multicore:
[10:19:53.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.102]    - tweaked: FALSE
[10:19:53.102]    - call: plan(strategy)
[10:19:53.106] plan(): nbrOfWorkers() = 2
[10:19:53.097] MulticoreFuture:
[10:19:53.097] Label: ‘future_sapply-2’
[10:19:53.097] Expression:
[10:19:53.097] {
[10:19:53.097]     do.call(function(...) {
[10:19:53.097]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.097]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.097]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.097]             on.exit(options(oopts), add = TRUE)
[10:19:53.097]         }
[10:19:53.097]         {
[10:19:53.097]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.097]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.097]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.097]             })
[10:19:53.097]         }
[10:19:53.097]     }, args = future.call.arguments)
[10:19:53.097] }
[10:19:53.097] Lazy evaluation: FALSE
[10:19:53.097] Asynchronous evaluation: TRUE
[10:19:53.097] Local evaluation: TRUE
[10:19:53.097] Environment: R_GlobalEnv
[10:19:53.097] Capture standard output: TRUE
[10:19:53.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.097] Globals: 5 objects totaling 5.10 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 293 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:53.097] Packages: 1 packages (‘stats’)
[10:19:53.097] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.097] Resolved: TRUE
[10:19:53.097] Value: <not collected>
[10:19:53.097] Conditions captured: <none>
[10:19:53.097] Early signaling: FALSE
[10:19:53.097] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.097] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.108] Chunk #2 of 2 ... DONE
[10:19:53.108] Launching 2 futures (chunks) ... DONE
[10:19:53.108] Resolving 2 futures (chunks) ...
[10:19:53.108] resolve() on list ...
[10:19:53.108]  recursive: 0
[10:19:53.109]  length: 2
[10:19:53.109] 
[10:19:53.109] Future #1
[10:19:53.110] result() for MulticoreFuture ...
[10:19:53.111] result() for MulticoreFuture ...
[10:19:53.111] result() for MulticoreFuture ... done
[10:19:53.112] result() for MulticoreFuture ... done
[10:19:53.112] result() for MulticoreFuture ...
[10:19:53.112] result() for MulticoreFuture ... done
[10:19:53.113] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:53.113] - nx: 2
[10:19:53.113] - relay: TRUE
[10:19:53.113] - stdout: TRUE
[10:19:53.113] - signal: TRUE
[10:19:53.114] - resignal: FALSE
[10:19:53.114] - force: TRUE
[10:19:53.114] - relayed: [n=2] FALSE, FALSE
[10:19:53.114] - queued futures: [n=2] FALSE, FALSE
[10:19:53.115]  - until=1
[10:19:53.115]  - relaying element #1
[10:19:53.115] result() for MulticoreFuture ...
[10:19:53.115] result() for MulticoreFuture ... done
[10:19:53.116] result() for MulticoreFuture ...
[10:19:53.116] result() for MulticoreFuture ... done
[10:19:53.116] result() for MulticoreFuture ...
[10:19:53.116] result() for MulticoreFuture ... done
[10:19:53.117] result() for MulticoreFuture ...
[10:19:53.117] result() for MulticoreFuture ... done
[10:19:53.117] - relayed: [n=2] TRUE, FALSE
[10:19:53.117] - queued futures: [n=2] TRUE, FALSE
[10:19:53.117] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:53.118]  length: 1 (resolved future 1)
[10:19:53.118] Future #2
[10:19:53.118] result() for MulticoreFuture ...
[10:19:53.119] result() for MulticoreFuture ...
[10:19:53.119] result() for MulticoreFuture ... done
[10:19:53.119] result() for MulticoreFuture ... done
[10:19:53.119] result() for MulticoreFuture ...
[10:19:53.119] result() for MulticoreFuture ... done
[10:19:53.120] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:53.120] - nx: 2
[10:19:53.120] - relay: TRUE
[10:19:53.120] - stdout: TRUE
[10:19:53.120] - signal: TRUE
[10:19:53.120] - resignal: FALSE
[10:19:53.120] - force: TRUE
[10:19:53.120] - relayed: [n=2] TRUE, FALSE
[10:19:53.120] - queued futures: [n=2] TRUE, FALSE
[10:19:53.121]  - until=2
[10:19:53.121]  - relaying element #2
[10:19:53.121] result() for MulticoreFuture ...
[10:19:53.121] result() for MulticoreFuture ... done
[10:19:53.121] result() for MulticoreFuture ...
[10:19:53.121] result() for MulticoreFuture ... done
[10:19:53.121] result() for MulticoreFuture ...
[10:19:53.121] result() for MulticoreFuture ... done
[10:19:53.122] result() for MulticoreFuture ...
[10:19:53.122] result() for MulticoreFuture ... done
[10:19:53.122] - relayed: [n=2] TRUE, TRUE
[10:19:53.122] - queued futures: [n=2] TRUE, TRUE
[10:19:53.122] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:53.122]  length: 0 (resolved future 2)
[10:19:53.122] Relaying remaining futures
[10:19:53.122] signalConditionsASAP(NULL, pos=0) ...
[10:19:53.122] - nx: 2
[10:19:53.122] - relay: TRUE
[10:19:53.123] - stdout: TRUE
[10:19:53.123] - signal: TRUE
[10:19:53.123] - resignal: FALSE
[10:19:53.123] - force: TRUE
[10:19:53.123] - relayed: [n=2] TRUE, TRUE
[10:19:53.123] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:53.123] - relayed: [n=2] TRUE, TRUE
[10:19:53.123] - queued futures: [n=2] TRUE, TRUE
[10:19:53.123] signalConditionsASAP(NULL, pos=0) ... done
[10:19:53.123] resolve() on list ... DONE
[10:19:53.124] result() for MulticoreFuture ...
[10:19:53.124] result() for MulticoreFuture ... done
[10:19:53.124] result() for MulticoreFuture ...
[10:19:53.124] result() for MulticoreFuture ... done
[10:19:53.124] result() for MulticoreFuture ...
[10:19:53.124] result() for MulticoreFuture ... done
[10:19:53.124] result() for MulticoreFuture ...
[10:19:53.124] result() for MulticoreFuture ... done
[10:19:53.124]  - Number of value chunks collected: 2
[10:19:53.125] Resolving 2 futures (chunks) ... DONE
[10:19:53.125] Reducing values from 2 chunks ...
[10:19:53.125]  - Number of values collected after concatenation: 7
[10:19:53.125]  - Number of values expected: 7
[10:19:53.125] Reducing values from 2 chunks ... DONE
[10:19:53.125] future_lapply() ... DONE
[10:19:53.126] future_lapply() ...
[10:19:53.129] Number of chunks: 2
[10:19:53.129] getGlobalsAndPackagesXApply() ...
[10:19:53.130]  - future.globals: TRUE
[10:19:53.130] getGlobalsAndPackages() ...
[10:19:53.130] Searching for globals...
[10:19:53.140] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:19:53.140] Searching for globals ... DONE
[10:19:53.140] Resolving globals: FALSE
[10:19:53.141] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[10:19:53.142] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[10:19:53.142] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.142] - packages: [2] ‘stats’, ‘future.apply’
[10:19:53.142] getGlobalsAndPackages() ... DONE
[10:19:53.142]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.142]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:19:53.142] Finding globals ... DONE
[10:19:53.142]  - use_args: TRUE
[10:19:53.142]  - Getting '...' globals ...
[10:19:53.143] resolve() on list ...
[10:19:53.143]  recursive: 0
[10:19:53.143]  length: 1
[10:19:53.143]  elements: ‘...’
[10:19:53.143]  length: 0 (resolved future 1)
[10:19:53.143] resolve() on list ... DONE
[10:19:53.143]    - '...' content: [n=0] 
[10:19:53.143] List of 1
[10:19:53.143]  $ ...: list()
[10:19:53.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.143]  - attr(*, "where")=List of 1
[10:19:53.143]   ..$ ...:<environment: 0x55c69f315358> 
[10:19:53.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.143]  - attr(*, "resolved")= logi TRUE
[10:19:53.143]  - attr(*, "total_size")= num NA
[10:19:53.146]  - Getting '...' globals ... DONE
[10:19:53.146] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:53.146] List of 8
[10:19:53.146]  $ ...future.FUN:function (x, ...)  
[10:19:53.146]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:19:53.146]  $ times        : int 5
[10:19:53.146]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.146]  $ stop_if_not  :function (...)  
[10:19:53.146]  $ dim          : NULL
[10:19:53.146]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:53.146]  $ ...          : list()
[10:19:53.146]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.146]  - attr(*, "where")=List of 8
[10:19:53.146]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:53.146]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:53.146]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:53.146]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:53.146]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:53.146]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:53.146]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:53.146]   ..$ ...          :<environment: 0x55c69f315358> 
[10:19:53.146]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.146]  - attr(*, "resolved")= logi FALSE
[10:19:53.146]  - attr(*, "total_size")= num 48005
[10:19:53.151] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:19:53.151] getGlobalsAndPackagesXApply() ... DONE
[10:19:53.152] Number of futures (= number of chunks): 2
[10:19:53.152] Launching 2 futures (chunks) ...
[10:19:53.152] Chunk #1 of 2 ...
[10:19:53.152]  - Finding globals in 'X' for chunk #1 ...
[10:19:53.152] getGlobalsAndPackages() ...
[10:19:53.152] Searching for globals...
[10:19:53.154] 
[10:19:53.154] Searching for globals ... DONE
[10:19:53.154] - globals: [0] <none>
[10:19:53.154] getGlobalsAndPackages() ... DONE
[10:19:53.154]    + additional globals found: [n=0] 
[10:19:53.154]    + additional namespaces needed: [n=0] 
[10:19:53.155]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:53.155]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.155]  - seeds: <none>
[10:19:53.155]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.155] getGlobalsAndPackages() ...
[10:19:53.155] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.155] Resolving globals: FALSE
[10:19:53.155] Tweak future expression to call with '...' arguments ...
[10:19:53.155] {
[10:19:53.155]     do.call(function(...) {
[10:19:53.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.155]             on.exit(options(oopts), add = TRUE)
[10:19:53.155]         }
[10:19:53.155]         {
[10:19:53.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.155]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.155]             })
[10:19:53.155]         }
[10:19:53.155]     }, args = future.call.arguments)
[10:19:53.155] }
[10:19:53.156] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.156] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.156] - packages: [2] ‘stats’, ‘future.apply’
[10:19:53.156] getGlobalsAndPackages() ... DONE
[10:19:53.157] run() for ‘Future’ ...
[10:19:53.157] - state: ‘created’
[10:19:53.157] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.159] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.159]   - Field: ‘label’
[10:19:53.159]   - Field: ‘local’
[10:19:53.159]   - Field: ‘owner’
[10:19:53.159]   - Field: ‘envir’
[10:19:53.159]   - Field: ‘workers’
[10:19:53.159]   - Field: ‘packages’
[10:19:53.159]   - Field: ‘gc’
[10:19:53.159]   - Field: ‘job’
[10:19:53.160]   - Field: ‘conditions’
[10:19:53.160]   - Field: ‘expr’
[10:19:53.160]   - Field: ‘uuid’
[10:19:53.160]   - Field: ‘seed’
[10:19:53.160]   - Field: ‘version’
[10:19:53.160]   - Field: ‘result’
[10:19:53.160]   - Field: ‘asynchronous’
[10:19:53.160]   - Field: ‘calls’
[10:19:53.160]   - Field: ‘globals’
[10:19:53.160]   - Field: ‘stdout’
[10:19:53.160]   - Field: ‘earlySignal’
[10:19:53.160]   - Field: ‘lazy’
[10:19:53.161]   - Field: ‘state’
[10:19:53.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.161] - Launch lazy future ...
[10:19:53.161] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:53.161] Packages needed by future strategies (n = 0): <none>
[10:19:53.162] {
[10:19:53.162]     {
[10:19:53.162]         {
[10:19:53.162]             ...future.startTime <- base::Sys.time()
[10:19:53.162]             {
[10:19:53.162]                 {
[10:19:53.162]                   {
[10:19:53.162]                     {
[10:19:53.162]                       {
[10:19:53.162]                         base::local({
[10:19:53.162]                           has_future <- base::requireNamespace("future", 
[10:19:53.162]                             quietly = TRUE)
[10:19:53.162]                           if (has_future) {
[10:19:53.162]                             ns <- base::getNamespace("future")
[10:19:53.162]                             version <- ns[[".package"]][["version"]]
[10:19:53.162]                             if (is.null(version)) 
[10:19:53.162]                               version <- utils::packageVersion("future")
[10:19:53.162]                           }
[10:19:53.162]                           else {
[10:19:53.162]                             version <- NULL
[10:19:53.162]                           }
[10:19:53.162]                           if (!has_future || version < "1.8.0") {
[10:19:53.162]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.162]                               "", base::R.version$version.string), 
[10:19:53.162]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.162]                                 base::R.version$platform, 8 * 
[10:19:53.162]                                   base::.Machine$sizeof.pointer), 
[10:19:53.162]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.162]                                 "release", "version")], collapse = " "), 
[10:19:53.162]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.162]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.162]                               info)
[10:19:53.162]                             info <- base::paste(info, collapse = "; ")
[10:19:53.162]                             if (!has_future) {
[10:19:53.162]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.162]                                 info)
[10:19:53.162]                             }
[10:19:53.162]                             else {
[10:19:53.162]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.162]                                 info, version)
[10:19:53.162]                             }
[10:19:53.162]                             base::stop(msg)
[10:19:53.162]                           }
[10:19:53.162]                         })
[10:19:53.162]                       }
[10:19:53.162]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.162]                       base::options(mc.cores = 1L)
[10:19:53.162]                     }
[10:19:53.162]                     base::local({
[10:19:53.162]                       for (pkg in c("stats", "future.apply")) {
[10:19:53.162]                         base::loadNamespace(pkg)
[10:19:53.162]                         base::library(pkg, character.only = TRUE)
[10:19:53.162]                       }
[10:19:53.162]                     })
[10:19:53.162]                   }
[10:19:53.162]                   ...future.strategy.old <- future::plan("list")
[10:19:53.162]                   options(future.plan = NULL)
[10:19:53.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.162]                 }
[10:19:53.162]                 ...future.workdir <- getwd()
[10:19:53.162]             }
[10:19:53.162]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.162]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.162]         }
[10:19:53.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.162]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.162]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.162]             base::names(...future.oldOptions))
[10:19:53.162]     }
[10:19:53.162]     if (FALSE) {
[10:19:53.162]     }
[10:19:53.162]     else {
[10:19:53.162]         if (TRUE) {
[10:19:53.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.162]                 open = "w")
[10:19:53.162]         }
[10:19:53.162]         else {
[10:19:53.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.162]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.162]         }
[10:19:53.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.162]             base::sink(type = "output", split = FALSE)
[10:19:53.162]             base::close(...future.stdout)
[10:19:53.162]         }, add = TRUE)
[10:19:53.162]     }
[10:19:53.162]     ...future.frame <- base::sys.nframe()
[10:19:53.162]     ...future.conditions <- base::list()
[10:19:53.162]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.162]     if (FALSE) {
[10:19:53.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.162]     }
[10:19:53.162]     ...future.result <- base::tryCatch({
[10:19:53.162]         base::withCallingHandlers({
[10:19:53.162]             ...future.value <- base::withVisible(base::local({
[10:19:53.162]                 withCallingHandlers({
[10:19:53.162]                   {
[10:19:53.162]                     do.call(function(...) {
[10:19:53.162]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.162]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.162]                         ...future.globals.maxSize)) {
[10:19:53.162]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.162]                         on.exit(options(oopts), add = TRUE)
[10:19:53.162]                       }
[10:19:53.162]                       {
[10:19:53.162]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.162]                           FUN = function(jj) {
[10:19:53.162]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.162]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.162]                           })
[10:19:53.162]                       }
[10:19:53.162]                     }, args = future.call.arguments)
[10:19:53.162]                   }
[10:19:53.162]                 }, immediateCondition = function(cond) {
[10:19:53.162]                   save_rds <- function (object, pathname, ...) 
[10:19:53.162]                   {
[10:19:53.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.162]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.162]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.162]                         fi_tmp[["mtime"]])
[10:19:53.162]                     }
[10:19:53.162]                     tryCatch({
[10:19:53.162]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.162]                     }, error = function(ex) {
[10:19:53.162]                       msg <- conditionMessage(ex)
[10:19:53.162]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.162]                         fi_tmp[["mtime"]], msg)
[10:19:53.162]                       ex$message <- msg
[10:19:53.162]                       stop(ex)
[10:19:53.162]                     })
[10:19:53.162]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.162]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.162]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.162]                       fi <- file.info(pathname)
[10:19:53.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.162]                         fi[["size"]], fi[["mtime"]])
[10:19:53.162]                       stop(msg)
[10:19:53.162]                     }
[10:19:53.162]                     invisible(pathname)
[10:19:53.162]                   }
[10:19:53.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.162]                     rootPath = tempdir()) 
[10:19:53.162]                   {
[10:19:53.162]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.162]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.162]                       tmpdir = path, fileext = ".rds")
[10:19:53.162]                     save_rds(obj, file)
[10:19:53.162]                   }
[10:19:53.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.162]                   {
[10:19:53.162]                     inherits <- base::inherits
[10:19:53.162]                     invokeRestart <- base::invokeRestart
[10:19:53.162]                     is.null <- base::is.null
[10:19:53.162]                     muffled <- FALSE
[10:19:53.162]                     if (inherits(cond, "message")) {
[10:19:53.162]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.162]                       if (muffled) 
[10:19:53.162]                         invokeRestart("muffleMessage")
[10:19:53.162]                     }
[10:19:53.162]                     else if (inherits(cond, "warning")) {
[10:19:53.162]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.162]                       if (muffled) 
[10:19:53.162]                         invokeRestart("muffleWarning")
[10:19:53.162]                     }
[10:19:53.162]                     else if (inherits(cond, "condition")) {
[10:19:53.162]                       if (!is.null(pattern)) {
[10:19:53.162]                         computeRestarts <- base::computeRestarts
[10:19:53.162]                         grepl <- base::grepl
[10:19:53.162]                         restarts <- computeRestarts(cond)
[10:19:53.162]                         for (restart in restarts) {
[10:19:53.162]                           name <- restart$name
[10:19:53.162]                           if (is.null(name)) 
[10:19:53.162]                             next
[10:19:53.162]                           if (!grepl(pattern, name)) 
[10:19:53.162]                             next
[10:19:53.162]                           invokeRestart(restart)
[10:19:53.162]                           muffled <- TRUE
[10:19:53.162]                           break
[10:19:53.162]                         }
[10:19:53.162]                       }
[10:19:53.162]                     }
[10:19:53.162]                     invisible(muffled)
[10:19:53.162]                   }
[10:19:53.162]                   muffleCondition(cond)
[10:19:53.162]                 })
[10:19:53.162]             }))
[10:19:53.162]             future::FutureResult(value = ...future.value$value, 
[10:19:53.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.162]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.162]                     ...future.globalenv.names))
[10:19:53.162]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.162]         }, condition = base::local({
[10:19:53.162]             c <- base::c
[10:19:53.162]             inherits <- base::inherits
[10:19:53.162]             invokeRestart <- base::invokeRestart
[10:19:53.162]             length <- base::length
[10:19:53.162]             list <- base::list
[10:19:53.162]             seq.int <- base::seq.int
[10:19:53.162]             signalCondition <- base::signalCondition
[10:19:53.162]             sys.calls <- base::sys.calls
[10:19:53.162]             `[[` <- base::`[[`
[10:19:53.162]             `+` <- base::`+`
[10:19:53.162]             `<<-` <- base::`<<-`
[10:19:53.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.162]                   3L)]
[10:19:53.162]             }
[10:19:53.162]             function(cond) {
[10:19:53.162]                 is_error <- inherits(cond, "error")
[10:19:53.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.162]                   NULL)
[10:19:53.162]                 if (is_error) {
[10:19:53.162]                   sessionInformation <- function() {
[10:19:53.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.162]                       search = base::search(), system = base::Sys.info())
[10:19:53.162]                   }
[10:19:53.162]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.162]                     cond$call), session = sessionInformation(), 
[10:19:53.162]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.162]                   signalCondition(cond)
[10:19:53.162]                 }
[10:19:53.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.162]                 "immediateCondition"))) {
[10:19:53.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.162]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.162]                   if (TRUE && !signal) {
[10:19:53.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.162]                     {
[10:19:53.162]                       inherits <- base::inherits
[10:19:53.162]                       invokeRestart <- base::invokeRestart
[10:19:53.162]                       is.null <- base::is.null
[10:19:53.162]                       muffled <- FALSE
[10:19:53.162]                       if (inherits(cond, "message")) {
[10:19:53.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.162]                         if (muffled) 
[10:19:53.162]                           invokeRestart("muffleMessage")
[10:19:53.162]                       }
[10:19:53.162]                       else if (inherits(cond, "warning")) {
[10:19:53.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.162]                         if (muffled) 
[10:19:53.162]                           invokeRestart("muffleWarning")
[10:19:53.162]                       }
[10:19:53.162]                       else if (inherits(cond, "condition")) {
[10:19:53.162]                         if (!is.null(pattern)) {
[10:19:53.162]                           computeRestarts <- base::computeRestarts
[10:19:53.162]                           grepl <- base::grepl
[10:19:53.162]                           restarts <- computeRestarts(cond)
[10:19:53.162]                           for (restart in restarts) {
[10:19:53.162]                             name <- restart$name
[10:19:53.162]                             if (is.null(name)) 
[10:19:53.162]                               next
[10:19:53.162]                             if (!grepl(pattern, name)) 
[10:19:53.162]                               next
[10:19:53.162]                             invokeRestart(restart)
[10:19:53.162]                             muffled <- TRUE
[10:19:53.162]                             break
[10:19:53.162]                           }
[10:19:53.162]                         }
[10:19:53.162]                       }
[10:19:53.162]                       invisible(muffled)
[10:19:53.162]                     }
[10:19:53.162]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.162]                   }
[10:19:53.162]                 }
[10:19:53.162]                 else {
[10:19:53.162]                   if (TRUE) {
[10:19:53.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.162]                     {
[10:19:53.162]                       inherits <- base::inherits
[10:19:53.162]                       invokeRestart <- base::invokeRestart
[10:19:53.162]                       is.null <- base::is.null
[10:19:53.162]                       muffled <- FALSE
[10:19:53.162]                       if (inherits(cond, "message")) {
[10:19:53.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.162]                         if (muffled) 
[10:19:53.162]                           invokeRestart("muffleMessage")
[10:19:53.162]                       }
[10:19:53.162]                       else if (inherits(cond, "warning")) {
[10:19:53.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.162]                         if (muffled) 
[10:19:53.162]                           invokeRestart("muffleWarning")
[10:19:53.162]                       }
[10:19:53.162]                       else if (inherits(cond, "condition")) {
[10:19:53.162]                         if (!is.null(pattern)) {
[10:19:53.162]                           computeRestarts <- base::computeRestarts
[10:19:53.162]                           grepl <- base::grepl
[10:19:53.162]                           restarts <- computeRestarts(cond)
[10:19:53.162]                           for (restart in restarts) {
[10:19:53.162]                             name <- restart$name
[10:19:53.162]                             if (is.null(name)) 
[10:19:53.162]                               next
[10:19:53.162]                             if (!grepl(pattern, name)) 
[10:19:53.162]                               next
[10:19:53.162]                             invokeRestart(restart)
[10:19:53.162]                             muffled <- TRUE
[10:19:53.162]                             break
[10:19:53.162]                           }
[10:19:53.162]                         }
[10:19:53.162]                       }
[10:19:53.162]                       invisible(muffled)
[10:19:53.162]                     }
[10:19:53.162]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.162]                   }
[10:19:53.162]                 }
[10:19:53.162]             }
[10:19:53.162]         }))
[10:19:53.162]     }, error = function(ex) {
[10:19:53.162]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.162]                 ...future.rng), started = ...future.startTime, 
[10:19:53.162]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.162]             version = "1.8"), class = "FutureResult")
[10:19:53.162]     }, finally = {
[10:19:53.162]         if (!identical(...future.workdir, getwd())) 
[10:19:53.162]             setwd(...future.workdir)
[10:19:53.162]         {
[10:19:53.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.162]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.162]             }
[10:19:53.162]             base::options(...future.oldOptions)
[10:19:53.162]             if (.Platform$OS.type == "windows") {
[10:19:53.162]                 old_names <- names(...future.oldEnvVars)
[10:19:53.162]                 envs <- base::Sys.getenv()
[10:19:53.162]                 names <- names(envs)
[10:19:53.162]                 common <- intersect(names, old_names)
[10:19:53.162]                 added <- setdiff(names, old_names)
[10:19:53.162]                 removed <- setdiff(old_names, names)
[10:19:53.162]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.162]                   envs[common]]
[10:19:53.162]                 NAMES <- toupper(changed)
[10:19:53.162]                 args <- list()
[10:19:53.162]                 for (kk in seq_along(NAMES)) {
[10:19:53.162]                   name <- changed[[kk]]
[10:19:53.162]                   NAME <- NAMES[[kk]]
[10:19:53.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.162]                     next
[10:19:53.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.162]                 }
[10:19:53.162]                 NAMES <- toupper(added)
[10:19:53.162]                 for (kk in seq_along(NAMES)) {
[10:19:53.162]                   name <- added[[kk]]
[10:19:53.162]                   NAME <- NAMES[[kk]]
[10:19:53.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.162]                     next
[10:19:53.162]                   args[[name]] <- ""
[10:19:53.162]                 }
[10:19:53.162]                 NAMES <- toupper(removed)
[10:19:53.162]                 for (kk in seq_along(NAMES)) {
[10:19:53.162]                   name <- removed[[kk]]
[10:19:53.162]                   NAME <- NAMES[[kk]]
[10:19:53.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.162]                     next
[10:19:53.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.162]                 }
[10:19:53.162]                 if (length(args) > 0) 
[10:19:53.162]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.162]             }
[10:19:53.162]             else {
[10:19:53.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.162]             }
[10:19:53.162]             {
[10:19:53.162]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.162]                   0L) {
[10:19:53.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.162]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.162]                   base::options(opts)
[10:19:53.162]                 }
[10:19:53.162]                 {
[10:19:53.162]                   {
[10:19:53.162]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.162]                     NULL
[10:19:53.162]                   }
[10:19:53.162]                   options(future.plan = NULL)
[10:19:53.162]                   if (is.na(NA_character_)) 
[10:19:53.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.162]                     .init = FALSE)
[10:19:53.162]                 }
[10:19:53.162]             }
[10:19:53.162]         }
[10:19:53.162]     })
[10:19:53.162]     if (TRUE) {
[10:19:53.162]         base::sink(type = "output", split = FALSE)
[10:19:53.162]         if (TRUE) {
[10:19:53.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.162]         }
[10:19:53.162]         else {
[10:19:53.162]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.162]         }
[10:19:53.162]         base::close(...future.stdout)
[10:19:53.162]         ...future.stdout <- NULL
[10:19:53.162]     }
[10:19:53.162]     ...future.result$conditions <- ...future.conditions
[10:19:53.162]     ...future.result$finished <- base::Sys.time()
[10:19:53.162]     ...future.result
[10:19:53.162] }
[10:19:53.164] assign_globals() ...
[10:19:53.164] List of 11
[10:19:53.164]  $ ...future.FUN            :function (x, ...)  
[10:19:53.164]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:19:53.164]  $ times                    : int 5
[10:19:53.164]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.164]  $ stop_if_not              :function (...)  
[10:19:53.164]  $ dim                      : NULL
[10:19:53.164]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:53.164]  $ future.call.arguments    : list()
[10:19:53.164]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.164]  $ ...future.elements_ii    :List of 4
[10:19:53.164]   ..$ : int [1:3] 1 2 3
[10:19:53.164]   ..$ : int [1:4] 1 2 3 4
[10:19:53.164]   ..$ : int [1:5] 1 2 3 4 5
[10:19:53.164]   ..$ : int [1:6] 1 2 3 4 5 6
[10:19:53.164]  $ ...future.seeds_ii       : NULL
[10:19:53.164]  $ ...future.globals.maxSize: NULL
[10:19:53.164]  - attr(*, "where")=List of 11
[10:19:53.164]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.164]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.164]  - attr(*, "resolved")= logi FALSE
[10:19:53.164]  - attr(*, "total_size")= num 48005
[10:19:53.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.164]  - attr(*, "already-done")= logi TRUE
[10:19:53.172] - copied ‘...future.FUN’ to environment
[10:19:53.172] - copied ‘x_FUN’ to environment
[10:19:53.172] - copied ‘times’ to environment
[10:19:53.172] - copied ‘stopf’ to environment
[10:19:53.172] - copied ‘stop_if_not’ to environment
[10:19:53.172] - copied ‘dim’ to environment
[10:19:53.172] - copied ‘valid_types’ to environment
[10:19:53.172] - copied ‘future.call.arguments’ to environment
[10:19:53.173] - copied ‘...future.elements_ii’ to environment
[10:19:53.173] - copied ‘...future.seeds_ii’ to environment
[10:19:53.173] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.173] assign_globals() ... done
[10:19:53.173] requestCore(): workers = 2
[10:19:53.177] MulticoreFuture started
[10:19:53.177] - Launch lazy future ... done
[10:19:53.178] run() for ‘MulticoreFuture’ ... done
[10:19:53.178] Created future:
[10:19:53.179] plan(): Setting new future strategy stack:
[10:19:53.179] List of future strategies:
[10:19:53.179] 1. sequential:
[10:19:53.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.179]    - tweaked: FALSE
[10:19:53.179]    - call: NULL
[10:19:53.181] plan(): nbrOfWorkers() = 1
[10:19:53.184] plan(): Setting new future strategy stack:
[10:19:53.185] List of future strategies:
[10:19:53.185] 1. multicore:
[10:19:53.185]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.185]    - tweaked: FALSE
[10:19:53.185]    - call: plan(strategy)
[10:19:53.189] plan(): nbrOfWorkers() = 2
[10:19:53.179] MulticoreFuture:
[10:19:53.179] Label: ‘future_vapply-1’
[10:19:53.179] Expression:
[10:19:53.179] {
[10:19:53.179]     do.call(function(...) {
[10:19:53.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.179]             on.exit(options(oopts), add = TRUE)
[10:19:53.179]         }
[10:19:53.179]         {
[10:19:53.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.179]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.179]             })
[10:19:53.179]         }
[10:19:53.179]     }, args = future.call.arguments)
[10:19:53.179] }
[10:19:53.179] Lazy evaluation: FALSE
[10:19:53.179] Asynchronous evaluation: TRUE
[10:19:53.179] Local evaluation: TRUE
[10:19:53.179] Environment: R_GlobalEnv
[10:19:53.179] Capture standard output: TRUE
[10:19:53.179] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.179] Globals: 11 objects totaling 27.22 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.179] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:53.179] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.179] Resolved: TRUE
[10:19:53.179] Value: <not collected>
[10:19:53.179] Conditions captured: <none>
[10:19:53.179] Early signaling: FALSE
[10:19:53.179] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.179] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.190] Chunk #1 of 2 ... DONE
[10:19:53.190] Chunk #2 of 2 ...
[10:19:53.191]  - Finding globals in 'X' for chunk #2 ...
[10:19:53.191] getGlobalsAndPackages() ...
[10:19:53.191] Searching for globals...
[10:19:53.192] 
[10:19:53.192] Searching for globals ... DONE
[10:19:53.192] - globals: [0] <none>
[10:19:53.192] getGlobalsAndPackages() ... DONE
[10:19:53.192]    + additional globals found: [n=0] 
[10:19:53.193]    + additional namespaces needed: [n=0] 
[10:19:53.193]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:53.193]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.193]  - seeds: <none>
[10:19:53.193]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.194] getGlobalsAndPackages() ...
[10:19:53.194] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.194] Resolving globals: FALSE
[10:19:53.194] Tweak future expression to call with '...' arguments ...
[10:19:53.195] {
[10:19:53.195]     do.call(function(...) {
[10:19:53.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.195]             on.exit(options(oopts), add = TRUE)
[10:19:53.195]         }
[10:19:53.195]         {
[10:19:53.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.195]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.195]             })
[10:19:53.195]         }
[10:19:53.195]     }, args = future.call.arguments)
[10:19:53.195] }
[10:19:53.195] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.197] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.197] - packages: [2] ‘stats’, ‘future.apply’
[10:19:53.197] getGlobalsAndPackages() ... DONE
[10:19:53.198] run() for ‘Future’ ...
[10:19:53.198] - state: ‘created’
[10:19:53.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.201]   - Field: ‘label’
[10:19:53.201]   - Field: ‘local’
[10:19:53.202]   - Field: ‘owner’
[10:19:53.202]   - Field: ‘envir’
[10:19:53.202]   - Field: ‘workers’
[10:19:53.202]   - Field: ‘packages’
[10:19:53.202]   - Field: ‘gc’
[10:19:53.202]   - Field: ‘job’
[10:19:53.202]   - Field: ‘conditions’
[10:19:53.203]   - Field: ‘expr’
[10:19:53.203]   - Field: ‘uuid’
[10:19:53.203]   - Field: ‘seed’
[10:19:53.203]   - Field: ‘version’
[10:19:53.203]   - Field: ‘result’
[10:19:53.203]   - Field: ‘asynchronous’
[10:19:53.203]   - Field: ‘calls’
[10:19:53.203]   - Field: ‘globals’
[10:19:53.204]   - Field: ‘stdout’
[10:19:53.204]   - Field: ‘earlySignal’
[10:19:53.204]   - Field: ‘lazy’
[10:19:53.204]   - Field: ‘state’
[10:19:53.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.204] - Launch lazy future ...
[10:19:53.205] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:53.205] Packages needed by future strategies (n = 0): <none>
[10:19:53.205] {
[10:19:53.205]     {
[10:19:53.205]         {
[10:19:53.205]             ...future.startTime <- base::Sys.time()
[10:19:53.205]             {
[10:19:53.205]                 {
[10:19:53.205]                   {
[10:19:53.205]                     {
[10:19:53.205]                       {
[10:19:53.205]                         base::local({
[10:19:53.205]                           has_future <- base::requireNamespace("future", 
[10:19:53.205]                             quietly = TRUE)
[10:19:53.205]                           if (has_future) {
[10:19:53.205]                             ns <- base::getNamespace("future")
[10:19:53.205]                             version <- ns[[".package"]][["version"]]
[10:19:53.205]                             if (is.null(version)) 
[10:19:53.205]                               version <- utils::packageVersion("future")
[10:19:53.205]                           }
[10:19:53.205]                           else {
[10:19:53.205]                             version <- NULL
[10:19:53.205]                           }
[10:19:53.205]                           if (!has_future || version < "1.8.0") {
[10:19:53.205]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.205]                               "", base::R.version$version.string), 
[10:19:53.205]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.205]                                 base::R.version$platform, 8 * 
[10:19:53.205]                                   base::.Machine$sizeof.pointer), 
[10:19:53.205]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.205]                                 "release", "version")], collapse = " "), 
[10:19:53.205]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.205]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.205]                               info)
[10:19:53.205]                             info <- base::paste(info, collapse = "; ")
[10:19:53.205]                             if (!has_future) {
[10:19:53.205]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.205]                                 info)
[10:19:53.205]                             }
[10:19:53.205]                             else {
[10:19:53.205]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.205]                                 info, version)
[10:19:53.205]                             }
[10:19:53.205]                             base::stop(msg)
[10:19:53.205]                           }
[10:19:53.205]                         })
[10:19:53.205]                       }
[10:19:53.205]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.205]                       base::options(mc.cores = 1L)
[10:19:53.205]                     }
[10:19:53.205]                     base::local({
[10:19:53.205]                       for (pkg in c("stats", "future.apply")) {
[10:19:53.205]                         base::loadNamespace(pkg)
[10:19:53.205]                         base::library(pkg, character.only = TRUE)
[10:19:53.205]                       }
[10:19:53.205]                     })
[10:19:53.205]                   }
[10:19:53.205]                   ...future.strategy.old <- future::plan("list")
[10:19:53.205]                   options(future.plan = NULL)
[10:19:53.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.205]                 }
[10:19:53.205]                 ...future.workdir <- getwd()
[10:19:53.205]             }
[10:19:53.205]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.205]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.205]         }
[10:19:53.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.205]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.205]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.205]             base::names(...future.oldOptions))
[10:19:53.205]     }
[10:19:53.205]     if (FALSE) {
[10:19:53.205]     }
[10:19:53.205]     else {
[10:19:53.205]         if (TRUE) {
[10:19:53.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.205]                 open = "w")
[10:19:53.205]         }
[10:19:53.205]         else {
[10:19:53.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.205]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.205]         }
[10:19:53.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.205]             base::sink(type = "output", split = FALSE)
[10:19:53.205]             base::close(...future.stdout)
[10:19:53.205]         }, add = TRUE)
[10:19:53.205]     }
[10:19:53.205]     ...future.frame <- base::sys.nframe()
[10:19:53.205]     ...future.conditions <- base::list()
[10:19:53.205]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.205]     if (FALSE) {
[10:19:53.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.205]     }
[10:19:53.205]     ...future.result <- base::tryCatch({
[10:19:53.205]         base::withCallingHandlers({
[10:19:53.205]             ...future.value <- base::withVisible(base::local({
[10:19:53.205]                 withCallingHandlers({
[10:19:53.205]                   {
[10:19:53.205]                     do.call(function(...) {
[10:19:53.205]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.205]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.205]                         ...future.globals.maxSize)) {
[10:19:53.205]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.205]                         on.exit(options(oopts), add = TRUE)
[10:19:53.205]                       }
[10:19:53.205]                       {
[10:19:53.205]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.205]                           FUN = function(jj) {
[10:19:53.205]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.205]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.205]                           })
[10:19:53.205]                       }
[10:19:53.205]                     }, args = future.call.arguments)
[10:19:53.205]                   }
[10:19:53.205]                 }, immediateCondition = function(cond) {
[10:19:53.205]                   save_rds <- function (object, pathname, ...) 
[10:19:53.205]                   {
[10:19:53.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.205]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.205]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.205]                         fi_tmp[["mtime"]])
[10:19:53.205]                     }
[10:19:53.205]                     tryCatch({
[10:19:53.205]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.205]                     }, error = function(ex) {
[10:19:53.205]                       msg <- conditionMessage(ex)
[10:19:53.205]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.205]                         fi_tmp[["mtime"]], msg)
[10:19:53.205]                       ex$message <- msg
[10:19:53.205]                       stop(ex)
[10:19:53.205]                     })
[10:19:53.205]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.205]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.205]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.205]                       fi <- file.info(pathname)
[10:19:53.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.205]                         fi[["size"]], fi[["mtime"]])
[10:19:53.205]                       stop(msg)
[10:19:53.205]                     }
[10:19:53.205]                     invisible(pathname)
[10:19:53.205]                   }
[10:19:53.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.205]                     rootPath = tempdir()) 
[10:19:53.205]                   {
[10:19:53.205]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.205]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.205]                       tmpdir = path, fileext = ".rds")
[10:19:53.205]                     save_rds(obj, file)
[10:19:53.205]                   }
[10:19:53.205]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.205]                   {
[10:19:53.205]                     inherits <- base::inherits
[10:19:53.205]                     invokeRestart <- base::invokeRestart
[10:19:53.205]                     is.null <- base::is.null
[10:19:53.205]                     muffled <- FALSE
[10:19:53.205]                     if (inherits(cond, "message")) {
[10:19:53.205]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.205]                       if (muffled) 
[10:19:53.205]                         invokeRestart("muffleMessage")
[10:19:53.205]                     }
[10:19:53.205]                     else if (inherits(cond, "warning")) {
[10:19:53.205]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.205]                       if (muffled) 
[10:19:53.205]                         invokeRestart("muffleWarning")
[10:19:53.205]                     }
[10:19:53.205]                     else if (inherits(cond, "condition")) {
[10:19:53.205]                       if (!is.null(pattern)) {
[10:19:53.205]                         computeRestarts <- base::computeRestarts
[10:19:53.205]                         grepl <- base::grepl
[10:19:53.205]                         restarts <- computeRestarts(cond)
[10:19:53.205]                         for (restart in restarts) {
[10:19:53.205]                           name <- restart$name
[10:19:53.205]                           if (is.null(name)) 
[10:19:53.205]                             next
[10:19:53.205]                           if (!grepl(pattern, name)) 
[10:19:53.205]                             next
[10:19:53.205]                           invokeRestart(restart)
[10:19:53.205]                           muffled <- TRUE
[10:19:53.205]                           break
[10:19:53.205]                         }
[10:19:53.205]                       }
[10:19:53.205]                     }
[10:19:53.205]                     invisible(muffled)
[10:19:53.205]                   }
[10:19:53.205]                   muffleCondition(cond)
[10:19:53.205]                 })
[10:19:53.205]             }))
[10:19:53.205]             future::FutureResult(value = ...future.value$value, 
[10:19:53.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.205]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.205]                     ...future.globalenv.names))
[10:19:53.205]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.205]         }, condition = base::local({
[10:19:53.205]             c <- base::c
[10:19:53.205]             inherits <- base::inherits
[10:19:53.205]             invokeRestart <- base::invokeRestart
[10:19:53.205]             length <- base::length
[10:19:53.205]             list <- base::list
[10:19:53.205]             seq.int <- base::seq.int
[10:19:53.205]             signalCondition <- base::signalCondition
[10:19:53.205]             sys.calls <- base::sys.calls
[10:19:53.205]             `[[` <- base::`[[`
[10:19:53.205]             `+` <- base::`+`
[10:19:53.205]             `<<-` <- base::`<<-`
[10:19:53.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.205]                   3L)]
[10:19:53.205]             }
[10:19:53.205]             function(cond) {
[10:19:53.205]                 is_error <- inherits(cond, "error")
[10:19:53.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.205]                   NULL)
[10:19:53.205]                 if (is_error) {
[10:19:53.205]                   sessionInformation <- function() {
[10:19:53.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.205]                       search = base::search(), system = base::Sys.info())
[10:19:53.205]                   }
[10:19:53.205]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.205]                     cond$call), session = sessionInformation(), 
[10:19:53.205]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.205]                   signalCondition(cond)
[10:19:53.205]                 }
[10:19:53.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.205]                 "immediateCondition"))) {
[10:19:53.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.205]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.205]                   if (TRUE && !signal) {
[10:19:53.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.205]                     {
[10:19:53.205]                       inherits <- base::inherits
[10:19:53.205]                       invokeRestart <- base::invokeRestart
[10:19:53.205]                       is.null <- base::is.null
[10:19:53.205]                       muffled <- FALSE
[10:19:53.205]                       if (inherits(cond, "message")) {
[10:19:53.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.205]                         if (muffled) 
[10:19:53.205]                           invokeRestart("muffleMessage")
[10:19:53.205]                       }
[10:19:53.205]                       else if (inherits(cond, "warning")) {
[10:19:53.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.205]                         if (muffled) 
[10:19:53.205]                           invokeRestart("muffleWarning")
[10:19:53.205]                       }
[10:19:53.205]                       else if (inherits(cond, "condition")) {
[10:19:53.205]                         if (!is.null(pattern)) {
[10:19:53.205]                           computeRestarts <- base::computeRestarts
[10:19:53.205]                           grepl <- base::grepl
[10:19:53.205]                           restarts <- computeRestarts(cond)
[10:19:53.205]                           for (restart in restarts) {
[10:19:53.205]                             name <- restart$name
[10:19:53.205]                             if (is.null(name)) 
[10:19:53.205]                               next
[10:19:53.205]                             if (!grepl(pattern, name)) 
[10:19:53.205]                               next
[10:19:53.205]                             invokeRestart(restart)
[10:19:53.205]                             muffled <- TRUE
[10:19:53.205]                             break
[10:19:53.205]                           }
[10:19:53.205]                         }
[10:19:53.205]                       }
[10:19:53.205]                       invisible(muffled)
[10:19:53.205]                     }
[10:19:53.205]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.205]                   }
[10:19:53.205]                 }
[10:19:53.205]                 else {
[10:19:53.205]                   if (TRUE) {
[10:19:53.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.205]                     {
[10:19:53.205]                       inherits <- base::inherits
[10:19:53.205]                       invokeRestart <- base::invokeRestart
[10:19:53.205]                       is.null <- base::is.null
[10:19:53.205]                       muffled <- FALSE
[10:19:53.205]                       if (inherits(cond, "message")) {
[10:19:53.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.205]                         if (muffled) 
[10:19:53.205]                           invokeRestart("muffleMessage")
[10:19:53.205]                       }
[10:19:53.205]                       else if (inherits(cond, "warning")) {
[10:19:53.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.205]                         if (muffled) 
[10:19:53.205]                           invokeRestart("muffleWarning")
[10:19:53.205]                       }
[10:19:53.205]                       else if (inherits(cond, "condition")) {
[10:19:53.205]                         if (!is.null(pattern)) {
[10:19:53.205]                           computeRestarts <- base::computeRestarts
[10:19:53.205]                           grepl <- base::grepl
[10:19:53.205]                           restarts <- computeRestarts(cond)
[10:19:53.205]                           for (restart in restarts) {
[10:19:53.205]                             name <- restart$name
[10:19:53.205]                             if (is.null(name)) 
[10:19:53.205]                               next
[10:19:53.205]                             if (!grepl(pattern, name)) 
[10:19:53.205]                               next
[10:19:53.205]                             invokeRestart(restart)
[10:19:53.205]                             muffled <- TRUE
[10:19:53.205]                             break
[10:19:53.205]                           }
[10:19:53.205]                         }
[10:19:53.205]                       }
[10:19:53.205]                       invisible(muffled)
[10:19:53.205]                     }
[10:19:53.205]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.205]                   }
[10:19:53.205]                 }
[10:19:53.205]             }
[10:19:53.205]         }))
[10:19:53.205]     }, error = function(ex) {
[10:19:53.205]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.205]                 ...future.rng), started = ...future.startTime, 
[10:19:53.205]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.205]             version = "1.8"), class = "FutureResult")
[10:19:53.205]     }, finally = {
[10:19:53.205]         if (!identical(...future.workdir, getwd())) 
[10:19:53.205]             setwd(...future.workdir)
[10:19:53.205]         {
[10:19:53.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.205]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.205]             }
[10:19:53.205]             base::options(...future.oldOptions)
[10:19:53.205]             if (.Platform$OS.type == "windows") {
[10:19:53.205]                 old_names <- names(...future.oldEnvVars)
[10:19:53.205]                 envs <- base::Sys.getenv()
[10:19:53.205]                 names <- names(envs)
[10:19:53.205]                 common <- intersect(names, old_names)
[10:19:53.205]                 added <- setdiff(names, old_names)
[10:19:53.205]                 removed <- setdiff(old_names, names)
[10:19:53.205]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.205]                   envs[common]]
[10:19:53.205]                 NAMES <- toupper(changed)
[10:19:53.205]                 args <- list()
[10:19:53.205]                 for (kk in seq_along(NAMES)) {
[10:19:53.205]                   name <- changed[[kk]]
[10:19:53.205]                   NAME <- NAMES[[kk]]
[10:19:53.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.205]                     next
[10:19:53.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.205]                 }
[10:19:53.205]                 NAMES <- toupper(added)
[10:19:53.205]                 for (kk in seq_along(NAMES)) {
[10:19:53.205]                   name <- added[[kk]]
[10:19:53.205]                   NAME <- NAMES[[kk]]
[10:19:53.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.205]                     next
[10:19:53.205]                   args[[name]] <- ""
[10:19:53.205]                 }
[10:19:53.205]                 NAMES <- toupper(removed)
[10:19:53.205]                 for (kk in seq_along(NAMES)) {
[10:19:53.205]                   name <- removed[[kk]]
[10:19:53.205]                   NAME <- NAMES[[kk]]
[10:19:53.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.205]                     next
[10:19:53.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.205]                 }
[10:19:53.205]                 if (length(args) > 0) 
[10:19:53.205]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.205]             }
[10:19:53.205]             else {
[10:19:53.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.205]             }
[10:19:53.205]             {
[10:19:53.205]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.205]                   0L) {
[10:19:53.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.205]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.205]                   base::options(opts)
[10:19:53.205]                 }
[10:19:53.205]                 {
[10:19:53.205]                   {
[10:19:53.205]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.205]                     NULL
[10:19:53.205]                   }
[10:19:53.205]                   options(future.plan = NULL)
[10:19:53.205]                   if (is.na(NA_character_)) 
[10:19:53.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.205]                     .init = FALSE)
[10:19:53.205]                 }
[10:19:53.205]             }
[10:19:53.205]         }
[10:19:53.205]     })
[10:19:53.205]     if (TRUE) {
[10:19:53.205]         base::sink(type = "output", split = FALSE)
[10:19:53.205]         if (TRUE) {
[10:19:53.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.205]         }
[10:19:53.205]         else {
[10:19:53.205]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.205]         }
[10:19:53.205]         base::close(...future.stdout)
[10:19:53.205]         ...future.stdout <- NULL
[10:19:53.205]     }
[10:19:53.205]     ...future.result$conditions <- ...future.conditions
[10:19:53.205]     ...future.result$finished <- base::Sys.time()
[10:19:53.205]     ...future.result
[10:19:53.205] }
[10:19:53.209] assign_globals() ...
[10:19:53.209] List of 11
[10:19:53.209]  $ ...future.FUN            :function (x, ...)  
[10:19:53.209]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:19:53.209]  $ times                    : int 5
[10:19:53.209]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.209]  $ stop_if_not              :function (...)  
[10:19:53.209]  $ dim                      : NULL
[10:19:53.209]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:53.209]  $ future.call.arguments    : list()
[10:19:53.209]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.209]  $ ...future.elements_ii    :List of 3
[10:19:53.209]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:19:53.209]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:19:53.209]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:19:53.209]  $ ...future.seeds_ii       : NULL
[10:19:53.209]  $ ...future.globals.maxSize: NULL
[10:19:53.209]  - attr(*, "where")=List of 11
[10:19:53.209]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.209]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.209]  - attr(*, "resolved")= logi FALSE
[10:19:53.209]  - attr(*, "total_size")= num 48005
[10:19:53.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.209]  - attr(*, "already-done")= logi TRUE
[10:19:53.221] - copied ‘...future.FUN’ to environment
[10:19:53.221] - copied ‘x_FUN’ to environment
[10:19:53.221] - copied ‘times’ to environment
[10:19:53.221] - copied ‘stopf’ to environment
[10:19:53.221] - copied ‘stop_if_not’ to environment
[10:19:53.221] - copied ‘dim’ to environment
[10:19:53.221] - copied ‘valid_types’ to environment
[10:19:53.222] - copied ‘future.call.arguments’ to environment
[10:19:53.222] - copied ‘...future.elements_ii’ to environment
[10:19:53.222] - copied ‘...future.seeds_ii’ to environment
[10:19:53.222] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.222] assign_globals() ... done
[10:19:53.222] requestCore(): workers = 2
[10:19:53.225] MulticoreFuture started
[10:19:53.225] - Launch lazy future ... done
[10:19:53.226] run() for ‘MulticoreFuture’ ... done
[10:19:53.226] Created future:
[10:19:53.227] plan(): Setting new future strategy stack:
[10:19:53.228] List of future strategies:
[10:19:53.228] 1. sequential:
[10:19:53.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.228]    - tweaked: FALSE
[10:19:53.228]    - call: NULL
[10:19:53.230] plan(): nbrOfWorkers() = 1
[10:19:53.234] plan(): Setting new future strategy stack:
[10:19:53.234] List of future strategies:
[10:19:53.234] 1. multicore:
[10:19:53.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.234]    - tweaked: FALSE
[10:19:53.234]    - call: plan(strategy)
[10:19:53.240] plan(): nbrOfWorkers() = 2
[10:19:53.227] MulticoreFuture:
[10:19:53.227] Label: ‘future_vapply-2’
[10:19:53.227] Expression:
[10:19:53.227] {
[10:19:53.227]     do.call(function(...) {
[10:19:53.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.227]             on.exit(options(oopts), add = TRUE)
[10:19:53.227]         }
[10:19:53.227]         {
[10:19:53.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.227]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.227]             })
[10:19:53.227]         }
[10:19:53.227]     }, args = future.call.arguments)
[10:19:53.227] }
[10:19:53.227] Lazy evaluation: FALSE
[10:19:53.227] Asynchronous evaluation: TRUE
[10:19:53.227] Local evaluation: TRUE
[10:19:53.227] Environment: R_GlobalEnv
[10:19:53.227] Capture standard output: TRUE
[10:19:53.227] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.227] Globals: 11 objects totaling 27.14 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.227] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:53.227] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.227] Resolved: FALSE
[10:19:53.227] Value: <not collected>
[10:19:53.227] Conditions captured: <none>
[10:19:53.227] Early signaling: FALSE
[10:19:53.227] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.227] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.241] Chunk #2 of 2 ... DONE
[10:19:53.241] Launching 2 futures (chunks) ... DONE
[10:19:53.241] Resolving 2 futures (chunks) ...
[10:19:53.242] resolve() on list ...
[10:19:53.242]  recursive: 0
[10:19:53.242]  length: 2
[10:19:53.242] 
[10:19:53.243] Future #1
[10:19:53.243] result() for MulticoreFuture ...
[10:19:53.244] result() for MulticoreFuture ...
[10:19:53.244] result() for MulticoreFuture ... done
[10:19:53.244] result() for MulticoreFuture ... done
[10:19:53.245] result() for MulticoreFuture ...
[10:19:53.245] result() for MulticoreFuture ... done
[10:19:53.245] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:53.245] - nx: 2
[10:19:53.245] - relay: TRUE
[10:19:53.246] - stdout: TRUE
[10:19:53.246] - signal: TRUE
[10:19:53.246] - resignal: FALSE
[10:19:53.246] - force: TRUE
[10:19:53.246] - relayed: [n=2] FALSE, FALSE
[10:19:53.246] - queued futures: [n=2] FALSE, FALSE
[10:19:53.246]  - until=1
[10:19:53.246]  - relaying element #1
[10:19:53.247] result() for MulticoreFuture ...
[10:19:53.247] result() for MulticoreFuture ... done
[10:19:53.247] result() for MulticoreFuture ...
[10:19:53.247] result() for MulticoreFuture ... done
[10:19:53.247] result() for MulticoreFuture ...
[10:19:53.247] result() for MulticoreFuture ... done
[10:19:53.247] result() for MulticoreFuture ...
[10:19:53.248] result() for MulticoreFuture ... done
[10:19:53.248] - relayed: [n=2] TRUE, FALSE
[10:19:53.248] - queued futures: [n=2] TRUE, FALSE
[10:19:53.248] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:53.248]  length: 1 (resolved future 1)
[10:19:53.249] Future #2
[10:19:53.249] result() for MulticoreFuture ...
[10:19:53.250] result() for MulticoreFuture ...
[10:19:53.250] result() for MulticoreFuture ... done
[10:19:53.250] result() for MulticoreFuture ... done
[10:19:53.250] result() for MulticoreFuture ...
[10:19:53.250] result() for MulticoreFuture ... done
[10:19:53.250] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:53.250] - nx: 2
[10:19:53.251] - relay: TRUE
[10:19:53.251] - stdout: TRUE
[10:19:53.251] - signal: TRUE
[10:19:53.251] - resignal: FALSE
[10:19:53.251] - force: TRUE
[10:19:53.251] - relayed: [n=2] TRUE, FALSE
[10:19:53.251] - queued futures: [n=2] TRUE, FALSE
[10:19:53.251]  - until=2
[10:19:53.251]  - relaying element #2
[10:19:53.252] result() for MulticoreFuture ...
[10:19:53.252] result() for MulticoreFuture ... done
[10:19:53.252] result() for MulticoreFuture ...
[10:19:53.252] result() for MulticoreFuture ... done
[10:19:53.252] result() for MulticoreFuture ...
[10:19:53.252] result() for MulticoreFuture ... done
[10:19:53.252] result() for MulticoreFuture ...
[10:19:53.252] result() for MulticoreFuture ... done
[10:19:53.253] - relayed: [n=2] TRUE, TRUE
[10:19:53.253] - queued futures: [n=2] TRUE, TRUE
[10:19:53.253] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:53.253]  length: 0 (resolved future 2)
[10:19:53.253] Relaying remaining futures
[10:19:53.253] signalConditionsASAP(NULL, pos=0) ...
[10:19:53.253] - nx: 2
[10:19:53.253] - relay: TRUE
[10:19:53.253] - stdout: TRUE
[10:19:53.253] - signal: TRUE
[10:19:53.253] - resignal: FALSE
[10:19:53.254] - force: TRUE
[10:19:53.254] - relayed: [n=2] TRUE, TRUE
[10:19:53.254] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:53.254] - relayed: [n=2] TRUE, TRUE
[10:19:53.254] - queued futures: [n=2] TRUE, TRUE
[10:19:53.254] signalConditionsASAP(NULL, pos=0) ... done
[10:19:53.254] resolve() on list ... DONE
[10:19:53.254] result() for MulticoreFuture ...
[10:19:53.254] result() for MulticoreFuture ... done
[10:19:53.254] result() for MulticoreFuture ...
[10:19:53.255] result() for MulticoreFuture ... done
[10:19:53.255] result() for MulticoreFuture ...
[10:19:53.255] result() for MulticoreFuture ... done
[10:19:53.255] result() for MulticoreFuture ...
[10:19:53.255] result() for MulticoreFuture ... done
[10:19:53.255]  - Number of value chunks collected: 2
[10:19:53.255] Resolving 2 futures (chunks) ... DONE
[10:19:53.255] Reducing values from 2 chunks ...
[10:19:53.255]  - Number of values collected after concatenation: 7
[10:19:53.255]  - Number of values expected: 7
[10:19:53.256] Reducing values from 2 chunks ... DONE
[10:19:53.256] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:19:53.258] future_lapply() ...
[10:19:53.260] Number of chunks: 2
[10:19:53.260] getGlobalsAndPackagesXApply() ...
[10:19:53.261]  - future.globals: TRUE
[10:19:53.261] getGlobalsAndPackages() ...
[10:19:53.261] Searching for globals...
[10:19:53.262] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:19:53.262] Searching for globals ... DONE
[10:19:53.262] Resolving globals: FALSE
[10:19:53.265] The total size of the 1 globals is 680 bytes (680 bytes)
[10:19:53.266] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[10:19:53.266] - globals: [1] ‘FUN’
[10:19:53.266] 
[10:19:53.266] getGlobalsAndPackages() ... DONE
[10:19:53.266]  - globals found/used: [n=1] ‘FUN’
[10:19:53.266]  - needed namespaces: [n=0] 
[10:19:53.266] Finding globals ... DONE
[10:19:53.267]  - use_args: TRUE
[10:19:53.267]  - Getting '...' globals ...
[10:19:53.267] resolve() on list ...
[10:19:53.267]  recursive: 0
[10:19:53.267]  length: 1
[10:19:53.268]  elements: ‘...’
[10:19:53.268]  length: 0 (resolved future 1)
[10:19:53.268] resolve() on list ... DONE
[10:19:53.268]    - '...' content: [n=1] ‘y’
[10:19:53.268] List of 1
[10:19:53.268]  $ ...:List of 1
[10:19:53.268]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.268]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.268]  - attr(*, "where")=List of 1
[10:19:53.268]   ..$ ...:<environment: 0x55c69faacbd0> 
[10:19:53.268]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.268]  - attr(*, "resolved")= logi TRUE
[10:19:53.268]  - attr(*, "total_size")= num NA
[10:19:53.271]  - Getting '...' globals ... DONE
[10:19:53.272] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:19:53.272] List of 2
[10:19:53.272]  $ ...future.FUN:function (x, y)  
[10:19:53.272]  $ ...          :List of 1
[10:19:53.272]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.272]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.272]  - attr(*, "where")=List of 2
[10:19:53.272]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:53.272]   ..$ ...          :<environment: 0x55c69faacbd0> 
[10:19:53.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.272]  - attr(*, "resolved")= logi FALSE
[10:19:53.272]  - attr(*, "total_size")= num 7318
[10:19:53.275] Packages to be attached in all futures: [n=0] 
[10:19:53.275] getGlobalsAndPackagesXApply() ... DONE
[10:19:53.275] Number of futures (= number of chunks): 2
[10:19:53.275] Launching 2 futures (chunks) ...
[10:19:53.275] Chunk #1 of 2 ...
[10:19:53.275]  - Finding globals in 'X' for chunk #1 ...
[10:19:53.275] getGlobalsAndPackages() ...
[10:19:53.276] Searching for globals...
[10:19:53.276] 
[10:19:53.276] Searching for globals ... DONE
[10:19:53.276] - globals: [0] <none>
[10:19:53.276] getGlobalsAndPackages() ... DONE
[10:19:53.276]    + additional globals found: [n=0] 
[10:19:53.276]    + additional namespaces needed: [n=0] 
[10:19:53.276]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:53.276]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.277]  - seeds: <none>
[10:19:53.277]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.277] getGlobalsAndPackages() ...
[10:19:53.277] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.277] Resolving globals: FALSE
[10:19:53.277] Tweak future expression to call with '...' arguments ...
[10:19:53.277] {
[10:19:53.277]     do.call(function(...) {
[10:19:53.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.277]             on.exit(options(oopts), add = TRUE)
[10:19:53.277]         }
[10:19:53.277]         {
[10:19:53.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.277]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.277]             })
[10:19:53.277]         }
[10:19:53.277]     }, args = future.call.arguments)
[10:19:53.277] }
[10:19:53.277] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.278] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.278] 
[10:19:53.278] getGlobalsAndPackages() ... DONE
[10:19:53.278] run() for ‘Future’ ...
[10:19:53.278] - state: ‘created’
[10:19:53.279] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.280] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.280]   - Field: ‘label’
[10:19:53.281]   - Field: ‘local’
[10:19:53.281]   - Field: ‘owner’
[10:19:53.281]   - Field: ‘envir’
[10:19:53.281]   - Field: ‘workers’
[10:19:53.281]   - Field: ‘packages’
[10:19:53.281]   - Field: ‘gc’
[10:19:53.281]   - Field: ‘job’
[10:19:53.281]   - Field: ‘conditions’
[10:19:53.281]   - Field: ‘expr’
[10:19:53.281]   - Field: ‘uuid’
[10:19:53.281]   - Field: ‘seed’
[10:19:53.282]   - Field: ‘version’
[10:19:53.282]   - Field: ‘result’
[10:19:53.282]   - Field: ‘asynchronous’
[10:19:53.282]   - Field: ‘calls’
[10:19:53.282]   - Field: ‘globals’
[10:19:53.282]   - Field: ‘stdout’
[10:19:53.282]   - Field: ‘earlySignal’
[10:19:53.282]   - Field: ‘lazy’
[10:19:53.282]   - Field: ‘state’
[10:19:53.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.282] - Launch lazy future ...
[10:19:53.283] Packages needed by the future expression (n = 0): <none>
[10:19:53.283] Packages needed by future strategies (n = 0): <none>
[10:19:53.283] {
[10:19:53.283]     {
[10:19:53.283]         {
[10:19:53.283]             ...future.startTime <- base::Sys.time()
[10:19:53.283]             {
[10:19:53.283]                 {
[10:19:53.283]                   {
[10:19:53.283]                     {
[10:19:53.283]                       base::local({
[10:19:53.283]                         has_future <- base::requireNamespace("future", 
[10:19:53.283]                           quietly = TRUE)
[10:19:53.283]                         if (has_future) {
[10:19:53.283]                           ns <- base::getNamespace("future")
[10:19:53.283]                           version <- ns[[".package"]][["version"]]
[10:19:53.283]                           if (is.null(version)) 
[10:19:53.283]                             version <- utils::packageVersion("future")
[10:19:53.283]                         }
[10:19:53.283]                         else {
[10:19:53.283]                           version <- NULL
[10:19:53.283]                         }
[10:19:53.283]                         if (!has_future || version < "1.8.0") {
[10:19:53.283]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.283]                             "", base::R.version$version.string), 
[10:19:53.283]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:53.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:53.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.283]                               "release", "version")], collapse = " "), 
[10:19:53.283]                             hostname = base::Sys.info()[["nodename"]])
[10:19:53.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.283]                             info)
[10:19:53.283]                           info <- base::paste(info, collapse = "; ")
[10:19:53.283]                           if (!has_future) {
[10:19:53.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.283]                               info)
[10:19:53.283]                           }
[10:19:53.283]                           else {
[10:19:53.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.283]                               info, version)
[10:19:53.283]                           }
[10:19:53.283]                           base::stop(msg)
[10:19:53.283]                         }
[10:19:53.283]                       })
[10:19:53.283]                     }
[10:19:53.283]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.283]                     base::options(mc.cores = 1L)
[10:19:53.283]                   }
[10:19:53.283]                   ...future.strategy.old <- future::plan("list")
[10:19:53.283]                   options(future.plan = NULL)
[10:19:53.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.283]                 }
[10:19:53.283]                 ...future.workdir <- getwd()
[10:19:53.283]             }
[10:19:53.283]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.283]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.283]         }
[10:19:53.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.283]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.283]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.283]             base::names(...future.oldOptions))
[10:19:53.283]     }
[10:19:53.283]     if (FALSE) {
[10:19:53.283]     }
[10:19:53.283]     else {
[10:19:53.283]         if (TRUE) {
[10:19:53.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.283]                 open = "w")
[10:19:53.283]         }
[10:19:53.283]         else {
[10:19:53.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.283]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.283]         }
[10:19:53.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.283]             base::sink(type = "output", split = FALSE)
[10:19:53.283]             base::close(...future.stdout)
[10:19:53.283]         }, add = TRUE)
[10:19:53.283]     }
[10:19:53.283]     ...future.frame <- base::sys.nframe()
[10:19:53.283]     ...future.conditions <- base::list()
[10:19:53.283]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.283]     if (FALSE) {
[10:19:53.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.283]     }
[10:19:53.283]     ...future.result <- base::tryCatch({
[10:19:53.283]         base::withCallingHandlers({
[10:19:53.283]             ...future.value <- base::withVisible(base::local({
[10:19:53.283]                 withCallingHandlers({
[10:19:53.283]                   {
[10:19:53.283]                     do.call(function(...) {
[10:19:53.283]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.283]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.283]                         ...future.globals.maxSize)) {
[10:19:53.283]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.283]                         on.exit(options(oopts), add = TRUE)
[10:19:53.283]                       }
[10:19:53.283]                       {
[10:19:53.283]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.283]                           FUN = function(jj) {
[10:19:53.283]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.283]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.283]                           })
[10:19:53.283]                       }
[10:19:53.283]                     }, args = future.call.arguments)
[10:19:53.283]                   }
[10:19:53.283]                 }, immediateCondition = function(cond) {
[10:19:53.283]                   save_rds <- function (object, pathname, ...) 
[10:19:53.283]                   {
[10:19:53.283]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.283]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.283]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.283]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.283]                         fi_tmp[["mtime"]])
[10:19:53.283]                     }
[10:19:53.283]                     tryCatch({
[10:19:53.283]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.283]                     }, error = function(ex) {
[10:19:53.283]                       msg <- conditionMessage(ex)
[10:19:53.283]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.283]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.283]                         fi_tmp[["mtime"]], msg)
[10:19:53.283]                       ex$message <- msg
[10:19:53.283]                       stop(ex)
[10:19:53.283]                     })
[10:19:53.283]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.283]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.283]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.283]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.283]                       fi <- file.info(pathname)
[10:19:53.283]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.283]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.283]                         fi[["size"]], fi[["mtime"]])
[10:19:53.283]                       stop(msg)
[10:19:53.283]                     }
[10:19:53.283]                     invisible(pathname)
[10:19:53.283]                   }
[10:19:53.283]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.283]                     rootPath = tempdir()) 
[10:19:53.283]                   {
[10:19:53.283]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.283]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.283]                       tmpdir = path, fileext = ".rds")
[10:19:53.283]                     save_rds(obj, file)
[10:19:53.283]                   }
[10:19:53.283]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.283]                   {
[10:19:53.283]                     inherits <- base::inherits
[10:19:53.283]                     invokeRestart <- base::invokeRestart
[10:19:53.283]                     is.null <- base::is.null
[10:19:53.283]                     muffled <- FALSE
[10:19:53.283]                     if (inherits(cond, "message")) {
[10:19:53.283]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.283]                       if (muffled) 
[10:19:53.283]                         invokeRestart("muffleMessage")
[10:19:53.283]                     }
[10:19:53.283]                     else if (inherits(cond, "warning")) {
[10:19:53.283]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.283]                       if (muffled) 
[10:19:53.283]                         invokeRestart("muffleWarning")
[10:19:53.283]                     }
[10:19:53.283]                     else if (inherits(cond, "condition")) {
[10:19:53.283]                       if (!is.null(pattern)) {
[10:19:53.283]                         computeRestarts <- base::computeRestarts
[10:19:53.283]                         grepl <- base::grepl
[10:19:53.283]                         restarts <- computeRestarts(cond)
[10:19:53.283]                         for (restart in restarts) {
[10:19:53.283]                           name <- restart$name
[10:19:53.283]                           if (is.null(name)) 
[10:19:53.283]                             next
[10:19:53.283]                           if (!grepl(pattern, name)) 
[10:19:53.283]                             next
[10:19:53.283]                           invokeRestart(restart)
[10:19:53.283]                           muffled <- TRUE
[10:19:53.283]                           break
[10:19:53.283]                         }
[10:19:53.283]                       }
[10:19:53.283]                     }
[10:19:53.283]                     invisible(muffled)
[10:19:53.283]                   }
[10:19:53.283]                   muffleCondition(cond)
[10:19:53.283]                 })
[10:19:53.283]             }))
[10:19:53.283]             future::FutureResult(value = ...future.value$value, 
[10:19:53.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.283]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.283]                     ...future.globalenv.names))
[10:19:53.283]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.283]         }, condition = base::local({
[10:19:53.283]             c <- base::c
[10:19:53.283]             inherits <- base::inherits
[10:19:53.283]             invokeRestart <- base::invokeRestart
[10:19:53.283]             length <- base::length
[10:19:53.283]             list <- base::list
[10:19:53.283]             seq.int <- base::seq.int
[10:19:53.283]             signalCondition <- base::signalCondition
[10:19:53.283]             sys.calls <- base::sys.calls
[10:19:53.283]             `[[` <- base::`[[`
[10:19:53.283]             `+` <- base::`+`
[10:19:53.283]             `<<-` <- base::`<<-`
[10:19:53.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.283]                   3L)]
[10:19:53.283]             }
[10:19:53.283]             function(cond) {
[10:19:53.283]                 is_error <- inherits(cond, "error")
[10:19:53.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.283]                   NULL)
[10:19:53.283]                 if (is_error) {
[10:19:53.283]                   sessionInformation <- function() {
[10:19:53.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.283]                       search = base::search(), system = base::Sys.info())
[10:19:53.283]                   }
[10:19:53.283]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.283]                     cond$call), session = sessionInformation(), 
[10:19:53.283]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.283]                   signalCondition(cond)
[10:19:53.283]                 }
[10:19:53.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.283]                 "immediateCondition"))) {
[10:19:53.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.283]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.283]                   if (TRUE && !signal) {
[10:19:53.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.283]                     {
[10:19:53.283]                       inherits <- base::inherits
[10:19:53.283]                       invokeRestart <- base::invokeRestart
[10:19:53.283]                       is.null <- base::is.null
[10:19:53.283]                       muffled <- FALSE
[10:19:53.283]                       if (inherits(cond, "message")) {
[10:19:53.283]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.283]                         if (muffled) 
[10:19:53.283]                           invokeRestart("muffleMessage")
[10:19:53.283]                       }
[10:19:53.283]                       else if (inherits(cond, "warning")) {
[10:19:53.283]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.283]                         if (muffled) 
[10:19:53.283]                           invokeRestart("muffleWarning")
[10:19:53.283]                       }
[10:19:53.283]                       else if (inherits(cond, "condition")) {
[10:19:53.283]                         if (!is.null(pattern)) {
[10:19:53.283]                           computeRestarts <- base::computeRestarts
[10:19:53.283]                           grepl <- base::grepl
[10:19:53.283]                           restarts <- computeRestarts(cond)
[10:19:53.283]                           for (restart in restarts) {
[10:19:53.283]                             name <- restart$name
[10:19:53.283]                             if (is.null(name)) 
[10:19:53.283]                               next
[10:19:53.283]                             if (!grepl(pattern, name)) 
[10:19:53.283]                               next
[10:19:53.283]                             invokeRestart(restart)
[10:19:53.283]                             muffled <- TRUE
[10:19:53.283]                             break
[10:19:53.283]                           }
[10:19:53.283]                         }
[10:19:53.283]                       }
[10:19:53.283]                       invisible(muffled)
[10:19:53.283]                     }
[10:19:53.283]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.283]                   }
[10:19:53.283]                 }
[10:19:53.283]                 else {
[10:19:53.283]                   if (TRUE) {
[10:19:53.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.283]                     {
[10:19:53.283]                       inherits <- base::inherits
[10:19:53.283]                       invokeRestart <- base::invokeRestart
[10:19:53.283]                       is.null <- base::is.null
[10:19:53.283]                       muffled <- FALSE
[10:19:53.283]                       if (inherits(cond, "message")) {
[10:19:53.283]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.283]                         if (muffled) 
[10:19:53.283]                           invokeRestart("muffleMessage")
[10:19:53.283]                       }
[10:19:53.283]                       else if (inherits(cond, "warning")) {
[10:19:53.283]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.283]                         if (muffled) 
[10:19:53.283]                           invokeRestart("muffleWarning")
[10:19:53.283]                       }
[10:19:53.283]                       else if (inherits(cond, "condition")) {
[10:19:53.283]                         if (!is.null(pattern)) {
[10:19:53.283]                           computeRestarts <- base::computeRestarts
[10:19:53.283]                           grepl <- base::grepl
[10:19:53.283]                           restarts <- computeRestarts(cond)
[10:19:53.283]                           for (restart in restarts) {
[10:19:53.283]                             name <- restart$name
[10:19:53.283]                             if (is.null(name)) 
[10:19:53.283]                               next
[10:19:53.283]                             if (!grepl(pattern, name)) 
[10:19:53.283]                               next
[10:19:53.283]                             invokeRestart(restart)
[10:19:53.283]                             muffled <- TRUE
[10:19:53.283]                             break
[10:19:53.283]                           }
[10:19:53.283]                         }
[10:19:53.283]                       }
[10:19:53.283]                       invisible(muffled)
[10:19:53.283]                     }
[10:19:53.283]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.283]                   }
[10:19:53.283]                 }
[10:19:53.283]             }
[10:19:53.283]         }))
[10:19:53.283]     }, error = function(ex) {
[10:19:53.283]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.283]                 ...future.rng), started = ...future.startTime, 
[10:19:53.283]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.283]             version = "1.8"), class = "FutureResult")
[10:19:53.283]     }, finally = {
[10:19:53.283]         if (!identical(...future.workdir, getwd())) 
[10:19:53.283]             setwd(...future.workdir)
[10:19:53.283]         {
[10:19:53.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.283]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.283]             }
[10:19:53.283]             base::options(...future.oldOptions)
[10:19:53.283]             if (.Platform$OS.type == "windows") {
[10:19:53.283]                 old_names <- names(...future.oldEnvVars)
[10:19:53.283]                 envs <- base::Sys.getenv()
[10:19:53.283]                 names <- names(envs)
[10:19:53.283]                 common <- intersect(names, old_names)
[10:19:53.283]                 added <- setdiff(names, old_names)
[10:19:53.283]                 removed <- setdiff(old_names, names)
[10:19:53.283]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.283]                   envs[common]]
[10:19:53.283]                 NAMES <- toupper(changed)
[10:19:53.283]                 args <- list()
[10:19:53.283]                 for (kk in seq_along(NAMES)) {
[10:19:53.283]                   name <- changed[[kk]]
[10:19:53.283]                   NAME <- NAMES[[kk]]
[10:19:53.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.283]                     next
[10:19:53.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.283]                 }
[10:19:53.283]                 NAMES <- toupper(added)
[10:19:53.283]                 for (kk in seq_along(NAMES)) {
[10:19:53.283]                   name <- added[[kk]]
[10:19:53.283]                   NAME <- NAMES[[kk]]
[10:19:53.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.283]                     next
[10:19:53.283]                   args[[name]] <- ""
[10:19:53.283]                 }
[10:19:53.283]                 NAMES <- toupper(removed)
[10:19:53.283]                 for (kk in seq_along(NAMES)) {
[10:19:53.283]                   name <- removed[[kk]]
[10:19:53.283]                   NAME <- NAMES[[kk]]
[10:19:53.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.283]                     next
[10:19:53.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.283]                 }
[10:19:53.283]                 if (length(args) > 0) 
[10:19:53.283]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.283]             }
[10:19:53.283]             else {
[10:19:53.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.283]             }
[10:19:53.283]             {
[10:19:53.283]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.283]                   0L) {
[10:19:53.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.283]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.283]                   base::options(opts)
[10:19:53.283]                 }
[10:19:53.283]                 {
[10:19:53.283]                   {
[10:19:53.283]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.283]                     NULL
[10:19:53.283]                   }
[10:19:53.283]                   options(future.plan = NULL)
[10:19:53.283]                   if (is.na(NA_character_)) 
[10:19:53.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.283]                     .init = FALSE)
[10:19:53.283]                 }
[10:19:53.283]             }
[10:19:53.283]         }
[10:19:53.283]     })
[10:19:53.283]     if (TRUE) {
[10:19:53.283]         base::sink(type = "output", split = FALSE)
[10:19:53.283]         if (TRUE) {
[10:19:53.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.283]         }
[10:19:53.283]         else {
[10:19:53.283]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.283]         }
[10:19:53.283]         base::close(...future.stdout)
[10:19:53.283]         ...future.stdout <- NULL
[10:19:53.283]     }
[10:19:53.283]     ...future.result$conditions <- ...future.conditions
[10:19:53.283]     ...future.result$finished <- base::Sys.time()
[10:19:53.283]     ...future.result
[10:19:53.283] }
[10:19:53.286] assign_globals() ...
[10:19:53.286] List of 5
[10:19:53.286]  $ ...future.FUN            :function (x, y)  
[10:19:53.286]  $ future.call.arguments    :List of 1
[10:19:53.286]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.286]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.286]  $ ...future.elements_ii    :List of 2
[10:19:53.286]   ..$ A: num 50
[10:19:53.286]   ..$ B: num 60
[10:19:53.286]  $ ...future.seeds_ii       : NULL
[10:19:53.286]  $ ...future.globals.maxSize: NULL
[10:19:53.286]  - attr(*, "where")=List of 5
[10:19:53.286]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.286]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.286]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.286]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.286]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.286]  - attr(*, "resolved")= logi FALSE
[10:19:53.286]  - attr(*, "total_size")= num 7318
[10:19:53.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.286]  - attr(*, "already-done")= logi TRUE
[10:19:53.294] - reassign environment for ‘...future.FUN’
[10:19:53.294] - copied ‘...future.FUN’ to environment
[10:19:53.294] - copied ‘future.call.arguments’ to environment
[10:19:53.294] - copied ‘...future.elements_ii’ to environment
[10:19:53.294] - copied ‘...future.seeds_ii’ to environment
[10:19:53.294] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.295] assign_globals() ... done
[10:19:53.295] requestCore(): workers = 2
[10:19:53.297] MulticoreFuture started
[10:19:53.297] - Launch lazy future ... done
[10:19:53.297] run() for ‘MulticoreFuture’ ... done
[10:19:53.298] plan(): Setting new future strategy stack:
[10:19:53.298] Created future:
[10:19:53.298] List of future strategies:
[10:19:53.298] 1. sequential:
[10:19:53.298]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.298]    - tweaked: FALSE
[10:19:53.298]    - call: NULL
[10:19:53.299] plan(): nbrOfWorkers() = 1
[10:19:53.301] plan(): Setting new future strategy stack:
[10:19:53.302] List of future strategies:
[10:19:53.302] 1. multicore:
[10:19:53.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.302]    - tweaked: FALSE
[10:19:53.302]    - call: plan(strategy)
[10:19:53.305] plan(): nbrOfWorkers() = 2
[10:19:53.298] MulticoreFuture:
[10:19:53.298] Label: ‘future_sapply-1’
[10:19:53.298] Expression:
[10:19:53.298] {
[10:19:53.298]     do.call(function(...) {
[10:19:53.298]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.298]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.298]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.298]             on.exit(options(oopts), add = TRUE)
[10:19:53.298]         }
[10:19:53.298]         {
[10:19:53.298]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.298]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.298]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.298]             })
[10:19:53.298]         }
[10:19:53.298]     }, args = future.call.arguments)
[10:19:53.298] }
[10:19:53.298] Lazy evaluation: FALSE
[10:19:53.298] Asynchronous evaluation: TRUE
[10:19:53.298] Local evaluation: TRUE
[10:19:53.298] Environment: R_GlobalEnv
[10:19:53.298] Capture standard output: TRUE
[10:19:53.298] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.298] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:53.298] Packages: <none>
[10:19:53.298] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.298] Resolved: TRUE
[10:19:53.298] Value: <not collected>
[10:19:53.298] Conditions captured: <none>
[10:19:53.298] Early signaling: FALSE
[10:19:53.298] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.298] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.306] Chunk #1 of 2 ... DONE
[10:19:53.306] Chunk #2 of 2 ...
[10:19:53.307]  - Finding globals in 'X' for chunk #2 ...
[10:19:53.307] getGlobalsAndPackages() ...
[10:19:53.307] Searching for globals...
[10:19:53.307] 
[10:19:53.307] Searching for globals ... DONE
[10:19:53.308] - globals: [0] <none>
[10:19:53.308] getGlobalsAndPackages() ... DONE
[10:19:53.308]    + additional globals found: [n=0] 
[10:19:53.308]    + additional namespaces needed: [n=0] 
[10:19:53.308]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:53.308]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.308]  - seeds: <none>
[10:19:53.309]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.309] getGlobalsAndPackages() ...
[10:19:53.309] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.309] Resolving globals: FALSE
[10:19:53.309] Tweak future expression to call with '...' arguments ...
[10:19:53.310] {
[10:19:53.310]     do.call(function(...) {
[10:19:53.310]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.310]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.310]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.310]             on.exit(options(oopts), add = TRUE)
[10:19:53.310]         }
[10:19:53.310]         {
[10:19:53.310]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.310]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.310]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.310]             })
[10:19:53.310]         }
[10:19:53.310]     }, args = future.call.arguments)
[10:19:53.310] }
[10:19:53.310] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.311] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.311] 
[10:19:53.311] getGlobalsAndPackages() ... DONE
[10:19:53.312] run() for ‘Future’ ...
[10:19:53.312] - state: ‘created’
[10:19:53.312] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.315] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.315]   - Field: ‘label’
[10:19:53.315]   - Field: ‘local’
[10:19:53.315]   - Field: ‘owner’
[10:19:53.315]   - Field: ‘envir’
[10:19:53.316]   - Field: ‘workers’
[10:19:53.316]   - Field: ‘packages’
[10:19:53.316]   - Field: ‘gc’
[10:19:53.316]   - Field: ‘job’
[10:19:53.316]   - Field: ‘conditions’
[10:19:53.316]   - Field: ‘expr’
[10:19:53.316]   - Field: ‘uuid’
[10:19:53.317]   - Field: ‘seed’
[10:19:53.317]   - Field: ‘version’
[10:19:53.317]   - Field: ‘result’
[10:19:53.317]   - Field: ‘asynchronous’
[10:19:53.317]   - Field: ‘calls’
[10:19:53.317]   - Field: ‘globals’
[10:19:53.317]   - Field: ‘stdout’
[10:19:53.317]   - Field: ‘earlySignal’
[10:19:53.318]   - Field: ‘lazy’
[10:19:53.318]   - Field: ‘state’
[10:19:53.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.318] - Launch lazy future ...
[10:19:53.319] Packages needed by the future expression (n = 0): <none>
[10:19:53.319] Packages needed by future strategies (n = 0): <none>
[10:19:53.319] {
[10:19:53.319]     {
[10:19:53.319]         {
[10:19:53.319]             ...future.startTime <- base::Sys.time()
[10:19:53.319]             {
[10:19:53.319]                 {
[10:19:53.319]                   {
[10:19:53.319]                     {
[10:19:53.319]                       base::local({
[10:19:53.319]                         has_future <- base::requireNamespace("future", 
[10:19:53.319]                           quietly = TRUE)
[10:19:53.319]                         if (has_future) {
[10:19:53.319]                           ns <- base::getNamespace("future")
[10:19:53.319]                           version <- ns[[".package"]][["version"]]
[10:19:53.319]                           if (is.null(version)) 
[10:19:53.319]                             version <- utils::packageVersion("future")
[10:19:53.319]                         }
[10:19:53.319]                         else {
[10:19:53.319]                           version <- NULL
[10:19:53.319]                         }
[10:19:53.319]                         if (!has_future || version < "1.8.0") {
[10:19:53.319]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.319]                             "", base::R.version$version.string), 
[10:19:53.319]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:53.319]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:53.319]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.319]                               "release", "version")], collapse = " "), 
[10:19:53.319]                             hostname = base::Sys.info()[["nodename"]])
[10:19:53.319]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.319]                             info)
[10:19:53.319]                           info <- base::paste(info, collapse = "; ")
[10:19:53.319]                           if (!has_future) {
[10:19:53.319]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.319]                               info)
[10:19:53.319]                           }
[10:19:53.319]                           else {
[10:19:53.319]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.319]                               info, version)
[10:19:53.319]                           }
[10:19:53.319]                           base::stop(msg)
[10:19:53.319]                         }
[10:19:53.319]                       })
[10:19:53.319]                     }
[10:19:53.319]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.319]                     base::options(mc.cores = 1L)
[10:19:53.319]                   }
[10:19:53.319]                   ...future.strategy.old <- future::plan("list")
[10:19:53.319]                   options(future.plan = NULL)
[10:19:53.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.319]                 }
[10:19:53.319]                 ...future.workdir <- getwd()
[10:19:53.319]             }
[10:19:53.319]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.319]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.319]         }
[10:19:53.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.319]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.319]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.319]             base::names(...future.oldOptions))
[10:19:53.319]     }
[10:19:53.319]     if (FALSE) {
[10:19:53.319]     }
[10:19:53.319]     else {
[10:19:53.319]         if (TRUE) {
[10:19:53.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.319]                 open = "w")
[10:19:53.319]         }
[10:19:53.319]         else {
[10:19:53.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.319]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.319]         }
[10:19:53.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.319]             base::sink(type = "output", split = FALSE)
[10:19:53.319]             base::close(...future.stdout)
[10:19:53.319]         }, add = TRUE)
[10:19:53.319]     }
[10:19:53.319]     ...future.frame <- base::sys.nframe()
[10:19:53.319]     ...future.conditions <- base::list()
[10:19:53.319]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.319]     if (FALSE) {
[10:19:53.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.319]     }
[10:19:53.319]     ...future.result <- base::tryCatch({
[10:19:53.319]         base::withCallingHandlers({
[10:19:53.319]             ...future.value <- base::withVisible(base::local({
[10:19:53.319]                 withCallingHandlers({
[10:19:53.319]                   {
[10:19:53.319]                     do.call(function(...) {
[10:19:53.319]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.319]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.319]                         ...future.globals.maxSize)) {
[10:19:53.319]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.319]                         on.exit(options(oopts), add = TRUE)
[10:19:53.319]                       }
[10:19:53.319]                       {
[10:19:53.319]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.319]                           FUN = function(jj) {
[10:19:53.319]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.319]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.319]                           })
[10:19:53.319]                       }
[10:19:53.319]                     }, args = future.call.arguments)
[10:19:53.319]                   }
[10:19:53.319]                 }, immediateCondition = function(cond) {
[10:19:53.319]                   save_rds <- function (object, pathname, ...) 
[10:19:53.319]                   {
[10:19:53.319]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.319]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.319]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.319]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.319]                         fi_tmp[["mtime"]])
[10:19:53.319]                     }
[10:19:53.319]                     tryCatch({
[10:19:53.319]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.319]                     }, error = function(ex) {
[10:19:53.319]                       msg <- conditionMessage(ex)
[10:19:53.319]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.319]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.319]                         fi_tmp[["mtime"]], msg)
[10:19:53.319]                       ex$message <- msg
[10:19:53.319]                       stop(ex)
[10:19:53.319]                     })
[10:19:53.319]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.319]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.319]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.319]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.319]                       fi <- file.info(pathname)
[10:19:53.319]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.319]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.319]                         fi[["size"]], fi[["mtime"]])
[10:19:53.319]                       stop(msg)
[10:19:53.319]                     }
[10:19:53.319]                     invisible(pathname)
[10:19:53.319]                   }
[10:19:53.319]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.319]                     rootPath = tempdir()) 
[10:19:53.319]                   {
[10:19:53.319]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.319]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.319]                       tmpdir = path, fileext = ".rds")
[10:19:53.319]                     save_rds(obj, file)
[10:19:53.319]                   }
[10:19:53.319]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.319]                   {
[10:19:53.319]                     inherits <- base::inherits
[10:19:53.319]                     invokeRestart <- base::invokeRestart
[10:19:53.319]                     is.null <- base::is.null
[10:19:53.319]                     muffled <- FALSE
[10:19:53.319]                     if (inherits(cond, "message")) {
[10:19:53.319]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.319]                       if (muffled) 
[10:19:53.319]                         invokeRestart("muffleMessage")
[10:19:53.319]                     }
[10:19:53.319]                     else if (inherits(cond, "warning")) {
[10:19:53.319]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.319]                       if (muffled) 
[10:19:53.319]                         invokeRestart("muffleWarning")
[10:19:53.319]                     }
[10:19:53.319]                     else if (inherits(cond, "condition")) {
[10:19:53.319]                       if (!is.null(pattern)) {
[10:19:53.319]                         computeRestarts <- base::computeRestarts
[10:19:53.319]                         grepl <- base::grepl
[10:19:53.319]                         restarts <- computeRestarts(cond)
[10:19:53.319]                         for (restart in restarts) {
[10:19:53.319]                           name <- restart$name
[10:19:53.319]                           if (is.null(name)) 
[10:19:53.319]                             next
[10:19:53.319]                           if (!grepl(pattern, name)) 
[10:19:53.319]                             next
[10:19:53.319]                           invokeRestart(restart)
[10:19:53.319]                           muffled <- TRUE
[10:19:53.319]                           break
[10:19:53.319]                         }
[10:19:53.319]                       }
[10:19:53.319]                     }
[10:19:53.319]                     invisible(muffled)
[10:19:53.319]                   }
[10:19:53.319]                   muffleCondition(cond)
[10:19:53.319]                 })
[10:19:53.319]             }))
[10:19:53.319]             future::FutureResult(value = ...future.value$value, 
[10:19:53.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.319]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.319]                     ...future.globalenv.names))
[10:19:53.319]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.319]         }, condition = base::local({
[10:19:53.319]             c <- base::c
[10:19:53.319]             inherits <- base::inherits
[10:19:53.319]             invokeRestart <- base::invokeRestart
[10:19:53.319]             length <- base::length
[10:19:53.319]             list <- base::list
[10:19:53.319]             seq.int <- base::seq.int
[10:19:53.319]             signalCondition <- base::signalCondition
[10:19:53.319]             sys.calls <- base::sys.calls
[10:19:53.319]             `[[` <- base::`[[`
[10:19:53.319]             `+` <- base::`+`
[10:19:53.319]             `<<-` <- base::`<<-`
[10:19:53.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.319]                   3L)]
[10:19:53.319]             }
[10:19:53.319]             function(cond) {
[10:19:53.319]                 is_error <- inherits(cond, "error")
[10:19:53.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.319]                   NULL)
[10:19:53.319]                 if (is_error) {
[10:19:53.319]                   sessionInformation <- function() {
[10:19:53.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.319]                       search = base::search(), system = base::Sys.info())
[10:19:53.319]                   }
[10:19:53.319]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.319]                     cond$call), session = sessionInformation(), 
[10:19:53.319]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.319]                   signalCondition(cond)
[10:19:53.319]                 }
[10:19:53.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.319]                 "immediateCondition"))) {
[10:19:53.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.319]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.319]                   if (TRUE && !signal) {
[10:19:53.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.319]                     {
[10:19:53.319]                       inherits <- base::inherits
[10:19:53.319]                       invokeRestart <- base::invokeRestart
[10:19:53.319]                       is.null <- base::is.null
[10:19:53.319]                       muffled <- FALSE
[10:19:53.319]                       if (inherits(cond, "message")) {
[10:19:53.319]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.319]                         if (muffled) 
[10:19:53.319]                           invokeRestart("muffleMessage")
[10:19:53.319]                       }
[10:19:53.319]                       else if (inherits(cond, "warning")) {
[10:19:53.319]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.319]                         if (muffled) 
[10:19:53.319]                           invokeRestart("muffleWarning")
[10:19:53.319]                       }
[10:19:53.319]                       else if (inherits(cond, "condition")) {
[10:19:53.319]                         if (!is.null(pattern)) {
[10:19:53.319]                           computeRestarts <- base::computeRestarts
[10:19:53.319]                           grepl <- base::grepl
[10:19:53.319]                           restarts <- computeRestarts(cond)
[10:19:53.319]                           for (restart in restarts) {
[10:19:53.319]                             name <- restart$name
[10:19:53.319]                             if (is.null(name)) 
[10:19:53.319]                               next
[10:19:53.319]                             if (!grepl(pattern, name)) 
[10:19:53.319]                               next
[10:19:53.319]                             invokeRestart(restart)
[10:19:53.319]                             muffled <- TRUE
[10:19:53.319]                             break
[10:19:53.319]                           }
[10:19:53.319]                         }
[10:19:53.319]                       }
[10:19:53.319]                       invisible(muffled)
[10:19:53.319]                     }
[10:19:53.319]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.319]                   }
[10:19:53.319]                 }
[10:19:53.319]                 else {
[10:19:53.319]                   if (TRUE) {
[10:19:53.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.319]                     {
[10:19:53.319]                       inherits <- base::inherits
[10:19:53.319]                       invokeRestart <- base::invokeRestart
[10:19:53.319]                       is.null <- base::is.null
[10:19:53.319]                       muffled <- FALSE
[10:19:53.319]                       if (inherits(cond, "message")) {
[10:19:53.319]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.319]                         if (muffled) 
[10:19:53.319]                           invokeRestart("muffleMessage")
[10:19:53.319]                       }
[10:19:53.319]                       else if (inherits(cond, "warning")) {
[10:19:53.319]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.319]                         if (muffled) 
[10:19:53.319]                           invokeRestart("muffleWarning")
[10:19:53.319]                       }
[10:19:53.319]                       else if (inherits(cond, "condition")) {
[10:19:53.319]                         if (!is.null(pattern)) {
[10:19:53.319]                           computeRestarts <- base::computeRestarts
[10:19:53.319]                           grepl <- base::grepl
[10:19:53.319]                           restarts <- computeRestarts(cond)
[10:19:53.319]                           for (restart in restarts) {
[10:19:53.319]                             name <- restart$name
[10:19:53.319]                             if (is.null(name)) 
[10:19:53.319]                               next
[10:19:53.319]                             if (!grepl(pattern, name)) 
[10:19:53.319]                               next
[10:19:53.319]                             invokeRestart(restart)
[10:19:53.319]                             muffled <- TRUE
[10:19:53.319]                             break
[10:19:53.319]                           }
[10:19:53.319]                         }
[10:19:53.319]                       }
[10:19:53.319]                       invisible(muffled)
[10:19:53.319]                     }
[10:19:53.319]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.319]                   }
[10:19:53.319]                 }
[10:19:53.319]             }
[10:19:53.319]         }))
[10:19:53.319]     }, error = function(ex) {
[10:19:53.319]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.319]                 ...future.rng), started = ...future.startTime, 
[10:19:53.319]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.319]             version = "1.8"), class = "FutureResult")
[10:19:53.319]     }, finally = {
[10:19:53.319]         if (!identical(...future.workdir, getwd())) 
[10:19:53.319]             setwd(...future.workdir)
[10:19:53.319]         {
[10:19:53.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.319]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.319]             }
[10:19:53.319]             base::options(...future.oldOptions)
[10:19:53.319]             if (.Platform$OS.type == "windows") {
[10:19:53.319]                 old_names <- names(...future.oldEnvVars)
[10:19:53.319]                 envs <- base::Sys.getenv()
[10:19:53.319]                 names <- names(envs)
[10:19:53.319]                 common <- intersect(names, old_names)
[10:19:53.319]                 added <- setdiff(names, old_names)
[10:19:53.319]                 removed <- setdiff(old_names, names)
[10:19:53.319]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.319]                   envs[common]]
[10:19:53.319]                 NAMES <- toupper(changed)
[10:19:53.319]                 args <- list()
[10:19:53.319]                 for (kk in seq_along(NAMES)) {
[10:19:53.319]                   name <- changed[[kk]]
[10:19:53.319]                   NAME <- NAMES[[kk]]
[10:19:53.319]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.319]                     next
[10:19:53.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.319]                 }
[10:19:53.319]                 NAMES <- toupper(added)
[10:19:53.319]                 for (kk in seq_along(NAMES)) {
[10:19:53.319]                   name <- added[[kk]]
[10:19:53.319]                   NAME <- NAMES[[kk]]
[10:19:53.319]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.319]                     next
[10:19:53.319]                   args[[name]] <- ""
[10:19:53.319]                 }
[10:19:53.319]                 NAMES <- toupper(removed)
[10:19:53.319]                 for (kk in seq_along(NAMES)) {
[10:19:53.319]                   name <- removed[[kk]]
[10:19:53.319]                   NAME <- NAMES[[kk]]
[10:19:53.319]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.319]                     next
[10:19:53.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.319]                 }
[10:19:53.319]                 if (length(args) > 0) 
[10:19:53.319]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.319]             }
[10:19:53.319]             else {
[10:19:53.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.319]             }
[10:19:53.319]             {
[10:19:53.319]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.319]                   0L) {
[10:19:53.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.319]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.319]                   base::options(opts)
[10:19:53.319]                 }
[10:19:53.319]                 {
[10:19:53.319]                   {
[10:19:53.319]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.319]                     NULL
[10:19:53.319]                   }
[10:19:53.319]                   options(future.plan = NULL)
[10:19:53.319]                   if (is.na(NA_character_)) 
[10:19:53.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.319]                     .init = FALSE)
[10:19:53.319]                 }
[10:19:53.319]             }
[10:19:53.319]         }
[10:19:53.319]     })
[10:19:53.319]     if (TRUE) {
[10:19:53.319]         base::sink(type = "output", split = FALSE)
[10:19:53.319]         if (TRUE) {
[10:19:53.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.319]         }
[10:19:53.319]         else {
[10:19:53.319]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.319]         }
[10:19:53.319]         base::close(...future.stdout)
[10:19:53.319]         ...future.stdout <- NULL
[10:19:53.319]     }
[10:19:53.319]     ...future.result$conditions <- ...future.conditions
[10:19:53.319]     ...future.result$finished <- base::Sys.time()
[10:19:53.319]     ...future.result
[10:19:53.319] }
[10:19:53.323] assign_globals() ...
[10:19:53.323] List of 5
[10:19:53.323]  $ ...future.FUN            :function (x, y)  
[10:19:53.323]  $ future.call.arguments    :List of 1
[10:19:53.323]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.323]  $ ...future.elements_ii    :List of 2
[10:19:53.323]   ..$ C: num 70
[10:19:53.323]   ..$ D: num 80
[10:19:53.323]  $ ...future.seeds_ii       : NULL
[10:19:53.323]  $ ...future.globals.maxSize: NULL
[10:19:53.323]  - attr(*, "where")=List of 5
[10:19:53.323]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.323]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.323]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.323]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.323]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.323]  - attr(*, "resolved")= logi FALSE
[10:19:53.323]  - attr(*, "total_size")= num 7318
[10:19:53.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.323]  - attr(*, "already-done")= logi TRUE
[10:19:53.336] - reassign environment for ‘...future.FUN’
[10:19:53.336] - copied ‘...future.FUN’ to environment
[10:19:53.336] - copied ‘future.call.arguments’ to environment
[10:19:53.336] - copied ‘...future.elements_ii’ to environment
[10:19:53.337] - copied ‘...future.seeds_ii’ to environment
[10:19:53.337] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.337] assign_globals() ... done
[10:19:53.337] requestCore(): workers = 2
[10:19:53.340] MulticoreFuture started
[10:19:53.341] - Launch lazy future ... done
[10:19:53.341] run() for ‘MulticoreFuture’ ... done
[10:19:53.342] plan(): Setting new future strategy stack:
[10:19:53.342] Created future:
[10:19:53.342] List of future strategies:
[10:19:53.342] 1. sequential:
[10:19:53.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.342]    - tweaked: FALSE
[10:19:53.342]    - call: NULL
[10:19:53.344] plan(): nbrOfWorkers() = 1
[10:19:53.347] plan(): Setting new future strategy stack:
[10:19:53.347] List of future strategies:
[10:19:53.347] 1. multicore:
[10:19:53.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.347]    - tweaked: FALSE
[10:19:53.347]    - call: plan(strategy)
[10:19:53.351] plan(): nbrOfWorkers() = 2
[10:19:53.343] MulticoreFuture:
[10:19:53.343] Label: ‘future_sapply-2’
[10:19:53.343] Expression:
[10:19:53.343] {
[10:19:53.343]     do.call(function(...) {
[10:19:53.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.343]             on.exit(options(oopts), add = TRUE)
[10:19:53.343]         }
[10:19:53.343]         {
[10:19:53.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.343]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.343]             })
[10:19:53.343]         }
[10:19:53.343]     }, args = future.call.arguments)
[10:19:53.343] }
[10:19:53.343] Lazy evaluation: FALSE
[10:19:53.343] Asynchronous evaluation: TRUE
[10:19:53.343] Local evaluation: TRUE
[10:19:53.343] Environment: R_GlobalEnv
[10:19:53.343] Capture standard output: TRUE
[10:19:53.343] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.343] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:53.343] Packages: <none>
[10:19:53.343] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.343] Resolved: TRUE
[10:19:53.343] Value: <not collected>
[10:19:53.343] Conditions captured: <none>
[10:19:53.343] Early signaling: FALSE
[10:19:53.343] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.343] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.352] Chunk #2 of 2 ... DONE
[10:19:53.352] Launching 2 futures (chunks) ... DONE
[10:19:53.352] Resolving 2 futures (chunks) ...
[10:19:53.352] resolve() on list ...
[10:19:53.352]  recursive: 0
[10:19:53.353]  length: 2
[10:19:53.353] 
[10:19:53.353] Future #1
[10:19:53.353] result() for MulticoreFuture ...
[10:19:53.354] result() for MulticoreFuture ...
[10:19:53.354] result() for MulticoreFuture ... done
[10:19:53.354] result() for MulticoreFuture ... done
[10:19:53.355] result() for MulticoreFuture ...
[10:19:53.355] result() for MulticoreFuture ... done
[10:19:53.355] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:53.355] - nx: 2
[10:19:53.355] - relay: TRUE
[10:19:53.355] - stdout: TRUE
[10:19:53.356] - signal: TRUE
[10:19:53.356] - resignal: FALSE
[10:19:53.356] - force: TRUE
[10:19:53.356] - relayed: [n=2] FALSE, FALSE
[10:19:53.356] - queued futures: [n=2] FALSE, FALSE
[10:19:53.356]  - until=1
[10:19:53.357]  - relaying element #1
[10:19:53.357] result() for MulticoreFuture ...
[10:19:53.357] result() for MulticoreFuture ... done
[10:19:53.357] result() for MulticoreFuture ...
[10:19:53.357] result() for MulticoreFuture ... done
[10:19:53.357] result() for MulticoreFuture ...
[10:19:53.358] result() for MulticoreFuture ... done
[10:19:53.358] result() for MulticoreFuture ...
[10:19:53.358] result() for MulticoreFuture ... done
[10:19:53.358] - relayed: [n=2] TRUE, FALSE
[10:19:53.358] - queued futures: [n=2] TRUE, FALSE
[10:19:53.358] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:53.359]  length: 1 (resolved future 1)
[10:19:53.359] Future #2
[10:19:53.359] result() for MulticoreFuture ...
[10:19:53.360] result() for MulticoreFuture ...
[10:19:53.360] result() for MulticoreFuture ... done
[10:19:53.360] result() for MulticoreFuture ... done
[10:19:53.360] result() for MulticoreFuture ...
[10:19:53.360] result() for MulticoreFuture ... done
[10:19:53.361] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:53.361] - nx: 2
[10:19:53.361] - relay: TRUE
[10:19:53.361] - stdout: TRUE
[10:19:53.361] - signal: TRUE
[10:19:53.361] - resignal: FALSE
[10:19:53.361] - force: TRUE
[10:19:53.361] - relayed: [n=2] TRUE, FALSE
[10:19:53.361] - queued futures: [n=2] TRUE, FALSE
[10:19:53.362]  - until=2
[10:19:53.362]  - relaying element #2
[10:19:53.362] result() for MulticoreFuture ...
[10:19:53.362] result() for MulticoreFuture ... done
[10:19:53.362] result() for MulticoreFuture ...
[10:19:53.362] result() for MulticoreFuture ... done
[10:19:53.362] result() for MulticoreFuture ...
[10:19:53.362] result() for MulticoreFuture ... done
[10:19:53.363] result() for MulticoreFuture ...
[10:19:53.363] result() for MulticoreFuture ... done
[10:19:53.363] - relayed: [n=2] TRUE, TRUE
[10:19:53.363] - queued futures: [n=2] TRUE, TRUE
[10:19:53.363] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:53.363]  length: 0 (resolved future 2)
[10:19:53.363] Relaying remaining futures
[10:19:53.363] signalConditionsASAP(NULL, pos=0) ...
[10:19:53.363] - nx: 2
[10:19:53.364] - relay: TRUE
[10:19:53.364] - stdout: TRUE
[10:19:53.364] - signal: TRUE
[10:19:53.364] - resignal: FALSE
[10:19:53.364] - force: TRUE
[10:19:53.364] - relayed: [n=2] TRUE, TRUE
[10:19:53.364] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:53.364] - relayed: [n=2] TRUE, TRUE
[10:19:53.364] - queued futures: [n=2] TRUE, TRUE
[10:19:53.365] signalConditionsASAP(NULL, pos=0) ... done
[10:19:53.365] resolve() on list ... DONE
[10:19:53.365] result() for MulticoreFuture ...
[10:19:53.365] result() for MulticoreFuture ... done
[10:19:53.365] result() for MulticoreFuture ...
[10:19:53.365] result() for MulticoreFuture ... done
[10:19:53.365] result() for MulticoreFuture ...
[10:19:53.365] result() for MulticoreFuture ... done
[10:19:53.365] result() for MulticoreFuture ...
[10:19:53.365] result() for MulticoreFuture ... done
[10:19:53.366]  - Number of value chunks collected: 2
[10:19:53.366] Resolving 2 futures (chunks) ... DONE
[10:19:53.366] Reducing values from 2 chunks ...
[10:19:53.366]  - Number of values collected after concatenation: 4
[10:19:53.366]  - Number of values expected: 4
[10:19:53.366] Reducing values from 2 chunks ... DONE
[10:19:53.366] future_lapply() ... DONE
[10:19:53.367] future_lapply() ...
[10:19:53.374] Number of chunks: 2
[10:19:53.374] getGlobalsAndPackagesXApply() ...
[10:19:53.374]  - future.globals: TRUE
[10:19:53.374] getGlobalsAndPackages() ...
[10:19:53.375] Searching for globals...
[10:19:53.380] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:19:53.380] Searching for globals ... DONE
[10:19:53.380] Resolving globals: FALSE
[10:19:53.381] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[10:19:53.382] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:53.382] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.382] - packages: [1] ‘future.apply’
[10:19:53.382] getGlobalsAndPackages() ... DONE
[10:19:53.382]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.382]  - needed namespaces: [n=1] ‘future.apply’
[10:19:53.382] Finding globals ... DONE
[10:19:53.382]  - use_args: TRUE
[10:19:53.382]  - Getting '...' globals ...
[10:19:53.383] resolve() on list ...
[10:19:53.383]  recursive: 0
[10:19:53.383]  length: 1
[10:19:53.383]  elements: ‘...’
[10:19:53.383]  length: 0 (resolved future 1)
[10:19:53.383] resolve() on list ... DONE
[10:19:53.383]    - '...' content: [n=1] ‘y’
[10:19:53.384] List of 1
[10:19:53.384]  $ ...:List of 1
[10:19:53.384]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.384]  - attr(*, "where")=List of 1
[10:19:53.384]   ..$ ...:<environment: 0x55c69fbb0e78> 
[10:19:53.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.384]  - attr(*, "resolved")= logi TRUE
[10:19:53.384]  - attr(*, "total_size")= num NA
[10:19:53.387]  - Getting '...' globals ... DONE
[10:19:53.387] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:53.387] List of 8
[10:19:53.387]  $ ...future.FUN:function (x, ...)  
[10:19:53.387]  $ x_FUN        :function (x, y)  
[10:19:53.387]  $ times        : int 15
[10:19:53.387]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.387]  $ stop_if_not  :function (...)  
[10:19:53.387]  $ dim          : int [1:2] 3 5
[10:19:53.387]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:53.387]  $ ...          :List of 1
[10:19:53.387]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.387]  - attr(*, "where")=List of 8
[10:19:53.387]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:53.387]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:53.387]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:53.387]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:53.387]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:53.387]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:53.387]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:53.387]   ..$ ...          :<environment: 0x55c69fbb0e78> 
[10:19:53.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.387]  - attr(*, "resolved")= logi FALSE
[10:19:53.387]  - attr(*, "total_size")= num 26659
[10:19:53.398] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:53.398] getGlobalsAndPackagesXApply() ... DONE
[10:19:53.398] Number of futures (= number of chunks): 2
[10:19:53.398] Launching 2 futures (chunks) ...
[10:19:53.398] Chunk #1 of 2 ...
[10:19:53.398]  - Finding globals in 'X' for chunk #1 ...
[10:19:53.399] getGlobalsAndPackages() ...
[10:19:53.399] Searching for globals...
[10:19:53.399] 
[10:19:53.399] Searching for globals ... DONE
[10:19:53.399] - globals: [0] <none>
[10:19:53.399] getGlobalsAndPackages() ... DONE
[10:19:53.399]    + additional globals found: [n=0] 
[10:19:53.399]    + additional namespaces needed: [n=0] 
[10:19:53.400]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:53.400]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.400]  - seeds: <none>
[10:19:53.400]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.400] getGlobalsAndPackages() ...
[10:19:53.400] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.400] Resolving globals: FALSE
[10:19:53.400] Tweak future expression to call with '...' arguments ...
[10:19:53.400] {
[10:19:53.400]     do.call(function(...) {
[10:19:53.400]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.400]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.400]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.400]             on.exit(options(oopts), add = TRUE)
[10:19:53.400]         }
[10:19:53.400]         {
[10:19:53.400]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.400]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.400]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.400]             })
[10:19:53.400]         }
[10:19:53.400]     }, args = future.call.arguments)
[10:19:53.400] }
[10:19:53.401] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.401] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.402] - packages: [1] ‘future.apply’
[10:19:53.402] getGlobalsAndPackages() ... DONE
[10:19:53.402] run() for ‘Future’ ...
[10:19:53.402] - state: ‘created’
[10:19:53.402] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.404] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.405]   - Field: ‘label’
[10:19:53.405]   - Field: ‘local’
[10:19:53.405]   - Field: ‘owner’
[10:19:53.405]   - Field: ‘envir’
[10:19:53.405]   - Field: ‘workers’
[10:19:53.405]   - Field: ‘packages’
[10:19:53.405]   - Field: ‘gc’
[10:19:53.405]   - Field: ‘job’
[10:19:53.405]   - Field: ‘conditions’
[10:19:53.405]   - Field: ‘expr’
[10:19:53.406]   - Field: ‘uuid’
[10:19:53.406]   - Field: ‘seed’
[10:19:53.406]   - Field: ‘version’
[10:19:53.406]   - Field: ‘result’
[10:19:53.406]   - Field: ‘asynchronous’
[10:19:53.406]   - Field: ‘calls’
[10:19:53.406]   - Field: ‘globals’
[10:19:53.406]   - Field: ‘stdout’
[10:19:53.406]   - Field: ‘earlySignal’
[10:19:53.406]   - Field: ‘lazy’
[10:19:53.406]   - Field: ‘state’
[10:19:53.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.407] - Launch lazy future ...
[10:19:53.407] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.407] Packages needed by future strategies (n = 0): <none>
[10:19:53.408] {
[10:19:53.408]     {
[10:19:53.408]         {
[10:19:53.408]             ...future.startTime <- base::Sys.time()
[10:19:53.408]             {
[10:19:53.408]                 {
[10:19:53.408]                   {
[10:19:53.408]                     {
[10:19:53.408]                       {
[10:19:53.408]                         base::local({
[10:19:53.408]                           has_future <- base::requireNamespace("future", 
[10:19:53.408]                             quietly = TRUE)
[10:19:53.408]                           if (has_future) {
[10:19:53.408]                             ns <- base::getNamespace("future")
[10:19:53.408]                             version <- ns[[".package"]][["version"]]
[10:19:53.408]                             if (is.null(version)) 
[10:19:53.408]                               version <- utils::packageVersion("future")
[10:19:53.408]                           }
[10:19:53.408]                           else {
[10:19:53.408]                             version <- NULL
[10:19:53.408]                           }
[10:19:53.408]                           if (!has_future || version < "1.8.0") {
[10:19:53.408]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.408]                               "", base::R.version$version.string), 
[10:19:53.408]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.408]                                 base::R.version$platform, 8 * 
[10:19:53.408]                                   base::.Machine$sizeof.pointer), 
[10:19:53.408]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.408]                                 "release", "version")], collapse = " "), 
[10:19:53.408]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.408]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.408]                               info)
[10:19:53.408]                             info <- base::paste(info, collapse = "; ")
[10:19:53.408]                             if (!has_future) {
[10:19:53.408]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.408]                                 info)
[10:19:53.408]                             }
[10:19:53.408]                             else {
[10:19:53.408]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.408]                                 info, version)
[10:19:53.408]                             }
[10:19:53.408]                             base::stop(msg)
[10:19:53.408]                           }
[10:19:53.408]                         })
[10:19:53.408]                       }
[10:19:53.408]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.408]                       base::options(mc.cores = 1L)
[10:19:53.408]                     }
[10:19:53.408]                     base::local({
[10:19:53.408]                       for (pkg in "future.apply") {
[10:19:53.408]                         base::loadNamespace(pkg)
[10:19:53.408]                         base::library(pkg, character.only = TRUE)
[10:19:53.408]                       }
[10:19:53.408]                     })
[10:19:53.408]                   }
[10:19:53.408]                   ...future.strategy.old <- future::plan("list")
[10:19:53.408]                   options(future.plan = NULL)
[10:19:53.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.408]                 }
[10:19:53.408]                 ...future.workdir <- getwd()
[10:19:53.408]             }
[10:19:53.408]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.408]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.408]         }
[10:19:53.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.408]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.408]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.408]             base::names(...future.oldOptions))
[10:19:53.408]     }
[10:19:53.408]     if (FALSE) {
[10:19:53.408]     }
[10:19:53.408]     else {
[10:19:53.408]         if (TRUE) {
[10:19:53.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.408]                 open = "w")
[10:19:53.408]         }
[10:19:53.408]         else {
[10:19:53.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.408]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.408]         }
[10:19:53.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.408]             base::sink(type = "output", split = FALSE)
[10:19:53.408]             base::close(...future.stdout)
[10:19:53.408]         }, add = TRUE)
[10:19:53.408]     }
[10:19:53.408]     ...future.frame <- base::sys.nframe()
[10:19:53.408]     ...future.conditions <- base::list()
[10:19:53.408]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.408]     if (FALSE) {
[10:19:53.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.408]     }
[10:19:53.408]     ...future.result <- base::tryCatch({
[10:19:53.408]         base::withCallingHandlers({
[10:19:53.408]             ...future.value <- base::withVisible(base::local({
[10:19:53.408]                 withCallingHandlers({
[10:19:53.408]                   {
[10:19:53.408]                     do.call(function(...) {
[10:19:53.408]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.408]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.408]                         ...future.globals.maxSize)) {
[10:19:53.408]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.408]                         on.exit(options(oopts), add = TRUE)
[10:19:53.408]                       }
[10:19:53.408]                       {
[10:19:53.408]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.408]                           FUN = function(jj) {
[10:19:53.408]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.408]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.408]                           })
[10:19:53.408]                       }
[10:19:53.408]                     }, args = future.call.arguments)
[10:19:53.408]                   }
[10:19:53.408]                 }, immediateCondition = function(cond) {
[10:19:53.408]                   save_rds <- function (object, pathname, ...) 
[10:19:53.408]                   {
[10:19:53.408]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.408]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.408]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.408]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.408]                         fi_tmp[["mtime"]])
[10:19:53.408]                     }
[10:19:53.408]                     tryCatch({
[10:19:53.408]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.408]                     }, error = function(ex) {
[10:19:53.408]                       msg <- conditionMessage(ex)
[10:19:53.408]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.408]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.408]                         fi_tmp[["mtime"]], msg)
[10:19:53.408]                       ex$message <- msg
[10:19:53.408]                       stop(ex)
[10:19:53.408]                     })
[10:19:53.408]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.408]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.408]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.408]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.408]                       fi <- file.info(pathname)
[10:19:53.408]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.408]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.408]                         fi[["size"]], fi[["mtime"]])
[10:19:53.408]                       stop(msg)
[10:19:53.408]                     }
[10:19:53.408]                     invisible(pathname)
[10:19:53.408]                   }
[10:19:53.408]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.408]                     rootPath = tempdir()) 
[10:19:53.408]                   {
[10:19:53.408]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.408]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.408]                       tmpdir = path, fileext = ".rds")
[10:19:53.408]                     save_rds(obj, file)
[10:19:53.408]                   }
[10:19:53.408]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.408]                   {
[10:19:53.408]                     inherits <- base::inherits
[10:19:53.408]                     invokeRestart <- base::invokeRestart
[10:19:53.408]                     is.null <- base::is.null
[10:19:53.408]                     muffled <- FALSE
[10:19:53.408]                     if (inherits(cond, "message")) {
[10:19:53.408]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.408]                       if (muffled) 
[10:19:53.408]                         invokeRestart("muffleMessage")
[10:19:53.408]                     }
[10:19:53.408]                     else if (inherits(cond, "warning")) {
[10:19:53.408]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.408]                       if (muffled) 
[10:19:53.408]                         invokeRestart("muffleWarning")
[10:19:53.408]                     }
[10:19:53.408]                     else if (inherits(cond, "condition")) {
[10:19:53.408]                       if (!is.null(pattern)) {
[10:19:53.408]                         computeRestarts <- base::computeRestarts
[10:19:53.408]                         grepl <- base::grepl
[10:19:53.408]                         restarts <- computeRestarts(cond)
[10:19:53.408]                         for (restart in restarts) {
[10:19:53.408]                           name <- restart$name
[10:19:53.408]                           if (is.null(name)) 
[10:19:53.408]                             next
[10:19:53.408]                           if (!grepl(pattern, name)) 
[10:19:53.408]                             next
[10:19:53.408]                           invokeRestart(restart)
[10:19:53.408]                           muffled <- TRUE
[10:19:53.408]                           break
[10:19:53.408]                         }
[10:19:53.408]                       }
[10:19:53.408]                     }
[10:19:53.408]                     invisible(muffled)
[10:19:53.408]                   }
[10:19:53.408]                   muffleCondition(cond)
[10:19:53.408]                 })
[10:19:53.408]             }))
[10:19:53.408]             future::FutureResult(value = ...future.value$value, 
[10:19:53.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.408]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.408]                     ...future.globalenv.names))
[10:19:53.408]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.408]         }, condition = base::local({
[10:19:53.408]             c <- base::c
[10:19:53.408]             inherits <- base::inherits
[10:19:53.408]             invokeRestart <- base::invokeRestart
[10:19:53.408]             length <- base::length
[10:19:53.408]             list <- base::list
[10:19:53.408]             seq.int <- base::seq.int
[10:19:53.408]             signalCondition <- base::signalCondition
[10:19:53.408]             sys.calls <- base::sys.calls
[10:19:53.408]             `[[` <- base::`[[`
[10:19:53.408]             `+` <- base::`+`
[10:19:53.408]             `<<-` <- base::`<<-`
[10:19:53.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.408]                   3L)]
[10:19:53.408]             }
[10:19:53.408]             function(cond) {
[10:19:53.408]                 is_error <- inherits(cond, "error")
[10:19:53.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.408]                   NULL)
[10:19:53.408]                 if (is_error) {
[10:19:53.408]                   sessionInformation <- function() {
[10:19:53.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.408]                       search = base::search(), system = base::Sys.info())
[10:19:53.408]                   }
[10:19:53.408]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.408]                     cond$call), session = sessionInformation(), 
[10:19:53.408]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.408]                   signalCondition(cond)
[10:19:53.408]                 }
[10:19:53.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.408]                 "immediateCondition"))) {
[10:19:53.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.408]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.408]                   if (TRUE && !signal) {
[10:19:53.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.408]                     {
[10:19:53.408]                       inherits <- base::inherits
[10:19:53.408]                       invokeRestart <- base::invokeRestart
[10:19:53.408]                       is.null <- base::is.null
[10:19:53.408]                       muffled <- FALSE
[10:19:53.408]                       if (inherits(cond, "message")) {
[10:19:53.408]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.408]                         if (muffled) 
[10:19:53.408]                           invokeRestart("muffleMessage")
[10:19:53.408]                       }
[10:19:53.408]                       else if (inherits(cond, "warning")) {
[10:19:53.408]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.408]                         if (muffled) 
[10:19:53.408]                           invokeRestart("muffleWarning")
[10:19:53.408]                       }
[10:19:53.408]                       else if (inherits(cond, "condition")) {
[10:19:53.408]                         if (!is.null(pattern)) {
[10:19:53.408]                           computeRestarts <- base::computeRestarts
[10:19:53.408]                           grepl <- base::grepl
[10:19:53.408]                           restarts <- computeRestarts(cond)
[10:19:53.408]                           for (restart in restarts) {
[10:19:53.408]                             name <- restart$name
[10:19:53.408]                             if (is.null(name)) 
[10:19:53.408]                               next
[10:19:53.408]                             if (!grepl(pattern, name)) 
[10:19:53.408]                               next
[10:19:53.408]                             invokeRestart(restart)
[10:19:53.408]                             muffled <- TRUE
[10:19:53.408]                             break
[10:19:53.408]                           }
[10:19:53.408]                         }
[10:19:53.408]                       }
[10:19:53.408]                       invisible(muffled)
[10:19:53.408]                     }
[10:19:53.408]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.408]                   }
[10:19:53.408]                 }
[10:19:53.408]                 else {
[10:19:53.408]                   if (TRUE) {
[10:19:53.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.408]                     {
[10:19:53.408]                       inherits <- base::inherits
[10:19:53.408]                       invokeRestart <- base::invokeRestart
[10:19:53.408]                       is.null <- base::is.null
[10:19:53.408]                       muffled <- FALSE
[10:19:53.408]                       if (inherits(cond, "message")) {
[10:19:53.408]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.408]                         if (muffled) 
[10:19:53.408]                           invokeRestart("muffleMessage")
[10:19:53.408]                       }
[10:19:53.408]                       else if (inherits(cond, "warning")) {
[10:19:53.408]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.408]                         if (muffled) 
[10:19:53.408]                           invokeRestart("muffleWarning")
[10:19:53.408]                       }
[10:19:53.408]                       else if (inherits(cond, "condition")) {
[10:19:53.408]                         if (!is.null(pattern)) {
[10:19:53.408]                           computeRestarts <- base::computeRestarts
[10:19:53.408]                           grepl <- base::grepl
[10:19:53.408]                           restarts <- computeRestarts(cond)
[10:19:53.408]                           for (restart in restarts) {
[10:19:53.408]                             name <- restart$name
[10:19:53.408]                             if (is.null(name)) 
[10:19:53.408]                               next
[10:19:53.408]                             if (!grepl(pattern, name)) 
[10:19:53.408]                               next
[10:19:53.408]                             invokeRestart(restart)
[10:19:53.408]                             muffled <- TRUE
[10:19:53.408]                             break
[10:19:53.408]                           }
[10:19:53.408]                         }
[10:19:53.408]                       }
[10:19:53.408]                       invisible(muffled)
[10:19:53.408]                     }
[10:19:53.408]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.408]                   }
[10:19:53.408]                 }
[10:19:53.408]             }
[10:19:53.408]         }))
[10:19:53.408]     }, error = function(ex) {
[10:19:53.408]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.408]                 ...future.rng), started = ...future.startTime, 
[10:19:53.408]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.408]             version = "1.8"), class = "FutureResult")
[10:19:53.408]     }, finally = {
[10:19:53.408]         if (!identical(...future.workdir, getwd())) 
[10:19:53.408]             setwd(...future.workdir)
[10:19:53.408]         {
[10:19:53.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.408]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.408]             }
[10:19:53.408]             base::options(...future.oldOptions)
[10:19:53.408]             if (.Platform$OS.type == "windows") {
[10:19:53.408]                 old_names <- names(...future.oldEnvVars)
[10:19:53.408]                 envs <- base::Sys.getenv()
[10:19:53.408]                 names <- names(envs)
[10:19:53.408]                 common <- intersect(names, old_names)
[10:19:53.408]                 added <- setdiff(names, old_names)
[10:19:53.408]                 removed <- setdiff(old_names, names)
[10:19:53.408]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.408]                   envs[common]]
[10:19:53.408]                 NAMES <- toupper(changed)
[10:19:53.408]                 args <- list()
[10:19:53.408]                 for (kk in seq_along(NAMES)) {
[10:19:53.408]                   name <- changed[[kk]]
[10:19:53.408]                   NAME <- NAMES[[kk]]
[10:19:53.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.408]                     next
[10:19:53.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.408]                 }
[10:19:53.408]                 NAMES <- toupper(added)
[10:19:53.408]                 for (kk in seq_along(NAMES)) {
[10:19:53.408]                   name <- added[[kk]]
[10:19:53.408]                   NAME <- NAMES[[kk]]
[10:19:53.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.408]                     next
[10:19:53.408]                   args[[name]] <- ""
[10:19:53.408]                 }
[10:19:53.408]                 NAMES <- toupper(removed)
[10:19:53.408]                 for (kk in seq_along(NAMES)) {
[10:19:53.408]                   name <- removed[[kk]]
[10:19:53.408]                   NAME <- NAMES[[kk]]
[10:19:53.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.408]                     next
[10:19:53.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.408]                 }
[10:19:53.408]                 if (length(args) > 0) 
[10:19:53.408]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.408]             }
[10:19:53.408]             else {
[10:19:53.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.408]             }
[10:19:53.408]             {
[10:19:53.408]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.408]                   0L) {
[10:19:53.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.408]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.408]                   base::options(opts)
[10:19:53.408]                 }
[10:19:53.408]                 {
[10:19:53.408]                   {
[10:19:53.408]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.408]                     NULL
[10:19:53.408]                   }
[10:19:53.408]                   options(future.plan = NULL)
[10:19:53.408]                   if (is.na(NA_character_)) 
[10:19:53.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.408]                     .init = FALSE)
[10:19:53.408]                 }
[10:19:53.408]             }
[10:19:53.408]         }
[10:19:53.408]     })
[10:19:53.408]     if (TRUE) {
[10:19:53.408]         base::sink(type = "output", split = FALSE)
[10:19:53.408]         if (TRUE) {
[10:19:53.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.408]         }
[10:19:53.408]         else {
[10:19:53.408]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.408]         }
[10:19:53.408]         base::close(...future.stdout)
[10:19:53.408]         ...future.stdout <- NULL
[10:19:53.408]     }
[10:19:53.408]     ...future.result$conditions <- ...future.conditions
[10:19:53.408]     ...future.result$finished <- base::Sys.time()
[10:19:53.408]     ...future.result
[10:19:53.408] }
[10:19:53.410] assign_globals() ...
[10:19:53.410] List of 11
[10:19:53.410]  $ ...future.FUN            :function (x, ...)  
[10:19:53.410]  $ x_FUN                    :function (x, y)  
[10:19:53.410]  $ times                    : int 15
[10:19:53.410]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.410]  $ stop_if_not              :function (...)  
[10:19:53.410]  $ dim                      : int [1:2] 3 5
[10:19:53.410]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:53.410]  $ future.call.arguments    :List of 1
[10:19:53.410]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.410]  $ ...future.elements_ii    :List of 2
[10:19:53.410]   ..$ A: num 50
[10:19:53.410]   ..$ B: num 60
[10:19:53.410]  $ ...future.seeds_ii       : NULL
[10:19:53.410]  $ ...future.globals.maxSize: NULL
[10:19:53.410]  - attr(*, "where")=List of 11
[10:19:53.410]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.410]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.410]  - attr(*, "resolved")= logi FALSE
[10:19:53.410]  - attr(*, "total_size")= num 26659
[10:19:53.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.410]  - attr(*, "already-done")= logi TRUE
[10:19:53.418] - copied ‘...future.FUN’ to environment
[10:19:53.418] - reassign environment for ‘x_FUN’
[10:19:53.420] - copied ‘x_FUN’ to environment
[10:19:53.421] - copied ‘times’ to environment
[10:19:53.421] - copied ‘stopf’ to environment
[10:19:53.421] - copied ‘stop_if_not’ to environment
[10:19:53.421] - copied ‘dim’ to environment
[10:19:53.421] - copied ‘valid_types’ to environment
[10:19:53.421] - copied ‘future.call.arguments’ to environment
[10:19:53.421] - copied ‘...future.elements_ii’ to environment
[10:19:53.421] - copied ‘...future.seeds_ii’ to environment
[10:19:53.421] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.421] assign_globals() ... done
[10:19:53.422] requestCore(): workers = 2
[10:19:53.424] MulticoreFuture started
[10:19:53.425] - Launch lazy future ... done
[10:19:53.425] run() for ‘MulticoreFuture’ ... done
[10:19:53.426] Created future:
[10:19:53.426] plan(): Setting new future strategy stack:
[10:19:53.427] List of future strategies:
[10:19:53.427] 1. sequential:
[10:19:53.427]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.427]    - tweaked: FALSE
[10:19:53.427]    - call: NULL
[10:19:53.428] plan(): nbrOfWorkers() = 1
[10:19:53.432] plan(): Setting new future strategy stack:
[10:19:53.432] List of future strategies:
[10:19:53.432] 1. multicore:
[10:19:53.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.432]    - tweaked: FALSE
[10:19:53.432]    - call: plan(strategy)
[10:19:53.436] plan(): nbrOfWorkers() = 2
[10:19:53.427] MulticoreFuture:
[10:19:53.427] Label: ‘future_vapply-1’
[10:19:53.427] Expression:
[10:19:53.427] {
[10:19:53.427]     do.call(function(...) {
[10:19:53.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.427]             on.exit(options(oopts), add = TRUE)
[10:19:53.427]         }
[10:19:53.427]         {
[10:19:53.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.427]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.427]             })
[10:19:53.427]         }
[10:19:53.427]     }, args = future.call.arguments)
[10:19:53.427] }
[10:19:53.427] Lazy evaluation: FALSE
[10:19:53.427] Asynchronous evaluation: TRUE
[10:19:53.427] Local evaluation: TRUE
[10:19:53.427] Environment: R_GlobalEnv
[10:19:53.427] Capture standard output: TRUE
[10:19:53.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.427] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.427] Packages: 1 packages (‘future.apply’)
[10:19:53.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.427] Resolved: TRUE
[10:19:53.427] Value: <not collected>
[10:19:53.427] Conditions captured: <none>
[10:19:53.427] Early signaling: FALSE
[10:19:53.427] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.427] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.438] Chunk #1 of 2 ... DONE
[10:19:53.438] Chunk #2 of 2 ...
[10:19:53.438]  - Finding globals in 'X' for chunk #2 ...
[10:19:53.438] getGlobalsAndPackages() ...
[10:19:53.439] Searching for globals...
[10:19:53.439] 
[10:19:53.439] Searching for globals ... DONE
[10:19:53.440] - globals: [0] <none>
[10:19:53.440] getGlobalsAndPackages() ... DONE
[10:19:53.440]    + additional globals found: [n=0] 
[10:19:53.440]    + additional namespaces needed: [n=0] 
[10:19:53.440]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:53.440]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.441]  - seeds: <none>
[10:19:53.441]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.441] getGlobalsAndPackages() ...
[10:19:53.441] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.442] Resolving globals: FALSE
[10:19:53.442] Tweak future expression to call with '...' arguments ...
[10:19:53.442] {
[10:19:53.442]     do.call(function(...) {
[10:19:53.442]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.442]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.442]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.442]             on.exit(options(oopts), add = TRUE)
[10:19:53.442]         }
[10:19:53.442]         {
[10:19:53.442]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.442]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.442]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.442]             })
[10:19:53.442]         }
[10:19:53.442]     }, args = future.call.arguments)
[10:19:53.442] }
[10:19:53.443] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.444] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.444] - packages: [1] ‘future.apply’
[10:19:53.445] getGlobalsAndPackages() ... DONE
[10:19:53.445] run() for ‘Future’ ...
[10:19:53.446] - state: ‘created’
[10:19:53.446] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.449] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.449] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.449]   - Field: ‘label’
[10:19:53.449]   - Field: ‘local’
[10:19:53.449]   - Field: ‘owner’
[10:19:53.449]   - Field: ‘envir’
[10:19:53.450]   - Field: ‘workers’
[10:19:53.450]   - Field: ‘packages’
[10:19:53.450]   - Field: ‘gc’
[10:19:53.450]   - Field: ‘job’
[10:19:53.450]   - Field: ‘conditions’
[10:19:53.450]   - Field: ‘expr’
[10:19:53.450]   - Field: ‘uuid’
[10:19:53.451]   - Field: ‘seed’
[10:19:53.451]   - Field: ‘version’
[10:19:53.451]   - Field: ‘result’
[10:19:53.451]   - Field: ‘asynchronous’
[10:19:53.451]   - Field: ‘calls’
[10:19:53.451]   - Field: ‘globals’
[10:19:53.451]   - Field: ‘stdout’
[10:19:53.452]   - Field: ‘earlySignal’
[10:19:53.452]   - Field: ‘lazy’
[10:19:53.452]   - Field: ‘state’
[10:19:53.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.452] - Launch lazy future ...
[10:19:53.452] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.453] Packages needed by future strategies (n = 0): <none>
[10:19:53.453] {
[10:19:53.453]     {
[10:19:53.453]         {
[10:19:53.453]             ...future.startTime <- base::Sys.time()
[10:19:53.453]             {
[10:19:53.453]                 {
[10:19:53.453]                   {
[10:19:53.453]                     {
[10:19:53.453]                       {
[10:19:53.453]                         base::local({
[10:19:53.453]                           has_future <- base::requireNamespace("future", 
[10:19:53.453]                             quietly = TRUE)
[10:19:53.453]                           if (has_future) {
[10:19:53.453]                             ns <- base::getNamespace("future")
[10:19:53.453]                             version <- ns[[".package"]][["version"]]
[10:19:53.453]                             if (is.null(version)) 
[10:19:53.453]                               version <- utils::packageVersion("future")
[10:19:53.453]                           }
[10:19:53.453]                           else {
[10:19:53.453]                             version <- NULL
[10:19:53.453]                           }
[10:19:53.453]                           if (!has_future || version < "1.8.0") {
[10:19:53.453]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.453]                               "", base::R.version$version.string), 
[10:19:53.453]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.453]                                 base::R.version$platform, 8 * 
[10:19:53.453]                                   base::.Machine$sizeof.pointer), 
[10:19:53.453]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.453]                                 "release", "version")], collapse = " "), 
[10:19:53.453]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.453]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.453]                               info)
[10:19:53.453]                             info <- base::paste(info, collapse = "; ")
[10:19:53.453]                             if (!has_future) {
[10:19:53.453]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.453]                                 info)
[10:19:53.453]                             }
[10:19:53.453]                             else {
[10:19:53.453]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.453]                                 info, version)
[10:19:53.453]                             }
[10:19:53.453]                             base::stop(msg)
[10:19:53.453]                           }
[10:19:53.453]                         })
[10:19:53.453]                       }
[10:19:53.453]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.453]                       base::options(mc.cores = 1L)
[10:19:53.453]                     }
[10:19:53.453]                     base::local({
[10:19:53.453]                       for (pkg in "future.apply") {
[10:19:53.453]                         base::loadNamespace(pkg)
[10:19:53.453]                         base::library(pkg, character.only = TRUE)
[10:19:53.453]                       }
[10:19:53.453]                     })
[10:19:53.453]                   }
[10:19:53.453]                   ...future.strategy.old <- future::plan("list")
[10:19:53.453]                   options(future.plan = NULL)
[10:19:53.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.453]                 }
[10:19:53.453]                 ...future.workdir <- getwd()
[10:19:53.453]             }
[10:19:53.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.453]         }
[10:19:53.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.453]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.453]             base::names(...future.oldOptions))
[10:19:53.453]     }
[10:19:53.453]     if (FALSE) {
[10:19:53.453]     }
[10:19:53.453]     else {
[10:19:53.453]         if (TRUE) {
[10:19:53.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.453]                 open = "w")
[10:19:53.453]         }
[10:19:53.453]         else {
[10:19:53.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.453]         }
[10:19:53.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.453]             base::sink(type = "output", split = FALSE)
[10:19:53.453]             base::close(...future.stdout)
[10:19:53.453]         }, add = TRUE)
[10:19:53.453]     }
[10:19:53.453]     ...future.frame <- base::sys.nframe()
[10:19:53.453]     ...future.conditions <- base::list()
[10:19:53.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.453]     if (FALSE) {
[10:19:53.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.453]     }
[10:19:53.453]     ...future.result <- base::tryCatch({
[10:19:53.453]         base::withCallingHandlers({
[10:19:53.453]             ...future.value <- base::withVisible(base::local({
[10:19:53.453]                 withCallingHandlers({
[10:19:53.453]                   {
[10:19:53.453]                     do.call(function(...) {
[10:19:53.453]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.453]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.453]                         ...future.globals.maxSize)) {
[10:19:53.453]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.453]                         on.exit(options(oopts), add = TRUE)
[10:19:53.453]                       }
[10:19:53.453]                       {
[10:19:53.453]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.453]                           FUN = function(jj) {
[10:19:53.453]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.453]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.453]                           })
[10:19:53.453]                       }
[10:19:53.453]                     }, args = future.call.arguments)
[10:19:53.453]                   }
[10:19:53.453]                 }, immediateCondition = function(cond) {
[10:19:53.453]                   save_rds <- function (object, pathname, ...) 
[10:19:53.453]                   {
[10:19:53.453]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.453]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.453]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.453]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.453]                         fi_tmp[["mtime"]])
[10:19:53.453]                     }
[10:19:53.453]                     tryCatch({
[10:19:53.453]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.453]                     }, error = function(ex) {
[10:19:53.453]                       msg <- conditionMessage(ex)
[10:19:53.453]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.453]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.453]                         fi_tmp[["mtime"]], msg)
[10:19:53.453]                       ex$message <- msg
[10:19:53.453]                       stop(ex)
[10:19:53.453]                     })
[10:19:53.453]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.453]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.453]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.453]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.453]                       fi <- file.info(pathname)
[10:19:53.453]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.453]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.453]                         fi[["size"]], fi[["mtime"]])
[10:19:53.453]                       stop(msg)
[10:19:53.453]                     }
[10:19:53.453]                     invisible(pathname)
[10:19:53.453]                   }
[10:19:53.453]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.453]                     rootPath = tempdir()) 
[10:19:53.453]                   {
[10:19:53.453]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.453]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.453]                       tmpdir = path, fileext = ".rds")
[10:19:53.453]                     save_rds(obj, file)
[10:19:53.453]                   }
[10:19:53.453]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.453]                   {
[10:19:53.453]                     inherits <- base::inherits
[10:19:53.453]                     invokeRestart <- base::invokeRestart
[10:19:53.453]                     is.null <- base::is.null
[10:19:53.453]                     muffled <- FALSE
[10:19:53.453]                     if (inherits(cond, "message")) {
[10:19:53.453]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.453]                       if (muffled) 
[10:19:53.453]                         invokeRestart("muffleMessage")
[10:19:53.453]                     }
[10:19:53.453]                     else if (inherits(cond, "warning")) {
[10:19:53.453]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.453]                       if (muffled) 
[10:19:53.453]                         invokeRestart("muffleWarning")
[10:19:53.453]                     }
[10:19:53.453]                     else if (inherits(cond, "condition")) {
[10:19:53.453]                       if (!is.null(pattern)) {
[10:19:53.453]                         computeRestarts <- base::computeRestarts
[10:19:53.453]                         grepl <- base::grepl
[10:19:53.453]                         restarts <- computeRestarts(cond)
[10:19:53.453]                         for (restart in restarts) {
[10:19:53.453]                           name <- restart$name
[10:19:53.453]                           if (is.null(name)) 
[10:19:53.453]                             next
[10:19:53.453]                           if (!grepl(pattern, name)) 
[10:19:53.453]                             next
[10:19:53.453]                           invokeRestart(restart)
[10:19:53.453]                           muffled <- TRUE
[10:19:53.453]                           break
[10:19:53.453]                         }
[10:19:53.453]                       }
[10:19:53.453]                     }
[10:19:53.453]                     invisible(muffled)
[10:19:53.453]                   }
[10:19:53.453]                   muffleCondition(cond)
[10:19:53.453]                 })
[10:19:53.453]             }))
[10:19:53.453]             future::FutureResult(value = ...future.value$value, 
[10:19:53.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.453]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.453]                     ...future.globalenv.names))
[10:19:53.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.453]         }, condition = base::local({
[10:19:53.453]             c <- base::c
[10:19:53.453]             inherits <- base::inherits
[10:19:53.453]             invokeRestart <- base::invokeRestart
[10:19:53.453]             length <- base::length
[10:19:53.453]             list <- base::list
[10:19:53.453]             seq.int <- base::seq.int
[10:19:53.453]             signalCondition <- base::signalCondition
[10:19:53.453]             sys.calls <- base::sys.calls
[10:19:53.453]             `[[` <- base::`[[`
[10:19:53.453]             `+` <- base::`+`
[10:19:53.453]             `<<-` <- base::`<<-`
[10:19:53.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.453]                   3L)]
[10:19:53.453]             }
[10:19:53.453]             function(cond) {
[10:19:53.453]                 is_error <- inherits(cond, "error")
[10:19:53.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.453]                   NULL)
[10:19:53.453]                 if (is_error) {
[10:19:53.453]                   sessionInformation <- function() {
[10:19:53.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.453]                       search = base::search(), system = base::Sys.info())
[10:19:53.453]                   }
[10:19:53.453]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.453]                     cond$call), session = sessionInformation(), 
[10:19:53.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.453]                   signalCondition(cond)
[10:19:53.453]                 }
[10:19:53.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.453]                 "immediateCondition"))) {
[10:19:53.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.453]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.453]                   if (TRUE && !signal) {
[10:19:53.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.453]                     {
[10:19:53.453]                       inherits <- base::inherits
[10:19:53.453]                       invokeRestart <- base::invokeRestart
[10:19:53.453]                       is.null <- base::is.null
[10:19:53.453]                       muffled <- FALSE
[10:19:53.453]                       if (inherits(cond, "message")) {
[10:19:53.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.453]                         if (muffled) 
[10:19:53.453]                           invokeRestart("muffleMessage")
[10:19:53.453]                       }
[10:19:53.453]                       else if (inherits(cond, "warning")) {
[10:19:53.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.453]                         if (muffled) 
[10:19:53.453]                           invokeRestart("muffleWarning")
[10:19:53.453]                       }
[10:19:53.453]                       else if (inherits(cond, "condition")) {
[10:19:53.453]                         if (!is.null(pattern)) {
[10:19:53.453]                           computeRestarts <- base::computeRestarts
[10:19:53.453]                           grepl <- base::grepl
[10:19:53.453]                           restarts <- computeRestarts(cond)
[10:19:53.453]                           for (restart in restarts) {
[10:19:53.453]                             name <- restart$name
[10:19:53.453]                             if (is.null(name)) 
[10:19:53.453]                               next
[10:19:53.453]                             if (!grepl(pattern, name)) 
[10:19:53.453]                               next
[10:19:53.453]                             invokeRestart(restart)
[10:19:53.453]                             muffled <- TRUE
[10:19:53.453]                             break
[10:19:53.453]                           }
[10:19:53.453]                         }
[10:19:53.453]                       }
[10:19:53.453]                       invisible(muffled)
[10:19:53.453]                     }
[10:19:53.453]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.453]                   }
[10:19:53.453]                 }
[10:19:53.453]                 else {
[10:19:53.453]                   if (TRUE) {
[10:19:53.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.453]                     {
[10:19:53.453]                       inherits <- base::inherits
[10:19:53.453]                       invokeRestart <- base::invokeRestart
[10:19:53.453]                       is.null <- base::is.null
[10:19:53.453]                       muffled <- FALSE
[10:19:53.453]                       if (inherits(cond, "message")) {
[10:19:53.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.453]                         if (muffled) 
[10:19:53.453]                           invokeRestart("muffleMessage")
[10:19:53.453]                       }
[10:19:53.453]                       else if (inherits(cond, "warning")) {
[10:19:53.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.453]                         if (muffled) 
[10:19:53.453]                           invokeRestart("muffleWarning")
[10:19:53.453]                       }
[10:19:53.453]                       else if (inherits(cond, "condition")) {
[10:19:53.453]                         if (!is.null(pattern)) {
[10:19:53.453]                           computeRestarts <- base::computeRestarts
[10:19:53.453]                           grepl <- base::grepl
[10:19:53.453]                           restarts <- computeRestarts(cond)
[10:19:53.453]                           for (restart in restarts) {
[10:19:53.453]                             name <- restart$name
[10:19:53.453]                             if (is.null(name)) 
[10:19:53.453]                               next
[10:19:53.453]                             if (!grepl(pattern, name)) 
[10:19:53.453]                               next
[10:19:53.453]                             invokeRestart(restart)
[10:19:53.453]                             muffled <- TRUE
[10:19:53.453]                             break
[10:19:53.453]                           }
[10:19:53.453]                         }
[10:19:53.453]                       }
[10:19:53.453]                       invisible(muffled)
[10:19:53.453]                     }
[10:19:53.453]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.453]                   }
[10:19:53.453]                 }
[10:19:53.453]             }
[10:19:53.453]         }))
[10:19:53.453]     }, error = function(ex) {
[10:19:53.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.453]                 ...future.rng), started = ...future.startTime, 
[10:19:53.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.453]             version = "1.8"), class = "FutureResult")
[10:19:53.453]     }, finally = {
[10:19:53.453]         if (!identical(...future.workdir, getwd())) 
[10:19:53.453]             setwd(...future.workdir)
[10:19:53.453]         {
[10:19:53.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.453]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.453]             }
[10:19:53.453]             base::options(...future.oldOptions)
[10:19:53.453]             if (.Platform$OS.type == "windows") {
[10:19:53.453]                 old_names <- names(...future.oldEnvVars)
[10:19:53.453]                 envs <- base::Sys.getenv()
[10:19:53.453]                 names <- names(envs)
[10:19:53.453]                 common <- intersect(names, old_names)
[10:19:53.453]                 added <- setdiff(names, old_names)
[10:19:53.453]                 removed <- setdiff(old_names, names)
[10:19:53.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.453]                   envs[common]]
[10:19:53.453]                 NAMES <- toupper(changed)
[10:19:53.453]                 args <- list()
[10:19:53.453]                 for (kk in seq_along(NAMES)) {
[10:19:53.453]                   name <- changed[[kk]]
[10:19:53.453]                   NAME <- NAMES[[kk]]
[10:19:53.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.453]                     next
[10:19:53.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.453]                 }
[10:19:53.453]                 NAMES <- toupper(added)
[10:19:53.453]                 for (kk in seq_along(NAMES)) {
[10:19:53.453]                   name <- added[[kk]]
[10:19:53.453]                   NAME <- NAMES[[kk]]
[10:19:53.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.453]                     next
[10:19:53.453]                   args[[name]] <- ""
[10:19:53.453]                 }
[10:19:53.453]                 NAMES <- toupper(removed)
[10:19:53.453]                 for (kk in seq_along(NAMES)) {
[10:19:53.453]                   name <- removed[[kk]]
[10:19:53.453]                   NAME <- NAMES[[kk]]
[10:19:53.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.453]                     next
[10:19:53.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.453]                 }
[10:19:53.453]                 if (length(args) > 0) 
[10:19:53.453]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.453]             }
[10:19:53.453]             else {
[10:19:53.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.453]             }
[10:19:53.453]             {
[10:19:53.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.453]                   0L) {
[10:19:53.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.453]                   base::options(opts)
[10:19:53.453]                 }
[10:19:53.453]                 {
[10:19:53.453]                   {
[10:19:53.453]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.453]                     NULL
[10:19:53.453]                   }
[10:19:53.453]                   options(future.plan = NULL)
[10:19:53.453]                   if (is.na(NA_character_)) 
[10:19:53.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.453]                     .init = FALSE)
[10:19:53.453]                 }
[10:19:53.453]             }
[10:19:53.453]         }
[10:19:53.453]     })
[10:19:53.453]     if (TRUE) {
[10:19:53.453]         base::sink(type = "output", split = FALSE)
[10:19:53.453]         if (TRUE) {
[10:19:53.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.453]         }
[10:19:53.453]         else {
[10:19:53.453]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.453]         }
[10:19:53.453]         base::close(...future.stdout)
[10:19:53.453]         ...future.stdout <- NULL
[10:19:53.453]     }
[10:19:53.453]     ...future.result$conditions <- ...future.conditions
[10:19:53.453]     ...future.result$finished <- base::Sys.time()
[10:19:53.453]     ...future.result
[10:19:53.453] }
[10:19:53.457] assign_globals() ...
[10:19:53.457] List of 11
[10:19:53.457]  $ ...future.FUN            :function (x, ...)  
[10:19:53.457]  $ x_FUN                    :function (x, y)  
[10:19:53.457]  $ times                    : int 15
[10:19:53.457]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.457]  $ stop_if_not              :function (...)  
[10:19:53.457]  $ dim                      : int [1:2] 3 5
[10:19:53.457]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:53.457]  $ future.call.arguments    :List of 1
[10:19:53.457]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:53.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.457]  $ ...future.elements_ii    :List of 2
[10:19:53.457]   ..$ C: num 70
[10:19:53.457]   ..$ D: num 80
[10:19:53.457]  $ ...future.seeds_ii       : NULL
[10:19:53.457]  $ ...future.globals.maxSize: NULL
[10:19:53.457]  - attr(*, "where")=List of 11
[10:19:53.457]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.457]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.457]  - attr(*, "resolved")= logi FALSE
[10:19:53.457]  - attr(*, "total_size")= num 26659
[10:19:53.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.457]  - attr(*, "already-done")= logi TRUE
[10:19:53.469] - copied ‘...future.FUN’ to environment
[10:19:53.470] - reassign environment for ‘x_FUN’
[10:19:53.470] - copied ‘x_FUN’ to environment
[10:19:53.470] - copied ‘times’ to environment
[10:19:53.470] - copied ‘stopf’ to environment
[10:19:53.470] - copied ‘stop_if_not’ to environment
[10:19:53.470] - copied ‘dim’ to environment
[10:19:53.470] - copied ‘valid_types’ to environment
[10:19:53.470] - copied ‘future.call.arguments’ to environment
[10:19:53.471] - copied ‘...future.elements_ii’ to environment
[10:19:53.471] - copied ‘...future.seeds_ii’ to environment
[10:19:53.471] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.471] assign_globals() ... done
[10:19:53.471] requestCore(): workers = 2
[10:19:53.474] MulticoreFuture started
[10:19:53.474] - Launch lazy future ... done
[10:19:53.475] run() for ‘MulticoreFuture’ ... done
[10:19:53.475] Created future:
[10:19:53.475] plan(): Setting new future strategy stack:
[10:19:53.476] List of future strategies:
[10:19:53.476] 1. sequential:
[10:19:53.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.476]    - tweaked: FALSE
[10:19:53.476]    - call: NULL
[10:19:53.477] plan(): nbrOfWorkers() = 1
[10:19:53.481] plan(): Setting new future strategy stack:
[10:19:53.481] List of future strategies:
[10:19:53.481] 1. multicore:
[10:19:53.481]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.481]    - tweaked: FALSE
[10:19:53.481]    - call: plan(strategy)
[10:19:53.485] plan(): nbrOfWorkers() = 2
[10:19:53.476] MulticoreFuture:
[10:19:53.476] Label: ‘future_vapply-2’
[10:19:53.476] Expression:
[10:19:53.476] {
[10:19:53.476]     do.call(function(...) {
[10:19:53.476]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.476]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.476]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.476]             on.exit(options(oopts), add = TRUE)
[10:19:53.476]         }
[10:19:53.476]         {
[10:19:53.476]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.476]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.476]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.476]             })
[10:19:53.476]         }
[10:19:53.476]     }, args = future.call.arguments)
[10:19:53.476] }
[10:19:53.476] Lazy evaluation: FALSE
[10:19:53.476] Asynchronous evaluation: TRUE
[10:19:53.476] Local evaluation: TRUE
[10:19:53.476] Environment: R_GlobalEnv
[10:19:53.476] Capture standard output: TRUE
[10:19:53.476] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.476] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.476] Packages: 1 packages (‘future.apply’)
[10:19:53.476] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.476] Resolved: TRUE
[10:19:53.476] Value: <not collected>
[10:19:53.476] Conditions captured: <none>
[10:19:53.476] Early signaling: FALSE
[10:19:53.476] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.476] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.487] Chunk #2 of 2 ... DONE
[10:19:53.487] Launching 2 futures (chunks) ... DONE
[10:19:53.487] Resolving 2 futures (chunks) ...
[10:19:53.488] resolve() on list ...
[10:19:53.488]  recursive: 0
[10:19:53.488]  length: 2
[10:19:53.488] 
[10:19:53.489] Future #1
[10:19:53.489] result() for MulticoreFuture ...
[10:19:53.490] result() for MulticoreFuture ...
[10:19:53.490] result() for MulticoreFuture ... done
[10:19:53.490] result() for MulticoreFuture ... done
[10:19:53.490] result() for MulticoreFuture ...
[10:19:53.491] result() for MulticoreFuture ... done
[10:19:53.491] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:53.491] - nx: 2
[10:19:53.491] - relay: TRUE
[10:19:53.492] - stdout: TRUE
[10:19:53.492] - signal: TRUE
[10:19:53.492] - resignal: FALSE
[10:19:53.492] - force: TRUE
[10:19:53.493] - relayed: [n=2] FALSE, FALSE
[10:19:53.493] - queued futures: [n=2] FALSE, FALSE
[10:19:53.493]  - until=1
[10:19:53.493]  - relaying element #1
[10:19:53.493] result() for MulticoreFuture ...
[10:19:53.494] result() for MulticoreFuture ... done
[10:19:53.494] result() for MulticoreFuture ...
[10:19:53.494] result() for MulticoreFuture ... done
[10:19:53.494] result() for MulticoreFuture ...
[10:19:53.494] result() for MulticoreFuture ... done
[10:19:53.494] result() for MulticoreFuture ...
[10:19:53.495] result() for MulticoreFuture ... done
[10:19:53.495] - relayed: [n=2] TRUE, FALSE
[10:19:53.495] - queued futures: [n=2] TRUE, FALSE
[10:19:53.495] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:53.495]  length: 1 (resolved future 1)
[10:19:53.495] Future #2
[10:19:53.496] result() for MulticoreFuture ...
[10:19:53.496] result() for MulticoreFuture ...
[10:19:53.496] result() for MulticoreFuture ... done
[10:19:53.497] result() for MulticoreFuture ... done
[10:19:53.497] result() for MulticoreFuture ...
[10:19:53.497] result() for MulticoreFuture ... done
[10:19:53.497] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:53.497] - nx: 2
[10:19:53.497] - relay: TRUE
[10:19:53.497] - stdout: TRUE
[10:19:53.498] - signal: TRUE
[10:19:53.498] - resignal: FALSE
[10:19:53.498] - force: TRUE
[10:19:53.498] - relayed: [n=2] TRUE, FALSE
[10:19:53.498] - queued futures: [n=2] TRUE, FALSE
[10:19:53.498]  - until=2
[10:19:53.498]  - relaying element #2
[10:19:53.498] result() for MulticoreFuture ...
[10:19:53.498] result() for MulticoreFuture ... done
[10:19:53.499] result() for MulticoreFuture ...
[10:19:53.499] result() for MulticoreFuture ... done
[10:19:53.499] result() for MulticoreFuture ...
[10:19:53.499] result() for MulticoreFuture ... done
[10:19:53.499] result() for MulticoreFuture ...
[10:19:53.499] result() for MulticoreFuture ... done
[10:19:53.499] - relayed: [n=2] TRUE, TRUE
[10:19:53.499] - queued futures: [n=2] TRUE, TRUE
[10:19:53.499] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:53.500]  length: 0 (resolved future 2)
[10:19:53.500] Relaying remaining futures
[10:19:53.500] signalConditionsASAP(NULL, pos=0) ...
[10:19:53.500] - nx: 2
[10:19:53.500] - relay: TRUE
[10:19:53.500] - stdout: TRUE
[10:19:53.500] - signal: TRUE
[10:19:53.500] - resignal: FALSE
[10:19:53.500] - force: TRUE
[10:19:53.500] - relayed: [n=2] TRUE, TRUE
[10:19:53.500] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:53.501] - relayed: [n=2] TRUE, TRUE
[10:19:53.501] - queued futures: [n=2] TRUE, TRUE
[10:19:53.501] signalConditionsASAP(NULL, pos=0) ... done
[10:19:53.501] resolve() on list ... DONE
[10:19:53.501] result() for MulticoreFuture ...
[10:19:53.501] result() for MulticoreFuture ... done
[10:19:53.501] result() for MulticoreFuture ...
[10:19:53.501] result() for MulticoreFuture ... done
[10:19:53.501] result() for MulticoreFuture ...
[10:19:53.502] result() for MulticoreFuture ... done
[10:19:53.502] result() for MulticoreFuture ...
[10:19:53.502] result() for MulticoreFuture ... done
[10:19:53.502]  - Number of value chunks collected: 2
[10:19:53.502] Resolving 2 futures (chunks) ... DONE
[10:19:53.502] Reducing values from 2 chunks ...
[10:19:53.502]  - Number of values collected after concatenation: 4
[10:19:53.502]  - Number of values expected: 4
[10:19:53.502] Reducing values from 2 chunks ... DONE
[10:19:53.502] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:19:53.504] future_lapply() ...
[10:19:53.508] Number of chunks: 2
[10:19:53.509] getGlobalsAndPackagesXApply() ...
[10:19:53.509]  - future.globals: TRUE
[10:19:53.509] getGlobalsAndPackages() ...
[10:19:53.509] Searching for globals...
[10:19:53.515] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:53.516] Searching for globals ... DONE
[10:19:53.516] Resolving globals: FALSE
[10:19:53.517] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[10:19:53.517] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:53.517] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.517] - packages: [1] ‘future.apply’
[10:19:53.518] getGlobalsAndPackages() ... DONE
[10:19:53.518]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.518]  - needed namespaces: [n=1] ‘future.apply’
[10:19:53.518] Finding globals ... DONE
[10:19:53.518]  - use_args: TRUE
[10:19:53.518]  - Getting '...' globals ...
[10:19:53.518] resolve() on list ...
[10:19:53.519]  recursive: 0
[10:19:53.519]  length: 1
[10:19:53.519]  elements: ‘...’
[10:19:53.519]  length: 0 (resolved future 1)
[10:19:53.519] resolve() on list ... DONE
[10:19:53.519]    - '...' content: [n=0] 
[10:19:53.519] List of 1
[10:19:53.519]  $ ...: list()
[10:19:53.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.519]  - attr(*, "where")=List of 1
[10:19:53.519]   ..$ ...:<environment: 0x55c69fa04ec0> 
[10:19:53.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.519]  - attr(*, "resolved")= logi TRUE
[10:19:53.519]  - attr(*, "total_size")= num NA
[10:19:53.522]  - Getting '...' globals ... DONE
[10:19:53.522] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:53.522] List of 8
[10:19:53.522]  $ ...future.FUN:function (x, ...)  
[10:19:53.522]  $ x_FUN        :function (x)  
[10:19:53.522]  $ times        : int 1
[10:19:53.522]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.522]  $ stop_if_not  :function (...)  
[10:19:53.522]  $ dim          : NULL
[10:19:53.522]  $ valid_types  : chr "logical"
[10:19:53.522]  $ ...          : list()
[10:19:53.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.522]  - attr(*, "where")=List of 8
[10:19:53.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:53.522]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:53.522]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:53.522]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:53.522]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:53.522]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:53.522]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:53.522]   ..$ ...          :<environment: 0x55c69fa04ec0> 
[10:19:53.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.522]  - attr(*, "resolved")= logi FALSE
[10:19:53.522]  - attr(*, "total_size")= num 30734
[10:19:53.527] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:53.527] getGlobalsAndPackagesXApply() ... DONE
[10:19:53.528] Number of futures (= number of chunks): 2
[10:19:53.528] Launching 2 futures (chunks) ...
[10:19:53.528] Chunk #1 of 2 ...
[10:19:53.528]  - Finding globals in 'X' for chunk #1 ...
[10:19:53.528] getGlobalsAndPackages() ...
[10:19:53.528] Searching for globals...
[10:19:53.528] 
[10:19:53.528] Searching for globals ... DONE
[10:19:53.529] - globals: [0] <none>
[10:19:53.529] getGlobalsAndPackages() ... DONE
[10:19:53.529]    + additional globals found: [n=0] 
[10:19:53.529]    + additional namespaces needed: [n=0] 
[10:19:53.529]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:53.529]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.529]  - seeds: <none>
[10:19:53.529]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.529] getGlobalsAndPackages() ...
[10:19:53.529] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.529] Resolving globals: FALSE
[10:19:53.530] Tweak future expression to call with '...' arguments ...
[10:19:53.530] {
[10:19:53.530]     do.call(function(...) {
[10:19:53.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.530]             on.exit(options(oopts), add = TRUE)
[10:19:53.530]         }
[10:19:53.530]         {
[10:19:53.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.530]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.530]             })
[10:19:53.530]         }
[10:19:53.530]     }, args = future.call.arguments)
[10:19:53.530] }
[10:19:53.530] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.530] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.531] - packages: [1] ‘future.apply’
[10:19:53.531] getGlobalsAndPackages() ... DONE
[10:19:53.533] run() for ‘Future’ ...
[10:19:53.533] - state: ‘created’
[10:19:53.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.535] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.536]   - Field: ‘label’
[10:19:53.536]   - Field: ‘local’
[10:19:53.536]   - Field: ‘owner’
[10:19:53.536]   - Field: ‘envir’
[10:19:53.536]   - Field: ‘workers’
[10:19:53.536]   - Field: ‘packages’
[10:19:53.536]   - Field: ‘gc’
[10:19:53.536]   - Field: ‘job’
[10:19:53.536]   - Field: ‘conditions’
[10:19:53.536]   - Field: ‘expr’
[10:19:53.537]   - Field: ‘uuid’
[10:19:53.537]   - Field: ‘seed’
[10:19:53.537]   - Field: ‘version’
[10:19:53.537]   - Field: ‘result’
[10:19:53.537]   - Field: ‘asynchronous’
[10:19:53.537]   - Field: ‘calls’
[10:19:53.537]   - Field: ‘globals’
[10:19:53.537]   - Field: ‘stdout’
[10:19:53.537]   - Field: ‘earlySignal’
[10:19:53.537]   - Field: ‘lazy’
[10:19:53.538]   - Field: ‘state’
[10:19:53.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.538] - Launch lazy future ...
[10:19:53.538] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.538] Packages needed by future strategies (n = 0): <none>
[10:19:53.539] {
[10:19:53.539]     {
[10:19:53.539]         {
[10:19:53.539]             ...future.startTime <- base::Sys.time()
[10:19:53.539]             {
[10:19:53.539]                 {
[10:19:53.539]                   {
[10:19:53.539]                     {
[10:19:53.539]                       {
[10:19:53.539]                         base::local({
[10:19:53.539]                           has_future <- base::requireNamespace("future", 
[10:19:53.539]                             quietly = TRUE)
[10:19:53.539]                           if (has_future) {
[10:19:53.539]                             ns <- base::getNamespace("future")
[10:19:53.539]                             version <- ns[[".package"]][["version"]]
[10:19:53.539]                             if (is.null(version)) 
[10:19:53.539]                               version <- utils::packageVersion("future")
[10:19:53.539]                           }
[10:19:53.539]                           else {
[10:19:53.539]                             version <- NULL
[10:19:53.539]                           }
[10:19:53.539]                           if (!has_future || version < "1.8.0") {
[10:19:53.539]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.539]                               "", base::R.version$version.string), 
[10:19:53.539]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.539]                                 base::R.version$platform, 8 * 
[10:19:53.539]                                   base::.Machine$sizeof.pointer), 
[10:19:53.539]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.539]                                 "release", "version")], collapse = " "), 
[10:19:53.539]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.539]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.539]                               info)
[10:19:53.539]                             info <- base::paste(info, collapse = "; ")
[10:19:53.539]                             if (!has_future) {
[10:19:53.539]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.539]                                 info)
[10:19:53.539]                             }
[10:19:53.539]                             else {
[10:19:53.539]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.539]                                 info, version)
[10:19:53.539]                             }
[10:19:53.539]                             base::stop(msg)
[10:19:53.539]                           }
[10:19:53.539]                         })
[10:19:53.539]                       }
[10:19:53.539]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.539]                       base::options(mc.cores = 1L)
[10:19:53.539]                     }
[10:19:53.539]                     base::local({
[10:19:53.539]                       for (pkg in "future.apply") {
[10:19:53.539]                         base::loadNamespace(pkg)
[10:19:53.539]                         base::library(pkg, character.only = TRUE)
[10:19:53.539]                       }
[10:19:53.539]                     })
[10:19:53.539]                   }
[10:19:53.539]                   ...future.strategy.old <- future::plan("list")
[10:19:53.539]                   options(future.plan = NULL)
[10:19:53.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.539]                 }
[10:19:53.539]                 ...future.workdir <- getwd()
[10:19:53.539]             }
[10:19:53.539]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.539]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.539]         }
[10:19:53.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.539]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.539]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.539]             base::names(...future.oldOptions))
[10:19:53.539]     }
[10:19:53.539]     if (FALSE) {
[10:19:53.539]     }
[10:19:53.539]     else {
[10:19:53.539]         if (TRUE) {
[10:19:53.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.539]                 open = "w")
[10:19:53.539]         }
[10:19:53.539]         else {
[10:19:53.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.539]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.539]         }
[10:19:53.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.539]             base::sink(type = "output", split = FALSE)
[10:19:53.539]             base::close(...future.stdout)
[10:19:53.539]         }, add = TRUE)
[10:19:53.539]     }
[10:19:53.539]     ...future.frame <- base::sys.nframe()
[10:19:53.539]     ...future.conditions <- base::list()
[10:19:53.539]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.539]     if (FALSE) {
[10:19:53.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.539]     }
[10:19:53.539]     ...future.result <- base::tryCatch({
[10:19:53.539]         base::withCallingHandlers({
[10:19:53.539]             ...future.value <- base::withVisible(base::local({
[10:19:53.539]                 withCallingHandlers({
[10:19:53.539]                   {
[10:19:53.539]                     do.call(function(...) {
[10:19:53.539]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.539]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.539]                         ...future.globals.maxSize)) {
[10:19:53.539]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.539]                         on.exit(options(oopts), add = TRUE)
[10:19:53.539]                       }
[10:19:53.539]                       {
[10:19:53.539]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.539]                           FUN = function(jj) {
[10:19:53.539]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.539]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.539]                           })
[10:19:53.539]                       }
[10:19:53.539]                     }, args = future.call.arguments)
[10:19:53.539]                   }
[10:19:53.539]                 }, immediateCondition = function(cond) {
[10:19:53.539]                   save_rds <- function (object, pathname, ...) 
[10:19:53.539]                   {
[10:19:53.539]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.539]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.539]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.539]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.539]                         fi_tmp[["mtime"]])
[10:19:53.539]                     }
[10:19:53.539]                     tryCatch({
[10:19:53.539]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.539]                     }, error = function(ex) {
[10:19:53.539]                       msg <- conditionMessage(ex)
[10:19:53.539]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.539]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.539]                         fi_tmp[["mtime"]], msg)
[10:19:53.539]                       ex$message <- msg
[10:19:53.539]                       stop(ex)
[10:19:53.539]                     })
[10:19:53.539]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.539]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.539]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.539]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.539]                       fi <- file.info(pathname)
[10:19:53.539]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.539]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.539]                         fi[["size"]], fi[["mtime"]])
[10:19:53.539]                       stop(msg)
[10:19:53.539]                     }
[10:19:53.539]                     invisible(pathname)
[10:19:53.539]                   }
[10:19:53.539]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.539]                     rootPath = tempdir()) 
[10:19:53.539]                   {
[10:19:53.539]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.539]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.539]                       tmpdir = path, fileext = ".rds")
[10:19:53.539]                     save_rds(obj, file)
[10:19:53.539]                   }
[10:19:53.539]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.539]                   {
[10:19:53.539]                     inherits <- base::inherits
[10:19:53.539]                     invokeRestart <- base::invokeRestart
[10:19:53.539]                     is.null <- base::is.null
[10:19:53.539]                     muffled <- FALSE
[10:19:53.539]                     if (inherits(cond, "message")) {
[10:19:53.539]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.539]                       if (muffled) 
[10:19:53.539]                         invokeRestart("muffleMessage")
[10:19:53.539]                     }
[10:19:53.539]                     else if (inherits(cond, "warning")) {
[10:19:53.539]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.539]                       if (muffled) 
[10:19:53.539]                         invokeRestart("muffleWarning")
[10:19:53.539]                     }
[10:19:53.539]                     else if (inherits(cond, "condition")) {
[10:19:53.539]                       if (!is.null(pattern)) {
[10:19:53.539]                         computeRestarts <- base::computeRestarts
[10:19:53.539]                         grepl <- base::grepl
[10:19:53.539]                         restarts <- computeRestarts(cond)
[10:19:53.539]                         for (restart in restarts) {
[10:19:53.539]                           name <- restart$name
[10:19:53.539]                           if (is.null(name)) 
[10:19:53.539]                             next
[10:19:53.539]                           if (!grepl(pattern, name)) 
[10:19:53.539]                             next
[10:19:53.539]                           invokeRestart(restart)
[10:19:53.539]                           muffled <- TRUE
[10:19:53.539]                           break
[10:19:53.539]                         }
[10:19:53.539]                       }
[10:19:53.539]                     }
[10:19:53.539]                     invisible(muffled)
[10:19:53.539]                   }
[10:19:53.539]                   muffleCondition(cond)
[10:19:53.539]                 })
[10:19:53.539]             }))
[10:19:53.539]             future::FutureResult(value = ...future.value$value, 
[10:19:53.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.539]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.539]                     ...future.globalenv.names))
[10:19:53.539]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.539]         }, condition = base::local({
[10:19:53.539]             c <- base::c
[10:19:53.539]             inherits <- base::inherits
[10:19:53.539]             invokeRestart <- base::invokeRestart
[10:19:53.539]             length <- base::length
[10:19:53.539]             list <- base::list
[10:19:53.539]             seq.int <- base::seq.int
[10:19:53.539]             signalCondition <- base::signalCondition
[10:19:53.539]             sys.calls <- base::sys.calls
[10:19:53.539]             `[[` <- base::`[[`
[10:19:53.539]             `+` <- base::`+`
[10:19:53.539]             `<<-` <- base::`<<-`
[10:19:53.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.539]                   3L)]
[10:19:53.539]             }
[10:19:53.539]             function(cond) {
[10:19:53.539]                 is_error <- inherits(cond, "error")
[10:19:53.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.539]                   NULL)
[10:19:53.539]                 if (is_error) {
[10:19:53.539]                   sessionInformation <- function() {
[10:19:53.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.539]                       search = base::search(), system = base::Sys.info())
[10:19:53.539]                   }
[10:19:53.539]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.539]                     cond$call), session = sessionInformation(), 
[10:19:53.539]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.539]                   signalCondition(cond)
[10:19:53.539]                 }
[10:19:53.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.539]                 "immediateCondition"))) {
[10:19:53.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.539]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.539]                   if (TRUE && !signal) {
[10:19:53.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.539]                     {
[10:19:53.539]                       inherits <- base::inherits
[10:19:53.539]                       invokeRestart <- base::invokeRestart
[10:19:53.539]                       is.null <- base::is.null
[10:19:53.539]                       muffled <- FALSE
[10:19:53.539]                       if (inherits(cond, "message")) {
[10:19:53.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.539]                         if (muffled) 
[10:19:53.539]                           invokeRestart("muffleMessage")
[10:19:53.539]                       }
[10:19:53.539]                       else if (inherits(cond, "warning")) {
[10:19:53.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.539]                         if (muffled) 
[10:19:53.539]                           invokeRestart("muffleWarning")
[10:19:53.539]                       }
[10:19:53.539]                       else if (inherits(cond, "condition")) {
[10:19:53.539]                         if (!is.null(pattern)) {
[10:19:53.539]                           computeRestarts <- base::computeRestarts
[10:19:53.539]                           grepl <- base::grepl
[10:19:53.539]                           restarts <- computeRestarts(cond)
[10:19:53.539]                           for (restart in restarts) {
[10:19:53.539]                             name <- restart$name
[10:19:53.539]                             if (is.null(name)) 
[10:19:53.539]                               next
[10:19:53.539]                             if (!grepl(pattern, name)) 
[10:19:53.539]                               next
[10:19:53.539]                             invokeRestart(restart)
[10:19:53.539]                             muffled <- TRUE
[10:19:53.539]                             break
[10:19:53.539]                           }
[10:19:53.539]                         }
[10:19:53.539]                       }
[10:19:53.539]                       invisible(muffled)
[10:19:53.539]                     }
[10:19:53.539]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.539]                   }
[10:19:53.539]                 }
[10:19:53.539]                 else {
[10:19:53.539]                   if (TRUE) {
[10:19:53.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.539]                     {
[10:19:53.539]                       inherits <- base::inherits
[10:19:53.539]                       invokeRestart <- base::invokeRestart
[10:19:53.539]                       is.null <- base::is.null
[10:19:53.539]                       muffled <- FALSE
[10:19:53.539]                       if (inherits(cond, "message")) {
[10:19:53.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.539]                         if (muffled) 
[10:19:53.539]                           invokeRestart("muffleMessage")
[10:19:53.539]                       }
[10:19:53.539]                       else if (inherits(cond, "warning")) {
[10:19:53.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.539]                         if (muffled) 
[10:19:53.539]                           invokeRestart("muffleWarning")
[10:19:53.539]                       }
[10:19:53.539]                       else if (inherits(cond, "condition")) {
[10:19:53.539]                         if (!is.null(pattern)) {
[10:19:53.539]                           computeRestarts <- base::computeRestarts
[10:19:53.539]                           grepl <- base::grepl
[10:19:53.539]                           restarts <- computeRestarts(cond)
[10:19:53.539]                           for (restart in restarts) {
[10:19:53.539]                             name <- restart$name
[10:19:53.539]                             if (is.null(name)) 
[10:19:53.539]                               next
[10:19:53.539]                             if (!grepl(pattern, name)) 
[10:19:53.539]                               next
[10:19:53.539]                             invokeRestart(restart)
[10:19:53.539]                             muffled <- TRUE
[10:19:53.539]                             break
[10:19:53.539]                           }
[10:19:53.539]                         }
[10:19:53.539]                       }
[10:19:53.539]                       invisible(muffled)
[10:19:53.539]                     }
[10:19:53.539]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.539]                   }
[10:19:53.539]                 }
[10:19:53.539]             }
[10:19:53.539]         }))
[10:19:53.539]     }, error = function(ex) {
[10:19:53.539]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.539]                 ...future.rng), started = ...future.startTime, 
[10:19:53.539]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.539]             version = "1.8"), class = "FutureResult")
[10:19:53.539]     }, finally = {
[10:19:53.539]         if (!identical(...future.workdir, getwd())) 
[10:19:53.539]             setwd(...future.workdir)
[10:19:53.539]         {
[10:19:53.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.539]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.539]             }
[10:19:53.539]             base::options(...future.oldOptions)
[10:19:53.539]             if (.Platform$OS.type == "windows") {
[10:19:53.539]                 old_names <- names(...future.oldEnvVars)
[10:19:53.539]                 envs <- base::Sys.getenv()
[10:19:53.539]                 names <- names(envs)
[10:19:53.539]                 common <- intersect(names, old_names)
[10:19:53.539]                 added <- setdiff(names, old_names)
[10:19:53.539]                 removed <- setdiff(old_names, names)
[10:19:53.539]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.539]                   envs[common]]
[10:19:53.539]                 NAMES <- toupper(changed)
[10:19:53.539]                 args <- list()
[10:19:53.539]                 for (kk in seq_along(NAMES)) {
[10:19:53.539]                   name <- changed[[kk]]
[10:19:53.539]                   NAME <- NAMES[[kk]]
[10:19:53.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.539]                     next
[10:19:53.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.539]                 }
[10:19:53.539]                 NAMES <- toupper(added)
[10:19:53.539]                 for (kk in seq_along(NAMES)) {
[10:19:53.539]                   name <- added[[kk]]
[10:19:53.539]                   NAME <- NAMES[[kk]]
[10:19:53.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.539]                     next
[10:19:53.539]                   args[[name]] <- ""
[10:19:53.539]                 }
[10:19:53.539]                 NAMES <- toupper(removed)
[10:19:53.539]                 for (kk in seq_along(NAMES)) {
[10:19:53.539]                   name <- removed[[kk]]
[10:19:53.539]                   NAME <- NAMES[[kk]]
[10:19:53.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.539]                     next
[10:19:53.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.539]                 }
[10:19:53.539]                 if (length(args) > 0) 
[10:19:53.539]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.539]             }
[10:19:53.539]             else {
[10:19:53.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.539]             }
[10:19:53.539]             {
[10:19:53.539]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.539]                   0L) {
[10:19:53.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.539]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.539]                   base::options(opts)
[10:19:53.539]                 }
[10:19:53.539]                 {
[10:19:53.539]                   {
[10:19:53.539]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.539]                     NULL
[10:19:53.539]                   }
[10:19:53.539]                   options(future.plan = NULL)
[10:19:53.539]                   if (is.na(NA_character_)) 
[10:19:53.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.539]                     .init = FALSE)
[10:19:53.539]                 }
[10:19:53.539]             }
[10:19:53.539]         }
[10:19:53.539]     })
[10:19:53.539]     if (TRUE) {
[10:19:53.539]         base::sink(type = "output", split = FALSE)
[10:19:53.539]         if (TRUE) {
[10:19:53.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.539]         }
[10:19:53.539]         else {
[10:19:53.539]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.539]         }
[10:19:53.539]         base::close(...future.stdout)
[10:19:53.539]         ...future.stdout <- NULL
[10:19:53.539]     }
[10:19:53.539]     ...future.result$conditions <- ...future.conditions
[10:19:53.539]     ...future.result$finished <- base::Sys.time()
[10:19:53.539]     ...future.result
[10:19:53.539] }
[10:19:53.541] assign_globals() ...
[10:19:53.541] List of 11
[10:19:53.541]  $ ...future.FUN            :function (x, ...)  
[10:19:53.541]  $ x_FUN                    :function (x)  
[10:19:53.541]  $ times                    : int 1
[10:19:53.541]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.541]  $ stop_if_not              :function (...)  
[10:19:53.541]  $ dim                      : NULL
[10:19:53.541]  $ valid_types              : chr "logical"
[10:19:53.541]  $ future.call.arguments    : list()
[10:19:53.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.541]  $ ...future.elements_ii    :List of 6
[10:19:53.541]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[10:19:53.541]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[10:19:53.541]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[10:19:53.541]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[10:19:53.541]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[10:19:53.541]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[10:19:53.541]  $ ...future.seeds_ii       : NULL
[10:19:53.541]  $ ...future.globals.maxSize: NULL
[10:19:53.541]  - attr(*, "where")=List of 11
[10:19:53.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.541]  - attr(*, "resolved")= logi FALSE
[10:19:53.541]  - attr(*, "total_size")= num 30734
[10:19:53.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.541]  - attr(*, "already-done")= logi TRUE
[10:19:53.550] - copied ‘...future.FUN’ to environment
[10:19:53.550] - copied ‘x_FUN’ to environment
[10:19:53.551] - copied ‘times’ to environment
[10:19:53.551] - copied ‘stopf’ to environment
[10:19:53.551] - copied ‘stop_if_not’ to environment
[10:19:53.551] - copied ‘dim’ to environment
[10:19:53.551] - copied ‘valid_types’ to environment
[10:19:53.551] - copied ‘future.call.arguments’ to environment
[10:19:53.551] - copied ‘...future.elements_ii’ to environment
[10:19:53.551] - copied ‘...future.seeds_ii’ to environment
[10:19:53.551] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.551] assign_globals() ... done
[10:19:53.552] requestCore(): workers = 2
[10:19:53.553] MulticoreFuture started
[10:19:53.554] - Launch lazy future ... done
[10:19:53.554] run() for ‘MulticoreFuture’ ... done
[10:19:53.554] Created future:
[10:19:53.555] plan(): Setting new future strategy stack:
[10:19:53.555] List of future strategies:
[10:19:53.555] 1. sequential:
[10:19:53.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.555]    - tweaked: FALSE
[10:19:53.555]    - call: NULL
[10:19:53.556] plan(): nbrOfWorkers() = 1
[10:19:53.558] plan(): Setting new future strategy stack:
[10:19:53.558] List of future strategies:
[10:19:53.558] 1. multicore:
[10:19:53.558]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.558]    - tweaked: FALSE
[10:19:53.558]    - call: plan(strategy)
[10:19:53.555] MulticoreFuture:
[10:19:53.555] Label: ‘future_vapply-1’
[10:19:53.555] Expression:
[10:19:53.555] {
[10:19:53.555]     do.call(function(...) {
[10:19:53.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.555]             on.exit(options(oopts), add = TRUE)
[10:19:53.555]         }
[10:19:53.555]         {
[10:19:53.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.555]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.555]             })
[10:19:53.555]         }
[10:19:53.555]     }, args = future.call.arguments)
[10:19:53.555] }
[10:19:53.555] Lazy evaluation: FALSE
[10:19:53.555] Asynchronous evaluation: TRUE
[10:19:53.555] Local evaluation: TRUE
[10:19:53.555] Environment: R_GlobalEnv
[10:19:53.555] Capture standard output: TRUE
[10:19:53.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.555] Globals: 11 objects totaling 16.54 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.555] Packages: 1 packages (‘future.apply’)
[10:19:53.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.555] Resolved: FALSE
[10:19:53.555] Value: <not collected>
[10:19:53.555] Conditions captured: <none>
[10:19:53.555] Early signaling: FALSE
[10:19:53.555] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.555] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.567] plan(): nbrOfWorkers() = 2
[10:19:53.567] Chunk #1 of 2 ... DONE
[10:19:53.567] Chunk #2 of 2 ...
[10:19:53.568]  - Finding globals in 'X' for chunk #2 ...
[10:19:53.568] getGlobalsAndPackages() ...
[10:19:53.568] Searching for globals...
[10:19:53.568] 
[10:19:53.571] Searching for globals ... DONE
[10:19:53.571] - globals: [0] <none>
[10:19:53.571] getGlobalsAndPackages() ... DONE
[10:19:53.572]    + additional globals found: [n=0] 
[10:19:53.572]    + additional namespaces needed: [n=0] 
[10:19:53.572]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:53.572]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.573]  - seeds: <none>
[10:19:53.573]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.573] getGlobalsAndPackages() ...
[10:19:53.573] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.574] Resolving globals: FALSE
[10:19:53.574] Tweak future expression to call with '...' arguments ...
[10:19:53.575] {
[10:19:53.575]     do.call(function(...) {
[10:19:53.575]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.575]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.575]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.575]             on.exit(options(oopts), add = TRUE)
[10:19:53.575]         }
[10:19:53.575]         {
[10:19:53.575]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.575]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.575]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.575]             })
[10:19:53.575]         }
[10:19:53.575]     }, args = future.call.arguments)
[10:19:53.575] }
[10:19:53.575] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.577] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.577] - packages: [1] ‘future.apply’
[10:19:53.577] getGlobalsAndPackages() ... DONE
[10:19:53.578] run() for ‘Future’ ...
[10:19:53.578] - state: ‘created’
[10:19:53.579] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.582] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.582]   - Field: ‘label’
[10:19:53.582]   - Field: ‘local’
[10:19:53.583]   - Field: ‘owner’
[10:19:53.583]   - Field: ‘envir’
[10:19:53.583]   - Field: ‘workers’
[10:19:53.583]   - Field: ‘packages’
[10:19:53.583]   - Field: ‘gc’
[10:19:53.584]   - Field: ‘job’
[10:19:53.584]   - Field: ‘conditions’
[10:19:53.584]   - Field: ‘expr’
[10:19:53.584]   - Field: ‘uuid’
[10:19:53.584]   - Field: ‘seed’
[10:19:53.585]   - Field: ‘version’
[10:19:53.585]   - Field: ‘result’
[10:19:53.585]   - Field: ‘asynchronous’
[10:19:53.585]   - Field: ‘calls’
[10:19:53.585]   - Field: ‘globals’
[10:19:53.586]   - Field: ‘stdout’
[10:19:53.586]   - Field: ‘earlySignal’
[10:19:53.586]   - Field: ‘lazy’
[10:19:53.586]   - Field: ‘state’
[10:19:53.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.587] - Launch lazy future ...
[10:19:53.587] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.587] Packages needed by future strategies (n = 0): <none>
[10:19:53.588] {
[10:19:53.588]     {
[10:19:53.588]         {
[10:19:53.588]             ...future.startTime <- base::Sys.time()
[10:19:53.588]             {
[10:19:53.588]                 {
[10:19:53.588]                   {
[10:19:53.588]                     {
[10:19:53.588]                       {
[10:19:53.588]                         base::local({
[10:19:53.588]                           has_future <- base::requireNamespace("future", 
[10:19:53.588]                             quietly = TRUE)
[10:19:53.588]                           if (has_future) {
[10:19:53.588]                             ns <- base::getNamespace("future")
[10:19:53.588]                             version <- ns[[".package"]][["version"]]
[10:19:53.588]                             if (is.null(version)) 
[10:19:53.588]                               version <- utils::packageVersion("future")
[10:19:53.588]                           }
[10:19:53.588]                           else {
[10:19:53.588]                             version <- NULL
[10:19:53.588]                           }
[10:19:53.588]                           if (!has_future || version < "1.8.0") {
[10:19:53.588]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.588]                               "", base::R.version$version.string), 
[10:19:53.588]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.588]                                 base::R.version$platform, 8 * 
[10:19:53.588]                                   base::.Machine$sizeof.pointer), 
[10:19:53.588]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.588]                                 "release", "version")], collapse = " "), 
[10:19:53.588]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.588]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.588]                               info)
[10:19:53.588]                             info <- base::paste(info, collapse = "; ")
[10:19:53.588]                             if (!has_future) {
[10:19:53.588]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.588]                                 info)
[10:19:53.588]                             }
[10:19:53.588]                             else {
[10:19:53.588]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.588]                                 info, version)
[10:19:53.588]                             }
[10:19:53.588]                             base::stop(msg)
[10:19:53.588]                           }
[10:19:53.588]                         })
[10:19:53.588]                       }
[10:19:53.588]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.588]                       base::options(mc.cores = 1L)
[10:19:53.588]                     }
[10:19:53.588]                     base::local({
[10:19:53.588]                       for (pkg in "future.apply") {
[10:19:53.588]                         base::loadNamespace(pkg)
[10:19:53.588]                         base::library(pkg, character.only = TRUE)
[10:19:53.588]                       }
[10:19:53.588]                     })
[10:19:53.588]                   }
[10:19:53.588]                   ...future.strategy.old <- future::plan("list")
[10:19:53.588]                   options(future.plan = NULL)
[10:19:53.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.588]                 }
[10:19:53.588]                 ...future.workdir <- getwd()
[10:19:53.588]             }
[10:19:53.588]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.588]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.588]         }
[10:19:53.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.588]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.588]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.588]             base::names(...future.oldOptions))
[10:19:53.588]     }
[10:19:53.588]     if (FALSE) {
[10:19:53.588]     }
[10:19:53.588]     else {
[10:19:53.588]         if (TRUE) {
[10:19:53.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.588]                 open = "w")
[10:19:53.588]         }
[10:19:53.588]         else {
[10:19:53.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.588]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.588]         }
[10:19:53.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.588]             base::sink(type = "output", split = FALSE)
[10:19:53.588]             base::close(...future.stdout)
[10:19:53.588]         }, add = TRUE)
[10:19:53.588]     }
[10:19:53.588]     ...future.frame <- base::sys.nframe()
[10:19:53.588]     ...future.conditions <- base::list()
[10:19:53.588]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.588]     if (FALSE) {
[10:19:53.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.588]     }
[10:19:53.588]     ...future.result <- base::tryCatch({
[10:19:53.588]         base::withCallingHandlers({
[10:19:53.588]             ...future.value <- base::withVisible(base::local({
[10:19:53.588]                 withCallingHandlers({
[10:19:53.588]                   {
[10:19:53.588]                     do.call(function(...) {
[10:19:53.588]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.588]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.588]                         ...future.globals.maxSize)) {
[10:19:53.588]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.588]                         on.exit(options(oopts), add = TRUE)
[10:19:53.588]                       }
[10:19:53.588]                       {
[10:19:53.588]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.588]                           FUN = function(jj) {
[10:19:53.588]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.588]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.588]                           })
[10:19:53.588]                       }
[10:19:53.588]                     }, args = future.call.arguments)
[10:19:53.588]                   }
[10:19:53.588]                 }, immediateCondition = function(cond) {
[10:19:53.588]                   save_rds <- function (object, pathname, ...) 
[10:19:53.588]                   {
[10:19:53.588]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.588]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.588]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.588]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.588]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.588]                         fi_tmp[["mtime"]])
[10:19:53.588]                     }
[10:19:53.588]                     tryCatch({
[10:19:53.588]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.588]                     }, error = function(ex) {
[10:19:53.588]                       msg <- conditionMessage(ex)
[10:19:53.588]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.588]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.588]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.588]                         fi_tmp[["mtime"]], msg)
[10:19:53.588]                       ex$message <- msg
[10:19:53.588]                       stop(ex)
[10:19:53.588]                     })
[10:19:53.588]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.588]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.588]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.588]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.588]                       fi <- file.info(pathname)
[10:19:53.588]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.588]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.588]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.588]                         fi[["size"]], fi[["mtime"]])
[10:19:53.588]                       stop(msg)
[10:19:53.588]                     }
[10:19:53.588]                     invisible(pathname)
[10:19:53.588]                   }
[10:19:53.588]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.588]                     rootPath = tempdir()) 
[10:19:53.588]                   {
[10:19:53.588]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.588]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.588]                       tmpdir = path, fileext = ".rds")
[10:19:53.588]                     save_rds(obj, file)
[10:19:53.588]                   }
[10:19:53.588]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.588]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.588]                   {
[10:19:53.588]                     inherits <- base::inherits
[10:19:53.588]                     invokeRestart <- base::invokeRestart
[10:19:53.588]                     is.null <- base::is.null
[10:19:53.588]                     muffled <- FALSE
[10:19:53.588]                     if (inherits(cond, "message")) {
[10:19:53.588]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.588]                       if (muffled) 
[10:19:53.588]                         invokeRestart("muffleMessage")
[10:19:53.588]                     }
[10:19:53.588]                     else if (inherits(cond, "warning")) {
[10:19:53.588]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.588]                       if (muffled) 
[10:19:53.588]                         invokeRestart("muffleWarning")
[10:19:53.588]                     }
[10:19:53.588]                     else if (inherits(cond, "condition")) {
[10:19:53.588]                       if (!is.null(pattern)) {
[10:19:53.588]                         computeRestarts <- base::computeRestarts
[10:19:53.588]                         grepl <- base::grepl
[10:19:53.588]                         restarts <- computeRestarts(cond)
[10:19:53.588]                         for (restart in restarts) {
[10:19:53.588]                           name <- restart$name
[10:19:53.588]                           if (is.null(name)) 
[10:19:53.588]                             next
[10:19:53.588]                           if (!grepl(pattern, name)) 
[10:19:53.588]                             next
[10:19:53.588]                           invokeRestart(restart)
[10:19:53.588]                           muffled <- TRUE
[10:19:53.588]                           break
[10:19:53.588]                         }
[10:19:53.588]                       }
[10:19:53.588]                     }
[10:19:53.588]                     invisible(muffled)
[10:19:53.588]                   }
[10:19:53.588]                   muffleCondition(cond)
[10:19:53.588]                 })
[10:19:53.588]             }))
[10:19:53.588]             future::FutureResult(value = ...future.value$value, 
[10:19:53.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.588]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.588]                     ...future.globalenv.names))
[10:19:53.588]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.588]         }, condition = base::local({
[10:19:53.588]             c <- base::c
[10:19:53.588]             inherits <- base::inherits
[10:19:53.588]             invokeRestart <- base::invokeRestart
[10:19:53.588]             length <- base::length
[10:19:53.588]             list <- base::list
[10:19:53.588]             seq.int <- base::seq.int
[10:19:53.588]             signalCondition <- base::signalCondition
[10:19:53.588]             sys.calls <- base::sys.calls
[10:19:53.588]             `[[` <- base::`[[`
[10:19:53.588]             `+` <- base::`+`
[10:19:53.588]             `<<-` <- base::`<<-`
[10:19:53.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.588]                   3L)]
[10:19:53.588]             }
[10:19:53.588]             function(cond) {
[10:19:53.588]                 is_error <- inherits(cond, "error")
[10:19:53.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.588]                   NULL)
[10:19:53.588]                 if (is_error) {
[10:19:53.588]                   sessionInformation <- function() {
[10:19:53.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.588]                       search = base::search(), system = base::Sys.info())
[10:19:53.588]                   }
[10:19:53.588]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.588]                     cond$call), session = sessionInformation(), 
[10:19:53.588]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.588]                   signalCondition(cond)
[10:19:53.588]                 }
[10:19:53.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.588]                 "immediateCondition"))) {
[10:19:53.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.588]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.588]                   if (TRUE && !signal) {
[10:19:53.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.588]                     {
[10:19:53.588]                       inherits <- base::inherits
[10:19:53.588]                       invokeRestart <- base::invokeRestart
[10:19:53.588]                       is.null <- base::is.null
[10:19:53.588]                       muffled <- FALSE
[10:19:53.588]                       if (inherits(cond, "message")) {
[10:19:53.588]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.588]                         if (muffled) 
[10:19:53.588]                           invokeRestart("muffleMessage")
[10:19:53.588]                       }
[10:19:53.588]                       else if (inherits(cond, "warning")) {
[10:19:53.588]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.588]                         if (muffled) 
[10:19:53.588]                           invokeRestart("muffleWarning")
[10:19:53.588]                       }
[10:19:53.588]                       else if (inherits(cond, "condition")) {
[10:19:53.588]                         if (!is.null(pattern)) {
[10:19:53.588]                           computeRestarts <- base::computeRestarts
[10:19:53.588]                           grepl <- base::grepl
[10:19:53.588]                           restarts <- computeRestarts(cond)
[10:19:53.588]                           for (restart in restarts) {
[10:19:53.588]                             name <- restart$name
[10:19:53.588]                             if (is.null(name)) 
[10:19:53.588]                               next
[10:19:53.588]                             if (!grepl(pattern, name)) 
[10:19:53.588]                               next
[10:19:53.588]                             invokeRestart(restart)
[10:19:53.588]                             muffled <- TRUE
[10:19:53.588]                             break
[10:19:53.588]                           }
[10:19:53.588]                         }
[10:19:53.588]                       }
[10:19:53.588]                       invisible(muffled)
[10:19:53.588]                     }
[10:19:53.588]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.588]                   }
[10:19:53.588]                 }
[10:19:53.588]                 else {
[10:19:53.588]                   if (TRUE) {
[10:19:53.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.588]                     {
[10:19:53.588]                       inherits <- base::inherits
[10:19:53.588]                       invokeRestart <- base::invokeRestart
[10:19:53.588]                       is.null <- base::is.null
[10:19:53.588]                       muffled <- FALSE
[10:19:53.588]                       if (inherits(cond, "message")) {
[10:19:53.588]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.588]                         if (muffled) 
[10:19:53.588]                           invokeRestart("muffleMessage")
[10:19:53.588]                       }
[10:19:53.588]                       else if (inherits(cond, "warning")) {
[10:19:53.588]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.588]                         if (muffled) 
[10:19:53.588]                           invokeRestart("muffleWarning")
[10:19:53.588]                       }
[10:19:53.588]                       else if (inherits(cond, "condition")) {
[10:19:53.588]                         if (!is.null(pattern)) {
[10:19:53.588]                           computeRestarts <- base::computeRestarts
[10:19:53.588]                           grepl <- base::grepl
[10:19:53.588]                           restarts <- computeRestarts(cond)
[10:19:53.588]                           for (restart in restarts) {
[10:19:53.588]                             name <- restart$name
[10:19:53.588]                             if (is.null(name)) 
[10:19:53.588]                               next
[10:19:53.588]                             if (!grepl(pattern, name)) 
[10:19:53.588]                               next
[10:19:53.588]                             invokeRestart(restart)
[10:19:53.588]                             muffled <- TRUE
[10:19:53.588]                             break
[10:19:53.588]                           }
[10:19:53.588]                         }
[10:19:53.588]                       }
[10:19:53.588]                       invisible(muffled)
[10:19:53.588]                     }
[10:19:53.588]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.588]                   }
[10:19:53.588]                 }
[10:19:53.588]             }
[10:19:53.588]         }))
[10:19:53.588]     }, error = function(ex) {
[10:19:53.588]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.588]                 ...future.rng), started = ...future.startTime, 
[10:19:53.588]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.588]             version = "1.8"), class = "FutureResult")
[10:19:53.588]     }, finally = {
[10:19:53.588]         if (!identical(...future.workdir, getwd())) 
[10:19:53.588]             setwd(...future.workdir)
[10:19:53.588]         {
[10:19:53.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.588]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.588]             }
[10:19:53.588]             base::options(...future.oldOptions)
[10:19:53.588]             if (.Platform$OS.type == "windows") {
[10:19:53.588]                 old_names <- names(...future.oldEnvVars)
[10:19:53.588]                 envs <- base::Sys.getenv()
[10:19:53.588]                 names <- names(envs)
[10:19:53.588]                 common <- intersect(names, old_names)
[10:19:53.588]                 added <- setdiff(names, old_names)
[10:19:53.588]                 removed <- setdiff(old_names, names)
[10:19:53.588]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.588]                   envs[common]]
[10:19:53.588]                 NAMES <- toupper(changed)
[10:19:53.588]                 args <- list()
[10:19:53.588]                 for (kk in seq_along(NAMES)) {
[10:19:53.588]                   name <- changed[[kk]]
[10:19:53.588]                   NAME <- NAMES[[kk]]
[10:19:53.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.588]                     next
[10:19:53.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.588]                 }
[10:19:53.588]                 NAMES <- toupper(added)
[10:19:53.588]                 for (kk in seq_along(NAMES)) {
[10:19:53.588]                   name <- added[[kk]]
[10:19:53.588]                   NAME <- NAMES[[kk]]
[10:19:53.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.588]                     next
[10:19:53.588]                   args[[name]] <- ""
[10:19:53.588]                 }
[10:19:53.588]                 NAMES <- toupper(removed)
[10:19:53.588]                 for (kk in seq_along(NAMES)) {
[10:19:53.588]                   name <- removed[[kk]]
[10:19:53.588]                   NAME <- NAMES[[kk]]
[10:19:53.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.588]                     next
[10:19:53.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.588]                 }
[10:19:53.588]                 if (length(args) > 0) 
[10:19:53.588]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.588]             }
[10:19:53.588]             else {
[10:19:53.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.588]             }
[10:19:53.588]             {
[10:19:53.588]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.588]                   0L) {
[10:19:53.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.588]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.588]                   base::options(opts)
[10:19:53.588]                 }
[10:19:53.588]                 {
[10:19:53.588]                   {
[10:19:53.588]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.588]                     NULL
[10:19:53.588]                   }
[10:19:53.588]                   options(future.plan = NULL)
[10:19:53.588]                   if (is.na(NA_character_)) 
[10:19:53.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.588]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.588]                     .init = FALSE)
[10:19:53.588]                 }
[10:19:53.588]             }
[10:19:53.588]         }
[10:19:53.588]     })
[10:19:53.588]     if (TRUE) {
[10:19:53.588]         base::sink(type = "output", split = FALSE)
[10:19:53.588]         if (TRUE) {
[10:19:53.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.588]         }
[10:19:53.588]         else {
[10:19:53.588]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.588]         }
[10:19:53.588]         base::close(...future.stdout)
[10:19:53.588]         ...future.stdout <- NULL
[10:19:53.588]     }
[10:19:53.588]     ...future.result$conditions <- ...future.conditions
[10:19:53.588]     ...future.result$finished <- base::Sys.time()
[10:19:53.588]     ...future.result
[10:19:53.588] }
[10:19:53.591] assign_globals() ...
[10:19:53.591] List of 11
[10:19:53.591]  $ ...future.FUN            :function (x, ...)  
[10:19:53.591]  $ x_FUN                    :function (x)  
[10:19:53.591]  $ times                    : int 1
[10:19:53.591]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.591]  $ stop_if_not              :function (...)  
[10:19:53.591]  $ dim                      : NULL
[10:19:53.591]  $ valid_types              : chr "logical"
[10:19:53.591]  $ future.call.arguments    : list()
[10:19:53.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.591]  $ ...future.elements_ii    :List of 5
[10:19:53.591]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[10:19:53.591]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[10:19:53.591]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[10:19:53.591]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[10:19:53.591]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[10:19:53.591]  $ ...future.seeds_ii       : NULL
[10:19:53.591]  $ ...future.globals.maxSize: NULL
[10:19:53.591]  - attr(*, "where")=List of 11
[10:19:53.591]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.591]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.591]  - attr(*, "resolved")= logi FALSE
[10:19:53.591]  - attr(*, "total_size")= num 30734
[10:19:53.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.591]  - attr(*, "already-done")= logi TRUE
[10:19:53.602] - copied ‘...future.FUN’ to environment
[10:19:53.602] - copied ‘x_FUN’ to environment
[10:19:53.602] - copied ‘times’ to environment
[10:19:53.602] - copied ‘stopf’ to environment
[10:19:53.602] - copied ‘stop_if_not’ to environment
[10:19:53.602] - copied ‘dim’ to environment
[10:19:53.602] - copied ‘valid_types’ to environment
[10:19:53.602] - copied ‘future.call.arguments’ to environment
[10:19:53.602] - copied ‘...future.elements_ii’ to environment
[10:19:53.603] - copied ‘...future.seeds_ii’ to environment
[10:19:53.603] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.603] assign_globals() ... done
[10:19:53.603] requestCore(): workers = 2
[10:19:53.607] MulticoreFuture started
[10:19:53.608] - Launch lazy future ... done
[10:19:53.608] run() for ‘MulticoreFuture’ ... done
[10:19:53.609] Created future:
[10:19:53.609] plan(): Setting new future strategy stack:
[10:19:53.610] List of future strategies:
[10:19:53.610] 1. sequential:
[10:19:53.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.610]    - tweaked: FALSE
[10:19:53.610]    - call: NULL
[10:19:53.611] plan(): nbrOfWorkers() = 1
[10:19:53.615] plan(): Setting new future strategy stack:
[10:19:53.615] List of future strategies:
[10:19:53.615] 1. multicore:
[10:19:53.615]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.615]    - tweaked: FALSE
[10:19:53.615]    - call: plan(strategy)
[10:19:53.619] plan(): nbrOfWorkers() = 2
[10:19:53.609] MulticoreFuture:
[10:19:53.609] Label: ‘future_vapply-2’
[10:19:53.609] Expression:
[10:19:53.609] {
[10:19:53.609]     do.call(function(...) {
[10:19:53.609]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.609]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.609]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.609]             on.exit(options(oopts), add = TRUE)
[10:19:53.609]         }
[10:19:53.609]         {
[10:19:53.609]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.609]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.609]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.609]             })
[10:19:53.609]         }
[10:19:53.609]     }, args = future.call.arguments)
[10:19:53.609] }
[10:19:53.609] Lazy evaluation: FALSE
[10:19:53.609] Asynchronous evaluation: TRUE
[10:19:53.609] Local evaluation: TRUE
[10:19:53.609] Environment: R_GlobalEnv
[10:19:53.609] Capture standard output: TRUE
[10:19:53.609] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.609] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.609] Packages: 1 packages (‘future.apply’)
[10:19:53.609] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.609] Resolved: TRUE
[10:19:53.609] Value: <not collected>
[10:19:53.609] Conditions captured: <none>
[10:19:53.609] Early signaling: FALSE
[10:19:53.609] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.609] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.620] Chunk #2 of 2 ... DONE
[10:19:53.620] Launching 2 futures (chunks) ... DONE
[10:19:53.621] Resolving 2 futures (chunks) ...
[10:19:53.621] resolve() on list ...
[10:19:53.621]  recursive: 0
[10:19:53.621]  length: 2
[10:19:53.621] 
[10:19:53.622] Future #1
[10:19:53.622] result() for MulticoreFuture ...
[10:19:53.623] result() for MulticoreFuture ...
[10:19:53.623] result() for MulticoreFuture ... done
[10:19:53.624] result() for MulticoreFuture ... done
[10:19:53.624] result() for MulticoreFuture ...
[10:19:53.624] result() for MulticoreFuture ... done
[10:19:53.624] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:53.624] - nx: 2
[10:19:53.625] - relay: TRUE
[10:19:53.625] - stdout: TRUE
[10:19:53.625] - signal: TRUE
[10:19:53.625] - resignal: FALSE
[10:19:53.625] - force: TRUE
[10:19:53.626] - relayed: [n=2] FALSE, FALSE
[10:19:53.626] - queued futures: [n=2] FALSE, FALSE
[10:19:53.626]  - until=1
[10:19:53.626]  - relaying element #1
[10:19:53.626] result() for MulticoreFuture ...
[10:19:53.627] result() for MulticoreFuture ... done
[10:19:53.627] result() for MulticoreFuture ...
[10:19:53.627] result() for MulticoreFuture ... done
[10:19:53.628] result() for MulticoreFuture ...
[10:19:53.628] result() for MulticoreFuture ... done
[10:19:53.628] result() for MulticoreFuture ...
[10:19:53.628] result() for MulticoreFuture ... done
[10:19:53.628] - relayed: [n=2] TRUE, FALSE
[10:19:53.629] - queued futures: [n=2] TRUE, FALSE
[10:19:53.629] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:53.629]  length: 1 (resolved future 1)
[10:19:53.629] Future #2
[10:19:53.630] result() for MulticoreFuture ...
[10:19:53.631] result() for MulticoreFuture ...
[10:19:53.631] result() for MulticoreFuture ... done
[10:19:53.631] result() for MulticoreFuture ... done
[10:19:53.631] result() for MulticoreFuture ...
[10:19:53.631] result() for MulticoreFuture ... done
[10:19:53.632] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:53.632] - nx: 2
[10:19:53.632] - relay: TRUE
[10:19:53.632] - stdout: TRUE
[10:19:53.632] - signal: TRUE
[10:19:53.632] - resignal: FALSE
[10:19:53.632] - force: TRUE
[10:19:53.632] - relayed: [n=2] TRUE, FALSE
[10:19:53.633] - queued futures: [n=2] TRUE, FALSE
[10:19:53.633]  - until=2
[10:19:53.633]  - relaying element #2
[10:19:53.633] result() for MulticoreFuture ...
[10:19:53.633] result() for MulticoreFuture ... done
[10:19:53.633] result() for MulticoreFuture ...
[10:19:53.633] result() for MulticoreFuture ... done
[10:19:53.633] result() for MulticoreFuture ...
[10:19:53.633] result() for MulticoreFuture ... done
[10:19:53.634] result() for MulticoreFuture ...
[10:19:53.634] result() for MulticoreFuture ... done
[10:19:53.634] - relayed: [n=2] TRUE, TRUE
[10:19:53.634] - queued futures: [n=2] TRUE, TRUE
[10:19:53.634] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:53.634]  length: 0 (resolved future 2)
[10:19:53.634] Relaying remaining futures
[10:19:53.634] signalConditionsASAP(NULL, pos=0) ...
[10:19:53.634] - nx: 2
[10:19:53.635] - relay: TRUE
[10:19:53.635] - stdout: TRUE
[10:19:53.635] - signal: TRUE
[10:19:53.635] - resignal: FALSE
[10:19:53.635] - force: TRUE
[10:19:53.635] - relayed: [n=2] TRUE, TRUE
[10:19:53.635] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:53.635] - relayed: [n=2] TRUE, TRUE
[10:19:53.635] - queued futures: [n=2] TRUE, TRUE
[10:19:53.635] signalConditionsASAP(NULL, pos=0) ... done
[10:19:53.636] resolve() on list ... DONE
[10:19:53.636] result() for MulticoreFuture ...
[10:19:53.636] result() for MulticoreFuture ... done
[10:19:53.636] result() for MulticoreFuture ...
[10:19:53.636] result() for MulticoreFuture ... done
[10:19:53.636] result() for MulticoreFuture ...
[10:19:53.636] result() for MulticoreFuture ... done
[10:19:53.636] result() for MulticoreFuture ...
[10:19:53.636] result() for MulticoreFuture ... done
[10:19:53.637]  - Number of value chunks collected: 2
[10:19:53.637] Resolving 2 futures (chunks) ... DONE
[10:19:53.637] Reducing values from 2 chunks ...
[10:19:53.637]  - Number of values collected after concatenation: 11
[10:19:53.637]  - Number of values expected: 11
[10:19:53.637] Reducing values from 2 chunks ... DONE
[10:19:53.637] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:19:53.638] future_lapply() ...
[10:19:53.642] Number of chunks: 2
[10:19:53.642] getGlobalsAndPackagesXApply() ...
[10:19:53.642]  - future.globals: TRUE
[10:19:53.642] getGlobalsAndPackages() ...
[10:19:53.643] Searching for globals...
[10:19:53.648] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:53.648] Searching for globals ... DONE
[10:19:53.648] Resolving globals: FALSE
[10:19:53.649] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[10:19:53.650] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:53.650] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.650] - packages: [1] ‘future.apply’
[10:19:53.650] getGlobalsAndPackages() ... DONE
[10:19:53.650]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.651]  - needed namespaces: [n=1] ‘future.apply’
[10:19:53.651] Finding globals ... DONE
[10:19:53.651]  - use_args: TRUE
[10:19:53.651]  - Getting '...' globals ...
[10:19:53.651] resolve() on list ...
[10:19:53.651]  recursive: 0
[10:19:53.652]  length: 1
[10:19:53.652]  elements: ‘...’
[10:19:53.652]  length: 0 (resolved future 1)
[10:19:53.652] resolve() on list ... DONE
[10:19:53.652]    - '...' content: [n=0] 
[10:19:53.652] List of 1
[10:19:53.652]  $ ...: list()
[10:19:53.652]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.652]  - attr(*, "where")=List of 1
[10:19:53.652]   ..$ ...:<environment: 0x55c69f2e9ba8> 
[10:19:53.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.652]  - attr(*, "resolved")= logi TRUE
[10:19:53.652]  - attr(*, "total_size")= num NA
[10:19:53.655]  - Getting '...' globals ... DONE
[10:19:53.655] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:53.655] List of 8
[10:19:53.655]  $ ...future.FUN:function (x, ...)  
[10:19:53.655]  $ x_FUN        :function (x)  
[10:19:53.655]  $ times        : int 1
[10:19:53.655]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.655]  $ stop_if_not  :function (...)  
[10:19:53.655]  $ dim          : NULL
[10:19:53.655]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:53.655]  $ ...          : list()
[10:19:53.655]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.655]  - attr(*, "where")=List of 8
[10:19:53.655]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:53.655]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:53.655]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:53.655]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:53.655]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:53.655]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:53.655]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:53.655]   ..$ ...          :<environment: 0x55c69f2e9ba8> 
[10:19:53.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.655]  - attr(*, "resolved")= logi FALSE
[10:19:53.655]  - attr(*, "total_size")= num 22016
[10:19:53.661] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:53.661] getGlobalsAndPackagesXApply() ... DONE
[10:19:53.661] Number of futures (= number of chunks): 2
[10:19:53.661] Launching 2 futures (chunks) ...
[10:19:53.661] Chunk #1 of 2 ...
[10:19:53.661]  - Finding globals in 'X' for chunk #1 ...
[10:19:53.662] getGlobalsAndPackages() ...
[10:19:53.662] Searching for globals...
[10:19:53.662] 
[10:19:53.662] Searching for globals ... DONE
[10:19:53.662] - globals: [0] <none>
[10:19:53.662] getGlobalsAndPackages() ... DONE
[10:19:53.662]    + additional globals found: [n=0] 
[10:19:53.662]    + additional namespaces needed: [n=0] 
[10:19:53.662]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:53.662]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.663]  - seeds: <none>
[10:19:53.663]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.663] getGlobalsAndPackages() ...
[10:19:53.663] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.663] Resolving globals: FALSE
[10:19:53.663] Tweak future expression to call with '...' arguments ...
[10:19:53.663] {
[10:19:53.663]     do.call(function(...) {
[10:19:53.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.663]             on.exit(options(oopts), add = TRUE)
[10:19:53.663]         }
[10:19:53.663]         {
[10:19:53.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.663]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.663]             })
[10:19:53.663]         }
[10:19:53.663]     }, args = future.call.arguments)
[10:19:53.663] }
[10:19:53.664] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.664] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.664] - packages: [1] ‘future.apply’
[10:19:53.664] getGlobalsAndPackages() ... DONE
[10:19:53.665] run() for ‘Future’ ...
[10:19:53.665] - state: ‘created’
[10:19:53.665] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.667]   - Field: ‘label’
[10:19:53.667]   - Field: ‘local’
[10:19:53.667]   - Field: ‘owner’
[10:19:53.667]   - Field: ‘envir’
[10:19:53.667]   - Field: ‘workers’
[10:19:53.667]   - Field: ‘packages’
[10:19:53.667]   - Field: ‘gc’
[10:19:53.667]   - Field: ‘job’
[10:19:53.667]   - Field: ‘conditions’
[10:19:53.670]   - Field: ‘expr’
[10:19:53.670]   - Field: ‘uuid’
[10:19:53.670]   - Field: ‘seed’
[10:19:53.670]   - Field: ‘version’
[10:19:53.670]   - Field: ‘result’
[10:19:53.670]   - Field: ‘asynchronous’
[10:19:53.670]   - Field: ‘calls’
[10:19:53.670]   - Field: ‘globals’
[10:19:53.671]   - Field: ‘stdout’
[10:19:53.671]   - Field: ‘earlySignal’
[10:19:53.671]   - Field: ‘lazy’
[10:19:53.671]   - Field: ‘state’
[10:19:53.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.671] - Launch lazy future ...
[10:19:53.671] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.672] Packages needed by future strategies (n = 0): <none>
[10:19:53.672] {
[10:19:53.672]     {
[10:19:53.672]         {
[10:19:53.672]             ...future.startTime <- base::Sys.time()
[10:19:53.672]             {
[10:19:53.672]                 {
[10:19:53.672]                   {
[10:19:53.672]                     {
[10:19:53.672]                       {
[10:19:53.672]                         base::local({
[10:19:53.672]                           has_future <- base::requireNamespace("future", 
[10:19:53.672]                             quietly = TRUE)
[10:19:53.672]                           if (has_future) {
[10:19:53.672]                             ns <- base::getNamespace("future")
[10:19:53.672]                             version <- ns[[".package"]][["version"]]
[10:19:53.672]                             if (is.null(version)) 
[10:19:53.672]                               version <- utils::packageVersion("future")
[10:19:53.672]                           }
[10:19:53.672]                           else {
[10:19:53.672]                             version <- NULL
[10:19:53.672]                           }
[10:19:53.672]                           if (!has_future || version < "1.8.0") {
[10:19:53.672]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.672]                               "", base::R.version$version.string), 
[10:19:53.672]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.672]                                 base::R.version$platform, 8 * 
[10:19:53.672]                                   base::.Machine$sizeof.pointer), 
[10:19:53.672]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.672]                                 "release", "version")], collapse = " "), 
[10:19:53.672]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.672]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.672]                               info)
[10:19:53.672]                             info <- base::paste(info, collapse = "; ")
[10:19:53.672]                             if (!has_future) {
[10:19:53.672]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.672]                                 info)
[10:19:53.672]                             }
[10:19:53.672]                             else {
[10:19:53.672]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.672]                                 info, version)
[10:19:53.672]                             }
[10:19:53.672]                             base::stop(msg)
[10:19:53.672]                           }
[10:19:53.672]                         })
[10:19:53.672]                       }
[10:19:53.672]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.672]                       base::options(mc.cores = 1L)
[10:19:53.672]                     }
[10:19:53.672]                     base::local({
[10:19:53.672]                       for (pkg in "future.apply") {
[10:19:53.672]                         base::loadNamespace(pkg)
[10:19:53.672]                         base::library(pkg, character.only = TRUE)
[10:19:53.672]                       }
[10:19:53.672]                     })
[10:19:53.672]                   }
[10:19:53.672]                   ...future.strategy.old <- future::plan("list")
[10:19:53.672]                   options(future.plan = NULL)
[10:19:53.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.672]                 }
[10:19:53.672]                 ...future.workdir <- getwd()
[10:19:53.672]             }
[10:19:53.672]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.672]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.672]         }
[10:19:53.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.672]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.672]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.672]             base::names(...future.oldOptions))
[10:19:53.672]     }
[10:19:53.672]     if (FALSE) {
[10:19:53.672]     }
[10:19:53.672]     else {
[10:19:53.672]         if (TRUE) {
[10:19:53.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.672]                 open = "w")
[10:19:53.672]         }
[10:19:53.672]         else {
[10:19:53.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.672]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.672]         }
[10:19:53.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.672]             base::sink(type = "output", split = FALSE)
[10:19:53.672]             base::close(...future.stdout)
[10:19:53.672]         }, add = TRUE)
[10:19:53.672]     }
[10:19:53.672]     ...future.frame <- base::sys.nframe()
[10:19:53.672]     ...future.conditions <- base::list()
[10:19:53.672]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.672]     if (FALSE) {
[10:19:53.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.672]     }
[10:19:53.672]     ...future.result <- base::tryCatch({
[10:19:53.672]         base::withCallingHandlers({
[10:19:53.672]             ...future.value <- base::withVisible(base::local({
[10:19:53.672]                 withCallingHandlers({
[10:19:53.672]                   {
[10:19:53.672]                     do.call(function(...) {
[10:19:53.672]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.672]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.672]                         ...future.globals.maxSize)) {
[10:19:53.672]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.672]                         on.exit(options(oopts), add = TRUE)
[10:19:53.672]                       }
[10:19:53.672]                       {
[10:19:53.672]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.672]                           FUN = function(jj) {
[10:19:53.672]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.672]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.672]                           })
[10:19:53.672]                       }
[10:19:53.672]                     }, args = future.call.arguments)
[10:19:53.672]                   }
[10:19:53.672]                 }, immediateCondition = function(cond) {
[10:19:53.672]                   save_rds <- function (object, pathname, ...) 
[10:19:53.672]                   {
[10:19:53.672]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.672]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.672]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.672]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.672]                         fi_tmp[["mtime"]])
[10:19:53.672]                     }
[10:19:53.672]                     tryCatch({
[10:19:53.672]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.672]                     }, error = function(ex) {
[10:19:53.672]                       msg <- conditionMessage(ex)
[10:19:53.672]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.672]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.672]                         fi_tmp[["mtime"]], msg)
[10:19:53.672]                       ex$message <- msg
[10:19:53.672]                       stop(ex)
[10:19:53.672]                     })
[10:19:53.672]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.672]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.672]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.672]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.672]                       fi <- file.info(pathname)
[10:19:53.672]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.672]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.672]                         fi[["size"]], fi[["mtime"]])
[10:19:53.672]                       stop(msg)
[10:19:53.672]                     }
[10:19:53.672]                     invisible(pathname)
[10:19:53.672]                   }
[10:19:53.672]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.672]                     rootPath = tempdir()) 
[10:19:53.672]                   {
[10:19:53.672]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.672]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.672]                       tmpdir = path, fileext = ".rds")
[10:19:53.672]                     save_rds(obj, file)
[10:19:53.672]                   }
[10:19:53.672]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.672]                   {
[10:19:53.672]                     inherits <- base::inherits
[10:19:53.672]                     invokeRestart <- base::invokeRestart
[10:19:53.672]                     is.null <- base::is.null
[10:19:53.672]                     muffled <- FALSE
[10:19:53.672]                     if (inherits(cond, "message")) {
[10:19:53.672]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.672]                       if (muffled) 
[10:19:53.672]                         invokeRestart("muffleMessage")
[10:19:53.672]                     }
[10:19:53.672]                     else if (inherits(cond, "warning")) {
[10:19:53.672]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.672]                       if (muffled) 
[10:19:53.672]                         invokeRestart("muffleWarning")
[10:19:53.672]                     }
[10:19:53.672]                     else if (inherits(cond, "condition")) {
[10:19:53.672]                       if (!is.null(pattern)) {
[10:19:53.672]                         computeRestarts <- base::computeRestarts
[10:19:53.672]                         grepl <- base::grepl
[10:19:53.672]                         restarts <- computeRestarts(cond)
[10:19:53.672]                         for (restart in restarts) {
[10:19:53.672]                           name <- restart$name
[10:19:53.672]                           if (is.null(name)) 
[10:19:53.672]                             next
[10:19:53.672]                           if (!grepl(pattern, name)) 
[10:19:53.672]                             next
[10:19:53.672]                           invokeRestart(restart)
[10:19:53.672]                           muffled <- TRUE
[10:19:53.672]                           break
[10:19:53.672]                         }
[10:19:53.672]                       }
[10:19:53.672]                     }
[10:19:53.672]                     invisible(muffled)
[10:19:53.672]                   }
[10:19:53.672]                   muffleCondition(cond)
[10:19:53.672]                 })
[10:19:53.672]             }))
[10:19:53.672]             future::FutureResult(value = ...future.value$value, 
[10:19:53.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.672]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.672]                     ...future.globalenv.names))
[10:19:53.672]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.672]         }, condition = base::local({
[10:19:53.672]             c <- base::c
[10:19:53.672]             inherits <- base::inherits
[10:19:53.672]             invokeRestart <- base::invokeRestart
[10:19:53.672]             length <- base::length
[10:19:53.672]             list <- base::list
[10:19:53.672]             seq.int <- base::seq.int
[10:19:53.672]             signalCondition <- base::signalCondition
[10:19:53.672]             sys.calls <- base::sys.calls
[10:19:53.672]             `[[` <- base::`[[`
[10:19:53.672]             `+` <- base::`+`
[10:19:53.672]             `<<-` <- base::`<<-`
[10:19:53.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.672]                   3L)]
[10:19:53.672]             }
[10:19:53.672]             function(cond) {
[10:19:53.672]                 is_error <- inherits(cond, "error")
[10:19:53.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.672]                   NULL)
[10:19:53.672]                 if (is_error) {
[10:19:53.672]                   sessionInformation <- function() {
[10:19:53.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.672]                       search = base::search(), system = base::Sys.info())
[10:19:53.672]                   }
[10:19:53.672]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.672]                     cond$call), session = sessionInformation(), 
[10:19:53.672]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.672]                   signalCondition(cond)
[10:19:53.672]                 }
[10:19:53.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.672]                 "immediateCondition"))) {
[10:19:53.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.672]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.672]                   if (TRUE && !signal) {
[10:19:53.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.672]                     {
[10:19:53.672]                       inherits <- base::inherits
[10:19:53.672]                       invokeRestart <- base::invokeRestart
[10:19:53.672]                       is.null <- base::is.null
[10:19:53.672]                       muffled <- FALSE
[10:19:53.672]                       if (inherits(cond, "message")) {
[10:19:53.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.672]                         if (muffled) 
[10:19:53.672]                           invokeRestart("muffleMessage")
[10:19:53.672]                       }
[10:19:53.672]                       else if (inherits(cond, "warning")) {
[10:19:53.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.672]                         if (muffled) 
[10:19:53.672]                           invokeRestart("muffleWarning")
[10:19:53.672]                       }
[10:19:53.672]                       else if (inherits(cond, "condition")) {
[10:19:53.672]                         if (!is.null(pattern)) {
[10:19:53.672]                           computeRestarts <- base::computeRestarts
[10:19:53.672]                           grepl <- base::grepl
[10:19:53.672]                           restarts <- computeRestarts(cond)
[10:19:53.672]                           for (restart in restarts) {
[10:19:53.672]                             name <- restart$name
[10:19:53.672]                             if (is.null(name)) 
[10:19:53.672]                               next
[10:19:53.672]                             if (!grepl(pattern, name)) 
[10:19:53.672]                               next
[10:19:53.672]                             invokeRestart(restart)
[10:19:53.672]                             muffled <- TRUE
[10:19:53.672]                             break
[10:19:53.672]                           }
[10:19:53.672]                         }
[10:19:53.672]                       }
[10:19:53.672]                       invisible(muffled)
[10:19:53.672]                     }
[10:19:53.672]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.672]                   }
[10:19:53.672]                 }
[10:19:53.672]                 else {
[10:19:53.672]                   if (TRUE) {
[10:19:53.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.672]                     {
[10:19:53.672]                       inherits <- base::inherits
[10:19:53.672]                       invokeRestart <- base::invokeRestart
[10:19:53.672]                       is.null <- base::is.null
[10:19:53.672]                       muffled <- FALSE
[10:19:53.672]                       if (inherits(cond, "message")) {
[10:19:53.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.672]                         if (muffled) 
[10:19:53.672]                           invokeRestart("muffleMessage")
[10:19:53.672]                       }
[10:19:53.672]                       else if (inherits(cond, "warning")) {
[10:19:53.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.672]                         if (muffled) 
[10:19:53.672]                           invokeRestart("muffleWarning")
[10:19:53.672]                       }
[10:19:53.672]                       else if (inherits(cond, "condition")) {
[10:19:53.672]                         if (!is.null(pattern)) {
[10:19:53.672]                           computeRestarts <- base::computeRestarts
[10:19:53.672]                           grepl <- base::grepl
[10:19:53.672]                           restarts <- computeRestarts(cond)
[10:19:53.672]                           for (restart in restarts) {
[10:19:53.672]                             name <- restart$name
[10:19:53.672]                             if (is.null(name)) 
[10:19:53.672]                               next
[10:19:53.672]                             if (!grepl(pattern, name)) 
[10:19:53.672]                               next
[10:19:53.672]                             invokeRestart(restart)
[10:19:53.672]                             muffled <- TRUE
[10:19:53.672]                             break
[10:19:53.672]                           }
[10:19:53.672]                         }
[10:19:53.672]                       }
[10:19:53.672]                       invisible(muffled)
[10:19:53.672]                     }
[10:19:53.672]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.672]                   }
[10:19:53.672]                 }
[10:19:53.672]             }
[10:19:53.672]         }))
[10:19:53.672]     }, error = function(ex) {
[10:19:53.672]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.672]                 ...future.rng), started = ...future.startTime, 
[10:19:53.672]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.672]             version = "1.8"), class = "FutureResult")
[10:19:53.672]     }, finally = {
[10:19:53.672]         if (!identical(...future.workdir, getwd())) 
[10:19:53.672]             setwd(...future.workdir)
[10:19:53.672]         {
[10:19:53.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.672]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.672]             }
[10:19:53.672]             base::options(...future.oldOptions)
[10:19:53.672]             if (.Platform$OS.type == "windows") {
[10:19:53.672]                 old_names <- names(...future.oldEnvVars)
[10:19:53.672]                 envs <- base::Sys.getenv()
[10:19:53.672]                 names <- names(envs)
[10:19:53.672]                 common <- intersect(names, old_names)
[10:19:53.672]                 added <- setdiff(names, old_names)
[10:19:53.672]                 removed <- setdiff(old_names, names)
[10:19:53.672]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.672]                   envs[common]]
[10:19:53.672]                 NAMES <- toupper(changed)
[10:19:53.672]                 args <- list()
[10:19:53.672]                 for (kk in seq_along(NAMES)) {
[10:19:53.672]                   name <- changed[[kk]]
[10:19:53.672]                   NAME <- NAMES[[kk]]
[10:19:53.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.672]                     next
[10:19:53.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.672]                 }
[10:19:53.672]                 NAMES <- toupper(added)
[10:19:53.672]                 for (kk in seq_along(NAMES)) {
[10:19:53.672]                   name <- added[[kk]]
[10:19:53.672]                   NAME <- NAMES[[kk]]
[10:19:53.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.672]                     next
[10:19:53.672]                   args[[name]] <- ""
[10:19:53.672]                 }
[10:19:53.672]                 NAMES <- toupper(removed)
[10:19:53.672]                 for (kk in seq_along(NAMES)) {
[10:19:53.672]                   name <- removed[[kk]]
[10:19:53.672]                   NAME <- NAMES[[kk]]
[10:19:53.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.672]                     next
[10:19:53.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.672]                 }
[10:19:53.672]                 if (length(args) > 0) 
[10:19:53.672]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.672]             }
[10:19:53.672]             else {
[10:19:53.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.672]             }
[10:19:53.672]             {
[10:19:53.672]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.672]                   0L) {
[10:19:53.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.672]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.672]                   base::options(opts)
[10:19:53.672]                 }
[10:19:53.672]                 {
[10:19:53.672]                   {
[10:19:53.672]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.672]                     NULL
[10:19:53.672]                   }
[10:19:53.672]                   options(future.plan = NULL)
[10:19:53.672]                   if (is.na(NA_character_)) 
[10:19:53.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.672]                     .init = FALSE)
[10:19:53.672]                 }
[10:19:53.672]             }
[10:19:53.672]         }
[10:19:53.672]     })
[10:19:53.672]     if (TRUE) {
[10:19:53.672]         base::sink(type = "output", split = FALSE)
[10:19:53.672]         if (TRUE) {
[10:19:53.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.672]         }
[10:19:53.672]         else {
[10:19:53.672]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.672]         }
[10:19:53.672]         base::close(...future.stdout)
[10:19:53.672]         ...future.stdout <- NULL
[10:19:53.672]     }
[10:19:53.672]     ...future.result$conditions <- ...future.conditions
[10:19:53.672]     ...future.result$finished <- base::Sys.time()
[10:19:53.672]     ...future.result
[10:19:53.672] }
[10:19:53.675] assign_globals() ...
[10:19:53.675] List of 11
[10:19:53.675]  $ ...future.FUN            :function (x, ...)  
[10:19:53.675]  $ x_FUN                    :function (x)  
[10:19:53.675]  $ times                    : int 1
[10:19:53.675]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.675]  $ stop_if_not              :function (...)  
[10:19:53.675]  $ dim                      : NULL
[10:19:53.675]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:53.675]  $ future.call.arguments    : list()
[10:19:53.675]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.675]  $ ...future.elements_ii    :List of 1
[10:19:53.675]   ..$ a: num 1
[10:19:53.675]  $ ...future.seeds_ii       : NULL
[10:19:53.675]  $ ...future.globals.maxSize: NULL
[10:19:53.675]  - attr(*, "where")=List of 11
[10:19:53.675]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.675]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.675]  - attr(*, "resolved")= logi FALSE
[10:19:53.675]  - attr(*, "total_size")= num 22016
[10:19:53.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.675]  - attr(*, "already-done")= logi TRUE
[10:19:53.682] - copied ‘...future.FUN’ to environment
[10:19:53.683] - copied ‘x_FUN’ to environment
[10:19:53.683] - copied ‘times’ to environment
[10:19:53.683] - copied ‘stopf’ to environment
[10:19:53.683] - copied ‘stop_if_not’ to environment
[10:19:53.683] - copied ‘dim’ to environment
[10:19:53.683] - copied ‘valid_types’ to environment
[10:19:53.683] - copied ‘future.call.arguments’ to environment
[10:19:53.683] - copied ‘...future.elements_ii’ to environment
[10:19:53.683] - copied ‘...future.seeds_ii’ to environment
[10:19:53.683] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.684] assign_globals() ... done
[10:19:53.684] requestCore(): workers = 2
[10:19:53.686] MulticoreFuture started
[10:19:53.686] - Launch lazy future ... done
[10:19:53.686] run() for ‘MulticoreFuture’ ... done
[10:19:53.687] Created future:
[10:19:53.687] plan(): Setting new future strategy stack:
[10:19:53.687] List of future strategies:
[10:19:53.687] 1. sequential:
[10:19:53.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.687]    - tweaked: FALSE
[10:19:53.687]    - call: NULL
[10:19:53.688] plan(): nbrOfWorkers() = 1
[10:19:53.690] plan(): Setting new future strategy stack:
[10:19:53.691] List of future strategies:
[10:19:53.691] 1. multicore:
[10:19:53.691]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.691]    - tweaked: FALSE
[10:19:53.691]    - call: plan(strategy)
[10:19:53.694] plan(): nbrOfWorkers() = 2
[10:19:53.687] MulticoreFuture:
[10:19:53.687] Label: ‘future_vapply-1’
[10:19:53.687] Expression:
[10:19:53.687] {
[10:19:53.687]     do.call(function(...) {
[10:19:53.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.687]             on.exit(options(oopts), add = TRUE)
[10:19:53.687]         }
[10:19:53.687]         {
[10:19:53.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.687]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.687]             })
[10:19:53.687]         }
[10:19:53.687]     }, args = future.call.arguments)
[10:19:53.687] }
[10:19:53.687] Lazy evaluation: FALSE
[10:19:53.687] Asynchronous evaluation: TRUE
[10:19:53.687] Local evaluation: TRUE
[10:19:53.687] Environment: R_GlobalEnv
[10:19:53.687] Capture standard output: TRUE
[10:19:53.687] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.687] Globals: 11 objects totaling 12.15 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.687] Packages: 1 packages (‘future.apply’)
[10:19:53.687] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.687] Resolved: TRUE
[10:19:53.687] Value: <not collected>
[10:19:53.687] Conditions captured: <none>
[10:19:53.687] Early signaling: FALSE
[10:19:53.687] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.687] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.695] Chunk #1 of 2 ... DONE
[10:19:53.695] Chunk #2 of 2 ...
[10:19:53.695]  - Finding globals in 'X' for chunk #2 ...
[10:19:53.695] getGlobalsAndPackages() ...
[10:19:53.695] Searching for globals...
[10:19:53.696] 
[10:19:53.696] Searching for globals ... DONE
[10:19:53.696] - globals: [0] <none>
[10:19:53.696] getGlobalsAndPackages() ... DONE
[10:19:53.696]    + additional globals found: [n=0] 
[10:19:53.697]    + additional namespaces needed: [n=0] 
[10:19:53.697]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:53.697]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.697]  - seeds: <none>
[10:19:53.697]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.697] getGlobalsAndPackages() ...
[10:19:53.697] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.698] Resolving globals: FALSE
[10:19:53.698] Tweak future expression to call with '...' arguments ...
[10:19:53.698] {
[10:19:53.698]     do.call(function(...) {
[10:19:53.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.698]             on.exit(options(oopts), add = TRUE)
[10:19:53.698]         }
[10:19:53.698]         {
[10:19:53.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.698]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.698]             })
[10:19:53.698]         }
[10:19:53.698]     }, args = future.call.arguments)
[10:19:53.698] }
[10:19:53.698] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.699] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.699] - packages: [1] ‘future.apply’
[10:19:53.700] getGlobalsAndPackages() ... DONE
[10:19:53.700] run() for ‘Future’ ...
[10:19:53.700] - state: ‘created’
[10:19:53.701] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.703] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.707]   - Field: ‘label’
[10:19:53.707]   - Field: ‘local’
[10:19:53.708]   - Field: ‘owner’
[10:19:53.708]   - Field: ‘envir’
[10:19:53.708]   - Field: ‘workers’
[10:19:53.709]   - Field: ‘packages’
[10:19:53.709]   - Field: ‘gc’
[10:19:53.709]   - Field: ‘job’
[10:19:53.709]   - Field: ‘conditions’
[10:19:53.710]   - Field: ‘expr’
[10:19:53.710]   - Field: ‘uuid’
[10:19:53.710]   - Field: ‘seed’
[10:19:53.711]   - Field: ‘version’
[10:19:53.711]   - Field: ‘result’
[10:19:53.711]   - Field: ‘asynchronous’
[10:19:53.711]   - Field: ‘calls’
[10:19:53.712]   - Field: ‘globals’
[10:19:53.712]   - Field: ‘stdout’
[10:19:53.712]   - Field: ‘earlySignal’
[10:19:53.712]   - Field: ‘lazy’
[10:19:53.712]   - Field: ‘state’
[10:19:53.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.713] - Launch lazy future ...
[10:19:53.713] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.714] Packages needed by future strategies (n = 0): <none>
[10:19:53.715] {
[10:19:53.715]     {
[10:19:53.715]         {
[10:19:53.715]             ...future.startTime <- base::Sys.time()
[10:19:53.715]             {
[10:19:53.715]                 {
[10:19:53.715]                   {
[10:19:53.715]                     {
[10:19:53.715]                       {
[10:19:53.715]                         base::local({
[10:19:53.715]                           has_future <- base::requireNamespace("future", 
[10:19:53.715]                             quietly = TRUE)
[10:19:53.715]                           if (has_future) {
[10:19:53.715]                             ns <- base::getNamespace("future")
[10:19:53.715]                             version <- ns[[".package"]][["version"]]
[10:19:53.715]                             if (is.null(version)) 
[10:19:53.715]                               version <- utils::packageVersion("future")
[10:19:53.715]                           }
[10:19:53.715]                           else {
[10:19:53.715]                             version <- NULL
[10:19:53.715]                           }
[10:19:53.715]                           if (!has_future || version < "1.8.0") {
[10:19:53.715]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.715]                               "", base::R.version$version.string), 
[10:19:53.715]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.715]                                 base::R.version$platform, 8 * 
[10:19:53.715]                                   base::.Machine$sizeof.pointer), 
[10:19:53.715]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.715]                                 "release", "version")], collapse = " "), 
[10:19:53.715]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.715]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.715]                               info)
[10:19:53.715]                             info <- base::paste(info, collapse = "; ")
[10:19:53.715]                             if (!has_future) {
[10:19:53.715]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.715]                                 info)
[10:19:53.715]                             }
[10:19:53.715]                             else {
[10:19:53.715]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.715]                                 info, version)
[10:19:53.715]                             }
[10:19:53.715]                             base::stop(msg)
[10:19:53.715]                           }
[10:19:53.715]                         })
[10:19:53.715]                       }
[10:19:53.715]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.715]                       base::options(mc.cores = 1L)
[10:19:53.715]                     }
[10:19:53.715]                     base::local({
[10:19:53.715]                       for (pkg in "future.apply") {
[10:19:53.715]                         base::loadNamespace(pkg)
[10:19:53.715]                         base::library(pkg, character.only = TRUE)
[10:19:53.715]                       }
[10:19:53.715]                     })
[10:19:53.715]                   }
[10:19:53.715]                   ...future.strategy.old <- future::plan("list")
[10:19:53.715]                   options(future.plan = NULL)
[10:19:53.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.715]                 }
[10:19:53.715]                 ...future.workdir <- getwd()
[10:19:53.715]             }
[10:19:53.715]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.715]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.715]         }
[10:19:53.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.715]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.715]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.715]             base::names(...future.oldOptions))
[10:19:53.715]     }
[10:19:53.715]     if (FALSE) {
[10:19:53.715]     }
[10:19:53.715]     else {
[10:19:53.715]         if (TRUE) {
[10:19:53.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.715]                 open = "w")
[10:19:53.715]         }
[10:19:53.715]         else {
[10:19:53.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.715]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.715]         }
[10:19:53.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.715]             base::sink(type = "output", split = FALSE)
[10:19:53.715]             base::close(...future.stdout)
[10:19:53.715]         }, add = TRUE)
[10:19:53.715]     }
[10:19:53.715]     ...future.frame <- base::sys.nframe()
[10:19:53.715]     ...future.conditions <- base::list()
[10:19:53.715]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.715]     if (FALSE) {
[10:19:53.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.715]     }
[10:19:53.715]     ...future.result <- base::tryCatch({
[10:19:53.715]         base::withCallingHandlers({
[10:19:53.715]             ...future.value <- base::withVisible(base::local({
[10:19:53.715]                 withCallingHandlers({
[10:19:53.715]                   {
[10:19:53.715]                     do.call(function(...) {
[10:19:53.715]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.715]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.715]                         ...future.globals.maxSize)) {
[10:19:53.715]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.715]                         on.exit(options(oopts), add = TRUE)
[10:19:53.715]                       }
[10:19:53.715]                       {
[10:19:53.715]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.715]                           FUN = function(jj) {
[10:19:53.715]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.715]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.715]                           })
[10:19:53.715]                       }
[10:19:53.715]                     }, args = future.call.arguments)
[10:19:53.715]                   }
[10:19:53.715]                 }, immediateCondition = function(cond) {
[10:19:53.715]                   save_rds <- function (object, pathname, ...) 
[10:19:53.715]                   {
[10:19:53.715]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.715]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.715]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.715]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.715]                         fi_tmp[["mtime"]])
[10:19:53.715]                     }
[10:19:53.715]                     tryCatch({
[10:19:53.715]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.715]                     }, error = function(ex) {
[10:19:53.715]                       msg <- conditionMessage(ex)
[10:19:53.715]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.715]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.715]                         fi_tmp[["mtime"]], msg)
[10:19:53.715]                       ex$message <- msg
[10:19:53.715]                       stop(ex)
[10:19:53.715]                     })
[10:19:53.715]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.715]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.715]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.715]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.715]                       fi <- file.info(pathname)
[10:19:53.715]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.715]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.715]                         fi[["size"]], fi[["mtime"]])
[10:19:53.715]                       stop(msg)
[10:19:53.715]                     }
[10:19:53.715]                     invisible(pathname)
[10:19:53.715]                   }
[10:19:53.715]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.715]                     rootPath = tempdir()) 
[10:19:53.715]                   {
[10:19:53.715]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.715]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.715]                       tmpdir = path, fileext = ".rds")
[10:19:53.715]                     save_rds(obj, file)
[10:19:53.715]                   }
[10:19:53.715]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.715]                   {
[10:19:53.715]                     inherits <- base::inherits
[10:19:53.715]                     invokeRestart <- base::invokeRestart
[10:19:53.715]                     is.null <- base::is.null
[10:19:53.715]                     muffled <- FALSE
[10:19:53.715]                     if (inherits(cond, "message")) {
[10:19:53.715]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.715]                       if (muffled) 
[10:19:53.715]                         invokeRestart("muffleMessage")
[10:19:53.715]                     }
[10:19:53.715]                     else if (inherits(cond, "warning")) {
[10:19:53.715]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.715]                       if (muffled) 
[10:19:53.715]                         invokeRestart("muffleWarning")
[10:19:53.715]                     }
[10:19:53.715]                     else if (inherits(cond, "condition")) {
[10:19:53.715]                       if (!is.null(pattern)) {
[10:19:53.715]                         computeRestarts <- base::computeRestarts
[10:19:53.715]                         grepl <- base::grepl
[10:19:53.715]                         restarts <- computeRestarts(cond)
[10:19:53.715]                         for (restart in restarts) {
[10:19:53.715]                           name <- restart$name
[10:19:53.715]                           if (is.null(name)) 
[10:19:53.715]                             next
[10:19:53.715]                           if (!grepl(pattern, name)) 
[10:19:53.715]                             next
[10:19:53.715]                           invokeRestart(restart)
[10:19:53.715]                           muffled <- TRUE
[10:19:53.715]                           break
[10:19:53.715]                         }
[10:19:53.715]                       }
[10:19:53.715]                     }
[10:19:53.715]                     invisible(muffled)
[10:19:53.715]                   }
[10:19:53.715]                   muffleCondition(cond)
[10:19:53.715]                 })
[10:19:53.715]             }))
[10:19:53.715]             future::FutureResult(value = ...future.value$value, 
[10:19:53.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.715]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.715]                     ...future.globalenv.names))
[10:19:53.715]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.715]         }, condition = base::local({
[10:19:53.715]             c <- base::c
[10:19:53.715]             inherits <- base::inherits
[10:19:53.715]             invokeRestart <- base::invokeRestart
[10:19:53.715]             length <- base::length
[10:19:53.715]             list <- base::list
[10:19:53.715]             seq.int <- base::seq.int
[10:19:53.715]             signalCondition <- base::signalCondition
[10:19:53.715]             sys.calls <- base::sys.calls
[10:19:53.715]             `[[` <- base::`[[`
[10:19:53.715]             `+` <- base::`+`
[10:19:53.715]             `<<-` <- base::`<<-`
[10:19:53.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.715]                   3L)]
[10:19:53.715]             }
[10:19:53.715]             function(cond) {
[10:19:53.715]                 is_error <- inherits(cond, "error")
[10:19:53.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.715]                   NULL)
[10:19:53.715]                 if (is_error) {
[10:19:53.715]                   sessionInformation <- function() {
[10:19:53.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.715]                       search = base::search(), system = base::Sys.info())
[10:19:53.715]                   }
[10:19:53.715]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.715]                     cond$call), session = sessionInformation(), 
[10:19:53.715]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.715]                   signalCondition(cond)
[10:19:53.715]                 }
[10:19:53.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.715]                 "immediateCondition"))) {
[10:19:53.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.715]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.715]                   if (TRUE && !signal) {
[10:19:53.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.715]                     {
[10:19:53.715]                       inherits <- base::inherits
[10:19:53.715]                       invokeRestart <- base::invokeRestart
[10:19:53.715]                       is.null <- base::is.null
[10:19:53.715]                       muffled <- FALSE
[10:19:53.715]                       if (inherits(cond, "message")) {
[10:19:53.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.715]                         if (muffled) 
[10:19:53.715]                           invokeRestart("muffleMessage")
[10:19:53.715]                       }
[10:19:53.715]                       else if (inherits(cond, "warning")) {
[10:19:53.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.715]                         if (muffled) 
[10:19:53.715]                           invokeRestart("muffleWarning")
[10:19:53.715]                       }
[10:19:53.715]                       else if (inherits(cond, "condition")) {
[10:19:53.715]                         if (!is.null(pattern)) {
[10:19:53.715]                           computeRestarts <- base::computeRestarts
[10:19:53.715]                           grepl <- base::grepl
[10:19:53.715]                           restarts <- computeRestarts(cond)
[10:19:53.715]                           for (restart in restarts) {
[10:19:53.715]                             name <- restart$name
[10:19:53.715]                             if (is.null(name)) 
[10:19:53.715]                               next
[10:19:53.715]                             if (!grepl(pattern, name)) 
[10:19:53.715]                               next
[10:19:53.715]                             invokeRestart(restart)
[10:19:53.715]                             muffled <- TRUE
[10:19:53.715]                             break
[10:19:53.715]                           }
[10:19:53.715]                         }
[10:19:53.715]                       }
[10:19:53.715]                       invisible(muffled)
[10:19:53.715]                     }
[10:19:53.715]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.715]                   }
[10:19:53.715]                 }
[10:19:53.715]                 else {
[10:19:53.715]                   if (TRUE) {
[10:19:53.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.715]                     {
[10:19:53.715]                       inherits <- base::inherits
[10:19:53.715]                       invokeRestart <- base::invokeRestart
[10:19:53.715]                       is.null <- base::is.null
[10:19:53.715]                       muffled <- FALSE
[10:19:53.715]                       if (inherits(cond, "message")) {
[10:19:53.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.715]                         if (muffled) 
[10:19:53.715]                           invokeRestart("muffleMessage")
[10:19:53.715]                       }
[10:19:53.715]                       else if (inherits(cond, "warning")) {
[10:19:53.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.715]                         if (muffled) 
[10:19:53.715]                           invokeRestart("muffleWarning")
[10:19:53.715]                       }
[10:19:53.715]                       else if (inherits(cond, "condition")) {
[10:19:53.715]                         if (!is.null(pattern)) {
[10:19:53.715]                           computeRestarts <- base::computeRestarts
[10:19:53.715]                           grepl <- base::grepl
[10:19:53.715]                           restarts <- computeRestarts(cond)
[10:19:53.715]                           for (restart in restarts) {
[10:19:53.715]                             name <- restart$name
[10:19:53.715]                             if (is.null(name)) 
[10:19:53.715]                               next
[10:19:53.715]                             if (!grepl(pattern, name)) 
[10:19:53.715]                               next
[10:19:53.715]                             invokeRestart(restart)
[10:19:53.715]                             muffled <- TRUE
[10:19:53.715]                             break
[10:19:53.715]                           }
[10:19:53.715]                         }
[10:19:53.715]                       }
[10:19:53.715]                       invisible(muffled)
[10:19:53.715]                     }
[10:19:53.715]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.715]                   }
[10:19:53.715]                 }
[10:19:53.715]             }
[10:19:53.715]         }))
[10:19:53.715]     }, error = function(ex) {
[10:19:53.715]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.715]                 ...future.rng), started = ...future.startTime, 
[10:19:53.715]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.715]             version = "1.8"), class = "FutureResult")
[10:19:53.715]     }, finally = {
[10:19:53.715]         if (!identical(...future.workdir, getwd())) 
[10:19:53.715]             setwd(...future.workdir)
[10:19:53.715]         {
[10:19:53.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.715]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.715]             }
[10:19:53.715]             base::options(...future.oldOptions)
[10:19:53.715]             if (.Platform$OS.type == "windows") {
[10:19:53.715]                 old_names <- names(...future.oldEnvVars)
[10:19:53.715]                 envs <- base::Sys.getenv()
[10:19:53.715]                 names <- names(envs)
[10:19:53.715]                 common <- intersect(names, old_names)
[10:19:53.715]                 added <- setdiff(names, old_names)
[10:19:53.715]                 removed <- setdiff(old_names, names)
[10:19:53.715]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.715]                   envs[common]]
[10:19:53.715]                 NAMES <- toupper(changed)
[10:19:53.715]                 args <- list()
[10:19:53.715]                 for (kk in seq_along(NAMES)) {
[10:19:53.715]                   name <- changed[[kk]]
[10:19:53.715]                   NAME <- NAMES[[kk]]
[10:19:53.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.715]                     next
[10:19:53.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.715]                 }
[10:19:53.715]                 NAMES <- toupper(added)
[10:19:53.715]                 for (kk in seq_along(NAMES)) {
[10:19:53.715]                   name <- added[[kk]]
[10:19:53.715]                   NAME <- NAMES[[kk]]
[10:19:53.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.715]                     next
[10:19:53.715]                   args[[name]] <- ""
[10:19:53.715]                 }
[10:19:53.715]                 NAMES <- toupper(removed)
[10:19:53.715]                 for (kk in seq_along(NAMES)) {
[10:19:53.715]                   name <- removed[[kk]]
[10:19:53.715]                   NAME <- NAMES[[kk]]
[10:19:53.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.715]                     next
[10:19:53.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.715]                 }
[10:19:53.715]                 if (length(args) > 0) 
[10:19:53.715]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.715]             }
[10:19:53.715]             else {
[10:19:53.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.715]             }
[10:19:53.715]             {
[10:19:53.715]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.715]                   0L) {
[10:19:53.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.715]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.715]                   base::options(opts)
[10:19:53.715]                 }
[10:19:53.715]                 {
[10:19:53.715]                   {
[10:19:53.715]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.715]                     NULL
[10:19:53.715]                   }
[10:19:53.715]                   options(future.plan = NULL)
[10:19:53.715]                   if (is.na(NA_character_)) 
[10:19:53.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.715]                     .init = FALSE)
[10:19:53.715]                 }
[10:19:53.715]             }
[10:19:53.715]         }
[10:19:53.715]     })
[10:19:53.715]     if (TRUE) {
[10:19:53.715]         base::sink(type = "output", split = FALSE)
[10:19:53.715]         if (TRUE) {
[10:19:53.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.715]         }
[10:19:53.715]         else {
[10:19:53.715]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.715]         }
[10:19:53.715]         base::close(...future.stdout)
[10:19:53.715]         ...future.stdout <- NULL
[10:19:53.715]     }
[10:19:53.715]     ...future.result$conditions <- ...future.conditions
[10:19:53.715]     ...future.result$finished <- base::Sys.time()
[10:19:53.715]     ...future.result
[10:19:53.715] }
[10:19:53.717] assign_globals() ...
[10:19:53.718] List of 11
[10:19:53.718]  $ ...future.FUN            :function (x, ...)  
[10:19:53.718]  $ x_FUN                    :function (x)  
[10:19:53.718]  $ times                    : int 1
[10:19:53.718]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.718]  $ stop_if_not              :function (...)  
[10:19:53.718]  $ dim                      : NULL
[10:19:53.718]  $ valid_types              : chr [1:2] "logical" "integer"
[10:19:53.718]  $ future.call.arguments    : list()
[10:19:53.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.718]  $ ...future.elements_ii    :List of 2
[10:19:53.718]   ..$ b: num 2
[10:19:53.718]   ..$ c: num 3
[10:19:53.718]  $ ...future.seeds_ii       : NULL
[10:19:53.718]  $ ...future.globals.maxSize: NULL
[10:19:53.718]  - attr(*, "where")=List of 11
[10:19:53.718]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.718]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.718]  - attr(*, "resolved")= logi FALSE
[10:19:53.718]  - attr(*, "total_size")= num 22016
[10:19:53.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.718]  - attr(*, "already-done")= logi TRUE
[10:19:53.729] - copied ‘...future.FUN’ to environment
[10:19:53.730] - copied ‘x_FUN’ to environment
[10:19:53.730] - copied ‘times’ to environment
[10:19:53.730] - copied ‘stopf’ to environment
[10:19:53.730] - copied ‘stop_if_not’ to environment
[10:19:53.730] - copied ‘dim’ to environment
[10:19:53.730] - copied ‘valid_types’ to environment
[10:19:53.730] - copied ‘future.call.arguments’ to environment
[10:19:53.730] - copied ‘...future.elements_ii’ to environment
[10:19:53.730] - copied ‘...future.seeds_ii’ to environment
[10:19:53.730] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.731] assign_globals() ... done
[10:19:53.731] requestCore(): workers = 2
[10:19:53.733] MulticoreFuture started
[10:19:53.733] - Launch lazy future ... done
[10:19:53.733] run() for ‘MulticoreFuture’ ... done
[10:19:53.734] Created future:
[10:19:53.734] plan(): Setting new future strategy stack:
[10:19:53.735] List of future strategies:
[10:19:53.735] 1. sequential:
[10:19:53.735]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.735]    - tweaked: FALSE
[10:19:53.735]    - call: NULL
[10:19:53.735] plan(): nbrOfWorkers() = 1
[10:19:53.738] plan(): Setting new future strategy stack:
[10:19:53.738] List of future strategies:
[10:19:53.738] 1. multicore:
[10:19:53.738]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.738]    - tweaked: FALSE
[10:19:53.738]    - call: plan(strategy)
[10:19:53.741] plan(): nbrOfWorkers() = 2
[10:19:53.734] MulticoreFuture:
[10:19:53.734] Label: ‘future_vapply-2’
[10:19:53.734] Expression:
[10:19:53.734] {
[10:19:53.734]     do.call(function(...) {
[10:19:53.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.734]             on.exit(options(oopts), add = TRUE)
[10:19:53.734]         }
[10:19:53.734]         {
[10:19:53.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.734]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.734]             })
[10:19:53.734]         }
[10:19:53.734]     }, args = future.call.arguments)
[10:19:53.734] }
[10:19:53.734] Lazy evaluation: FALSE
[10:19:53.734] Asynchronous evaluation: TRUE
[10:19:53.734] Local evaluation: TRUE
[10:19:53.734] Environment: R_GlobalEnv
[10:19:53.734] Capture standard output: TRUE
[10:19:53.734] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.734] Globals: 11 objects totaling 12.17 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.734] Packages: 1 packages (‘future.apply’)
[10:19:53.734] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.734] Resolved: TRUE
[10:19:53.734] Value: <not collected>
[10:19:53.734] Conditions captured: <none>
[10:19:53.734] Early signaling: FALSE
[10:19:53.734] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.734] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.742] Chunk #2 of 2 ... DONE
[10:19:53.742] Launching 2 futures (chunks) ... DONE
[10:19:53.742] Resolving 2 futures (chunks) ...
[10:19:53.743] resolve() on list ...
[10:19:53.743]  recursive: 0
[10:19:53.743]  length: 2
[10:19:53.743] 
[10:19:53.743] Future #1
[10:19:53.743] result() for MulticoreFuture ...
[10:19:53.744] result() for MulticoreFuture ...
[10:19:53.744] result() for MulticoreFuture ... done
[10:19:53.745] result() for MulticoreFuture ... done
[10:19:53.745] result() for MulticoreFuture ...
[10:19:53.745] result() for MulticoreFuture ... done
[10:19:53.745] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:53.745] - nx: 2
[10:19:53.745] - relay: TRUE
[10:19:53.745] - stdout: TRUE
[10:19:53.746] - signal: TRUE
[10:19:53.746] - resignal: FALSE
[10:19:53.746] - force: TRUE
[10:19:53.746] - relayed: [n=2] FALSE, FALSE
[10:19:53.746] - queued futures: [n=2] FALSE, FALSE
[10:19:53.746]  - until=1
[10:19:53.746]  - relaying element #1
[10:19:53.746] result() for MulticoreFuture ...
[10:19:53.747] result() for MulticoreFuture ... done
[10:19:53.747] result() for MulticoreFuture ...
[10:19:53.747] result() for MulticoreFuture ... done
[10:19:53.747] result() for MulticoreFuture ...
[10:19:53.751] result() for MulticoreFuture ... done
[10:19:53.751] result() for MulticoreFuture ...
[10:19:53.752] result() for MulticoreFuture ... done
[10:19:53.752] - relayed: [n=2] TRUE, FALSE
[10:19:53.752] - queued futures: [n=2] TRUE, FALSE
[10:19:53.753] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:53.753]  length: 1 (resolved future 1)
[10:19:53.754] Future #2
[10:19:53.754] result() for MulticoreFuture ...
[10:19:53.755] result() for MulticoreFuture ...
[10:19:53.756] result() for MulticoreFuture ... done
[10:19:53.756] result() for MulticoreFuture ... done
[10:19:53.756] result() for MulticoreFuture ...
[10:19:53.756] result() for MulticoreFuture ... done
[10:19:53.757] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:53.757] - nx: 2
[10:19:53.757] - relay: TRUE
[10:19:53.757] - stdout: TRUE
[10:19:53.757] - signal: TRUE
[10:19:53.757] - resignal: FALSE
[10:19:53.757] - force: TRUE
[10:19:53.758] - relayed: [n=2] TRUE, FALSE
[10:19:53.758] - queued futures: [n=2] TRUE, FALSE
[10:19:53.758]  - until=2
[10:19:53.758]  - relaying element #2
[10:19:53.758] result() for MulticoreFuture ...
[10:19:53.758] result() for MulticoreFuture ... done
[10:19:53.759] result() for MulticoreFuture ...
[10:19:53.759] result() for MulticoreFuture ... done
[10:19:53.759] result() for MulticoreFuture ...
[10:19:53.759] result() for MulticoreFuture ... done
[10:19:53.759] result() for MulticoreFuture ...
[10:19:53.759] result() for MulticoreFuture ... done
[10:19:53.759] - relayed: [n=2] TRUE, TRUE
[10:19:53.760] - queued futures: [n=2] TRUE, TRUE
[10:19:53.760] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:53.760]  length: 0 (resolved future 2)
[10:19:53.760] Relaying remaining futures
[10:19:53.760] signalConditionsASAP(NULL, pos=0) ...
[10:19:53.760] - nx: 2
[10:19:53.760] - relay: TRUE
[10:19:53.761] - stdout: TRUE
[10:19:53.761] - signal: TRUE
[10:19:53.761] - resignal: FALSE
[10:19:53.761] - force: TRUE
[10:19:53.761] - relayed: [n=2] TRUE, TRUE
[10:19:53.761] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:53.761] - relayed: [n=2] TRUE, TRUE
[10:19:53.762] - queued futures: [n=2] TRUE, TRUE
[10:19:53.762] signalConditionsASAP(NULL, pos=0) ... done
[10:19:53.762] resolve() on list ... DONE
[10:19:53.762] result() for MulticoreFuture ...
[10:19:53.762] result() for MulticoreFuture ... done
[10:19:53.762] result() for MulticoreFuture ...
[10:19:53.762] result() for MulticoreFuture ... done
[10:19:53.763] result() for MulticoreFuture ...
[10:19:53.763] result() for MulticoreFuture ... done
[10:19:53.763] result() for MulticoreFuture ...
[10:19:53.763] result() for MulticoreFuture ... done
[10:19:53.763]  - Number of value chunks collected: 2
[10:19:53.763] Resolving 2 futures (chunks) ... DONE
[10:19:53.763] Reducing values from 2 chunks ...
[10:19:53.764]  - Number of values collected after concatenation: 3
[10:19:53.764]  - Number of values expected: 3
[10:19:53.764] Reducing values from 2 chunks ... DONE
[10:19:53.764] future_lapply() ... DONE
- exceptions ...
[10:19:53.764] future_lapply() ...
[10:19:53.768] Number of chunks: 2
[10:19:53.768] getGlobalsAndPackagesXApply() ...
[10:19:53.768]  - future.globals: TRUE
[10:19:53.768] getGlobalsAndPackages() ...
[10:19:53.769] Searching for globals...
[10:19:53.772] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:53.772] Searching for globals ... DONE
[10:19:53.772] Resolving globals: FALSE
[10:19:53.773] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[10:19:53.774] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:53.774] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.774] - packages: [1] ‘future.apply’
[10:19:53.774] getGlobalsAndPackages() ... DONE
[10:19:53.774]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:53.774]  - needed namespaces: [n=1] ‘future.apply’
[10:19:53.774] Finding globals ... DONE
[10:19:53.774]  - use_args: TRUE
[10:19:53.775]  - Getting '...' globals ...
[10:19:53.775] resolve() on list ...
[10:19:53.775]  recursive: 0
[10:19:53.775]  length: 1
[10:19:53.775]  elements: ‘...’
[10:19:53.775]  length: 0 (resolved future 1)
[10:19:53.775] resolve() on list ... DONE
[10:19:53.775]    - '...' content: [n=0] 
[10:19:53.776] List of 1
[10:19:53.776]  $ ...: list()
[10:19:53.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.776]  - attr(*, "where")=List of 1
[10:19:53.776]   ..$ ...:<environment: 0x55c69f0754a0> 
[10:19:53.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.776]  - attr(*, "resolved")= logi TRUE
[10:19:53.776]  - attr(*, "total_size")= num NA
[10:19:53.781]  - Getting '...' globals ... DONE
[10:19:53.781] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:53.781] List of 8
[10:19:53.781]  $ ...future.FUN:function (x, ...)  
[10:19:53.781]  $ x_FUN        :function (x)  
[10:19:53.781]  $ times        : int 2
[10:19:53.781]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.781]  $ stop_if_not  :function (...)  
[10:19:53.781]  $ dim          : NULL
[10:19:53.781]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:53.781]  $ ...          : list()
[10:19:53.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.781]  - attr(*, "where")=List of 8
[10:19:53.781]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:53.781]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:53.781]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:53.781]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:53.781]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:53.781]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:53.781]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:53.781]   ..$ ...          :<environment: 0x55c69f0754a0> 
[10:19:53.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.781]  - attr(*, "resolved")= logi FALSE
[10:19:53.781]  - attr(*, "total_size")= num 23676
[10:19:53.787] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:53.787] getGlobalsAndPackagesXApply() ... DONE
[10:19:53.787] Number of futures (= number of chunks): 2
[10:19:53.787] Launching 2 futures (chunks) ...
[10:19:53.787] Chunk #1 of 2 ...
[10:19:53.787]  - Finding globals in 'X' for chunk #1 ...
[10:19:53.787] getGlobalsAndPackages() ...
[10:19:53.788] Searching for globals...
[10:19:53.788] 
[10:19:53.788] Searching for globals ... DONE
[10:19:53.788] - globals: [0] <none>
[10:19:53.788] getGlobalsAndPackages() ... DONE
[10:19:53.788]    + additional globals found: [n=0] 
[10:19:53.788]    + additional namespaces needed: [n=0] 
[10:19:53.788]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:53.788]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.789]  - seeds: <none>
[10:19:53.789]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.789] getGlobalsAndPackages() ...
[10:19:53.789] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.789] Resolving globals: FALSE
[10:19:53.789] Tweak future expression to call with '...' arguments ...
[10:19:53.789] {
[10:19:53.789]     do.call(function(...) {
[10:19:53.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.789]             on.exit(options(oopts), add = TRUE)
[10:19:53.789]         }
[10:19:53.789]         {
[10:19:53.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.789]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.789]             })
[10:19:53.789]         }
[10:19:53.789]     }, args = future.call.arguments)
[10:19:53.789] }
[10:19:53.789] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.790] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.790] - packages: [1] ‘future.apply’
[10:19:53.790] getGlobalsAndPackages() ... DONE
[10:19:53.790] run() for ‘Future’ ...
[10:19:53.791] - state: ‘created’
[10:19:53.791] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.792] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.793]   - Field: ‘label’
[10:19:53.793]   - Field: ‘local’
[10:19:53.793]   - Field: ‘owner’
[10:19:53.793]   - Field: ‘envir’
[10:19:53.793]   - Field: ‘workers’
[10:19:53.793]   - Field: ‘packages’
[10:19:53.793]   - Field: ‘gc’
[10:19:53.793]   - Field: ‘job’
[10:19:53.793]   - Field: ‘conditions’
[10:19:53.793]   - Field: ‘expr’
[10:19:53.793]   - Field: ‘uuid’
[10:19:53.794]   - Field: ‘seed’
[10:19:53.794]   - Field: ‘version’
[10:19:53.794]   - Field: ‘result’
[10:19:53.794]   - Field: ‘asynchronous’
[10:19:53.794]   - Field: ‘calls’
[10:19:53.794]   - Field: ‘globals’
[10:19:53.794]   - Field: ‘stdout’
[10:19:53.794]   - Field: ‘earlySignal’
[10:19:53.794]   - Field: ‘lazy’
[10:19:53.794]   - Field: ‘state’
[10:19:53.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.795] - Launch lazy future ...
[10:19:53.795] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.795] Packages needed by future strategies (n = 0): <none>
[10:19:53.795] {
[10:19:53.795]     {
[10:19:53.795]         {
[10:19:53.795]             ...future.startTime <- base::Sys.time()
[10:19:53.795]             {
[10:19:53.795]                 {
[10:19:53.795]                   {
[10:19:53.795]                     {
[10:19:53.795]                       {
[10:19:53.795]                         base::local({
[10:19:53.795]                           has_future <- base::requireNamespace("future", 
[10:19:53.795]                             quietly = TRUE)
[10:19:53.795]                           if (has_future) {
[10:19:53.795]                             ns <- base::getNamespace("future")
[10:19:53.795]                             version <- ns[[".package"]][["version"]]
[10:19:53.795]                             if (is.null(version)) 
[10:19:53.795]                               version <- utils::packageVersion("future")
[10:19:53.795]                           }
[10:19:53.795]                           else {
[10:19:53.795]                             version <- NULL
[10:19:53.795]                           }
[10:19:53.795]                           if (!has_future || version < "1.8.0") {
[10:19:53.795]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.795]                               "", base::R.version$version.string), 
[10:19:53.795]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.795]                                 base::R.version$platform, 8 * 
[10:19:53.795]                                   base::.Machine$sizeof.pointer), 
[10:19:53.795]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.795]                                 "release", "version")], collapse = " "), 
[10:19:53.795]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.795]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.795]                               info)
[10:19:53.795]                             info <- base::paste(info, collapse = "; ")
[10:19:53.795]                             if (!has_future) {
[10:19:53.795]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.795]                                 info)
[10:19:53.795]                             }
[10:19:53.795]                             else {
[10:19:53.795]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.795]                                 info, version)
[10:19:53.795]                             }
[10:19:53.795]                             base::stop(msg)
[10:19:53.795]                           }
[10:19:53.795]                         })
[10:19:53.795]                       }
[10:19:53.795]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.795]                       base::options(mc.cores = 1L)
[10:19:53.795]                     }
[10:19:53.795]                     base::local({
[10:19:53.795]                       for (pkg in "future.apply") {
[10:19:53.795]                         base::loadNamespace(pkg)
[10:19:53.795]                         base::library(pkg, character.only = TRUE)
[10:19:53.795]                       }
[10:19:53.795]                     })
[10:19:53.795]                   }
[10:19:53.795]                   ...future.strategy.old <- future::plan("list")
[10:19:53.795]                   options(future.plan = NULL)
[10:19:53.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.795]                 }
[10:19:53.795]                 ...future.workdir <- getwd()
[10:19:53.795]             }
[10:19:53.795]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.795]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.795]         }
[10:19:53.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.795]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.795]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.795]             base::names(...future.oldOptions))
[10:19:53.795]     }
[10:19:53.795]     if (FALSE) {
[10:19:53.795]     }
[10:19:53.795]     else {
[10:19:53.795]         if (TRUE) {
[10:19:53.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.795]                 open = "w")
[10:19:53.795]         }
[10:19:53.795]         else {
[10:19:53.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.795]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.795]         }
[10:19:53.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.795]             base::sink(type = "output", split = FALSE)
[10:19:53.795]             base::close(...future.stdout)
[10:19:53.795]         }, add = TRUE)
[10:19:53.795]     }
[10:19:53.795]     ...future.frame <- base::sys.nframe()
[10:19:53.795]     ...future.conditions <- base::list()
[10:19:53.795]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.795]     if (FALSE) {
[10:19:53.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.795]     }
[10:19:53.795]     ...future.result <- base::tryCatch({
[10:19:53.795]         base::withCallingHandlers({
[10:19:53.795]             ...future.value <- base::withVisible(base::local({
[10:19:53.795]                 withCallingHandlers({
[10:19:53.795]                   {
[10:19:53.795]                     do.call(function(...) {
[10:19:53.795]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.795]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.795]                         ...future.globals.maxSize)) {
[10:19:53.795]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.795]                         on.exit(options(oopts), add = TRUE)
[10:19:53.795]                       }
[10:19:53.795]                       {
[10:19:53.795]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.795]                           FUN = function(jj) {
[10:19:53.795]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.795]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.795]                           })
[10:19:53.795]                       }
[10:19:53.795]                     }, args = future.call.arguments)
[10:19:53.795]                   }
[10:19:53.795]                 }, immediateCondition = function(cond) {
[10:19:53.795]                   save_rds <- function (object, pathname, ...) 
[10:19:53.795]                   {
[10:19:53.795]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.795]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.795]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.795]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.795]                         fi_tmp[["mtime"]])
[10:19:53.795]                     }
[10:19:53.795]                     tryCatch({
[10:19:53.795]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.795]                     }, error = function(ex) {
[10:19:53.795]                       msg <- conditionMessage(ex)
[10:19:53.795]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.795]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.795]                         fi_tmp[["mtime"]], msg)
[10:19:53.795]                       ex$message <- msg
[10:19:53.795]                       stop(ex)
[10:19:53.795]                     })
[10:19:53.795]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.795]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.795]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.795]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.795]                       fi <- file.info(pathname)
[10:19:53.795]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.795]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.795]                         fi[["size"]], fi[["mtime"]])
[10:19:53.795]                       stop(msg)
[10:19:53.795]                     }
[10:19:53.795]                     invisible(pathname)
[10:19:53.795]                   }
[10:19:53.795]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.795]                     rootPath = tempdir()) 
[10:19:53.795]                   {
[10:19:53.795]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.795]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.795]                       tmpdir = path, fileext = ".rds")
[10:19:53.795]                     save_rds(obj, file)
[10:19:53.795]                   }
[10:19:53.795]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.795]                   {
[10:19:53.795]                     inherits <- base::inherits
[10:19:53.795]                     invokeRestart <- base::invokeRestart
[10:19:53.795]                     is.null <- base::is.null
[10:19:53.795]                     muffled <- FALSE
[10:19:53.795]                     if (inherits(cond, "message")) {
[10:19:53.795]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.795]                       if (muffled) 
[10:19:53.795]                         invokeRestart("muffleMessage")
[10:19:53.795]                     }
[10:19:53.795]                     else if (inherits(cond, "warning")) {
[10:19:53.795]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.795]                       if (muffled) 
[10:19:53.795]                         invokeRestart("muffleWarning")
[10:19:53.795]                     }
[10:19:53.795]                     else if (inherits(cond, "condition")) {
[10:19:53.795]                       if (!is.null(pattern)) {
[10:19:53.795]                         computeRestarts <- base::computeRestarts
[10:19:53.795]                         grepl <- base::grepl
[10:19:53.795]                         restarts <- computeRestarts(cond)
[10:19:53.795]                         for (restart in restarts) {
[10:19:53.795]                           name <- restart$name
[10:19:53.795]                           if (is.null(name)) 
[10:19:53.795]                             next
[10:19:53.795]                           if (!grepl(pattern, name)) 
[10:19:53.795]                             next
[10:19:53.795]                           invokeRestart(restart)
[10:19:53.795]                           muffled <- TRUE
[10:19:53.795]                           break
[10:19:53.795]                         }
[10:19:53.795]                       }
[10:19:53.795]                     }
[10:19:53.795]                     invisible(muffled)
[10:19:53.795]                   }
[10:19:53.795]                   muffleCondition(cond)
[10:19:53.795]                 })
[10:19:53.795]             }))
[10:19:53.795]             future::FutureResult(value = ...future.value$value, 
[10:19:53.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.795]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.795]                     ...future.globalenv.names))
[10:19:53.795]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.795]         }, condition = base::local({
[10:19:53.795]             c <- base::c
[10:19:53.795]             inherits <- base::inherits
[10:19:53.795]             invokeRestart <- base::invokeRestart
[10:19:53.795]             length <- base::length
[10:19:53.795]             list <- base::list
[10:19:53.795]             seq.int <- base::seq.int
[10:19:53.795]             signalCondition <- base::signalCondition
[10:19:53.795]             sys.calls <- base::sys.calls
[10:19:53.795]             `[[` <- base::`[[`
[10:19:53.795]             `+` <- base::`+`
[10:19:53.795]             `<<-` <- base::`<<-`
[10:19:53.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.795]                   3L)]
[10:19:53.795]             }
[10:19:53.795]             function(cond) {
[10:19:53.795]                 is_error <- inherits(cond, "error")
[10:19:53.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.795]                   NULL)
[10:19:53.795]                 if (is_error) {
[10:19:53.795]                   sessionInformation <- function() {
[10:19:53.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.795]                       search = base::search(), system = base::Sys.info())
[10:19:53.795]                   }
[10:19:53.795]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.795]                     cond$call), session = sessionInformation(), 
[10:19:53.795]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.795]                   signalCondition(cond)
[10:19:53.795]                 }
[10:19:53.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.795]                 "immediateCondition"))) {
[10:19:53.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.795]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.795]                   if (TRUE && !signal) {
[10:19:53.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.795]                     {
[10:19:53.795]                       inherits <- base::inherits
[10:19:53.795]                       invokeRestart <- base::invokeRestart
[10:19:53.795]                       is.null <- base::is.null
[10:19:53.795]                       muffled <- FALSE
[10:19:53.795]                       if (inherits(cond, "message")) {
[10:19:53.795]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.795]                         if (muffled) 
[10:19:53.795]                           invokeRestart("muffleMessage")
[10:19:53.795]                       }
[10:19:53.795]                       else if (inherits(cond, "warning")) {
[10:19:53.795]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.795]                         if (muffled) 
[10:19:53.795]                           invokeRestart("muffleWarning")
[10:19:53.795]                       }
[10:19:53.795]                       else if (inherits(cond, "condition")) {
[10:19:53.795]                         if (!is.null(pattern)) {
[10:19:53.795]                           computeRestarts <- base::computeRestarts
[10:19:53.795]                           grepl <- base::grepl
[10:19:53.795]                           restarts <- computeRestarts(cond)
[10:19:53.795]                           for (restart in restarts) {
[10:19:53.795]                             name <- restart$name
[10:19:53.795]                             if (is.null(name)) 
[10:19:53.795]                               next
[10:19:53.795]                             if (!grepl(pattern, name)) 
[10:19:53.795]                               next
[10:19:53.795]                             invokeRestart(restart)
[10:19:53.795]                             muffled <- TRUE
[10:19:53.795]                             break
[10:19:53.795]                           }
[10:19:53.795]                         }
[10:19:53.795]                       }
[10:19:53.795]                       invisible(muffled)
[10:19:53.795]                     }
[10:19:53.795]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.795]                   }
[10:19:53.795]                 }
[10:19:53.795]                 else {
[10:19:53.795]                   if (TRUE) {
[10:19:53.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.795]                     {
[10:19:53.795]                       inherits <- base::inherits
[10:19:53.795]                       invokeRestart <- base::invokeRestart
[10:19:53.795]                       is.null <- base::is.null
[10:19:53.795]                       muffled <- FALSE
[10:19:53.795]                       if (inherits(cond, "message")) {
[10:19:53.795]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.795]                         if (muffled) 
[10:19:53.795]                           invokeRestart("muffleMessage")
[10:19:53.795]                       }
[10:19:53.795]                       else if (inherits(cond, "warning")) {
[10:19:53.795]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.795]                         if (muffled) 
[10:19:53.795]                           invokeRestart("muffleWarning")
[10:19:53.795]                       }
[10:19:53.795]                       else if (inherits(cond, "condition")) {
[10:19:53.795]                         if (!is.null(pattern)) {
[10:19:53.795]                           computeRestarts <- base::computeRestarts
[10:19:53.795]                           grepl <- base::grepl
[10:19:53.795]                           restarts <- computeRestarts(cond)
[10:19:53.795]                           for (restart in restarts) {
[10:19:53.795]                             name <- restart$name
[10:19:53.795]                             if (is.null(name)) 
[10:19:53.795]                               next
[10:19:53.795]                             if (!grepl(pattern, name)) 
[10:19:53.795]                               next
[10:19:53.795]                             invokeRestart(restart)
[10:19:53.795]                             muffled <- TRUE
[10:19:53.795]                             break
[10:19:53.795]                           }
[10:19:53.795]                         }
[10:19:53.795]                       }
[10:19:53.795]                       invisible(muffled)
[10:19:53.795]                     }
[10:19:53.795]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.795]                   }
[10:19:53.795]                 }
[10:19:53.795]             }
[10:19:53.795]         }))
[10:19:53.795]     }, error = function(ex) {
[10:19:53.795]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.795]                 ...future.rng), started = ...future.startTime, 
[10:19:53.795]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.795]             version = "1.8"), class = "FutureResult")
[10:19:53.795]     }, finally = {
[10:19:53.795]         if (!identical(...future.workdir, getwd())) 
[10:19:53.795]             setwd(...future.workdir)
[10:19:53.795]         {
[10:19:53.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.795]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.795]             }
[10:19:53.795]             base::options(...future.oldOptions)
[10:19:53.795]             if (.Platform$OS.type == "windows") {
[10:19:53.795]                 old_names <- names(...future.oldEnvVars)
[10:19:53.795]                 envs <- base::Sys.getenv()
[10:19:53.795]                 names <- names(envs)
[10:19:53.795]                 common <- intersect(names, old_names)
[10:19:53.795]                 added <- setdiff(names, old_names)
[10:19:53.795]                 removed <- setdiff(old_names, names)
[10:19:53.795]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.795]                   envs[common]]
[10:19:53.795]                 NAMES <- toupper(changed)
[10:19:53.795]                 args <- list()
[10:19:53.795]                 for (kk in seq_along(NAMES)) {
[10:19:53.795]                   name <- changed[[kk]]
[10:19:53.795]                   NAME <- NAMES[[kk]]
[10:19:53.795]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.795]                     next
[10:19:53.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.795]                 }
[10:19:53.795]                 NAMES <- toupper(added)
[10:19:53.795]                 for (kk in seq_along(NAMES)) {
[10:19:53.795]                   name <- added[[kk]]
[10:19:53.795]                   NAME <- NAMES[[kk]]
[10:19:53.795]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.795]                     next
[10:19:53.795]                   args[[name]] <- ""
[10:19:53.795]                 }
[10:19:53.795]                 NAMES <- toupper(removed)
[10:19:53.795]                 for (kk in seq_along(NAMES)) {
[10:19:53.795]                   name <- removed[[kk]]
[10:19:53.795]                   NAME <- NAMES[[kk]]
[10:19:53.795]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.795]                     next
[10:19:53.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.795]                 }
[10:19:53.795]                 if (length(args) > 0) 
[10:19:53.795]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.795]             }
[10:19:53.795]             else {
[10:19:53.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.795]             }
[10:19:53.795]             {
[10:19:53.795]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.795]                   0L) {
[10:19:53.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.795]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.795]                   base::options(opts)
[10:19:53.795]                 }
[10:19:53.795]                 {
[10:19:53.795]                   {
[10:19:53.795]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.795]                     NULL
[10:19:53.795]                   }
[10:19:53.795]                   options(future.plan = NULL)
[10:19:53.795]                   if (is.na(NA_character_)) 
[10:19:53.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.795]                     .init = FALSE)
[10:19:53.795]                 }
[10:19:53.795]             }
[10:19:53.795]         }
[10:19:53.795]     })
[10:19:53.795]     if (TRUE) {
[10:19:53.795]         base::sink(type = "output", split = FALSE)
[10:19:53.795]         if (TRUE) {
[10:19:53.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.795]         }
[10:19:53.795]         else {
[10:19:53.795]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.795]         }
[10:19:53.795]         base::close(...future.stdout)
[10:19:53.795]         ...future.stdout <- NULL
[10:19:53.795]     }
[10:19:53.795]     ...future.result$conditions <- ...future.conditions
[10:19:53.795]     ...future.result$finished <- base::Sys.time()
[10:19:53.795]     ...future.result
[10:19:53.795] }
[10:19:53.798] assign_globals() ...
[10:19:53.798] List of 11
[10:19:53.798]  $ ...future.FUN            :function (x, ...)  
[10:19:53.798]  $ x_FUN                    :function (x)  
[10:19:53.798]  $ times                    : int 2
[10:19:53.798]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.798]  $ stop_if_not              :function (...)  
[10:19:53.798]  $ dim                      : NULL
[10:19:53.798]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:53.798]  $ future.call.arguments    : list()
[10:19:53.798]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.798]  $ ...future.elements_ii    :List of 1
[10:19:53.798]   ..$ : int 1
[10:19:53.798]  $ ...future.seeds_ii       : NULL
[10:19:53.798]  $ ...future.globals.maxSize: NULL
[10:19:53.798]  - attr(*, "where")=List of 11
[10:19:53.798]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.798]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.798]  - attr(*, "resolved")= logi FALSE
[10:19:53.798]  - attr(*, "total_size")= num 23676
[10:19:53.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.798]  - attr(*, "already-done")= logi TRUE
[10:19:53.808] - copied ‘...future.FUN’ to environment
[10:19:53.808] - copied ‘x_FUN’ to environment
[10:19:53.808] - copied ‘times’ to environment
[10:19:53.808] - copied ‘stopf’ to environment
[10:19:53.808] - copied ‘stop_if_not’ to environment
[10:19:53.808] - copied ‘dim’ to environment
[10:19:53.808] - copied ‘valid_types’ to environment
[10:19:53.808] - copied ‘future.call.arguments’ to environment
[10:19:53.809] - copied ‘...future.elements_ii’ to environment
[10:19:53.809] - copied ‘...future.seeds_ii’ to environment
[10:19:53.809] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.809] assign_globals() ... done
[10:19:53.809] requestCore(): workers = 2
[10:19:53.811] MulticoreFuture started
[10:19:53.811] - Launch lazy future ... done
[10:19:53.812] run() for ‘MulticoreFuture’ ... done
[10:19:53.812] Created future:
[10:19:53.812] plan(): Setting new future strategy stack:
[10:19:53.813] List of future strategies:
[10:19:53.813] 1. sequential:
[10:19:53.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.813]    - tweaked: FALSE
[10:19:53.813]    - call: NULL
[10:19:53.814] plan(): nbrOfWorkers() = 1
[10:19:53.816] plan(): Setting new future strategy stack:
[10:19:53.816] List of future strategies:
[10:19:53.816] 1. multicore:
[10:19:53.816]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.816]    - tweaked: FALSE
[10:19:53.816]    - call: plan(strategy)
[10:19:53.820] plan(): nbrOfWorkers() = 2
[10:19:53.812] MulticoreFuture:
[10:19:53.812] Label: ‘future_vapply-1’
[10:19:53.812] Expression:
[10:19:53.812] {
[10:19:53.812]     do.call(function(...) {
[10:19:53.812]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.812]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.812]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.812]             on.exit(options(oopts), add = TRUE)
[10:19:53.812]         }
[10:19:53.812]         {
[10:19:53.812]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.812]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.812]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.812]             })
[10:19:53.812]         }
[10:19:53.812]     }, args = future.call.arguments)
[10:19:53.812] }
[10:19:53.812] Lazy evaluation: FALSE
[10:19:53.812] Asynchronous evaluation: TRUE
[10:19:53.812] Local evaluation: TRUE
[10:19:53.812] Environment: R_GlobalEnv
[10:19:53.812] Capture standard output: TRUE
[10:19:53.812] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.812] Globals: 11 objects totaling 13.00 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.812] Packages: 1 packages (‘future.apply’)
[10:19:53.812] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.812] Resolved: FALSE
[10:19:53.812] Value: <not collected>
[10:19:53.812] Conditions captured: <none>
[10:19:53.812] Early signaling: FALSE
[10:19:53.812] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.812] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.825] Chunk #1 of 2 ... DONE
[10:19:53.825] Chunk #2 of 2 ...
[10:19:53.826]  - Finding globals in 'X' for chunk #2 ...
[10:19:53.826] getGlobalsAndPackages() ...
[10:19:53.826] Searching for globals...
[10:19:53.826] 
[10:19:53.827] Searching for globals ... DONE
[10:19:53.827] - globals: [0] <none>
[10:19:53.827] getGlobalsAndPackages() ... DONE
[10:19:53.827]    + additional globals found: [n=0] 
[10:19:53.827]    + additional namespaces needed: [n=0] 
[10:19:53.827]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:53.827]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:53.827]  - seeds: <none>
[10:19:53.828]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.828] getGlobalsAndPackages() ...
[10:19:53.828] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.828] Resolving globals: FALSE
[10:19:53.828] Tweak future expression to call with '...' arguments ...
[10:19:53.828] {
[10:19:53.828]     do.call(function(...) {
[10:19:53.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.828]             on.exit(options(oopts), add = TRUE)
[10:19:53.828]         }
[10:19:53.828]         {
[10:19:53.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.828]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.828]             })
[10:19:53.828]         }
[10:19:53.828]     }, args = future.call.arguments)
[10:19:53.828] }
[10:19:53.829] Tweak future expression to call with '...' arguments ... DONE
[10:19:53.830] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:53.830] - packages: [1] ‘future.apply’
[10:19:53.830] getGlobalsAndPackages() ... DONE
[10:19:53.830] run() for ‘Future’ ...
[10:19:53.831] - state: ‘created’
[10:19:53.831] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:53.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:53.833]   - Field: ‘label’
[10:19:53.834]   - Field: ‘local’
[10:19:53.834]   - Field: ‘owner’
[10:19:53.834]   - Field: ‘envir’
[10:19:53.834]   - Field: ‘workers’
[10:19:53.834]   - Field: ‘packages’
[10:19:53.834]   - Field: ‘gc’
[10:19:53.834]   - Field: ‘job’
[10:19:53.835]   - Field: ‘conditions’
[10:19:53.835]   - Field: ‘expr’
[10:19:53.835]   - Field: ‘uuid’
[10:19:53.835]   - Field: ‘seed’
[10:19:53.835]   - Field: ‘version’
[10:19:53.835]   - Field: ‘result’
[10:19:53.835]   - Field: ‘asynchronous’
[10:19:53.836]   - Field: ‘calls’
[10:19:53.836]   - Field: ‘globals’
[10:19:53.836]   - Field: ‘stdout’
[10:19:53.836]   - Field: ‘earlySignal’
[10:19:53.836]   - Field: ‘lazy’
[10:19:53.836]   - Field: ‘state’
[10:19:53.836] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:53.837] - Launch lazy future ...
[10:19:53.837] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:53.837] Packages needed by future strategies (n = 0): <none>
[10:19:53.841] {
[10:19:53.841]     {
[10:19:53.841]         {
[10:19:53.841]             ...future.startTime <- base::Sys.time()
[10:19:53.841]             {
[10:19:53.841]                 {
[10:19:53.841]                   {
[10:19:53.841]                     {
[10:19:53.841]                       {
[10:19:53.841]                         base::local({
[10:19:53.841]                           has_future <- base::requireNamespace("future", 
[10:19:53.841]                             quietly = TRUE)
[10:19:53.841]                           if (has_future) {
[10:19:53.841]                             ns <- base::getNamespace("future")
[10:19:53.841]                             version <- ns[[".package"]][["version"]]
[10:19:53.841]                             if (is.null(version)) 
[10:19:53.841]                               version <- utils::packageVersion("future")
[10:19:53.841]                           }
[10:19:53.841]                           else {
[10:19:53.841]                             version <- NULL
[10:19:53.841]                           }
[10:19:53.841]                           if (!has_future || version < "1.8.0") {
[10:19:53.841]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:53.841]                               "", base::R.version$version.string), 
[10:19:53.841]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:53.841]                                 base::R.version$platform, 8 * 
[10:19:53.841]                                   base::.Machine$sizeof.pointer), 
[10:19:53.841]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:53.841]                                 "release", "version")], collapse = " "), 
[10:19:53.841]                               hostname = base::Sys.info()[["nodename"]])
[10:19:53.841]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:53.841]                               info)
[10:19:53.841]                             info <- base::paste(info, collapse = "; ")
[10:19:53.841]                             if (!has_future) {
[10:19:53.841]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:53.841]                                 info)
[10:19:53.841]                             }
[10:19:53.841]                             else {
[10:19:53.841]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:53.841]                                 info, version)
[10:19:53.841]                             }
[10:19:53.841]                             base::stop(msg)
[10:19:53.841]                           }
[10:19:53.841]                         })
[10:19:53.841]                       }
[10:19:53.841]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:53.841]                       base::options(mc.cores = 1L)
[10:19:53.841]                     }
[10:19:53.841]                     base::local({
[10:19:53.841]                       for (pkg in "future.apply") {
[10:19:53.841]                         base::loadNamespace(pkg)
[10:19:53.841]                         base::library(pkg, character.only = TRUE)
[10:19:53.841]                       }
[10:19:53.841]                     })
[10:19:53.841]                   }
[10:19:53.841]                   ...future.strategy.old <- future::plan("list")
[10:19:53.841]                   options(future.plan = NULL)
[10:19:53.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:53.841]                 }
[10:19:53.841]                 ...future.workdir <- getwd()
[10:19:53.841]             }
[10:19:53.841]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:53.841]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:53.841]         }
[10:19:53.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:53.841]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:53.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:53.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:53.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:53.841]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:53.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:53.841]             base::names(...future.oldOptions))
[10:19:53.841]     }
[10:19:53.841]     if (FALSE) {
[10:19:53.841]     }
[10:19:53.841]     else {
[10:19:53.841]         if (TRUE) {
[10:19:53.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:53.841]                 open = "w")
[10:19:53.841]         }
[10:19:53.841]         else {
[10:19:53.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:53.841]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:53.841]         }
[10:19:53.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:53.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:53.841]             base::sink(type = "output", split = FALSE)
[10:19:53.841]             base::close(...future.stdout)
[10:19:53.841]         }, add = TRUE)
[10:19:53.841]     }
[10:19:53.841]     ...future.frame <- base::sys.nframe()
[10:19:53.841]     ...future.conditions <- base::list()
[10:19:53.841]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:53.841]     if (FALSE) {
[10:19:53.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:53.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:53.841]     }
[10:19:53.841]     ...future.result <- base::tryCatch({
[10:19:53.841]         base::withCallingHandlers({
[10:19:53.841]             ...future.value <- base::withVisible(base::local({
[10:19:53.841]                 withCallingHandlers({
[10:19:53.841]                   {
[10:19:53.841]                     do.call(function(...) {
[10:19:53.841]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.841]                       if (!identical(...future.globals.maxSize.org, 
[10:19:53.841]                         ...future.globals.maxSize)) {
[10:19:53.841]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.841]                         on.exit(options(oopts), add = TRUE)
[10:19:53.841]                       }
[10:19:53.841]                       {
[10:19:53.841]                         lapply(seq_along(...future.elements_ii), 
[10:19:53.841]                           FUN = function(jj) {
[10:19:53.841]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.841]                             ...future.FUN(...future.X_jj, ...)
[10:19:53.841]                           })
[10:19:53.841]                       }
[10:19:53.841]                     }, args = future.call.arguments)
[10:19:53.841]                   }
[10:19:53.841]                 }, immediateCondition = function(cond) {
[10:19:53.841]                   save_rds <- function (object, pathname, ...) 
[10:19:53.841]                   {
[10:19:53.841]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:53.841]                     if (file_test("-f", pathname_tmp)) {
[10:19:53.841]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.841]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:53.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.841]                         fi_tmp[["mtime"]])
[10:19:53.841]                     }
[10:19:53.841]                     tryCatch({
[10:19:53.841]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:53.841]                     }, error = function(ex) {
[10:19:53.841]                       msg <- conditionMessage(ex)
[10:19:53.841]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.841]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:53.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.841]                         fi_tmp[["mtime"]], msg)
[10:19:53.841]                       ex$message <- msg
[10:19:53.841]                       stop(ex)
[10:19:53.841]                     })
[10:19:53.841]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:53.841]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:53.841]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:53.841]                       fi_tmp <- file.info(pathname_tmp)
[10:19:53.841]                       fi <- file.info(pathname)
[10:19:53.841]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:53.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:53.841]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:53.841]                         fi[["size"]], fi[["mtime"]])
[10:19:53.841]                       stop(msg)
[10:19:53.841]                     }
[10:19:53.841]                     invisible(pathname)
[10:19:53.841]                   }
[10:19:53.841]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:53.841]                     rootPath = tempdir()) 
[10:19:53.841]                   {
[10:19:53.841]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:53.841]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:53.841]                       tmpdir = path, fileext = ".rds")
[10:19:53.841]                     save_rds(obj, file)
[10:19:53.841]                   }
[10:19:53.841]                   saveImmediateCondition(cond, path = "/tmp/RtmpxsuDeL/.future/immediateConditions")
[10:19:53.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.841]                   {
[10:19:53.841]                     inherits <- base::inherits
[10:19:53.841]                     invokeRestart <- base::invokeRestart
[10:19:53.841]                     is.null <- base::is.null
[10:19:53.841]                     muffled <- FALSE
[10:19:53.841]                     if (inherits(cond, "message")) {
[10:19:53.841]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:53.841]                       if (muffled) 
[10:19:53.841]                         invokeRestart("muffleMessage")
[10:19:53.841]                     }
[10:19:53.841]                     else if (inherits(cond, "warning")) {
[10:19:53.841]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:53.841]                       if (muffled) 
[10:19:53.841]                         invokeRestart("muffleWarning")
[10:19:53.841]                     }
[10:19:53.841]                     else if (inherits(cond, "condition")) {
[10:19:53.841]                       if (!is.null(pattern)) {
[10:19:53.841]                         computeRestarts <- base::computeRestarts
[10:19:53.841]                         grepl <- base::grepl
[10:19:53.841]                         restarts <- computeRestarts(cond)
[10:19:53.841]                         for (restart in restarts) {
[10:19:53.841]                           name <- restart$name
[10:19:53.841]                           if (is.null(name)) 
[10:19:53.841]                             next
[10:19:53.841]                           if (!grepl(pattern, name)) 
[10:19:53.841]                             next
[10:19:53.841]                           invokeRestart(restart)
[10:19:53.841]                           muffled <- TRUE
[10:19:53.841]                           break
[10:19:53.841]                         }
[10:19:53.841]                       }
[10:19:53.841]                     }
[10:19:53.841]                     invisible(muffled)
[10:19:53.841]                   }
[10:19:53.841]                   muffleCondition(cond)
[10:19:53.841]                 })
[10:19:53.841]             }))
[10:19:53.841]             future::FutureResult(value = ...future.value$value, 
[10:19:53.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.841]                   ...future.rng), globalenv = if (FALSE) 
[10:19:53.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:53.841]                     ...future.globalenv.names))
[10:19:53.841]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:53.841]         }, condition = base::local({
[10:19:53.841]             c <- base::c
[10:19:53.841]             inherits <- base::inherits
[10:19:53.841]             invokeRestart <- base::invokeRestart
[10:19:53.841]             length <- base::length
[10:19:53.841]             list <- base::list
[10:19:53.841]             seq.int <- base::seq.int
[10:19:53.841]             signalCondition <- base::signalCondition
[10:19:53.841]             sys.calls <- base::sys.calls
[10:19:53.841]             `[[` <- base::`[[`
[10:19:53.841]             `+` <- base::`+`
[10:19:53.841]             `<<-` <- base::`<<-`
[10:19:53.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:53.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:53.841]                   3L)]
[10:19:53.841]             }
[10:19:53.841]             function(cond) {
[10:19:53.841]                 is_error <- inherits(cond, "error")
[10:19:53.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:53.841]                   NULL)
[10:19:53.841]                 if (is_error) {
[10:19:53.841]                   sessionInformation <- function() {
[10:19:53.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:53.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:53.841]                       search = base::search(), system = base::Sys.info())
[10:19:53.841]                   }
[10:19:53.841]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:53.841]                     cond$call), session = sessionInformation(), 
[10:19:53.841]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:53.841]                   signalCondition(cond)
[10:19:53.841]                 }
[10:19:53.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:53.841]                 "immediateCondition"))) {
[10:19:53.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:53.841]                   ...future.conditions[[length(...future.conditions) + 
[10:19:53.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:53.841]                   if (TRUE && !signal) {
[10:19:53.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.841]                     {
[10:19:53.841]                       inherits <- base::inherits
[10:19:53.841]                       invokeRestart <- base::invokeRestart
[10:19:53.841]                       is.null <- base::is.null
[10:19:53.841]                       muffled <- FALSE
[10:19:53.841]                       if (inherits(cond, "message")) {
[10:19:53.841]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.841]                         if (muffled) 
[10:19:53.841]                           invokeRestart("muffleMessage")
[10:19:53.841]                       }
[10:19:53.841]                       else if (inherits(cond, "warning")) {
[10:19:53.841]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.841]                         if (muffled) 
[10:19:53.841]                           invokeRestart("muffleWarning")
[10:19:53.841]                       }
[10:19:53.841]                       else if (inherits(cond, "condition")) {
[10:19:53.841]                         if (!is.null(pattern)) {
[10:19:53.841]                           computeRestarts <- base::computeRestarts
[10:19:53.841]                           grepl <- base::grepl
[10:19:53.841]                           restarts <- computeRestarts(cond)
[10:19:53.841]                           for (restart in restarts) {
[10:19:53.841]                             name <- restart$name
[10:19:53.841]                             if (is.null(name)) 
[10:19:53.841]                               next
[10:19:53.841]                             if (!grepl(pattern, name)) 
[10:19:53.841]                               next
[10:19:53.841]                             invokeRestart(restart)
[10:19:53.841]                             muffled <- TRUE
[10:19:53.841]                             break
[10:19:53.841]                           }
[10:19:53.841]                         }
[10:19:53.841]                       }
[10:19:53.841]                       invisible(muffled)
[10:19:53.841]                     }
[10:19:53.841]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.841]                   }
[10:19:53.841]                 }
[10:19:53.841]                 else {
[10:19:53.841]                   if (TRUE) {
[10:19:53.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:53.841]                     {
[10:19:53.841]                       inherits <- base::inherits
[10:19:53.841]                       invokeRestart <- base::invokeRestart
[10:19:53.841]                       is.null <- base::is.null
[10:19:53.841]                       muffled <- FALSE
[10:19:53.841]                       if (inherits(cond, "message")) {
[10:19:53.841]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:53.841]                         if (muffled) 
[10:19:53.841]                           invokeRestart("muffleMessage")
[10:19:53.841]                       }
[10:19:53.841]                       else if (inherits(cond, "warning")) {
[10:19:53.841]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:53.841]                         if (muffled) 
[10:19:53.841]                           invokeRestart("muffleWarning")
[10:19:53.841]                       }
[10:19:53.841]                       else if (inherits(cond, "condition")) {
[10:19:53.841]                         if (!is.null(pattern)) {
[10:19:53.841]                           computeRestarts <- base::computeRestarts
[10:19:53.841]                           grepl <- base::grepl
[10:19:53.841]                           restarts <- computeRestarts(cond)
[10:19:53.841]                           for (restart in restarts) {
[10:19:53.841]                             name <- restart$name
[10:19:53.841]                             if (is.null(name)) 
[10:19:53.841]                               next
[10:19:53.841]                             if (!grepl(pattern, name)) 
[10:19:53.841]                               next
[10:19:53.841]                             invokeRestart(restart)
[10:19:53.841]                             muffled <- TRUE
[10:19:53.841]                             break
[10:19:53.841]                           }
[10:19:53.841]                         }
[10:19:53.841]                       }
[10:19:53.841]                       invisible(muffled)
[10:19:53.841]                     }
[10:19:53.841]                     muffleCondition(cond, pattern = "^muffle")
[10:19:53.841]                   }
[10:19:53.841]                 }
[10:19:53.841]             }
[10:19:53.841]         }))
[10:19:53.841]     }, error = function(ex) {
[10:19:53.841]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:53.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:53.841]                 ...future.rng), started = ...future.startTime, 
[10:19:53.841]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:53.841]             version = "1.8"), class = "FutureResult")
[10:19:53.841]     }, finally = {
[10:19:53.841]         if (!identical(...future.workdir, getwd())) 
[10:19:53.841]             setwd(...future.workdir)
[10:19:53.841]         {
[10:19:53.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:53.841]                 ...future.oldOptions$nwarnings <- NULL
[10:19:53.841]             }
[10:19:53.841]             base::options(...future.oldOptions)
[10:19:53.841]             if (.Platform$OS.type == "windows") {
[10:19:53.841]                 old_names <- names(...future.oldEnvVars)
[10:19:53.841]                 envs <- base::Sys.getenv()
[10:19:53.841]                 names <- names(envs)
[10:19:53.841]                 common <- intersect(names, old_names)
[10:19:53.841]                 added <- setdiff(names, old_names)
[10:19:53.841]                 removed <- setdiff(old_names, names)
[10:19:53.841]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:53.841]                   envs[common]]
[10:19:53.841]                 NAMES <- toupper(changed)
[10:19:53.841]                 args <- list()
[10:19:53.841]                 for (kk in seq_along(NAMES)) {
[10:19:53.841]                   name <- changed[[kk]]
[10:19:53.841]                   NAME <- NAMES[[kk]]
[10:19:53.841]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.841]                     next
[10:19:53.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.841]                 }
[10:19:53.841]                 NAMES <- toupper(added)
[10:19:53.841]                 for (kk in seq_along(NAMES)) {
[10:19:53.841]                   name <- added[[kk]]
[10:19:53.841]                   NAME <- NAMES[[kk]]
[10:19:53.841]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.841]                     next
[10:19:53.841]                   args[[name]] <- ""
[10:19:53.841]                 }
[10:19:53.841]                 NAMES <- toupper(removed)
[10:19:53.841]                 for (kk in seq_along(NAMES)) {
[10:19:53.841]                   name <- removed[[kk]]
[10:19:53.841]                   NAME <- NAMES[[kk]]
[10:19:53.841]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:53.841]                     next
[10:19:53.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:53.841]                 }
[10:19:53.841]                 if (length(args) > 0) 
[10:19:53.841]                   base::do.call(base::Sys.setenv, args = args)
[10:19:53.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:53.841]             }
[10:19:53.841]             else {
[10:19:53.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:53.841]             }
[10:19:53.841]             {
[10:19:53.841]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:53.841]                   0L) {
[10:19:53.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:53.841]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:53.841]                   base::options(opts)
[10:19:53.841]                 }
[10:19:53.841]                 {
[10:19:53.841]                   {
[10:19:53.841]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:53.841]                     NULL
[10:19:53.841]                   }
[10:19:53.841]                   options(future.plan = NULL)
[10:19:53.841]                   if (is.na(NA_character_)) 
[10:19:53.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:53.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:53.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:53.841]                     .init = FALSE)
[10:19:53.841]                 }
[10:19:53.841]             }
[10:19:53.841]         }
[10:19:53.841]     })
[10:19:53.841]     if (TRUE) {
[10:19:53.841]         base::sink(type = "output", split = FALSE)
[10:19:53.841]         if (TRUE) {
[10:19:53.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:53.841]         }
[10:19:53.841]         else {
[10:19:53.841]             ...future.result["stdout"] <- base::list(NULL)
[10:19:53.841]         }
[10:19:53.841]         base::close(...future.stdout)
[10:19:53.841]         ...future.stdout <- NULL
[10:19:53.841]     }
[10:19:53.841]     ...future.result$conditions <- ...future.conditions
[10:19:53.841]     ...future.result$finished <- base::Sys.time()
[10:19:53.841]     ...future.result
[10:19:53.841] }
[10:19:53.845] assign_globals() ...
[10:19:53.845] List of 11
[10:19:53.845]  $ ...future.FUN            :function (x, ...)  
[10:19:53.845]  $ x_FUN                    :function (x)  
[10:19:53.845]  $ times                    : int 2
[10:19:53.845]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:53.845]  $ stop_if_not              :function (...)  
[10:19:53.845]  $ dim                      : NULL
[10:19:53.845]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:19:53.845]  $ future.call.arguments    : list()
[10:19:53.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:53.845]  $ ...future.elements_ii    :List of 2
[10:19:53.845]   ..$ : int 2
[10:19:53.845]   ..$ : int 3
[10:19:53.845]  $ ...future.seeds_ii       : NULL
[10:19:53.845]  $ ...future.globals.maxSize: NULL
[10:19:53.845]  - attr(*, "where")=List of 11
[10:19:53.845]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ times                    :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:53.845]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:53.845]  - attr(*, "resolved")= logi FALSE
[10:19:53.845]  - attr(*, "total_size")= num 23676
[10:19:53.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:53.845]  - attr(*, "already-done")= logi TRUE
[10:19:53.859] - copied ‘...future.FUN’ to environment
[10:19:53.859] - copied ‘x_FUN’ to environment
[10:19:53.860] - copied ‘times’ to environment
[10:19:53.860] - copied ‘stopf’ to environment
[10:19:53.860] - copied ‘stop_if_not’ to environment
[10:19:53.860] - copied ‘dim’ to environment
[10:19:53.860] - copied ‘valid_types’ to environment
[10:19:53.860] - copied ‘future.call.arguments’ to environment
[10:19:53.860] - copied ‘...future.elements_ii’ to environment
[10:19:53.861] - copied ‘...future.seeds_ii’ to environment
[10:19:53.861] - copied ‘...future.globals.maxSize’ to environment
[10:19:53.861] assign_globals() ... done
[10:19:53.861] requestCore(): workers = 2
[10:19:53.864] MulticoreFuture started
[10:19:53.865] - Launch lazy future ... done
[10:19:53.865] run() for ‘MulticoreFuture’ ... done
[10:19:53.866] Created future:
[10:19:53.866] plan(): Setting new future strategy stack:
[10:19:53.866] List of future strategies:
[10:19:53.866] 1. sequential:
[10:19:53.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.866]    - tweaked: FALSE
[10:19:53.866]    - call: NULL
[10:19:53.867] plan(): nbrOfWorkers() = 1
[10:19:53.869] plan(): Setting new future strategy stack:
[10:19:53.870] List of future strategies:
[10:19:53.870] 1. multicore:
[10:19:53.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:53.870]    - tweaked: FALSE
[10:19:53.870]    - call: plan(strategy)
[10:19:53.873] plan(): nbrOfWorkers() = 2
[10:19:53.866] MulticoreFuture:
[10:19:53.866] Label: ‘future_vapply-2’
[10:19:53.866] Expression:
[10:19:53.866] {
[10:19:53.866]     do.call(function(...) {
[10:19:53.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:53.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:53.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:53.866]             on.exit(options(oopts), add = TRUE)
[10:19:53.866]         }
[10:19:53.866]         {
[10:19:53.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:53.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:53.866]                 ...future.FUN(...future.X_jj, ...)
[10:19:53.866]             })
[10:19:53.866]         }
[10:19:53.866]     }, args = future.call.arguments)
[10:19:53.866] }
[10:19:53.866] Lazy evaluation: FALSE
[10:19:53.866] Asynchronous evaluation: TRUE
[10:19:53.866] Local evaluation: TRUE
[10:19:53.866] Environment: R_GlobalEnv
[10:19:53.866] Capture standard output: TRUE
[10:19:53.866] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:53.866] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:53.866] Packages: 1 packages (‘future.apply’)
[10:19:53.866] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:53.866] Resolved: FALSE
[10:19:53.866] Value: <not collected>
[10:19:53.866] Conditions captured: <none>
[10:19:53.866] Early signaling: FALSE
[10:19:53.866] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:53.866] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:53.879] Chunk #2 of 2 ... DONE
[10:19:53.879] Launching 2 futures (chunks) ... DONE
[10:19:53.879] Resolving 2 futures (chunks) ...
[10:19:53.879] resolve() on list ...
[10:19:53.879]  recursive: 0
[10:19:53.879]  length: 2
[10:19:53.880] 
[10:19:53.880] Future #1
[10:19:53.880] result() for MulticoreFuture ...
[10:19:53.892] result() for MulticoreFuture ...
[10:19:53.892] result() for MulticoreFuture ... done
[10:19:53.892] signalConditions() ...
[10:19:53.893]  - include = ‘immediateCondition’
[10:19:53.893]  - exclude = 
[10:19:53.893]  - resignal = FALSE
[10:19:53.893]  - Number of conditions: 1
[10:19:53.894] signalConditions() ... done
[10:19:53.894] result() for MulticoreFuture ... done
[10:19:53.894] result() for MulticoreFuture ...
[10:19:53.895] result() for MulticoreFuture ... done
[10:19:53.895] signalConditions() ...
[10:19:53.895]  - include = ‘immediateCondition’
[10:19:53.895]  - exclude = 
[10:19:53.895]  - resignal = FALSE
[10:19:53.896]  - Number of conditions: 1
[10:19:53.896] signalConditions() ... done
[10:19:53.896] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:53.896] - nx: 2
[10:19:53.897] - relay: TRUE
[10:19:53.897] - stdout: TRUE
[10:19:53.897] - signal: TRUE
[10:19:53.897] - resignal: FALSE
[10:19:53.897] - force: TRUE
[10:19:53.897] - relayed: [n=2] FALSE, FALSE
[10:19:53.897] - queued futures: [n=2] FALSE, FALSE
[10:19:53.898]  - until=1
[10:19:53.898]  - relaying element #1
[10:19:53.898] result() for MulticoreFuture ...
[10:19:53.898] result() for MulticoreFuture ... done
[10:19:53.898] result() for MulticoreFuture ...
[10:19:53.898] result() for MulticoreFuture ... done
[10:19:53.899] signalConditions() ...
[10:19:53.899]  - include = ‘immediateCondition’
[10:19:53.899]  - exclude = 
[10:19:53.899]  - resignal = FALSE
[10:19:53.899]  - Number of conditions: 1
[10:19:53.899] signalConditions() ... done
[10:19:53.900] result() for MulticoreFuture ...
[10:19:53.900] result() for MulticoreFuture ... done
[10:19:53.900] signalConditions() ...
[10:19:53.900]  - include = ‘immediateCondition’
[10:19:53.900]  - exclude = 
[10:19:53.900]  - resignal = FALSE
[10:19:53.901]  - Number of conditions: 1
[10:19:53.901] signalConditions() ... done
[10:19:53.901] result() for MulticoreFuture ...
[10:19:53.901] result() for MulticoreFuture ... done
[10:19:53.901] signalConditions() ...
[10:19:53.901]  - include = ‘condition’
[10:19:53.902]  - exclude = ‘immediateCondition’
[10:19:53.902]  - resignal = TRUE
[10:19:53.902]  - Number of conditions: 1
[10:19:53.902]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:19:53.902] signalConditions() ... done
[10:19:53.903] - relayed: [n=2] FALSE, FALSE
[10:19:53.903] - queued futures: [n=2] TRUE, FALSE
[10:19:53.903] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:53.903] plan(): Setting new future strategy stack:
[10:19:53.903] List of future strategies:
[10:19:53.903] 1. sequential:
[10:19:53.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:53.903]    - tweaked: FALSE
[10:19:53.903]    - call: plan(sequential)
[10:19:53.904] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:19:53.905] plan(): Setting new future strategy stack:
[10:19:53.905] List of future strategies:
[10:19:53.905] 1. multisession:
[10:19:53.905]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:19:53.905]    - tweaked: FALSE
[10:19:53.905]    - call: plan(strategy)
[10:19:53.905] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:19:53.905] multisession:
[10:19:53.905] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:19:53.905] - tweaked: FALSE
[10:19:53.905] - call: plan(strategy)
[10:19:53.910] getGlobalsAndPackages() ...
[10:19:53.910] Not searching for globals
[10:19:53.910] - globals: [0] <none>
[10:19:53.911] getGlobalsAndPackages() ... DONE
[10:19:54.401] Packages needed by the future expression (n = 0): <none>
[10:19:54.401] Packages needed by future strategies (n = 0): <none>
[10:19:54.402] {
[10:19:54.402]     {
[10:19:54.402]         {
[10:19:54.402]             ...future.startTime <- base::Sys.time()
[10:19:54.402]             {
[10:19:54.402]                 {
[10:19:54.402]                   {
[10:19:54.402]                     {
[10:19:54.402]                       base::local({
[10:19:54.402]                         has_future <- base::requireNamespace("future", 
[10:19:54.402]                           quietly = TRUE)
[10:19:54.402]                         if (has_future) {
[10:19:54.402]                           ns <- base::getNamespace("future")
[10:19:54.402]                           version <- ns[[".package"]][["version"]]
[10:19:54.402]                           if (is.null(version)) 
[10:19:54.402]                             version <- utils::packageVersion("future")
[10:19:54.402]                         }
[10:19:54.402]                         else {
[10:19:54.402]                           version <- NULL
[10:19:54.402]                         }
[10:19:54.402]                         if (!has_future || version < "1.8.0") {
[10:19:54.402]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:54.402]                             "", base::R.version$version.string), 
[10:19:54.402]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:54.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:54.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:54.402]                               "release", "version")], collapse = " "), 
[10:19:54.402]                             hostname = base::Sys.info()[["nodename"]])
[10:19:54.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:54.402]                             info)
[10:19:54.402]                           info <- base::paste(info, collapse = "; ")
[10:19:54.402]                           if (!has_future) {
[10:19:54.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:54.402]                               info)
[10:19:54.402]                           }
[10:19:54.402]                           else {
[10:19:54.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:54.402]                               info, version)
[10:19:54.402]                           }
[10:19:54.402]                           base::stop(msg)
[10:19:54.402]                         }
[10:19:54.402]                       })
[10:19:54.402]                     }
[10:19:54.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:54.402]                     base::options(mc.cores = 1L)
[10:19:54.402]                   }
[10:19:54.402]                   ...future.strategy.old <- future::plan("list")
[10:19:54.402]                   options(future.plan = NULL)
[10:19:54.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:54.402]                 }
[10:19:54.402]                 ...future.workdir <- getwd()
[10:19:54.402]             }
[10:19:54.402]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:54.402]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:54.402]         }
[10:19:54.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:54.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:54.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:54.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:54.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:54.402]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:54.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:54.402]             base::names(...future.oldOptions))
[10:19:54.402]     }
[10:19:54.402]     if (FALSE) {
[10:19:54.402]     }
[10:19:54.402]     else {
[10:19:54.402]         if (TRUE) {
[10:19:54.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:54.402]                 open = "w")
[10:19:54.402]         }
[10:19:54.402]         else {
[10:19:54.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:54.402]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:54.402]         }
[10:19:54.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:54.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:54.402]             base::sink(type = "output", split = FALSE)
[10:19:54.402]             base::close(...future.stdout)
[10:19:54.402]         }, add = TRUE)
[10:19:54.402]     }
[10:19:54.402]     ...future.frame <- base::sys.nframe()
[10:19:54.402]     ...future.conditions <- base::list()
[10:19:54.402]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:54.402]     if (FALSE) {
[10:19:54.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:54.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:54.402]     }
[10:19:54.402]     ...future.result <- base::tryCatch({
[10:19:54.402]         base::withCallingHandlers({
[10:19:54.402]             ...future.value <- base::withVisible(base::local({
[10:19:54.402]                 ...future.makeSendCondition <- base::local({
[10:19:54.402]                   sendCondition <- NULL
[10:19:54.402]                   function(frame = 1L) {
[10:19:54.402]                     if (is.function(sendCondition)) 
[10:19:54.402]                       return(sendCondition)
[10:19:54.402]                     ns <- getNamespace("parallel")
[10:19:54.402]                     if (exists("sendData", mode = "function", 
[10:19:54.402]                       envir = ns)) {
[10:19:54.402]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:54.402]                         envir = ns)
[10:19:54.402]                       envir <- sys.frame(frame)
[10:19:54.402]                       master <- NULL
[10:19:54.402]                       while (!identical(envir, .GlobalEnv) && 
[10:19:54.402]                         !identical(envir, emptyenv())) {
[10:19:54.402]                         if (exists("master", mode = "list", envir = envir, 
[10:19:54.402]                           inherits = FALSE)) {
[10:19:54.402]                           master <- get("master", mode = "list", 
[10:19:54.402]                             envir = envir, inherits = FALSE)
[10:19:54.402]                           if (inherits(master, c("SOCKnode", 
[10:19:54.402]                             "SOCK0node"))) {
[10:19:54.402]                             sendCondition <<- function(cond) {
[10:19:54.402]                               data <- list(type = "VALUE", value = cond, 
[10:19:54.402]                                 success = TRUE)
[10:19:54.402]                               parallel_sendData(master, data)
[10:19:54.402]                             }
[10:19:54.402]                             return(sendCondition)
[10:19:54.402]                           }
[10:19:54.402]                         }
[10:19:54.402]                         frame <- frame + 1L
[10:19:54.402]                         envir <- sys.frame(frame)
[10:19:54.402]                       }
[10:19:54.402]                     }
[10:19:54.402]                     sendCondition <<- function(cond) NULL
[10:19:54.402]                   }
[10:19:54.402]                 })
[10:19:54.402]                 withCallingHandlers({
[10:19:54.402]                   NA
[10:19:54.402]                 }, immediateCondition = function(cond) {
[10:19:54.402]                   sendCondition <- ...future.makeSendCondition()
[10:19:54.402]                   sendCondition(cond)
[10:19:54.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.402]                   {
[10:19:54.402]                     inherits <- base::inherits
[10:19:54.402]                     invokeRestart <- base::invokeRestart
[10:19:54.402]                     is.null <- base::is.null
[10:19:54.402]                     muffled <- FALSE
[10:19:54.402]                     if (inherits(cond, "message")) {
[10:19:54.402]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:54.402]                       if (muffled) 
[10:19:54.402]                         invokeRestart("muffleMessage")
[10:19:54.402]                     }
[10:19:54.402]                     else if (inherits(cond, "warning")) {
[10:19:54.402]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:54.402]                       if (muffled) 
[10:19:54.402]                         invokeRestart("muffleWarning")
[10:19:54.402]                     }
[10:19:54.402]                     else if (inherits(cond, "condition")) {
[10:19:54.402]                       if (!is.null(pattern)) {
[10:19:54.402]                         computeRestarts <- base::computeRestarts
[10:19:54.402]                         grepl <- base::grepl
[10:19:54.402]                         restarts <- computeRestarts(cond)
[10:19:54.402]                         for (restart in restarts) {
[10:19:54.402]                           name <- restart$name
[10:19:54.402]                           if (is.null(name)) 
[10:19:54.402]                             next
[10:19:54.402]                           if (!grepl(pattern, name)) 
[10:19:54.402]                             next
[10:19:54.402]                           invokeRestart(restart)
[10:19:54.402]                           muffled <- TRUE
[10:19:54.402]                           break
[10:19:54.402]                         }
[10:19:54.402]                       }
[10:19:54.402]                     }
[10:19:54.402]                     invisible(muffled)
[10:19:54.402]                   }
[10:19:54.402]                   muffleCondition(cond)
[10:19:54.402]                 })
[10:19:54.402]             }))
[10:19:54.402]             future::FutureResult(value = ...future.value$value, 
[10:19:54.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.402]                   ...future.rng), globalenv = if (FALSE) 
[10:19:54.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:54.402]                     ...future.globalenv.names))
[10:19:54.402]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:54.402]         }, condition = base::local({
[10:19:54.402]             c <- base::c
[10:19:54.402]             inherits <- base::inherits
[10:19:54.402]             invokeRestart <- base::invokeRestart
[10:19:54.402]             length <- base::length
[10:19:54.402]             list <- base::list
[10:19:54.402]             seq.int <- base::seq.int
[10:19:54.402]             signalCondition <- base::signalCondition
[10:19:54.402]             sys.calls <- base::sys.calls
[10:19:54.402]             `[[` <- base::`[[`
[10:19:54.402]             `+` <- base::`+`
[10:19:54.402]             `<<-` <- base::`<<-`
[10:19:54.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:54.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:54.402]                   3L)]
[10:19:54.402]             }
[10:19:54.402]             function(cond) {
[10:19:54.402]                 is_error <- inherits(cond, "error")
[10:19:54.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:54.402]                   NULL)
[10:19:54.402]                 if (is_error) {
[10:19:54.402]                   sessionInformation <- function() {
[10:19:54.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:54.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:54.402]                       search = base::search(), system = base::Sys.info())
[10:19:54.402]                   }
[10:19:54.402]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:54.402]                     cond$call), session = sessionInformation(), 
[10:19:54.402]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:54.402]                   signalCondition(cond)
[10:19:54.402]                 }
[10:19:54.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:54.402]                 "immediateCondition"))) {
[10:19:54.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:54.402]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:54.402]                   if (TRUE && !signal) {
[10:19:54.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.402]                     {
[10:19:54.402]                       inherits <- base::inherits
[10:19:54.402]                       invokeRestart <- base::invokeRestart
[10:19:54.402]                       is.null <- base::is.null
[10:19:54.402]                       muffled <- FALSE
[10:19:54.402]                       if (inherits(cond, "message")) {
[10:19:54.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.402]                         if (muffled) 
[10:19:54.402]                           invokeRestart("muffleMessage")
[10:19:54.402]                       }
[10:19:54.402]                       else if (inherits(cond, "warning")) {
[10:19:54.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.402]                         if (muffled) 
[10:19:54.402]                           invokeRestart("muffleWarning")
[10:19:54.402]                       }
[10:19:54.402]                       else if (inherits(cond, "condition")) {
[10:19:54.402]                         if (!is.null(pattern)) {
[10:19:54.402]                           computeRestarts <- base::computeRestarts
[10:19:54.402]                           grepl <- base::grepl
[10:19:54.402]                           restarts <- computeRestarts(cond)
[10:19:54.402]                           for (restart in restarts) {
[10:19:54.402]                             name <- restart$name
[10:19:54.402]                             if (is.null(name)) 
[10:19:54.402]                               next
[10:19:54.402]                             if (!grepl(pattern, name)) 
[10:19:54.402]                               next
[10:19:54.402]                             invokeRestart(restart)
[10:19:54.402]                             muffled <- TRUE
[10:19:54.402]                             break
[10:19:54.402]                           }
[10:19:54.402]                         }
[10:19:54.402]                       }
[10:19:54.402]                       invisible(muffled)
[10:19:54.402]                     }
[10:19:54.402]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.402]                   }
[10:19:54.402]                 }
[10:19:54.402]                 else {
[10:19:54.402]                   if (TRUE) {
[10:19:54.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.402]                     {
[10:19:54.402]                       inherits <- base::inherits
[10:19:54.402]                       invokeRestart <- base::invokeRestart
[10:19:54.402]                       is.null <- base::is.null
[10:19:54.402]                       muffled <- FALSE
[10:19:54.402]                       if (inherits(cond, "message")) {
[10:19:54.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.402]                         if (muffled) 
[10:19:54.402]                           invokeRestart("muffleMessage")
[10:19:54.402]                       }
[10:19:54.402]                       else if (inherits(cond, "warning")) {
[10:19:54.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.402]                         if (muffled) 
[10:19:54.402]                           invokeRestart("muffleWarning")
[10:19:54.402]                       }
[10:19:54.402]                       else if (inherits(cond, "condition")) {
[10:19:54.402]                         if (!is.null(pattern)) {
[10:19:54.402]                           computeRestarts <- base::computeRestarts
[10:19:54.402]                           grepl <- base::grepl
[10:19:54.402]                           restarts <- computeRestarts(cond)
[10:19:54.402]                           for (restart in restarts) {
[10:19:54.402]                             name <- restart$name
[10:19:54.402]                             if (is.null(name)) 
[10:19:54.402]                               next
[10:19:54.402]                             if (!grepl(pattern, name)) 
[10:19:54.402]                               next
[10:19:54.402]                             invokeRestart(restart)
[10:19:54.402]                             muffled <- TRUE
[10:19:54.402]                             break
[10:19:54.402]                           }
[10:19:54.402]                         }
[10:19:54.402]                       }
[10:19:54.402]                       invisible(muffled)
[10:19:54.402]                     }
[10:19:54.402]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.402]                   }
[10:19:54.402]                 }
[10:19:54.402]             }
[10:19:54.402]         }))
[10:19:54.402]     }, error = function(ex) {
[10:19:54.402]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:54.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.402]                 ...future.rng), started = ...future.startTime, 
[10:19:54.402]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:54.402]             version = "1.8"), class = "FutureResult")
[10:19:54.402]     }, finally = {
[10:19:54.402]         if (!identical(...future.workdir, getwd())) 
[10:19:54.402]             setwd(...future.workdir)
[10:19:54.402]         {
[10:19:54.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:54.402]                 ...future.oldOptions$nwarnings <- NULL
[10:19:54.402]             }
[10:19:54.402]             base::options(...future.oldOptions)
[10:19:54.402]             if (.Platform$OS.type == "windows") {
[10:19:54.402]                 old_names <- names(...future.oldEnvVars)
[10:19:54.402]                 envs <- base::Sys.getenv()
[10:19:54.402]                 names <- names(envs)
[10:19:54.402]                 common <- intersect(names, old_names)
[10:19:54.402]                 added <- setdiff(names, old_names)
[10:19:54.402]                 removed <- setdiff(old_names, names)
[10:19:54.402]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:54.402]                   envs[common]]
[10:19:54.402]                 NAMES <- toupper(changed)
[10:19:54.402]                 args <- list()
[10:19:54.402]                 for (kk in seq_along(NAMES)) {
[10:19:54.402]                   name <- changed[[kk]]
[10:19:54.402]                   NAME <- NAMES[[kk]]
[10:19:54.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.402]                     next
[10:19:54.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.402]                 }
[10:19:54.402]                 NAMES <- toupper(added)
[10:19:54.402]                 for (kk in seq_along(NAMES)) {
[10:19:54.402]                   name <- added[[kk]]
[10:19:54.402]                   NAME <- NAMES[[kk]]
[10:19:54.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.402]                     next
[10:19:54.402]                   args[[name]] <- ""
[10:19:54.402]                 }
[10:19:54.402]                 NAMES <- toupper(removed)
[10:19:54.402]                 for (kk in seq_along(NAMES)) {
[10:19:54.402]                   name <- removed[[kk]]
[10:19:54.402]                   NAME <- NAMES[[kk]]
[10:19:54.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.402]                     next
[10:19:54.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.402]                 }
[10:19:54.402]                 if (length(args) > 0) 
[10:19:54.402]                   base::do.call(base::Sys.setenv, args = args)
[10:19:54.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:54.402]             }
[10:19:54.402]             else {
[10:19:54.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:54.402]             }
[10:19:54.402]             {
[10:19:54.402]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:54.402]                   0L) {
[10:19:54.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:54.402]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:54.402]                   base::options(opts)
[10:19:54.402]                 }
[10:19:54.402]                 {
[10:19:54.402]                   {
[10:19:54.402]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:54.402]                     NULL
[10:19:54.402]                   }
[10:19:54.402]                   options(future.plan = NULL)
[10:19:54.402]                   if (is.na(NA_character_)) 
[10:19:54.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:54.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:54.402]                     .init = FALSE)
[10:19:54.402]                 }
[10:19:54.402]             }
[10:19:54.402]         }
[10:19:54.402]     })
[10:19:54.402]     if (TRUE) {
[10:19:54.402]         base::sink(type = "output", split = FALSE)
[10:19:54.402]         if (TRUE) {
[10:19:54.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:54.402]         }
[10:19:54.402]         else {
[10:19:54.402]             ...future.result["stdout"] <- base::list(NULL)
[10:19:54.402]         }
[10:19:54.402]         base::close(...future.stdout)
[10:19:54.402]         ...future.stdout <- NULL
[10:19:54.402]     }
[10:19:54.402]     ...future.result$conditions <- ...future.conditions
[10:19:54.402]     ...future.result$finished <- base::Sys.time()
[10:19:54.402]     ...future.result
[10:19:54.402] }
[10:19:54.454] MultisessionFuture started
[10:19:54.454] result() for ClusterFuture ...
[10:19:54.454] receiveMessageFromWorker() for ClusterFuture ...
[10:19:54.455] - Validating connection of MultisessionFuture
[10:19:54.485] - received message: FutureResult
[10:19:54.485] - Received FutureResult
[10:19:54.485] - Erased future from FutureRegistry
[10:19:54.485] result() for ClusterFuture ...
[10:19:54.485] - result already collected: FutureResult
[10:19:54.485] result() for ClusterFuture ... done
[10:19:54.486] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:54.486] result() for ClusterFuture ... done
[10:19:54.486] result() for ClusterFuture ...
[10:19:54.486] - result already collected: FutureResult
[10:19:54.486] result() for ClusterFuture ... done
[10:19:54.486] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:19:54.488] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:19:54.490] future_lapply() ...
[10:19:54.493] Number of chunks: 2
[10:19:54.493] getGlobalsAndPackagesXApply() ...
[10:19:54.493]  - future.globals: TRUE
[10:19:54.494] getGlobalsAndPackages() ...
[10:19:54.494] Searching for globals...
[10:19:54.497] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:54.497] Searching for globals ... DONE
[10:19:54.497] Resolving globals: FALSE
[10:19:54.498] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[10:19:54.498] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:54.498] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:54.499] - packages: [1] ‘future.apply’
[10:19:54.499] getGlobalsAndPackages() ... DONE
[10:19:54.499]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:54.499]  - needed namespaces: [n=1] ‘future.apply’
[10:19:54.499] Finding globals ... DONE
[10:19:54.499]  - use_args: TRUE
[10:19:54.499]  - Getting '...' globals ...
[10:19:54.500] resolve() on list ...
[10:19:54.500]  recursive: 0
[10:19:54.500]  length: 1
[10:19:54.500]  elements: ‘...’
[10:19:54.500]  length: 0 (resolved future 1)
[10:19:54.500] resolve() on list ... DONE
[10:19:54.500]    - '...' content: [n=0] 
[10:19:54.500] List of 1
[10:19:54.500]  $ ...: list()
[10:19:54.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:54.500]  - attr(*, "where")=List of 1
[10:19:54.500]   ..$ ...:<environment: 0x55c69f9d16f0> 
[10:19:54.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:54.500]  - attr(*, "resolved")= logi TRUE
[10:19:54.500]  - attr(*, "total_size")= num NA
[10:19:54.503]  - Getting '...' globals ... DONE
[10:19:54.503] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:54.503] List of 8
[10:19:54.503]  $ ...future.FUN:function (x, ...)  
[10:19:54.503]  $ x_FUN        :function (x)  
[10:19:54.503]  $ times        : int 1
[10:19:54.503]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:54.503]  $ stop_if_not  :function (...)  
[10:19:54.503]  $ dim          : NULL
[10:19:54.503]  $ valid_types  : chr "character"
[10:19:54.503]  $ ...          : list()
[10:19:54.503]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:54.503]  - attr(*, "where")=List of 8
[10:19:54.503]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:54.503]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:54.503]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:54.503]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:54.503]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:54.503]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:54.503]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:54.503]   ..$ ...          :<environment: 0x55c69f9d16f0> 
[10:19:54.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:54.503]  - attr(*, "resolved")= logi FALSE
[10:19:54.503]  - attr(*, "total_size")= num 22333
[10:19:54.509] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:54.509] getGlobalsAndPackagesXApply() ... DONE
[10:19:54.510] Number of futures (= number of chunks): 2
[10:19:54.510] Launching 2 futures (chunks) ...
[10:19:54.510] Chunk #1 of 2 ...
[10:19:54.510]  - Finding globals in 'X' for chunk #1 ...
[10:19:54.510] getGlobalsAndPackages() ...
[10:19:54.510] Searching for globals...
[10:19:54.510] 
[10:19:54.511] Searching for globals ... DONE
[10:19:54.511] - globals: [0] <none>
[10:19:54.511] getGlobalsAndPackages() ... DONE
[10:19:54.511]    + additional globals found: [n=0] 
[10:19:54.511]    + additional namespaces needed: [n=0] 
[10:19:54.511]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:54.511]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:54.511]  - seeds: <none>
[10:19:54.511]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.512] getGlobalsAndPackages() ...
[10:19:54.512] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.512] Resolving globals: FALSE
[10:19:54.512] Tweak future expression to call with '...' arguments ...
[10:19:54.512] {
[10:19:54.512]     do.call(function(...) {
[10:19:54.512]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.512]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:54.512]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.512]             on.exit(options(oopts), add = TRUE)
[10:19:54.512]         }
[10:19:54.512]         {
[10:19:54.512]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:54.512]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.512]                 ...future.FUN(...future.X_jj, ...)
[10:19:54.512]             })
[10:19:54.512]         }
[10:19:54.512]     }, args = future.call.arguments)
[10:19:54.512] }
[10:19:54.512] Tweak future expression to call with '...' arguments ... DONE
[10:19:54.513] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.513] - packages: [1] ‘future.apply’
[10:19:54.513] getGlobalsAndPackages() ... DONE
[10:19:54.514] run() for ‘Future’ ...
[10:19:54.514] - state: ‘created’
[10:19:54.514] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:54.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:54.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:54.529]   - Field: ‘node’
[10:19:54.529]   - Field: ‘label’
[10:19:54.529]   - Field: ‘local’
[10:19:54.529]   - Field: ‘owner’
[10:19:54.529]   - Field: ‘envir’
[10:19:54.529]   - Field: ‘workers’
[10:19:54.529]   - Field: ‘packages’
[10:19:54.529]   - Field: ‘gc’
[10:19:54.529]   - Field: ‘conditions’
[10:19:54.529]   - Field: ‘persistent’
[10:19:54.530]   - Field: ‘expr’
[10:19:54.530]   - Field: ‘uuid’
[10:19:54.530]   - Field: ‘seed’
[10:19:54.530]   - Field: ‘version’
[10:19:54.530]   - Field: ‘result’
[10:19:54.530]   - Field: ‘asynchronous’
[10:19:54.530]   - Field: ‘calls’
[10:19:54.530]   - Field: ‘globals’
[10:19:54.531]   - Field: ‘stdout’
[10:19:54.531]   - Field: ‘earlySignal’
[10:19:54.531]   - Field: ‘lazy’
[10:19:54.531]   - Field: ‘state’
[10:19:54.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:54.531] - Launch lazy future ...
[10:19:54.531] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:54.532] Packages needed by future strategies (n = 0): <none>
[10:19:54.532] {
[10:19:54.532]     {
[10:19:54.532]         {
[10:19:54.532]             ...future.startTime <- base::Sys.time()
[10:19:54.532]             {
[10:19:54.532]                 {
[10:19:54.532]                   {
[10:19:54.532]                     {
[10:19:54.532]                       {
[10:19:54.532]                         base::local({
[10:19:54.532]                           has_future <- base::requireNamespace("future", 
[10:19:54.532]                             quietly = TRUE)
[10:19:54.532]                           if (has_future) {
[10:19:54.532]                             ns <- base::getNamespace("future")
[10:19:54.532]                             version <- ns[[".package"]][["version"]]
[10:19:54.532]                             if (is.null(version)) 
[10:19:54.532]                               version <- utils::packageVersion("future")
[10:19:54.532]                           }
[10:19:54.532]                           else {
[10:19:54.532]                             version <- NULL
[10:19:54.532]                           }
[10:19:54.532]                           if (!has_future || version < "1.8.0") {
[10:19:54.532]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:54.532]                               "", base::R.version$version.string), 
[10:19:54.532]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:54.532]                                 base::R.version$platform, 8 * 
[10:19:54.532]                                   base::.Machine$sizeof.pointer), 
[10:19:54.532]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:54.532]                                 "release", "version")], collapse = " "), 
[10:19:54.532]                               hostname = base::Sys.info()[["nodename"]])
[10:19:54.532]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:54.532]                               info)
[10:19:54.532]                             info <- base::paste(info, collapse = "; ")
[10:19:54.532]                             if (!has_future) {
[10:19:54.532]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:54.532]                                 info)
[10:19:54.532]                             }
[10:19:54.532]                             else {
[10:19:54.532]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:54.532]                                 info, version)
[10:19:54.532]                             }
[10:19:54.532]                             base::stop(msg)
[10:19:54.532]                           }
[10:19:54.532]                         })
[10:19:54.532]                       }
[10:19:54.532]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:54.532]                       base::options(mc.cores = 1L)
[10:19:54.532]                     }
[10:19:54.532]                     base::local({
[10:19:54.532]                       for (pkg in "future.apply") {
[10:19:54.532]                         base::loadNamespace(pkg)
[10:19:54.532]                         base::library(pkg, character.only = TRUE)
[10:19:54.532]                       }
[10:19:54.532]                     })
[10:19:54.532]                   }
[10:19:54.532]                   ...future.strategy.old <- future::plan("list")
[10:19:54.532]                   options(future.plan = NULL)
[10:19:54.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:54.532]                 }
[10:19:54.532]                 ...future.workdir <- getwd()
[10:19:54.532]             }
[10:19:54.532]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:54.532]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:54.532]         }
[10:19:54.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:54.532]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:54.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:54.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:54.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:54.532]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:54.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:54.532]             base::names(...future.oldOptions))
[10:19:54.532]     }
[10:19:54.532]     if (FALSE) {
[10:19:54.532]     }
[10:19:54.532]     else {
[10:19:54.532]         if (TRUE) {
[10:19:54.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:54.532]                 open = "w")
[10:19:54.532]         }
[10:19:54.532]         else {
[10:19:54.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:54.532]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:54.532]         }
[10:19:54.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:54.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:54.532]             base::sink(type = "output", split = FALSE)
[10:19:54.532]             base::close(...future.stdout)
[10:19:54.532]         }, add = TRUE)
[10:19:54.532]     }
[10:19:54.532]     ...future.frame <- base::sys.nframe()
[10:19:54.532]     ...future.conditions <- base::list()
[10:19:54.532]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:54.532]     if (FALSE) {
[10:19:54.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:54.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:54.532]     }
[10:19:54.532]     ...future.result <- base::tryCatch({
[10:19:54.532]         base::withCallingHandlers({
[10:19:54.532]             ...future.value <- base::withVisible(base::local({
[10:19:54.532]                 ...future.makeSendCondition <- base::local({
[10:19:54.532]                   sendCondition <- NULL
[10:19:54.532]                   function(frame = 1L) {
[10:19:54.532]                     if (is.function(sendCondition)) 
[10:19:54.532]                       return(sendCondition)
[10:19:54.532]                     ns <- getNamespace("parallel")
[10:19:54.532]                     if (exists("sendData", mode = "function", 
[10:19:54.532]                       envir = ns)) {
[10:19:54.532]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:54.532]                         envir = ns)
[10:19:54.532]                       envir <- sys.frame(frame)
[10:19:54.532]                       master <- NULL
[10:19:54.532]                       while (!identical(envir, .GlobalEnv) && 
[10:19:54.532]                         !identical(envir, emptyenv())) {
[10:19:54.532]                         if (exists("master", mode = "list", envir = envir, 
[10:19:54.532]                           inherits = FALSE)) {
[10:19:54.532]                           master <- get("master", mode = "list", 
[10:19:54.532]                             envir = envir, inherits = FALSE)
[10:19:54.532]                           if (inherits(master, c("SOCKnode", 
[10:19:54.532]                             "SOCK0node"))) {
[10:19:54.532]                             sendCondition <<- function(cond) {
[10:19:54.532]                               data <- list(type = "VALUE", value = cond, 
[10:19:54.532]                                 success = TRUE)
[10:19:54.532]                               parallel_sendData(master, data)
[10:19:54.532]                             }
[10:19:54.532]                             return(sendCondition)
[10:19:54.532]                           }
[10:19:54.532]                         }
[10:19:54.532]                         frame <- frame + 1L
[10:19:54.532]                         envir <- sys.frame(frame)
[10:19:54.532]                       }
[10:19:54.532]                     }
[10:19:54.532]                     sendCondition <<- function(cond) NULL
[10:19:54.532]                   }
[10:19:54.532]                 })
[10:19:54.532]                 withCallingHandlers({
[10:19:54.532]                   {
[10:19:54.532]                     do.call(function(...) {
[10:19:54.532]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.532]                       if (!identical(...future.globals.maxSize.org, 
[10:19:54.532]                         ...future.globals.maxSize)) {
[10:19:54.532]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.532]                         on.exit(options(oopts), add = TRUE)
[10:19:54.532]                       }
[10:19:54.532]                       {
[10:19:54.532]                         lapply(seq_along(...future.elements_ii), 
[10:19:54.532]                           FUN = function(jj) {
[10:19:54.532]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.532]                             ...future.FUN(...future.X_jj, ...)
[10:19:54.532]                           })
[10:19:54.532]                       }
[10:19:54.532]                     }, args = future.call.arguments)
[10:19:54.532]                   }
[10:19:54.532]                 }, immediateCondition = function(cond) {
[10:19:54.532]                   sendCondition <- ...future.makeSendCondition()
[10:19:54.532]                   sendCondition(cond)
[10:19:54.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.532]                   {
[10:19:54.532]                     inherits <- base::inherits
[10:19:54.532]                     invokeRestart <- base::invokeRestart
[10:19:54.532]                     is.null <- base::is.null
[10:19:54.532]                     muffled <- FALSE
[10:19:54.532]                     if (inherits(cond, "message")) {
[10:19:54.532]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:54.532]                       if (muffled) 
[10:19:54.532]                         invokeRestart("muffleMessage")
[10:19:54.532]                     }
[10:19:54.532]                     else if (inherits(cond, "warning")) {
[10:19:54.532]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:54.532]                       if (muffled) 
[10:19:54.532]                         invokeRestart("muffleWarning")
[10:19:54.532]                     }
[10:19:54.532]                     else if (inherits(cond, "condition")) {
[10:19:54.532]                       if (!is.null(pattern)) {
[10:19:54.532]                         computeRestarts <- base::computeRestarts
[10:19:54.532]                         grepl <- base::grepl
[10:19:54.532]                         restarts <- computeRestarts(cond)
[10:19:54.532]                         for (restart in restarts) {
[10:19:54.532]                           name <- restart$name
[10:19:54.532]                           if (is.null(name)) 
[10:19:54.532]                             next
[10:19:54.532]                           if (!grepl(pattern, name)) 
[10:19:54.532]                             next
[10:19:54.532]                           invokeRestart(restart)
[10:19:54.532]                           muffled <- TRUE
[10:19:54.532]                           break
[10:19:54.532]                         }
[10:19:54.532]                       }
[10:19:54.532]                     }
[10:19:54.532]                     invisible(muffled)
[10:19:54.532]                   }
[10:19:54.532]                   muffleCondition(cond)
[10:19:54.532]                 })
[10:19:54.532]             }))
[10:19:54.532]             future::FutureResult(value = ...future.value$value, 
[10:19:54.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.532]                   ...future.rng), globalenv = if (FALSE) 
[10:19:54.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:54.532]                     ...future.globalenv.names))
[10:19:54.532]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:54.532]         }, condition = base::local({
[10:19:54.532]             c <- base::c
[10:19:54.532]             inherits <- base::inherits
[10:19:54.532]             invokeRestart <- base::invokeRestart
[10:19:54.532]             length <- base::length
[10:19:54.532]             list <- base::list
[10:19:54.532]             seq.int <- base::seq.int
[10:19:54.532]             signalCondition <- base::signalCondition
[10:19:54.532]             sys.calls <- base::sys.calls
[10:19:54.532]             `[[` <- base::`[[`
[10:19:54.532]             `+` <- base::`+`
[10:19:54.532]             `<<-` <- base::`<<-`
[10:19:54.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:54.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:54.532]                   3L)]
[10:19:54.532]             }
[10:19:54.532]             function(cond) {
[10:19:54.532]                 is_error <- inherits(cond, "error")
[10:19:54.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:54.532]                   NULL)
[10:19:54.532]                 if (is_error) {
[10:19:54.532]                   sessionInformation <- function() {
[10:19:54.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:54.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:54.532]                       search = base::search(), system = base::Sys.info())
[10:19:54.532]                   }
[10:19:54.532]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:54.532]                     cond$call), session = sessionInformation(), 
[10:19:54.532]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:54.532]                   signalCondition(cond)
[10:19:54.532]                 }
[10:19:54.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:54.532]                 "immediateCondition"))) {
[10:19:54.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:54.532]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:54.532]                   if (TRUE && !signal) {
[10:19:54.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.532]                     {
[10:19:54.532]                       inherits <- base::inherits
[10:19:54.532]                       invokeRestart <- base::invokeRestart
[10:19:54.532]                       is.null <- base::is.null
[10:19:54.532]                       muffled <- FALSE
[10:19:54.532]                       if (inherits(cond, "message")) {
[10:19:54.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.532]                         if (muffled) 
[10:19:54.532]                           invokeRestart("muffleMessage")
[10:19:54.532]                       }
[10:19:54.532]                       else if (inherits(cond, "warning")) {
[10:19:54.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.532]                         if (muffled) 
[10:19:54.532]                           invokeRestart("muffleWarning")
[10:19:54.532]                       }
[10:19:54.532]                       else if (inherits(cond, "condition")) {
[10:19:54.532]                         if (!is.null(pattern)) {
[10:19:54.532]                           computeRestarts <- base::computeRestarts
[10:19:54.532]                           grepl <- base::grepl
[10:19:54.532]                           restarts <- computeRestarts(cond)
[10:19:54.532]                           for (restart in restarts) {
[10:19:54.532]                             name <- restart$name
[10:19:54.532]                             if (is.null(name)) 
[10:19:54.532]                               next
[10:19:54.532]                             if (!grepl(pattern, name)) 
[10:19:54.532]                               next
[10:19:54.532]                             invokeRestart(restart)
[10:19:54.532]                             muffled <- TRUE
[10:19:54.532]                             break
[10:19:54.532]                           }
[10:19:54.532]                         }
[10:19:54.532]                       }
[10:19:54.532]                       invisible(muffled)
[10:19:54.532]                     }
[10:19:54.532]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.532]                   }
[10:19:54.532]                 }
[10:19:54.532]                 else {
[10:19:54.532]                   if (TRUE) {
[10:19:54.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.532]                     {
[10:19:54.532]                       inherits <- base::inherits
[10:19:54.532]                       invokeRestart <- base::invokeRestart
[10:19:54.532]                       is.null <- base::is.null
[10:19:54.532]                       muffled <- FALSE
[10:19:54.532]                       if (inherits(cond, "message")) {
[10:19:54.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.532]                         if (muffled) 
[10:19:54.532]                           invokeRestart("muffleMessage")
[10:19:54.532]                       }
[10:19:54.532]                       else if (inherits(cond, "warning")) {
[10:19:54.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.532]                         if (muffled) 
[10:19:54.532]                           invokeRestart("muffleWarning")
[10:19:54.532]                       }
[10:19:54.532]                       else if (inherits(cond, "condition")) {
[10:19:54.532]                         if (!is.null(pattern)) {
[10:19:54.532]                           computeRestarts <- base::computeRestarts
[10:19:54.532]                           grepl <- base::grepl
[10:19:54.532]                           restarts <- computeRestarts(cond)
[10:19:54.532]                           for (restart in restarts) {
[10:19:54.532]                             name <- restart$name
[10:19:54.532]                             if (is.null(name)) 
[10:19:54.532]                               next
[10:19:54.532]                             if (!grepl(pattern, name)) 
[10:19:54.532]                               next
[10:19:54.532]                             invokeRestart(restart)
[10:19:54.532]                             muffled <- TRUE
[10:19:54.532]                             break
[10:19:54.532]                           }
[10:19:54.532]                         }
[10:19:54.532]                       }
[10:19:54.532]                       invisible(muffled)
[10:19:54.532]                     }
[10:19:54.532]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.532]                   }
[10:19:54.532]                 }
[10:19:54.532]             }
[10:19:54.532]         }))
[10:19:54.532]     }, error = function(ex) {
[10:19:54.532]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:54.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.532]                 ...future.rng), started = ...future.startTime, 
[10:19:54.532]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:54.532]             version = "1.8"), class = "FutureResult")
[10:19:54.532]     }, finally = {
[10:19:54.532]         if (!identical(...future.workdir, getwd())) 
[10:19:54.532]             setwd(...future.workdir)
[10:19:54.532]         {
[10:19:54.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:54.532]                 ...future.oldOptions$nwarnings <- NULL
[10:19:54.532]             }
[10:19:54.532]             base::options(...future.oldOptions)
[10:19:54.532]             if (.Platform$OS.type == "windows") {
[10:19:54.532]                 old_names <- names(...future.oldEnvVars)
[10:19:54.532]                 envs <- base::Sys.getenv()
[10:19:54.532]                 names <- names(envs)
[10:19:54.532]                 common <- intersect(names, old_names)
[10:19:54.532]                 added <- setdiff(names, old_names)
[10:19:54.532]                 removed <- setdiff(old_names, names)
[10:19:54.532]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:54.532]                   envs[common]]
[10:19:54.532]                 NAMES <- toupper(changed)
[10:19:54.532]                 args <- list()
[10:19:54.532]                 for (kk in seq_along(NAMES)) {
[10:19:54.532]                   name <- changed[[kk]]
[10:19:54.532]                   NAME <- NAMES[[kk]]
[10:19:54.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.532]                     next
[10:19:54.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.532]                 }
[10:19:54.532]                 NAMES <- toupper(added)
[10:19:54.532]                 for (kk in seq_along(NAMES)) {
[10:19:54.532]                   name <- added[[kk]]
[10:19:54.532]                   NAME <- NAMES[[kk]]
[10:19:54.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.532]                     next
[10:19:54.532]                   args[[name]] <- ""
[10:19:54.532]                 }
[10:19:54.532]                 NAMES <- toupper(removed)
[10:19:54.532]                 for (kk in seq_along(NAMES)) {
[10:19:54.532]                   name <- removed[[kk]]
[10:19:54.532]                   NAME <- NAMES[[kk]]
[10:19:54.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.532]                     next
[10:19:54.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.532]                 }
[10:19:54.532]                 if (length(args) > 0) 
[10:19:54.532]                   base::do.call(base::Sys.setenv, args = args)
[10:19:54.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:54.532]             }
[10:19:54.532]             else {
[10:19:54.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:54.532]             }
[10:19:54.532]             {
[10:19:54.532]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:54.532]                   0L) {
[10:19:54.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:54.532]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:54.532]                   base::options(opts)
[10:19:54.532]                 }
[10:19:54.532]                 {
[10:19:54.532]                   {
[10:19:54.532]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:54.532]                     NULL
[10:19:54.532]                   }
[10:19:54.532]                   options(future.plan = NULL)
[10:19:54.532]                   if (is.na(NA_character_)) 
[10:19:54.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:54.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:54.532]                     .init = FALSE)
[10:19:54.532]                 }
[10:19:54.532]             }
[10:19:54.532]         }
[10:19:54.532]     })
[10:19:54.532]     if (TRUE) {
[10:19:54.532]         base::sink(type = "output", split = FALSE)
[10:19:54.532]         if (TRUE) {
[10:19:54.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:54.532]         }
[10:19:54.532]         else {
[10:19:54.532]             ...future.result["stdout"] <- base::list(NULL)
[10:19:54.532]         }
[10:19:54.532]         base::close(...future.stdout)
[10:19:54.532]         ...future.stdout <- NULL
[10:19:54.532]     }
[10:19:54.532]     ...future.result$conditions <- ...future.conditions
[10:19:54.532]     ...future.result$finished <- base::Sys.time()
[10:19:54.532]     ...future.result
[10:19:54.532] }
[10:19:54.535] Exporting 11 global objects (12.52 KiB) to cluster node #1 ...
[10:19:54.535] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #1 ...
[10:19:54.576] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #1 ... DONE
[10:19:54.577] Exporting ‘x_FUN’ (36 bytes) to cluster node #1 ...
[10:19:54.577] Exporting ‘x_FUN’ (36 bytes) to cluster node #1 ... DONE
[10:19:54.577] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:54.577] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:54.578] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:54.618] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:54.619] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:54.659] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:54.660] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:54.660] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:54.660] Exporting ‘valid_types’ (48 bytes) to cluster node #1 ...
[10:19:54.660] Exporting ‘valid_types’ (48 bytes) to cluster node #1 ... DONE
[10:19:54.661] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:54.661] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:54.661] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ...
[10:19:54.661] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ... DONE
[10:19:54.662] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:54.662] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:54.662] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:54.662] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:54.663] Exporting 11 global objects (12.52 KiB) to cluster node #1 ... DONE
[10:19:54.663] MultisessionFuture started
[10:19:54.663] - Launch lazy future ... done
[10:19:54.663] run() for ‘MultisessionFuture’ ... done
[10:19:54.664] Created future:
[10:19:54.664] MultisessionFuture:
[10:19:54.664] Label: ‘future_vapply-1’
[10:19:54.664] Expression:
[10:19:54.664] {
[10:19:54.664]     do.call(function(...) {
[10:19:54.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:54.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.664]             on.exit(options(oopts), add = TRUE)
[10:19:54.664]         }
[10:19:54.664]         {
[10:19:54.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:54.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.664]                 ...future.FUN(...future.X_jj, ...)
[10:19:54.664]             })
[10:19:54.664]         }
[10:19:54.664]     }, args = future.call.arguments)
[10:19:54.664] }
[10:19:54.664] Lazy evaluation: FALSE
[10:19:54.664] Asynchronous evaluation: TRUE
[10:19:54.664] Local evaluation: TRUE
[10:19:54.664] Environment: R_GlobalEnv
[10:19:54.664] Capture standard output: TRUE
[10:19:54.664] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:54.664] Globals: 11 objects totaling 12.33 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:54.664] Packages: 1 packages (‘future.apply’)
[10:19:54.664] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:54.664] Resolved: FALSE
[10:19:54.664] Value: <not collected>
[10:19:54.664] Conditions captured: <none>
[10:19:54.664] Early signaling: FALSE
[10:19:54.664] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:54.664] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:54.676] Chunk #1 of 2 ... DONE
[10:19:54.676] Chunk #2 of 2 ...
[10:19:54.676]  - Finding globals in 'X' for chunk #2 ...
[10:19:54.676] getGlobalsAndPackages() ...
[10:19:54.676] Searching for globals...
[10:19:54.677] 
[10:19:54.677] Searching for globals ... DONE
[10:19:54.677] - globals: [0] <none>
[10:19:54.677] getGlobalsAndPackages() ... DONE
[10:19:54.677]    + additional globals found: [n=0] 
[10:19:54.677]    + additional namespaces needed: [n=0] 
[10:19:54.677]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:54.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:54.677]  - seeds: <none>
[10:19:54.678]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.678] getGlobalsAndPackages() ...
[10:19:54.678] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.678] Resolving globals: FALSE
[10:19:54.678] Tweak future expression to call with '...' arguments ...
[10:19:54.678] {
[10:19:54.678]     do.call(function(...) {
[10:19:54.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:54.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.678]             on.exit(options(oopts), add = TRUE)
[10:19:54.678]         }
[10:19:54.678]         {
[10:19:54.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:54.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.678]                 ...future.FUN(...future.X_jj, ...)
[10:19:54.678]             })
[10:19:54.678]         }
[10:19:54.678]     }, args = future.call.arguments)
[10:19:54.678] }
[10:19:54.678] Tweak future expression to call with '...' arguments ... DONE
[10:19:54.679] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.679] - packages: [1] ‘future.apply’
[10:19:54.679] getGlobalsAndPackages() ... DONE
[10:19:54.680] run() for ‘Future’ ...
[10:19:54.680] - state: ‘created’
[10:19:54.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:54.695] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:54.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:54.695]   - Field: ‘node’
[10:19:54.695]   - Field: ‘label’
[10:19:54.695]   - Field: ‘local’
[10:19:54.695]   - Field: ‘owner’
[10:19:54.695]   - Field: ‘envir’
[10:19:54.695]   - Field: ‘workers’
[10:19:54.695]   - Field: ‘packages’
[10:19:54.695]   - Field: ‘gc’
[10:19:54.696]   - Field: ‘conditions’
[10:19:54.696]   - Field: ‘persistent’
[10:19:54.696]   - Field: ‘expr’
[10:19:54.696]   - Field: ‘uuid’
[10:19:54.696]   - Field: ‘seed’
[10:19:54.696]   - Field: ‘version’
[10:19:54.696]   - Field: ‘result’
[10:19:54.696]   - Field: ‘asynchronous’
[10:19:54.696]   - Field: ‘calls’
[10:19:54.696]   - Field: ‘globals’
[10:19:54.697]   - Field: ‘stdout’
[10:19:54.697]   - Field: ‘earlySignal’
[10:19:54.697]   - Field: ‘lazy’
[10:19:54.697]   - Field: ‘state’
[10:19:54.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:54.697] - Launch lazy future ...
[10:19:54.697] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:54.698] Packages needed by future strategies (n = 0): <none>
[10:19:54.698] {
[10:19:54.698]     {
[10:19:54.698]         {
[10:19:54.698]             ...future.startTime <- base::Sys.time()
[10:19:54.698]             {
[10:19:54.698]                 {
[10:19:54.698]                   {
[10:19:54.698]                     {
[10:19:54.698]                       {
[10:19:54.698]                         base::local({
[10:19:54.698]                           has_future <- base::requireNamespace("future", 
[10:19:54.698]                             quietly = TRUE)
[10:19:54.698]                           if (has_future) {
[10:19:54.698]                             ns <- base::getNamespace("future")
[10:19:54.698]                             version <- ns[[".package"]][["version"]]
[10:19:54.698]                             if (is.null(version)) 
[10:19:54.698]                               version <- utils::packageVersion("future")
[10:19:54.698]                           }
[10:19:54.698]                           else {
[10:19:54.698]                             version <- NULL
[10:19:54.698]                           }
[10:19:54.698]                           if (!has_future || version < "1.8.0") {
[10:19:54.698]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:54.698]                               "", base::R.version$version.string), 
[10:19:54.698]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:54.698]                                 base::R.version$platform, 8 * 
[10:19:54.698]                                   base::.Machine$sizeof.pointer), 
[10:19:54.698]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:54.698]                                 "release", "version")], collapse = " "), 
[10:19:54.698]                               hostname = base::Sys.info()[["nodename"]])
[10:19:54.698]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:54.698]                               info)
[10:19:54.698]                             info <- base::paste(info, collapse = "; ")
[10:19:54.698]                             if (!has_future) {
[10:19:54.698]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:54.698]                                 info)
[10:19:54.698]                             }
[10:19:54.698]                             else {
[10:19:54.698]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:54.698]                                 info, version)
[10:19:54.698]                             }
[10:19:54.698]                             base::stop(msg)
[10:19:54.698]                           }
[10:19:54.698]                         })
[10:19:54.698]                       }
[10:19:54.698]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:54.698]                       base::options(mc.cores = 1L)
[10:19:54.698]                     }
[10:19:54.698]                     base::local({
[10:19:54.698]                       for (pkg in "future.apply") {
[10:19:54.698]                         base::loadNamespace(pkg)
[10:19:54.698]                         base::library(pkg, character.only = TRUE)
[10:19:54.698]                       }
[10:19:54.698]                     })
[10:19:54.698]                   }
[10:19:54.698]                   ...future.strategy.old <- future::plan("list")
[10:19:54.698]                   options(future.plan = NULL)
[10:19:54.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:54.698]                 }
[10:19:54.698]                 ...future.workdir <- getwd()
[10:19:54.698]             }
[10:19:54.698]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:54.698]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:54.698]         }
[10:19:54.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:54.698]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:54.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:54.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:54.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:54.698]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:54.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:54.698]             base::names(...future.oldOptions))
[10:19:54.698]     }
[10:19:54.698]     if (FALSE) {
[10:19:54.698]     }
[10:19:54.698]     else {
[10:19:54.698]         if (TRUE) {
[10:19:54.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:54.698]                 open = "w")
[10:19:54.698]         }
[10:19:54.698]         else {
[10:19:54.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:54.698]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:54.698]         }
[10:19:54.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:54.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:54.698]             base::sink(type = "output", split = FALSE)
[10:19:54.698]             base::close(...future.stdout)
[10:19:54.698]         }, add = TRUE)
[10:19:54.698]     }
[10:19:54.698]     ...future.frame <- base::sys.nframe()
[10:19:54.698]     ...future.conditions <- base::list()
[10:19:54.698]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:54.698]     if (FALSE) {
[10:19:54.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:54.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:54.698]     }
[10:19:54.698]     ...future.result <- base::tryCatch({
[10:19:54.698]         base::withCallingHandlers({
[10:19:54.698]             ...future.value <- base::withVisible(base::local({
[10:19:54.698]                 ...future.makeSendCondition <- base::local({
[10:19:54.698]                   sendCondition <- NULL
[10:19:54.698]                   function(frame = 1L) {
[10:19:54.698]                     if (is.function(sendCondition)) 
[10:19:54.698]                       return(sendCondition)
[10:19:54.698]                     ns <- getNamespace("parallel")
[10:19:54.698]                     if (exists("sendData", mode = "function", 
[10:19:54.698]                       envir = ns)) {
[10:19:54.698]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:54.698]                         envir = ns)
[10:19:54.698]                       envir <- sys.frame(frame)
[10:19:54.698]                       master <- NULL
[10:19:54.698]                       while (!identical(envir, .GlobalEnv) && 
[10:19:54.698]                         !identical(envir, emptyenv())) {
[10:19:54.698]                         if (exists("master", mode = "list", envir = envir, 
[10:19:54.698]                           inherits = FALSE)) {
[10:19:54.698]                           master <- get("master", mode = "list", 
[10:19:54.698]                             envir = envir, inherits = FALSE)
[10:19:54.698]                           if (inherits(master, c("SOCKnode", 
[10:19:54.698]                             "SOCK0node"))) {
[10:19:54.698]                             sendCondition <<- function(cond) {
[10:19:54.698]                               data <- list(type = "VALUE", value = cond, 
[10:19:54.698]                                 success = TRUE)
[10:19:54.698]                               parallel_sendData(master, data)
[10:19:54.698]                             }
[10:19:54.698]                             return(sendCondition)
[10:19:54.698]                           }
[10:19:54.698]                         }
[10:19:54.698]                         frame <- frame + 1L
[10:19:54.698]                         envir <- sys.frame(frame)
[10:19:54.698]                       }
[10:19:54.698]                     }
[10:19:54.698]                     sendCondition <<- function(cond) NULL
[10:19:54.698]                   }
[10:19:54.698]                 })
[10:19:54.698]                 withCallingHandlers({
[10:19:54.698]                   {
[10:19:54.698]                     do.call(function(...) {
[10:19:54.698]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.698]                       if (!identical(...future.globals.maxSize.org, 
[10:19:54.698]                         ...future.globals.maxSize)) {
[10:19:54.698]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.698]                         on.exit(options(oopts), add = TRUE)
[10:19:54.698]                       }
[10:19:54.698]                       {
[10:19:54.698]                         lapply(seq_along(...future.elements_ii), 
[10:19:54.698]                           FUN = function(jj) {
[10:19:54.698]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.698]                             ...future.FUN(...future.X_jj, ...)
[10:19:54.698]                           })
[10:19:54.698]                       }
[10:19:54.698]                     }, args = future.call.arguments)
[10:19:54.698]                   }
[10:19:54.698]                 }, immediateCondition = function(cond) {
[10:19:54.698]                   sendCondition <- ...future.makeSendCondition()
[10:19:54.698]                   sendCondition(cond)
[10:19:54.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.698]                   {
[10:19:54.698]                     inherits <- base::inherits
[10:19:54.698]                     invokeRestart <- base::invokeRestart
[10:19:54.698]                     is.null <- base::is.null
[10:19:54.698]                     muffled <- FALSE
[10:19:54.698]                     if (inherits(cond, "message")) {
[10:19:54.698]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:54.698]                       if (muffled) 
[10:19:54.698]                         invokeRestart("muffleMessage")
[10:19:54.698]                     }
[10:19:54.698]                     else if (inherits(cond, "warning")) {
[10:19:54.698]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:54.698]                       if (muffled) 
[10:19:54.698]                         invokeRestart("muffleWarning")
[10:19:54.698]                     }
[10:19:54.698]                     else if (inherits(cond, "condition")) {
[10:19:54.698]                       if (!is.null(pattern)) {
[10:19:54.698]                         computeRestarts <- base::computeRestarts
[10:19:54.698]                         grepl <- base::grepl
[10:19:54.698]                         restarts <- computeRestarts(cond)
[10:19:54.698]                         for (restart in restarts) {
[10:19:54.698]                           name <- restart$name
[10:19:54.698]                           if (is.null(name)) 
[10:19:54.698]                             next
[10:19:54.698]                           if (!grepl(pattern, name)) 
[10:19:54.698]                             next
[10:19:54.698]                           invokeRestart(restart)
[10:19:54.698]                           muffled <- TRUE
[10:19:54.698]                           break
[10:19:54.698]                         }
[10:19:54.698]                       }
[10:19:54.698]                     }
[10:19:54.698]                     invisible(muffled)
[10:19:54.698]                   }
[10:19:54.698]                   muffleCondition(cond)
[10:19:54.698]                 })
[10:19:54.698]             }))
[10:19:54.698]             future::FutureResult(value = ...future.value$value, 
[10:19:54.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.698]                   ...future.rng), globalenv = if (FALSE) 
[10:19:54.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:54.698]                     ...future.globalenv.names))
[10:19:54.698]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:54.698]         }, condition = base::local({
[10:19:54.698]             c <- base::c
[10:19:54.698]             inherits <- base::inherits
[10:19:54.698]             invokeRestart <- base::invokeRestart
[10:19:54.698]             length <- base::length
[10:19:54.698]             list <- base::list
[10:19:54.698]             seq.int <- base::seq.int
[10:19:54.698]             signalCondition <- base::signalCondition
[10:19:54.698]             sys.calls <- base::sys.calls
[10:19:54.698]             `[[` <- base::`[[`
[10:19:54.698]             `+` <- base::`+`
[10:19:54.698]             `<<-` <- base::`<<-`
[10:19:54.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:54.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:54.698]                   3L)]
[10:19:54.698]             }
[10:19:54.698]             function(cond) {
[10:19:54.698]                 is_error <- inherits(cond, "error")
[10:19:54.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:54.698]                   NULL)
[10:19:54.698]                 if (is_error) {
[10:19:54.698]                   sessionInformation <- function() {
[10:19:54.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:54.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:54.698]                       search = base::search(), system = base::Sys.info())
[10:19:54.698]                   }
[10:19:54.698]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:54.698]                     cond$call), session = sessionInformation(), 
[10:19:54.698]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:54.698]                   signalCondition(cond)
[10:19:54.698]                 }
[10:19:54.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:54.698]                 "immediateCondition"))) {
[10:19:54.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:54.698]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:54.698]                   if (TRUE && !signal) {
[10:19:54.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.698]                     {
[10:19:54.698]                       inherits <- base::inherits
[10:19:54.698]                       invokeRestart <- base::invokeRestart
[10:19:54.698]                       is.null <- base::is.null
[10:19:54.698]                       muffled <- FALSE
[10:19:54.698]                       if (inherits(cond, "message")) {
[10:19:54.698]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.698]                         if (muffled) 
[10:19:54.698]                           invokeRestart("muffleMessage")
[10:19:54.698]                       }
[10:19:54.698]                       else if (inherits(cond, "warning")) {
[10:19:54.698]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.698]                         if (muffled) 
[10:19:54.698]                           invokeRestart("muffleWarning")
[10:19:54.698]                       }
[10:19:54.698]                       else if (inherits(cond, "condition")) {
[10:19:54.698]                         if (!is.null(pattern)) {
[10:19:54.698]                           computeRestarts <- base::computeRestarts
[10:19:54.698]                           grepl <- base::grepl
[10:19:54.698]                           restarts <- computeRestarts(cond)
[10:19:54.698]                           for (restart in restarts) {
[10:19:54.698]                             name <- restart$name
[10:19:54.698]                             if (is.null(name)) 
[10:19:54.698]                               next
[10:19:54.698]                             if (!grepl(pattern, name)) 
[10:19:54.698]                               next
[10:19:54.698]                             invokeRestart(restart)
[10:19:54.698]                             muffled <- TRUE
[10:19:54.698]                             break
[10:19:54.698]                           }
[10:19:54.698]                         }
[10:19:54.698]                       }
[10:19:54.698]                       invisible(muffled)
[10:19:54.698]                     }
[10:19:54.698]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.698]                   }
[10:19:54.698]                 }
[10:19:54.698]                 else {
[10:19:54.698]                   if (TRUE) {
[10:19:54.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.698]                     {
[10:19:54.698]                       inherits <- base::inherits
[10:19:54.698]                       invokeRestart <- base::invokeRestart
[10:19:54.698]                       is.null <- base::is.null
[10:19:54.698]                       muffled <- FALSE
[10:19:54.698]                       if (inherits(cond, "message")) {
[10:19:54.698]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.698]                         if (muffled) 
[10:19:54.698]                           invokeRestart("muffleMessage")
[10:19:54.698]                       }
[10:19:54.698]                       else if (inherits(cond, "warning")) {
[10:19:54.698]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.698]                         if (muffled) 
[10:19:54.698]                           invokeRestart("muffleWarning")
[10:19:54.698]                       }
[10:19:54.698]                       else if (inherits(cond, "condition")) {
[10:19:54.698]                         if (!is.null(pattern)) {
[10:19:54.698]                           computeRestarts <- base::computeRestarts
[10:19:54.698]                           grepl <- base::grepl
[10:19:54.698]                           restarts <- computeRestarts(cond)
[10:19:54.698]                           for (restart in restarts) {
[10:19:54.698]                             name <- restart$name
[10:19:54.698]                             if (is.null(name)) 
[10:19:54.698]                               next
[10:19:54.698]                             if (!grepl(pattern, name)) 
[10:19:54.698]                               next
[10:19:54.698]                             invokeRestart(restart)
[10:19:54.698]                             muffled <- TRUE
[10:19:54.698]                             break
[10:19:54.698]                           }
[10:19:54.698]                         }
[10:19:54.698]                       }
[10:19:54.698]                       invisible(muffled)
[10:19:54.698]                     }
[10:19:54.698]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.698]                   }
[10:19:54.698]                 }
[10:19:54.698]             }
[10:19:54.698]         }))
[10:19:54.698]     }, error = function(ex) {
[10:19:54.698]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:54.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.698]                 ...future.rng), started = ...future.startTime, 
[10:19:54.698]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:54.698]             version = "1.8"), class = "FutureResult")
[10:19:54.698]     }, finally = {
[10:19:54.698]         if (!identical(...future.workdir, getwd())) 
[10:19:54.698]             setwd(...future.workdir)
[10:19:54.698]         {
[10:19:54.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:54.698]                 ...future.oldOptions$nwarnings <- NULL
[10:19:54.698]             }
[10:19:54.698]             base::options(...future.oldOptions)
[10:19:54.698]             if (.Platform$OS.type == "windows") {
[10:19:54.698]                 old_names <- names(...future.oldEnvVars)
[10:19:54.698]                 envs <- base::Sys.getenv()
[10:19:54.698]                 names <- names(envs)
[10:19:54.698]                 common <- intersect(names, old_names)
[10:19:54.698]                 added <- setdiff(names, old_names)
[10:19:54.698]                 removed <- setdiff(old_names, names)
[10:19:54.698]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:54.698]                   envs[common]]
[10:19:54.698]                 NAMES <- toupper(changed)
[10:19:54.698]                 args <- list()
[10:19:54.698]                 for (kk in seq_along(NAMES)) {
[10:19:54.698]                   name <- changed[[kk]]
[10:19:54.698]                   NAME <- NAMES[[kk]]
[10:19:54.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.698]                     next
[10:19:54.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.698]                 }
[10:19:54.698]                 NAMES <- toupper(added)
[10:19:54.698]                 for (kk in seq_along(NAMES)) {
[10:19:54.698]                   name <- added[[kk]]
[10:19:54.698]                   NAME <- NAMES[[kk]]
[10:19:54.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.698]                     next
[10:19:54.698]                   args[[name]] <- ""
[10:19:54.698]                 }
[10:19:54.698]                 NAMES <- toupper(removed)
[10:19:54.698]                 for (kk in seq_along(NAMES)) {
[10:19:54.698]                   name <- removed[[kk]]
[10:19:54.698]                   NAME <- NAMES[[kk]]
[10:19:54.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.698]                     next
[10:19:54.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.698]                 }
[10:19:54.698]                 if (length(args) > 0) 
[10:19:54.698]                   base::do.call(base::Sys.setenv, args = args)
[10:19:54.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:54.698]             }
[10:19:54.698]             else {
[10:19:54.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:54.698]             }
[10:19:54.698]             {
[10:19:54.698]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:54.698]                   0L) {
[10:19:54.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:54.698]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:54.698]                   base::options(opts)
[10:19:54.698]                 }
[10:19:54.698]                 {
[10:19:54.698]                   {
[10:19:54.698]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:54.698]                     NULL
[10:19:54.698]                   }
[10:19:54.698]                   options(future.plan = NULL)
[10:19:54.698]                   if (is.na(NA_character_)) 
[10:19:54.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:54.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:54.698]                     .init = FALSE)
[10:19:54.698]                 }
[10:19:54.698]             }
[10:19:54.698]         }
[10:19:54.698]     })
[10:19:54.698]     if (TRUE) {
[10:19:54.698]         base::sink(type = "output", split = FALSE)
[10:19:54.698]         if (TRUE) {
[10:19:54.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:54.698]         }
[10:19:54.698]         else {
[10:19:54.698]             ...future.result["stdout"] <- base::list(NULL)
[10:19:54.698]         }
[10:19:54.698]         base::close(...future.stdout)
[10:19:54.698]         ...future.stdout <- NULL
[10:19:54.698]     }
[10:19:54.698]     ...future.result$conditions <- ...future.conditions
[10:19:54.698]     ...future.result$finished <- base::Sys.time()
[10:19:54.698]     ...future.result
[10:19:54.698] }
[10:19:54.751] Exporting 11 global objects (12.54 KiB) to cluster node #2 ...
[10:19:54.751] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #2 ...
[10:19:54.755] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #2 ... DONE
[10:19:54.755] Exporting ‘x_FUN’ (36 bytes) to cluster node #2 ...
[10:19:54.756] Exporting ‘x_FUN’ (36 bytes) to cluster node #2 ... DONE
[10:19:54.756] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:54.756] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:54.756] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:54.797] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:54.797] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:54.838] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:54.838] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:54.839] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:54.839] Exporting ‘valid_types’ (48 bytes) to cluster node #2 ...
[10:19:54.840] Exporting ‘valid_types’ (48 bytes) to cluster node #2 ... DONE
[10:19:54.840] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:54.840] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:54.840] Exporting ‘...future.elements_ii’ (171 bytes) to cluster node #2 ...
[10:19:54.841] Exporting ‘...future.elements_ii’ (171 bytes) to cluster node #2 ... DONE
[10:19:54.841] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:54.841] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:54.842] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:54.842] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:54.842] Exporting 11 global objects (12.54 KiB) to cluster node #2 ... DONE
[10:19:54.843] MultisessionFuture started
[10:19:54.843] - Launch lazy future ... done
[10:19:54.843] run() for ‘MultisessionFuture’ ... done
[10:19:54.843] Created future:
[10:19:54.843] MultisessionFuture:
[10:19:54.843] Label: ‘future_vapply-2’
[10:19:54.843] Expression:
[10:19:54.843] {
[10:19:54.843]     do.call(function(...) {
[10:19:54.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:54.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.843]             on.exit(options(oopts), add = TRUE)
[10:19:54.843]         }
[10:19:54.843]         {
[10:19:54.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:54.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.843]                 ...future.FUN(...future.X_jj, ...)
[10:19:54.843]             })
[10:19:54.843]         }
[10:19:54.843]     }, args = future.call.arguments)
[10:19:54.843] }
[10:19:54.843] Lazy evaluation: FALSE
[10:19:54.843] Asynchronous evaluation: TRUE
[10:19:54.843] Local evaluation: TRUE
[10:19:54.843] Environment: R_GlobalEnv
[10:19:54.843] Capture standard output: TRUE
[10:19:54.843] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:54.843] Globals: 11 objects totaling 12.32 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:54.843] Packages: 1 packages (‘future.apply’)
[10:19:54.843] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:54.843] Resolved: FALSE
[10:19:54.843] Value: <not collected>
[10:19:54.843] Conditions captured: <none>
[10:19:54.843] Early signaling: FALSE
[10:19:54.843] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:54.843] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:54.855] Chunk #2 of 2 ... DONE
[10:19:54.855] Launching 2 futures (chunks) ... DONE
[10:19:54.855] Resolving 2 futures (chunks) ...
[10:19:54.856] resolve() on list ...
[10:19:54.856]  recursive: 0
[10:19:54.856]  length: 2
[10:19:54.856] 
[10:19:54.856] receiveMessageFromWorker() for ClusterFuture ...
[10:19:54.857] - Validating connection of MultisessionFuture
[10:19:54.857] - received message: FutureResult
[10:19:54.857] - Received FutureResult
[10:19:54.857] - Erased future from FutureRegistry
[10:19:54.857] result() for ClusterFuture ...
[10:19:54.857] - result already collected: FutureResult
[10:19:54.857] result() for ClusterFuture ... done
[10:19:54.858] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:54.858] Future #1
[10:19:54.858] result() for ClusterFuture ...
[10:19:54.858] - result already collected: FutureResult
[10:19:54.858] result() for ClusterFuture ... done
[10:19:54.858] result() for ClusterFuture ...
[10:19:54.858] - result already collected: FutureResult
[10:19:54.858] result() for ClusterFuture ... done
[10:19:54.858] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:54.859] - nx: 2
[10:19:54.859] - relay: TRUE
[10:19:54.859] - stdout: TRUE
[10:19:54.859] - signal: TRUE
[10:19:54.859] - resignal: FALSE
[10:19:54.859] - force: TRUE
[10:19:54.859] - relayed: [n=2] FALSE, FALSE
[10:19:54.859] - queued futures: [n=2] FALSE, FALSE
[10:19:54.859]  - until=1
[10:19:54.859]  - relaying element #1
[10:19:54.860] result() for ClusterFuture ...
[10:19:54.860] - result already collected: FutureResult
[10:19:54.860] result() for ClusterFuture ... done
[10:19:54.860] result() for ClusterFuture ...
[10:19:54.860] - result already collected: FutureResult
[10:19:54.860] result() for ClusterFuture ... done
[10:19:54.860] result() for ClusterFuture ...
[10:19:54.860] - result already collected: FutureResult
[10:19:54.860] result() for ClusterFuture ... done
[10:19:54.861] result() for ClusterFuture ...
[10:19:54.861] - result already collected: FutureResult
[10:19:54.861] result() for ClusterFuture ... done
[10:19:54.861] - relayed: [n=2] TRUE, FALSE
[10:19:54.861] - queued futures: [n=2] TRUE, FALSE
[10:19:54.861] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:54.861]  length: 1 (resolved future 1)
[10:19:54.924] receiveMessageFromWorker() for ClusterFuture ...
[10:19:54.924] - Validating connection of MultisessionFuture
[10:19:54.925] - received message: FutureResult
[10:19:54.925] - Received FutureResult
[10:19:54.925] - Erased future from FutureRegistry
[10:19:54.925] result() for ClusterFuture ...
[10:19:54.925] - result already collected: FutureResult
[10:19:54.925] result() for ClusterFuture ... done
[10:19:54.925] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:54.925] Future #2
[10:19:54.926] result() for ClusterFuture ...
[10:19:54.926] - result already collected: FutureResult
[10:19:54.926] result() for ClusterFuture ... done
[10:19:54.926] result() for ClusterFuture ...
[10:19:54.926] - result already collected: FutureResult
[10:19:54.926] result() for ClusterFuture ... done
[10:19:54.926] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:54.926] - nx: 2
[10:19:54.926] - relay: TRUE
[10:19:54.926] - stdout: TRUE
[10:19:54.927] - signal: TRUE
[10:19:54.927] - resignal: FALSE
[10:19:54.927] - force: TRUE
[10:19:54.927] - relayed: [n=2] TRUE, FALSE
[10:19:54.927] - queued futures: [n=2] TRUE, FALSE
[10:19:54.927]  - until=2
[10:19:54.927]  - relaying element #2
[10:19:54.927] result() for ClusterFuture ...
[10:19:54.927] - result already collected: FutureResult
[10:19:54.927] result() for ClusterFuture ... done
[10:19:54.928] result() for ClusterFuture ...
[10:19:54.928] - result already collected: FutureResult
[10:19:54.928] result() for ClusterFuture ... done
[10:19:54.928] result() for ClusterFuture ...
[10:19:54.928] - result already collected: FutureResult
[10:19:54.928] result() for ClusterFuture ... done
[10:19:54.928] result() for ClusterFuture ...
[10:19:54.928] - result already collected: FutureResult
[10:19:54.928] result() for ClusterFuture ... done
[10:19:54.929] - relayed: [n=2] TRUE, TRUE
[10:19:54.929] - queued futures: [n=2] TRUE, TRUE
[10:19:54.929] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:54.929]  length: 0 (resolved future 2)
[10:19:54.929] Relaying remaining futures
[10:19:54.929] signalConditionsASAP(NULL, pos=0) ...
[10:19:54.929] - nx: 2
[10:19:54.929] - relay: TRUE
[10:19:54.929] - stdout: TRUE
[10:19:54.929] - signal: TRUE
[10:19:54.930] - resignal: FALSE
[10:19:54.930] - force: TRUE
[10:19:54.930] - relayed: [n=2] TRUE, TRUE
[10:19:54.930] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:54.930] - relayed: [n=2] TRUE, TRUE
[10:19:54.930] - queued futures: [n=2] TRUE, TRUE
[10:19:54.930] signalConditionsASAP(NULL, pos=0) ... done
[10:19:54.930] resolve() on list ... DONE
[10:19:54.931] result() for ClusterFuture ...
[10:19:54.931] - result already collected: FutureResult
[10:19:54.931] result() for ClusterFuture ... done
[10:19:54.931] result() for ClusterFuture ...
[10:19:54.931] - result already collected: FutureResult
[10:19:54.931] result() for ClusterFuture ... done
[10:19:54.931] result() for ClusterFuture ...
[10:19:54.931] - result already collected: FutureResult
[10:19:54.931] result() for ClusterFuture ... done
[10:19:54.931] result() for ClusterFuture ...
[10:19:54.932] - result already collected: FutureResult
[10:19:54.932] result() for ClusterFuture ... done
[10:19:54.932]  - Number of value chunks collected: 2
[10:19:54.932] Resolving 2 futures (chunks) ... DONE
[10:19:54.932] Reducing values from 2 chunks ...
[10:19:54.932]  - Number of values collected after concatenation: 2
[10:19:54.932]  - Number of values expected: 2
[10:19:54.932] Reducing values from 2 chunks ... DONE
[10:19:54.932] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:19:54.934] future_lapply() ...
[10:19:54.938] Number of chunks: 2
[10:19:54.938] getGlobalsAndPackagesXApply() ...
[10:19:54.938]  - future.globals: TRUE
[10:19:54.938] getGlobalsAndPackages() ...
[10:19:54.938] Searching for globals...
[10:19:54.942] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:19:54.942] Searching for globals ... DONE
[10:19:54.943] Resolving globals: FALSE
[10:19:54.944] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[10:19:54.944] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:54.944] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:54.944] - packages: [1] ‘future.apply’
[10:19:54.944] getGlobalsAndPackages() ... DONE
[10:19:54.947]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:54.947]  - needed namespaces: [n=1] ‘future.apply’
[10:19:54.947] Finding globals ... DONE
[10:19:54.947]  - use_args: TRUE
[10:19:54.947]  - Getting '...' globals ...
[10:19:54.947] resolve() on list ...
[10:19:54.947]  recursive: 0
[10:19:54.948]  length: 1
[10:19:54.948]  elements: ‘...’
[10:19:54.948]  length: 0 (resolved future 1)
[10:19:54.948] resolve() on list ... DONE
[10:19:54.948]    - '...' content: [n=0] 
[10:19:54.948] List of 1
[10:19:54.948]  $ ...: list()
[10:19:54.948]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:54.948]  - attr(*, "where")=List of 1
[10:19:54.948]   ..$ ...:<environment: 0x55c6a28f5238> 
[10:19:54.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:54.948]  - attr(*, "resolved")= logi TRUE
[10:19:54.948]  - attr(*, "total_size")= num NA
[10:19:54.950]  - Getting '...' globals ... DONE
[10:19:54.950] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:54.951] List of 8
[10:19:54.951]  $ ...future.FUN:function (x, ...)  
[10:19:54.951]  $ x_FUN        :function (x)  
[10:19:54.951]  $ times        : int 0
[10:19:54.951]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:54.951]  $ stop_if_not  :function (...)  
[10:19:54.951]  $ dim          : NULL
[10:19:54.951]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:54.951]  $ ...          : list()
[10:19:54.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:54.951]  - attr(*, "where")=List of 8
[10:19:54.951]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:54.951]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:54.951]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:54.951]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:54.951]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:54.951]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:54.951]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:54.951]   ..$ ...          :<environment: 0x55c6a28f5238> 
[10:19:54.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:54.951]  - attr(*, "resolved")= logi FALSE
[10:19:54.951]  - attr(*, "total_size")= num 23490
[10:19:54.956] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:54.956] getGlobalsAndPackagesXApply() ... DONE
[10:19:54.956] Number of futures (= number of chunks): 2
[10:19:54.956] Launching 2 futures (chunks) ...
[10:19:54.956] Chunk #1 of 2 ...
[10:19:54.956]  - Finding globals in 'X' for chunk #1 ...
[10:19:54.956] getGlobalsAndPackages() ...
[10:19:54.956] Searching for globals...
[10:19:54.957] 
[10:19:54.957] Searching for globals ... DONE
[10:19:54.957] - globals: [0] <none>
[10:19:54.957] getGlobalsAndPackages() ... DONE
[10:19:54.957]    + additional globals found: [n=0] 
[10:19:54.957]    + additional namespaces needed: [n=0] 
[10:19:54.957]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:54.957]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:54.957]  - seeds: <none>
[10:19:54.957]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.958] getGlobalsAndPackages() ...
[10:19:54.958] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.958] Resolving globals: FALSE
[10:19:54.958] Tweak future expression to call with '...' arguments ...
[10:19:54.958] {
[10:19:54.958]     do.call(function(...) {
[10:19:54.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:54.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.958]             on.exit(options(oopts), add = TRUE)
[10:19:54.958]         }
[10:19:54.958]         {
[10:19:54.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:54.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.958]                 ...future.FUN(...future.X_jj, ...)
[10:19:54.958]             })
[10:19:54.958]         }
[10:19:54.958]     }, args = future.call.arguments)
[10:19:54.958] }
[10:19:54.958] Tweak future expression to call with '...' arguments ... DONE
[10:19:54.959] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:54.959] - packages: [1] ‘future.apply’
[10:19:54.959] getGlobalsAndPackages() ... DONE
[10:19:54.959] run() for ‘Future’ ...
[10:19:54.959] - state: ‘created’
[10:19:54.960] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:54.974] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:54.975] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:54.975]   - Field: ‘node’
[10:19:54.975]   - Field: ‘label’
[10:19:54.975]   - Field: ‘local’
[10:19:54.975]   - Field: ‘owner’
[10:19:54.975]   - Field: ‘envir’
[10:19:54.975]   - Field: ‘workers’
[10:19:54.975]   - Field: ‘packages’
[10:19:54.975]   - Field: ‘gc’
[10:19:54.975]   - Field: ‘conditions’
[10:19:54.975]   - Field: ‘persistent’
[10:19:54.976]   - Field: ‘expr’
[10:19:54.976]   - Field: ‘uuid’
[10:19:54.976]   - Field: ‘seed’
[10:19:54.976]   - Field: ‘version’
[10:19:54.976]   - Field: ‘result’
[10:19:54.976]   - Field: ‘asynchronous’
[10:19:54.976]   - Field: ‘calls’
[10:19:54.976]   - Field: ‘globals’
[10:19:54.976]   - Field: ‘stdout’
[10:19:54.976]   - Field: ‘earlySignal’
[10:19:54.976]   - Field: ‘lazy’
[10:19:54.977]   - Field: ‘state’
[10:19:54.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:54.977] - Launch lazy future ...
[10:19:54.977] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:54.977] Packages needed by future strategies (n = 0): <none>
[10:19:54.978] {
[10:19:54.978]     {
[10:19:54.978]         {
[10:19:54.978]             ...future.startTime <- base::Sys.time()
[10:19:54.978]             {
[10:19:54.978]                 {
[10:19:54.978]                   {
[10:19:54.978]                     {
[10:19:54.978]                       {
[10:19:54.978]                         base::local({
[10:19:54.978]                           has_future <- base::requireNamespace("future", 
[10:19:54.978]                             quietly = TRUE)
[10:19:54.978]                           if (has_future) {
[10:19:54.978]                             ns <- base::getNamespace("future")
[10:19:54.978]                             version <- ns[[".package"]][["version"]]
[10:19:54.978]                             if (is.null(version)) 
[10:19:54.978]                               version <- utils::packageVersion("future")
[10:19:54.978]                           }
[10:19:54.978]                           else {
[10:19:54.978]                             version <- NULL
[10:19:54.978]                           }
[10:19:54.978]                           if (!has_future || version < "1.8.0") {
[10:19:54.978]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:54.978]                               "", base::R.version$version.string), 
[10:19:54.978]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:54.978]                                 base::R.version$platform, 8 * 
[10:19:54.978]                                   base::.Machine$sizeof.pointer), 
[10:19:54.978]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:54.978]                                 "release", "version")], collapse = " "), 
[10:19:54.978]                               hostname = base::Sys.info()[["nodename"]])
[10:19:54.978]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:54.978]                               info)
[10:19:54.978]                             info <- base::paste(info, collapse = "; ")
[10:19:54.978]                             if (!has_future) {
[10:19:54.978]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:54.978]                                 info)
[10:19:54.978]                             }
[10:19:54.978]                             else {
[10:19:54.978]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:54.978]                                 info, version)
[10:19:54.978]                             }
[10:19:54.978]                             base::stop(msg)
[10:19:54.978]                           }
[10:19:54.978]                         })
[10:19:54.978]                       }
[10:19:54.978]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:54.978]                       base::options(mc.cores = 1L)
[10:19:54.978]                     }
[10:19:54.978]                     base::local({
[10:19:54.978]                       for (pkg in "future.apply") {
[10:19:54.978]                         base::loadNamespace(pkg)
[10:19:54.978]                         base::library(pkg, character.only = TRUE)
[10:19:54.978]                       }
[10:19:54.978]                     })
[10:19:54.978]                   }
[10:19:54.978]                   ...future.strategy.old <- future::plan("list")
[10:19:54.978]                   options(future.plan = NULL)
[10:19:54.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:54.978]                 }
[10:19:54.978]                 ...future.workdir <- getwd()
[10:19:54.978]             }
[10:19:54.978]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:54.978]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:54.978]         }
[10:19:54.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:54.978]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:54.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:54.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:54.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:54.978]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:54.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:54.978]             base::names(...future.oldOptions))
[10:19:54.978]     }
[10:19:54.978]     if (FALSE) {
[10:19:54.978]     }
[10:19:54.978]     else {
[10:19:54.978]         if (TRUE) {
[10:19:54.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:54.978]                 open = "w")
[10:19:54.978]         }
[10:19:54.978]         else {
[10:19:54.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:54.978]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:54.978]         }
[10:19:54.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:54.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:54.978]             base::sink(type = "output", split = FALSE)
[10:19:54.978]             base::close(...future.stdout)
[10:19:54.978]         }, add = TRUE)
[10:19:54.978]     }
[10:19:54.978]     ...future.frame <- base::sys.nframe()
[10:19:54.978]     ...future.conditions <- base::list()
[10:19:54.978]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:54.978]     if (FALSE) {
[10:19:54.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:54.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:54.978]     }
[10:19:54.978]     ...future.result <- base::tryCatch({
[10:19:54.978]         base::withCallingHandlers({
[10:19:54.978]             ...future.value <- base::withVisible(base::local({
[10:19:54.978]                 ...future.makeSendCondition <- base::local({
[10:19:54.978]                   sendCondition <- NULL
[10:19:54.978]                   function(frame = 1L) {
[10:19:54.978]                     if (is.function(sendCondition)) 
[10:19:54.978]                       return(sendCondition)
[10:19:54.978]                     ns <- getNamespace("parallel")
[10:19:54.978]                     if (exists("sendData", mode = "function", 
[10:19:54.978]                       envir = ns)) {
[10:19:54.978]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:54.978]                         envir = ns)
[10:19:54.978]                       envir <- sys.frame(frame)
[10:19:54.978]                       master <- NULL
[10:19:54.978]                       while (!identical(envir, .GlobalEnv) && 
[10:19:54.978]                         !identical(envir, emptyenv())) {
[10:19:54.978]                         if (exists("master", mode = "list", envir = envir, 
[10:19:54.978]                           inherits = FALSE)) {
[10:19:54.978]                           master <- get("master", mode = "list", 
[10:19:54.978]                             envir = envir, inherits = FALSE)
[10:19:54.978]                           if (inherits(master, c("SOCKnode", 
[10:19:54.978]                             "SOCK0node"))) {
[10:19:54.978]                             sendCondition <<- function(cond) {
[10:19:54.978]                               data <- list(type = "VALUE", value = cond, 
[10:19:54.978]                                 success = TRUE)
[10:19:54.978]                               parallel_sendData(master, data)
[10:19:54.978]                             }
[10:19:54.978]                             return(sendCondition)
[10:19:54.978]                           }
[10:19:54.978]                         }
[10:19:54.978]                         frame <- frame + 1L
[10:19:54.978]                         envir <- sys.frame(frame)
[10:19:54.978]                       }
[10:19:54.978]                     }
[10:19:54.978]                     sendCondition <<- function(cond) NULL
[10:19:54.978]                   }
[10:19:54.978]                 })
[10:19:54.978]                 withCallingHandlers({
[10:19:54.978]                   {
[10:19:54.978]                     do.call(function(...) {
[10:19:54.978]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:54.978]                       if (!identical(...future.globals.maxSize.org, 
[10:19:54.978]                         ...future.globals.maxSize)) {
[10:19:54.978]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:54.978]                         on.exit(options(oopts), add = TRUE)
[10:19:54.978]                       }
[10:19:54.978]                       {
[10:19:54.978]                         lapply(seq_along(...future.elements_ii), 
[10:19:54.978]                           FUN = function(jj) {
[10:19:54.978]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:54.978]                             ...future.FUN(...future.X_jj, ...)
[10:19:54.978]                           })
[10:19:54.978]                       }
[10:19:54.978]                     }, args = future.call.arguments)
[10:19:54.978]                   }
[10:19:54.978]                 }, immediateCondition = function(cond) {
[10:19:54.978]                   sendCondition <- ...future.makeSendCondition()
[10:19:54.978]                   sendCondition(cond)
[10:19:54.978]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.978]                   {
[10:19:54.978]                     inherits <- base::inherits
[10:19:54.978]                     invokeRestart <- base::invokeRestart
[10:19:54.978]                     is.null <- base::is.null
[10:19:54.978]                     muffled <- FALSE
[10:19:54.978]                     if (inherits(cond, "message")) {
[10:19:54.978]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:54.978]                       if (muffled) 
[10:19:54.978]                         invokeRestart("muffleMessage")
[10:19:54.978]                     }
[10:19:54.978]                     else if (inherits(cond, "warning")) {
[10:19:54.978]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:54.978]                       if (muffled) 
[10:19:54.978]                         invokeRestart("muffleWarning")
[10:19:54.978]                     }
[10:19:54.978]                     else if (inherits(cond, "condition")) {
[10:19:54.978]                       if (!is.null(pattern)) {
[10:19:54.978]                         computeRestarts <- base::computeRestarts
[10:19:54.978]                         grepl <- base::grepl
[10:19:54.978]                         restarts <- computeRestarts(cond)
[10:19:54.978]                         for (restart in restarts) {
[10:19:54.978]                           name <- restart$name
[10:19:54.978]                           if (is.null(name)) 
[10:19:54.978]                             next
[10:19:54.978]                           if (!grepl(pattern, name)) 
[10:19:54.978]                             next
[10:19:54.978]                           invokeRestart(restart)
[10:19:54.978]                           muffled <- TRUE
[10:19:54.978]                           break
[10:19:54.978]                         }
[10:19:54.978]                       }
[10:19:54.978]                     }
[10:19:54.978]                     invisible(muffled)
[10:19:54.978]                   }
[10:19:54.978]                   muffleCondition(cond)
[10:19:54.978]                 })
[10:19:54.978]             }))
[10:19:54.978]             future::FutureResult(value = ...future.value$value, 
[10:19:54.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.978]                   ...future.rng), globalenv = if (FALSE) 
[10:19:54.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:54.978]                     ...future.globalenv.names))
[10:19:54.978]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:54.978]         }, condition = base::local({
[10:19:54.978]             c <- base::c
[10:19:54.978]             inherits <- base::inherits
[10:19:54.978]             invokeRestart <- base::invokeRestart
[10:19:54.978]             length <- base::length
[10:19:54.978]             list <- base::list
[10:19:54.978]             seq.int <- base::seq.int
[10:19:54.978]             signalCondition <- base::signalCondition
[10:19:54.978]             sys.calls <- base::sys.calls
[10:19:54.978]             `[[` <- base::`[[`
[10:19:54.978]             `+` <- base::`+`
[10:19:54.978]             `<<-` <- base::`<<-`
[10:19:54.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:54.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:54.978]                   3L)]
[10:19:54.978]             }
[10:19:54.978]             function(cond) {
[10:19:54.978]                 is_error <- inherits(cond, "error")
[10:19:54.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:54.978]                   NULL)
[10:19:54.978]                 if (is_error) {
[10:19:54.978]                   sessionInformation <- function() {
[10:19:54.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:54.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:54.978]                       search = base::search(), system = base::Sys.info())
[10:19:54.978]                   }
[10:19:54.978]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:54.978]                     cond$call), session = sessionInformation(), 
[10:19:54.978]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:54.978]                   signalCondition(cond)
[10:19:54.978]                 }
[10:19:54.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:54.978]                 "immediateCondition"))) {
[10:19:54.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:54.978]                   ...future.conditions[[length(...future.conditions) + 
[10:19:54.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:54.978]                   if (TRUE && !signal) {
[10:19:54.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.978]                     {
[10:19:54.978]                       inherits <- base::inherits
[10:19:54.978]                       invokeRestart <- base::invokeRestart
[10:19:54.978]                       is.null <- base::is.null
[10:19:54.978]                       muffled <- FALSE
[10:19:54.978]                       if (inherits(cond, "message")) {
[10:19:54.978]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.978]                         if (muffled) 
[10:19:54.978]                           invokeRestart("muffleMessage")
[10:19:54.978]                       }
[10:19:54.978]                       else if (inherits(cond, "warning")) {
[10:19:54.978]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.978]                         if (muffled) 
[10:19:54.978]                           invokeRestart("muffleWarning")
[10:19:54.978]                       }
[10:19:54.978]                       else if (inherits(cond, "condition")) {
[10:19:54.978]                         if (!is.null(pattern)) {
[10:19:54.978]                           computeRestarts <- base::computeRestarts
[10:19:54.978]                           grepl <- base::grepl
[10:19:54.978]                           restarts <- computeRestarts(cond)
[10:19:54.978]                           for (restart in restarts) {
[10:19:54.978]                             name <- restart$name
[10:19:54.978]                             if (is.null(name)) 
[10:19:54.978]                               next
[10:19:54.978]                             if (!grepl(pattern, name)) 
[10:19:54.978]                               next
[10:19:54.978]                             invokeRestart(restart)
[10:19:54.978]                             muffled <- TRUE
[10:19:54.978]                             break
[10:19:54.978]                           }
[10:19:54.978]                         }
[10:19:54.978]                       }
[10:19:54.978]                       invisible(muffled)
[10:19:54.978]                     }
[10:19:54.978]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.978]                   }
[10:19:54.978]                 }
[10:19:54.978]                 else {
[10:19:54.978]                   if (TRUE) {
[10:19:54.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:54.978]                     {
[10:19:54.978]                       inherits <- base::inherits
[10:19:54.978]                       invokeRestart <- base::invokeRestart
[10:19:54.978]                       is.null <- base::is.null
[10:19:54.978]                       muffled <- FALSE
[10:19:54.978]                       if (inherits(cond, "message")) {
[10:19:54.978]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:54.978]                         if (muffled) 
[10:19:54.978]                           invokeRestart("muffleMessage")
[10:19:54.978]                       }
[10:19:54.978]                       else if (inherits(cond, "warning")) {
[10:19:54.978]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:54.978]                         if (muffled) 
[10:19:54.978]                           invokeRestart("muffleWarning")
[10:19:54.978]                       }
[10:19:54.978]                       else if (inherits(cond, "condition")) {
[10:19:54.978]                         if (!is.null(pattern)) {
[10:19:54.978]                           computeRestarts <- base::computeRestarts
[10:19:54.978]                           grepl <- base::grepl
[10:19:54.978]                           restarts <- computeRestarts(cond)
[10:19:54.978]                           for (restart in restarts) {
[10:19:54.978]                             name <- restart$name
[10:19:54.978]                             if (is.null(name)) 
[10:19:54.978]                               next
[10:19:54.978]                             if (!grepl(pattern, name)) 
[10:19:54.978]                               next
[10:19:54.978]                             invokeRestart(restart)
[10:19:54.978]                             muffled <- TRUE
[10:19:54.978]                             break
[10:19:54.978]                           }
[10:19:54.978]                         }
[10:19:54.978]                       }
[10:19:54.978]                       invisible(muffled)
[10:19:54.978]                     }
[10:19:54.978]                     muffleCondition(cond, pattern = "^muffle")
[10:19:54.978]                   }
[10:19:54.978]                 }
[10:19:54.978]             }
[10:19:54.978]         }))
[10:19:54.978]     }, error = function(ex) {
[10:19:54.978]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:54.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:54.978]                 ...future.rng), started = ...future.startTime, 
[10:19:54.978]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:54.978]             version = "1.8"), class = "FutureResult")
[10:19:54.978]     }, finally = {
[10:19:54.978]         if (!identical(...future.workdir, getwd())) 
[10:19:54.978]             setwd(...future.workdir)
[10:19:54.978]         {
[10:19:54.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:54.978]                 ...future.oldOptions$nwarnings <- NULL
[10:19:54.978]             }
[10:19:54.978]             base::options(...future.oldOptions)
[10:19:54.978]             if (.Platform$OS.type == "windows") {
[10:19:54.978]                 old_names <- names(...future.oldEnvVars)
[10:19:54.978]                 envs <- base::Sys.getenv()
[10:19:54.978]                 names <- names(envs)
[10:19:54.978]                 common <- intersect(names, old_names)
[10:19:54.978]                 added <- setdiff(names, old_names)
[10:19:54.978]                 removed <- setdiff(old_names, names)
[10:19:54.978]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:54.978]                   envs[common]]
[10:19:54.978]                 NAMES <- toupper(changed)
[10:19:54.978]                 args <- list()
[10:19:54.978]                 for (kk in seq_along(NAMES)) {
[10:19:54.978]                   name <- changed[[kk]]
[10:19:54.978]                   NAME <- NAMES[[kk]]
[10:19:54.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.978]                     next
[10:19:54.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.978]                 }
[10:19:54.978]                 NAMES <- toupper(added)
[10:19:54.978]                 for (kk in seq_along(NAMES)) {
[10:19:54.978]                   name <- added[[kk]]
[10:19:54.978]                   NAME <- NAMES[[kk]]
[10:19:54.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.978]                     next
[10:19:54.978]                   args[[name]] <- ""
[10:19:54.978]                 }
[10:19:54.978]                 NAMES <- toupper(removed)
[10:19:54.978]                 for (kk in seq_along(NAMES)) {
[10:19:54.978]                   name <- removed[[kk]]
[10:19:54.978]                   NAME <- NAMES[[kk]]
[10:19:54.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:54.978]                     next
[10:19:54.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:54.978]                 }
[10:19:54.978]                 if (length(args) > 0) 
[10:19:54.978]                   base::do.call(base::Sys.setenv, args = args)
[10:19:54.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:54.978]             }
[10:19:54.978]             else {
[10:19:54.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:54.978]             }
[10:19:54.978]             {
[10:19:54.978]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:54.978]                   0L) {
[10:19:54.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:54.978]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:54.978]                   base::options(opts)
[10:19:54.978]                 }
[10:19:54.978]                 {
[10:19:54.978]                   {
[10:19:54.978]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:54.978]                     NULL
[10:19:54.978]                   }
[10:19:54.978]                   options(future.plan = NULL)
[10:19:54.978]                   if (is.na(NA_character_)) 
[10:19:54.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:54.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:54.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:54.978]                     .init = FALSE)
[10:19:54.978]                 }
[10:19:54.978]             }
[10:19:54.978]         }
[10:19:54.978]     })
[10:19:54.978]     if (TRUE) {
[10:19:54.978]         base::sink(type = "output", split = FALSE)
[10:19:54.978]         if (TRUE) {
[10:19:54.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:54.978]         }
[10:19:54.978]         else {
[10:19:54.978]             ...future.result["stdout"] <- base::list(NULL)
[10:19:54.978]         }
[10:19:54.978]         base::close(...future.stdout)
[10:19:54.978]         ...future.stdout <- NULL
[10:19:54.978]     }
[10:19:54.978]     ...future.result$conditions <- ...future.conditions
[10:19:54.978]     ...future.result$finished <- base::Sys.time()
[10:19:54.978]     ...future.result
[10:19:54.978] }
[10:19:54.980] Exporting 11 global objects (13.22 KiB) to cluster node #1 ...
[10:19:54.981] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #1 ...
[10:19:55.021] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #1 ... DONE
[10:19:55.022] Exporting ‘x_FUN’ (295 bytes) to cluster node #1 ...
[10:19:55.022] Exporting ‘x_FUN’ (295 bytes) to cluster node #1 ... DONE
[10:19:55.022] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:55.022] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:55.023] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:55.063] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:55.064] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:55.104] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:55.105] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:55.105] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.105] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:55.106] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:55.106] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:55.106] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:55.106] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[10:19:55.106] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[10:19:55.107] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:55.107] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.107] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:55.108] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.108] Exporting 11 global objects (13.22 KiB) to cluster node #1 ... DONE
[10:19:55.108] MultisessionFuture started
[10:19:55.108] - Launch lazy future ... done
[10:19:55.108] run() for ‘MultisessionFuture’ ... done
[10:19:55.108] Created future:
[10:19:55.109] MultisessionFuture:
[10:19:55.109] Label: ‘future_vapply-1’
[10:19:55.109] Expression:
[10:19:55.109] {
[10:19:55.109]     do.call(function(...) {
[10:19:55.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.109]             on.exit(options(oopts), add = TRUE)
[10:19:55.109]         }
[10:19:55.109]         {
[10:19:55.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.109]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.109]             })
[10:19:55.109]         }
[10:19:55.109]     }, args = future.call.arguments)
[10:19:55.109] }
[10:19:55.109] Lazy evaluation: FALSE
[10:19:55.109] Asynchronous evaluation: TRUE
[10:19:55.109] Local evaluation: TRUE
[10:19:55.109] Environment: R_GlobalEnv
[10:19:55.109] Capture standard output: TRUE
[10:19:55.109] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:55.109] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:55.109] Packages: 1 packages (‘future.apply’)
[10:19:55.109] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:55.109] Resolved: FALSE
[10:19:55.109] Value: <not collected>
[10:19:55.109] Conditions captured: <none>
[10:19:55.109] Early signaling: FALSE
[10:19:55.109] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:55.109] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.120] Chunk #1 of 2 ... DONE
[10:19:55.120] Chunk #2 of 2 ...
[10:19:55.121]  - Finding globals in 'X' for chunk #2 ...
[10:19:55.121] getGlobalsAndPackages() ...
[10:19:55.121] Searching for globals...
[10:19:55.121] 
[10:19:55.121] Searching for globals ... DONE
[10:19:55.121] - globals: [0] <none>
[10:19:55.121] getGlobalsAndPackages() ... DONE
[10:19:55.121]    + additional globals found: [n=0] 
[10:19:55.122]    + additional namespaces needed: [n=0] 
[10:19:55.122]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:55.122]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:55.122]  - seeds: <none>
[10:19:55.122]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.122] getGlobalsAndPackages() ...
[10:19:55.122] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.122] Resolving globals: FALSE
[10:19:55.122] Tweak future expression to call with '...' arguments ...
[10:19:55.122] {
[10:19:55.122]     do.call(function(...) {
[10:19:55.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.122]             on.exit(options(oopts), add = TRUE)
[10:19:55.122]         }
[10:19:55.122]         {
[10:19:55.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.122]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.122]             })
[10:19:55.122]         }
[10:19:55.122]     }, args = future.call.arguments)
[10:19:55.122] }
[10:19:55.123] Tweak future expression to call with '...' arguments ... DONE
[10:19:55.123] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.123] - packages: [1] ‘future.apply’
[10:19:55.123] getGlobalsAndPackages() ... DONE
[10:19:55.124] run() for ‘Future’ ...
[10:19:55.124] - state: ‘created’
[10:19:55.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:55.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:55.138]   - Field: ‘node’
[10:19:55.138]   - Field: ‘label’
[10:19:55.138]   - Field: ‘local’
[10:19:55.139]   - Field: ‘owner’
[10:19:55.139]   - Field: ‘envir’
[10:19:55.139]   - Field: ‘workers’
[10:19:55.139]   - Field: ‘packages’
[10:19:55.139]   - Field: ‘gc’
[10:19:55.139]   - Field: ‘conditions’
[10:19:55.139]   - Field: ‘persistent’
[10:19:55.139]   - Field: ‘expr’
[10:19:55.139]   - Field: ‘uuid’
[10:19:55.139]   - Field: ‘seed’
[10:19:55.139]   - Field: ‘version’
[10:19:55.139]   - Field: ‘result’
[10:19:55.140]   - Field: ‘asynchronous’
[10:19:55.140]   - Field: ‘calls’
[10:19:55.140]   - Field: ‘globals’
[10:19:55.140]   - Field: ‘stdout’
[10:19:55.140]   - Field: ‘earlySignal’
[10:19:55.140]   - Field: ‘lazy’
[10:19:55.140]   - Field: ‘state’
[10:19:55.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:55.140] - Launch lazy future ...
[10:19:55.141] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:55.141] Packages needed by future strategies (n = 0): <none>
[10:19:55.141] {
[10:19:55.141]     {
[10:19:55.141]         {
[10:19:55.141]             ...future.startTime <- base::Sys.time()
[10:19:55.141]             {
[10:19:55.141]                 {
[10:19:55.141]                   {
[10:19:55.141]                     {
[10:19:55.141]                       {
[10:19:55.141]                         base::local({
[10:19:55.141]                           has_future <- base::requireNamespace("future", 
[10:19:55.141]                             quietly = TRUE)
[10:19:55.141]                           if (has_future) {
[10:19:55.141]                             ns <- base::getNamespace("future")
[10:19:55.141]                             version <- ns[[".package"]][["version"]]
[10:19:55.141]                             if (is.null(version)) 
[10:19:55.141]                               version <- utils::packageVersion("future")
[10:19:55.141]                           }
[10:19:55.141]                           else {
[10:19:55.141]                             version <- NULL
[10:19:55.141]                           }
[10:19:55.141]                           if (!has_future || version < "1.8.0") {
[10:19:55.141]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:55.141]                               "", base::R.version$version.string), 
[10:19:55.141]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:55.141]                                 base::R.version$platform, 8 * 
[10:19:55.141]                                   base::.Machine$sizeof.pointer), 
[10:19:55.141]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:55.141]                                 "release", "version")], collapse = " "), 
[10:19:55.141]                               hostname = base::Sys.info()[["nodename"]])
[10:19:55.141]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:55.141]                               info)
[10:19:55.141]                             info <- base::paste(info, collapse = "; ")
[10:19:55.141]                             if (!has_future) {
[10:19:55.141]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:55.141]                                 info)
[10:19:55.141]                             }
[10:19:55.141]                             else {
[10:19:55.141]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:55.141]                                 info, version)
[10:19:55.141]                             }
[10:19:55.141]                             base::stop(msg)
[10:19:55.141]                           }
[10:19:55.141]                         })
[10:19:55.141]                       }
[10:19:55.141]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:55.141]                       base::options(mc.cores = 1L)
[10:19:55.141]                     }
[10:19:55.141]                     base::local({
[10:19:55.141]                       for (pkg in "future.apply") {
[10:19:55.141]                         base::loadNamespace(pkg)
[10:19:55.141]                         base::library(pkg, character.only = TRUE)
[10:19:55.141]                       }
[10:19:55.141]                     })
[10:19:55.141]                   }
[10:19:55.141]                   ...future.strategy.old <- future::plan("list")
[10:19:55.141]                   options(future.plan = NULL)
[10:19:55.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:55.141]                 }
[10:19:55.141]                 ...future.workdir <- getwd()
[10:19:55.141]             }
[10:19:55.141]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:55.141]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:55.141]         }
[10:19:55.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:55.141]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:55.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:55.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:55.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:55.141]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:55.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:55.141]             base::names(...future.oldOptions))
[10:19:55.141]     }
[10:19:55.141]     if (FALSE) {
[10:19:55.141]     }
[10:19:55.141]     else {
[10:19:55.141]         if (TRUE) {
[10:19:55.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:55.141]                 open = "w")
[10:19:55.141]         }
[10:19:55.141]         else {
[10:19:55.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:55.141]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:55.141]         }
[10:19:55.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:55.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:55.141]             base::sink(type = "output", split = FALSE)
[10:19:55.141]             base::close(...future.stdout)
[10:19:55.141]         }, add = TRUE)
[10:19:55.141]     }
[10:19:55.141]     ...future.frame <- base::sys.nframe()
[10:19:55.141]     ...future.conditions <- base::list()
[10:19:55.141]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:55.141]     if (FALSE) {
[10:19:55.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:55.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:55.141]     }
[10:19:55.141]     ...future.result <- base::tryCatch({
[10:19:55.141]         base::withCallingHandlers({
[10:19:55.141]             ...future.value <- base::withVisible(base::local({
[10:19:55.141]                 ...future.makeSendCondition <- base::local({
[10:19:55.141]                   sendCondition <- NULL
[10:19:55.141]                   function(frame = 1L) {
[10:19:55.141]                     if (is.function(sendCondition)) 
[10:19:55.141]                       return(sendCondition)
[10:19:55.141]                     ns <- getNamespace("parallel")
[10:19:55.141]                     if (exists("sendData", mode = "function", 
[10:19:55.141]                       envir = ns)) {
[10:19:55.141]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:55.141]                         envir = ns)
[10:19:55.141]                       envir <- sys.frame(frame)
[10:19:55.141]                       master <- NULL
[10:19:55.141]                       while (!identical(envir, .GlobalEnv) && 
[10:19:55.141]                         !identical(envir, emptyenv())) {
[10:19:55.141]                         if (exists("master", mode = "list", envir = envir, 
[10:19:55.141]                           inherits = FALSE)) {
[10:19:55.141]                           master <- get("master", mode = "list", 
[10:19:55.141]                             envir = envir, inherits = FALSE)
[10:19:55.141]                           if (inherits(master, c("SOCKnode", 
[10:19:55.141]                             "SOCK0node"))) {
[10:19:55.141]                             sendCondition <<- function(cond) {
[10:19:55.141]                               data <- list(type = "VALUE", value = cond, 
[10:19:55.141]                                 success = TRUE)
[10:19:55.141]                               parallel_sendData(master, data)
[10:19:55.141]                             }
[10:19:55.141]                             return(sendCondition)
[10:19:55.141]                           }
[10:19:55.141]                         }
[10:19:55.141]                         frame <- frame + 1L
[10:19:55.141]                         envir <- sys.frame(frame)
[10:19:55.141]                       }
[10:19:55.141]                     }
[10:19:55.141]                     sendCondition <<- function(cond) NULL
[10:19:55.141]                   }
[10:19:55.141]                 })
[10:19:55.141]                 withCallingHandlers({
[10:19:55.141]                   {
[10:19:55.141]                     do.call(function(...) {
[10:19:55.141]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.141]                       if (!identical(...future.globals.maxSize.org, 
[10:19:55.141]                         ...future.globals.maxSize)) {
[10:19:55.141]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.141]                         on.exit(options(oopts), add = TRUE)
[10:19:55.141]                       }
[10:19:55.141]                       {
[10:19:55.141]                         lapply(seq_along(...future.elements_ii), 
[10:19:55.141]                           FUN = function(jj) {
[10:19:55.141]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.141]                             ...future.FUN(...future.X_jj, ...)
[10:19:55.141]                           })
[10:19:55.141]                       }
[10:19:55.141]                     }, args = future.call.arguments)
[10:19:55.141]                   }
[10:19:55.141]                 }, immediateCondition = function(cond) {
[10:19:55.141]                   sendCondition <- ...future.makeSendCondition()
[10:19:55.141]                   sendCondition(cond)
[10:19:55.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.141]                   {
[10:19:55.141]                     inherits <- base::inherits
[10:19:55.141]                     invokeRestart <- base::invokeRestart
[10:19:55.141]                     is.null <- base::is.null
[10:19:55.141]                     muffled <- FALSE
[10:19:55.141]                     if (inherits(cond, "message")) {
[10:19:55.141]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:55.141]                       if (muffled) 
[10:19:55.141]                         invokeRestart("muffleMessage")
[10:19:55.141]                     }
[10:19:55.141]                     else if (inherits(cond, "warning")) {
[10:19:55.141]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:55.141]                       if (muffled) 
[10:19:55.141]                         invokeRestart("muffleWarning")
[10:19:55.141]                     }
[10:19:55.141]                     else if (inherits(cond, "condition")) {
[10:19:55.141]                       if (!is.null(pattern)) {
[10:19:55.141]                         computeRestarts <- base::computeRestarts
[10:19:55.141]                         grepl <- base::grepl
[10:19:55.141]                         restarts <- computeRestarts(cond)
[10:19:55.141]                         for (restart in restarts) {
[10:19:55.141]                           name <- restart$name
[10:19:55.141]                           if (is.null(name)) 
[10:19:55.141]                             next
[10:19:55.141]                           if (!grepl(pattern, name)) 
[10:19:55.141]                             next
[10:19:55.141]                           invokeRestart(restart)
[10:19:55.141]                           muffled <- TRUE
[10:19:55.141]                           break
[10:19:55.141]                         }
[10:19:55.141]                       }
[10:19:55.141]                     }
[10:19:55.141]                     invisible(muffled)
[10:19:55.141]                   }
[10:19:55.141]                   muffleCondition(cond)
[10:19:55.141]                 })
[10:19:55.141]             }))
[10:19:55.141]             future::FutureResult(value = ...future.value$value, 
[10:19:55.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.141]                   ...future.rng), globalenv = if (FALSE) 
[10:19:55.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:55.141]                     ...future.globalenv.names))
[10:19:55.141]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:55.141]         }, condition = base::local({
[10:19:55.141]             c <- base::c
[10:19:55.141]             inherits <- base::inherits
[10:19:55.141]             invokeRestart <- base::invokeRestart
[10:19:55.141]             length <- base::length
[10:19:55.141]             list <- base::list
[10:19:55.141]             seq.int <- base::seq.int
[10:19:55.141]             signalCondition <- base::signalCondition
[10:19:55.141]             sys.calls <- base::sys.calls
[10:19:55.141]             `[[` <- base::`[[`
[10:19:55.141]             `+` <- base::`+`
[10:19:55.141]             `<<-` <- base::`<<-`
[10:19:55.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:55.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:55.141]                   3L)]
[10:19:55.141]             }
[10:19:55.141]             function(cond) {
[10:19:55.141]                 is_error <- inherits(cond, "error")
[10:19:55.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:55.141]                   NULL)
[10:19:55.141]                 if (is_error) {
[10:19:55.141]                   sessionInformation <- function() {
[10:19:55.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:55.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:55.141]                       search = base::search(), system = base::Sys.info())
[10:19:55.141]                   }
[10:19:55.141]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:55.141]                     cond$call), session = sessionInformation(), 
[10:19:55.141]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:55.141]                   signalCondition(cond)
[10:19:55.141]                 }
[10:19:55.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:55.141]                 "immediateCondition"))) {
[10:19:55.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:55.141]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:55.141]                   if (TRUE && !signal) {
[10:19:55.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.141]                     {
[10:19:55.141]                       inherits <- base::inherits
[10:19:55.141]                       invokeRestart <- base::invokeRestart
[10:19:55.141]                       is.null <- base::is.null
[10:19:55.141]                       muffled <- FALSE
[10:19:55.141]                       if (inherits(cond, "message")) {
[10:19:55.141]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.141]                         if (muffled) 
[10:19:55.141]                           invokeRestart("muffleMessage")
[10:19:55.141]                       }
[10:19:55.141]                       else if (inherits(cond, "warning")) {
[10:19:55.141]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.141]                         if (muffled) 
[10:19:55.141]                           invokeRestart("muffleWarning")
[10:19:55.141]                       }
[10:19:55.141]                       else if (inherits(cond, "condition")) {
[10:19:55.141]                         if (!is.null(pattern)) {
[10:19:55.141]                           computeRestarts <- base::computeRestarts
[10:19:55.141]                           grepl <- base::grepl
[10:19:55.141]                           restarts <- computeRestarts(cond)
[10:19:55.141]                           for (restart in restarts) {
[10:19:55.141]                             name <- restart$name
[10:19:55.141]                             if (is.null(name)) 
[10:19:55.141]                               next
[10:19:55.141]                             if (!grepl(pattern, name)) 
[10:19:55.141]                               next
[10:19:55.141]                             invokeRestart(restart)
[10:19:55.141]                             muffled <- TRUE
[10:19:55.141]                             break
[10:19:55.141]                           }
[10:19:55.141]                         }
[10:19:55.141]                       }
[10:19:55.141]                       invisible(muffled)
[10:19:55.141]                     }
[10:19:55.141]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.141]                   }
[10:19:55.141]                 }
[10:19:55.141]                 else {
[10:19:55.141]                   if (TRUE) {
[10:19:55.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.141]                     {
[10:19:55.141]                       inherits <- base::inherits
[10:19:55.141]                       invokeRestart <- base::invokeRestart
[10:19:55.141]                       is.null <- base::is.null
[10:19:55.141]                       muffled <- FALSE
[10:19:55.141]                       if (inherits(cond, "message")) {
[10:19:55.141]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.141]                         if (muffled) 
[10:19:55.141]                           invokeRestart("muffleMessage")
[10:19:55.141]                       }
[10:19:55.141]                       else if (inherits(cond, "warning")) {
[10:19:55.141]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.141]                         if (muffled) 
[10:19:55.141]                           invokeRestart("muffleWarning")
[10:19:55.141]                       }
[10:19:55.141]                       else if (inherits(cond, "condition")) {
[10:19:55.141]                         if (!is.null(pattern)) {
[10:19:55.141]                           computeRestarts <- base::computeRestarts
[10:19:55.141]                           grepl <- base::grepl
[10:19:55.141]                           restarts <- computeRestarts(cond)
[10:19:55.141]                           for (restart in restarts) {
[10:19:55.141]                             name <- restart$name
[10:19:55.141]                             if (is.null(name)) 
[10:19:55.141]                               next
[10:19:55.141]                             if (!grepl(pattern, name)) 
[10:19:55.141]                               next
[10:19:55.141]                             invokeRestart(restart)
[10:19:55.141]                             muffled <- TRUE
[10:19:55.141]                             break
[10:19:55.141]                           }
[10:19:55.141]                         }
[10:19:55.141]                       }
[10:19:55.141]                       invisible(muffled)
[10:19:55.141]                     }
[10:19:55.141]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.141]                   }
[10:19:55.141]                 }
[10:19:55.141]             }
[10:19:55.141]         }))
[10:19:55.141]     }, error = function(ex) {
[10:19:55.141]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:55.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.141]                 ...future.rng), started = ...future.startTime, 
[10:19:55.141]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:55.141]             version = "1.8"), class = "FutureResult")
[10:19:55.141]     }, finally = {
[10:19:55.141]         if (!identical(...future.workdir, getwd())) 
[10:19:55.141]             setwd(...future.workdir)
[10:19:55.141]         {
[10:19:55.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:55.141]                 ...future.oldOptions$nwarnings <- NULL
[10:19:55.141]             }
[10:19:55.141]             base::options(...future.oldOptions)
[10:19:55.141]             if (.Platform$OS.type == "windows") {
[10:19:55.141]                 old_names <- names(...future.oldEnvVars)
[10:19:55.141]                 envs <- base::Sys.getenv()
[10:19:55.141]                 names <- names(envs)
[10:19:55.141]                 common <- intersect(names, old_names)
[10:19:55.141]                 added <- setdiff(names, old_names)
[10:19:55.141]                 removed <- setdiff(old_names, names)
[10:19:55.141]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:55.141]                   envs[common]]
[10:19:55.141]                 NAMES <- toupper(changed)
[10:19:55.141]                 args <- list()
[10:19:55.141]                 for (kk in seq_along(NAMES)) {
[10:19:55.141]                   name <- changed[[kk]]
[10:19:55.141]                   NAME <- NAMES[[kk]]
[10:19:55.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.141]                     next
[10:19:55.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.141]                 }
[10:19:55.141]                 NAMES <- toupper(added)
[10:19:55.141]                 for (kk in seq_along(NAMES)) {
[10:19:55.141]                   name <- added[[kk]]
[10:19:55.141]                   NAME <- NAMES[[kk]]
[10:19:55.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.141]                     next
[10:19:55.141]                   args[[name]] <- ""
[10:19:55.141]                 }
[10:19:55.141]                 NAMES <- toupper(removed)
[10:19:55.141]                 for (kk in seq_along(NAMES)) {
[10:19:55.141]                   name <- removed[[kk]]
[10:19:55.141]                   NAME <- NAMES[[kk]]
[10:19:55.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.141]                     next
[10:19:55.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.141]                 }
[10:19:55.141]                 if (length(args) > 0) 
[10:19:55.141]                   base::do.call(base::Sys.setenv, args = args)
[10:19:55.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:55.141]             }
[10:19:55.141]             else {
[10:19:55.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:55.141]             }
[10:19:55.141]             {
[10:19:55.141]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:55.141]                   0L) {
[10:19:55.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:55.141]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:55.141]                   base::options(opts)
[10:19:55.141]                 }
[10:19:55.141]                 {
[10:19:55.141]                   {
[10:19:55.141]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:55.141]                     NULL
[10:19:55.141]                   }
[10:19:55.141]                   options(future.plan = NULL)
[10:19:55.141]                   if (is.na(NA_character_)) 
[10:19:55.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:55.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:55.141]                     .init = FALSE)
[10:19:55.141]                 }
[10:19:55.141]             }
[10:19:55.141]         }
[10:19:55.141]     })
[10:19:55.141]     if (TRUE) {
[10:19:55.141]         base::sink(type = "output", split = FALSE)
[10:19:55.141]         if (TRUE) {
[10:19:55.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:55.141]         }
[10:19:55.141]         else {
[10:19:55.141]             ...future.result["stdout"] <- base::list(NULL)
[10:19:55.141]         }
[10:19:55.141]         base::close(...future.stdout)
[10:19:55.141]         ...future.stdout <- NULL
[10:19:55.141]     }
[10:19:55.141]     ...future.result$conditions <- ...future.conditions
[10:19:55.141]     ...future.result$finished <- base::Sys.time()
[10:19:55.141]     ...future.result
[10:19:55.141] }
[10:19:55.144] Exporting 11 global objects (13.22 KiB) to cluster node #2 ...
[10:19:55.144] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #2 ...
[10:19:55.185] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #2 ... DONE
[10:19:55.186] Exporting ‘x_FUN’ (295 bytes) to cluster node #2 ...
[10:19:55.186] Exporting ‘x_FUN’ (295 bytes) to cluster node #2 ... DONE
[10:19:55.186] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:55.187] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:55.187] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:55.227] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:55.228] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:55.268] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:55.268] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:55.269] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:55.269] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:55.269] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:55.269] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:55.270] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:55.270] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[10:19:55.270] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[10:19:55.270] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:55.271] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:55.271] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:55.271] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:55.271] Exporting 11 global objects (13.22 KiB) to cluster node #2 ... DONE
[10:19:55.272] MultisessionFuture started
[10:19:55.272] - Launch lazy future ... done
[10:19:55.272] run() for ‘MultisessionFuture’ ... done
[10:19:55.272] Created future:
[10:19:55.272] MultisessionFuture:
[10:19:55.272] Label: ‘future_vapply-2’
[10:19:55.272] Expression:
[10:19:55.272] {
[10:19:55.272]     do.call(function(...) {
[10:19:55.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.272]             on.exit(options(oopts), add = TRUE)
[10:19:55.272]         }
[10:19:55.272]         {
[10:19:55.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.272]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.272]             })
[10:19:55.272]         }
[10:19:55.272]     }, args = future.call.arguments)
[10:19:55.272] }
[10:19:55.272] Lazy evaluation: FALSE
[10:19:55.272] Asynchronous evaluation: TRUE
[10:19:55.272] Local evaluation: TRUE
[10:19:55.272] Environment: R_GlobalEnv
[10:19:55.272] Capture standard output: TRUE
[10:19:55.272] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:55.272] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:55.272] Packages: 1 packages (‘future.apply’)
[10:19:55.272] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:55.272] Resolved: FALSE
[10:19:55.272] Value: <not collected>
[10:19:55.272] Conditions captured: <none>
[10:19:55.272] Early signaling: FALSE
[10:19:55.272] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:55.272] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.284] Chunk #2 of 2 ... DONE
[10:19:55.284] Launching 2 futures (chunks) ... DONE
[10:19:55.284] Resolving 2 futures (chunks) ...
[10:19:55.284] resolve() on list ...
[10:19:55.284]  recursive: 0
[10:19:55.284]  length: 2
[10:19:55.284] 
[10:19:55.285] receiveMessageFromWorker() for ClusterFuture ...
[10:19:55.285] - Validating connection of MultisessionFuture
[10:19:55.285] - received message: FutureResult
[10:19:55.285] - Received FutureResult
[10:19:55.285] - Erased future from FutureRegistry
[10:19:55.285] result() for ClusterFuture ...
[10:19:55.286] - result already collected: FutureResult
[10:19:55.286] result() for ClusterFuture ... done
[10:19:55.286] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:55.286] Future #1
[10:19:55.286] result() for ClusterFuture ...
[10:19:55.286] - result already collected: FutureResult
[10:19:55.286] result() for ClusterFuture ... done
[10:19:55.286] result() for ClusterFuture ...
[10:19:55.286] - result already collected: FutureResult
[10:19:55.286] result() for ClusterFuture ... done
[10:19:55.286] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:55.286] - nx: 2
[10:19:55.287] - relay: TRUE
[10:19:55.287] - stdout: TRUE
[10:19:55.287] - signal: TRUE
[10:19:55.287] - resignal: FALSE
[10:19:55.287] - force: TRUE
[10:19:55.287] - relayed: [n=2] FALSE, FALSE
[10:19:55.287] - queued futures: [n=2] FALSE, FALSE
[10:19:55.287]  - until=1
[10:19:55.287]  - relaying element #1
[10:19:55.287] result() for ClusterFuture ...
[10:19:55.287] - result already collected: FutureResult
[10:19:55.287] result() for ClusterFuture ... done
[10:19:55.287] result() for ClusterFuture ...
[10:19:55.288] - result already collected: FutureResult
[10:19:55.288] result() for ClusterFuture ... done
[10:19:55.288] result() for ClusterFuture ...
[10:19:55.288] - result already collected: FutureResult
[10:19:55.288] result() for ClusterFuture ... done
[10:19:55.288] result() for ClusterFuture ...
[10:19:55.288] - result already collected: FutureResult
[10:19:55.288] result() for ClusterFuture ... done
[10:19:55.288] - relayed: [n=2] TRUE, FALSE
[10:19:55.288] - queued futures: [n=2] TRUE, FALSE
[10:19:55.288] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:55.289]  length: 1 (resolved future 1)
[10:19:55.314] receiveMessageFromWorker() for ClusterFuture ...
[10:19:55.315] - Validating connection of MultisessionFuture
[10:19:55.315] - received message: FutureResult
[10:19:55.315] - Received FutureResult
[10:19:55.315] - Erased future from FutureRegistry
[10:19:55.315] result() for ClusterFuture ...
[10:19:55.315] - result already collected: FutureResult
[10:19:55.315] result() for ClusterFuture ... done
[10:19:55.315] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:55.315] Future #2
[10:19:55.316] result() for ClusterFuture ...
[10:19:55.316] - result already collected: FutureResult
[10:19:55.316] result() for ClusterFuture ... done
[10:19:55.316] result() for ClusterFuture ...
[10:19:55.316] - result already collected: FutureResult
[10:19:55.316] result() for ClusterFuture ... done
[10:19:55.316] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:55.316] - nx: 2
[10:19:55.316] - relay: TRUE
[10:19:55.316] - stdout: TRUE
[10:19:55.316] - signal: TRUE
[10:19:55.316] - resignal: FALSE
[10:19:55.317] - force: TRUE
[10:19:55.317] - relayed: [n=2] TRUE, FALSE
[10:19:55.317] - queued futures: [n=2] TRUE, FALSE
[10:19:55.317]  - until=2
[10:19:55.317]  - relaying element #2
[10:19:55.317] result() for ClusterFuture ...
[10:19:55.317] - result already collected: FutureResult
[10:19:55.317] result() for ClusterFuture ... done
[10:19:55.317] result() for ClusterFuture ...
[10:19:55.317] - result already collected: FutureResult
[10:19:55.317] result() for ClusterFuture ... done
[10:19:55.318] result() for ClusterFuture ...
[10:19:55.318] - result already collected: FutureResult
[10:19:55.318] result() for ClusterFuture ... done
[10:19:55.318] result() for ClusterFuture ...
[10:19:55.318] - result already collected: FutureResult
[10:19:55.318] result() for ClusterFuture ... done
[10:19:55.318] - relayed: [n=2] TRUE, TRUE
[10:19:55.318] - queued futures: [n=2] TRUE, TRUE
[10:19:55.318] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:55.318]  length: 0 (resolved future 2)
[10:19:55.318] Relaying remaining futures
[10:19:55.318] signalConditionsASAP(NULL, pos=0) ...
[10:19:55.319] - nx: 2
[10:19:55.319] - relay: TRUE
[10:19:55.319] - stdout: TRUE
[10:19:55.319] - signal: TRUE
[10:19:55.319] - resignal: FALSE
[10:19:55.319] - force: TRUE
[10:19:55.319] - relayed: [n=2] TRUE, TRUE
[10:19:55.319] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:55.319] - relayed: [n=2] TRUE, TRUE
[10:19:55.319] - queued futures: [n=2] TRUE, TRUE
[10:19:55.319] signalConditionsASAP(NULL, pos=0) ... done
[10:19:55.319] resolve() on list ... DONE
[10:19:55.320] result() for ClusterFuture ...
[10:19:55.320] - result already collected: FutureResult
[10:19:55.320] result() for ClusterFuture ... done
[10:19:55.320] result() for ClusterFuture ...
[10:19:55.320] - result already collected: FutureResult
[10:19:55.320] result() for ClusterFuture ... done
[10:19:55.320] result() for ClusterFuture ...
[10:19:55.320] - result already collected: FutureResult
[10:19:55.320] result() for ClusterFuture ... done
[10:19:55.320] result() for ClusterFuture ...
[10:19:55.320] - result already collected: FutureResult
[10:19:55.320] result() for ClusterFuture ... done
[10:19:55.321]  - Number of value chunks collected: 2
[10:19:55.321] Resolving 2 futures (chunks) ... DONE
[10:19:55.321] Reducing values from 2 chunks ...
[10:19:55.321]  - Number of values collected after concatenation: 10
[10:19:55.321]  - Number of values expected: 10
[10:19:55.321] Reducing values from 2 chunks ... DONE
[10:19:55.321] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:19:55.322] future_lapply() ...
[10:19:55.325] Number of chunks: 2
[10:19:55.325] getGlobalsAndPackagesXApply() ...
[10:19:55.325]  - future.globals: TRUE
[10:19:55.326] getGlobalsAndPackages() ...
[10:19:55.326] Searching for globals...
[10:19:55.329] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:19:55.329] Searching for globals ... DONE
[10:19:55.329] Resolving globals: FALSE
[10:19:55.330] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[10:19:55.331] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:55.331] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:55.331] - packages: [1] ‘future.apply’
[10:19:55.331] getGlobalsAndPackages() ... DONE
[10:19:55.331]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:55.331]  - needed namespaces: [n=1] ‘future.apply’
[10:19:55.331] Finding globals ... DONE
[10:19:55.331]  - use_args: TRUE
[10:19:55.331]  - Getting '...' globals ...
[10:19:55.332] resolve() on list ...
[10:19:55.332]  recursive: 0
[10:19:55.332]  length: 1
[10:19:55.332]  elements: ‘...’
[10:19:55.332]  length: 0 (resolved future 1)
[10:19:55.332] resolve() on list ... DONE
[10:19:55.332]    - '...' content: [n=0] 
[10:19:55.332] List of 1
[10:19:55.332]  $ ...: list()
[10:19:55.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:55.332]  - attr(*, "where")=List of 1
[10:19:55.332]   ..$ ...:<environment: 0x55c6a1dc88b0> 
[10:19:55.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:55.332]  - attr(*, "resolved")= logi TRUE
[10:19:55.332]  - attr(*, "total_size")= num NA
[10:19:55.335]  - Getting '...' globals ... DONE
[10:19:55.335] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:55.335] List of 8
[10:19:55.335]  $ ...future.FUN:function (x, ...)  
[10:19:55.335]  $ x_FUN        :function (x)  
[10:19:55.335]  $ times        : int 0
[10:19:55.335]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:55.335]  $ stop_if_not  :function (...)  
[10:19:55.335]  $ dim          : NULL
[10:19:55.335]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:55.335]  $ ...          : list()
[10:19:55.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:55.335]  - attr(*, "where")=List of 8
[10:19:55.335]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:55.335]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:55.335]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:55.335]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:55.335]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:55.335]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:55.335]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:55.335]   ..$ ...          :<environment: 0x55c6a1dc88b0> 
[10:19:55.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:55.335]  - attr(*, "resolved")= logi FALSE
[10:19:55.335]  - attr(*, "total_size")= num 23453
[10:19:55.340] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:55.340] getGlobalsAndPackagesXApply() ... DONE
[10:19:55.340] Number of futures (= number of chunks): 2
[10:19:55.340] Launching 2 futures (chunks) ...
[10:19:55.341] Chunk #1 of 2 ...
[10:19:55.341]  - Finding globals in 'X' for chunk #1 ...
[10:19:55.341] getGlobalsAndPackages() ...
[10:19:55.341] Searching for globals...
[10:19:55.341] 
[10:19:55.341] Searching for globals ... DONE
[10:19:55.341] - globals: [0] <none>
[10:19:55.341] getGlobalsAndPackages() ... DONE
[10:19:55.341]    + additional globals found: [n=0] 
[10:19:55.342]    + additional namespaces needed: [n=0] 
[10:19:55.342]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:55.342]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:55.342]  - seeds: <none>
[10:19:55.342]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.342] getGlobalsAndPackages() ...
[10:19:55.342] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.342] Resolving globals: FALSE
[10:19:55.342] Tweak future expression to call with '...' arguments ...
[10:19:55.342] {
[10:19:55.342]     do.call(function(...) {
[10:19:55.342]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.342]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.342]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.342]             on.exit(options(oopts), add = TRUE)
[10:19:55.342]         }
[10:19:55.342]         {
[10:19:55.342]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.342]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.342]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.342]             })
[10:19:55.342]         }
[10:19:55.342]     }, args = future.call.arguments)
[10:19:55.342] }
[10:19:55.343] Tweak future expression to call with '...' arguments ... DONE
[10:19:55.343] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.343] - packages: [1] ‘future.apply’
[10:19:55.343] getGlobalsAndPackages() ... DONE
[10:19:55.344] run() for ‘Future’ ...
[10:19:55.344] - state: ‘created’
[10:19:55.344] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:55.358] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:55.358]   - Field: ‘node’
[10:19:55.358]   - Field: ‘label’
[10:19:55.358]   - Field: ‘local’
[10:19:55.358]   - Field: ‘owner’
[10:19:55.358]   - Field: ‘envir’
[10:19:55.359]   - Field: ‘workers’
[10:19:55.359]   - Field: ‘packages’
[10:19:55.359]   - Field: ‘gc’
[10:19:55.359]   - Field: ‘conditions’
[10:19:55.359]   - Field: ‘persistent’
[10:19:55.359]   - Field: ‘expr’
[10:19:55.359]   - Field: ‘uuid’
[10:19:55.359]   - Field: ‘seed’
[10:19:55.359]   - Field: ‘version’
[10:19:55.359]   - Field: ‘result’
[10:19:55.359]   - Field: ‘asynchronous’
[10:19:55.359]   - Field: ‘calls’
[10:19:55.360]   - Field: ‘globals’
[10:19:55.360]   - Field: ‘stdout’
[10:19:55.360]   - Field: ‘earlySignal’
[10:19:55.360]   - Field: ‘lazy’
[10:19:55.360]   - Field: ‘state’
[10:19:55.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:55.360] - Launch lazy future ...
[10:19:55.360] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:55.360] Packages needed by future strategies (n = 0): <none>
[10:19:55.361] {
[10:19:55.361]     {
[10:19:55.361]         {
[10:19:55.361]             ...future.startTime <- base::Sys.time()
[10:19:55.361]             {
[10:19:55.361]                 {
[10:19:55.361]                   {
[10:19:55.361]                     {
[10:19:55.361]                       {
[10:19:55.361]                         base::local({
[10:19:55.361]                           has_future <- base::requireNamespace("future", 
[10:19:55.361]                             quietly = TRUE)
[10:19:55.361]                           if (has_future) {
[10:19:55.361]                             ns <- base::getNamespace("future")
[10:19:55.361]                             version <- ns[[".package"]][["version"]]
[10:19:55.361]                             if (is.null(version)) 
[10:19:55.361]                               version <- utils::packageVersion("future")
[10:19:55.361]                           }
[10:19:55.361]                           else {
[10:19:55.361]                             version <- NULL
[10:19:55.361]                           }
[10:19:55.361]                           if (!has_future || version < "1.8.0") {
[10:19:55.361]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:55.361]                               "", base::R.version$version.string), 
[10:19:55.361]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:55.361]                                 base::R.version$platform, 8 * 
[10:19:55.361]                                   base::.Machine$sizeof.pointer), 
[10:19:55.361]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:55.361]                                 "release", "version")], collapse = " "), 
[10:19:55.361]                               hostname = base::Sys.info()[["nodename"]])
[10:19:55.361]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:55.361]                               info)
[10:19:55.361]                             info <- base::paste(info, collapse = "; ")
[10:19:55.361]                             if (!has_future) {
[10:19:55.361]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:55.361]                                 info)
[10:19:55.361]                             }
[10:19:55.361]                             else {
[10:19:55.361]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:55.361]                                 info, version)
[10:19:55.361]                             }
[10:19:55.361]                             base::stop(msg)
[10:19:55.361]                           }
[10:19:55.361]                         })
[10:19:55.361]                       }
[10:19:55.361]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:55.361]                       base::options(mc.cores = 1L)
[10:19:55.361]                     }
[10:19:55.361]                     base::local({
[10:19:55.361]                       for (pkg in "future.apply") {
[10:19:55.361]                         base::loadNamespace(pkg)
[10:19:55.361]                         base::library(pkg, character.only = TRUE)
[10:19:55.361]                       }
[10:19:55.361]                     })
[10:19:55.361]                   }
[10:19:55.361]                   ...future.strategy.old <- future::plan("list")
[10:19:55.361]                   options(future.plan = NULL)
[10:19:55.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:55.361]                 }
[10:19:55.361]                 ...future.workdir <- getwd()
[10:19:55.361]             }
[10:19:55.361]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:55.361]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:55.361]         }
[10:19:55.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:55.361]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:55.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:55.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:55.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:55.361]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:55.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:55.361]             base::names(...future.oldOptions))
[10:19:55.361]     }
[10:19:55.361]     if (FALSE) {
[10:19:55.361]     }
[10:19:55.361]     else {
[10:19:55.361]         if (TRUE) {
[10:19:55.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:55.361]                 open = "w")
[10:19:55.361]         }
[10:19:55.361]         else {
[10:19:55.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:55.361]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:55.361]         }
[10:19:55.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:55.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:55.361]             base::sink(type = "output", split = FALSE)
[10:19:55.361]             base::close(...future.stdout)
[10:19:55.361]         }, add = TRUE)
[10:19:55.361]     }
[10:19:55.361]     ...future.frame <- base::sys.nframe()
[10:19:55.361]     ...future.conditions <- base::list()
[10:19:55.361]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:55.361]     if (FALSE) {
[10:19:55.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:55.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:55.361]     }
[10:19:55.361]     ...future.result <- base::tryCatch({
[10:19:55.361]         base::withCallingHandlers({
[10:19:55.361]             ...future.value <- base::withVisible(base::local({
[10:19:55.361]                 ...future.makeSendCondition <- base::local({
[10:19:55.361]                   sendCondition <- NULL
[10:19:55.361]                   function(frame = 1L) {
[10:19:55.361]                     if (is.function(sendCondition)) 
[10:19:55.361]                       return(sendCondition)
[10:19:55.361]                     ns <- getNamespace("parallel")
[10:19:55.361]                     if (exists("sendData", mode = "function", 
[10:19:55.361]                       envir = ns)) {
[10:19:55.361]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:55.361]                         envir = ns)
[10:19:55.361]                       envir <- sys.frame(frame)
[10:19:55.361]                       master <- NULL
[10:19:55.361]                       while (!identical(envir, .GlobalEnv) && 
[10:19:55.361]                         !identical(envir, emptyenv())) {
[10:19:55.361]                         if (exists("master", mode = "list", envir = envir, 
[10:19:55.361]                           inherits = FALSE)) {
[10:19:55.361]                           master <- get("master", mode = "list", 
[10:19:55.361]                             envir = envir, inherits = FALSE)
[10:19:55.361]                           if (inherits(master, c("SOCKnode", 
[10:19:55.361]                             "SOCK0node"))) {
[10:19:55.361]                             sendCondition <<- function(cond) {
[10:19:55.361]                               data <- list(type = "VALUE", value = cond, 
[10:19:55.361]                                 success = TRUE)
[10:19:55.361]                               parallel_sendData(master, data)
[10:19:55.361]                             }
[10:19:55.361]                             return(sendCondition)
[10:19:55.361]                           }
[10:19:55.361]                         }
[10:19:55.361]                         frame <- frame + 1L
[10:19:55.361]                         envir <- sys.frame(frame)
[10:19:55.361]                       }
[10:19:55.361]                     }
[10:19:55.361]                     sendCondition <<- function(cond) NULL
[10:19:55.361]                   }
[10:19:55.361]                 })
[10:19:55.361]                 withCallingHandlers({
[10:19:55.361]                   {
[10:19:55.361]                     do.call(function(...) {
[10:19:55.361]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.361]                       if (!identical(...future.globals.maxSize.org, 
[10:19:55.361]                         ...future.globals.maxSize)) {
[10:19:55.361]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.361]                         on.exit(options(oopts), add = TRUE)
[10:19:55.361]                       }
[10:19:55.361]                       {
[10:19:55.361]                         lapply(seq_along(...future.elements_ii), 
[10:19:55.361]                           FUN = function(jj) {
[10:19:55.361]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.361]                             ...future.FUN(...future.X_jj, ...)
[10:19:55.361]                           })
[10:19:55.361]                       }
[10:19:55.361]                     }, args = future.call.arguments)
[10:19:55.361]                   }
[10:19:55.361]                 }, immediateCondition = function(cond) {
[10:19:55.361]                   sendCondition <- ...future.makeSendCondition()
[10:19:55.361]                   sendCondition(cond)
[10:19:55.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.361]                   {
[10:19:55.361]                     inherits <- base::inherits
[10:19:55.361]                     invokeRestart <- base::invokeRestart
[10:19:55.361]                     is.null <- base::is.null
[10:19:55.361]                     muffled <- FALSE
[10:19:55.361]                     if (inherits(cond, "message")) {
[10:19:55.361]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:55.361]                       if (muffled) 
[10:19:55.361]                         invokeRestart("muffleMessage")
[10:19:55.361]                     }
[10:19:55.361]                     else if (inherits(cond, "warning")) {
[10:19:55.361]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:55.361]                       if (muffled) 
[10:19:55.361]                         invokeRestart("muffleWarning")
[10:19:55.361]                     }
[10:19:55.361]                     else if (inherits(cond, "condition")) {
[10:19:55.361]                       if (!is.null(pattern)) {
[10:19:55.361]                         computeRestarts <- base::computeRestarts
[10:19:55.361]                         grepl <- base::grepl
[10:19:55.361]                         restarts <- computeRestarts(cond)
[10:19:55.361]                         for (restart in restarts) {
[10:19:55.361]                           name <- restart$name
[10:19:55.361]                           if (is.null(name)) 
[10:19:55.361]                             next
[10:19:55.361]                           if (!grepl(pattern, name)) 
[10:19:55.361]                             next
[10:19:55.361]                           invokeRestart(restart)
[10:19:55.361]                           muffled <- TRUE
[10:19:55.361]                           break
[10:19:55.361]                         }
[10:19:55.361]                       }
[10:19:55.361]                     }
[10:19:55.361]                     invisible(muffled)
[10:19:55.361]                   }
[10:19:55.361]                   muffleCondition(cond)
[10:19:55.361]                 })
[10:19:55.361]             }))
[10:19:55.361]             future::FutureResult(value = ...future.value$value, 
[10:19:55.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.361]                   ...future.rng), globalenv = if (FALSE) 
[10:19:55.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:55.361]                     ...future.globalenv.names))
[10:19:55.361]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:55.361]         }, condition = base::local({
[10:19:55.361]             c <- base::c
[10:19:55.361]             inherits <- base::inherits
[10:19:55.361]             invokeRestart <- base::invokeRestart
[10:19:55.361]             length <- base::length
[10:19:55.361]             list <- base::list
[10:19:55.361]             seq.int <- base::seq.int
[10:19:55.361]             signalCondition <- base::signalCondition
[10:19:55.361]             sys.calls <- base::sys.calls
[10:19:55.361]             `[[` <- base::`[[`
[10:19:55.361]             `+` <- base::`+`
[10:19:55.361]             `<<-` <- base::`<<-`
[10:19:55.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:55.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:55.361]                   3L)]
[10:19:55.361]             }
[10:19:55.361]             function(cond) {
[10:19:55.361]                 is_error <- inherits(cond, "error")
[10:19:55.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:55.361]                   NULL)
[10:19:55.361]                 if (is_error) {
[10:19:55.361]                   sessionInformation <- function() {
[10:19:55.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:55.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:55.361]                       search = base::search(), system = base::Sys.info())
[10:19:55.361]                   }
[10:19:55.361]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:55.361]                     cond$call), session = sessionInformation(), 
[10:19:55.361]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:55.361]                   signalCondition(cond)
[10:19:55.361]                 }
[10:19:55.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:55.361]                 "immediateCondition"))) {
[10:19:55.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:55.361]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:55.361]                   if (TRUE && !signal) {
[10:19:55.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.361]                     {
[10:19:55.361]                       inherits <- base::inherits
[10:19:55.361]                       invokeRestart <- base::invokeRestart
[10:19:55.361]                       is.null <- base::is.null
[10:19:55.361]                       muffled <- FALSE
[10:19:55.361]                       if (inherits(cond, "message")) {
[10:19:55.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.361]                         if (muffled) 
[10:19:55.361]                           invokeRestart("muffleMessage")
[10:19:55.361]                       }
[10:19:55.361]                       else if (inherits(cond, "warning")) {
[10:19:55.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.361]                         if (muffled) 
[10:19:55.361]                           invokeRestart("muffleWarning")
[10:19:55.361]                       }
[10:19:55.361]                       else if (inherits(cond, "condition")) {
[10:19:55.361]                         if (!is.null(pattern)) {
[10:19:55.361]                           computeRestarts <- base::computeRestarts
[10:19:55.361]                           grepl <- base::grepl
[10:19:55.361]                           restarts <- computeRestarts(cond)
[10:19:55.361]                           for (restart in restarts) {
[10:19:55.361]                             name <- restart$name
[10:19:55.361]                             if (is.null(name)) 
[10:19:55.361]                               next
[10:19:55.361]                             if (!grepl(pattern, name)) 
[10:19:55.361]                               next
[10:19:55.361]                             invokeRestart(restart)
[10:19:55.361]                             muffled <- TRUE
[10:19:55.361]                             break
[10:19:55.361]                           }
[10:19:55.361]                         }
[10:19:55.361]                       }
[10:19:55.361]                       invisible(muffled)
[10:19:55.361]                     }
[10:19:55.361]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.361]                   }
[10:19:55.361]                 }
[10:19:55.361]                 else {
[10:19:55.361]                   if (TRUE) {
[10:19:55.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.361]                     {
[10:19:55.361]                       inherits <- base::inherits
[10:19:55.361]                       invokeRestart <- base::invokeRestart
[10:19:55.361]                       is.null <- base::is.null
[10:19:55.361]                       muffled <- FALSE
[10:19:55.361]                       if (inherits(cond, "message")) {
[10:19:55.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.361]                         if (muffled) 
[10:19:55.361]                           invokeRestart("muffleMessage")
[10:19:55.361]                       }
[10:19:55.361]                       else if (inherits(cond, "warning")) {
[10:19:55.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.361]                         if (muffled) 
[10:19:55.361]                           invokeRestart("muffleWarning")
[10:19:55.361]                       }
[10:19:55.361]                       else if (inherits(cond, "condition")) {
[10:19:55.361]                         if (!is.null(pattern)) {
[10:19:55.361]                           computeRestarts <- base::computeRestarts
[10:19:55.361]                           grepl <- base::grepl
[10:19:55.361]                           restarts <- computeRestarts(cond)
[10:19:55.361]                           for (restart in restarts) {
[10:19:55.361]                             name <- restart$name
[10:19:55.361]                             if (is.null(name)) 
[10:19:55.361]                               next
[10:19:55.361]                             if (!grepl(pattern, name)) 
[10:19:55.361]                               next
[10:19:55.361]                             invokeRestart(restart)
[10:19:55.361]                             muffled <- TRUE
[10:19:55.361]                             break
[10:19:55.361]                           }
[10:19:55.361]                         }
[10:19:55.361]                       }
[10:19:55.361]                       invisible(muffled)
[10:19:55.361]                     }
[10:19:55.361]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.361]                   }
[10:19:55.361]                 }
[10:19:55.361]             }
[10:19:55.361]         }))
[10:19:55.361]     }, error = function(ex) {
[10:19:55.361]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:55.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.361]                 ...future.rng), started = ...future.startTime, 
[10:19:55.361]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:55.361]             version = "1.8"), class = "FutureResult")
[10:19:55.361]     }, finally = {
[10:19:55.361]         if (!identical(...future.workdir, getwd())) 
[10:19:55.361]             setwd(...future.workdir)
[10:19:55.361]         {
[10:19:55.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:55.361]                 ...future.oldOptions$nwarnings <- NULL
[10:19:55.361]             }
[10:19:55.361]             base::options(...future.oldOptions)
[10:19:55.361]             if (.Platform$OS.type == "windows") {
[10:19:55.361]                 old_names <- names(...future.oldEnvVars)
[10:19:55.361]                 envs <- base::Sys.getenv()
[10:19:55.361]                 names <- names(envs)
[10:19:55.361]                 common <- intersect(names, old_names)
[10:19:55.361]                 added <- setdiff(names, old_names)
[10:19:55.361]                 removed <- setdiff(old_names, names)
[10:19:55.361]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:55.361]                   envs[common]]
[10:19:55.361]                 NAMES <- toupper(changed)
[10:19:55.361]                 args <- list()
[10:19:55.361]                 for (kk in seq_along(NAMES)) {
[10:19:55.361]                   name <- changed[[kk]]
[10:19:55.361]                   NAME <- NAMES[[kk]]
[10:19:55.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.361]                     next
[10:19:55.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.361]                 }
[10:19:55.361]                 NAMES <- toupper(added)
[10:19:55.361]                 for (kk in seq_along(NAMES)) {
[10:19:55.361]                   name <- added[[kk]]
[10:19:55.361]                   NAME <- NAMES[[kk]]
[10:19:55.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.361]                     next
[10:19:55.361]                   args[[name]] <- ""
[10:19:55.361]                 }
[10:19:55.361]                 NAMES <- toupper(removed)
[10:19:55.361]                 for (kk in seq_along(NAMES)) {
[10:19:55.361]                   name <- removed[[kk]]
[10:19:55.361]                   NAME <- NAMES[[kk]]
[10:19:55.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.361]                     next
[10:19:55.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.361]                 }
[10:19:55.361]                 if (length(args) > 0) 
[10:19:55.361]                   base::do.call(base::Sys.setenv, args = args)
[10:19:55.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:55.361]             }
[10:19:55.361]             else {
[10:19:55.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:55.361]             }
[10:19:55.361]             {
[10:19:55.361]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:55.361]                   0L) {
[10:19:55.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:55.361]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:55.361]                   base::options(opts)
[10:19:55.361]                 }
[10:19:55.361]                 {
[10:19:55.361]                   {
[10:19:55.361]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:55.361]                     NULL
[10:19:55.361]                   }
[10:19:55.361]                   options(future.plan = NULL)
[10:19:55.361]                   if (is.na(NA_character_)) 
[10:19:55.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:55.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:55.361]                     .init = FALSE)
[10:19:55.361]                 }
[10:19:55.361]             }
[10:19:55.361]         }
[10:19:55.361]     })
[10:19:55.361]     if (TRUE) {
[10:19:55.361]         base::sink(type = "output", split = FALSE)
[10:19:55.361]         if (TRUE) {
[10:19:55.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:55.361]         }
[10:19:55.361]         else {
[10:19:55.361]             ...future.result["stdout"] <- base::list(NULL)
[10:19:55.361]         }
[10:19:55.361]         base::close(...future.stdout)
[10:19:55.361]         ...future.stdout <- NULL
[10:19:55.361]     }
[10:19:55.361]     ...future.result$conditions <- ...future.conditions
[10:19:55.361]     ...future.result$finished <- base::Sys.time()
[10:19:55.361]     ...future.result
[10:19:55.361] }
[10:19:55.364] Exporting 11 global objects (13.20 KiB) to cluster node #1 ...
[10:19:55.364] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #1 ...
[10:19:55.406] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #1 ... DONE
[10:19:55.406] Exporting ‘x_FUN’ (296 bytes) to cluster node #1 ...
[10:19:55.406] Exporting ‘x_FUN’ (296 bytes) to cluster node #1 ... DONE
[10:19:55.407] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:55.407] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:55.410] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:55.451] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:55.451] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:55.492] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:55.493] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:55.493] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.493] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[10:19:55.494] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[10:19:55.494] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:55.494] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:55.494] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[10:19:55.495] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[10:19:55.495] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:55.495] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.495] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:55.496] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.496] Exporting 11 global objects (13.20 KiB) to cluster node #1 ... DONE
[10:19:55.496] MultisessionFuture started
[10:19:55.496] - Launch lazy future ... done
[10:19:55.496] run() for ‘MultisessionFuture’ ... done
[10:19:55.497] Created future:
[10:19:55.497] MultisessionFuture:
[10:19:55.497] Label: ‘future_vapply-1’
[10:19:55.497] Expression:
[10:19:55.497] {
[10:19:55.497]     do.call(function(...) {
[10:19:55.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.497]             on.exit(options(oopts), add = TRUE)
[10:19:55.497]         }
[10:19:55.497]         {
[10:19:55.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.497]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.497]             })
[10:19:55.497]         }
[10:19:55.497]     }, args = future.call.arguments)
[10:19:55.497] }
[10:19:55.497] Lazy evaluation: FALSE
[10:19:55.497] Asynchronous evaluation: TRUE
[10:19:55.497] Local evaluation: TRUE
[10:19:55.497] Environment: R_GlobalEnv
[10:19:55.497] Capture standard output: TRUE
[10:19:55.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:55.497] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:55.497] Packages: 1 packages (‘future.apply’)
[10:19:55.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:55.497] Resolved: FALSE
[10:19:55.497] Value: <not collected>
[10:19:55.497] Conditions captured: <none>
[10:19:55.497] Early signaling: FALSE
[10:19:55.497] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:55.497] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.508] Chunk #1 of 2 ... DONE
[10:19:55.508] Chunk #2 of 2 ...
[10:19:55.509]  - Finding globals in 'X' for chunk #2 ...
[10:19:55.509] getGlobalsAndPackages() ...
[10:19:55.509] Searching for globals...
[10:19:55.509] 
[10:19:55.509] Searching for globals ... DONE
[10:19:55.509] - globals: [0] <none>
[10:19:55.509] getGlobalsAndPackages() ... DONE
[10:19:55.509]    + additional globals found: [n=0] 
[10:19:55.510]    + additional namespaces needed: [n=0] 
[10:19:55.510]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:55.510]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:55.510]  - seeds: <none>
[10:19:55.510]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.510] getGlobalsAndPackages() ...
[10:19:55.510] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.510] Resolving globals: FALSE
[10:19:55.510] Tweak future expression to call with '...' arguments ...
[10:19:55.510] {
[10:19:55.510]     do.call(function(...) {
[10:19:55.510]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.510]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.510]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.510]             on.exit(options(oopts), add = TRUE)
[10:19:55.510]         }
[10:19:55.510]         {
[10:19:55.510]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.510]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.510]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.510]             })
[10:19:55.510]         }
[10:19:55.510]     }, args = future.call.arguments)
[10:19:55.510] }
[10:19:55.511] Tweak future expression to call with '...' arguments ... DONE
[10:19:55.511] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.511] - packages: [1] ‘future.apply’
[10:19:55.511] getGlobalsAndPackages() ... DONE
[10:19:55.512] run() for ‘Future’ ...
[10:19:55.512] - state: ‘created’
[10:19:55.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:55.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:55.526]   - Field: ‘node’
[10:19:55.527]   - Field: ‘label’
[10:19:55.527]   - Field: ‘local’
[10:19:55.527]   - Field: ‘owner’
[10:19:55.527]   - Field: ‘envir’
[10:19:55.527]   - Field: ‘workers’
[10:19:55.527]   - Field: ‘packages’
[10:19:55.527]   - Field: ‘gc’
[10:19:55.527]   - Field: ‘conditions’
[10:19:55.527]   - Field: ‘persistent’
[10:19:55.527]   - Field: ‘expr’
[10:19:55.527]   - Field: ‘uuid’
[10:19:55.528]   - Field: ‘seed’
[10:19:55.528]   - Field: ‘version’
[10:19:55.528]   - Field: ‘result’
[10:19:55.528]   - Field: ‘asynchronous’
[10:19:55.528]   - Field: ‘calls’
[10:19:55.528]   - Field: ‘globals’
[10:19:55.528]   - Field: ‘stdout’
[10:19:55.528]   - Field: ‘earlySignal’
[10:19:55.528]   - Field: ‘lazy’
[10:19:55.528]   - Field: ‘state’
[10:19:55.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:55.529] - Launch lazy future ...
[10:19:55.529] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:55.529] Packages needed by future strategies (n = 0): <none>
[10:19:55.530] {
[10:19:55.530]     {
[10:19:55.530]         {
[10:19:55.530]             ...future.startTime <- base::Sys.time()
[10:19:55.530]             {
[10:19:55.530]                 {
[10:19:55.530]                   {
[10:19:55.530]                     {
[10:19:55.530]                       {
[10:19:55.530]                         base::local({
[10:19:55.530]                           has_future <- base::requireNamespace("future", 
[10:19:55.530]                             quietly = TRUE)
[10:19:55.530]                           if (has_future) {
[10:19:55.530]                             ns <- base::getNamespace("future")
[10:19:55.530]                             version <- ns[[".package"]][["version"]]
[10:19:55.530]                             if (is.null(version)) 
[10:19:55.530]                               version <- utils::packageVersion("future")
[10:19:55.530]                           }
[10:19:55.530]                           else {
[10:19:55.530]                             version <- NULL
[10:19:55.530]                           }
[10:19:55.530]                           if (!has_future || version < "1.8.0") {
[10:19:55.530]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:55.530]                               "", base::R.version$version.string), 
[10:19:55.530]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:55.530]                                 base::R.version$platform, 8 * 
[10:19:55.530]                                   base::.Machine$sizeof.pointer), 
[10:19:55.530]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:55.530]                                 "release", "version")], collapse = " "), 
[10:19:55.530]                               hostname = base::Sys.info()[["nodename"]])
[10:19:55.530]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:55.530]                               info)
[10:19:55.530]                             info <- base::paste(info, collapse = "; ")
[10:19:55.530]                             if (!has_future) {
[10:19:55.530]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:55.530]                                 info)
[10:19:55.530]                             }
[10:19:55.530]                             else {
[10:19:55.530]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:55.530]                                 info, version)
[10:19:55.530]                             }
[10:19:55.530]                             base::stop(msg)
[10:19:55.530]                           }
[10:19:55.530]                         })
[10:19:55.530]                       }
[10:19:55.530]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:55.530]                       base::options(mc.cores = 1L)
[10:19:55.530]                     }
[10:19:55.530]                     base::local({
[10:19:55.530]                       for (pkg in "future.apply") {
[10:19:55.530]                         base::loadNamespace(pkg)
[10:19:55.530]                         base::library(pkg, character.only = TRUE)
[10:19:55.530]                       }
[10:19:55.530]                     })
[10:19:55.530]                   }
[10:19:55.530]                   ...future.strategy.old <- future::plan("list")
[10:19:55.530]                   options(future.plan = NULL)
[10:19:55.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:55.530]                 }
[10:19:55.530]                 ...future.workdir <- getwd()
[10:19:55.530]             }
[10:19:55.530]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:55.530]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:55.530]         }
[10:19:55.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:55.530]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:55.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:55.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:55.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:55.530]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:55.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:55.530]             base::names(...future.oldOptions))
[10:19:55.530]     }
[10:19:55.530]     if (FALSE) {
[10:19:55.530]     }
[10:19:55.530]     else {
[10:19:55.530]         if (TRUE) {
[10:19:55.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:55.530]                 open = "w")
[10:19:55.530]         }
[10:19:55.530]         else {
[10:19:55.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:55.530]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:55.530]         }
[10:19:55.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:55.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:55.530]             base::sink(type = "output", split = FALSE)
[10:19:55.530]             base::close(...future.stdout)
[10:19:55.530]         }, add = TRUE)
[10:19:55.530]     }
[10:19:55.530]     ...future.frame <- base::sys.nframe()
[10:19:55.530]     ...future.conditions <- base::list()
[10:19:55.530]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:55.530]     if (FALSE) {
[10:19:55.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:55.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:55.530]     }
[10:19:55.530]     ...future.result <- base::tryCatch({
[10:19:55.530]         base::withCallingHandlers({
[10:19:55.530]             ...future.value <- base::withVisible(base::local({
[10:19:55.530]                 ...future.makeSendCondition <- base::local({
[10:19:55.530]                   sendCondition <- NULL
[10:19:55.530]                   function(frame = 1L) {
[10:19:55.530]                     if (is.function(sendCondition)) 
[10:19:55.530]                       return(sendCondition)
[10:19:55.530]                     ns <- getNamespace("parallel")
[10:19:55.530]                     if (exists("sendData", mode = "function", 
[10:19:55.530]                       envir = ns)) {
[10:19:55.530]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:55.530]                         envir = ns)
[10:19:55.530]                       envir <- sys.frame(frame)
[10:19:55.530]                       master <- NULL
[10:19:55.530]                       while (!identical(envir, .GlobalEnv) && 
[10:19:55.530]                         !identical(envir, emptyenv())) {
[10:19:55.530]                         if (exists("master", mode = "list", envir = envir, 
[10:19:55.530]                           inherits = FALSE)) {
[10:19:55.530]                           master <- get("master", mode = "list", 
[10:19:55.530]                             envir = envir, inherits = FALSE)
[10:19:55.530]                           if (inherits(master, c("SOCKnode", 
[10:19:55.530]                             "SOCK0node"))) {
[10:19:55.530]                             sendCondition <<- function(cond) {
[10:19:55.530]                               data <- list(type = "VALUE", value = cond, 
[10:19:55.530]                                 success = TRUE)
[10:19:55.530]                               parallel_sendData(master, data)
[10:19:55.530]                             }
[10:19:55.530]                             return(sendCondition)
[10:19:55.530]                           }
[10:19:55.530]                         }
[10:19:55.530]                         frame <- frame + 1L
[10:19:55.530]                         envir <- sys.frame(frame)
[10:19:55.530]                       }
[10:19:55.530]                     }
[10:19:55.530]                     sendCondition <<- function(cond) NULL
[10:19:55.530]                   }
[10:19:55.530]                 })
[10:19:55.530]                 withCallingHandlers({
[10:19:55.530]                   {
[10:19:55.530]                     do.call(function(...) {
[10:19:55.530]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.530]                       if (!identical(...future.globals.maxSize.org, 
[10:19:55.530]                         ...future.globals.maxSize)) {
[10:19:55.530]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.530]                         on.exit(options(oopts), add = TRUE)
[10:19:55.530]                       }
[10:19:55.530]                       {
[10:19:55.530]                         lapply(seq_along(...future.elements_ii), 
[10:19:55.530]                           FUN = function(jj) {
[10:19:55.530]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.530]                             ...future.FUN(...future.X_jj, ...)
[10:19:55.530]                           })
[10:19:55.530]                       }
[10:19:55.530]                     }, args = future.call.arguments)
[10:19:55.530]                   }
[10:19:55.530]                 }, immediateCondition = function(cond) {
[10:19:55.530]                   sendCondition <- ...future.makeSendCondition()
[10:19:55.530]                   sendCondition(cond)
[10:19:55.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.530]                   {
[10:19:55.530]                     inherits <- base::inherits
[10:19:55.530]                     invokeRestart <- base::invokeRestart
[10:19:55.530]                     is.null <- base::is.null
[10:19:55.530]                     muffled <- FALSE
[10:19:55.530]                     if (inherits(cond, "message")) {
[10:19:55.530]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:55.530]                       if (muffled) 
[10:19:55.530]                         invokeRestart("muffleMessage")
[10:19:55.530]                     }
[10:19:55.530]                     else if (inherits(cond, "warning")) {
[10:19:55.530]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:55.530]                       if (muffled) 
[10:19:55.530]                         invokeRestart("muffleWarning")
[10:19:55.530]                     }
[10:19:55.530]                     else if (inherits(cond, "condition")) {
[10:19:55.530]                       if (!is.null(pattern)) {
[10:19:55.530]                         computeRestarts <- base::computeRestarts
[10:19:55.530]                         grepl <- base::grepl
[10:19:55.530]                         restarts <- computeRestarts(cond)
[10:19:55.530]                         for (restart in restarts) {
[10:19:55.530]                           name <- restart$name
[10:19:55.530]                           if (is.null(name)) 
[10:19:55.530]                             next
[10:19:55.530]                           if (!grepl(pattern, name)) 
[10:19:55.530]                             next
[10:19:55.530]                           invokeRestart(restart)
[10:19:55.530]                           muffled <- TRUE
[10:19:55.530]                           break
[10:19:55.530]                         }
[10:19:55.530]                       }
[10:19:55.530]                     }
[10:19:55.530]                     invisible(muffled)
[10:19:55.530]                   }
[10:19:55.530]                   muffleCondition(cond)
[10:19:55.530]                 })
[10:19:55.530]             }))
[10:19:55.530]             future::FutureResult(value = ...future.value$value, 
[10:19:55.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.530]                   ...future.rng), globalenv = if (FALSE) 
[10:19:55.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:55.530]                     ...future.globalenv.names))
[10:19:55.530]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:55.530]         }, condition = base::local({
[10:19:55.530]             c <- base::c
[10:19:55.530]             inherits <- base::inherits
[10:19:55.530]             invokeRestart <- base::invokeRestart
[10:19:55.530]             length <- base::length
[10:19:55.530]             list <- base::list
[10:19:55.530]             seq.int <- base::seq.int
[10:19:55.530]             signalCondition <- base::signalCondition
[10:19:55.530]             sys.calls <- base::sys.calls
[10:19:55.530]             `[[` <- base::`[[`
[10:19:55.530]             `+` <- base::`+`
[10:19:55.530]             `<<-` <- base::`<<-`
[10:19:55.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:55.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:55.530]                   3L)]
[10:19:55.530]             }
[10:19:55.530]             function(cond) {
[10:19:55.530]                 is_error <- inherits(cond, "error")
[10:19:55.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:55.530]                   NULL)
[10:19:55.530]                 if (is_error) {
[10:19:55.530]                   sessionInformation <- function() {
[10:19:55.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:55.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:55.530]                       search = base::search(), system = base::Sys.info())
[10:19:55.530]                   }
[10:19:55.530]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:55.530]                     cond$call), session = sessionInformation(), 
[10:19:55.530]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:55.530]                   signalCondition(cond)
[10:19:55.530]                 }
[10:19:55.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:55.530]                 "immediateCondition"))) {
[10:19:55.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:55.530]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:55.530]                   if (TRUE && !signal) {
[10:19:55.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.530]                     {
[10:19:55.530]                       inherits <- base::inherits
[10:19:55.530]                       invokeRestart <- base::invokeRestart
[10:19:55.530]                       is.null <- base::is.null
[10:19:55.530]                       muffled <- FALSE
[10:19:55.530]                       if (inherits(cond, "message")) {
[10:19:55.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.530]                         if (muffled) 
[10:19:55.530]                           invokeRestart("muffleMessage")
[10:19:55.530]                       }
[10:19:55.530]                       else if (inherits(cond, "warning")) {
[10:19:55.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.530]                         if (muffled) 
[10:19:55.530]                           invokeRestart("muffleWarning")
[10:19:55.530]                       }
[10:19:55.530]                       else if (inherits(cond, "condition")) {
[10:19:55.530]                         if (!is.null(pattern)) {
[10:19:55.530]                           computeRestarts <- base::computeRestarts
[10:19:55.530]                           grepl <- base::grepl
[10:19:55.530]                           restarts <- computeRestarts(cond)
[10:19:55.530]                           for (restart in restarts) {
[10:19:55.530]                             name <- restart$name
[10:19:55.530]                             if (is.null(name)) 
[10:19:55.530]                               next
[10:19:55.530]                             if (!grepl(pattern, name)) 
[10:19:55.530]                               next
[10:19:55.530]                             invokeRestart(restart)
[10:19:55.530]                             muffled <- TRUE
[10:19:55.530]                             break
[10:19:55.530]                           }
[10:19:55.530]                         }
[10:19:55.530]                       }
[10:19:55.530]                       invisible(muffled)
[10:19:55.530]                     }
[10:19:55.530]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.530]                   }
[10:19:55.530]                 }
[10:19:55.530]                 else {
[10:19:55.530]                   if (TRUE) {
[10:19:55.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.530]                     {
[10:19:55.530]                       inherits <- base::inherits
[10:19:55.530]                       invokeRestart <- base::invokeRestart
[10:19:55.530]                       is.null <- base::is.null
[10:19:55.530]                       muffled <- FALSE
[10:19:55.530]                       if (inherits(cond, "message")) {
[10:19:55.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.530]                         if (muffled) 
[10:19:55.530]                           invokeRestart("muffleMessage")
[10:19:55.530]                       }
[10:19:55.530]                       else if (inherits(cond, "warning")) {
[10:19:55.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.530]                         if (muffled) 
[10:19:55.530]                           invokeRestart("muffleWarning")
[10:19:55.530]                       }
[10:19:55.530]                       else if (inherits(cond, "condition")) {
[10:19:55.530]                         if (!is.null(pattern)) {
[10:19:55.530]                           computeRestarts <- base::computeRestarts
[10:19:55.530]                           grepl <- base::grepl
[10:19:55.530]                           restarts <- computeRestarts(cond)
[10:19:55.530]                           for (restart in restarts) {
[10:19:55.530]                             name <- restart$name
[10:19:55.530]                             if (is.null(name)) 
[10:19:55.530]                               next
[10:19:55.530]                             if (!grepl(pattern, name)) 
[10:19:55.530]                               next
[10:19:55.530]                             invokeRestart(restart)
[10:19:55.530]                             muffled <- TRUE
[10:19:55.530]                             break
[10:19:55.530]                           }
[10:19:55.530]                         }
[10:19:55.530]                       }
[10:19:55.530]                       invisible(muffled)
[10:19:55.530]                     }
[10:19:55.530]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.530]                   }
[10:19:55.530]                 }
[10:19:55.530]             }
[10:19:55.530]         }))
[10:19:55.530]     }, error = function(ex) {
[10:19:55.530]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:55.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.530]                 ...future.rng), started = ...future.startTime, 
[10:19:55.530]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:55.530]             version = "1.8"), class = "FutureResult")
[10:19:55.530]     }, finally = {
[10:19:55.530]         if (!identical(...future.workdir, getwd())) 
[10:19:55.530]             setwd(...future.workdir)
[10:19:55.530]         {
[10:19:55.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:55.530]                 ...future.oldOptions$nwarnings <- NULL
[10:19:55.530]             }
[10:19:55.530]             base::options(...future.oldOptions)
[10:19:55.530]             if (.Platform$OS.type == "windows") {
[10:19:55.530]                 old_names <- names(...future.oldEnvVars)
[10:19:55.530]                 envs <- base::Sys.getenv()
[10:19:55.530]                 names <- names(envs)
[10:19:55.530]                 common <- intersect(names, old_names)
[10:19:55.530]                 added <- setdiff(names, old_names)
[10:19:55.530]                 removed <- setdiff(old_names, names)
[10:19:55.530]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:55.530]                   envs[common]]
[10:19:55.530]                 NAMES <- toupper(changed)
[10:19:55.530]                 args <- list()
[10:19:55.530]                 for (kk in seq_along(NAMES)) {
[10:19:55.530]                   name <- changed[[kk]]
[10:19:55.530]                   NAME <- NAMES[[kk]]
[10:19:55.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.530]                     next
[10:19:55.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.530]                 }
[10:19:55.530]                 NAMES <- toupper(added)
[10:19:55.530]                 for (kk in seq_along(NAMES)) {
[10:19:55.530]                   name <- added[[kk]]
[10:19:55.530]                   NAME <- NAMES[[kk]]
[10:19:55.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.530]                     next
[10:19:55.530]                   args[[name]] <- ""
[10:19:55.530]                 }
[10:19:55.530]                 NAMES <- toupper(removed)
[10:19:55.530]                 for (kk in seq_along(NAMES)) {
[10:19:55.530]                   name <- removed[[kk]]
[10:19:55.530]                   NAME <- NAMES[[kk]]
[10:19:55.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.530]                     next
[10:19:55.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.530]                 }
[10:19:55.530]                 if (length(args) > 0) 
[10:19:55.530]                   base::do.call(base::Sys.setenv, args = args)
[10:19:55.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:55.530]             }
[10:19:55.530]             else {
[10:19:55.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:55.530]             }
[10:19:55.530]             {
[10:19:55.530]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:55.530]                   0L) {
[10:19:55.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:55.530]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:55.530]                   base::options(opts)
[10:19:55.530]                 }
[10:19:55.530]                 {
[10:19:55.530]                   {
[10:19:55.530]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:55.530]                     NULL
[10:19:55.530]                   }
[10:19:55.530]                   options(future.plan = NULL)
[10:19:55.530]                   if (is.na(NA_character_)) 
[10:19:55.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:55.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:55.530]                     .init = FALSE)
[10:19:55.530]                 }
[10:19:55.530]             }
[10:19:55.530]         }
[10:19:55.530]     })
[10:19:55.530]     if (TRUE) {
[10:19:55.530]         base::sink(type = "output", split = FALSE)
[10:19:55.530]         if (TRUE) {
[10:19:55.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:55.530]         }
[10:19:55.530]         else {
[10:19:55.530]             ...future.result["stdout"] <- base::list(NULL)
[10:19:55.530]         }
[10:19:55.530]         base::close(...future.stdout)
[10:19:55.530]         ...future.stdout <- NULL
[10:19:55.530]     }
[10:19:55.530]     ...future.result$conditions <- ...future.conditions
[10:19:55.530]     ...future.result$finished <- base::Sys.time()
[10:19:55.530]     ...future.result
[10:19:55.530] }
[10:19:55.533] Exporting 11 global objects (13.20 KiB) to cluster node #2 ...
[10:19:55.533] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #2 ...
[10:19:55.575] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #2 ... DONE
[10:19:55.575] Exporting ‘x_FUN’ (296 bytes) to cluster node #2 ...
[10:19:55.575] Exporting ‘x_FUN’ (296 bytes) to cluster node #2 ... DONE
[10:19:55.576] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:55.576] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:55.576] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:55.617] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:55.618] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:55.658] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:55.659] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:55.659] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:55.659] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[10:19:55.660] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[10:19:55.660] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:55.660] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:55.660] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[10:19:55.661] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[10:19:55.661] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:55.661] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:55.661] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:55.662] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:55.662] Exporting 11 global objects (13.20 KiB) to cluster node #2 ... DONE
[10:19:55.662] MultisessionFuture started
[10:19:55.662] - Launch lazy future ... done
[10:19:55.663] run() for ‘MultisessionFuture’ ... done
[10:19:55.663] Created future:
[10:19:55.663] MultisessionFuture:
[10:19:55.663] Label: ‘future_vapply-2’
[10:19:55.663] Expression:
[10:19:55.663] {
[10:19:55.663]     do.call(function(...) {
[10:19:55.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.663]             on.exit(options(oopts), add = TRUE)
[10:19:55.663]         }
[10:19:55.663]         {
[10:19:55.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.663]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.663]             })
[10:19:55.663]         }
[10:19:55.663]     }, args = future.call.arguments)
[10:19:55.663] }
[10:19:55.663] Lazy evaluation: FALSE
[10:19:55.663] Asynchronous evaluation: TRUE
[10:19:55.663] Local evaluation: TRUE
[10:19:55.663] Environment: R_GlobalEnv
[10:19:55.663] Capture standard output: TRUE
[10:19:55.663] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:55.663] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:55.663] Packages: 1 packages (‘future.apply’)
[10:19:55.663] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:55.663] Resolved: FALSE
[10:19:55.663] Value: <not collected>
[10:19:55.663] Conditions captured: <none>
[10:19:55.663] Early signaling: FALSE
[10:19:55.663] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:55.663] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.675] Chunk #2 of 2 ... DONE
[10:19:55.675] Launching 2 futures (chunks) ... DONE
[10:19:55.675] Resolving 2 futures (chunks) ...
[10:19:55.675] resolve() on list ...
[10:19:55.675]  recursive: 0
[10:19:55.675]  length: 2
[10:19:55.675] 
[10:19:55.676] receiveMessageFromWorker() for ClusterFuture ...
[10:19:55.676] - Validating connection of MultisessionFuture
[10:19:55.676] - received message: FutureResult
[10:19:55.676] - Received FutureResult
[10:19:55.676] - Erased future from FutureRegistry
[10:19:55.676] result() for ClusterFuture ...
[10:19:55.676] - result already collected: FutureResult
[10:19:55.677] result() for ClusterFuture ... done
[10:19:55.677] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:55.677] Future #1
[10:19:55.677] result() for ClusterFuture ...
[10:19:55.677] - result already collected: FutureResult
[10:19:55.677] result() for ClusterFuture ... done
[10:19:55.677] result() for ClusterFuture ...
[10:19:55.677] - result already collected: FutureResult
[10:19:55.677] result() for ClusterFuture ... done
[10:19:55.677] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:55.677] - nx: 2
[10:19:55.677] - relay: TRUE
[10:19:55.678] - stdout: TRUE
[10:19:55.678] - signal: TRUE
[10:19:55.678] - resignal: FALSE
[10:19:55.678] - force: TRUE
[10:19:55.678] - relayed: [n=2] FALSE, FALSE
[10:19:55.678] - queued futures: [n=2] FALSE, FALSE
[10:19:55.678]  - until=1
[10:19:55.678]  - relaying element #1
[10:19:55.678] result() for ClusterFuture ...
[10:19:55.678] - result already collected: FutureResult
[10:19:55.678] result() for ClusterFuture ... done
[10:19:55.678] result() for ClusterFuture ...
[10:19:55.679] - result already collected: FutureResult
[10:19:55.679] result() for ClusterFuture ... done
[10:19:55.679] result() for ClusterFuture ...
[10:19:55.679] - result already collected: FutureResult
[10:19:55.679] result() for ClusterFuture ... done
[10:19:55.679] result() for ClusterFuture ...
[10:19:55.679] - result already collected: FutureResult
[10:19:55.679] result() for ClusterFuture ... done
[10:19:55.679] - relayed: [n=2] TRUE, FALSE
[10:19:55.679] - queued futures: [n=2] TRUE, FALSE
[10:19:55.679] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:55.679]  length: 1 (resolved future 1)
[10:19:55.704] receiveMessageFromWorker() for ClusterFuture ...
[10:19:55.704] - Validating connection of MultisessionFuture
[10:19:55.705] - received message: FutureResult
[10:19:55.705] - Received FutureResult
[10:19:55.705] - Erased future from FutureRegistry
[10:19:55.705] result() for ClusterFuture ...
[10:19:55.705] - result already collected: FutureResult
[10:19:55.705] result() for ClusterFuture ... done
[10:19:55.705] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:55.705] Future #2
[10:19:55.705] result() for ClusterFuture ...
[10:19:55.705] - result already collected: FutureResult
[10:19:55.706] result() for ClusterFuture ... done
[10:19:55.706] result() for ClusterFuture ...
[10:19:55.706] - result already collected: FutureResult
[10:19:55.706] result() for ClusterFuture ... done
[10:19:55.706] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:55.706] - nx: 2
[10:19:55.706] - relay: TRUE
[10:19:55.706] - stdout: TRUE
[10:19:55.706] - signal: TRUE
[10:19:55.706] - resignal: FALSE
[10:19:55.706] - force: TRUE
[10:19:55.706] - relayed: [n=2] TRUE, FALSE
[10:19:55.707] - queued futures: [n=2] TRUE, FALSE
[10:19:55.707]  - until=2
[10:19:55.707]  - relaying element #2
[10:19:55.707] result() for ClusterFuture ...
[10:19:55.707] - result already collected: FutureResult
[10:19:55.707] result() for ClusterFuture ... done
[10:19:55.707] result() for ClusterFuture ...
[10:19:55.707] - result already collected: FutureResult
[10:19:55.707] result() for ClusterFuture ... done
[10:19:55.707] result() for ClusterFuture ...
[10:19:55.707] - result already collected: FutureResult
[10:19:55.707] result() for ClusterFuture ... done
[10:19:55.708] result() for ClusterFuture ...
[10:19:55.708] - result already collected: FutureResult
[10:19:55.708] result() for ClusterFuture ... done
[10:19:55.708] - relayed: [n=2] TRUE, TRUE
[10:19:55.708] - queued futures: [n=2] TRUE, TRUE
[10:19:55.708] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:55.708]  length: 0 (resolved future 2)
[10:19:55.708] Relaying remaining futures
[10:19:55.708] signalConditionsASAP(NULL, pos=0) ...
[10:19:55.708] - nx: 2
[10:19:55.708] - relay: TRUE
[10:19:55.708] - stdout: TRUE
[10:19:55.709] - signal: TRUE
[10:19:55.709] - resignal: FALSE
[10:19:55.709] - force: TRUE
[10:19:55.709] - relayed: [n=2] TRUE, TRUE
[10:19:55.709] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:55.709] - relayed: [n=2] TRUE, TRUE
[10:19:55.709] - queued futures: [n=2] TRUE, TRUE
[10:19:55.709] signalConditionsASAP(NULL, pos=0) ... done
[10:19:55.709] resolve() on list ... DONE
[10:19:55.709] result() for ClusterFuture ...
[10:19:55.709] - result already collected: FutureResult
[10:19:55.709] result() for ClusterFuture ... done
[10:19:55.710] result() for ClusterFuture ...
[10:19:55.710] - result already collected: FutureResult
[10:19:55.710] result() for ClusterFuture ... done
[10:19:55.710] result() for ClusterFuture ...
[10:19:55.710] - result already collected: FutureResult
[10:19:55.710] result() for ClusterFuture ... done
[10:19:55.710] result() for ClusterFuture ...
[10:19:55.710] - result already collected: FutureResult
[10:19:55.710] result() for ClusterFuture ... done
[10:19:55.710]  - Number of value chunks collected: 2
[10:19:55.710] Resolving 2 futures (chunks) ... DONE
[10:19:55.711] Reducing values from 2 chunks ...
[10:19:55.711]  - Number of values collected after concatenation: 10
[10:19:55.711]  - Number of values expected: 10
[10:19:55.711] Reducing values from 2 chunks ... DONE
[10:19:55.711] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:19:55.712] future_lapply() ...
[10:19:55.715] Number of chunks: 2
[10:19:55.715] getGlobalsAndPackagesXApply() ...
[10:19:55.715]  - future.globals: TRUE
[10:19:55.715] getGlobalsAndPackages() ...
[10:19:55.715] Searching for globals...
[10:19:55.718] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:55.719] Searching for globals ... DONE
[10:19:55.719] Resolving globals: FALSE
[10:19:55.719] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[10:19:55.720] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:55.720] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:55.720] - packages: [1] ‘future.apply’
[10:19:55.720] getGlobalsAndPackages() ... DONE
[10:19:55.720]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:55.720]  - needed namespaces: [n=1] ‘future.apply’
[10:19:55.720] Finding globals ... DONE
[10:19:55.721]  - use_args: TRUE
[10:19:55.721]  - Getting '...' globals ...
[10:19:55.721] resolve() on list ...
[10:19:55.721]  recursive: 0
[10:19:55.721]  length: 1
[10:19:55.721]  elements: ‘...’
[10:19:55.721]  length: 0 (resolved future 1)
[10:19:55.721] resolve() on list ... DONE
[10:19:55.722]    - '...' content: [n=0] 
[10:19:55.722] List of 1
[10:19:55.722]  $ ...: list()
[10:19:55.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:55.722]  - attr(*, "where")=List of 1
[10:19:55.722]   ..$ ...:<environment: 0x55c6a1274668> 
[10:19:55.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:55.722]  - attr(*, "resolved")= logi TRUE
[10:19:55.722]  - attr(*, "total_size")= num NA
[10:19:55.724]  - Getting '...' globals ... DONE
[10:19:55.724] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:55.724] List of 8
[10:19:55.724]  $ ...future.FUN:function (x, ...)  
[10:19:55.724]  $ x_FUN        :function (x)  
[10:19:55.724]  $ times        : int 1
[10:19:55.724]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:55.724]  $ stop_if_not  :function (...)  
[10:19:55.724]  $ dim          : NULL
[10:19:55.724]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:55.724]  $ ...          : list()
[10:19:55.724]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:55.724]  - attr(*, "where")=List of 8
[10:19:55.724]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:55.724]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:55.724]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:55.724]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:55.724]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:55.724]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:55.724]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:55.724]   ..$ ...          :<environment: 0x55c6a1274668> 
[10:19:55.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:55.724]  - attr(*, "resolved")= logi FALSE
[10:19:55.724]  - attr(*, "total_size")= num 22322
[10:19:55.729] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:55.729] getGlobalsAndPackagesXApply() ... DONE
[10:19:55.730] Number of futures (= number of chunks): 2
[10:19:55.730] Launching 2 futures (chunks) ...
[10:19:55.730] Chunk #1 of 2 ...
[10:19:55.730]  - Finding globals in 'X' for chunk #1 ...
[10:19:55.730] getGlobalsAndPackages() ...
[10:19:55.730] Searching for globals...
[10:19:55.730] 
[10:19:55.731] Searching for globals ... DONE
[10:19:55.731] - globals: [0] <none>
[10:19:55.731] getGlobalsAndPackages() ... DONE
[10:19:55.731]    + additional globals found: [n=0] 
[10:19:55.731]    + additional namespaces needed: [n=0] 
[10:19:55.731]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:55.731]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:55.731]  - seeds: <none>
[10:19:55.731]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.731] getGlobalsAndPackages() ...
[10:19:55.731] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.731] Resolving globals: FALSE
[10:19:55.732] Tweak future expression to call with '...' arguments ...
[10:19:55.732] {
[10:19:55.732]     do.call(function(...) {
[10:19:55.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.732]             on.exit(options(oopts), add = TRUE)
[10:19:55.732]         }
[10:19:55.732]         {
[10:19:55.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.732]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.732]             })
[10:19:55.732]         }
[10:19:55.732]     }, args = future.call.arguments)
[10:19:55.732] }
[10:19:55.732] Tweak future expression to call with '...' arguments ... DONE
[10:19:55.732] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.733] - packages: [1] ‘future.apply’
[10:19:55.733] getGlobalsAndPackages() ... DONE
[10:19:55.733] run() for ‘Future’ ...
[10:19:55.733] - state: ‘created’
[10:19:55.733] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:55.747] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:55.747]   - Field: ‘node’
[10:19:55.748]   - Field: ‘label’
[10:19:55.748]   - Field: ‘local’
[10:19:55.748]   - Field: ‘owner’
[10:19:55.748]   - Field: ‘envir’
[10:19:55.748]   - Field: ‘workers’
[10:19:55.748]   - Field: ‘packages’
[10:19:55.748]   - Field: ‘gc’
[10:19:55.748]   - Field: ‘conditions’
[10:19:55.748]   - Field: ‘persistent’
[10:19:55.748]   - Field: ‘expr’
[10:19:55.748]   - Field: ‘uuid’
[10:19:55.749]   - Field: ‘seed’
[10:19:55.749]   - Field: ‘version’
[10:19:55.749]   - Field: ‘result’
[10:19:55.749]   - Field: ‘asynchronous’
[10:19:55.749]   - Field: ‘calls’
[10:19:55.749]   - Field: ‘globals’
[10:19:55.749]   - Field: ‘stdout’
[10:19:55.749]   - Field: ‘earlySignal’
[10:19:55.749]   - Field: ‘lazy’
[10:19:55.749]   - Field: ‘state’
[10:19:55.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:55.749] - Launch lazy future ...
[10:19:55.750] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:55.750] Packages needed by future strategies (n = 0): <none>
[10:19:55.750] {
[10:19:55.750]     {
[10:19:55.750]         {
[10:19:55.750]             ...future.startTime <- base::Sys.time()
[10:19:55.750]             {
[10:19:55.750]                 {
[10:19:55.750]                   {
[10:19:55.750]                     {
[10:19:55.750]                       {
[10:19:55.750]                         base::local({
[10:19:55.750]                           has_future <- base::requireNamespace("future", 
[10:19:55.750]                             quietly = TRUE)
[10:19:55.750]                           if (has_future) {
[10:19:55.750]                             ns <- base::getNamespace("future")
[10:19:55.750]                             version <- ns[[".package"]][["version"]]
[10:19:55.750]                             if (is.null(version)) 
[10:19:55.750]                               version <- utils::packageVersion("future")
[10:19:55.750]                           }
[10:19:55.750]                           else {
[10:19:55.750]                             version <- NULL
[10:19:55.750]                           }
[10:19:55.750]                           if (!has_future || version < "1.8.0") {
[10:19:55.750]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:55.750]                               "", base::R.version$version.string), 
[10:19:55.750]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:55.750]                                 base::R.version$platform, 8 * 
[10:19:55.750]                                   base::.Machine$sizeof.pointer), 
[10:19:55.750]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:55.750]                                 "release", "version")], collapse = " "), 
[10:19:55.750]                               hostname = base::Sys.info()[["nodename"]])
[10:19:55.750]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:55.750]                               info)
[10:19:55.750]                             info <- base::paste(info, collapse = "; ")
[10:19:55.750]                             if (!has_future) {
[10:19:55.750]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:55.750]                                 info)
[10:19:55.750]                             }
[10:19:55.750]                             else {
[10:19:55.750]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:55.750]                                 info, version)
[10:19:55.750]                             }
[10:19:55.750]                             base::stop(msg)
[10:19:55.750]                           }
[10:19:55.750]                         })
[10:19:55.750]                       }
[10:19:55.750]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:55.750]                       base::options(mc.cores = 1L)
[10:19:55.750]                     }
[10:19:55.750]                     base::local({
[10:19:55.750]                       for (pkg in "future.apply") {
[10:19:55.750]                         base::loadNamespace(pkg)
[10:19:55.750]                         base::library(pkg, character.only = TRUE)
[10:19:55.750]                       }
[10:19:55.750]                     })
[10:19:55.750]                   }
[10:19:55.750]                   ...future.strategy.old <- future::plan("list")
[10:19:55.750]                   options(future.plan = NULL)
[10:19:55.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:55.750]                 }
[10:19:55.750]                 ...future.workdir <- getwd()
[10:19:55.750]             }
[10:19:55.750]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:55.750]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:55.750]         }
[10:19:55.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:55.750]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:55.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:55.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:55.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:55.750]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:55.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:55.750]             base::names(...future.oldOptions))
[10:19:55.750]     }
[10:19:55.750]     if (FALSE) {
[10:19:55.750]     }
[10:19:55.750]     else {
[10:19:55.750]         if (TRUE) {
[10:19:55.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:55.750]                 open = "w")
[10:19:55.750]         }
[10:19:55.750]         else {
[10:19:55.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:55.750]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:55.750]         }
[10:19:55.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:55.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:55.750]             base::sink(type = "output", split = FALSE)
[10:19:55.750]             base::close(...future.stdout)
[10:19:55.750]         }, add = TRUE)
[10:19:55.750]     }
[10:19:55.750]     ...future.frame <- base::sys.nframe()
[10:19:55.750]     ...future.conditions <- base::list()
[10:19:55.750]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:55.750]     if (FALSE) {
[10:19:55.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:55.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:55.750]     }
[10:19:55.750]     ...future.result <- base::tryCatch({
[10:19:55.750]         base::withCallingHandlers({
[10:19:55.750]             ...future.value <- base::withVisible(base::local({
[10:19:55.750]                 ...future.makeSendCondition <- base::local({
[10:19:55.750]                   sendCondition <- NULL
[10:19:55.750]                   function(frame = 1L) {
[10:19:55.750]                     if (is.function(sendCondition)) 
[10:19:55.750]                       return(sendCondition)
[10:19:55.750]                     ns <- getNamespace("parallel")
[10:19:55.750]                     if (exists("sendData", mode = "function", 
[10:19:55.750]                       envir = ns)) {
[10:19:55.750]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:55.750]                         envir = ns)
[10:19:55.750]                       envir <- sys.frame(frame)
[10:19:55.750]                       master <- NULL
[10:19:55.750]                       while (!identical(envir, .GlobalEnv) && 
[10:19:55.750]                         !identical(envir, emptyenv())) {
[10:19:55.750]                         if (exists("master", mode = "list", envir = envir, 
[10:19:55.750]                           inherits = FALSE)) {
[10:19:55.750]                           master <- get("master", mode = "list", 
[10:19:55.750]                             envir = envir, inherits = FALSE)
[10:19:55.750]                           if (inherits(master, c("SOCKnode", 
[10:19:55.750]                             "SOCK0node"))) {
[10:19:55.750]                             sendCondition <<- function(cond) {
[10:19:55.750]                               data <- list(type = "VALUE", value = cond, 
[10:19:55.750]                                 success = TRUE)
[10:19:55.750]                               parallel_sendData(master, data)
[10:19:55.750]                             }
[10:19:55.750]                             return(sendCondition)
[10:19:55.750]                           }
[10:19:55.750]                         }
[10:19:55.750]                         frame <- frame + 1L
[10:19:55.750]                         envir <- sys.frame(frame)
[10:19:55.750]                       }
[10:19:55.750]                     }
[10:19:55.750]                     sendCondition <<- function(cond) NULL
[10:19:55.750]                   }
[10:19:55.750]                 })
[10:19:55.750]                 withCallingHandlers({
[10:19:55.750]                   {
[10:19:55.750]                     do.call(function(...) {
[10:19:55.750]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.750]                       if (!identical(...future.globals.maxSize.org, 
[10:19:55.750]                         ...future.globals.maxSize)) {
[10:19:55.750]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.750]                         on.exit(options(oopts), add = TRUE)
[10:19:55.750]                       }
[10:19:55.750]                       {
[10:19:55.750]                         lapply(seq_along(...future.elements_ii), 
[10:19:55.750]                           FUN = function(jj) {
[10:19:55.750]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.750]                             ...future.FUN(...future.X_jj, ...)
[10:19:55.750]                           })
[10:19:55.750]                       }
[10:19:55.750]                     }, args = future.call.arguments)
[10:19:55.750]                   }
[10:19:55.750]                 }, immediateCondition = function(cond) {
[10:19:55.750]                   sendCondition <- ...future.makeSendCondition()
[10:19:55.750]                   sendCondition(cond)
[10:19:55.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.750]                   {
[10:19:55.750]                     inherits <- base::inherits
[10:19:55.750]                     invokeRestart <- base::invokeRestart
[10:19:55.750]                     is.null <- base::is.null
[10:19:55.750]                     muffled <- FALSE
[10:19:55.750]                     if (inherits(cond, "message")) {
[10:19:55.750]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:55.750]                       if (muffled) 
[10:19:55.750]                         invokeRestart("muffleMessage")
[10:19:55.750]                     }
[10:19:55.750]                     else if (inherits(cond, "warning")) {
[10:19:55.750]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:55.750]                       if (muffled) 
[10:19:55.750]                         invokeRestart("muffleWarning")
[10:19:55.750]                     }
[10:19:55.750]                     else if (inherits(cond, "condition")) {
[10:19:55.750]                       if (!is.null(pattern)) {
[10:19:55.750]                         computeRestarts <- base::computeRestarts
[10:19:55.750]                         grepl <- base::grepl
[10:19:55.750]                         restarts <- computeRestarts(cond)
[10:19:55.750]                         for (restart in restarts) {
[10:19:55.750]                           name <- restart$name
[10:19:55.750]                           if (is.null(name)) 
[10:19:55.750]                             next
[10:19:55.750]                           if (!grepl(pattern, name)) 
[10:19:55.750]                             next
[10:19:55.750]                           invokeRestart(restart)
[10:19:55.750]                           muffled <- TRUE
[10:19:55.750]                           break
[10:19:55.750]                         }
[10:19:55.750]                       }
[10:19:55.750]                     }
[10:19:55.750]                     invisible(muffled)
[10:19:55.750]                   }
[10:19:55.750]                   muffleCondition(cond)
[10:19:55.750]                 })
[10:19:55.750]             }))
[10:19:55.750]             future::FutureResult(value = ...future.value$value, 
[10:19:55.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.750]                   ...future.rng), globalenv = if (FALSE) 
[10:19:55.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:55.750]                     ...future.globalenv.names))
[10:19:55.750]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:55.750]         }, condition = base::local({
[10:19:55.750]             c <- base::c
[10:19:55.750]             inherits <- base::inherits
[10:19:55.750]             invokeRestart <- base::invokeRestart
[10:19:55.750]             length <- base::length
[10:19:55.750]             list <- base::list
[10:19:55.750]             seq.int <- base::seq.int
[10:19:55.750]             signalCondition <- base::signalCondition
[10:19:55.750]             sys.calls <- base::sys.calls
[10:19:55.750]             `[[` <- base::`[[`
[10:19:55.750]             `+` <- base::`+`
[10:19:55.750]             `<<-` <- base::`<<-`
[10:19:55.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:55.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:55.750]                   3L)]
[10:19:55.750]             }
[10:19:55.750]             function(cond) {
[10:19:55.750]                 is_error <- inherits(cond, "error")
[10:19:55.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:55.750]                   NULL)
[10:19:55.750]                 if (is_error) {
[10:19:55.750]                   sessionInformation <- function() {
[10:19:55.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:55.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:55.750]                       search = base::search(), system = base::Sys.info())
[10:19:55.750]                   }
[10:19:55.750]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:55.750]                     cond$call), session = sessionInformation(), 
[10:19:55.750]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:55.750]                   signalCondition(cond)
[10:19:55.750]                 }
[10:19:55.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:55.750]                 "immediateCondition"))) {
[10:19:55.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:55.750]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:55.750]                   if (TRUE && !signal) {
[10:19:55.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.750]                     {
[10:19:55.750]                       inherits <- base::inherits
[10:19:55.750]                       invokeRestart <- base::invokeRestart
[10:19:55.750]                       is.null <- base::is.null
[10:19:55.750]                       muffled <- FALSE
[10:19:55.750]                       if (inherits(cond, "message")) {
[10:19:55.750]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.750]                         if (muffled) 
[10:19:55.750]                           invokeRestart("muffleMessage")
[10:19:55.750]                       }
[10:19:55.750]                       else if (inherits(cond, "warning")) {
[10:19:55.750]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.750]                         if (muffled) 
[10:19:55.750]                           invokeRestart("muffleWarning")
[10:19:55.750]                       }
[10:19:55.750]                       else if (inherits(cond, "condition")) {
[10:19:55.750]                         if (!is.null(pattern)) {
[10:19:55.750]                           computeRestarts <- base::computeRestarts
[10:19:55.750]                           grepl <- base::grepl
[10:19:55.750]                           restarts <- computeRestarts(cond)
[10:19:55.750]                           for (restart in restarts) {
[10:19:55.750]                             name <- restart$name
[10:19:55.750]                             if (is.null(name)) 
[10:19:55.750]                               next
[10:19:55.750]                             if (!grepl(pattern, name)) 
[10:19:55.750]                               next
[10:19:55.750]                             invokeRestart(restart)
[10:19:55.750]                             muffled <- TRUE
[10:19:55.750]                             break
[10:19:55.750]                           }
[10:19:55.750]                         }
[10:19:55.750]                       }
[10:19:55.750]                       invisible(muffled)
[10:19:55.750]                     }
[10:19:55.750]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.750]                   }
[10:19:55.750]                 }
[10:19:55.750]                 else {
[10:19:55.750]                   if (TRUE) {
[10:19:55.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.750]                     {
[10:19:55.750]                       inherits <- base::inherits
[10:19:55.750]                       invokeRestart <- base::invokeRestart
[10:19:55.750]                       is.null <- base::is.null
[10:19:55.750]                       muffled <- FALSE
[10:19:55.750]                       if (inherits(cond, "message")) {
[10:19:55.750]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.750]                         if (muffled) 
[10:19:55.750]                           invokeRestart("muffleMessage")
[10:19:55.750]                       }
[10:19:55.750]                       else if (inherits(cond, "warning")) {
[10:19:55.750]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.750]                         if (muffled) 
[10:19:55.750]                           invokeRestart("muffleWarning")
[10:19:55.750]                       }
[10:19:55.750]                       else if (inherits(cond, "condition")) {
[10:19:55.750]                         if (!is.null(pattern)) {
[10:19:55.750]                           computeRestarts <- base::computeRestarts
[10:19:55.750]                           grepl <- base::grepl
[10:19:55.750]                           restarts <- computeRestarts(cond)
[10:19:55.750]                           for (restart in restarts) {
[10:19:55.750]                             name <- restart$name
[10:19:55.750]                             if (is.null(name)) 
[10:19:55.750]                               next
[10:19:55.750]                             if (!grepl(pattern, name)) 
[10:19:55.750]                               next
[10:19:55.750]                             invokeRestart(restart)
[10:19:55.750]                             muffled <- TRUE
[10:19:55.750]                             break
[10:19:55.750]                           }
[10:19:55.750]                         }
[10:19:55.750]                       }
[10:19:55.750]                       invisible(muffled)
[10:19:55.750]                     }
[10:19:55.750]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.750]                   }
[10:19:55.750]                 }
[10:19:55.750]             }
[10:19:55.750]         }))
[10:19:55.750]     }, error = function(ex) {
[10:19:55.750]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:55.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.750]                 ...future.rng), started = ...future.startTime, 
[10:19:55.750]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:55.750]             version = "1.8"), class = "FutureResult")
[10:19:55.750]     }, finally = {
[10:19:55.750]         if (!identical(...future.workdir, getwd())) 
[10:19:55.750]             setwd(...future.workdir)
[10:19:55.750]         {
[10:19:55.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:55.750]                 ...future.oldOptions$nwarnings <- NULL
[10:19:55.750]             }
[10:19:55.750]             base::options(...future.oldOptions)
[10:19:55.750]             if (.Platform$OS.type == "windows") {
[10:19:55.750]                 old_names <- names(...future.oldEnvVars)
[10:19:55.750]                 envs <- base::Sys.getenv()
[10:19:55.750]                 names <- names(envs)
[10:19:55.750]                 common <- intersect(names, old_names)
[10:19:55.750]                 added <- setdiff(names, old_names)
[10:19:55.750]                 removed <- setdiff(old_names, names)
[10:19:55.750]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:55.750]                   envs[common]]
[10:19:55.750]                 NAMES <- toupper(changed)
[10:19:55.750]                 args <- list()
[10:19:55.750]                 for (kk in seq_along(NAMES)) {
[10:19:55.750]                   name <- changed[[kk]]
[10:19:55.750]                   NAME <- NAMES[[kk]]
[10:19:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.750]                     next
[10:19:55.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.750]                 }
[10:19:55.750]                 NAMES <- toupper(added)
[10:19:55.750]                 for (kk in seq_along(NAMES)) {
[10:19:55.750]                   name <- added[[kk]]
[10:19:55.750]                   NAME <- NAMES[[kk]]
[10:19:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.750]                     next
[10:19:55.750]                   args[[name]] <- ""
[10:19:55.750]                 }
[10:19:55.750]                 NAMES <- toupper(removed)
[10:19:55.750]                 for (kk in seq_along(NAMES)) {
[10:19:55.750]                   name <- removed[[kk]]
[10:19:55.750]                   NAME <- NAMES[[kk]]
[10:19:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.750]                     next
[10:19:55.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.750]                 }
[10:19:55.750]                 if (length(args) > 0) 
[10:19:55.750]                   base::do.call(base::Sys.setenv, args = args)
[10:19:55.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:55.750]             }
[10:19:55.750]             else {
[10:19:55.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:55.750]             }
[10:19:55.750]             {
[10:19:55.750]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:55.750]                   0L) {
[10:19:55.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:55.750]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:55.750]                   base::options(opts)
[10:19:55.750]                 }
[10:19:55.750]                 {
[10:19:55.750]                   {
[10:19:55.750]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:55.750]                     NULL
[10:19:55.750]                   }
[10:19:55.750]                   options(future.plan = NULL)
[10:19:55.750]                   if (is.na(NA_character_)) 
[10:19:55.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:55.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:55.750]                     .init = FALSE)
[10:19:55.750]                 }
[10:19:55.750]             }
[10:19:55.750]         }
[10:19:55.750]     })
[10:19:55.750]     if (TRUE) {
[10:19:55.750]         base::sink(type = "output", split = FALSE)
[10:19:55.750]         if (TRUE) {
[10:19:55.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:55.750]         }
[10:19:55.750]         else {
[10:19:55.750]             ...future.result["stdout"] <- base::list(NULL)
[10:19:55.750]         }
[10:19:55.750]         base::close(...future.stdout)
[10:19:55.750]         ...future.stdout <- NULL
[10:19:55.750]     }
[10:19:55.750]     ...future.result$conditions <- ...future.conditions
[10:19:55.750]     ...future.result$finished <- base::Sys.time()
[10:19:55.750]     ...future.result
[10:19:55.750] }
[10:19:55.753] Exporting 11 global objects (12.56 KiB) to cluster node #1 ...
[10:19:55.754] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #1 ...
[10:19:55.794] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #1 ... DONE
[10:19:55.795] Exporting ‘x_FUN’ (35 bytes) to cluster node #1 ...
[10:19:55.795] Exporting ‘x_FUN’ (35 bytes) to cluster node #1 ... DONE
[10:19:55.795] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:55.796] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:55.796] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:55.836] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:55.837] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:55.877] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:55.877] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:55.878] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.878] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:55.878] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:55.879] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:55.879] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:55.879] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[10:19:55.879] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[10:19:55.880] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:55.880] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.880] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:55.880] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:55.880] Exporting 11 global objects (12.56 KiB) to cluster node #1 ... DONE
[10:19:55.881] MultisessionFuture started
[10:19:55.881] - Launch lazy future ... done
[10:19:55.881] run() for ‘MultisessionFuture’ ... done
[10:19:55.881] Created future:
[10:19:55.881] MultisessionFuture:
[10:19:55.881] Label: ‘future_vapply-1’
[10:19:55.881] Expression:
[10:19:55.881] {
[10:19:55.881]     do.call(function(...) {
[10:19:55.881]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.881]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.881]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.881]             on.exit(options(oopts), add = TRUE)
[10:19:55.881]         }
[10:19:55.881]         {
[10:19:55.881]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.881]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.881]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.881]             })
[10:19:55.881]         }
[10:19:55.881]     }, args = future.call.arguments)
[10:19:55.881] }
[10:19:55.881] Lazy evaluation: FALSE
[10:19:55.881] Asynchronous evaluation: TRUE
[10:19:55.881] Local evaluation: TRUE
[10:19:55.881] Environment: R_GlobalEnv
[10:19:55.881] Capture standard output: TRUE
[10:19:55.881] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:55.881] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:55.881] Packages: 1 packages (‘future.apply’)
[10:19:55.881] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:55.881] Resolved: FALSE
[10:19:55.881] Value: <not collected>
[10:19:55.881] Conditions captured: <none>
[10:19:55.881] Early signaling: FALSE
[10:19:55.881] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:55.881] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.893] Chunk #1 of 2 ... DONE
[10:19:55.893] Chunk #2 of 2 ...
[10:19:55.893]  - Finding globals in 'X' for chunk #2 ...
[10:19:55.893] getGlobalsAndPackages() ...
[10:19:55.894] Searching for globals...
[10:19:55.894] 
[10:19:55.894] Searching for globals ... DONE
[10:19:55.894] - globals: [0] <none>
[10:19:55.894] getGlobalsAndPackages() ... DONE
[10:19:55.894]    + additional globals found: [n=0] 
[10:19:55.894]    + additional namespaces needed: [n=0] 
[10:19:55.894]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:55.894]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:55.895]  - seeds: <none>
[10:19:55.895]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.895] getGlobalsAndPackages() ...
[10:19:55.895] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.895] Resolving globals: FALSE
[10:19:55.895] Tweak future expression to call with '...' arguments ...
[10:19:55.895] {
[10:19:55.895]     do.call(function(...) {
[10:19:55.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:55.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.895]             on.exit(options(oopts), add = TRUE)
[10:19:55.895]         }
[10:19:55.895]         {
[10:19:55.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:55.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.895]                 ...future.FUN(...future.X_jj, ...)
[10:19:55.895]             })
[10:19:55.895]         }
[10:19:55.895]     }, args = future.call.arguments)
[10:19:55.895] }
[10:19:55.895] Tweak future expression to call with '...' arguments ... DONE
[10:19:55.896] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:55.896] - packages: [1] ‘future.apply’
[10:19:55.896] getGlobalsAndPackages() ... DONE
[10:19:55.897] run() for ‘Future’ ...
[10:19:55.897] - state: ‘created’
[10:19:55.897] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:55.911] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:55.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:55.911]   - Field: ‘node’
[10:19:55.911]   - Field: ‘label’
[10:19:55.911]   - Field: ‘local’
[10:19:55.911]   - Field: ‘owner’
[10:19:55.912]   - Field: ‘envir’
[10:19:55.912]   - Field: ‘workers’
[10:19:55.912]   - Field: ‘packages’
[10:19:55.912]   - Field: ‘gc’
[10:19:55.912]   - Field: ‘conditions’
[10:19:55.912]   - Field: ‘persistent’
[10:19:55.912]   - Field: ‘expr’
[10:19:55.912]   - Field: ‘uuid’
[10:19:55.912]   - Field: ‘seed’
[10:19:55.912]   - Field: ‘version’
[10:19:55.912]   - Field: ‘result’
[10:19:55.912]   - Field: ‘asynchronous’
[10:19:55.913]   - Field: ‘calls’
[10:19:55.913]   - Field: ‘globals’
[10:19:55.913]   - Field: ‘stdout’
[10:19:55.913]   - Field: ‘earlySignal’
[10:19:55.913]   - Field: ‘lazy’
[10:19:55.913]   - Field: ‘state’
[10:19:55.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:55.913] - Launch lazy future ...
[10:19:55.913] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:55.914] Packages needed by future strategies (n = 0): <none>
[10:19:55.914] {
[10:19:55.914]     {
[10:19:55.914]         {
[10:19:55.914]             ...future.startTime <- base::Sys.time()
[10:19:55.914]             {
[10:19:55.914]                 {
[10:19:55.914]                   {
[10:19:55.914]                     {
[10:19:55.914]                       {
[10:19:55.914]                         base::local({
[10:19:55.914]                           has_future <- base::requireNamespace("future", 
[10:19:55.914]                             quietly = TRUE)
[10:19:55.914]                           if (has_future) {
[10:19:55.914]                             ns <- base::getNamespace("future")
[10:19:55.914]                             version <- ns[[".package"]][["version"]]
[10:19:55.914]                             if (is.null(version)) 
[10:19:55.914]                               version <- utils::packageVersion("future")
[10:19:55.914]                           }
[10:19:55.914]                           else {
[10:19:55.914]                             version <- NULL
[10:19:55.914]                           }
[10:19:55.914]                           if (!has_future || version < "1.8.0") {
[10:19:55.914]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:55.914]                               "", base::R.version$version.string), 
[10:19:55.914]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:55.914]                                 base::R.version$platform, 8 * 
[10:19:55.914]                                   base::.Machine$sizeof.pointer), 
[10:19:55.914]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:55.914]                                 "release", "version")], collapse = " "), 
[10:19:55.914]                               hostname = base::Sys.info()[["nodename"]])
[10:19:55.914]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:55.914]                               info)
[10:19:55.914]                             info <- base::paste(info, collapse = "; ")
[10:19:55.914]                             if (!has_future) {
[10:19:55.914]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:55.914]                                 info)
[10:19:55.914]                             }
[10:19:55.914]                             else {
[10:19:55.914]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:55.914]                                 info, version)
[10:19:55.914]                             }
[10:19:55.914]                             base::stop(msg)
[10:19:55.914]                           }
[10:19:55.914]                         })
[10:19:55.914]                       }
[10:19:55.914]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:55.914]                       base::options(mc.cores = 1L)
[10:19:55.914]                     }
[10:19:55.914]                     base::local({
[10:19:55.914]                       for (pkg in "future.apply") {
[10:19:55.914]                         base::loadNamespace(pkg)
[10:19:55.914]                         base::library(pkg, character.only = TRUE)
[10:19:55.914]                       }
[10:19:55.914]                     })
[10:19:55.914]                   }
[10:19:55.914]                   ...future.strategy.old <- future::plan("list")
[10:19:55.914]                   options(future.plan = NULL)
[10:19:55.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:55.914]                 }
[10:19:55.914]                 ...future.workdir <- getwd()
[10:19:55.914]             }
[10:19:55.914]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:55.914]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:55.914]         }
[10:19:55.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:55.914]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:55.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:55.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:55.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:55.914]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:55.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:55.914]             base::names(...future.oldOptions))
[10:19:55.914]     }
[10:19:55.914]     if (FALSE) {
[10:19:55.914]     }
[10:19:55.914]     else {
[10:19:55.914]         if (TRUE) {
[10:19:55.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:55.914]                 open = "w")
[10:19:55.914]         }
[10:19:55.914]         else {
[10:19:55.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:55.914]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:55.914]         }
[10:19:55.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:55.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:55.914]             base::sink(type = "output", split = FALSE)
[10:19:55.914]             base::close(...future.stdout)
[10:19:55.914]         }, add = TRUE)
[10:19:55.914]     }
[10:19:55.914]     ...future.frame <- base::sys.nframe()
[10:19:55.914]     ...future.conditions <- base::list()
[10:19:55.914]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:55.914]     if (FALSE) {
[10:19:55.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:55.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:55.914]     }
[10:19:55.914]     ...future.result <- base::tryCatch({
[10:19:55.914]         base::withCallingHandlers({
[10:19:55.914]             ...future.value <- base::withVisible(base::local({
[10:19:55.914]                 ...future.makeSendCondition <- base::local({
[10:19:55.914]                   sendCondition <- NULL
[10:19:55.914]                   function(frame = 1L) {
[10:19:55.914]                     if (is.function(sendCondition)) 
[10:19:55.914]                       return(sendCondition)
[10:19:55.914]                     ns <- getNamespace("parallel")
[10:19:55.914]                     if (exists("sendData", mode = "function", 
[10:19:55.914]                       envir = ns)) {
[10:19:55.914]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:55.914]                         envir = ns)
[10:19:55.914]                       envir <- sys.frame(frame)
[10:19:55.914]                       master <- NULL
[10:19:55.914]                       while (!identical(envir, .GlobalEnv) && 
[10:19:55.914]                         !identical(envir, emptyenv())) {
[10:19:55.914]                         if (exists("master", mode = "list", envir = envir, 
[10:19:55.914]                           inherits = FALSE)) {
[10:19:55.914]                           master <- get("master", mode = "list", 
[10:19:55.914]                             envir = envir, inherits = FALSE)
[10:19:55.914]                           if (inherits(master, c("SOCKnode", 
[10:19:55.914]                             "SOCK0node"))) {
[10:19:55.914]                             sendCondition <<- function(cond) {
[10:19:55.914]                               data <- list(type = "VALUE", value = cond, 
[10:19:55.914]                                 success = TRUE)
[10:19:55.914]                               parallel_sendData(master, data)
[10:19:55.914]                             }
[10:19:55.914]                             return(sendCondition)
[10:19:55.914]                           }
[10:19:55.914]                         }
[10:19:55.914]                         frame <- frame + 1L
[10:19:55.914]                         envir <- sys.frame(frame)
[10:19:55.914]                       }
[10:19:55.914]                     }
[10:19:55.914]                     sendCondition <<- function(cond) NULL
[10:19:55.914]                   }
[10:19:55.914]                 })
[10:19:55.914]                 withCallingHandlers({
[10:19:55.914]                   {
[10:19:55.914]                     do.call(function(...) {
[10:19:55.914]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:55.914]                       if (!identical(...future.globals.maxSize.org, 
[10:19:55.914]                         ...future.globals.maxSize)) {
[10:19:55.914]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:55.914]                         on.exit(options(oopts), add = TRUE)
[10:19:55.914]                       }
[10:19:55.914]                       {
[10:19:55.914]                         lapply(seq_along(...future.elements_ii), 
[10:19:55.914]                           FUN = function(jj) {
[10:19:55.914]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:55.914]                             ...future.FUN(...future.X_jj, ...)
[10:19:55.914]                           })
[10:19:55.914]                       }
[10:19:55.914]                     }, args = future.call.arguments)
[10:19:55.914]                   }
[10:19:55.914]                 }, immediateCondition = function(cond) {
[10:19:55.914]                   sendCondition <- ...future.makeSendCondition()
[10:19:55.914]                   sendCondition(cond)
[10:19:55.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.914]                   {
[10:19:55.914]                     inherits <- base::inherits
[10:19:55.914]                     invokeRestart <- base::invokeRestart
[10:19:55.914]                     is.null <- base::is.null
[10:19:55.914]                     muffled <- FALSE
[10:19:55.914]                     if (inherits(cond, "message")) {
[10:19:55.914]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:55.914]                       if (muffled) 
[10:19:55.914]                         invokeRestart("muffleMessage")
[10:19:55.914]                     }
[10:19:55.914]                     else if (inherits(cond, "warning")) {
[10:19:55.914]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:55.914]                       if (muffled) 
[10:19:55.914]                         invokeRestart("muffleWarning")
[10:19:55.914]                     }
[10:19:55.914]                     else if (inherits(cond, "condition")) {
[10:19:55.914]                       if (!is.null(pattern)) {
[10:19:55.914]                         computeRestarts <- base::computeRestarts
[10:19:55.914]                         grepl <- base::grepl
[10:19:55.914]                         restarts <- computeRestarts(cond)
[10:19:55.914]                         for (restart in restarts) {
[10:19:55.914]                           name <- restart$name
[10:19:55.914]                           if (is.null(name)) 
[10:19:55.914]                             next
[10:19:55.914]                           if (!grepl(pattern, name)) 
[10:19:55.914]                             next
[10:19:55.914]                           invokeRestart(restart)
[10:19:55.914]                           muffled <- TRUE
[10:19:55.914]                           break
[10:19:55.914]                         }
[10:19:55.914]                       }
[10:19:55.914]                     }
[10:19:55.914]                     invisible(muffled)
[10:19:55.914]                   }
[10:19:55.914]                   muffleCondition(cond)
[10:19:55.914]                 })
[10:19:55.914]             }))
[10:19:55.914]             future::FutureResult(value = ...future.value$value, 
[10:19:55.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.914]                   ...future.rng), globalenv = if (FALSE) 
[10:19:55.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:55.914]                     ...future.globalenv.names))
[10:19:55.914]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:55.914]         }, condition = base::local({
[10:19:55.914]             c <- base::c
[10:19:55.914]             inherits <- base::inherits
[10:19:55.914]             invokeRestart <- base::invokeRestart
[10:19:55.914]             length <- base::length
[10:19:55.914]             list <- base::list
[10:19:55.914]             seq.int <- base::seq.int
[10:19:55.914]             signalCondition <- base::signalCondition
[10:19:55.914]             sys.calls <- base::sys.calls
[10:19:55.914]             `[[` <- base::`[[`
[10:19:55.914]             `+` <- base::`+`
[10:19:55.914]             `<<-` <- base::`<<-`
[10:19:55.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:55.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:55.914]                   3L)]
[10:19:55.914]             }
[10:19:55.914]             function(cond) {
[10:19:55.914]                 is_error <- inherits(cond, "error")
[10:19:55.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:55.914]                   NULL)
[10:19:55.914]                 if (is_error) {
[10:19:55.914]                   sessionInformation <- function() {
[10:19:55.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:55.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:55.914]                       search = base::search(), system = base::Sys.info())
[10:19:55.914]                   }
[10:19:55.914]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:55.914]                     cond$call), session = sessionInformation(), 
[10:19:55.914]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:55.914]                   signalCondition(cond)
[10:19:55.914]                 }
[10:19:55.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:55.914]                 "immediateCondition"))) {
[10:19:55.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:55.914]                   ...future.conditions[[length(...future.conditions) + 
[10:19:55.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:55.914]                   if (TRUE && !signal) {
[10:19:55.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.914]                     {
[10:19:55.914]                       inherits <- base::inherits
[10:19:55.914]                       invokeRestart <- base::invokeRestart
[10:19:55.914]                       is.null <- base::is.null
[10:19:55.914]                       muffled <- FALSE
[10:19:55.914]                       if (inherits(cond, "message")) {
[10:19:55.914]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.914]                         if (muffled) 
[10:19:55.914]                           invokeRestart("muffleMessage")
[10:19:55.914]                       }
[10:19:55.914]                       else if (inherits(cond, "warning")) {
[10:19:55.914]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.914]                         if (muffled) 
[10:19:55.914]                           invokeRestart("muffleWarning")
[10:19:55.914]                       }
[10:19:55.914]                       else if (inherits(cond, "condition")) {
[10:19:55.914]                         if (!is.null(pattern)) {
[10:19:55.914]                           computeRestarts <- base::computeRestarts
[10:19:55.914]                           grepl <- base::grepl
[10:19:55.914]                           restarts <- computeRestarts(cond)
[10:19:55.914]                           for (restart in restarts) {
[10:19:55.914]                             name <- restart$name
[10:19:55.914]                             if (is.null(name)) 
[10:19:55.914]                               next
[10:19:55.914]                             if (!grepl(pattern, name)) 
[10:19:55.914]                               next
[10:19:55.914]                             invokeRestart(restart)
[10:19:55.914]                             muffled <- TRUE
[10:19:55.914]                             break
[10:19:55.914]                           }
[10:19:55.914]                         }
[10:19:55.914]                       }
[10:19:55.914]                       invisible(muffled)
[10:19:55.914]                     }
[10:19:55.914]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.914]                   }
[10:19:55.914]                 }
[10:19:55.914]                 else {
[10:19:55.914]                   if (TRUE) {
[10:19:55.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:55.914]                     {
[10:19:55.914]                       inherits <- base::inherits
[10:19:55.914]                       invokeRestart <- base::invokeRestart
[10:19:55.914]                       is.null <- base::is.null
[10:19:55.914]                       muffled <- FALSE
[10:19:55.914]                       if (inherits(cond, "message")) {
[10:19:55.914]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:55.914]                         if (muffled) 
[10:19:55.914]                           invokeRestart("muffleMessage")
[10:19:55.914]                       }
[10:19:55.914]                       else if (inherits(cond, "warning")) {
[10:19:55.914]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:55.914]                         if (muffled) 
[10:19:55.914]                           invokeRestart("muffleWarning")
[10:19:55.914]                       }
[10:19:55.914]                       else if (inherits(cond, "condition")) {
[10:19:55.914]                         if (!is.null(pattern)) {
[10:19:55.914]                           computeRestarts <- base::computeRestarts
[10:19:55.914]                           grepl <- base::grepl
[10:19:55.914]                           restarts <- computeRestarts(cond)
[10:19:55.914]                           for (restart in restarts) {
[10:19:55.914]                             name <- restart$name
[10:19:55.914]                             if (is.null(name)) 
[10:19:55.914]                               next
[10:19:55.914]                             if (!grepl(pattern, name)) 
[10:19:55.914]                               next
[10:19:55.914]                             invokeRestart(restart)
[10:19:55.914]                             muffled <- TRUE
[10:19:55.914]                             break
[10:19:55.914]                           }
[10:19:55.914]                         }
[10:19:55.914]                       }
[10:19:55.914]                       invisible(muffled)
[10:19:55.914]                     }
[10:19:55.914]                     muffleCondition(cond, pattern = "^muffle")
[10:19:55.914]                   }
[10:19:55.914]                 }
[10:19:55.914]             }
[10:19:55.914]         }))
[10:19:55.914]     }, error = function(ex) {
[10:19:55.914]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:55.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:55.914]                 ...future.rng), started = ...future.startTime, 
[10:19:55.914]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:55.914]             version = "1.8"), class = "FutureResult")
[10:19:55.914]     }, finally = {
[10:19:55.914]         if (!identical(...future.workdir, getwd())) 
[10:19:55.914]             setwd(...future.workdir)
[10:19:55.914]         {
[10:19:55.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:55.914]                 ...future.oldOptions$nwarnings <- NULL
[10:19:55.914]             }
[10:19:55.914]             base::options(...future.oldOptions)
[10:19:55.914]             if (.Platform$OS.type == "windows") {
[10:19:55.914]                 old_names <- names(...future.oldEnvVars)
[10:19:55.914]                 envs <- base::Sys.getenv()
[10:19:55.914]                 names <- names(envs)
[10:19:55.914]                 common <- intersect(names, old_names)
[10:19:55.914]                 added <- setdiff(names, old_names)
[10:19:55.914]                 removed <- setdiff(old_names, names)
[10:19:55.914]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:55.914]                   envs[common]]
[10:19:55.914]                 NAMES <- toupper(changed)
[10:19:55.914]                 args <- list()
[10:19:55.914]                 for (kk in seq_along(NAMES)) {
[10:19:55.914]                   name <- changed[[kk]]
[10:19:55.914]                   NAME <- NAMES[[kk]]
[10:19:55.914]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.914]                     next
[10:19:55.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.914]                 }
[10:19:55.914]                 NAMES <- toupper(added)
[10:19:55.914]                 for (kk in seq_along(NAMES)) {
[10:19:55.914]                   name <- added[[kk]]
[10:19:55.914]                   NAME <- NAMES[[kk]]
[10:19:55.914]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.914]                     next
[10:19:55.914]                   args[[name]] <- ""
[10:19:55.914]                 }
[10:19:55.914]                 NAMES <- toupper(removed)
[10:19:55.914]                 for (kk in seq_along(NAMES)) {
[10:19:55.914]                   name <- removed[[kk]]
[10:19:55.914]                   NAME <- NAMES[[kk]]
[10:19:55.914]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:55.914]                     next
[10:19:55.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:55.914]                 }
[10:19:55.914]                 if (length(args) > 0) 
[10:19:55.914]                   base::do.call(base::Sys.setenv, args = args)
[10:19:55.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:55.914]             }
[10:19:55.914]             else {
[10:19:55.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:55.914]             }
[10:19:55.914]             {
[10:19:55.914]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:55.914]                   0L) {
[10:19:55.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:55.914]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:55.914]                   base::options(opts)
[10:19:55.914]                 }
[10:19:55.914]                 {
[10:19:55.914]                   {
[10:19:55.914]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:55.914]                     NULL
[10:19:55.914]                   }
[10:19:55.914]                   options(future.plan = NULL)
[10:19:55.914]                   if (is.na(NA_character_)) 
[10:19:55.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:55.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:55.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:55.914]                     .init = FALSE)
[10:19:55.914]                 }
[10:19:55.914]             }
[10:19:55.914]         }
[10:19:55.914]     })
[10:19:55.914]     if (TRUE) {
[10:19:55.914]         base::sink(type = "output", split = FALSE)
[10:19:55.914]         if (TRUE) {
[10:19:55.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:55.914]         }
[10:19:55.914]         else {
[10:19:55.914]             ...future.result["stdout"] <- base::list(NULL)
[10:19:55.914]         }
[10:19:55.914]         base::close(...future.stdout)
[10:19:55.914]         ...future.stdout <- NULL
[10:19:55.914]     }
[10:19:55.914]     ...future.result$conditions <- ...future.conditions
[10:19:55.914]     ...future.result$finished <- base::Sys.time()
[10:19:55.914]     ...future.result
[10:19:55.914] }
[10:19:55.917] Exporting 11 global objects (12.56 KiB) to cluster node #2 ...
[10:19:55.917] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #2 ...
[10:19:55.959] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #2 ... DONE
[10:19:55.959] Exporting ‘x_FUN’ (35 bytes) to cluster node #2 ...
[10:19:55.960] Exporting ‘x_FUN’ (35 bytes) to cluster node #2 ... DONE
[10:19:55.960] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:55.960] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:55.960] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:56.001] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:56.002] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:56.042] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:56.043] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:56.043] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.043] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:56.043] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:56.043] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:56.044] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:56.044] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[10:19:56.044] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[10:19:56.044] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:56.045] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.045] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:56.045] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.045] Exporting 11 global objects (12.56 KiB) to cluster node #2 ... DONE
[10:19:56.046] MultisessionFuture started
[10:19:56.046] - Launch lazy future ... done
[10:19:56.046] run() for ‘MultisessionFuture’ ... done
[10:19:56.046] Created future:
[10:19:56.046] MultisessionFuture:
[10:19:56.046] Label: ‘future_vapply-2’
[10:19:56.046] Expression:
[10:19:56.046] {
[10:19:56.046]     do.call(function(...) {
[10:19:56.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.046]             on.exit(options(oopts), add = TRUE)
[10:19:56.046]         }
[10:19:56.046]         {
[10:19:56.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.046]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.046]             })
[10:19:56.046]         }
[10:19:56.046]     }, args = future.call.arguments)
[10:19:56.046] }
[10:19:56.046] Lazy evaluation: FALSE
[10:19:56.046] Asynchronous evaluation: TRUE
[10:19:56.046] Local evaluation: TRUE
[10:19:56.046] Environment: R_GlobalEnv
[10:19:56.046] Capture standard output: TRUE
[10:19:56.046] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:56.046] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:56.046] Packages: 1 packages (‘future.apply’)
[10:19:56.046] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:56.046] Resolved: FALSE
[10:19:56.046] Value: <not collected>
[10:19:56.046] Conditions captured: <none>
[10:19:56.046] Early signaling: FALSE
[10:19:56.046] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:56.046] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.058] Chunk #2 of 2 ... DONE
[10:19:56.058] Launching 2 futures (chunks) ... DONE
[10:19:56.058] Resolving 2 futures (chunks) ...
[10:19:56.058] resolve() on list ...
[10:19:56.058]  recursive: 0
[10:19:56.059]  length: 2
[10:19:56.059] 
[10:19:56.059] receiveMessageFromWorker() for ClusterFuture ...
[10:19:56.059] - Validating connection of MultisessionFuture
[10:19:56.059] - received message: FutureResult
[10:19:56.060] - Received FutureResult
[10:19:56.060] - Erased future from FutureRegistry
[10:19:56.060] result() for ClusterFuture ...
[10:19:56.060] - result already collected: FutureResult
[10:19:56.060] result() for ClusterFuture ... done
[10:19:56.060] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:56.060] Future #1
[10:19:56.060] result() for ClusterFuture ...
[10:19:56.060] - result already collected: FutureResult
[10:19:56.060] result() for ClusterFuture ... done
[10:19:56.060] result() for ClusterFuture ...
[10:19:56.061] - result already collected: FutureResult
[10:19:56.061] result() for ClusterFuture ... done
[10:19:56.061] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:56.061] - nx: 2
[10:19:56.061] - relay: TRUE
[10:19:56.061] - stdout: TRUE
[10:19:56.063] - signal: TRUE
[10:19:56.064] - resignal: FALSE
[10:19:56.064] - force: TRUE
[10:19:56.064] - relayed: [n=2] FALSE, FALSE
[10:19:56.064] - queued futures: [n=2] FALSE, FALSE
[10:19:56.064]  - until=1
[10:19:56.064]  - relaying element #1
[10:19:56.064] result() for ClusterFuture ...
[10:19:56.064] - result already collected: FutureResult
[10:19:56.064] result() for ClusterFuture ... done
[10:19:56.064] result() for ClusterFuture ...
[10:19:56.064] - result already collected: FutureResult
[10:19:56.065] result() for ClusterFuture ... done
[10:19:56.065] result() for ClusterFuture ...
[10:19:56.065] - result already collected: FutureResult
[10:19:56.065] result() for ClusterFuture ... done
[10:19:56.065] result() for ClusterFuture ...
[10:19:56.065] - result already collected: FutureResult
[10:19:56.065] result() for ClusterFuture ... done
[10:19:56.065] - relayed: [n=2] TRUE, FALSE
[10:19:56.065] - queued futures: [n=2] TRUE, FALSE
[10:19:56.065] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:56.065]  length: 1 (resolved future 1)
[10:19:56.088] receiveMessageFromWorker() for ClusterFuture ...
[10:19:56.088] - Validating connection of MultisessionFuture
[10:19:56.088] - received message: FutureResult
[10:19:56.089] - Received FutureResult
[10:19:56.089] - Erased future from FutureRegistry
[10:19:56.089] result() for ClusterFuture ...
[10:19:56.089] - result already collected: FutureResult
[10:19:56.089] result() for ClusterFuture ... done
[10:19:56.089] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:56.089] Future #2
[10:19:56.089] result() for ClusterFuture ...
[10:19:56.089] - result already collected: FutureResult
[10:19:56.089] result() for ClusterFuture ... done
[10:19:56.090] result() for ClusterFuture ...
[10:19:56.090] - result already collected: FutureResult
[10:19:56.090] result() for ClusterFuture ... done
[10:19:56.090] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:56.090] - nx: 2
[10:19:56.090] - relay: TRUE
[10:19:56.090] - stdout: TRUE
[10:19:56.090] - signal: TRUE
[10:19:56.090] - resignal: FALSE
[10:19:56.090] - force: TRUE
[10:19:56.090] - relayed: [n=2] TRUE, FALSE
[10:19:56.090] - queued futures: [n=2] TRUE, FALSE
[10:19:56.091]  - until=2
[10:19:56.091]  - relaying element #2
[10:19:56.091] result() for ClusterFuture ...
[10:19:56.091] - result already collected: FutureResult
[10:19:56.091] result() for ClusterFuture ... done
[10:19:56.091] result() for ClusterFuture ...
[10:19:56.091] - result already collected: FutureResult
[10:19:56.091] result() for ClusterFuture ... done
[10:19:56.091] result() for ClusterFuture ...
[10:19:56.091] - result already collected: FutureResult
[10:19:56.091] result() for ClusterFuture ... done
[10:19:56.091] result() for ClusterFuture ...
[10:19:56.092] - result already collected: FutureResult
[10:19:56.092] result() for ClusterFuture ... done
[10:19:56.092] - relayed: [n=2] TRUE, TRUE
[10:19:56.092] - queued futures: [n=2] TRUE, TRUE
[10:19:56.092] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:56.092]  length: 0 (resolved future 2)
[10:19:56.092] Relaying remaining futures
[10:19:56.092] signalConditionsASAP(NULL, pos=0) ...
[10:19:56.092] - nx: 2
[10:19:56.092] - relay: TRUE
[10:19:56.092] - stdout: TRUE
[10:19:56.092] - signal: TRUE
[10:19:56.093] - resignal: FALSE
[10:19:56.093] - force: TRUE
[10:19:56.093] - relayed: [n=2] TRUE, TRUE
[10:19:56.093] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:56.093] - relayed: [n=2] TRUE, TRUE
[10:19:56.093] - queued futures: [n=2] TRUE, TRUE
[10:19:56.093] signalConditionsASAP(NULL, pos=0) ... done
[10:19:56.093] resolve() on list ... DONE
[10:19:56.093] result() for ClusterFuture ...
[10:19:56.093] - result already collected: FutureResult
[10:19:56.093] result() for ClusterFuture ... done
[10:19:56.093] result() for ClusterFuture ...
[10:19:56.094] - result already collected: FutureResult
[10:19:56.094] result() for ClusterFuture ... done
[10:19:56.094] result() for ClusterFuture ...
[10:19:56.094] - result already collected: FutureResult
[10:19:56.094] result() for ClusterFuture ... done
[10:19:56.094] result() for ClusterFuture ...
[10:19:56.094] - result already collected: FutureResult
[10:19:56.094] result() for ClusterFuture ... done
[10:19:56.094]  - Number of value chunks collected: 2
[10:19:56.094] Resolving 2 futures (chunks) ... DONE
[10:19:56.094] Reducing values from 2 chunks ...
[10:19:56.094]  - Number of values collected after concatenation: 10
[10:19:56.095]  - Number of values expected: 10
[10:19:56.095] Reducing values from 2 chunks ... DONE
[10:19:56.095] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:19:56.096] future_lapply() ...
[10:19:56.099] Number of chunks: 2
[10:19:56.099] getGlobalsAndPackagesXApply() ...
[10:19:56.099]  - future.globals: TRUE
[10:19:56.099] getGlobalsAndPackages() ...
[10:19:56.099] Searching for globals...
[10:19:56.103] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:19:56.103] Searching for globals ... DONE
[10:19:56.103] Resolving globals: FALSE
[10:19:56.104] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[10:19:56.105] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:56.105] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:56.105] - packages: [1] ‘future.apply’
[10:19:56.105] getGlobalsAndPackages() ... DONE
[10:19:56.105]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:56.105]  - needed namespaces: [n=1] ‘future.apply’
[10:19:56.105] Finding globals ... DONE
[10:19:56.105]  - use_args: TRUE
[10:19:56.105]  - Getting '...' globals ...
[10:19:56.106] resolve() on list ...
[10:19:56.106]  recursive: 0
[10:19:56.106]  length: 1
[10:19:56.106]  elements: ‘...’
[10:19:56.106]  length: 0 (resolved future 1)
[10:19:56.106] resolve() on list ... DONE
[10:19:56.106]    - '...' content: [n=0] 
[10:19:56.106] List of 1
[10:19:56.106]  $ ...: list()
[10:19:56.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:56.106]  - attr(*, "where")=List of 1
[10:19:56.106]   ..$ ...:<environment: 0x55c69fd01010> 
[10:19:56.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:56.106]  - attr(*, "resolved")= logi TRUE
[10:19:56.106]  - attr(*, "total_size")= num NA
[10:19:56.109]  - Getting '...' globals ... DONE
[10:19:56.109] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:56.109] List of 8
[10:19:56.109]  $ ...future.FUN:function (x, ...)  
[10:19:56.109]  $ x_FUN        :function (x)  
[10:19:56.109]  $ times        : int 2
[10:19:56.109]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:56.109]  $ stop_if_not  :function (...)  
[10:19:56.109]  $ dim          : NULL
[10:19:56.109]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:56.109]  $ ...          : list()
[10:19:56.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:56.109]  - attr(*, "where")=List of 8
[10:19:56.109]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:56.109]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:56.109]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:56.109]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:56.109]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:56.109]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:56.109]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:56.109]   ..$ ...          :<environment: 0x55c69fd01010> 
[10:19:56.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:56.109]  - attr(*, "resolved")= logi FALSE
[10:19:56.109]  - attr(*, "total_size")= num 24454
[10:19:56.114] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:56.114] getGlobalsAndPackagesXApply() ... DONE
[10:19:56.114] Number of futures (= number of chunks): 2
[10:19:56.114] Launching 2 futures (chunks) ...
[10:19:56.114] Chunk #1 of 2 ...
[10:19:56.115]  - Finding globals in 'X' for chunk #1 ...
[10:19:56.115] getGlobalsAndPackages() ...
[10:19:56.115] Searching for globals...
[10:19:56.115] 
[10:19:56.115] Searching for globals ... DONE
[10:19:56.115] - globals: [0] <none>
[10:19:56.115] getGlobalsAndPackages() ... DONE
[10:19:56.115]    + additional globals found: [n=0] 
[10:19:56.115]    + additional namespaces needed: [n=0] 
[10:19:56.116]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:56.116]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:56.116]  - seeds: <none>
[10:19:56.116]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.116] getGlobalsAndPackages() ...
[10:19:56.116] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.116] Resolving globals: FALSE
[10:19:56.116] Tweak future expression to call with '...' arguments ...
[10:19:56.116] {
[10:19:56.116]     do.call(function(...) {
[10:19:56.116]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.116]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.116]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.116]             on.exit(options(oopts), add = TRUE)
[10:19:56.116]         }
[10:19:56.116]         {
[10:19:56.116]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.116]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.116]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.116]             })
[10:19:56.116]         }
[10:19:56.116]     }, args = future.call.arguments)
[10:19:56.116] }
[10:19:56.117] Tweak future expression to call with '...' arguments ... DONE
[10:19:56.117] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.117] - packages: [1] ‘future.apply’
[10:19:56.117] getGlobalsAndPackages() ... DONE
[10:19:56.118] run() for ‘Future’ ...
[10:19:56.118] - state: ‘created’
[10:19:56.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:56.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:56.134]   - Field: ‘node’
[10:19:56.134]   - Field: ‘label’
[10:19:56.134]   - Field: ‘local’
[10:19:56.134]   - Field: ‘owner’
[10:19:56.134]   - Field: ‘envir’
[10:19:56.134]   - Field: ‘workers’
[10:19:56.134]   - Field: ‘packages’
[10:19:56.134]   - Field: ‘gc’
[10:19:56.134]   - Field: ‘conditions’
[10:19:56.134]   - Field: ‘persistent’
[10:19:56.135]   - Field: ‘expr’
[10:19:56.135]   - Field: ‘uuid’
[10:19:56.135]   - Field: ‘seed’
[10:19:56.135]   - Field: ‘version’
[10:19:56.135]   - Field: ‘result’
[10:19:56.135]   - Field: ‘asynchronous’
[10:19:56.135]   - Field: ‘calls’
[10:19:56.135]   - Field: ‘globals’
[10:19:56.135]   - Field: ‘stdout’
[10:19:56.135]   - Field: ‘earlySignal’
[10:19:56.135]   - Field: ‘lazy’
[10:19:56.135]   - Field: ‘state’
[10:19:56.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:56.136] - Launch lazy future ...
[10:19:56.136] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:56.136] Packages needed by future strategies (n = 0): <none>
[10:19:56.137] {
[10:19:56.137]     {
[10:19:56.137]         {
[10:19:56.137]             ...future.startTime <- base::Sys.time()
[10:19:56.137]             {
[10:19:56.137]                 {
[10:19:56.137]                   {
[10:19:56.137]                     {
[10:19:56.137]                       {
[10:19:56.137]                         base::local({
[10:19:56.137]                           has_future <- base::requireNamespace("future", 
[10:19:56.137]                             quietly = TRUE)
[10:19:56.137]                           if (has_future) {
[10:19:56.137]                             ns <- base::getNamespace("future")
[10:19:56.137]                             version <- ns[[".package"]][["version"]]
[10:19:56.137]                             if (is.null(version)) 
[10:19:56.137]                               version <- utils::packageVersion("future")
[10:19:56.137]                           }
[10:19:56.137]                           else {
[10:19:56.137]                             version <- NULL
[10:19:56.137]                           }
[10:19:56.137]                           if (!has_future || version < "1.8.0") {
[10:19:56.137]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:56.137]                               "", base::R.version$version.string), 
[10:19:56.137]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:56.137]                                 base::R.version$platform, 8 * 
[10:19:56.137]                                   base::.Machine$sizeof.pointer), 
[10:19:56.137]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:56.137]                                 "release", "version")], collapse = " "), 
[10:19:56.137]                               hostname = base::Sys.info()[["nodename"]])
[10:19:56.137]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:56.137]                               info)
[10:19:56.137]                             info <- base::paste(info, collapse = "; ")
[10:19:56.137]                             if (!has_future) {
[10:19:56.137]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:56.137]                                 info)
[10:19:56.137]                             }
[10:19:56.137]                             else {
[10:19:56.137]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:56.137]                                 info, version)
[10:19:56.137]                             }
[10:19:56.137]                             base::stop(msg)
[10:19:56.137]                           }
[10:19:56.137]                         })
[10:19:56.137]                       }
[10:19:56.137]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:56.137]                       base::options(mc.cores = 1L)
[10:19:56.137]                     }
[10:19:56.137]                     base::local({
[10:19:56.137]                       for (pkg in "future.apply") {
[10:19:56.137]                         base::loadNamespace(pkg)
[10:19:56.137]                         base::library(pkg, character.only = TRUE)
[10:19:56.137]                       }
[10:19:56.137]                     })
[10:19:56.137]                   }
[10:19:56.137]                   ...future.strategy.old <- future::plan("list")
[10:19:56.137]                   options(future.plan = NULL)
[10:19:56.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:56.137]                 }
[10:19:56.137]                 ...future.workdir <- getwd()
[10:19:56.137]             }
[10:19:56.137]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:56.137]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:56.137]         }
[10:19:56.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:56.137]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:56.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:56.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:56.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:56.137]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:56.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:56.137]             base::names(...future.oldOptions))
[10:19:56.137]     }
[10:19:56.137]     if (FALSE) {
[10:19:56.137]     }
[10:19:56.137]     else {
[10:19:56.137]         if (TRUE) {
[10:19:56.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:56.137]                 open = "w")
[10:19:56.137]         }
[10:19:56.137]         else {
[10:19:56.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:56.137]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:56.137]         }
[10:19:56.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:56.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:56.137]             base::sink(type = "output", split = FALSE)
[10:19:56.137]             base::close(...future.stdout)
[10:19:56.137]         }, add = TRUE)
[10:19:56.137]     }
[10:19:56.137]     ...future.frame <- base::sys.nframe()
[10:19:56.137]     ...future.conditions <- base::list()
[10:19:56.137]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:56.137]     if (FALSE) {
[10:19:56.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:56.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:56.137]     }
[10:19:56.137]     ...future.result <- base::tryCatch({
[10:19:56.137]         base::withCallingHandlers({
[10:19:56.137]             ...future.value <- base::withVisible(base::local({
[10:19:56.137]                 ...future.makeSendCondition <- base::local({
[10:19:56.137]                   sendCondition <- NULL
[10:19:56.137]                   function(frame = 1L) {
[10:19:56.137]                     if (is.function(sendCondition)) 
[10:19:56.137]                       return(sendCondition)
[10:19:56.137]                     ns <- getNamespace("parallel")
[10:19:56.137]                     if (exists("sendData", mode = "function", 
[10:19:56.137]                       envir = ns)) {
[10:19:56.137]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:56.137]                         envir = ns)
[10:19:56.137]                       envir <- sys.frame(frame)
[10:19:56.137]                       master <- NULL
[10:19:56.137]                       while (!identical(envir, .GlobalEnv) && 
[10:19:56.137]                         !identical(envir, emptyenv())) {
[10:19:56.137]                         if (exists("master", mode = "list", envir = envir, 
[10:19:56.137]                           inherits = FALSE)) {
[10:19:56.137]                           master <- get("master", mode = "list", 
[10:19:56.137]                             envir = envir, inherits = FALSE)
[10:19:56.137]                           if (inherits(master, c("SOCKnode", 
[10:19:56.137]                             "SOCK0node"))) {
[10:19:56.137]                             sendCondition <<- function(cond) {
[10:19:56.137]                               data <- list(type = "VALUE", value = cond, 
[10:19:56.137]                                 success = TRUE)
[10:19:56.137]                               parallel_sendData(master, data)
[10:19:56.137]                             }
[10:19:56.137]                             return(sendCondition)
[10:19:56.137]                           }
[10:19:56.137]                         }
[10:19:56.137]                         frame <- frame + 1L
[10:19:56.137]                         envir <- sys.frame(frame)
[10:19:56.137]                       }
[10:19:56.137]                     }
[10:19:56.137]                     sendCondition <<- function(cond) NULL
[10:19:56.137]                   }
[10:19:56.137]                 })
[10:19:56.137]                 withCallingHandlers({
[10:19:56.137]                   {
[10:19:56.137]                     do.call(function(...) {
[10:19:56.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.137]                       if (!identical(...future.globals.maxSize.org, 
[10:19:56.137]                         ...future.globals.maxSize)) {
[10:19:56.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.137]                         on.exit(options(oopts), add = TRUE)
[10:19:56.137]                       }
[10:19:56.137]                       {
[10:19:56.137]                         lapply(seq_along(...future.elements_ii), 
[10:19:56.137]                           FUN = function(jj) {
[10:19:56.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.137]                             ...future.FUN(...future.X_jj, ...)
[10:19:56.137]                           })
[10:19:56.137]                       }
[10:19:56.137]                     }, args = future.call.arguments)
[10:19:56.137]                   }
[10:19:56.137]                 }, immediateCondition = function(cond) {
[10:19:56.137]                   sendCondition <- ...future.makeSendCondition()
[10:19:56.137]                   sendCondition(cond)
[10:19:56.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.137]                   {
[10:19:56.137]                     inherits <- base::inherits
[10:19:56.137]                     invokeRestart <- base::invokeRestart
[10:19:56.137]                     is.null <- base::is.null
[10:19:56.137]                     muffled <- FALSE
[10:19:56.137]                     if (inherits(cond, "message")) {
[10:19:56.137]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:56.137]                       if (muffled) 
[10:19:56.137]                         invokeRestart("muffleMessage")
[10:19:56.137]                     }
[10:19:56.137]                     else if (inherits(cond, "warning")) {
[10:19:56.137]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:56.137]                       if (muffled) 
[10:19:56.137]                         invokeRestart("muffleWarning")
[10:19:56.137]                     }
[10:19:56.137]                     else if (inherits(cond, "condition")) {
[10:19:56.137]                       if (!is.null(pattern)) {
[10:19:56.137]                         computeRestarts <- base::computeRestarts
[10:19:56.137]                         grepl <- base::grepl
[10:19:56.137]                         restarts <- computeRestarts(cond)
[10:19:56.137]                         for (restart in restarts) {
[10:19:56.137]                           name <- restart$name
[10:19:56.137]                           if (is.null(name)) 
[10:19:56.137]                             next
[10:19:56.137]                           if (!grepl(pattern, name)) 
[10:19:56.137]                             next
[10:19:56.137]                           invokeRestart(restart)
[10:19:56.137]                           muffled <- TRUE
[10:19:56.137]                           break
[10:19:56.137]                         }
[10:19:56.137]                       }
[10:19:56.137]                     }
[10:19:56.137]                     invisible(muffled)
[10:19:56.137]                   }
[10:19:56.137]                   muffleCondition(cond)
[10:19:56.137]                 })
[10:19:56.137]             }))
[10:19:56.137]             future::FutureResult(value = ...future.value$value, 
[10:19:56.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.137]                   ...future.rng), globalenv = if (FALSE) 
[10:19:56.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:56.137]                     ...future.globalenv.names))
[10:19:56.137]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:56.137]         }, condition = base::local({
[10:19:56.137]             c <- base::c
[10:19:56.137]             inherits <- base::inherits
[10:19:56.137]             invokeRestart <- base::invokeRestart
[10:19:56.137]             length <- base::length
[10:19:56.137]             list <- base::list
[10:19:56.137]             seq.int <- base::seq.int
[10:19:56.137]             signalCondition <- base::signalCondition
[10:19:56.137]             sys.calls <- base::sys.calls
[10:19:56.137]             `[[` <- base::`[[`
[10:19:56.137]             `+` <- base::`+`
[10:19:56.137]             `<<-` <- base::`<<-`
[10:19:56.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:56.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:56.137]                   3L)]
[10:19:56.137]             }
[10:19:56.137]             function(cond) {
[10:19:56.137]                 is_error <- inherits(cond, "error")
[10:19:56.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:56.137]                   NULL)
[10:19:56.137]                 if (is_error) {
[10:19:56.137]                   sessionInformation <- function() {
[10:19:56.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:56.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:56.137]                       search = base::search(), system = base::Sys.info())
[10:19:56.137]                   }
[10:19:56.137]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:56.137]                     cond$call), session = sessionInformation(), 
[10:19:56.137]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:56.137]                   signalCondition(cond)
[10:19:56.137]                 }
[10:19:56.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:56.137]                 "immediateCondition"))) {
[10:19:56.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:56.137]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:56.137]                   if (TRUE && !signal) {
[10:19:56.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.137]                     {
[10:19:56.137]                       inherits <- base::inherits
[10:19:56.137]                       invokeRestart <- base::invokeRestart
[10:19:56.137]                       is.null <- base::is.null
[10:19:56.137]                       muffled <- FALSE
[10:19:56.137]                       if (inherits(cond, "message")) {
[10:19:56.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.137]                         if (muffled) 
[10:19:56.137]                           invokeRestart("muffleMessage")
[10:19:56.137]                       }
[10:19:56.137]                       else if (inherits(cond, "warning")) {
[10:19:56.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.137]                         if (muffled) 
[10:19:56.137]                           invokeRestart("muffleWarning")
[10:19:56.137]                       }
[10:19:56.137]                       else if (inherits(cond, "condition")) {
[10:19:56.137]                         if (!is.null(pattern)) {
[10:19:56.137]                           computeRestarts <- base::computeRestarts
[10:19:56.137]                           grepl <- base::grepl
[10:19:56.137]                           restarts <- computeRestarts(cond)
[10:19:56.137]                           for (restart in restarts) {
[10:19:56.137]                             name <- restart$name
[10:19:56.137]                             if (is.null(name)) 
[10:19:56.137]                               next
[10:19:56.137]                             if (!grepl(pattern, name)) 
[10:19:56.137]                               next
[10:19:56.137]                             invokeRestart(restart)
[10:19:56.137]                             muffled <- TRUE
[10:19:56.137]                             break
[10:19:56.137]                           }
[10:19:56.137]                         }
[10:19:56.137]                       }
[10:19:56.137]                       invisible(muffled)
[10:19:56.137]                     }
[10:19:56.137]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.137]                   }
[10:19:56.137]                 }
[10:19:56.137]                 else {
[10:19:56.137]                   if (TRUE) {
[10:19:56.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.137]                     {
[10:19:56.137]                       inherits <- base::inherits
[10:19:56.137]                       invokeRestart <- base::invokeRestart
[10:19:56.137]                       is.null <- base::is.null
[10:19:56.137]                       muffled <- FALSE
[10:19:56.137]                       if (inherits(cond, "message")) {
[10:19:56.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.137]                         if (muffled) 
[10:19:56.137]                           invokeRestart("muffleMessage")
[10:19:56.137]                       }
[10:19:56.137]                       else if (inherits(cond, "warning")) {
[10:19:56.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.137]                         if (muffled) 
[10:19:56.137]                           invokeRestart("muffleWarning")
[10:19:56.137]                       }
[10:19:56.137]                       else if (inherits(cond, "condition")) {
[10:19:56.137]                         if (!is.null(pattern)) {
[10:19:56.137]                           computeRestarts <- base::computeRestarts
[10:19:56.137]                           grepl <- base::grepl
[10:19:56.137]                           restarts <- computeRestarts(cond)
[10:19:56.137]                           for (restart in restarts) {
[10:19:56.137]                             name <- restart$name
[10:19:56.137]                             if (is.null(name)) 
[10:19:56.137]                               next
[10:19:56.137]                             if (!grepl(pattern, name)) 
[10:19:56.137]                               next
[10:19:56.137]                             invokeRestart(restart)
[10:19:56.137]                             muffled <- TRUE
[10:19:56.137]                             break
[10:19:56.137]                           }
[10:19:56.137]                         }
[10:19:56.137]                       }
[10:19:56.137]                       invisible(muffled)
[10:19:56.137]                     }
[10:19:56.137]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.137]                   }
[10:19:56.137]                 }
[10:19:56.137]             }
[10:19:56.137]         }))
[10:19:56.137]     }, error = function(ex) {
[10:19:56.137]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:56.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.137]                 ...future.rng), started = ...future.startTime, 
[10:19:56.137]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:56.137]             version = "1.8"), class = "FutureResult")
[10:19:56.137]     }, finally = {
[10:19:56.137]         if (!identical(...future.workdir, getwd())) 
[10:19:56.137]             setwd(...future.workdir)
[10:19:56.137]         {
[10:19:56.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:56.137]                 ...future.oldOptions$nwarnings <- NULL
[10:19:56.137]             }
[10:19:56.137]             base::options(...future.oldOptions)
[10:19:56.137]             if (.Platform$OS.type == "windows") {
[10:19:56.137]                 old_names <- names(...future.oldEnvVars)
[10:19:56.137]                 envs <- base::Sys.getenv()
[10:19:56.137]                 names <- names(envs)
[10:19:56.137]                 common <- intersect(names, old_names)
[10:19:56.137]                 added <- setdiff(names, old_names)
[10:19:56.137]                 removed <- setdiff(old_names, names)
[10:19:56.137]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:56.137]                   envs[common]]
[10:19:56.137]                 NAMES <- toupper(changed)
[10:19:56.137]                 args <- list()
[10:19:56.137]                 for (kk in seq_along(NAMES)) {
[10:19:56.137]                   name <- changed[[kk]]
[10:19:56.137]                   NAME <- NAMES[[kk]]
[10:19:56.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.137]                     next
[10:19:56.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.137]                 }
[10:19:56.137]                 NAMES <- toupper(added)
[10:19:56.137]                 for (kk in seq_along(NAMES)) {
[10:19:56.137]                   name <- added[[kk]]
[10:19:56.137]                   NAME <- NAMES[[kk]]
[10:19:56.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.137]                     next
[10:19:56.137]                   args[[name]] <- ""
[10:19:56.137]                 }
[10:19:56.137]                 NAMES <- toupper(removed)
[10:19:56.137]                 for (kk in seq_along(NAMES)) {
[10:19:56.137]                   name <- removed[[kk]]
[10:19:56.137]                   NAME <- NAMES[[kk]]
[10:19:56.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.137]                     next
[10:19:56.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.137]                 }
[10:19:56.137]                 if (length(args) > 0) 
[10:19:56.137]                   base::do.call(base::Sys.setenv, args = args)
[10:19:56.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:56.137]             }
[10:19:56.137]             else {
[10:19:56.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:56.137]             }
[10:19:56.137]             {
[10:19:56.137]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:56.137]                   0L) {
[10:19:56.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:56.137]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:56.137]                   base::options(opts)
[10:19:56.137]                 }
[10:19:56.137]                 {
[10:19:56.137]                   {
[10:19:56.137]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:56.137]                     NULL
[10:19:56.137]                   }
[10:19:56.137]                   options(future.plan = NULL)
[10:19:56.137]                   if (is.na(NA_character_)) 
[10:19:56.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:56.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:56.137]                     .init = FALSE)
[10:19:56.137]                 }
[10:19:56.137]             }
[10:19:56.137]         }
[10:19:56.137]     })
[10:19:56.137]     if (TRUE) {
[10:19:56.137]         base::sink(type = "output", split = FALSE)
[10:19:56.137]         if (TRUE) {
[10:19:56.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:56.137]         }
[10:19:56.137]         else {
[10:19:56.137]             ...future.result["stdout"] <- base::list(NULL)
[10:19:56.137]         }
[10:19:56.137]         base::close(...future.stdout)
[10:19:56.137]         ...future.stdout <- NULL
[10:19:56.137]     }
[10:19:56.137]     ...future.result$conditions <- ...future.conditions
[10:19:56.137]     ...future.result$finished <- base::Sys.time()
[10:19:56.137]     ...future.result
[10:19:56.137] }
[10:19:56.140] Exporting 11 global objects (13.78 KiB) to cluster node #1 ...
[10:19:56.140] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #1 ...
[10:19:56.180] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #1 ... DONE
[10:19:56.181] Exporting ‘x_FUN’ (483 bytes) to cluster node #1 ...
[10:19:56.181] Exporting ‘x_FUN’ (483 bytes) to cluster node #1 ... DONE
[10:19:56.181] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:56.181] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:56.182] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:56.222] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:56.223] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:56.263] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:56.264] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:56.264] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:56.264] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:56.265] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:56.265] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:56.265] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:56.265] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[10:19:56.266] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[10:19:56.266] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:56.266] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:56.266] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:56.266] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:56.267] Exporting 11 global objects (13.78 KiB) to cluster node #1 ... DONE
[10:19:56.267] MultisessionFuture started
[10:19:56.267] - Launch lazy future ... done
[10:19:56.267] run() for ‘MultisessionFuture’ ... done
[10:19:56.267] Created future:
[10:19:56.267] MultisessionFuture:
[10:19:56.267] Label: ‘future_vapply-1’
[10:19:56.267] Expression:
[10:19:56.267] {
[10:19:56.267]     do.call(function(...) {
[10:19:56.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.267]             on.exit(options(oopts), add = TRUE)
[10:19:56.267]         }
[10:19:56.267]         {
[10:19:56.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.267]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.267]             })
[10:19:56.267]         }
[10:19:56.267]     }, args = future.call.arguments)
[10:19:56.267] }
[10:19:56.267] Lazy evaluation: FALSE
[10:19:56.267] Asynchronous evaluation: TRUE
[10:19:56.267] Local evaluation: TRUE
[10:19:56.267] Environment: R_GlobalEnv
[10:19:56.267] Capture standard output: TRUE
[10:19:56.267] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:56.267] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:56.267] Packages: 1 packages (‘future.apply’)
[10:19:56.267] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:56.267] Resolved: FALSE
[10:19:56.267] Value: <not collected>
[10:19:56.267] Conditions captured: <none>
[10:19:56.267] Early signaling: FALSE
[10:19:56.267] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:56.267] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.279] Chunk #1 of 2 ... DONE
[10:19:56.279] Chunk #2 of 2 ...
[10:19:56.279]  - Finding globals in 'X' for chunk #2 ...
[10:19:56.279] getGlobalsAndPackages() ...
[10:19:56.279] Searching for globals...
[10:19:56.280] 
[10:19:56.280] Searching for globals ... DONE
[10:19:56.280] - globals: [0] <none>
[10:19:56.280] getGlobalsAndPackages() ... DONE
[10:19:56.280]    + additional globals found: [n=0] 
[10:19:56.280]    + additional namespaces needed: [n=0] 
[10:19:56.280]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:56.280]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:56.280]  - seeds: <none>
[10:19:56.280]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.281] getGlobalsAndPackages() ...
[10:19:56.281] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.281] Resolving globals: FALSE
[10:19:56.281] Tweak future expression to call with '...' arguments ...
[10:19:56.281] {
[10:19:56.281]     do.call(function(...) {
[10:19:56.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.281]             on.exit(options(oopts), add = TRUE)
[10:19:56.281]         }
[10:19:56.281]         {
[10:19:56.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.281]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.281]             })
[10:19:56.281]         }
[10:19:56.281]     }, args = future.call.arguments)
[10:19:56.281] }
[10:19:56.281] Tweak future expression to call with '...' arguments ... DONE
[10:19:56.282] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.282] - packages: [1] ‘future.apply’
[10:19:56.282] getGlobalsAndPackages() ... DONE
[10:19:56.282] run() for ‘Future’ ...
[10:19:56.282] - state: ‘created’
[10:19:56.282] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:56.296] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.296] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:56.296]   - Field: ‘node’
[10:19:56.296]   - Field: ‘label’
[10:19:56.297]   - Field: ‘local’
[10:19:56.297]   - Field: ‘owner’
[10:19:56.297]   - Field: ‘envir’
[10:19:56.297]   - Field: ‘workers’
[10:19:56.297]   - Field: ‘packages’
[10:19:56.297]   - Field: ‘gc’
[10:19:56.297]   - Field: ‘conditions’
[10:19:56.297]   - Field: ‘persistent’
[10:19:56.297]   - Field: ‘expr’
[10:19:56.297]   - Field: ‘uuid’
[10:19:56.297]   - Field: ‘seed’
[10:19:56.297]   - Field: ‘version’
[10:19:56.298]   - Field: ‘result’
[10:19:56.298]   - Field: ‘asynchronous’
[10:19:56.298]   - Field: ‘calls’
[10:19:56.298]   - Field: ‘globals’
[10:19:56.298]   - Field: ‘stdout’
[10:19:56.298]   - Field: ‘earlySignal’
[10:19:56.298]   - Field: ‘lazy’
[10:19:56.298]   - Field: ‘state’
[10:19:56.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:56.298] - Launch lazy future ...
[10:19:56.299] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:56.299] Packages needed by future strategies (n = 0): <none>
[10:19:56.299] {
[10:19:56.299]     {
[10:19:56.299]         {
[10:19:56.299]             ...future.startTime <- base::Sys.time()
[10:19:56.299]             {
[10:19:56.299]                 {
[10:19:56.299]                   {
[10:19:56.299]                     {
[10:19:56.299]                       {
[10:19:56.299]                         base::local({
[10:19:56.299]                           has_future <- base::requireNamespace("future", 
[10:19:56.299]                             quietly = TRUE)
[10:19:56.299]                           if (has_future) {
[10:19:56.299]                             ns <- base::getNamespace("future")
[10:19:56.299]                             version <- ns[[".package"]][["version"]]
[10:19:56.299]                             if (is.null(version)) 
[10:19:56.299]                               version <- utils::packageVersion("future")
[10:19:56.299]                           }
[10:19:56.299]                           else {
[10:19:56.299]                             version <- NULL
[10:19:56.299]                           }
[10:19:56.299]                           if (!has_future || version < "1.8.0") {
[10:19:56.299]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:56.299]                               "", base::R.version$version.string), 
[10:19:56.299]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:56.299]                                 base::R.version$platform, 8 * 
[10:19:56.299]                                   base::.Machine$sizeof.pointer), 
[10:19:56.299]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:56.299]                                 "release", "version")], collapse = " "), 
[10:19:56.299]                               hostname = base::Sys.info()[["nodename"]])
[10:19:56.299]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:56.299]                               info)
[10:19:56.299]                             info <- base::paste(info, collapse = "; ")
[10:19:56.299]                             if (!has_future) {
[10:19:56.299]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:56.299]                                 info)
[10:19:56.299]                             }
[10:19:56.299]                             else {
[10:19:56.299]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:56.299]                                 info, version)
[10:19:56.299]                             }
[10:19:56.299]                             base::stop(msg)
[10:19:56.299]                           }
[10:19:56.299]                         })
[10:19:56.299]                       }
[10:19:56.299]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:56.299]                       base::options(mc.cores = 1L)
[10:19:56.299]                     }
[10:19:56.299]                     base::local({
[10:19:56.299]                       for (pkg in "future.apply") {
[10:19:56.299]                         base::loadNamespace(pkg)
[10:19:56.299]                         base::library(pkg, character.only = TRUE)
[10:19:56.299]                       }
[10:19:56.299]                     })
[10:19:56.299]                   }
[10:19:56.299]                   ...future.strategy.old <- future::plan("list")
[10:19:56.299]                   options(future.plan = NULL)
[10:19:56.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:56.299]                 }
[10:19:56.299]                 ...future.workdir <- getwd()
[10:19:56.299]             }
[10:19:56.299]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:56.299]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:56.299]         }
[10:19:56.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:56.299]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:56.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:56.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:56.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:56.299]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:56.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:56.299]             base::names(...future.oldOptions))
[10:19:56.299]     }
[10:19:56.299]     if (FALSE) {
[10:19:56.299]     }
[10:19:56.299]     else {
[10:19:56.299]         if (TRUE) {
[10:19:56.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:56.299]                 open = "w")
[10:19:56.299]         }
[10:19:56.299]         else {
[10:19:56.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:56.299]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:56.299]         }
[10:19:56.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:56.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:56.299]             base::sink(type = "output", split = FALSE)
[10:19:56.299]             base::close(...future.stdout)
[10:19:56.299]         }, add = TRUE)
[10:19:56.299]     }
[10:19:56.299]     ...future.frame <- base::sys.nframe()
[10:19:56.299]     ...future.conditions <- base::list()
[10:19:56.299]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:56.299]     if (FALSE) {
[10:19:56.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:56.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:56.299]     }
[10:19:56.299]     ...future.result <- base::tryCatch({
[10:19:56.299]         base::withCallingHandlers({
[10:19:56.299]             ...future.value <- base::withVisible(base::local({
[10:19:56.299]                 ...future.makeSendCondition <- base::local({
[10:19:56.299]                   sendCondition <- NULL
[10:19:56.299]                   function(frame = 1L) {
[10:19:56.299]                     if (is.function(sendCondition)) 
[10:19:56.299]                       return(sendCondition)
[10:19:56.299]                     ns <- getNamespace("parallel")
[10:19:56.299]                     if (exists("sendData", mode = "function", 
[10:19:56.299]                       envir = ns)) {
[10:19:56.299]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:56.299]                         envir = ns)
[10:19:56.299]                       envir <- sys.frame(frame)
[10:19:56.299]                       master <- NULL
[10:19:56.299]                       while (!identical(envir, .GlobalEnv) && 
[10:19:56.299]                         !identical(envir, emptyenv())) {
[10:19:56.299]                         if (exists("master", mode = "list", envir = envir, 
[10:19:56.299]                           inherits = FALSE)) {
[10:19:56.299]                           master <- get("master", mode = "list", 
[10:19:56.299]                             envir = envir, inherits = FALSE)
[10:19:56.299]                           if (inherits(master, c("SOCKnode", 
[10:19:56.299]                             "SOCK0node"))) {
[10:19:56.299]                             sendCondition <<- function(cond) {
[10:19:56.299]                               data <- list(type = "VALUE", value = cond, 
[10:19:56.299]                                 success = TRUE)
[10:19:56.299]                               parallel_sendData(master, data)
[10:19:56.299]                             }
[10:19:56.299]                             return(sendCondition)
[10:19:56.299]                           }
[10:19:56.299]                         }
[10:19:56.299]                         frame <- frame + 1L
[10:19:56.299]                         envir <- sys.frame(frame)
[10:19:56.299]                       }
[10:19:56.299]                     }
[10:19:56.299]                     sendCondition <<- function(cond) NULL
[10:19:56.299]                   }
[10:19:56.299]                 })
[10:19:56.299]                 withCallingHandlers({
[10:19:56.299]                   {
[10:19:56.299]                     do.call(function(...) {
[10:19:56.299]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.299]                       if (!identical(...future.globals.maxSize.org, 
[10:19:56.299]                         ...future.globals.maxSize)) {
[10:19:56.299]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.299]                         on.exit(options(oopts), add = TRUE)
[10:19:56.299]                       }
[10:19:56.299]                       {
[10:19:56.299]                         lapply(seq_along(...future.elements_ii), 
[10:19:56.299]                           FUN = function(jj) {
[10:19:56.299]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.299]                             ...future.FUN(...future.X_jj, ...)
[10:19:56.299]                           })
[10:19:56.299]                       }
[10:19:56.299]                     }, args = future.call.arguments)
[10:19:56.299]                   }
[10:19:56.299]                 }, immediateCondition = function(cond) {
[10:19:56.299]                   sendCondition <- ...future.makeSendCondition()
[10:19:56.299]                   sendCondition(cond)
[10:19:56.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.299]                   {
[10:19:56.299]                     inherits <- base::inherits
[10:19:56.299]                     invokeRestart <- base::invokeRestart
[10:19:56.299]                     is.null <- base::is.null
[10:19:56.299]                     muffled <- FALSE
[10:19:56.299]                     if (inherits(cond, "message")) {
[10:19:56.299]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:56.299]                       if (muffled) 
[10:19:56.299]                         invokeRestart("muffleMessage")
[10:19:56.299]                     }
[10:19:56.299]                     else if (inherits(cond, "warning")) {
[10:19:56.299]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:56.299]                       if (muffled) 
[10:19:56.299]                         invokeRestart("muffleWarning")
[10:19:56.299]                     }
[10:19:56.299]                     else if (inherits(cond, "condition")) {
[10:19:56.299]                       if (!is.null(pattern)) {
[10:19:56.299]                         computeRestarts <- base::computeRestarts
[10:19:56.299]                         grepl <- base::grepl
[10:19:56.299]                         restarts <- computeRestarts(cond)
[10:19:56.299]                         for (restart in restarts) {
[10:19:56.299]                           name <- restart$name
[10:19:56.299]                           if (is.null(name)) 
[10:19:56.299]                             next
[10:19:56.299]                           if (!grepl(pattern, name)) 
[10:19:56.299]                             next
[10:19:56.299]                           invokeRestart(restart)
[10:19:56.299]                           muffled <- TRUE
[10:19:56.299]                           break
[10:19:56.299]                         }
[10:19:56.299]                       }
[10:19:56.299]                     }
[10:19:56.299]                     invisible(muffled)
[10:19:56.299]                   }
[10:19:56.299]                   muffleCondition(cond)
[10:19:56.299]                 })
[10:19:56.299]             }))
[10:19:56.299]             future::FutureResult(value = ...future.value$value, 
[10:19:56.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.299]                   ...future.rng), globalenv = if (FALSE) 
[10:19:56.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:56.299]                     ...future.globalenv.names))
[10:19:56.299]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:56.299]         }, condition = base::local({
[10:19:56.299]             c <- base::c
[10:19:56.299]             inherits <- base::inherits
[10:19:56.299]             invokeRestart <- base::invokeRestart
[10:19:56.299]             length <- base::length
[10:19:56.299]             list <- base::list
[10:19:56.299]             seq.int <- base::seq.int
[10:19:56.299]             signalCondition <- base::signalCondition
[10:19:56.299]             sys.calls <- base::sys.calls
[10:19:56.299]             `[[` <- base::`[[`
[10:19:56.299]             `+` <- base::`+`
[10:19:56.299]             `<<-` <- base::`<<-`
[10:19:56.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:56.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:56.299]                   3L)]
[10:19:56.299]             }
[10:19:56.299]             function(cond) {
[10:19:56.299]                 is_error <- inherits(cond, "error")
[10:19:56.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:56.299]                   NULL)
[10:19:56.299]                 if (is_error) {
[10:19:56.299]                   sessionInformation <- function() {
[10:19:56.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:56.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:56.299]                       search = base::search(), system = base::Sys.info())
[10:19:56.299]                   }
[10:19:56.299]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:56.299]                     cond$call), session = sessionInformation(), 
[10:19:56.299]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:56.299]                   signalCondition(cond)
[10:19:56.299]                 }
[10:19:56.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:56.299]                 "immediateCondition"))) {
[10:19:56.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:56.299]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:56.299]                   if (TRUE && !signal) {
[10:19:56.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.299]                     {
[10:19:56.299]                       inherits <- base::inherits
[10:19:56.299]                       invokeRestart <- base::invokeRestart
[10:19:56.299]                       is.null <- base::is.null
[10:19:56.299]                       muffled <- FALSE
[10:19:56.299]                       if (inherits(cond, "message")) {
[10:19:56.299]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.299]                         if (muffled) 
[10:19:56.299]                           invokeRestart("muffleMessage")
[10:19:56.299]                       }
[10:19:56.299]                       else if (inherits(cond, "warning")) {
[10:19:56.299]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.299]                         if (muffled) 
[10:19:56.299]                           invokeRestart("muffleWarning")
[10:19:56.299]                       }
[10:19:56.299]                       else if (inherits(cond, "condition")) {
[10:19:56.299]                         if (!is.null(pattern)) {
[10:19:56.299]                           computeRestarts <- base::computeRestarts
[10:19:56.299]                           grepl <- base::grepl
[10:19:56.299]                           restarts <- computeRestarts(cond)
[10:19:56.299]                           for (restart in restarts) {
[10:19:56.299]                             name <- restart$name
[10:19:56.299]                             if (is.null(name)) 
[10:19:56.299]                               next
[10:19:56.299]                             if (!grepl(pattern, name)) 
[10:19:56.299]                               next
[10:19:56.299]                             invokeRestart(restart)
[10:19:56.299]                             muffled <- TRUE
[10:19:56.299]                             break
[10:19:56.299]                           }
[10:19:56.299]                         }
[10:19:56.299]                       }
[10:19:56.299]                       invisible(muffled)
[10:19:56.299]                     }
[10:19:56.299]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.299]                   }
[10:19:56.299]                 }
[10:19:56.299]                 else {
[10:19:56.299]                   if (TRUE) {
[10:19:56.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.299]                     {
[10:19:56.299]                       inherits <- base::inherits
[10:19:56.299]                       invokeRestart <- base::invokeRestart
[10:19:56.299]                       is.null <- base::is.null
[10:19:56.299]                       muffled <- FALSE
[10:19:56.299]                       if (inherits(cond, "message")) {
[10:19:56.299]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.299]                         if (muffled) 
[10:19:56.299]                           invokeRestart("muffleMessage")
[10:19:56.299]                       }
[10:19:56.299]                       else if (inherits(cond, "warning")) {
[10:19:56.299]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.299]                         if (muffled) 
[10:19:56.299]                           invokeRestart("muffleWarning")
[10:19:56.299]                       }
[10:19:56.299]                       else if (inherits(cond, "condition")) {
[10:19:56.299]                         if (!is.null(pattern)) {
[10:19:56.299]                           computeRestarts <- base::computeRestarts
[10:19:56.299]                           grepl <- base::grepl
[10:19:56.299]                           restarts <- computeRestarts(cond)
[10:19:56.299]                           for (restart in restarts) {
[10:19:56.299]                             name <- restart$name
[10:19:56.299]                             if (is.null(name)) 
[10:19:56.299]                               next
[10:19:56.299]                             if (!grepl(pattern, name)) 
[10:19:56.299]                               next
[10:19:56.299]                             invokeRestart(restart)
[10:19:56.299]                             muffled <- TRUE
[10:19:56.299]                             break
[10:19:56.299]                           }
[10:19:56.299]                         }
[10:19:56.299]                       }
[10:19:56.299]                       invisible(muffled)
[10:19:56.299]                     }
[10:19:56.299]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.299]                   }
[10:19:56.299]                 }
[10:19:56.299]             }
[10:19:56.299]         }))
[10:19:56.299]     }, error = function(ex) {
[10:19:56.299]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:56.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.299]                 ...future.rng), started = ...future.startTime, 
[10:19:56.299]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:56.299]             version = "1.8"), class = "FutureResult")
[10:19:56.299]     }, finally = {
[10:19:56.299]         if (!identical(...future.workdir, getwd())) 
[10:19:56.299]             setwd(...future.workdir)
[10:19:56.299]         {
[10:19:56.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:56.299]                 ...future.oldOptions$nwarnings <- NULL
[10:19:56.299]             }
[10:19:56.299]             base::options(...future.oldOptions)
[10:19:56.299]             if (.Platform$OS.type == "windows") {
[10:19:56.299]                 old_names <- names(...future.oldEnvVars)
[10:19:56.299]                 envs <- base::Sys.getenv()
[10:19:56.299]                 names <- names(envs)
[10:19:56.299]                 common <- intersect(names, old_names)
[10:19:56.299]                 added <- setdiff(names, old_names)
[10:19:56.299]                 removed <- setdiff(old_names, names)
[10:19:56.299]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:56.299]                   envs[common]]
[10:19:56.299]                 NAMES <- toupper(changed)
[10:19:56.299]                 args <- list()
[10:19:56.299]                 for (kk in seq_along(NAMES)) {
[10:19:56.299]                   name <- changed[[kk]]
[10:19:56.299]                   NAME <- NAMES[[kk]]
[10:19:56.299]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.299]                     next
[10:19:56.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.299]                 }
[10:19:56.299]                 NAMES <- toupper(added)
[10:19:56.299]                 for (kk in seq_along(NAMES)) {
[10:19:56.299]                   name <- added[[kk]]
[10:19:56.299]                   NAME <- NAMES[[kk]]
[10:19:56.299]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.299]                     next
[10:19:56.299]                   args[[name]] <- ""
[10:19:56.299]                 }
[10:19:56.299]                 NAMES <- toupper(removed)
[10:19:56.299]                 for (kk in seq_along(NAMES)) {
[10:19:56.299]                   name <- removed[[kk]]
[10:19:56.299]                   NAME <- NAMES[[kk]]
[10:19:56.299]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.299]                     next
[10:19:56.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.299]                 }
[10:19:56.299]                 if (length(args) > 0) 
[10:19:56.299]                   base::do.call(base::Sys.setenv, args = args)
[10:19:56.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:56.299]             }
[10:19:56.299]             else {
[10:19:56.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:56.299]             }
[10:19:56.299]             {
[10:19:56.299]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:56.299]                   0L) {
[10:19:56.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:56.299]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:56.299]                   base::options(opts)
[10:19:56.299]                 }
[10:19:56.299]                 {
[10:19:56.299]                   {
[10:19:56.299]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:56.299]                     NULL
[10:19:56.299]                   }
[10:19:56.299]                   options(future.plan = NULL)
[10:19:56.299]                   if (is.na(NA_character_)) 
[10:19:56.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:56.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:56.299]                     .init = FALSE)
[10:19:56.299]                 }
[10:19:56.299]             }
[10:19:56.299]         }
[10:19:56.299]     })
[10:19:56.299]     if (TRUE) {
[10:19:56.299]         base::sink(type = "output", split = FALSE)
[10:19:56.299]         if (TRUE) {
[10:19:56.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:56.299]         }
[10:19:56.299]         else {
[10:19:56.299]             ...future.result["stdout"] <- base::list(NULL)
[10:19:56.299]         }
[10:19:56.299]         base::close(...future.stdout)
[10:19:56.299]         ...future.stdout <- NULL
[10:19:56.299]     }
[10:19:56.299]     ...future.result$conditions <- ...future.conditions
[10:19:56.299]     ...future.result$finished <- base::Sys.time()
[10:19:56.299]     ...future.result
[10:19:56.299] }
[10:19:56.302] Exporting 11 global objects (13.78 KiB) to cluster node #2 ...
[10:19:56.302] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #2 ...
[10:19:56.343] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #2 ... DONE
[10:19:56.344] Exporting ‘x_FUN’ (483 bytes) to cluster node #2 ...
[10:19:56.344] Exporting ‘x_FUN’ (483 bytes) to cluster node #2 ... DONE
[10:19:56.344] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:56.345] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:56.345] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:56.385] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:56.386] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:56.426] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:56.427] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:56.427] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.427] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:56.428] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:56.428] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:56.428] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:56.428] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[10:19:56.429] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[10:19:56.429] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:56.429] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.429] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:56.430] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.430] Exporting 11 global objects (13.78 KiB) to cluster node #2 ... DONE
[10:19:56.430] MultisessionFuture started
[10:19:56.430] - Launch lazy future ... done
[10:19:56.431] run() for ‘MultisessionFuture’ ... done
[10:19:56.431] Created future:
[10:19:56.431] MultisessionFuture:
[10:19:56.431] Label: ‘future_vapply-2’
[10:19:56.431] Expression:
[10:19:56.431] {
[10:19:56.431]     do.call(function(...) {
[10:19:56.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.431]             on.exit(options(oopts), add = TRUE)
[10:19:56.431]         }
[10:19:56.431]         {
[10:19:56.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.431]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.431]             })
[10:19:56.431]         }
[10:19:56.431]     }, args = future.call.arguments)
[10:19:56.431] }
[10:19:56.431] Lazy evaluation: FALSE
[10:19:56.431] Asynchronous evaluation: TRUE
[10:19:56.431] Local evaluation: TRUE
[10:19:56.431] Environment: R_GlobalEnv
[10:19:56.431] Capture standard output: TRUE
[10:19:56.431] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:56.431] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:56.431] Packages: 1 packages (‘future.apply’)
[10:19:56.431] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:56.431] Resolved: FALSE
[10:19:56.431] Value: <not collected>
[10:19:56.431] Conditions captured: <none>
[10:19:56.431] Early signaling: FALSE
[10:19:56.431] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:56.431] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.442] Chunk #2 of 2 ... DONE
[10:19:56.442] Launching 2 futures (chunks) ... DONE
[10:19:56.443] Resolving 2 futures (chunks) ...
[10:19:56.443] resolve() on list ...
[10:19:56.443]  recursive: 0
[10:19:56.443]  length: 2
[10:19:56.443] 
[10:19:56.444] receiveMessageFromWorker() for ClusterFuture ...
[10:19:56.444] - Validating connection of MultisessionFuture
[10:19:56.444] - received message: FutureResult
[10:19:56.444] - Received FutureResult
[10:19:56.444] - Erased future from FutureRegistry
[10:19:56.444] result() for ClusterFuture ...
[10:19:56.445] - result already collected: FutureResult
[10:19:56.445] result() for ClusterFuture ... done
[10:19:56.445] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:56.445] Future #1
[10:19:56.445] result() for ClusterFuture ...
[10:19:56.445] - result already collected: FutureResult
[10:19:56.445] result() for ClusterFuture ... done
[10:19:56.445] result() for ClusterFuture ...
[10:19:56.445] - result already collected: FutureResult
[10:19:56.446] result() for ClusterFuture ... done
[10:19:56.446] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:56.446] - nx: 2
[10:19:56.446] - relay: TRUE
[10:19:56.446] - stdout: TRUE
[10:19:56.446] - signal: TRUE
[10:19:56.446] - resignal: FALSE
[10:19:56.446] - force: TRUE
[10:19:56.446] - relayed: [n=2] FALSE, FALSE
[10:19:56.447] - queued futures: [n=2] FALSE, FALSE
[10:19:56.447]  - until=1
[10:19:56.447]  - relaying element #1
[10:19:56.447] result() for ClusterFuture ...
[10:19:56.447] - result already collected: FutureResult
[10:19:56.447] result() for ClusterFuture ... done
[10:19:56.447] result() for ClusterFuture ...
[10:19:56.447] - result already collected: FutureResult
[10:19:56.447] result() for ClusterFuture ... done
[10:19:56.448] result() for ClusterFuture ...
[10:19:56.448] - result already collected: FutureResult
[10:19:56.448] result() for ClusterFuture ... done
[10:19:56.448] result() for ClusterFuture ...
[10:19:56.448] - result already collected: FutureResult
[10:19:56.448] result() for ClusterFuture ... done
[10:19:56.448] - relayed: [n=2] TRUE, FALSE
[10:19:56.448] - queued futures: [n=2] TRUE, FALSE
[10:19:56.448] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:56.449]  length: 1 (resolved future 1)
[10:19:56.472] receiveMessageFromWorker() for ClusterFuture ...
[10:19:56.472] - Validating connection of MultisessionFuture
[10:19:56.473] - received message: FutureResult
[10:19:56.473] - Received FutureResult
[10:19:56.473] - Erased future from FutureRegistry
[10:19:56.473] result() for ClusterFuture ...
[10:19:56.473] - result already collected: FutureResult
[10:19:56.473] result() for ClusterFuture ... done
[10:19:56.473] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:56.473] Future #2
[10:19:56.473] result() for ClusterFuture ...
[10:19:56.473] - result already collected: FutureResult
[10:19:56.473] result() for ClusterFuture ... done
[10:19:56.474] result() for ClusterFuture ...
[10:19:56.474] - result already collected: FutureResult
[10:19:56.474] result() for ClusterFuture ... done
[10:19:56.474] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:56.474] - nx: 2
[10:19:56.474] - relay: TRUE
[10:19:56.474] - stdout: TRUE
[10:19:56.474] - signal: TRUE
[10:19:56.474] - resignal: FALSE
[10:19:56.474] - force: TRUE
[10:19:56.474] - relayed: [n=2] TRUE, FALSE
[10:19:56.474] - queued futures: [n=2] TRUE, FALSE
[10:19:56.475]  - until=2
[10:19:56.475]  - relaying element #2
[10:19:56.475] result() for ClusterFuture ...
[10:19:56.475] - result already collected: FutureResult
[10:19:56.475] result() for ClusterFuture ... done
[10:19:56.475] result() for ClusterFuture ...
[10:19:56.475] - result already collected: FutureResult
[10:19:56.475] result() for ClusterFuture ... done
[10:19:56.475] result() for ClusterFuture ...
[10:19:56.475] - result already collected: FutureResult
[10:19:56.475] result() for ClusterFuture ... done
[10:19:56.476] result() for ClusterFuture ...
[10:19:56.476] - result already collected: FutureResult
[10:19:56.476] result() for ClusterFuture ... done
[10:19:56.476] - relayed: [n=2] TRUE, TRUE
[10:19:56.476] - queued futures: [n=2] TRUE, TRUE
[10:19:56.476] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:56.476]  length: 0 (resolved future 2)
[10:19:56.476] Relaying remaining futures
[10:19:56.476] signalConditionsASAP(NULL, pos=0) ...
[10:19:56.476] - nx: 2
[10:19:56.476] - relay: TRUE
[10:19:56.476] - stdout: TRUE
[10:19:56.476] - signal: TRUE
[10:19:56.477] - resignal: FALSE
[10:19:56.477] - force: TRUE
[10:19:56.477] - relayed: [n=2] TRUE, TRUE
[10:19:56.477] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:56.477] - relayed: [n=2] TRUE, TRUE
[10:19:56.477] - queued futures: [n=2] TRUE, TRUE
[10:19:56.477] signalConditionsASAP(NULL, pos=0) ... done
[10:19:56.477] resolve() on list ... DONE
[10:19:56.477] result() for ClusterFuture ...
[10:19:56.477] - result already collected: FutureResult
[10:19:56.477] result() for ClusterFuture ... done
[10:19:56.478] result() for ClusterFuture ...
[10:19:56.478] - result already collected: FutureResult
[10:19:56.478] result() for ClusterFuture ... done
[10:19:56.478] result() for ClusterFuture ...
[10:19:56.478] - result already collected: FutureResult
[10:19:56.478] result() for ClusterFuture ... done
[10:19:56.478] result() for ClusterFuture ...
[10:19:56.478] - result already collected: FutureResult
[10:19:56.478] result() for ClusterFuture ... done
[10:19:56.478]  - Number of value chunks collected: 2
[10:19:56.478] Resolving 2 futures (chunks) ... DONE
[10:19:56.478] Reducing values from 2 chunks ...
[10:19:56.479]  - Number of values collected after concatenation: 10
[10:19:56.479]  - Number of values expected: 10
[10:19:56.479] Reducing values from 2 chunks ... DONE
[10:19:56.479] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:19:56.480] future_lapply() ...
[10:19:56.483] Number of chunks: 2
[10:19:56.483] getGlobalsAndPackagesXApply() ...
[10:19:56.483]  - future.globals: TRUE
[10:19:56.483] getGlobalsAndPackages() ...
[10:19:56.483] Searching for globals...
[10:19:56.487] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:19:56.487] Searching for globals ... DONE
[10:19:56.487] Resolving globals: FALSE
[10:19:56.488] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[10:19:56.488] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:56.489] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:56.489] - packages: [1] ‘future.apply’
[10:19:56.489] getGlobalsAndPackages() ... DONE
[10:19:56.489]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:56.489]  - needed namespaces: [n=1] ‘future.apply’
[10:19:56.489] Finding globals ... DONE
[10:19:56.489]  - use_args: TRUE
[10:19:56.489]  - Getting '...' globals ...
[10:19:56.492] resolve() on list ...
[10:19:56.492]  recursive: 0
[10:19:56.492]  length: 1
[10:19:56.492]  elements: ‘...’
[10:19:56.493]  length: 0 (resolved future 1)
[10:19:56.493] resolve() on list ... DONE
[10:19:56.493]    - '...' content: [n=0] 
[10:19:56.493] List of 1
[10:19:56.493]  $ ...: list()
[10:19:56.493]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:56.493]  - attr(*, "where")=List of 1
[10:19:56.493]   ..$ ...:<environment: 0x55c6a2853aa0> 
[10:19:56.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:56.493]  - attr(*, "resolved")= logi TRUE
[10:19:56.493]  - attr(*, "total_size")= num NA
[10:19:56.495]  - Getting '...' globals ... DONE
[10:19:56.495] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:56.495] List of 8
[10:19:56.495]  $ ...future.FUN:function (x, ...)  
[10:19:56.495]  $ x_FUN        :function (x)  
[10:19:56.495]  $ times        : int 4
[10:19:56.495]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:56.495]  $ stop_if_not  :function (...)  
[10:19:56.495]  $ dim          : int [1:2] 2 2
[10:19:56.495]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:56.495]  $ ...          : list()
[10:19:56.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:56.495]  - attr(*, "where")=List of 8
[10:19:56.495]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:56.495]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:56.495]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:56.495]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:56.495]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:56.495]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:56.495]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:56.495]   ..$ ...          :<environment: 0x55c6a2853aa0> 
[10:19:56.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:56.495]  - attr(*, "resolved")= logi FALSE
[10:19:56.495]  - attr(*, "total_size")= num 24886
[10:19:56.501] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:56.501] getGlobalsAndPackagesXApply() ... DONE
[10:19:56.501] Number of futures (= number of chunks): 2
[10:19:56.501] Launching 2 futures (chunks) ...
[10:19:56.501] Chunk #1 of 2 ...
[10:19:56.501]  - Finding globals in 'X' for chunk #1 ...
[10:19:56.501] getGlobalsAndPackages() ...
[10:19:56.502] Searching for globals...
[10:19:56.502] 
[10:19:56.502] Searching for globals ... DONE
[10:19:56.502] - globals: [0] <none>
[10:19:56.502] getGlobalsAndPackages() ... DONE
[10:19:56.502]    + additional globals found: [n=0] 
[10:19:56.502]    + additional namespaces needed: [n=0] 
[10:19:56.502]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:56.502]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:56.503]  - seeds: <none>
[10:19:56.503]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.503] getGlobalsAndPackages() ...
[10:19:56.503] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.503] Resolving globals: FALSE
[10:19:56.503] Tweak future expression to call with '...' arguments ...
[10:19:56.503] {
[10:19:56.503]     do.call(function(...) {
[10:19:56.503]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.503]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.503]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.503]             on.exit(options(oopts), add = TRUE)
[10:19:56.503]         }
[10:19:56.503]         {
[10:19:56.503]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.503]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.503]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.503]             })
[10:19:56.503]         }
[10:19:56.503]     }, args = future.call.arguments)
[10:19:56.503] }
[10:19:56.503] Tweak future expression to call with '...' arguments ... DONE
[10:19:56.504] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.504] - packages: [1] ‘future.apply’
[10:19:56.504] getGlobalsAndPackages() ... DONE
[10:19:56.505] run() for ‘Future’ ...
[10:19:56.505] - state: ‘created’
[10:19:56.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:56.520] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:56.520]   - Field: ‘node’
[10:19:56.520]   - Field: ‘label’
[10:19:56.520]   - Field: ‘local’
[10:19:56.520]   - Field: ‘owner’
[10:19:56.521]   - Field: ‘envir’
[10:19:56.521]   - Field: ‘workers’
[10:19:56.521]   - Field: ‘packages’
[10:19:56.521]   - Field: ‘gc’
[10:19:56.521]   - Field: ‘conditions’
[10:19:56.521]   - Field: ‘persistent’
[10:19:56.521]   - Field: ‘expr’
[10:19:56.521]   - Field: ‘uuid’
[10:19:56.521]   - Field: ‘seed’
[10:19:56.521]   - Field: ‘version’
[10:19:56.521]   - Field: ‘result’
[10:19:56.522]   - Field: ‘asynchronous’
[10:19:56.522]   - Field: ‘calls’
[10:19:56.522]   - Field: ‘globals’
[10:19:56.522]   - Field: ‘stdout’
[10:19:56.522]   - Field: ‘earlySignal’
[10:19:56.522]   - Field: ‘lazy’
[10:19:56.522]   - Field: ‘state’
[10:19:56.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:56.522] - Launch lazy future ...
[10:19:56.522] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:56.523] Packages needed by future strategies (n = 0): <none>
[10:19:56.523] {
[10:19:56.523]     {
[10:19:56.523]         {
[10:19:56.523]             ...future.startTime <- base::Sys.time()
[10:19:56.523]             {
[10:19:56.523]                 {
[10:19:56.523]                   {
[10:19:56.523]                     {
[10:19:56.523]                       {
[10:19:56.523]                         base::local({
[10:19:56.523]                           has_future <- base::requireNamespace("future", 
[10:19:56.523]                             quietly = TRUE)
[10:19:56.523]                           if (has_future) {
[10:19:56.523]                             ns <- base::getNamespace("future")
[10:19:56.523]                             version <- ns[[".package"]][["version"]]
[10:19:56.523]                             if (is.null(version)) 
[10:19:56.523]                               version <- utils::packageVersion("future")
[10:19:56.523]                           }
[10:19:56.523]                           else {
[10:19:56.523]                             version <- NULL
[10:19:56.523]                           }
[10:19:56.523]                           if (!has_future || version < "1.8.0") {
[10:19:56.523]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:56.523]                               "", base::R.version$version.string), 
[10:19:56.523]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:56.523]                                 base::R.version$platform, 8 * 
[10:19:56.523]                                   base::.Machine$sizeof.pointer), 
[10:19:56.523]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:56.523]                                 "release", "version")], collapse = " "), 
[10:19:56.523]                               hostname = base::Sys.info()[["nodename"]])
[10:19:56.523]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:56.523]                               info)
[10:19:56.523]                             info <- base::paste(info, collapse = "; ")
[10:19:56.523]                             if (!has_future) {
[10:19:56.523]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:56.523]                                 info)
[10:19:56.523]                             }
[10:19:56.523]                             else {
[10:19:56.523]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:56.523]                                 info, version)
[10:19:56.523]                             }
[10:19:56.523]                             base::stop(msg)
[10:19:56.523]                           }
[10:19:56.523]                         })
[10:19:56.523]                       }
[10:19:56.523]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:56.523]                       base::options(mc.cores = 1L)
[10:19:56.523]                     }
[10:19:56.523]                     base::local({
[10:19:56.523]                       for (pkg in "future.apply") {
[10:19:56.523]                         base::loadNamespace(pkg)
[10:19:56.523]                         base::library(pkg, character.only = TRUE)
[10:19:56.523]                       }
[10:19:56.523]                     })
[10:19:56.523]                   }
[10:19:56.523]                   ...future.strategy.old <- future::plan("list")
[10:19:56.523]                   options(future.plan = NULL)
[10:19:56.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:56.523]                 }
[10:19:56.523]                 ...future.workdir <- getwd()
[10:19:56.523]             }
[10:19:56.523]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:56.523]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:56.523]         }
[10:19:56.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:56.523]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:56.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:56.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:56.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:56.523]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:56.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:56.523]             base::names(...future.oldOptions))
[10:19:56.523]     }
[10:19:56.523]     if (FALSE) {
[10:19:56.523]     }
[10:19:56.523]     else {
[10:19:56.523]         if (TRUE) {
[10:19:56.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:56.523]                 open = "w")
[10:19:56.523]         }
[10:19:56.523]         else {
[10:19:56.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:56.523]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:56.523]         }
[10:19:56.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:56.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:56.523]             base::sink(type = "output", split = FALSE)
[10:19:56.523]             base::close(...future.stdout)
[10:19:56.523]         }, add = TRUE)
[10:19:56.523]     }
[10:19:56.523]     ...future.frame <- base::sys.nframe()
[10:19:56.523]     ...future.conditions <- base::list()
[10:19:56.523]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:56.523]     if (FALSE) {
[10:19:56.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:56.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:56.523]     }
[10:19:56.523]     ...future.result <- base::tryCatch({
[10:19:56.523]         base::withCallingHandlers({
[10:19:56.523]             ...future.value <- base::withVisible(base::local({
[10:19:56.523]                 ...future.makeSendCondition <- base::local({
[10:19:56.523]                   sendCondition <- NULL
[10:19:56.523]                   function(frame = 1L) {
[10:19:56.523]                     if (is.function(sendCondition)) 
[10:19:56.523]                       return(sendCondition)
[10:19:56.523]                     ns <- getNamespace("parallel")
[10:19:56.523]                     if (exists("sendData", mode = "function", 
[10:19:56.523]                       envir = ns)) {
[10:19:56.523]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:56.523]                         envir = ns)
[10:19:56.523]                       envir <- sys.frame(frame)
[10:19:56.523]                       master <- NULL
[10:19:56.523]                       while (!identical(envir, .GlobalEnv) && 
[10:19:56.523]                         !identical(envir, emptyenv())) {
[10:19:56.523]                         if (exists("master", mode = "list", envir = envir, 
[10:19:56.523]                           inherits = FALSE)) {
[10:19:56.523]                           master <- get("master", mode = "list", 
[10:19:56.523]                             envir = envir, inherits = FALSE)
[10:19:56.523]                           if (inherits(master, c("SOCKnode", 
[10:19:56.523]                             "SOCK0node"))) {
[10:19:56.523]                             sendCondition <<- function(cond) {
[10:19:56.523]                               data <- list(type = "VALUE", value = cond, 
[10:19:56.523]                                 success = TRUE)
[10:19:56.523]                               parallel_sendData(master, data)
[10:19:56.523]                             }
[10:19:56.523]                             return(sendCondition)
[10:19:56.523]                           }
[10:19:56.523]                         }
[10:19:56.523]                         frame <- frame + 1L
[10:19:56.523]                         envir <- sys.frame(frame)
[10:19:56.523]                       }
[10:19:56.523]                     }
[10:19:56.523]                     sendCondition <<- function(cond) NULL
[10:19:56.523]                   }
[10:19:56.523]                 })
[10:19:56.523]                 withCallingHandlers({
[10:19:56.523]                   {
[10:19:56.523]                     do.call(function(...) {
[10:19:56.523]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.523]                       if (!identical(...future.globals.maxSize.org, 
[10:19:56.523]                         ...future.globals.maxSize)) {
[10:19:56.523]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.523]                         on.exit(options(oopts), add = TRUE)
[10:19:56.523]                       }
[10:19:56.523]                       {
[10:19:56.523]                         lapply(seq_along(...future.elements_ii), 
[10:19:56.523]                           FUN = function(jj) {
[10:19:56.523]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.523]                             ...future.FUN(...future.X_jj, ...)
[10:19:56.523]                           })
[10:19:56.523]                       }
[10:19:56.523]                     }, args = future.call.arguments)
[10:19:56.523]                   }
[10:19:56.523]                 }, immediateCondition = function(cond) {
[10:19:56.523]                   sendCondition <- ...future.makeSendCondition()
[10:19:56.523]                   sendCondition(cond)
[10:19:56.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.523]                   {
[10:19:56.523]                     inherits <- base::inherits
[10:19:56.523]                     invokeRestart <- base::invokeRestart
[10:19:56.523]                     is.null <- base::is.null
[10:19:56.523]                     muffled <- FALSE
[10:19:56.523]                     if (inherits(cond, "message")) {
[10:19:56.523]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:56.523]                       if (muffled) 
[10:19:56.523]                         invokeRestart("muffleMessage")
[10:19:56.523]                     }
[10:19:56.523]                     else if (inherits(cond, "warning")) {
[10:19:56.523]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:56.523]                       if (muffled) 
[10:19:56.523]                         invokeRestart("muffleWarning")
[10:19:56.523]                     }
[10:19:56.523]                     else if (inherits(cond, "condition")) {
[10:19:56.523]                       if (!is.null(pattern)) {
[10:19:56.523]                         computeRestarts <- base::computeRestarts
[10:19:56.523]                         grepl <- base::grepl
[10:19:56.523]                         restarts <- computeRestarts(cond)
[10:19:56.523]                         for (restart in restarts) {
[10:19:56.523]                           name <- restart$name
[10:19:56.523]                           if (is.null(name)) 
[10:19:56.523]                             next
[10:19:56.523]                           if (!grepl(pattern, name)) 
[10:19:56.523]                             next
[10:19:56.523]                           invokeRestart(restart)
[10:19:56.523]                           muffled <- TRUE
[10:19:56.523]                           break
[10:19:56.523]                         }
[10:19:56.523]                       }
[10:19:56.523]                     }
[10:19:56.523]                     invisible(muffled)
[10:19:56.523]                   }
[10:19:56.523]                   muffleCondition(cond)
[10:19:56.523]                 })
[10:19:56.523]             }))
[10:19:56.523]             future::FutureResult(value = ...future.value$value, 
[10:19:56.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.523]                   ...future.rng), globalenv = if (FALSE) 
[10:19:56.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:56.523]                     ...future.globalenv.names))
[10:19:56.523]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:56.523]         }, condition = base::local({
[10:19:56.523]             c <- base::c
[10:19:56.523]             inherits <- base::inherits
[10:19:56.523]             invokeRestart <- base::invokeRestart
[10:19:56.523]             length <- base::length
[10:19:56.523]             list <- base::list
[10:19:56.523]             seq.int <- base::seq.int
[10:19:56.523]             signalCondition <- base::signalCondition
[10:19:56.523]             sys.calls <- base::sys.calls
[10:19:56.523]             `[[` <- base::`[[`
[10:19:56.523]             `+` <- base::`+`
[10:19:56.523]             `<<-` <- base::`<<-`
[10:19:56.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:56.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:56.523]                   3L)]
[10:19:56.523]             }
[10:19:56.523]             function(cond) {
[10:19:56.523]                 is_error <- inherits(cond, "error")
[10:19:56.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:56.523]                   NULL)
[10:19:56.523]                 if (is_error) {
[10:19:56.523]                   sessionInformation <- function() {
[10:19:56.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:56.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:56.523]                       search = base::search(), system = base::Sys.info())
[10:19:56.523]                   }
[10:19:56.523]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:56.523]                     cond$call), session = sessionInformation(), 
[10:19:56.523]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:56.523]                   signalCondition(cond)
[10:19:56.523]                 }
[10:19:56.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:56.523]                 "immediateCondition"))) {
[10:19:56.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:56.523]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:56.523]                   if (TRUE && !signal) {
[10:19:56.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.523]                     {
[10:19:56.523]                       inherits <- base::inherits
[10:19:56.523]                       invokeRestart <- base::invokeRestart
[10:19:56.523]                       is.null <- base::is.null
[10:19:56.523]                       muffled <- FALSE
[10:19:56.523]                       if (inherits(cond, "message")) {
[10:19:56.523]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.523]                         if (muffled) 
[10:19:56.523]                           invokeRestart("muffleMessage")
[10:19:56.523]                       }
[10:19:56.523]                       else if (inherits(cond, "warning")) {
[10:19:56.523]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.523]                         if (muffled) 
[10:19:56.523]                           invokeRestart("muffleWarning")
[10:19:56.523]                       }
[10:19:56.523]                       else if (inherits(cond, "condition")) {
[10:19:56.523]                         if (!is.null(pattern)) {
[10:19:56.523]                           computeRestarts <- base::computeRestarts
[10:19:56.523]                           grepl <- base::grepl
[10:19:56.523]                           restarts <- computeRestarts(cond)
[10:19:56.523]                           for (restart in restarts) {
[10:19:56.523]                             name <- restart$name
[10:19:56.523]                             if (is.null(name)) 
[10:19:56.523]                               next
[10:19:56.523]                             if (!grepl(pattern, name)) 
[10:19:56.523]                               next
[10:19:56.523]                             invokeRestart(restart)
[10:19:56.523]                             muffled <- TRUE
[10:19:56.523]                             break
[10:19:56.523]                           }
[10:19:56.523]                         }
[10:19:56.523]                       }
[10:19:56.523]                       invisible(muffled)
[10:19:56.523]                     }
[10:19:56.523]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.523]                   }
[10:19:56.523]                 }
[10:19:56.523]                 else {
[10:19:56.523]                   if (TRUE) {
[10:19:56.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.523]                     {
[10:19:56.523]                       inherits <- base::inherits
[10:19:56.523]                       invokeRestart <- base::invokeRestart
[10:19:56.523]                       is.null <- base::is.null
[10:19:56.523]                       muffled <- FALSE
[10:19:56.523]                       if (inherits(cond, "message")) {
[10:19:56.523]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.523]                         if (muffled) 
[10:19:56.523]                           invokeRestart("muffleMessage")
[10:19:56.523]                       }
[10:19:56.523]                       else if (inherits(cond, "warning")) {
[10:19:56.523]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.523]                         if (muffled) 
[10:19:56.523]                           invokeRestart("muffleWarning")
[10:19:56.523]                       }
[10:19:56.523]                       else if (inherits(cond, "condition")) {
[10:19:56.523]                         if (!is.null(pattern)) {
[10:19:56.523]                           computeRestarts <- base::computeRestarts
[10:19:56.523]                           grepl <- base::grepl
[10:19:56.523]                           restarts <- computeRestarts(cond)
[10:19:56.523]                           for (restart in restarts) {
[10:19:56.523]                             name <- restart$name
[10:19:56.523]                             if (is.null(name)) 
[10:19:56.523]                               next
[10:19:56.523]                             if (!grepl(pattern, name)) 
[10:19:56.523]                               next
[10:19:56.523]                             invokeRestart(restart)
[10:19:56.523]                             muffled <- TRUE
[10:19:56.523]                             break
[10:19:56.523]                           }
[10:19:56.523]                         }
[10:19:56.523]                       }
[10:19:56.523]                       invisible(muffled)
[10:19:56.523]                     }
[10:19:56.523]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.523]                   }
[10:19:56.523]                 }
[10:19:56.523]             }
[10:19:56.523]         }))
[10:19:56.523]     }, error = function(ex) {
[10:19:56.523]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:56.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.523]                 ...future.rng), started = ...future.startTime, 
[10:19:56.523]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:56.523]             version = "1.8"), class = "FutureResult")
[10:19:56.523]     }, finally = {
[10:19:56.523]         if (!identical(...future.workdir, getwd())) 
[10:19:56.523]             setwd(...future.workdir)
[10:19:56.523]         {
[10:19:56.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:56.523]                 ...future.oldOptions$nwarnings <- NULL
[10:19:56.523]             }
[10:19:56.523]             base::options(...future.oldOptions)
[10:19:56.523]             if (.Platform$OS.type == "windows") {
[10:19:56.523]                 old_names <- names(...future.oldEnvVars)
[10:19:56.523]                 envs <- base::Sys.getenv()
[10:19:56.523]                 names <- names(envs)
[10:19:56.523]                 common <- intersect(names, old_names)
[10:19:56.523]                 added <- setdiff(names, old_names)
[10:19:56.523]                 removed <- setdiff(old_names, names)
[10:19:56.523]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:56.523]                   envs[common]]
[10:19:56.523]                 NAMES <- toupper(changed)
[10:19:56.523]                 args <- list()
[10:19:56.523]                 for (kk in seq_along(NAMES)) {
[10:19:56.523]                   name <- changed[[kk]]
[10:19:56.523]                   NAME <- NAMES[[kk]]
[10:19:56.523]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.523]                     next
[10:19:56.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.523]                 }
[10:19:56.523]                 NAMES <- toupper(added)
[10:19:56.523]                 for (kk in seq_along(NAMES)) {
[10:19:56.523]                   name <- added[[kk]]
[10:19:56.523]                   NAME <- NAMES[[kk]]
[10:19:56.523]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.523]                     next
[10:19:56.523]                   args[[name]] <- ""
[10:19:56.523]                 }
[10:19:56.523]                 NAMES <- toupper(removed)
[10:19:56.523]                 for (kk in seq_along(NAMES)) {
[10:19:56.523]                   name <- removed[[kk]]
[10:19:56.523]                   NAME <- NAMES[[kk]]
[10:19:56.523]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.523]                     next
[10:19:56.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.523]                 }
[10:19:56.523]                 if (length(args) > 0) 
[10:19:56.523]                   base::do.call(base::Sys.setenv, args = args)
[10:19:56.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:56.523]             }
[10:19:56.523]             else {
[10:19:56.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:56.523]             }
[10:19:56.523]             {
[10:19:56.523]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:56.523]                   0L) {
[10:19:56.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:56.523]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:56.523]                   base::options(opts)
[10:19:56.523]                 }
[10:19:56.523]                 {
[10:19:56.523]                   {
[10:19:56.523]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:56.523]                     NULL
[10:19:56.523]                   }
[10:19:56.523]                   options(future.plan = NULL)
[10:19:56.523]                   if (is.na(NA_character_)) 
[10:19:56.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:56.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:56.523]                     .init = FALSE)
[10:19:56.523]                 }
[10:19:56.523]             }
[10:19:56.523]         }
[10:19:56.523]     })
[10:19:56.523]     if (TRUE) {
[10:19:56.523]         base::sink(type = "output", split = FALSE)
[10:19:56.523]         if (TRUE) {
[10:19:56.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:56.523]         }
[10:19:56.523]         else {
[10:19:56.523]             ...future.result["stdout"] <- base::list(NULL)
[10:19:56.523]         }
[10:19:56.523]         base::close(...future.stdout)
[10:19:56.523]         ...future.stdout <- NULL
[10:19:56.523]     }
[10:19:56.523]     ...future.result$conditions <- ...future.conditions
[10:19:56.523]     ...future.result$finished <- base::Sys.time()
[10:19:56.523]     ...future.result
[10:19:56.523] }
[10:19:56.526] Exporting 11 global objects (14.01 KiB) to cluster node #1 ...
[10:19:56.526] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #1 ...
[10:19:56.567] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #1 ... DONE
[10:19:56.567] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ...
[10:19:56.568] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ... DONE
[10:19:56.568] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:56.568] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:56.569] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:56.609] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:56.609] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:56.650] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:56.651] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[10:19:56.651] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[10:19:56.651] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[10:19:56.651] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[10:19:56.652] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:56.652] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:56.652] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[10:19:56.652] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[10:19:56.652] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:56.653] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:56.653] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:56.653] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:56.653] Exporting 11 global objects (14.01 KiB) to cluster node #1 ... DONE
[10:19:56.654] MultisessionFuture started
[10:19:56.654] - Launch lazy future ... done
[10:19:56.654] run() for ‘MultisessionFuture’ ... done
[10:19:56.654] Created future:
[10:19:56.654] MultisessionFuture:
[10:19:56.654] Label: ‘future_vapply-1’
[10:19:56.654] Expression:
[10:19:56.654] {
[10:19:56.654]     do.call(function(...) {
[10:19:56.654]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.654]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.654]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.654]             on.exit(options(oopts), add = TRUE)
[10:19:56.654]         }
[10:19:56.654]         {
[10:19:56.654]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.654]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.654]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.654]             })
[10:19:56.654]         }
[10:19:56.654]     }, args = future.call.arguments)
[10:19:56.654] }
[10:19:56.654] Lazy evaluation: FALSE
[10:19:56.654] Asynchronous evaluation: TRUE
[10:19:56.654] Local evaluation: TRUE
[10:19:56.654] Environment: R_GlobalEnv
[10:19:56.654] Capture standard output: TRUE
[10:19:56.654] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:56.654] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:56.654] Packages: 1 packages (‘future.apply’)
[10:19:56.654] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:56.654] Resolved: FALSE
[10:19:56.654] Value: <not collected>
[10:19:56.654] Conditions captured: <none>
[10:19:56.654] Early signaling: FALSE
[10:19:56.654] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:56.654] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.666] Chunk #1 of 2 ... DONE
[10:19:56.666] Chunk #2 of 2 ...
[10:19:56.666]  - Finding globals in 'X' for chunk #2 ...
[10:19:56.666] getGlobalsAndPackages() ...
[10:19:56.666] Searching for globals...
[10:19:56.667] 
[10:19:56.667] Searching for globals ... DONE
[10:19:56.667] - globals: [0] <none>
[10:19:56.667] getGlobalsAndPackages() ... DONE
[10:19:56.667]    + additional globals found: [n=0] 
[10:19:56.667]    + additional namespaces needed: [n=0] 
[10:19:56.667]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:56.667]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:56.667]  - seeds: <none>
[10:19:56.668]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.668] getGlobalsAndPackages() ...
[10:19:56.668] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.668] Resolving globals: FALSE
[10:19:56.668] Tweak future expression to call with '...' arguments ...
[10:19:56.668] {
[10:19:56.668]     do.call(function(...) {
[10:19:56.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.668]             on.exit(options(oopts), add = TRUE)
[10:19:56.668]         }
[10:19:56.668]         {
[10:19:56.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.668]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.668]             })
[10:19:56.668]         }
[10:19:56.668]     }, args = future.call.arguments)
[10:19:56.668] }
[10:19:56.668] Tweak future expression to call with '...' arguments ... DONE
[10:19:56.669] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.669] - packages: [1] ‘future.apply’
[10:19:56.669] getGlobalsAndPackages() ... DONE
[10:19:56.669] run() for ‘Future’ ...
[10:19:56.669] - state: ‘created’
[10:19:56.669] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:56.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:56.684]   - Field: ‘node’
[10:19:56.684]   - Field: ‘label’
[10:19:56.684]   - Field: ‘local’
[10:19:56.684]   - Field: ‘owner’
[10:19:56.684]   - Field: ‘envir’
[10:19:56.684]   - Field: ‘workers’
[10:19:56.684]   - Field: ‘packages’
[10:19:56.684]   - Field: ‘gc’
[10:19:56.684]   - Field: ‘conditions’
[10:19:56.684]   - Field: ‘persistent’
[10:19:56.685]   - Field: ‘expr’
[10:19:56.685]   - Field: ‘uuid’
[10:19:56.685]   - Field: ‘seed’
[10:19:56.685]   - Field: ‘version’
[10:19:56.685]   - Field: ‘result’
[10:19:56.685]   - Field: ‘asynchronous’
[10:19:56.685]   - Field: ‘calls’
[10:19:56.685]   - Field: ‘globals’
[10:19:56.685]   - Field: ‘stdout’
[10:19:56.685]   - Field: ‘earlySignal’
[10:19:56.685]   - Field: ‘lazy’
[10:19:56.686]   - Field: ‘state’
[10:19:56.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:56.686] - Launch lazy future ...
[10:19:56.686] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:56.686] Packages needed by future strategies (n = 0): <none>
[10:19:56.687] {
[10:19:56.687]     {
[10:19:56.687]         {
[10:19:56.687]             ...future.startTime <- base::Sys.time()
[10:19:56.687]             {
[10:19:56.687]                 {
[10:19:56.687]                   {
[10:19:56.687]                     {
[10:19:56.687]                       {
[10:19:56.687]                         base::local({
[10:19:56.687]                           has_future <- base::requireNamespace("future", 
[10:19:56.687]                             quietly = TRUE)
[10:19:56.687]                           if (has_future) {
[10:19:56.687]                             ns <- base::getNamespace("future")
[10:19:56.687]                             version <- ns[[".package"]][["version"]]
[10:19:56.687]                             if (is.null(version)) 
[10:19:56.687]                               version <- utils::packageVersion("future")
[10:19:56.687]                           }
[10:19:56.687]                           else {
[10:19:56.687]                             version <- NULL
[10:19:56.687]                           }
[10:19:56.687]                           if (!has_future || version < "1.8.0") {
[10:19:56.687]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:56.687]                               "", base::R.version$version.string), 
[10:19:56.687]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:56.687]                                 base::R.version$platform, 8 * 
[10:19:56.687]                                   base::.Machine$sizeof.pointer), 
[10:19:56.687]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:56.687]                                 "release", "version")], collapse = " "), 
[10:19:56.687]                               hostname = base::Sys.info()[["nodename"]])
[10:19:56.687]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:56.687]                               info)
[10:19:56.687]                             info <- base::paste(info, collapse = "; ")
[10:19:56.687]                             if (!has_future) {
[10:19:56.687]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:56.687]                                 info)
[10:19:56.687]                             }
[10:19:56.687]                             else {
[10:19:56.687]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:56.687]                                 info, version)
[10:19:56.687]                             }
[10:19:56.687]                             base::stop(msg)
[10:19:56.687]                           }
[10:19:56.687]                         })
[10:19:56.687]                       }
[10:19:56.687]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:56.687]                       base::options(mc.cores = 1L)
[10:19:56.687]                     }
[10:19:56.687]                     base::local({
[10:19:56.687]                       for (pkg in "future.apply") {
[10:19:56.687]                         base::loadNamespace(pkg)
[10:19:56.687]                         base::library(pkg, character.only = TRUE)
[10:19:56.687]                       }
[10:19:56.687]                     })
[10:19:56.687]                   }
[10:19:56.687]                   ...future.strategy.old <- future::plan("list")
[10:19:56.687]                   options(future.plan = NULL)
[10:19:56.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:56.687]                 }
[10:19:56.687]                 ...future.workdir <- getwd()
[10:19:56.687]             }
[10:19:56.687]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:56.687]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:56.687]         }
[10:19:56.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:56.687]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:56.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:56.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:56.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:56.687]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:56.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:56.687]             base::names(...future.oldOptions))
[10:19:56.687]     }
[10:19:56.687]     if (FALSE) {
[10:19:56.687]     }
[10:19:56.687]     else {
[10:19:56.687]         if (TRUE) {
[10:19:56.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:56.687]                 open = "w")
[10:19:56.687]         }
[10:19:56.687]         else {
[10:19:56.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:56.687]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:56.687]         }
[10:19:56.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:56.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:56.687]             base::sink(type = "output", split = FALSE)
[10:19:56.687]             base::close(...future.stdout)
[10:19:56.687]         }, add = TRUE)
[10:19:56.687]     }
[10:19:56.687]     ...future.frame <- base::sys.nframe()
[10:19:56.687]     ...future.conditions <- base::list()
[10:19:56.687]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:56.687]     if (FALSE) {
[10:19:56.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:56.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:56.687]     }
[10:19:56.687]     ...future.result <- base::tryCatch({
[10:19:56.687]         base::withCallingHandlers({
[10:19:56.687]             ...future.value <- base::withVisible(base::local({
[10:19:56.687]                 ...future.makeSendCondition <- base::local({
[10:19:56.687]                   sendCondition <- NULL
[10:19:56.687]                   function(frame = 1L) {
[10:19:56.687]                     if (is.function(sendCondition)) 
[10:19:56.687]                       return(sendCondition)
[10:19:56.687]                     ns <- getNamespace("parallel")
[10:19:56.687]                     if (exists("sendData", mode = "function", 
[10:19:56.687]                       envir = ns)) {
[10:19:56.687]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:56.687]                         envir = ns)
[10:19:56.687]                       envir <- sys.frame(frame)
[10:19:56.687]                       master <- NULL
[10:19:56.687]                       while (!identical(envir, .GlobalEnv) && 
[10:19:56.687]                         !identical(envir, emptyenv())) {
[10:19:56.687]                         if (exists("master", mode = "list", envir = envir, 
[10:19:56.687]                           inherits = FALSE)) {
[10:19:56.687]                           master <- get("master", mode = "list", 
[10:19:56.687]                             envir = envir, inherits = FALSE)
[10:19:56.687]                           if (inherits(master, c("SOCKnode", 
[10:19:56.687]                             "SOCK0node"))) {
[10:19:56.687]                             sendCondition <<- function(cond) {
[10:19:56.687]                               data <- list(type = "VALUE", value = cond, 
[10:19:56.687]                                 success = TRUE)
[10:19:56.687]                               parallel_sendData(master, data)
[10:19:56.687]                             }
[10:19:56.687]                             return(sendCondition)
[10:19:56.687]                           }
[10:19:56.687]                         }
[10:19:56.687]                         frame <- frame + 1L
[10:19:56.687]                         envir <- sys.frame(frame)
[10:19:56.687]                       }
[10:19:56.687]                     }
[10:19:56.687]                     sendCondition <<- function(cond) NULL
[10:19:56.687]                   }
[10:19:56.687]                 })
[10:19:56.687]                 withCallingHandlers({
[10:19:56.687]                   {
[10:19:56.687]                     do.call(function(...) {
[10:19:56.687]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.687]                       if (!identical(...future.globals.maxSize.org, 
[10:19:56.687]                         ...future.globals.maxSize)) {
[10:19:56.687]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.687]                         on.exit(options(oopts), add = TRUE)
[10:19:56.687]                       }
[10:19:56.687]                       {
[10:19:56.687]                         lapply(seq_along(...future.elements_ii), 
[10:19:56.687]                           FUN = function(jj) {
[10:19:56.687]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.687]                             ...future.FUN(...future.X_jj, ...)
[10:19:56.687]                           })
[10:19:56.687]                       }
[10:19:56.687]                     }, args = future.call.arguments)
[10:19:56.687]                   }
[10:19:56.687]                 }, immediateCondition = function(cond) {
[10:19:56.687]                   sendCondition <- ...future.makeSendCondition()
[10:19:56.687]                   sendCondition(cond)
[10:19:56.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.687]                   {
[10:19:56.687]                     inherits <- base::inherits
[10:19:56.687]                     invokeRestart <- base::invokeRestart
[10:19:56.687]                     is.null <- base::is.null
[10:19:56.687]                     muffled <- FALSE
[10:19:56.687]                     if (inherits(cond, "message")) {
[10:19:56.687]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:56.687]                       if (muffled) 
[10:19:56.687]                         invokeRestart("muffleMessage")
[10:19:56.687]                     }
[10:19:56.687]                     else if (inherits(cond, "warning")) {
[10:19:56.687]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:56.687]                       if (muffled) 
[10:19:56.687]                         invokeRestart("muffleWarning")
[10:19:56.687]                     }
[10:19:56.687]                     else if (inherits(cond, "condition")) {
[10:19:56.687]                       if (!is.null(pattern)) {
[10:19:56.687]                         computeRestarts <- base::computeRestarts
[10:19:56.687]                         grepl <- base::grepl
[10:19:56.687]                         restarts <- computeRestarts(cond)
[10:19:56.687]                         for (restart in restarts) {
[10:19:56.687]                           name <- restart$name
[10:19:56.687]                           if (is.null(name)) 
[10:19:56.687]                             next
[10:19:56.687]                           if (!grepl(pattern, name)) 
[10:19:56.687]                             next
[10:19:56.687]                           invokeRestart(restart)
[10:19:56.687]                           muffled <- TRUE
[10:19:56.687]                           break
[10:19:56.687]                         }
[10:19:56.687]                       }
[10:19:56.687]                     }
[10:19:56.687]                     invisible(muffled)
[10:19:56.687]                   }
[10:19:56.687]                   muffleCondition(cond)
[10:19:56.687]                 })
[10:19:56.687]             }))
[10:19:56.687]             future::FutureResult(value = ...future.value$value, 
[10:19:56.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.687]                   ...future.rng), globalenv = if (FALSE) 
[10:19:56.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:56.687]                     ...future.globalenv.names))
[10:19:56.687]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:56.687]         }, condition = base::local({
[10:19:56.687]             c <- base::c
[10:19:56.687]             inherits <- base::inherits
[10:19:56.687]             invokeRestart <- base::invokeRestart
[10:19:56.687]             length <- base::length
[10:19:56.687]             list <- base::list
[10:19:56.687]             seq.int <- base::seq.int
[10:19:56.687]             signalCondition <- base::signalCondition
[10:19:56.687]             sys.calls <- base::sys.calls
[10:19:56.687]             `[[` <- base::`[[`
[10:19:56.687]             `+` <- base::`+`
[10:19:56.687]             `<<-` <- base::`<<-`
[10:19:56.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:56.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:56.687]                   3L)]
[10:19:56.687]             }
[10:19:56.687]             function(cond) {
[10:19:56.687]                 is_error <- inherits(cond, "error")
[10:19:56.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:56.687]                   NULL)
[10:19:56.687]                 if (is_error) {
[10:19:56.687]                   sessionInformation <- function() {
[10:19:56.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:56.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:56.687]                       search = base::search(), system = base::Sys.info())
[10:19:56.687]                   }
[10:19:56.687]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:56.687]                     cond$call), session = sessionInformation(), 
[10:19:56.687]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:56.687]                   signalCondition(cond)
[10:19:56.687]                 }
[10:19:56.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:56.687]                 "immediateCondition"))) {
[10:19:56.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:56.687]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:56.687]                   if (TRUE && !signal) {
[10:19:56.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.687]                     {
[10:19:56.687]                       inherits <- base::inherits
[10:19:56.687]                       invokeRestart <- base::invokeRestart
[10:19:56.687]                       is.null <- base::is.null
[10:19:56.687]                       muffled <- FALSE
[10:19:56.687]                       if (inherits(cond, "message")) {
[10:19:56.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.687]                         if (muffled) 
[10:19:56.687]                           invokeRestart("muffleMessage")
[10:19:56.687]                       }
[10:19:56.687]                       else if (inherits(cond, "warning")) {
[10:19:56.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.687]                         if (muffled) 
[10:19:56.687]                           invokeRestart("muffleWarning")
[10:19:56.687]                       }
[10:19:56.687]                       else if (inherits(cond, "condition")) {
[10:19:56.687]                         if (!is.null(pattern)) {
[10:19:56.687]                           computeRestarts <- base::computeRestarts
[10:19:56.687]                           grepl <- base::grepl
[10:19:56.687]                           restarts <- computeRestarts(cond)
[10:19:56.687]                           for (restart in restarts) {
[10:19:56.687]                             name <- restart$name
[10:19:56.687]                             if (is.null(name)) 
[10:19:56.687]                               next
[10:19:56.687]                             if (!grepl(pattern, name)) 
[10:19:56.687]                               next
[10:19:56.687]                             invokeRestart(restart)
[10:19:56.687]                             muffled <- TRUE
[10:19:56.687]                             break
[10:19:56.687]                           }
[10:19:56.687]                         }
[10:19:56.687]                       }
[10:19:56.687]                       invisible(muffled)
[10:19:56.687]                     }
[10:19:56.687]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.687]                   }
[10:19:56.687]                 }
[10:19:56.687]                 else {
[10:19:56.687]                   if (TRUE) {
[10:19:56.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.687]                     {
[10:19:56.687]                       inherits <- base::inherits
[10:19:56.687]                       invokeRestart <- base::invokeRestart
[10:19:56.687]                       is.null <- base::is.null
[10:19:56.687]                       muffled <- FALSE
[10:19:56.687]                       if (inherits(cond, "message")) {
[10:19:56.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.687]                         if (muffled) 
[10:19:56.687]                           invokeRestart("muffleMessage")
[10:19:56.687]                       }
[10:19:56.687]                       else if (inherits(cond, "warning")) {
[10:19:56.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.687]                         if (muffled) 
[10:19:56.687]                           invokeRestart("muffleWarning")
[10:19:56.687]                       }
[10:19:56.687]                       else if (inherits(cond, "condition")) {
[10:19:56.687]                         if (!is.null(pattern)) {
[10:19:56.687]                           computeRestarts <- base::computeRestarts
[10:19:56.687]                           grepl <- base::grepl
[10:19:56.687]                           restarts <- computeRestarts(cond)
[10:19:56.687]                           for (restart in restarts) {
[10:19:56.687]                             name <- restart$name
[10:19:56.687]                             if (is.null(name)) 
[10:19:56.687]                               next
[10:19:56.687]                             if (!grepl(pattern, name)) 
[10:19:56.687]                               next
[10:19:56.687]                             invokeRestart(restart)
[10:19:56.687]                             muffled <- TRUE
[10:19:56.687]                             break
[10:19:56.687]                           }
[10:19:56.687]                         }
[10:19:56.687]                       }
[10:19:56.687]                       invisible(muffled)
[10:19:56.687]                     }
[10:19:56.687]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.687]                   }
[10:19:56.687]                 }
[10:19:56.687]             }
[10:19:56.687]         }))
[10:19:56.687]     }, error = function(ex) {
[10:19:56.687]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:56.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.687]                 ...future.rng), started = ...future.startTime, 
[10:19:56.687]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:56.687]             version = "1.8"), class = "FutureResult")
[10:19:56.687]     }, finally = {
[10:19:56.687]         if (!identical(...future.workdir, getwd())) 
[10:19:56.687]             setwd(...future.workdir)
[10:19:56.687]         {
[10:19:56.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:56.687]                 ...future.oldOptions$nwarnings <- NULL
[10:19:56.687]             }
[10:19:56.687]             base::options(...future.oldOptions)
[10:19:56.687]             if (.Platform$OS.type == "windows") {
[10:19:56.687]                 old_names <- names(...future.oldEnvVars)
[10:19:56.687]                 envs <- base::Sys.getenv()
[10:19:56.687]                 names <- names(envs)
[10:19:56.687]                 common <- intersect(names, old_names)
[10:19:56.687]                 added <- setdiff(names, old_names)
[10:19:56.687]                 removed <- setdiff(old_names, names)
[10:19:56.687]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:56.687]                   envs[common]]
[10:19:56.687]                 NAMES <- toupper(changed)
[10:19:56.687]                 args <- list()
[10:19:56.687]                 for (kk in seq_along(NAMES)) {
[10:19:56.687]                   name <- changed[[kk]]
[10:19:56.687]                   NAME <- NAMES[[kk]]
[10:19:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.687]                     next
[10:19:56.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.687]                 }
[10:19:56.687]                 NAMES <- toupper(added)
[10:19:56.687]                 for (kk in seq_along(NAMES)) {
[10:19:56.687]                   name <- added[[kk]]
[10:19:56.687]                   NAME <- NAMES[[kk]]
[10:19:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.687]                     next
[10:19:56.687]                   args[[name]] <- ""
[10:19:56.687]                 }
[10:19:56.687]                 NAMES <- toupper(removed)
[10:19:56.687]                 for (kk in seq_along(NAMES)) {
[10:19:56.687]                   name <- removed[[kk]]
[10:19:56.687]                   NAME <- NAMES[[kk]]
[10:19:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.687]                     next
[10:19:56.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.687]                 }
[10:19:56.687]                 if (length(args) > 0) 
[10:19:56.687]                   base::do.call(base::Sys.setenv, args = args)
[10:19:56.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:56.687]             }
[10:19:56.687]             else {
[10:19:56.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:56.687]             }
[10:19:56.687]             {
[10:19:56.687]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:56.687]                   0L) {
[10:19:56.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:56.687]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:56.687]                   base::options(opts)
[10:19:56.687]                 }
[10:19:56.687]                 {
[10:19:56.687]                   {
[10:19:56.687]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:56.687]                     NULL
[10:19:56.687]                   }
[10:19:56.687]                   options(future.plan = NULL)
[10:19:56.687]                   if (is.na(NA_character_)) 
[10:19:56.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:56.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:56.687]                     .init = FALSE)
[10:19:56.687]                 }
[10:19:56.687]             }
[10:19:56.687]         }
[10:19:56.687]     })
[10:19:56.687]     if (TRUE) {
[10:19:56.687]         base::sink(type = "output", split = FALSE)
[10:19:56.687]         if (TRUE) {
[10:19:56.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:56.687]         }
[10:19:56.687]         else {
[10:19:56.687]             ...future.result["stdout"] <- base::list(NULL)
[10:19:56.687]         }
[10:19:56.687]         base::close(...future.stdout)
[10:19:56.687]         ...future.stdout <- NULL
[10:19:56.687]     }
[10:19:56.687]     ...future.result$conditions <- ...future.conditions
[10:19:56.687]     ...future.result$finished <- base::Sys.time()
[10:19:56.687]     ...future.result
[10:19:56.687] }
[10:19:56.689] Exporting 11 global objects (14.01 KiB) to cluster node #2 ...
[10:19:56.690] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #2 ...
[10:19:56.730] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #2 ... DONE
[10:19:56.731] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ...
[10:19:56.731] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ... DONE
[10:19:56.731] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:56.731] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:56.732] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:56.772] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:56.773] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:56.813] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:56.814] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[10:19:56.814] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[10:19:56.814] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[10:19:56.815] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[10:19:56.815] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:56.815] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:56.815] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[10:19:56.815] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[10:19:56.816] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:56.816] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.816] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:56.816] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:56.817] Exporting 11 global objects (14.01 KiB) to cluster node #2 ... DONE
[10:19:56.817] MultisessionFuture started
[10:19:56.817] - Launch lazy future ... done
[10:19:56.817] run() for ‘MultisessionFuture’ ... done
[10:19:56.817] Created future:
[10:19:56.817] MultisessionFuture:
[10:19:56.817] Label: ‘future_vapply-2’
[10:19:56.817] Expression:
[10:19:56.817] {
[10:19:56.817]     do.call(function(...) {
[10:19:56.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.817]             on.exit(options(oopts), add = TRUE)
[10:19:56.817]         }
[10:19:56.817]         {
[10:19:56.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.817]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.817]             })
[10:19:56.817]         }
[10:19:56.817]     }, args = future.call.arguments)
[10:19:56.817] }
[10:19:56.817] Lazy evaluation: FALSE
[10:19:56.817] Asynchronous evaluation: TRUE
[10:19:56.817] Local evaluation: TRUE
[10:19:56.817] Environment: R_GlobalEnv
[10:19:56.817] Capture standard output: TRUE
[10:19:56.817] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:56.817] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:56.817] Packages: 1 packages (‘future.apply’)
[10:19:56.817] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:56.817] Resolved: FALSE
[10:19:56.817] Value: <not collected>
[10:19:56.817] Conditions captured: <none>
[10:19:56.817] Early signaling: FALSE
[10:19:56.817] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:56.817] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.829] Chunk #2 of 2 ... DONE
[10:19:56.829] Launching 2 futures (chunks) ... DONE
[10:19:56.829] Resolving 2 futures (chunks) ...
[10:19:56.829] resolve() on list ...
[10:19:56.829]  recursive: 0
[10:19:56.829]  length: 2
[10:19:56.830] 
[10:19:56.830] receiveMessageFromWorker() for ClusterFuture ...
[10:19:56.830] - Validating connection of MultisessionFuture
[10:19:56.830] - received message: FutureResult
[10:19:56.830] - Received FutureResult
[10:19:56.830] - Erased future from FutureRegistry
[10:19:56.831] result() for ClusterFuture ...
[10:19:56.831] - result already collected: FutureResult
[10:19:56.831] result() for ClusterFuture ... done
[10:19:56.831] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:56.831] Future #1
[10:19:56.831] result() for ClusterFuture ...
[10:19:56.831] - result already collected: FutureResult
[10:19:56.831] result() for ClusterFuture ... done
[10:19:56.831] result() for ClusterFuture ...
[10:19:56.831] - result already collected: FutureResult
[10:19:56.831] result() for ClusterFuture ... done
[10:19:56.831] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:56.832] - nx: 2
[10:19:56.832] - relay: TRUE
[10:19:56.832] - stdout: TRUE
[10:19:56.832] - signal: TRUE
[10:19:56.832] - resignal: FALSE
[10:19:56.832] - force: TRUE
[10:19:56.832] - relayed: [n=2] FALSE, FALSE
[10:19:56.832] - queued futures: [n=2] FALSE, FALSE
[10:19:56.832]  - until=1
[10:19:56.832]  - relaying element #1
[10:19:56.832] result() for ClusterFuture ...
[10:19:56.832] - result already collected: FutureResult
[10:19:56.833] result() for ClusterFuture ... done
[10:19:56.833] result() for ClusterFuture ...
[10:19:56.833] - result already collected: FutureResult
[10:19:56.833] result() for ClusterFuture ... done
[10:19:56.833] result() for ClusterFuture ...
[10:19:56.833] - result already collected: FutureResult
[10:19:56.833] result() for ClusterFuture ... done
[10:19:56.833] result() for ClusterFuture ...
[10:19:56.833] - result already collected: FutureResult
[10:19:56.833] result() for ClusterFuture ... done
[10:19:56.833] - relayed: [n=2] TRUE, FALSE
[10:19:56.833] - queued futures: [n=2] TRUE, FALSE
[10:19:56.834] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:56.834]  length: 1 (resolved future 1)
[10:19:56.859] receiveMessageFromWorker() for ClusterFuture ...
[10:19:56.859] - Validating connection of MultisessionFuture
[10:19:56.859] - received message: FutureResult
[10:19:56.860] - Received FutureResult
[10:19:56.860] - Erased future from FutureRegistry
[10:19:56.860] result() for ClusterFuture ...
[10:19:56.860] - result already collected: FutureResult
[10:19:56.860] result() for ClusterFuture ... done
[10:19:56.860] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:56.860] Future #2
[10:19:56.860] result() for ClusterFuture ...
[10:19:56.860] - result already collected: FutureResult
[10:19:56.860] result() for ClusterFuture ... done
[10:19:56.860] result() for ClusterFuture ...
[10:19:56.861] - result already collected: FutureResult
[10:19:56.861] result() for ClusterFuture ... done
[10:19:56.861] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:56.861] - nx: 2
[10:19:56.861] - relay: TRUE
[10:19:56.861] - stdout: TRUE
[10:19:56.861] - signal: TRUE
[10:19:56.861] - resignal: FALSE
[10:19:56.861] - force: TRUE
[10:19:56.861] - relayed: [n=2] TRUE, FALSE
[10:19:56.861] - queued futures: [n=2] TRUE, FALSE
[10:19:56.861]  - until=2
[10:19:56.862]  - relaying element #2
[10:19:56.862] result() for ClusterFuture ...
[10:19:56.862] - result already collected: FutureResult
[10:19:56.862] result() for ClusterFuture ... done
[10:19:56.862] result() for ClusterFuture ...
[10:19:56.862] - result already collected: FutureResult
[10:19:56.862] result() for ClusterFuture ... done
[10:19:56.862] result() for ClusterFuture ...
[10:19:56.862] - result already collected: FutureResult
[10:19:56.862] result() for ClusterFuture ... done
[10:19:56.862] result() for ClusterFuture ...
[10:19:56.862] - result already collected: FutureResult
[10:19:56.863] result() for ClusterFuture ... done
[10:19:56.863] - relayed: [n=2] TRUE, TRUE
[10:19:56.863] - queued futures: [n=2] TRUE, TRUE
[10:19:56.863] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:56.863]  length: 0 (resolved future 2)
[10:19:56.863] Relaying remaining futures
[10:19:56.863] signalConditionsASAP(NULL, pos=0) ...
[10:19:56.863] - nx: 2
[10:19:56.863] - relay: TRUE
[10:19:56.863] - stdout: TRUE
[10:19:56.863] - signal: TRUE
[10:19:56.863] - resignal: FALSE
[10:19:56.863] - force: TRUE
[10:19:56.864] - relayed: [n=2] TRUE, TRUE
[10:19:56.864] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:56.864] - relayed: [n=2] TRUE, TRUE
[10:19:56.864] - queued futures: [n=2] TRUE, TRUE
[10:19:56.864] signalConditionsASAP(NULL, pos=0) ... done
[10:19:56.864] resolve() on list ... DONE
[10:19:56.864] result() for ClusterFuture ...
[10:19:56.864] - result already collected: FutureResult
[10:19:56.864] result() for ClusterFuture ... done
[10:19:56.864] result() for ClusterFuture ...
[10:19:56.864] - result already collected: FutureResult
[10:19:56.865] result() for ClusterFuture ... done
[10:19:56.865] result() for ClusterFuture ...
[10:19:56.865] - result already collected: FutureResult
[10:19:56.865] result() for ClusterFuture ... done
[10:19:56.865] result() for ClusterFuture ...
[10:19:56.865] - result already collected: FutureResult
[10:19:56.865] result() for ClusterFuture ... done
[10:19:56.865]  - Number of value chunks collected: 2
[10:19:56.865] Resolving 2 futures (chunks) ... DONE
[10:19:56.865] Reducing values from 2 chunks ...
[10:19:56.865]  - Number of values collected after concatenation: 10
[10:19:56.865]  - Number of values expected: 10
[10:19:56.866] Reducing values from 2 chunks ... DONE
[10:19:56.866] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:19:56.867] future_lapply() ...
[10:19:56.870] Number of chunks: 2
[10:19:56.870] getGlobalsAndPackagesXApply() ...
[10:19:56.870]  - future.globals: TRUE
[10:19:56.870] getGlobalsAndPackages() ...
[10:19:56.870] Searching for globals...
[10:19:56.873] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:19:56.874] Searching for globals ... DONE
[10:19:56.874] Resolving globals: FALSE
[10:19:56.875] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[10:19:56.875] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:56.875] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:56.875] - packages: [1] ‘future.apply’
[10:19:56.875] getGlobalsAndPackages() ... DONE
[10:19:56.875]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:56.875]  - needed namespaces: [n=1] ‘future.apply’
[10:19:56.876] Finding globals ... DONE
[10:19:56.876]  - use_args: TRUE
[10:19:56.876]  - Getting '...' globals ...
[10:19:56.876] resolve() on list ...
[10:19:56.876]  recursive: 0
[10:19:56.876]  length: 1
[10:19:56.876]  elements: ‘...’
[10:19:56.876]  length: 0 (resolved future 1)
[10:19:56.877] resolve() on list ... DONE
[10:19:56.877]    - '...' content: [n=0] 
[10:19:56.877] List of 1
[10:19:56.877]  $ ...: list()
[10:19:56.877]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:56.877]  - attr(*, "where")=List of 1
[10:19:56.877]   ..$ ...:<environment: 0x55c6a1da8028> 
[10:19:56.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:56.877]  - attr(*, "resolved")= logi TRUE
[10:19:56.877]  - attr(*, "total_size")= num NA
[10:19:56.879]  - Getting '...' globals ... DONE
[10:19:56.879] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:56.879] List of 8
[10:19:56.879]  $ ...future.FUN:function (x, ...)  
[10:19:56.879]  $ x_FUN        :function (x)  
[10:19:56.879]  $ times        : int 4
[10:19:56.879]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:56.879]  $ stop_if_not  :function (...)  
[10:19:56.879]  $ dim          : int [1:2] 2 2
[10:19:56.879]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:56.879]  $ ...          : list()
[10:19:56.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:56.879]  - attr(*, "where")=List of 8
[10:19:56.879]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:56.879]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:56.879]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:56.879]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:56.879]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:56.879]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:56.879]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:56.879]   ..$ ...          :<environment: 0x55c6a1da8028> 
[10:19:56.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:56.879]  - attr(*, "resolved")= logi FALSE
[10:19:56.879]  - attr(*, "total_size")= num 24958
[10:19:56.884] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:56.885] getGlobalsAndPackagesXApply() ... DONE
[10:19:56.885] Number of futures (= number of chunks): 2
[10:19:56.885] Launching 2 futures (chunks) ...
[10:19:56.885] Chunk #1 of 2 ...
[10:19:56.885]  - Finding globals in 'X' for chunk #1 ...
[10:19:56.885] getGlobalsAndPackages() ...
[10:19:56.885] Searching for globals...
[10:19:56.885] 
[10:19:56.886] Searching for globals ... DONE
[10:19:56.886] - globals: [0] <none>
[10:19:56.886] getGlobalsAndPackages() ... DONE
[10:19:56.886]    + additional globals found: [n=0] 
[10:19:56.886]    + additional namespaces needed: [n=0] 
[10:19:56.886]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:56.886]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:56.886]  - seeds: <none>
[10:19:56.886]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.886] getGlobalsAndPackages() ...
[10:19:56.886] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.887] Resolving globals: FALSE
[10:19:56.887] Tweak future expression to call with '...' arguments ...
[10:19:56.887] {
[10:19:56.887]     do.call(function(...) {
[10:19:56.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:56.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.887]             on.exit(options(oopts), add = TRUE)
[10:19:56.887]         }
[10:19:56.887]         {
[10:19:56.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:56.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.887]                 ...future.FUN(...future.X_jj, ...)
[10:19:56.887]             })
[10:19:56.887]         }
[10:19:56.887]     }, args = future.call.arguments)
[10:19:56.887] }
[10:19:56.887] Tweak future expression to call with '...' arguments ... DONE
[10:19:56.888] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:56.888] - packages: [1] ‘future.apply’
[10:19:56.888] getGlobalsAndPackages() ... DONE
[10:19:56.888] run() for ‘Future’ ...
[10:19:56.888] - state: ‘created’
[10:19:56.888] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:56.902] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:56.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:56.902]   - Field: ‘node’
[10:19:56.902]   - Field: ‘label’
[10:19:56.903]   - Field: ‘local’
[10:19:56.903]   - Field: ‘owner’
[10:19:56.903]   - Field: ‘envir’
[10:19:56.903]   - Field: ‘workers’
[10:19:56.903]   - Field: ‘packages’
[10:19:56.903]   - Field: ‘gc’
[10:19:56.903]   - Field: ‘conditions’
[10:19:56.903]   - Field: ‘persistent’
[10:19:56.903]   - Field: ‘expr’
[10:19:56.903]   - Field: ‘uuid’
[10:19:56.903]   - Field: ‘seed’
[10:19:56.903]   - Field: ‘version’
[10:19:56.904]   - Field: ‘result’
[10:19:56.904]   - Field: ‘asynchronous’
[10:19:56.904]   - Field: ‘calls’
[10:19:56.904]   - Field: ‘globals’
[10:19:56.904]   - Field: ‘stdout’
[10:19:56.904]   - Field: ‘earlySignal’
[10:19:56.904]   - Field: ‘lazy’
[10:19:56.904]   - Field: ‘state’
[10:19:56.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:56.904] - Launch lazy future ...
[10:19:56.905] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:56.905] Packages needed by future strategies (n = 0): <none>
[10:19:56.905] {
[10:19:56.905]     {
[10:19:56.905]         {
[10:19:56.905]             ...future.startTime <- base::Sys.time()
[10:19:56.905]             {
[10:19:56.905]                 {
[10:19:56.905]                   {
[10:19:56.905]                     {
[10:19:56.905]                       {
[10:19:56.905]                         base::local({
[10:19:56.905]                           has_future <- base::requireNamespace("future", 
[10:19:56.905]                             quietly = TRUE)
[10:19:56.905]                           if (has_future) {
[10:19:56.905]                             ns <- base::getNamespace("future")
[10:19:56.905]                             version <- ns[[".package"]][["version"]]
[10:19:56.905]                             if (is.null(version)) 
[10:19:56.905]                               version <- utils::packageVersion("future")
[10:19:56.905]                           }
[10:19:56.905]                           else {
[10:19:56.905]                             version <- NULL
[10:19:56.905]                           }
[10:19:56.905]                           if (!has_future || version < "1.8.0") {
[10:19:56.905]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:56.905]                               "", base::R.version$version.string), 
[10:19:56.905]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:56.905]                                 base::R.version$platform, 8 * 
[10:19:56.905]                                   base::.Machine$sizeof.pointer), 
[10:19:56.905]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:56.905]                                 "release", "version")], collapse = " "), 
[10:19:56.905]                               hostname = base::Sys.info()[["nodename"]])
[10:19:56.905]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:56.905]                               info)
[10:19:56.905]                             info <- base::paste(info, collapse = "; ")
[10:19:56.905]                             if (!has_future) {
[10:19:56.905]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:56.905]                                 info)
[10:19:56.905]                             }
[10:19:56.905]                             else {
[10:19:56.905]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:56.905]                                 info, version)
[10:19:56.905]                             }
[10:19:56.905]                             base::stop(msg)
[10:19:56.905]                           }
[10:19:56.905]                         })
[10:19:56.905]                       }
[10:19:56.905]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:56.905]                       base::options(mc.cores = 1L)
[10:19:56.905]                     }
[10:19:56.905]                     base::local({
[10:19:56.905]                       for (pkg in "future.apply") {
[10:19:56.905]                         base::loadNamespace(pkg)
[10:19:56.905]                         base::library(pkg, character.only = TRUE)
[10:19:56.905]                       }
[10:19:56.905]                     })
[10:19:56.905]                   }
[10:19:56.905]                   ...future.strategy.old <- future::plan("list")
[10:19:56.905]                   options(future.plan = NULL)
[10:19:56.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:56.905]                 }
[10:19:56.905]                 ...future.workdir <- getwd()
[10:19:56.905]             }
[10:19:56.905]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:56.905]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:56.905]         }
[10:19:56.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:56.905]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:56.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:56.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:56.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:56.905]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:56.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:56.905]             base::names(...future.oldOptions))
[10:19:56.905]     }
[10:19:56.905]     if (FALSE) {
[10:19:56.905]     }
[10:19:56.905]     else {
[10:19:56.905]         if (TRUE) {
[10:19:56.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:56.905]                 open = "w")
[10:19:56.905]         }
[10:19:56.905]         else {
[10:19:56.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:56.905]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:56.905]         }
[10:19:56.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:56.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:56.905]             base::sink(type = "output", split = FALSE)
[10:19:56.905]             base::close(...future.stdout)
[10:19:56.905]         }, add = TRUE)
[10:19:56.905]     }
[10:19:56.905]     ...future.frame <- base::sys.nframe()
[10:19:56.905]     ...future.conditions <- base::list()
[10:19:56.905]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:56.905]     if (FALSE) {
[10:19:56.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:56.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:56.905]     }
[10:19:56.905]     ...future.result <- base::tryCatch({
[10:19:56.905]         base::withCallingHandlers({
[10:19:56.905]             ...future.value <- base::withVisible(base::local({
[10:19:56.905]                 ...future.makeSendCondition <- base::local({
[10:19:56.905]                   sendCondition <- NULL
[10:19:56.905]                   function(frame = 1L) {
[10:19:56.905]                     if (is.function(sendCondition)) 
[10:19:56.905]                       return(sendCondition)
[10:19:56.905]                     ns <- getNamespace("parallel")
[10:19:56.905]                     if (exists("sendData", mode = "function", 
[10:19:56.905]                       envir = ns)) {
[10:19:56.905]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:56.905]                         envir = ns)
[10:19:56.905]                       envir <- sys.frame(frame)
[10:19:56.905]                       master <- NULL
[10:19:56.905]                       while (!identical(envir, .GlobalEnv) && 
[10:19:56.905]                         !identical(envir, emptyenv())) {
[10:19:56.905]                         if (exists("master", mode = "list", envir = envir, 
[10:19:56.905]                           inherits = FALSE)) {
[10:19:56.905]                           master <- get("master", mode = "list", 
[10:19:56.905]                             envir = envir, inherits = FALSE)
[10:19:56.905]                           if (inherits(master, c("SOCKnode", 
[10:19:56.905]                             "SOCK0node"))) {
[10:19:56.905]                             sendCondition <<- function(cond) {
[10:19:56.905]                               data <- list(type = "VALUE", value = cond, 
[10:19:56.905]                                 success = TRUE)
[10:19:56.905]                               parallel_sendData(master, data)
[10:19:56.905]                             }
[10:19:56.905]                             return(sendCondition)
[10:19:56.905]                           }
[10:19:56.905]                         }
[10:19:56.905]                         frame <- frame + 1L
[10:19:56.905]                         envir <- sys.frame(frame)
[10:19:56.905]                       }
[10:19:56.905]                     }
[10:19:56.905]                     sendCondition <<- function(cond) NULL
[10:19:56.905]                   }
[10:19:56.905]                 })
[10:19:56.905]                 withCallingHandlers({
[10:19:56.905]                   {
[10:19:56.905]                     do.call(function(...) {
[10:19:56.905]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:56.905]                       if (!identical(...future.globals.maxSize.org, 
[10:19:56.905]                         ...future.globals.maxSize)) {
[10:19:56.905]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:56.905]                         on.exit(options(oopts), add = TRUE)
[10:19:56.905]                       }
[10:19:56.905]                       {
[10:19:56.905]                         lapply(seq_along(...future.elements_ii), 
[10:19:56.905]                           FUN = function(jj) {
[10:19:56.905]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:56.905]                             ...future.FUN(...future.X_jj, ...)
[10:19:56.905]                           })
[10:19:56.905]                       }
[10:19:56.905]                     }, args = future.call.arguments)
[10:19:56.905]                   }
[10:19:56.905]                 }, immediateCondition = function(cond) {
[10:19:56.905]                   sendCondition <- ...future.makeSendCondition()
[10:19:56.905]                   sendCondition(cond)
[10:19:56.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.905]                   {
[10:19:56.905]                     inherits <- base::inherits
[10:19:56.905]                     invokeRestart <- base::invokeRestart
[10:19:56.905]                     is.null <- base::is.null
[10:19:56.905]                     muffled <- FALSE
[10:19:56.905]                     if (inherits(cond, "message")) {
[10:19:56.905]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:56.905]                       if (muffled) 
[10:19:56.905]                         invokeRestart("muffleMessage")
[10:19:56.905]                     }
[10:19:56.905]                     else if (inherits(cond, "warning")) {
[10:19:56.905]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:56.905]                       if (muffled) 
[10:19:56.905]                         invokeRestart("muffleWarning")
[10:19:56.905]                     }
[10:19:56.905]                     else if (inherits(cond, "condition")) {
[10:19:56.905]                       if (!is.null(pattern)) {
[10:19:56.905]                         computeRestarts <- base::computeRestarts
[10:19:56.905]                         grepl <- base::grepl
[10:19:56.905]                         restarts <- computeRestarts(cond)
[10:19:56.905]                         for (restart in restarts) {
[10:19:56.905]                           name <- restart$name
[10:19:56.905]                           if (is.null(name)) 
[10:19:56.905]                             next
[10:19:56.905]                           if (!grepl(pattern, name)) 
[10:19:56.905]                             next
[10:19:56.905]                           invokeRestart(restart)
[10:19:56.905]                           muffled <- TRUE
[10:19:56.905]                           break
[10:19:56.905]                         }
[10:19:56.905]                       }
[10:19:56.905]                     }
[10:19:56.905]                     invisible(muffled)
[10:19:56.905]                   }
[10:19:56.905]                   muffleCondition(cond)
[10:19:56.905]                 })
[10:19:56.905]             }))
[10:19:56.905]             future::FutureResult(value = ...future.value$value, 
[10:19:56.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.905]                   ...future.rng), globalenv = if (FALSE) 
[10:19:56.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:56.905]                     ...future.globalenv.names))
[10:19:56.905]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:56.905]         }, condition = base::local({
[10:19:56.905]             c <- base::c
[10:19:56.905]             inherits <- base::inherits
[10:19:56.905]             invokeRestart <- base::invokeRestart
[10:19:56.905]             length <- base::length
[10:19:56.905]             list <- base::list
[10:19:56.905]             seq.int <- base::seq.int
[10:19:56.905]             signalCondition <- base::signalCondition
[10:19:56.905]             sys.calls <- base::sys.calls
[10:19:56.905]             `[[` <- base::`[[`
[10:19:56.905]             `+` <- base::`+`
[10:19:56.905]             `<<-` <- base::`<<-`
[10:19:56.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:56.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:56.905]                   3L)]
[10:19:56.905]             }
[10:19:56.905]             function(cond) {
[10:19:56.905]                 is_error <- inherits(cond, "error")
[10:19:56.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:56.905]                   NULL)
[10:19:56.905]                 if (is_error) {
[10:19:56.905]                   sessionInformation <- function() {
[10:19:56.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:56.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:56.905]                       search = base::search(), system = base::Sys.info())
[10:19:56.905]                   }
[10:19:56.905]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:56.905]                     cond$call), session = sessionInformation(), 
[10:19:56.905]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:56.905]                   signalCondition(cond)
[10:19:56.905]                 }
[10:19:56.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:56.905]                 "immediateCondition"))) {
[10:19:56.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:56.905]                   ...future.conditions[[length(...future.conditions) + 
[10:19:56.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:56.905]                   if (TRUE && !signal) {
[10:19:56.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.905]                     {
[10:19:56.905]                       inherits <- base::inherits
[10:19:56.905]                       invokeRestart <- base::invokeRestart
[10:19:56.905]                       is.null <- base::is.null
[10:19:56.905]                       muffled <- FALSE
[10:19:56.905]                       if (inherits(cond, "message")) {
[10:19:56.905]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.905]                         if (muffled) 
[10:19:56.905]                           invokeRestart("muffleMessage")
[10:19:56.905]                       }
[10:19:56.905]                       else if (inherits(cond, "warning")) {
[10:19:56.905]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.905]                         if (muffled) 
[10:19:56.905]                           invokeRestart("muffleWarning")
[10:19:56.905]                       }
[10:19:56.905]                       else if (inherits(cond, "condition")) {
[10:19:56.905]                         if (!is.null(pattern)) {
[10:19:56.905]                           computeRestarts <- base::computeRestarts
[10:19:56.905]                           grepl <- base::grepl
[10:19:56.905]                           restarts <- computeRestarts(cond)
[10:19:56.905]                           for (restart in restarts) {
[10:19:56.905]                             name <- restart$name
[10:19:56.905]                             if (is.null(name)) 
[10:19:56.905]                               next
[10:19:56.905]                             if (!grepl(pattern, name)) 
[10:19:56.905]                               next
[10:19:56.905]                             invokeRestart(restart)
[10:19:56.905]                             muffled <- TRUE
[10:19:56.905]                             break
[10:19:56.905]                           }
[10:19:56.905]                         }
[10:19:56.905]                       }
[10:19:56.905]                       invisible(muffled)
[10:19:56.905]                     }
[10:19:56.905]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.905]                   }
[10:19:56.905]                 }
[10:19:56.905]                 else {
[10:19:56.905]                   if (TRUE) {
[10:19:56.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:56.905]                     {
[10:19:56.905]                       inherits <- base::inherits
[10:19:56.905]                       invokeRestart <- base::invokeRestart
[10:19:56.905]                       is.null <- base::is.null
[10:19:56.905]                       muffled <- FALSE
[10:19:56.905]                       if (inherits(cond, "message")) {
[10:19:56.905]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:56.905]                         if (muffled) 
[10:19:56.905]                           invokeRestart("muffleMessage")
[10:19:56.905]                       }
[10:19:56.905]                       else if (inherits(cond, "warning")) {
[10:19:56.905]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:56.905]                         if (muffled) 
[10:19:56.905]                           invokeRestart("muffleWarning")
[10:19:56.905]                       }
[10:19:56.905]                       else if (inherits(cond, "condition")) {
[10:19:56.905]                         if (!is.null(pattern)) {
[10:19:56.905]                           computeRestarts <- base::computeRestarts
[10:19:56.905]                           grepl <- base::grepl
[10:19:56.905]                           restarts <- computeRestarts(cond)
[10:19:56.905]                           for (restart in restarts) {
[10:19:56.905]                             name <- restart$name
[10:19:56.905]                             if (is.null(name)) 
[10:19:56.905]                               next
[10:19:56.905]                             if (!grepl(pattern, name)) 
[10:19:56.905]                               next
[10:19:56.905]                             invokeRestart(restart)
[10:19:56.905]                             muffled <- TRUE
[10:19:56.905]                             break
[10:19:56.905]                           }
[10:19:56.905]                         }
[10:19:56.905]                       }
[10:19:56.905]                       invisible(muffled)
[10:19:56.905]                     }
[10:19:56.905]                     muffleCondition(cond, pattern = "^muffle")
[10:19:56.905]                   }
[10:19:56.905]                 }
[10:19:56.905]             }
[10:19:56.905]         }))
[10:19:56.905]     }, error = function(ex) {
[10:19:56.905]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:56.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:56.905]                 ...future.rng), started = ...future.startTime, 
[10:19:56.905]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:56.905]             version = "1.8"), class = "FutureResult")
[10:19:56.905]     }, finally = {
[10:19:56.905]         if (!identical(...future.workdir, getwd())) 
[10:19:56.905]             setwd(...future.workdir)
[10:19:56.905]         {
[10:19:56.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:56.905]                 ...future.oldOptions$nwarnings <- NULL
[10:19:56.905]             }
[10:19:56.905]             base::options(...future.oldOptions)
[10:19:56.905]             if (.Platform$OS.type == "windows") {
[10:19:56.905]                 old_names <- names(...future.oldEnvVars)
[10:19:56.905]                 envs <- base::Sys.getenv()
[10:19:56.905]                 names <- names(envs)
[10:19:56.905]                 common <- intersect(names, old_names)
[10:19:56.905]                 added <- setdiff(names, old_names)
[10:19:56.905]                 removed <- setdiff(old_names, names)
[10:19:56.905]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:56.905]                   envs[common]]
[10:19:56.905]                 NAMES <- toupper(changed)
[10:19:56.905]                 args <- list()
[10:19:56.905]                 for (kk in seq_along(NAMES)) {
[10:19:56.905]                   name <- changed[[kk]]
[10:19:56.905]                   NAME <- NAMES[[kk]]
[10:19:56.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.905]                     next
[10:19:56.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.905]                 }
[10:19:56.905]                 NAMES <- toupper(added)
[10:19:56.905]                 for (kk in seq_along(NAMES)) {
[10:19:56.905]                   name <- added[[kk]]
[10:19:56.905]                   NAME <- NAMES[[kk]]
[10:19:56.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.905]                     next
[10:19:56.905]                   args[[name]] <- ""
[10:19:56.905]                 }
[10:19:56.905]                 NAMES <- toupper(removed)
[10:19:56.905]                 for (kk in seq_along(NAMES)) {
[10:19:56.905]                   name <- removed[[kk]]
[10:19:56.905]                   NAME <- NAMES[[kk]]
[10:19:56.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:56.905]                     next
[10:19:56.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:56.905]                 }
[10:19:56.905]                 if (length(args) > 0) 
[10:19:56.905]                   base::do.call(base::Sys.setenv, args = args)
[10:19:56.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:56.905]             }
[10:19:56.905]             else {
[10:19:56.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:56.905]             }
[10:19:56.905]             {
[10:19:56.905]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:56.905]                   0L) {
[10:19:56.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:56.905]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:56.905]                   base::options(opts)
[10:19:56.905]                 }
[10:19:56.905]                 {
[10:19:56.905]                   {
[10:19:56.905]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:56.905]                     NULL
[10:19:56.905]                   }
[10:19:56.905]                   options(future.plan = NULL)
[10:19:56.905]                   if (is.na(NA_character_)) 
[10:19:56.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:56.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:56.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:56.905]                     .init = FALSE)
[10:19:56.905]                 }
[10:19:56.905]             }
[10:19:56.905]         }
[10:19:56.905]     })
[10:19:56.905]     if (TRUE) {
[10:19:56.905]         base::sink(type = "output", split = FALSE)
[10:19:56.905]         if (TRUE) {
[10:19:56.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:56.905]         }
[10:19:56.905]         else {
[10:19:56.905]             ...future.result["stdout"] <- base::list(NULL)
[10:19:56.905]         }
[10:19:56.905]         base::close(...future.stdout)
[10:19:56.905]         ...future.stdout <- NULL
[10:19:56.905]     }
[10:19:56.905]     ...future.result$conditions <- ...future.conditions
[10:19:56.905]     ...future.result$finished <- base::Sys.time()
[10:19:56.905]     ...future.result
[10:19:56.905] }
[10:19:56.908] Exporting 11 global objects (14.06 KiB) to cluster node #1 ...
[10:19:56.908] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #1 ...
[10:19:56.951] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #1 ... DONE
[10:19:56.952] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ...
[10:19:56.952] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ... DONE
[10:19:56.952] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:56.953] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:56.953] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:56.993] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:56.994] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:57.034] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:57.035] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[10:19:57.035] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[10:19:57.035] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:57.036] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:57.036] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:57.036] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:57.036] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[10:19:57.037] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[10:19:57.037] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:57.037] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:57.037] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:57.038] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:57.038] Exporting 11 global objects (14.06 KiB) to cluster node #1 ... DONE
[10:19:57.038] MultisessionFuture started
[10:19:57.038] - Launch lazy future ... done
[10:19:57.038] run() for ‘MultisessionFuture’ ... done
[10:19:57.038] Created future:
[10:19:57.038] MultisessionFuture:
[10:19:57.038] Label: ‘future_vapply-1’
[10:19:57.038] Expression:
[10:19:57.038] {
[10:19:57.038]     do.call(function(...) {
[10:19:57.038]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.038]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.038]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.038]             on.exit(options(oopts), add = TRUE)
[10:19:57.038]         }
[10:19:57.038]         {
[10:19:57.038]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.038]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.038]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.038]             })
[10:19:57.038]         }
[10:19:57.038]     }, args = future.call.arguments)
[10:19:57.038] }
[10:19:57.038] Lazy evaluation: FALSE
[10:19:57.038] Asynchronous evaluation: TRUE
[10:19:57.038] Local evaluation: TRUE
[10:19:57.038] Environment: R_GlobalEnv
[10:19:57.038] Capture standard output: TRUE
[10:19:57.038] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:57.038] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:57.038] Packages: 1 packages (‘future.apply’)
[10:19:57.038] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:57.038] Resolved: FALSE
[10:19:57.038] Value: <not collected>
[10:19:57.038] Conditions captured: <none>
[10:19:57.038] Early signaling: FALSE
[10:19:57.038] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:57.038] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.050] Chunk #1 of 2 ... DONE
[10:19:57.050] Chunk #2 of 2 ...
[10:19:57.050]  - Finding globals in 'X' for chunk #2 ...
[10:19:57.050] getGlobalsAndPackages() ...
[10:19:57.050] Searching for globals...
[10:19:57.051] 
[10:19:57.051] Searching for globals ... DONE
[10:19:57.051] - globals: [0] <none>
[10:19:57.051] getGlobalsAndPackages() ... DONE
[10:19:57.051]    + additional globals found: [n=0] 
[10:19:57.051]    + additional namespaces needed: [n=0] 
[10:19:57.051]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:57.051]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:57.051]  - seeds: <none>
[10:19:57.051]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.051] getGlobalsAndPackages() ...
[10:19:57.052] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.052] Resolving globals: FALSE
[10:19:57.052] Tweak future expression to call with '...' arguments ...
[10:19:57.052] {
[10:19:57.052]     do.call(function(...) {
[10:19:57.052]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.052]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.052]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.052]             on.exit(options(oopts), add = TRUE)
[10:19:57.052]         }
[10:19:57.052]         {
[10:19:57.052]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.052]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.052]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.052]             })
[10:19:57.052]         }
[10:19:57.052]     }, args = future.call.arguments)
[10:19:57.052] }
[10:19:57.052] Tweak future expression to call with '...' arguments ... DONE
[10:19:57.053] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.053] - packages: [1] ‘future.apply’
[10:19:57.053] getGlobalsAndPackages() ... DONE
[10:19:57.053] run() for ‘Future’ ...
[10:19:57.053] - state: ‘created’
[10:19:57.053] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:57.067] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:57.067]   - Field: ‘node’
[10:19:57.067]   - Field: ‘label’
[10:19:57.067]   - Field: ‘local’
[10:19:57.067]   - Field: ‘owner’
[10:19:57.068]   - Field: ‘envir’
[10:19:57.068]   - Field: ‘workers’
[10:19:57.068]   - Field: ‘packages’
[10:19:57.068]   - Field: ‘gc’
[10:19:57.068]   - Field: ‘conditions’
[10:19:57.068]   - Field: ‘persistent’
[10:19:57.068]   - Field: ‘expr’
[10:19:57.068]   - Field: ‘uuid’
[10:19:57.068]   - Field: ‘seed’
[10:19:57.068]   - Field: ‘version’
[10:19:57.068]   - Field: ‘result’
[10:19:57.069]   - Field: ‘asynchronous’
[10:19:57.069]   - Field: ‘calls’
[10:19:57.069]   - Field: ‘globals’
[10:19:57.069]   - Field: ‘stdout’
[10:19:57.069]   - Field: ‘earlySignal’
[10:19:57.069]   - Field: ‘lazy’
[10:19:57.069]   - Field: ‘state’
[10:19:57.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:57.069] - Launch lazy future ...
[10:19:57.070] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:57.070] Packages needed by future strategies (n = 0): <none>
[10:19:57.070] {
[10:19:57.070]     {
[10:19:57.070]         {
[10:19:57.070]             ...future.startTime <- base::Sys.time()
[10:19:57.070]             {
[10:19:57.070]                 {
[10:19:57.070]                   {
[10:19:57.070]                     {
[10:19:57.070]                       {
[10:19:57.070]                         base::local({
[10:19:57.070]                           has_future <- base::requireNamespace("future", 
[10:19:57.070]                             quietly = TRUE)
[10:19:57.070]                           if (has_future) {
[10:19:57.070]                             ns <- base::getNamespace("future")
[10:19:57.070]                             version <- ns[[".package"]][["version"]]
[10:19:57.070]                             if (is.null(version)) 
[10:19:57.070]                               version <- utils::packageVersion("future")
[10:19:57.070]                           }
[10:19:57.070]                           else {
[10:19:57.070]                             version <- NULL
[10:19:57.070]                           }
[10:19:57.070]                           if (!has_future || version < "1.8.0") {
[10:19:57.070]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:57.070]                               "", base::R.version$version.string), 
[10:19:57.070]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:57.070]                                 base::R.version$platform, 8 * 
[10:19:57.070]                                   base::.Machine$sizeof.pointer), 
[10:19:57.070]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:57.070]                                 "release", "version")], collapse = " "), 
[10:19:57.070]                               hostname = base::Sys.info()[["nodename"]])
[10:19:57.070]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:57.070]                               info)
[10:19:57.070]                             info <- base::paste(info, collapse = "; ")
[10:19:57.070]                             if (!has_future) {
[10:19:57.070]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:57.070]                                 info)
[10:19:57.070]                             }
[10:19:57.070]                             else {
[10:19:57.070]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:57.070]                                 info, version)
[10:19:57.070]                             }
[10:19:57.070]                             base::stop(msg)
[10:19:57.070]                           }
[10:19:57.070]                         })
[10:19:57.070]                       }
[10:19:57.070]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:57.070]                       base::options(mc.cores = 1L)
[10:19:57.070]                     }
[10:19:57.070]                     base::local({
[10:19:57.070]                       for (pkg in "future.apply") {
[10:19:57.070]                         base::loadNamespace(pkg)
[10:19:57.070]                         base::library(pkg, character.only = TRUE)
[10:19:57.070]                       }
[10:19:57.070]                     })
[10:19:57.070]                   }
[10:19:57.070]                   ...future.strategy.old <- future::plan("list")
[10:19:57.070]                   options(future.plan = NULL)
[10:19:57.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:57.070]                 }
[10:19:57.070]                 ...future.workdir <- getwd()
[10:19:57.070]             }
[10:19:57.070]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:57.070]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:57.070]         }
[10:19:57.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:57.070]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:57.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:57.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:57.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:57.070]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:57.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:57.070]             base::names(...future.oldOptions))
[10:19:57.070]     }
[10:19:57.070]     if (FALSE) {
[10:19:57.070]     }
[10:19:57.070]     else {
[10:19:57.070]         if (TRUE) {
[10:19:57.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:57.070]                 open = "w")
[10:19:57.070]         }
[10:19:57.070]         else {
[10:19:57.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:57.070]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:57.070]         }
[10:19:57.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:57.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:57.070]             base::sink(type = "output", split = FALSE)
[10:19:57.070]             base::close(...future.stdout)
[10:19:57.070]         }, add = TRUE)
[10:19:57.070]     }
[10:19:57.070]     ...future.frame <- base::sys.nframe()
[10:19:57.070]     ...future.conditions <- base::list()
[10:19:57.070]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:57.070]     if (FALSE) {
[10:19:57.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:57.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:57.070]     }
[10:19:57.070]     ...future.result <- base::tryCatch({
[10:19:57.070]         base::withCallingHandlers({
[10:19:57.070]             ...future.value <- base::withVisible(base::local({
[10:19:57.070]                 ...future.makeSendCondition <- base::local({
[10:19:57.070]                   sendCondition <- NULL
[10:19:57.070]                   function(frame = 1L) {
[10:19:57.070]                     if (is.function(sendCondition)) 
[10:19:57.070]                       return(sendCondition)
[10:19:57.070]                     ns <- getNamespace("parallel")
[10:19:57.070]                     if (exists("sendData", mode = "function", 
[10:19:57.070]                       envir = ns)) {
[10:19:57.070]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:57.070]                         envir = ns)
[10:19:57.070]                       envir <- sys.frame(frame)
[10:19:57.070]                       master <- NULL
[10:19:57.070]                       while (!identical(envir, .GlobalEnv) && 
[10:19:57.070]                         !identical(envir, emptyenv())) {
[10:19:57.070]                         if (exists("master", mode = "list", envir = envir, 
[10:19:57.070]                           inherits = FALSE)) {
[10:19:57.070]                           master <- get("master", mode = "list", 
[10:19:57.070]                             envir = envir, inherits = FALSE)
[10:19:57.070]                           if (inherits(master, c("SOCKnode", 
[10:19:57.070]                             "SOCK0node"))) {
[10:19:57.070]                             sendCondition <<- function(cond) {
[10:19:57.070]                               data <- list(type = "VALUE", value = cond, 
[10:19:57.070]                                 success = TRUE)
[10:19:57.070]                               parallel_sendData(master, data)
[10:19:57.070]                             }
[10:19:57.070]                             return(sendCondition)
[10:19:57.070]                           }
[10:19:57.070]                         }
[10:19:57.070]                         frame <- frame + 1L
[10:19:57.070]                         envir <- sys.frame(frame)
[10:19:57.070]                       }
[10:19:57.070]                     }
[10:19:57.070]                     sendCondition <<- function(cond) NULL
[10:19:57.070]                   }
[10:19:57.070]                 })
[10:19:57.070]                 withCallingHandlers({
[10:19:57.070]                   {
[10:19:57.070]                     do.call(function(...) {
[10:19:57.070]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.070]                       if (!identical(...future.globals.maxSize.org, 
[10:19:57.070]                         ...future.globals.maxSize)) {
[10:19:57.070]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.070]                         on.exit(options(oopts), add = TRUE)
[10:19:57.070]                       }
[10:19:57.070]                       {
[10:19:57.070]                         lapply(seq_along(...future.elements_ii), 
[10:19:57.070]                           FUN = function(jj) {
[10:19:57.070]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.070]                             ...future.FUN(...future.X_jj, ...)
[10:19:57.070]                           })
[10:19:57.070]                       }
[10:19:57.070]                     }, args = future.call.arguments)
[10:19:57.070]                   }
[10:19:57.070]                 }, immediateCondition = function(cond) {
[10:19:57.070]                   sendCondition <- ...future.makeSendCondition()
[10:19:57.070]                   sendCondition(cond)
[10:19:57.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.070]                   {
[10:19:57.070]                     inherits <- base::inherits
[10:19:57.070]                     invokeRestart <- base::invokeRestart
[10:19:57.070]                     is.null <- base::is.null
[10:19:57.070]                     muffled <- FALSE
[10:19:57.070]                     if (inherits(cond, "message")) {
[10:19:57.070]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:57.070]                       if (muffled) 
[10:19:57.070]                         invokeRestart("muffleMessage")
[10:19:57.070]                     }
[10:19:57.070]                     else if (inherits(cond, "warning")) {
[10:19:57.070]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:57.070]                       if (muffled) 
[10:19:57.070]                         invokeRestart("muffleWarning")
[10:19:57.070]                     }
[10:19:57.070]                     else if (inherits(cond, "condition")) {
[10:19:57.070]                       if (!is.null(pattern)) {
[10:19:57.070]                         computeRestarts <- base::computeRestarts
[10:19:57.070]                         grepl <- base::grepl
[10:19:57.070]                         restarts <- computeRestarts(cond)
[10:19:57.070]                         for (restart in restarts) {
[10:19:57.070]                           name <- restart$name
[10:19:57.070]                           if (is.null(name)) 
[10:19:57.070]                             next
[10:19:57.070]                           if (!grepl(pattern, name)) 
[10:19:57.070]                             next
[10:19:57.070]                           invokeRestart(restart)
[10:19:57.070]                           muffled <- TRUE
[10:19:57.070]                           break
[10:19:57.070]                         }
[10:19:57.070]                       }
[10:19:57.070]                     }
[10:19:57.070]                     invisible(muffled)
[10:19:57.070]                   }
[10:19:57.070]                   muffleCondition(cond)
[10:19:57.070]                 })
[10:19:57.070]             }))
[10:19:57.070]             future::FutureResult(value = ...future.value$value, 
[10:19:57.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.070]                   ...future.rng), globalenv = if (FALSE) 
[10:19:57.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:57.070]                     ...future.globalenv.names))
[10:19:57.070]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:57.070]         }, condition = base::local({
[10:19:57.070]             c <- base::c
[10:19:57.070]             inherits <- base::inherits
[10:19:57.070]             invokeRestart <- base::invokeRestart
[10:19:57.070]             length <- base::length
[10:19:57.070]             list <- base::list
[10:19:57.070]             seq.int <- base::seq.int
[10:19:57.070]             signalCondition <- base::signalCondition
[10:19:57.070]             sys.calls <- base::sys.calls
[10:19:57.070]             `[[` <- base::`[[`
[10:19:57.070]             `+` <- base::`+`
[10:19:57.070]             `<<-` <- base::`<<-`
[10:19:57.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:57.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:57.070]                   3L)]
[10:19:57.070]             }
[10:19:57.070]             function(cond) {
[10:19:57.070]                 is_error <- inherits(cond, "error")
[10:19:57.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:57.070]                   NULL)
[10:19:57.070]                 if (is_error) {
[10:19:57.070]                   sessionInformation <- function() {
[10:19:57.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:57.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:57.070]                       search = base::search(), system = base::Sys.info())
[10:19:57.070]                   }
[10:19:57.070]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:57.070]                     cond$call), session = sessionInformation(), 
[10:19:57.070]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:57.070]                   signalCondition(cond)
[10:19:57.070]                 }
[10:19:57.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:57.070]                 "immediateCondition"))) {
[10:19:57.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:57.070]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:57.070]                   if (TRUE && !signal) {
[10:19:57.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.070]                     {
[10:19:57.070]                       inherits <- base::inherits
[10:19:57.070]                       invokeRestart <- base::invokeRestart
[10:19:57.070]                       is.null <- base::is.null
[10:19:57.070]                       muffled <- FALSE
[10:19:57.070]                       if (inherits(cond, "message")) {
[10:19:57.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.070]                         if (muffled) 
[10:19:57.070]                           invokeRestart("muffleMessage")
[10:19:57.070]                       }
[10:19:57.070]                       else if (inherits(cond, "warning")) {
[10:19:57.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.070]                         if (muffled) 
[10:19:57.070]                           invokeRestart("muffleWarning")
[10:19:57.070]                       }
[10:19:57.070]                       else if (inherits(cond, "condition")) {
[10:19:57.070]                         if (!is.null(pattern)) {
[10:19:57.070]                           computeRestarts <- base::computeRestarts
[10:19:57.070]                           grepl <- base::grepl
[10:19:57.070]                           restarts <- computeRestarts(cond)
[10:19:57.070]                           for (restart in restarts) {
[10:19:57.070]                             name <- restart$name
[10:19:57.070]                             if (is.null(name)) 
[10:19:57.070]                               next
[10:19:57.070]                             if (!grepl(pattern, name)) 
[10:19:57.070]                               next
[10:19:57.070]                             invokeRestart(restart)
[10:19:57.070]                             muffled <- TRUE
[10:19:57.070]                             break
[10:19:57.070]                           }
[10:19:57.070]                         }
[10:19:57.070]                       }
[10:19:57.070]                       invisible(muffled)
[10:19:57.070]                     }
[10:19:57.070]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.070]                   }
[10:19:57.070]                 }
[10:19:57.070]                 else {
[10:19:57.070]                   if (TRUE) {
[10:19:57.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.070]                     {
[10:19:57.070]                       inherits <- base::inherits
[10:19:57.070]                       invokeRestart <- base::invokeRestart
[10:19:57.070]                       is.null <- base::is.null
[10:19:57.070]                       muffled <- FALSE
[10:19:57.070]                       if (inherits(cond, "message")) {
[10:19:57.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.070]                         if (muffled) 
[10:19:57.070]                           invokeRestart("muffleMessage")
[10:19:57.070]                       }
[10:19:57.070]                       else if (inherits(cond, "warning")) {
[10:19:57.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.070]                         if (muffled) 
[10:19:57.070]                           invokeRestart("muffleWarning")
[10:19:57.070]                       }
[10:19:57.070]                       else if (inherits(cond, "condition")) {
[10:19:57.070]                         if (!is.null(pattern)) {
[10:19:57.070]                           computeRestarts <- base::computeRestarts
[10:19:57.070]                           grepl <- base::grepl
[10:19:57.070]                           restarts <- computeRestarts(cond)
[10:19:57.070]                           for (restart in restarts) {
[10:19:57.070]                             name <- restart$name
[10:19:57.070]                             if (is.null(name)) 
[10:19:57.070]                               next
[10:19:57.070]                             if (!grepl(pattern, name)) 
[10:19:57.070]                               next
[10:19:57.070]                             invokeRestart(restart)
[10:19:57.070]                             muffled <- TRUE
[10:19:57.070]                             break
[10:19:57.070]                           }
[10:19:57.070]                         }
[10:19:57.070]                       }
[10:19:57.070]                       invisible(muffled)
[10:19:57.070]                     }
[10:19:57.070]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.070]                   }
[10:19:57.070]                 }
[10:19:57.070]             }
[10:19:57.070]         }))
[10:19:57.070]     }, error = function(ex) {
[10:19:57.070]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:57.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.070]                 ...future.rng), started = ...future.startTime, 
[10:19:57.070]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:57.070]             version = "1.8"), class = "FutureResult")
[10:19:57.070]     }, finally = {
[10:19:57.070]         if (!identical(...future.workdir, getwd())) 
[10:19:57.070]             setwd(...future.workdir)
[10:19:57.070]         {
[10:19:57.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:57.070]                 ...future.oldOptions$nwarnings <- NULL
[10:19:57.070]             }
[10:19:57.070]             base::options(...future.oldOptions)
[10:19:57.070]             if (.Platform$OS.type == "windows") {
[10:19:57.070]                 old_names <- names(...future.oldEnvVars)
[10:19:57.070]                 envs <- base::Sys.getenv()
[10:19:57.070]                 names <- names(envs)
[10:19:57.070]                 common <- intersect(names, old_names)
[10:19:57.070]                 added <- setdiff(names, old_names)
[10:19:57.070]                 removed <- setdiff(old_names, names)
[10:19:57.070]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:57.070]                   envs[common]]
[10:19:57.070]                 NAMES <- toupper(changed)
[10:19:57.070]                 args <- list()
[10:19:57.070]                 for (kk in seq_along(NAMES)) {
[10:19:57.070]                   name <- changed[[kk]]
[10:19:57.070]                   NAME <- NAMES[[kk]]
[10:19:57.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.070]                     next
[10:19:57.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.070]                 }
[10:19:57.070]                 NAMES <- toupper(added)
[10:19:57.070]                 for (kk in seq_along(NAMES)) {
[10:19:57.070]                   name <- added[[kk]]
[10:19:57.070]                   NAME <- NAMES[[kk]]
[10:19:57.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.070]                     next
[10:19:57.070]                   args[[name]] <- ""
[10:19:57.070]                 }
[10:19:57.070]                 NAMES <- toupper(removed)
[10:19:57.070]                 for (kk in seq_along(NAMES)) {
[10:19:57.070]                   name <- removed[[kk]]
[10:19:57.070]                   NAME <- NAMES[[kk]]
[10:19:57.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.070]                     next
[10:19:57.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.070]                 }
[10:19:57.070]                 if (length(args) > 0) 
[10:19:57.070]                   base::do.call(base::Sys.setenv, args = args)
[10:19:57.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:57.070]             }
[10:19:57.070]             else {
[10:19:57.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:57.070]             }
[10:19:57.070]             {
[10:19:57.070]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:57.070]                   0L) {
[10:19:57.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:57.070]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:57.070]                   base::options(opts)
[10:19:57.070]                 }
[10:19:57.070]                 {
[10:19:57.070]                   {
[10:19:57.070]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:57.070]                     NULL
[10:19:57.070]                   }
[10:19:57.070]                   options(future.plan = NULL)
[10:19:57.070]                   if (is.na(NA_character_)) 
[10:19:57.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:57.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:57.070]                     .init = FALSE)
[10:19:57.070]                 }
[10:19:57.070]             }
[10:19:57.070]         }
[10:19:57.070]     })
[10:19:57.070]     if (TRUE) {
[10:19:57.070]         base::sink(type = "output", split = FALSE)
[10:19:57.070]         if (TRUE) {
[10:19:57.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:57.070]         }
[10:19:57.070]         else {
[10:19:57.070]             ...future.result["stdout"] <- base::list(NULL)
[10:19:57.070]         }
[10:19:57.070]         base::close(...future.stdout)
[10:19:57.070]         ...future.stdout <- NULL
[10:19:57.070]     }
[10:19:57.070]     ...future.result$conditions <- ...future.conditions
[10:19:57.070]     ...future.result$finished <- base::Sys.time()
[10:19:57.070]     ...future.result
[10:19:57.070] }
[10:19:57.073] Exporting 11 global objects (14.06 KiB) to cluster node #2 ...
[10:19:57.073] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #2 ...
[10:19:57.114] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #2 ... DONE
[10:19:57.115] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ...
[10:19:57.115] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ... DONE
[10:19:57.115] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:57.115] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:57.116] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:57.156] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:57.157] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:57.197] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:57.198] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[10:19:57.198] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[10:19:57.198] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:57.198] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:57.199] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:57.199] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:57.199] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[10:19:57.199] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[10:19:57.200] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:57.200] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:57.200] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:57.200] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:57.201] Exporting 11 global objects (14.06 KiB) to cluster node #2 ... DONE
[10:19:57.201] MultisessionFuture started
[10:19:57.201] - Launch lazy future ... done
[10:19:57.201] run() for ‘MultisessionFuture’ ... done
[10:19:57.201] Created future:
[10:19:57.202] MultisessionFuture:
[10:19:57.202] Label: ‘future_vapply-2’
[10:19:57.202] Expression:
[10:19:57.202] {
[10:19:57.202]     do.call(function(...) {
[10:19:57.202]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.202]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.202]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.202]             on.exit(options(oopts), add = TRUE)
[10:19:57.202]         }
[10:19:57.202]         {
[10:19:57.202]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.202]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.202]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.202]             })
[10:19:57.202]         }
[10:19:57.202]     }, args = future.call.arguments)
[10:19:57.202] }
[10:19:57.202] Lazy evaluation: FALSE
[10:19:57.202] Asynchronous evaluation: TRUE
[10:19:57.202] Local evaluation: TRUE
[10:19:57.202] Environment: R_GlobalEnv
[10:19:57.202] Capture standard output: TRUE
[10:19:57.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:57.202] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:57.202] Packages: 1 packages (‘future.apply’)
[10:19:57.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:57.202] Resolved: FALSE
[10:19:57.202] Value: <not collected>
[10:19:57.202] Conditions captured: <none>
[10:19:57.202] Early signaling: FALSE
[10:19:57.202] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:57.202] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.213] Chunk #2 of 2 ... DONE
[10:19:57.213] Launching 2 futures (chunks) ... DONE
[10:19:57.213] Resolving 2 futures (chunks) ...
[10:19:57.214] resolve() on list ...
[10:19:57.214]  recursive: 0
[10:19:57.214]  length: 2
[10:19:57.214] 
[10:19:57.214] receiveMessageFromWorker() for ClusterFuture ...
[10:19:57.214] - Validating connection of MultisessionFuture
[10:19:57.215] - received message: FutureResult
[10:19:57.215] - Received FutureResult
[10:19:57.215] - Erased future from FutureRegistry
[10:19:57.215] result() for ClusterFuture ...
[10:19:57.215] - result already collected: FutureResult
[10:19:57.215] result() for ClusterFuture ... done
[10:19:57.215] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:57.215] Future #1
[10:19:57.215] result() for ClusterFuture ...
[10:19:57.215] - result already collected: FutureResult
[10:19:57.215] result() for ClusterFuture ... done
[10:19:57.216] result() for ClusterFuture ...
[10:19:57.216] - result already collected: FutureResult
[10:19:57.216] result() for ClusterFuture ... done
[10:19:57.216] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:57.216] - nx: 2
[10:19:57.216] - relay: TRUE
[10:19:57.216] - stdout: TRUE
[10:19:57.216] - signal: TRUE
[10:19:57.216] - resignal: FALSE
[10:19:57.216] - force: TRUE
[10:19:57.216] - relayed: [n=2] FALSE, FALSE
[10:19:57.216] - queued futures: [n=2] FALSE, FALSE
[10:19:57.217]  - until=1
[10:19:57.217]  - relaying element #1
[10:19:57.217] result() for ClusterFuture ...
[10:19:57.217] - result already collected: FutureResult
[10:19:57.217] result() for ClusterFuture ... done
[10:19:57.217] result() for ClusterFuture ...
[10:19:57.217] - result already collected: FutureResult
[10:19:57.217] result() for ClusterFuture ... done
[10:19:57.217] result() for ClusterFuture ...
[10:19:57.217] - result already collected: FutureResult
[10:19:57.217] result() for ClusterFuture ... done
[10:19:57.217] result() for ClusterFuture ...
[10:19:57.218] - result already collected: FutureResult
[10:19:57.218] result() for ClusterFuture ... done
[10:19:57.218] - relayed: [n=2] TRUE, FALSE
[10:19:57.218] - queued futures: [n=2] TRUE, FALSE
[10:19:57.218] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:57.218]  length: 1 (resolved future 1)
[10:19:57.243] receiveMessageFromWorker() for ClusterFuture ...
[10:19:57.243] - Validating connection of MultisessionFuture
[10:19:57.244] - received message: FutureResult
[10:19:57.244] - Received FutureResult
[10:19:57.244] - Erased future from FutureRegistry
[10:19:57.244] result() for ClusterFuture ...
[10:19:57.244] - result already collected: FutureResult
[10:19:57.244] result() for ClusterFuture ... done
[10:19:57.244] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:57.244] Future #2
[10:19:57.244] result() for ClusterFuture ...
[10:19:57.244] - result already collected: FutureResult
[10:19:57.244] result() for ClusterFuture ... done
[10:19:57.245] result() for ClusterFuture ...
[10:19:57.245] - result already collected: FutureResult
[10:19:57.245] result() for ClusterFuture ... done
[10:19:57.245] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:57.245] - nx: 2
[10:19:57.245] - relay: TRUE
[10:19:57.245] - stdout: TRUE
[10:19:57.245] - signal: TRUE
[10:19:57.245] - resignal: FALSE
[10:19:57.245] - force: TRUE
[10:19:57.245] - relayed: [n=2] TRUE, FALSE
[10:19:57.245] - queued futures: [n=2] TRUE, FALSE
[10:19:57.246]  - until=2
[10:19:57.246]  - relaying element #2
[10:19:57.246] result() for ClusterFuture ...
[10:19:57.246] - result already collected: FutureResult
[10:19:57.246] result() for ClusterFuture ... done
[10:19:57.246] result() for ClusterFuture ...
[10:19:57.246] - result already collected: FutureResult
[10:19:57.246] result() for ClusterFuture ... done
[10:19:57.246] result() for ClusterFuture ...
[10:19:57.246] - result already collected: FutureResult
[10:19:57.246] result() for ClusterFuture ... done
[10:19:57.246] result() for ClusterFuture ...
[10:19:57.247] - result already collected: FutureResult
[10:19:57.247] result() for ClusterFuture ... done
[10:19:57.247] - relayed: [n=2] TRUE, TRUE
[10:19:57.247] - queued futures: [n=2] TRUE, TRUE
[10:19:57.247] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:57.247]  length: 0 (resolved future 2)
[10:19:57.247] Relaying remaining futures
[10:19:57.247] signalConditionsASAP(NULL, pos=0) ...
[10:19:57.247] - nx: 2
[10:19:57.247] - relay: TRUE
[10:19:57.247] - stdout: TRUE
[10:19:57.247] - signal: TRUE
[10:19:57.247] - resignal: FALSE
[10:19:57.248] - force: TRUE
[10:19:57.248] - relayed: [n=2] TRUE, TRUE
[10:19:57.248] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:57.248] - relayed: [n=2] TRUE, TRUE
[10:19:57.248] - queued futures: [n=2] TRUE, TRUE
[10:19:57.248] signalConditionsASAP(NULL, pos=0) ... done
[10:19:57.248] resolve() on list ... DONE
[10:19:57.248] result() for ClusterFuture ...
[10:19:57.248] - result already collected: FutureResult
[10:19:57.248] result() for ClusterFuture ... done
[10:19:57.248] result() for ClusterFuture ...
[10:19:57.249] - result already collected: FutureResult
[10:19:57.249] result() for ClusterFuture ... done
[10:19:57.249] result() for ClusterFuture ...
[10:19:57.249] - result already collected: FutureResult
[10:19:57.249] result() for ClusterFuture ... done
[10:19:57.249] result() for ClusterFuture ...
[10:19:57.249] - result already collected: FutureResult
[10:19:57.249] result() for ClusterFuture ... done
[10:19:57.249]  - Number of value chunks collected: 2
[10:19:57.249] Resolving 2 futures (chunks) ... DONE
[10:19:57.249] Reducing values from 2 chunks ...
[10:19:57.249]  - Number of values collected after concatenation: 10
[10:19:57.250]  - Number of values expected: 10
[10:19:57.250] Reducing values from 2 chunks ... DONE
[10:19:57.250] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:19:57.252] future_lapply() ...
[10:19:57.255] Number of chunks: 2
[10:19:57.255] getGlobalsAndPackagesXApply() ...
[10:19:57.255]  - future.globals: TRUE
[10:19:57.255] getGlobalsAndPackages() ...
[10:19:57.255] Searching for globals...
[10:19:57.259] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:19:57.259] Searching for globals ... DONE
[10:19:57.259] Resolving globals: FALSE
[10:19:57.260] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[10:19:57.261] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:57.261] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:57.261] - packages: [1] ‘future.apply’
[10:19:57.261] getGlobalsAndPackages() ... DONE
[10:19:57.261]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:57.261]  - needed namespaces: [n=1] ‘future.apply’
[10:19:57.261] Finding globals ... DONE
[10:19:57.261]  - use_args: TRUE
[10:19:57.261]  - Getting '...' globals ...
[10:19:57.262] resolve() on list ...
[10:19:57.262]  recursive: 0
[10:19:57.262]  length: 1
[10:19:57.262]  elements: ‘...’
[10:19:57.262]  length: 0 (resolved future 1)
[10:19:57.262] resolve() on list ... DONE
[10:19:57.262]    - '...' content: [n=0] 
[10:19:57.262] List of 1
[10:19:57.262]  $ ...: list()
[10:19:57.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:57.262]  - attr(*, "where")=List of 1
[10:19:57.262]   ..$ ...:<environment: 0x55c6a135eaf8> 
[10:19:57.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:57.262]  - attr(*, "resolved")= logi TRUE
[10:19:57.262]  - attr(*, "total_size")= num NA
[10:19:57.265]  - Getting '...' globals ... DONE
[10:19:57.265] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:57.265] List of 8
[10:19:57.265]  $ ...future.FUN:function (x, ...)  
[10:19:57.265]  $ x_FUN        :function (x)  
[10:19:57.265]  $ times        : int 4
[10:19:57.265]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:57.265]  $ stop_if_not  :function (...)  
[10:19:57.265]  $ dim          : int [1:2] 2 2
[10:19:57.265]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:57.265]  $ ...          : list()
[10:19:57.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:57.265]  - attr(*, "where")=List of 8
[10:19:57.265]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:57.265]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:57.265]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:57.265]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:57.265]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:57.265]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:57.265]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:57.265]   ..$ ...          :<environment: 0x55c6a135eaf8> 
[10:19:57.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:57.265]  - attr(*, "resolved")= logi FALSE
[10:19:57.265]  - attr(*, "total_size")= num 29094
[10:19:57.270] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:57.270] getGlobalsAndPackagesXApply() ... DONE
[10:19:57.270] Number of futures (= number of chunks): 2
[10:19:57.271] Launching 2 futures (chunks) ...
[10:19:57.271] Chunk #1 of 2 ...
[10:19:57.271]  - Finding globals in 'X' for chunk #1 ...
[10:19:57.271] getGlobalsAndPackages() ...
[10:19:57.271] Searching for globals...
[10:19:57.271] 
[10:19:57.271] Searching for globals ... DONE
[10:19:57.271] - globals: [0] <none>
[10:19:57.271] getGlobalsAndPackages() ... DONE
[10:19:57.272]    + additional globals found: [n=0] 
[10:19:57.272]    + additional namespaces needed: [n=0] 
[10:19:57.272]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:57.272]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:57.272]  - seeds: <none>
[10:19:57.272]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.272] getGlobalsAndPackages() ...
[10:19:57.272] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.272] Resolving globals: FALSE
[10:19:57.272] Tweak future expression to call with '...' arguments ...
[10:19:57.272] {
[10:19:57.272]     do.call(function(...) {
[10:19:57.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.272]             on.exit(options(oopts), add = TRUE)
[10:19:57.272]         }
[10:19:57.272]         {
[10:19:57.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.272]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.272]             })
[10:19:57.272]         }
[10:19:57.272]     }, args = future.call.arguments)
[10:19:57.272] }
[10:19:57.273] Tweak future expression to call with '...' arguments ... DONE
[10:19:57.273] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.273] - packages: [1] ‘future.apply’
[10:19:57.273] getGlobalsAndPackages() ... DONE
[10:19:57.274] run() for ‘Future’ ...
[10:19:57.274] - state: ‘created’
[10:19:57.274] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:57.288] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:57.288]   - Field: ‘node’
[10:19:57.288]   - Field: ‘label’
[10:19:57.289]   - Field: ‘local’
[10:19:57.289]   - Field: ‘owner’
[10:19:57.289]   - Field: ‘envir’
[10:19:57.289]   - Field: ‘workers’
[10:19:57.289]   - Field: ‘packages’
[10:19:57.289]   - Field: ‘gc’
[10:19:57.289]   - Field: ‘conditions’
[10:19:57.289]   - Field: ‘persistent’
[10:19:57.289]   - Field: ‘expr’
[10:19:57.289]   - Field: ‘uuid’
[10:19:57.289]   - Field: ‘seed’
[10:19:57.289]   - Field: ‘version’
[10:19:57.290]   - Field: ‘result’
[10:19:57.290]   - Field: ‘asynchronous’
[10:19:57.290]   - Field: ‘calls’
[10:19:57.290]   - Field: ‘globals’
[10:19:57.290]   - Field: ‘stdout’
[10:19:57.290]   - Field: ‘earlySignal’
[10:19:57.290]   - Field: ‘lazy’
[10:19:57.290]   - Field: ‘state’
[10:19:57.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:57.290] - Launch lazy future ...
[10:19:57.291] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:57.291] Packages needed by future strategies (n = 0): <none>
[10:19:57.291] {
[10:19:57.291]     {
[10:19:57.291]         {
[10:19:57.291]             ...future.startTime <- base::Sys.time()
[10:19:57.291]             {
[10:19:57.291]                 {
[10:19:57.291]                   {
[10:19:57.291]                     {
[10:19:57.291]                       {
[10:19:57.291]                         base::local({
[10:19:57.291]                           has_future <- base::requireNamespace("future", 
[10:19:57.291]                             quietly = TRUE)
[10:19:57.291]                           if (has_future) {
[10:19:57.291]                             ns <- base::getNamespace("future")
[10:19:57.291]                             version <- ns[[".package"]][["version"]]
[10:19:57.291]                             if (is.null(version)) 
[10:19:57.291]                               version <- utils::packageVersion("future")
[10:19:57.291]                           }
[10:19:57.291]                           else {
[10:19:57.291]                             version <- NULL
[10:19:57.291]                           }
[10:19:57.291]                           if (!has_future || version < "1.8.0") {
[10:19:57.291]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:57.291]                               "", base::R.version$version.string), 
[10:19:57.291]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:57.291]                                 base::R.version$platform, 8 * 
[10:19:57.291]                                   base::.Machine$sizeof.pointer), 
[10:19:57.291]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:57.291]                                 "release", "version")], collapse = " "), 
[10:19:57.291]                               hostname = base::Sys.info()[["nodename"]])
[10:19:57.291]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:57.291]                               info)
[10:19:57.291]                             info <- base::paste(info, collapse = "; ")
[10:19:57.291]                             if (!has_future) {
[10:19:57.291]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:57.291]                                 info)
[10:19:57.291]                             }
[10:19:57.291]                             else {
[10:19:57.291]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:57.291]                                 info, version)
[10:19:57.291]                             }
[10:19:57.291]                             base::stop(msg)
[10:19:57.291]                           }
[10:19:57.291]                         })
[10:19:57.291]                       }
[10:19:57.291]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:57.291]                       base::options(mc.cores = 1L)
[10:19:57.291]                     }
[10:19:57.291]                     base::local({
[10:19:57.291]                       for (pkg in "future.apply") {
[10:19:57.291]                         base::loadNamespace(pkg)
[10:19:57.291]                         base::library(pkg, character.only = TRUE)
[10:19:57.291]                       }
[10:19:57.291]                     })
[10:19:57.291]                   }
[10:19:57.291]                   ...future.strategy.old <- future::plan("list")
[10:19:57.291]                   options(future.plan = NULL)
[10:19:57.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:57.291]                 }
[10:19:57.291]                 ...future.workdir <- getwd()
[10:19:57.291]             }
[10:19:57.291]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:57.291]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:57.291]         }
[10:19:57.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:57.291]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:57.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:57.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:57.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:57.291]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:57.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:57.291]             base::names(...future.oldOptions))
[10:19:57.291]     }
[10:19:57.291]     if (FALSE) {
[10:19:57.291]     }
[10:19:57.291]     else {
[10:19:57.291]         if (TRUE) {
[10:19:57.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:57.291]                 open = "w")
[10:19:57.291]         }
[10:19:57.291]         else {
[10:19:57.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:57.291]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:57.291]         }
[10:19:57.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:57.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:57.291]             base::sink(type = "output", split = FALSE)
[10:19:57.291]             base::close(...future.stdout)
[10:19:57.291]         }, add = TRUE)
[10:19:57.291]     }
[10:19:57.291]     ...future.frame <- base::sys.nframe()
[10:19:57.291]     ...future.conditions <- base::list()
[10:19:57.291]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:57.291]     if (FALSE) {
[10:19:57.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:57.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:57.291]     }
[10:19:57.291]     ...future.result <- base::tryCatch({
[10:19:57.291]         base::withCallingHandlers({
[10:19:57.291]             ...future.value <- base::withVisible(base::local({
[10:19:57.291]                 ...future.makeSendCondition <- base::local({
[10:19:57.291]                   sendCondition <- NULL
[10:19:57.291]                   function(frame = 1L) {
[10:19:57.291]                     if (is.function(sendCondition)) 
[10:19:57.291]                       return(sendCondition)
[10:19:57.291]                     ns <- getNamespace("parallel")
[10:19:57.291]                     if (exists("sendData", mode = "function", 
[10:19:57.291]                       envir = ns)) {
[10:19:57.291]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:57.291]                         envir = ns)
[10:19:57.291]                       envir <- sys.frame(frame)
[10:19:57.291]                       master <- NULL
[10:19:57.291]                       while (!identical(envir, .GlobalEnv) && 
[10:19:57.291]                         !identical(envir, emptyenv())) {
[10:19:57.291]                         if (exists("master", mode = "list", envir = envir, 
[10:19:57.291]                           inherits = FALSE)) {
[10:19:57.291]                           master <- get("master", mode = "list", 
[10:19:57.291]                             envir = envir, inherits = FALSE)
[10:19:57.291]                           if (inherits(master, c("SOCKnode", 
[10:19:57.291]                             "SOCK0node"))) {
[10:19:57.291]                             sendCondition <<- function(cond) {
[10:19:57.291]                               data <- list(type = "VALUE", value = cond, 
[10:19:57.291]                                 success = TRUE)
[10:19:57.291]                               parallel_sendData(master, data)
[10:19:57.291]                             }
[10:19:57.291]                             return(sendCondition)
[10:19:57.291]                           }
[10:19:57.291]                         }
[10:19:57.291]                         frame <- frame + 1L
[10:19:57.291]                         envir <- sys.frame(frame)
[10:19:57.291]                       }
[10:19:57.291]                     }
[10:19:57.291]                     sendCondition <<- function(cond) NULL
[10:19:57.291]                   }
[10:19:57.291]                 })
[10:19:57.291]                 withCallingHandlers({
[10:19:57.291]                   {
[10:19:57.291]                     do.call(function(...) {
[10:19:57.291]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.291]                       if (!identical(...future.globals.maxSize.org, 
[10:19:57.291]                         ...future.globals.maxSize)) {
[10:19:57.291]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.291]                         on.exit(options(oopts), add = TRUE)
[10:19:57.291]                       }
[10:19:57.291]                       {
[10:19:57.291]                         lapply(seq_along(...future.elements_ii), 
[10:19:57.291]                           FUN = function(jj) {
[10:19:57.291]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.291]                             ...future.FUN(...future.X_jj, ...)
[10:19:57.291]                           })
[10:19:57.291]                       }
[10:19:57.291]                     }, args = future.call.arguments)
[10:19:57.291]                   }
[10:19:57.291]                 }, immediateCondition = function(cond) {
[10:19:57.291]                   sendCondition <- ...future.makeSendCondition()
[10:19:57.291]                   sendCondition(cond)
[10:19:57.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.291]                   {
[10:19:57.291]                     inherits <- base::inherits
[10:19:57.291]                     invokeRestart <- base::invokeRestart
[10:19:57.291]                     is.null <- base::is.null
[10:19:57.291]                     muffled <- FALSE
[10:19:57.291]                     if (inherits(cond, "message")) {
[10:19:57.291]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:57.291]                       if (muffled) 
[10:19:57.291]                         invokeRestart("muffleMessage")
[10:19:57.291]                     }
[10:19:57.291]                     else if (inherits(cond, "warning")) {
[10:19:57.291]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:57.291]                       if (muffled) 
[10:19:57.291]                         invokeRestart("muffleWarning")
[10:19:57.291]                     }
[10:19:57.291]                     else if (inherits(cond, "condition")) {
[10:19:57.291]                       if (!is.null(pattern)) {
[10:19:57.291]                         computeRestarts <- base::computeRestarts
[10:19:57.291]                         grepl <- base::grepl
[10:19:57.291]                         restarts <- computeRestarts(cond)
[10:19:57.291]                         for (restart in restarts) {
[10:19:57.291]                           name <- restart$name
[10:19:57.291]                           if (is.null(name)) 
[10:19:57.291]                             next
[10:19:57.291]                           if (!grepl(pattern, name)) 
[10:19:57.291]                             next
[10:19:57.291]                           invokeRestart(restart)
[10:19:57.291]                           muffled <- TRUE
[10:19:57.291]                           break
[10:19:57.291]                         }
[10:19:57.291]                       }
[10:19:57.291]                     }
[10:19:57.291]                     invisible(muffled)
[10:19:57.291]                   }
[10:19:57.291]                   muffleCondition(cond)
[10:19:57.291]                 })
[10:19:57.291]             }))
[10:19:57.291]             future::FutureResult(value = ...future.value$value, 
[10:19:57.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.291]                   ...future.rng), globalenv = if (FALSE) 
[10:19:57.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:57.291]                     ...future.globalenv.names))
[10:19:57.291]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:57.291]         }, condition = base::local({
[10:19:57.291]             c <- base::c
[10:19:57.291]             inherits <- base::inherits
[10:19:57.291]             invokeRestart <- base::invokeRestart
[10:19:57.291]             length <- base::length
[10:19:57.291]             list <- base::list
[10:19:57.291]             seq.int <- base::seq.int
[10:19:57.291]             signalCondition <- base::signalCondition
[10:19:57.291]             sys.calls <- base::sys.calls
[10:19:57.291]             `[[` <- base::`[[`
[10:19:57.291]             `+` <- base::`+`
[10:19:57.291]             `<<-` <- base::`<<-`
[10:19:57.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:57.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:57.291]                   3L)]
[10:19:57.291]             }
[10:19:57.291]             function(cond) {
[10:19:57.291]                 is_error <- inherits(cond, "error")
[10:19:57.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:57.291]                   NULL)
[10:19:57.291]                 if (is_error) {
[10:19:57.291]                   sessionInformation <- function() {
[10:19:57.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:57.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:57.291]                       search = base::search(), system = base::Sys.info())
[10:19:57.291]                   }
[10:19:57.291]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:57.291]                     cond$call), session = sessionInformation(), 
[10:19:57.291]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:57.291]                   signalCondition(cond)
[10:19:57.291]                 }
[10:19:57.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:57.291]                 "immediateCondition"))) {
[10:19:57.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:57.291]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:57.291]                   if (TRUE && !signal) {
[10:19:57.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.291]                     {
[10:19:57.291]                       inherits <- base::inherits
[10:19:57.291]                       invokeRestart <- base::invokeRestart
[10:19:57.291]                       is.null <- base::is.null
[10:19:57.291]                       muffled <- FALSE
[10:19:57.291]                       if (inherits(cond, "message")) {
[10:19:57.291]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.291]                         if (muffled) 
[10:19:57.291]                           invokeRestart("muffleMessage")
[10:19:57.291]                       }
[10:19:57.291]                       else if (inherits(cond, "warning")) {
[10:19:57.291]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.291]                         if (muffled) 
[10:19:57.291]                           invokeRestart("muffleWarning")
[10:19:57.291]                       }
[10:19:57.291]                       else if (inherits(cond, "condition")) {
[10:19:57.291]                         if (!is.null(pattern)) {
[10:19:57.291]                           computeRestarts <- base::computeRestarts
[10:19:57.291]                           grepl <- base::grepl
[10:19:57.291]                           restarts <- computeRestarts(cond)
[10:19:57.291]                           for (restart in restarts) {
[10:19:57.291]                             name <- restart$name
[10:19:57.291]                             if (is.null(name)) 
[10:19:57.291]                               next
[10:19:57.291]                             if (!grepl(pattern, name)) 
[10:19:57.291]                               next
[10:19:57.291]                             invokeRestart(restart)
[10:19:57.291]                             muffled <- TRUE
[10:19:57.291]                             break
[10:19:57.291]                           }
[10:19:57.291]                         }
[10:19:57.291]                       }
[10:19:57.291]                       invisible(muffled)
[10:19:57.291]                     }
[10:19:57.291]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.291]                   }
[10:19:57.291]                 }
[10:19:57.291]                 else {
[10:19:57.291]                   if (TRUE) {
[10:19:57.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.291]                     {
[10:19:57.291]                       inherits <- base::inherits
[10:19:57.291]                       invokeRestart <- base::invokeRestart
[10:19:57.291]                       is.null <- base::is.null
[10:19:57.291]                       muffled <- FALSE
[10:19:57.291]                       if (inherits(cond, "message")) {
[10:19:57.291]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.291]                         if (muffled) 
[10:19:57.291]                           invokeRestart("muffleMessage")
[10:19:57.291]                       }
[10:19:57.291]                       else if (inherits(cond, "warning")) {
[10:19:57.291]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.291]                         if (muffled) 
[10:19:57.291]                           invokeRestart("muffleWarning")
[10:19:57.291]                       }
[10:19:57.291]                       else if (inherits(cond, "condition")) {
[10:19:57.291]                         if (!is.null(pattern)) {
[10:19:57.291]                           computeRestarts <- base::computeRestarts
[10:19:57.291]                           grepl <- base::grepl
[10:19:57.291]                           restarts <- computeRestarts(cond)
[10:19:57.291]                           for (restart in restarts) {
[10:19:57.291]                             name <- restart$name
[10:19:57.291]                             if (is.null(name)) 
[10:19:57.291]                               next
[10:19:57.291]                             if (!grepl(pattern, name)) 
[10:19:57.291]                               next
[10:19:57.291]                             invokeRestart(restart)
[10:19:57.291]                             muffled <- TRUE
[10:19:57.291]                             break
[10:19:57.291]                           }
[10:19:57.291]                         }
[10:19:57.291]                       }
[10:19:57.291]                       invisible(muffled)
[10:19:57.291]                     }
[10:19:57.291]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.291]                   }
[10:19:57.291]                 }
[10:19:57.291]             }
[10:19:57.291]         }))
[10:19:57.291]     }, error = function(ex) {
[10:19:57.291]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:57.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.291]                 ...future.rng), started = ...future.startTime, 
[10:19:57.291]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:57.291]             version = "1.8"), class = "FutureResult")
[10:19:57.291]     }, finally = {
[10:19:57.291]         if (!identical(...future.workdir, getwd())) 
[10:19:57.291]             setwd(...future.workdir)
[10:19:57.291]         {
[10:19:57.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:57.291]                 ...future.oldOptions$nwarnings <- NULL
[10:19:57.291]             }
[10:19:57.291]             base::options(...future.oldOptions)
[10:19:57.291]             if (.Platform$OS.type == "windows") {
[10:19:57.291]                 old_names <- names(...future.oldEnvVars)
[10:19:57.291]                 envs <- base::Sys.getenv()
[10:19:57.291]                 names <- names(envs)
[10:19:57.291]                 common <- intersect(names, old_names)
[10:19:57.291]                 added <- setdiff(names, old_names)
[10:19:57.291]                 removed <- setdiff(old_names, names)
[10:19:57.291]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:57.291]                   envs[common]]
[10:19:57.291]                 NAMES <- toupper(changed)
[10:19:57.291]                 args <- list()
[10:19:57.291]                 for (kk in seq_along(NAMES)) {
[10:19:57.291]                   name <- changed[[kk]]
[10:19:57.291]                   NAME <- NAMES[[kk]]
[10:19:57.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.291]                     next
[10:19:57.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.291]                 }
[10:19:57.291]                 NAMES <- toupper(added)
[10:19:57.291]                 for (kk in seq_along(NAMES)) {
[10:19:57.291]                   name <- added[[kk]]
[10:19:57.291]                   NAME <- NAMES[[kk]]
[10:19:57.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.291]                     next
[10:19:57.291]                   args[[name]] <- ""
[10:19:57.291]                 }
[10:19:57.291]                 NAMES <- toupper(removed)
[10:19:57.291]                 for (kk in seq_along(NAMES)) {
[10:19:57.291]                   name <- removed[[kk]]
[10:19:57.291]                   NAME <- NAMES[[kk]]
[10:19:57.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.291]                     next
[10:19:57.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.291]                 }
[10:19:57.291]                 if (length(args) > 0) 
[10:19:57.291]                   base::do.call(base::Sys.setenv, args = args)
[10:19:57.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:57.291]             }
[10:19:57.291]             else {
[10:19:57.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:57.291]             }
[10:19:57.291]             {
[10:19:57.291]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:57.291]                   0L) {
[10:19:57.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:57.291]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:57.291]                   base::options(opts)
[10:19:57.291]                 }
[10:19:57.291]                 {
[10:19:57.291]                   {
[10:19:57.291]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:57.291]                     NULL
[10:19:57.291]                   }
[10:19:57.291]                   options(future.plan = NULL)
[10:19:57.291]                   if (is.na(NA_character_)) 
[10:19:57.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:57.291]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:57.291]                     .init = FALSE)
[10:19:57.291]                 }
[10:19:57.291]             }
[10:19:57.291]         }
[10:19:57.291]     })
[10:19:57.291]     if (TRUE) {
[10:19:57.291]         base::sink(type = "output", split = FALSE)
[10:19:57.291]         if (TRUE) {
[10:19:57.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:57.291]         }
[10:19:57.291]         else {
[10:19:57.291]             ...future.result["stdout"] <- base::list(NULL)
[10:19:57.291]         }
[10:19:57.291]         base::close(...future.stdout)
[10:19:57.291]         ...future.stdout <- NULL
[10:19:57.291]     }
[10:19:57.291]     ...future.result$conditions <- ...future.conditions
[10:19:57.291]     ...future.result$finished <- base::Sys.time()
[10:19:57.291]     ...future.result
[10:19:57.291] }
[10:19:57.294] Exporting 11 global objects (16.42 KiB) to cluster node #1 ...
[10:19:57.294] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #1 ...
[10:19:57.335] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #1 ... DONE
[10:19:57.336] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #1 ...
[10:19:57.336] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #1 ... DONE
[10:19:57.336] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:57.337] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:57.337] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:57.377] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:57.378] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:57.418] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:57.419] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[10:19:57.419] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[10:19:57.419] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:57.420] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:57.420] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:57.420] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:57.420] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[10:19:57.421] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[10:19:57.421] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:57.421] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:57.421] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:57.422] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:57.422] Exporting 11 global objects (16.42 KiB) to cluster node #1 ... DONE
[10:19:57.422] MultisessionFuture started
[10:19:57.422] - Launch lazy future ... done
[10:19:57.422] run() for ‘MultisessionFuture’ ... done
[10:19:57.422] Created future:
[10:19:57.423] MultisessionFuture:
[10:19:57.423] Label: ‘future_vapply-1’
[10:19:57.423] Expression:
[10:19:57.423] {
[10:19:57.423]     do.call(function(...) {
[10:19:57.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.423]             on.exit(options(oopts), add = TRUE)
[10:19:57.423]         }
[10:19:57.423]         {
[10:19:57.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.423]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.423]             })
[10:19:57.423]         }
[10:19:57.423]     }, args = future.call.arguments)
[10:19:57.423] }
[10:19:57.423] Lazy evaluation: FALSE
[10:19:57.423] Asynchronous evaluation: TRUE
[10:19:57.423] Local evaluation: TRUE
[10:19:57.423] Environment: R_GlobalEnv
[10:19:57.423] Capture standard output: TRUE
[10:19:57.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:57.423] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:57.423] Packages: 1 packages (‘future.apply’)
[10:19:57.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:57.423] Resolved: FALSE
[10:19:57.423] Value: <not collected>
[10:19:57.423] Conditions captured: <none>
[10:19:57.423] Early signaling: FALSE
[10:19:57.423] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:57.423] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.434] Chunk #1 of 2 ... DONE
[10:19:57.434] Chunk #2 of 2 ...
[10:19:57.434]  - Finding globals in 'X' for chunk #2 ...
[10:19:57.434] getGlobalsAndPackages() ...
[10:19:57.435] Searching for globals...
[10:19:57.435] 
[10:19:57.435] Searching for globals ... DONE
[10:19:57.435] - globals: [0] <none>
[10:19:57.435] getGlobalsAndPackages() ... DONE
[10:19:57.435]    + additional globals found: [n=0] 
[10:19:57.435]    + additional namespaces needed: [n=0] 
[10:19:57.435]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:57.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:57.435]  - seeds: <none>
[10:19:57.436]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.436] getGlobalsAndPackages() ...
[10:19:57.436] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.436] Resolving globals: FALSE
[10:19:57.436] Tweak future expression to call with '...' arguments ...
[10:19:57.436] {
[10:19:57.436]     do.call(function(...) {
[10:19:57.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.436]             on.exit(options(oopts), add = TRUE)
[10:19:57.436]         }
[10:19:57.436]         {
[10:19:57.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.436]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.436]             })
[10:19:57.436]         }
[10:19:57.436]     }, args = future.call.arguments)
[10:19:57.436] }
[10:19:57.436] Tweak future expression to call with '...' arguments ... DONE
[10:19:57.437] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.437] - packages: [1] ‘future.apply’
[10:19:57.437] getGlobalsAndPackages() ... DONE
[10:19:57.437] run() for ‘Future’ ...
[10:19:57.437] - state: ‘created’
[10:19:57.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:57.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:57.452]   - Field: ‘node’
[10:19:57.452]   - Field: ‘label’
[10:19:57.452]   - Field: ‘local’
[10:19:57.452]   - Field: ‘owner’
[10:19:57.452]   - Field: ‘envir’
[10:19:57.452]   - Field: ‘workers’
[10:19:57.453]   - Field: ‘packages’
[10:19:57.453]   - Field: ‘gc’
[10:19:57.453]   - Field: ‘conditions’
[10:19:57.453]   - Field: ‘persistent’
[10:19:57.453]   - Field: ‘expr’
[10:19:57.453]   - Field: ‘uuid’
[10:19:57.453]   - Field: ‘seed’
[10:19:57.453]   - Field: ‘version’
[10:19:57.453]   - Field: ‘result’
[10:19:57.453]   - Field: ‘asynchronous’
[10:19:57.453]   - Field: ‘calls’
[10:19:57.454]   - Field: ‘globals’
[10:19:57.454]   - Field: ‘stdout’
[10:19:57.454]   - Field: ‘earlySignal’
[10:19:57.454]   - Field: ‘lazy’
[10:19:57.454]   - Field: ‘state’
[10:19:57.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:57.454] - Launch lazy future ...
[10:19:57.454] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:57.454] Packages needed by future strategies (n = 0): <none>
[10:19:57.455] {
[10:19:57.455]     {
[10:19:57.455]         {
[10:19:57.455]             ...future.startTime <- base::Sys.time()
[10:19:57.455]             {
[10:19:57.455]                 {
[10:19:57.455]                   {
[10:19:57.455]                     {
[10:19:57.455]                       {
[10:19:57.455]                         base::local({
[10:19:57.455]                           has_future <- base::requireNamespace("future", 
[10:19:57.455]                             quietly = TRUE)
[10:19:57.455]                           if (has_future) {
[10:19:57.455]                             ns <- base::getNamespace("future")
[10:19:57.455]                             version <- ns[[".package"]][["version"]]
[10:19:57.455]                             if (is.null(version)) 
[10:19:57.455]                               version <- utils::packageVersion("future")
[10:19:57.455]                           }
[10:19:57.455]                           else {
[10:19:57.455]                             version <- NULL
[10:19:57.455]                           }
[10:19:57.455]                           if (!has_future || version < "1.8.0") {
[10:19:57.455]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:57.455]                               "", base::R.version$version.string), 
[10:19:57.455]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:57.455]                                 base::R.version$platform, 8 * 
[10:19:57.455]                                   base::.Machine$sizeof.pointer), 
[10:19:57.455]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:57.455]                                 "release", "version")], collapse = " "), 
[10:19:57.455]                               hostname = base::Sys.info()[["nodename"]])
[10:19:57.455]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:57.455]                               info)
[10:19:57.455]                             info <- base::paste(info, collapse = "; ")
[10:19:57.455]                             if (!has_future) {
[10:19:57.455]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:57.455]                                 info)
[10:19:57.455]                             }
[10:19:57.455]                             else {
[10:19:57.455]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:57.455]                                 info, version)
[10:19:57.455]                             }
[10:19:57.455]                             base::stop(msg)
[10:19:57.455]                           }
[10:19:57.455]                         })
[10:19:57.455]                       }
[10:19:57.455]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:57.455]                       base::options(mc.cores = 1L)
[10:19:57.455]                     }
[10:19:57.455]                     base::local({
[10:19:57.455]                       for (pkg in "future.apply") {
[10:19:57.455]                         base::loadNamespace(pkg)
[10:19:57.455]                         base::library(pkg, character.only = TRUE)
[10:19:57.455]                       }
[10:19:57.455]                     })
[10:19:57.455]                   }
[10:19:57.455]                   ...future.strategy.old <- future::plan("list")
[10:19:57.455]                   options(future.plan = NULL)
[10:19:57.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:57.455]                 }
[10:19:57.455]                 ...future.workdir <- getwd()
[10:19:57.455]             }
[10:19:57.455]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:57.455]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:57.455]         }
[10:19:57.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:57.455]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:57.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:57.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:57.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:57.455]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:57.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:57.455]             base::names(...future.oldOptions))
[10:19:57.455]     }
[10:19:57.455]     if (FALSE) {
[10:19:57.455]     }
[10:19:57.455]     else {
[10:19:57.455]         if (TRUE) {
[10:19:57.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:57.455]                 open = "w")
[10:19:57.455]         }
[10:19:57.455]         else {
[10:19:57.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:57.455]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:57.455]         }
[10:19:57.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:57.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:57.455]             base::sink(type = "output", split = FALSE)
[10:19:57.455]             base::close(...future.stdout)
[10:19:57.455]         }, add = TRUE)
[10:19:57.455]     }
[10:19:57.455]     ...future.frame <- base::sys.nframe()
[10:19:57.455]     ...future.conditions <- base::list()
[10:19:57.455]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:57.455]     if (FALSE) {
[10:19:57.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:57.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:57.455]     }
[10:19:57.455]     ...future.result <- base::tryCatch({
[10:19:57.455]         base::withCallingHandlers({
[10:19:57.455]             ...future.value <- base::withVisible(base::local({
[10:19:57.455]                 ...future.makeSendCondition <- base::local({
[10:19:57.455]                   sendCondition <- NULL
[10:19:57.455]                   function(frame = 1L) {
[10:19:57.455]                     if (is.function(sendCondition)) 
[10:19:57.455]                       return(sendCondition)
[10:19:57.455]                     ns <- getNamespace("parallel")
[10:19:57.455]                     if (exists("sendData", mode = "function", 
[10:19:57.455]                       envir = ns)) {
[10:19:57.455]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:57.455]                         envir = ns)
[10:19:57.455]                       envir <- sys.frame(frame)
[10:19:57.455]                       master <- NULL
[10:19:57.455]                       while (!identical(envir, .GlobalEnv) && 
[10:19:57.455]                         !identical(envir, emptyenv())) {
[10:19:57.455]                         if (exists("master", mode = "list", envir = envir, 
[10:19:57.455]                           inherits = FALSE)) {
[10:19:57.455]                           master <- get("master", mode = "list", 
[10:19:57.455]                             envir = envir, inherits = FALSE)
[10:19:57.455]                           if (inherits(master, c("SOCKnode", 
[10:19:57.455]                             "SOCK0node"))) {
[10:19:57.455]                             sendCondition <<- function(cond) {
[10:19:57.455]                               data <- list(type = "VALUE", value = cond, 
[10:19:57.455]                                 success = TRUE)
[10:19:57.455]                               parallel_sendData(master, data)
[10:19:57.455]                             }
[10:19:57.455]                             return(sendCondition)
[10:19:57.455]                           }
[10:19:57.455]                         }
[10:19:57.455]                         frame <- frame + 1L
[10:19:57.455]                         envir <- sys.frame(frame)
[10:19:57.455]                       }
[10:19:57.455]                     }
[10:19:57.455]                     sendCondition <<- function(cond) NULL
[10:19:57.455]                   }
[10:19:57.455]                 })
[10:19:57.455]                 withCallingHandlers({
[10:19:57.455]                   {
[10:19:57.455]                     do.call(function(...) {
[10:19:57.455]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.455]                       if (!identical(...future.globals.maxSize.org, 
[10:19:57.455]                         ...future.globals.maxSize)) {
[10:19:57.455]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.455]                         on.exit(options(oopts), add = TRUE)
[10:19:57.455]                       }
[10:19:57.455]                       {
[10:19:57.455]                         lapply(seq_along(...future.elements_ii), 
[10:19:57.455]                           FUN = function(jj) {
[10:19:57.455]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.455]                             ...future.FUN(...future.X_jj, ...)
[10:19:57.455]                           })
[10:19:57.455]                       }
[10:19:57.455]                     }, args = future.call.arguments)
[10:19:57.455]                   }
[10:19:57.455]                 }, immediateCondition = function(cond) {
[10:19:57.455]                   sendCondition <- ...future.makeSendCondition()
[10:19:57.455]                   sendCondition(cond)
[10:19:57.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.455]                   {
[10:19:57.455]                     inherits <- base::inherits
[10:19:57.455]                     invokeRestart <- base::invokeRestart
[10:19:57.455]                     is.null <- base::is.null
[10:19:57.455]                     muffled <- FALSE
[10:19:57.455]                     if (inherits(cond, "message")) {
[10:19:57.455]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:57.455]                       if (muffled) 
[10:19:57.455]                         invokeRestart("muffleMessage")
[10:19:57.455]                     }
[10:19:57.455]                     else if (inherits(cond, "warning")) {
[10:19:57.455]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:57.455]                       if (muffled) 
[10:19:57.455]                         invokeRestart("muffleWarning")
[10:19:57.455]                     }
[10:19:57.455]                     else if (inherits(cond, "condition")) {
[10:19:57.455]                       if (!is.null(pattern)) {
[10:19:57.455]                         computeRestarts <- base::computeRestarts
[10:19:57.455]                         grepl <- base::grepl
[10:19:57.455]                         restarts <- computeRestarts(cond)
[10:19:57.455]                         for (restart in restarts) {
[10:19:57.455]                           name <- restart$name
[10:19:57.455]                           if (is.null(name)) 
[10:19:57.455]                             next
[10:19:57.455]                           if (!grepl(pattern, name)) 
[10:19:57.455]                             next
[10:19:57.455]                           invokeRestart(restart)
[10:19:57.455]                           muffled <- TRUE
[10:19:57.455]                           break
[10:19:57.455]                         }
[10:19:57.455]                       }
[10:19:57.455]                     }
[10:19:57.455]                     invisible(muffled)
[10:19:57.455]                   }
[10:19:57.455]                   muffleCondition(cond)
[10:19:57.455]                 })
[10:19:57.455]             }))
[10:19:57.455]             future::FutureResult(value = ...future.value$value, 
[10:19:57.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.455]                   ...future.rng), globalenv = if (FALSE) 
[10:19:57.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:57.455]                     ...future.globalenv.names))
[10:19:57.455]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:57.455]         }, condition = base::local({
[10:19:57.455]             c <- base::c
[10:19:57.455]             inherits <- base::inherits
[10:19:57.455]             invokeRestart <- base::invokeRestart
[10:19:57.455]             length <- base::length
[10:19:57.455]             list <- base::list
[10:19:57.455]             seq.int <- base::seq.int
[10:19:57.455]             signalCondition <- base::signalCondition
[10:19:57.455]             sys.calls <- base::sys.calls
[10:19:57.455]             `[[` <- base::`[[`
[10:19:57.455]             `+` <- base::`+`
[10:19:57.455]             `<<-` <- base::`<<-`
[10:19:57.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:57.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:57.455]                   3L)]
[10:19:57.455]             }
[10:19:57.455]             function(cond) {
[10:19:57.455]                 is_error <- inherits(cond, "error")
[10:19:57.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:57.455]                   NULL)
[10:19:57.455]                 if (is_error) {
[10:19:57.455]                   sessionInformation <- function() {
[10:19:57.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:57.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:57.455]                       search = base::search(), system = base::Sys.info())
[10:19:57.455]                   }
[10:19:57.455]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:57.455]                     cond$call), session = sessionInformation(), 
[10:19:57.455]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:57.455]                   signalCondition(cond)
[10:19:57.455]                 }
[10:19:57.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:57.455]                 "immediateCondition"))) {
[10:19:57.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:57.455]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:57.455]                   if (TRUE && !signal) {
[10:19:57.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.455]                     {
[10:19:57.455]                       inherits <- base::inherits
[10:19:57.455]                       invokeRestart <- base::invokeRestart
[10:19:57.455]                       is.null <- base::is.null
[10:19:57.455]                       muffled <- FALSE
[10:19:57.455]                       if (inherits(cond, "message")) {
[10:19:57.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.455]                         if (muffled) 
[10:19:57.455]                           invokeRestart("muffleMessage")
[10:19:57.455]                       }
[10:19:57.455]                       else if (inherits(cond, "warning")) {
[10:19:57.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.455]                         if (muffled) 
[10:19:57.455]                           invokeRestart("muffleWarning")
[10:19:57.455]                       }
[10:19:57.455]                       else if (inherits(cond, "condition")) {
[10:19:57.455]                         if (!is.null(pattern)) {
[10:19:57.455]                           computeRestarts <- base::computeRestarts
[10:19:57.455]                           grepl <- base::grepl
[10:19:57.455]                           restarts <- computeRestarts(cond)
[10:19:57.455]                           for (restart in restarts) {
[10:19:57.455]                             name <- restart$name
[10:19:57.455]                             if (is.null(name)) 
[10:19:57.455]                               next
[10:19:57.455]                             if (!grepl(pattern, name)) 
[10:19:57.455]                               next
[10:19:57.455]                             invokeRestart(restart)
[10:19:57.455]                             muffled <- TRUE
[10:19:57.455]                             break
[10:19:57.455]                           }
[10:19:57.455]                         }
[10:19:57.455]                       }
[10:19:57.455]                       invisible(muffled)
[10:19:57.455]                     }
[10:19:57.455]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.455]                   }
[10:19:57.455]                 }
[10:19:57.455]                 else {
[10:19:57.455]                   if (TRUE) {
[10:19:57.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.455]                     {
[10:19:57.455]                       inherits <- base::inherits
[10:19:57.455]                       invokeRestart <- base::invokeRestart
[10:19:57.455]                       is.null <- base::is.null
[10:19:57.455]                       muffled <- FALSE
[10:19:57.455]                       if (inherits(cond, "message")) {
[10:19:57.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.455]                         if (muffled) 
[10:19:57.455]                           invokeRestart("muffleMessage")
[10:19:57.455]                       }
[10:19:57.455]                       else if (inherits(cond, "warning")) {
[10:19:57.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.455]                         if (muffled) 
[10:19:57.455]                           invokeRestart("muffleWarning")
[10:19:57.455]                       }
[10:19:57.455]                       else if (inherits(cond, "condition")) {
[10:19:57.455]                         if (!is.null(pattern)) {
[10:19:57.455]                           computeRestarts <- base::computeRestarts
[10:19:57.455]                           grepl <- base::grepl
[10:19:57.455]                           restarts <- computeRestarts(cond)
[10:19:57.455]                           for (restart in restarts) {
[10:19:57.455]                             name <- restart$name
[10:19:57.455]                             if (is.null(name)) 
[10:19:57.455]                               next
[10:19:57.455]                             if (!grepl(pattern, name)) 
[10:19:57.455]                               next
[10:19:57.455]                             invokeRestart(restart)
[10:19:57.455]                             muffled <- TRUE
[10:19:57.455]                             break
[10:19:57.455]                           }
[10:19:57.455]                         }
[10:19:57.455]                       }
[10:19:57.455]                       invisible(muffled)
[10:19:57.455]                     }
[10:19:57.455]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.455]                   }
[10:19:57.455]                 }
[10:19:57.455]             }
[10:19:57.455]         }))
[10:19:57.455]     }, error = function(ex) {
[10:19:57.455]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:57.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.455]                 ...future.rng), started = ...future.startTime, 
[10:19:57.455]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:57.455]             version = "1.8"), class = "FutureResult")
[10:19:57.455]     }, finally = {
[10:19:57.455]         if (!identical(...future.workdir, getwd())) 
[10:19:57.455]             setwd(...future.workdir)
[10:19:57.455]         {
[10:19:57.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:57.455]                 ...future.oldOptions$nwarnings <- NULL
[10:19:57.455]             }
[10:19:57.455]             base::options(...future.oldOptions)
[10:19:57.455]             if (.Platform$OS.type == "windows") {
[10:19:57.455]                 old_names <- names(...future.oldEnvVars)
[10:19:57.455]                 envs <- base::Sys.getenv()
[10:19:57.455]                 names <- names(envs)
[10:19:57.455]                 common <- intersect(names, old_names)
[10:19:57.455]                 added <- setdiff(names, old_names)
[10:19:57.455]                 removed <- setdiff(old_names, names)
[10:19:57.455]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:57.455]                   envs[common]]
[10:19:57.455]                 NAMES <- toupper(changed)
[10:19:57.455]                 args <- list()
[10:19:57.455]                 for (kk in seq_along(NAMES)) {
[10:19:57.455]                   name <- changed[[kk]]
[10:19:57.455]                   NAME <- NAMES[[kk]]
[10:19:57.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.455]                     next
[10:19:57.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.455]                 }
[10:19:57.455]                 NAMES <- toupper(added)
[10:19:57.455]                 for (kk in seq_along(NAMES)) {
[10:19:57.455]                   name <- added[[kk]]
[10:19:57.455]                   NAME <- NAMES[[kk]]
[10:19:57.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.455]                     next
[10:19:57.455]                   args[[name]] <- ""
[10:19:57.455]                 }
[10:19:57.455]                 NAMES <- toupper(removed)
[10:19:57.455]                 for (kk in seq_along(NAMES)) {
[10:19:57.455]                   name <- removed[[kk]]
[10:19:57.455]                   NAME <- NAMES[[kk]]
[10:19:57.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.455]                     next
[10:19:57.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.455]                 }
[10:19:57.455]                 if (length(args) > 0) 
[10:19:57.455]                   base::do.call(base::Sys.setenv, args = args)
[10:19:57.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:57.455]             }
[10:19:57.455]             else {
[10:19:57.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:57.455]             }
[10:19:57.455]             {
[10:19:57.455]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:57.455]                   0L) {
[10:19:57.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:57.455]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:57.455]                   base::options(opts)
[10:19:57.455]                 }
[10:19:57.455]                 {
[10:19:57.455]                   {
[10:19:57.455]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:57.455]                     NULL
[10:19:57.455]                   }
[10:19:57.455]                   options(future.plan = NULL)
[10:19:57.455]                   if (is.na(NA_character_)) 
[10:19:57.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:57.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:57.455]                     .init = FALSE)
[10:19:57.455]                 }
[10:19:57.455]             }
[10:19:57.455]         }
[10:19:57.455]     })
[10:19:57.455]     if (TRUE) {
[10:19:57.455]         base::sink(type = "output", split = FALSE)
[10:19:57.455]         if (TRUE) {
[10:19:57.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:57.455]         }
[10:19:57.455]         else {
[10:19:57.455]             ...future.result["stdout"] <- base::list(NULL)
[10:19:57.455]         }
[10:19:57.455]         base::close(...future.stdout)
[10:19:57.455]         ...future.stdout <- NULL
[10:19:57.455]     }
[10:19:57.455]     ...future.result$conditions <- ...future.conditions
[10:19:57.455]     ...future.result$finished <- base::Sys.time()
[10:19:57.455]     ...future.result
[10:19:57.455] }
[10:19:57.458] Exporting 11 global objects (16.42 KiB) to cluster node #2 ...
[10:19:57.458] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #2 ...
[10:19:57.499] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #2 ... DONE
[10:19:57.500] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #2 ...
[10:19:57.500] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #2 ... DONE
[10:19:57.500] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:57.501] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:57.501] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:57.541] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:57.542] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:57.582] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:57.583] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[10:19:57.583] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[10:19:57.583] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:57.584] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:57.584] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:57.584] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:57.584] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[10:19:57.585] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[10:19:57.585] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:57.585] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:57.585] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:57.586] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:57.588] Exporting 11 global objects (16.42 KiB) to cluster node #2 ... DONE
[10:19:57.589] MultisessionFuture started
[10:19:57.589] - Launch lazy future ... done
[10:19:57.589] run() for ‘MultisessionFuture’ ... done
[10:19:57.589] Created future:
[10:19:57.589] MultisessionFuture:
[10:19:57.589] Label: ‘future_vapply-2’
[10:19:57.589] Expression:
[10:19:57.589] {
[10:19:57.589]     do.call(function(...) {
[10:19:57.589]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.589]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.589]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.589]             on.exit(options(oopts), add = TRUE)
[10:19:57.589]         }
[10:19:57.589]         {
[10:19:57.589]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.589]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.589]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.589]             })
[10:19:57.589]         }
[10:19:57.589]     }, args = future.call.arguments)
[10:19:57.589] }
[10:19:57.589] Lazy evaluation: FALSE
[10:19:57.589] Asynchronous evaluation: TRUE
[10:19:57.589] Local evaluation: TRUE
[10:19:57.589] Environment: R_GlobalEnv
[10:19:57.589] Capture standard output: TRUE
[10:19:57.589] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:57.589] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:57.589] Packages: 1 packages (‘future.apply’)
[10:19:57.589] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:57.589] Resolved: FALSE
[10:19:57.589] Value: <not collected>
[10:19:57.589] Conditions captured: <none>
[10:19:57.589] Early signaling: FALSE
[10:19:57.589] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:57.589] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.601] Chunk #2 of 2 ... DONE
[10:19:57.601] Launching 2 futures (chunks) ... DONE
[10:19:57.601] Resolving 2 futures (chunks) ...
[10:19:57.602] resolve() on list ...
[10:19:57.602]  recursive: 0
[10:19:57.602]  length: 2
[10:19:57.602] 
[10:19:57.602] receiveMessageFromWorker() for ClusterFuture ...
[10:19:57.602] - Validating connection of MultisessionFuture
[10:19:57.603] - received message: FutureResult
[10:19:57.603] - Received FutureResult
[10:19:57.603] - Erased future from FutureRegistry
[10:19:57.603] result() for ClusterFuture ...
[10:19:57.603] - result already collected: FutureResult
[10:19:57.603] result() for ClusterFuture ... done
[10:19:57.603] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:57.603] Future #1
[10:19:57.603] result() for ClusterFuture ...
[10:19:57.603] - result already collected: FutureResult
[10:19:57.603] result() for ClusterFuture ... done
[10:19:57.604] result() for ClusterFuture ...
[10:19:57.604] - result already collected: FutureResult
[10:19:57.604] result() for ClusterFuture ... done
[10:19:57.604] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:57.604] - nx: 2
[10:19:57.604] - relay: TRUE
[10:19:57.604] - stdout: TRUE
[10:19:57.604] - signal: TRUE
[10:19:57.604] - resignal: FALSE
[10:19:57.604] - force: TRUE
[10:19:57.604] - relayed: [n=2] FALSE, FALSE
[10:19:57.604] - queued futures: [n=2] FALSE, FALSE
[10:19:57.605]  - until=1
[10:19:57.605]  - relaying element #1
[10:19:57.605] result() for ClusterFuture ...
[10:19:57.605] - result already collected: FutureResult
[10:19:57.605] result() for ClusterFuture ... done
[10:19:57.605] result() for ClusterFuture ...
[10:19:57.605] - result already collected: FutureResult
[10:19:57.605] result() for ClusterFuture ... done
[10:19:57.605] result() for ClusterFuture ...
[10:19:57.605] - result already collected: FutureResult
[10:19:57.605] result() for ClusterFuture ... done
[10:19:57.605] result() for ClusterFuture ...
[10:19:57.606] - result already collected: FutureResult
[10:19:57.606] result() for ClusterFuture ... done
[10:19:57.606] - relayed: [n=2] TRUE, FALSE
[10:19:57.606] - queued futures: [n=2] TRUE, FALSE
[10:19:57.606] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:57.606]  length: 1 (resolved future 1)
[10:19:57.631] receiveMessageFromWorker() for ClusterFuture ...
[10:19:57.631] - Validating connection of MultisessionFuture
[10:19:57.631] - received message: FutureResult
[10:19:57.632] - Received FutureResult
[10:19:57.632] - Erased future from FutureRegistry
[10:19:57.632] result() for ClusterFuture ...
[10:19:57.632] - result already collected: FutureResult
[10:19:57.632] result() for ClusterFuture ... done
[10:19:57.632] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:57.632] Future #2
[10:19:57.632] result() for ClusterFuture ...
[10:19:57.632] - result already collected: FutureResult
[10:19:57.632] result() for ClusterFuture ... done
[10:19:57.632] result() for ClusterFuture ...
[10:19:57.633] - result already collected: FutureResult
[10:19:57.633] result() for ClusterFuture ... done
[10:19:57.633] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:57.633] - nx: 2
[10:19:57.633] - relay: TRUE
[10:19:57.633] - stdout: TRUE
[10:19:57.633] - signal: TRUE
[10:19:57.633] - resignal: FALSE
[10:19:57.633] - force: TRUE
[10:19:57.633] - relayed: [n=2] TRUE, FALSE
[10:19:57.633] - queued futures: [n=2] TRUE, FALSE
[10:19:57.633]  - until=2
[10:19:57.633]  - relaying element #2
[10:19:57.634] result() for ClusterFuture ...
[10:19:57.634] - result already collected: FutureResult
[10:19:57.634] result() for ClusterFuture ... done
[10:19:57.634] result() for ClusterFuture ...
[10:19:57.634] - result already collected: FutureResult
[10:19:57.634] result() for ClusterFuture ... done
[10:19:57.634] result() for ClusterFuture ...
[10:19:57.634] - result already collected: FutureResult
[10:19:57.634] result() for ClusterFuture ... done
[10:19:57.634] result() for ClusterFuture ...
[10:19:57.634] - result already collected: FutureResult
[10:19:57.634] result() for ClusterFuture ... done
[10:19:57.635] - relayed: [n=2] TRUE, TRUE
[10:19:57.635] - queued futures: [n=2] TRUE, TRUE
[10:19:57.635] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:57.635]  length: 0 (resolved future 2)
[10:19:57.635] Relaying remaining futures
[10:19:57.635] signalConditionsASAP(NULL, pos=0) ...
[10:19:57.635] - nx: 2
[10:19:57.635] - relay: TRUE
[10:19:57.635] - stdout: TRUE
[10:19:57.635] - signal: TRUE
[10:19:57.635] - resignal: FALSE
[10:19:57.635] - force: TRUE
[10:19:57.636] - relayed: [n=2] TRUE, TRUE
[10:19:57.636] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:57.636] - relayed: [n=2] TRUE, TRUE
[10:19:57.636] - queued futures: [n=2] TRUE, TRUE
[10:19:57.636] signalConditionsASAP(NULL, pos=0) ... done
[10:19:57.636] resolve() on list ... DONE
[10:19:57.636] result() for ClusterFuture ...
[10:19:57.636] - result already collected: FutureResult
[10:19:57.636] result() for ClusterFuture ... done
[10:19:57.636] result() for ClusterFuture ...
[10:19:57.637] - result already collected: FutureResult
[10:19:57.637] result() for ClusterFuture ... done
[10:19:57.637] result() for ClusterFuture ...
[10:19:57.637] - result already collected: FutureResult
[10:19:57.637] result() for ClusterFuture ... done
[10:19:57.637] result() for ClusterFuture ...
[10:19:57.637] - result already collected: FutureResult
[10:19:57.637] result() for ClusterFuture ... done
[10:19:57.637]  - Number of value chunks collected: 2
[10:19:57.637] Resolving 2 futures (chunks) ... DONE
[10:19:57.637] Reducing values from 2 chunks ...
[10:19:57.637]  - Number of values collected after concatenation: 10
[10:19:57.638]  - Number of values expected: 10
[10:19:57.638] Reducing values from 2 chunks ... DONE
[10:19:57.638] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:19:57.640] future_lapply() ...
[10:19:57.643] Number of chunks: 2
[10:19:57.643] getGlobalsAndPackagesXApply() ...
[10:19:57.643]  - future.globals: TRUE
[10:19:57.644] getGlobalsAndPackages() ...
[10:19:57.644] Searching for globals...
[10:19:57.647] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:19:57.647] Searching for globals ... DONE
[10:19:57.647] Resolving globals: FALSE
[10:19:57.648] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[10:19:57.648] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:57.649] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:57.649] - packages: [2] ‘stats’, ‘future.apply’
[10:19:57.649] getGlobalsAndPackages() ... DONE
[10:19:57.649]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:57.649]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:19:57.649] Finding globals ... DONE
[10:19:57.649]  - use_args: TRUE
[10:19:57.649]  - Getting '...' globals ...
[10:19:57.650] resolve() on list ...
[10:19:57.650]  recursive: 0
[10:19:57.650]  length: 1
[10:19:57.650]  elements: ‘...’
[10:19:57.650]  length: 0 (resolved future 1)
[10:19:57.650] resolve() on list ... DONE
[10:19:57.650]    - '...' content: [n=0] 
[10:19:57.650] List of 1
[10:19:57.650]  $ ...: list()
[10:19:57.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:57.650]  - attr(*, "where")=List of 1
[10:19:57.650]   ..$ ...:<environment: 0x55c69f021588> 
[10:19:57.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:57.650]  - attr(*, "resolved")= logi TRUE
[10:19:57.650]  - attr(*, "total_size")= num NA
[10:19:57.652]  - Getting '...' globals ... DONE
[10:19:57.653] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:57.653] List of 8
[10:19:57.653]  $ ...future.FUN:function (x, ...)  
[10:19:57.653]  $ x_FUN        :function (x, ...)  
[10:19:57.653]  $ times        : int 5
[10:19:57.653]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:57.653]  $ stop_if_not  :function (...)  
[10:19:57.653]  $ dim          : NULL
[10:19:57.653]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:57.653]  $ ...          : list()
[10:19:57.653]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:57.653]  - attr(*, "where")=List of 8
[10:19:57.653]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:57.653]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:57.653]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:57.653]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:57.653]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:57.653]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:57.653]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:57.653]   ..$ ...          :<environment: 0x55c69f021588> 
[10:19:57.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:57.653]  - attr(*, "resolved")= logi FALSE
[10:19:57.653]  - attr(*, "total_size")= num 24127
[10:19:57.658] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:19:57.658] getGlobalsAndPackagesXApply() ... DONE
[10:19:57.658] Number of futures (= number of chunks): 2
[10:19:57.659] Launching 2 futures (chunks) ...
[10:19:57.659] Chunk #1 of 2 ...
[10:19:57.659]  - Finding globals in 'X' for chunk #1 ...
[10:19:57.659] getGlobalsAndPackages() ...
[10:19:57.659] Searching for globals...
[10:19:57.659] 
[10:19:57.659] Searching for globals ... DONE
[10:19:57.660] - globals: [0] <none>
[10:19:57.660] getGlobalsAndPackages() ... DONE
[10:19:57.660]    + additional globals found: [n=0] 
[10:19:57.660]    + additional namespaces needed: [n=0] 
[10:19:57.660]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:57.660]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:57.660]  - seeds: <none>
[10:19:57.660]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.660] getGlobalsAndPackages() ...
[10:19:57.661] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.661] Resolving globals: FALSE
[10:19:57.661] Tweak future expression to call with '...' arguments ...
[10:19:57.661] {
[10:19:57.661]     do.call(function(...) {
[10:19:57.661]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.661]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.661]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.661]             on.exit(options(oopts), add = TRUE)
[10:19:57.661]         }
[10:19:57.661]         {
[10:19:57.661]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.661]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.661]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.661]             })
[10:19:57.661]         }
[10:19:57.661]     }, args = future.call.arguments)
[10:19:57.661] }
[10:19:57.661] Tweak future expression to call with '...' arguments ... DONE
[10:19:57.662] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.662] - packages: [2] ‘stats’, ‘future.apply’
[10:19:57.662] getGlobalsAndPackages() ... DONE
[10:19:57.662] run() for ‘Future’ ...
[10:19:57.662] - state: ‘created’
[10:19:57.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:57.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:57.677]   - Field: ‘node’
[10:19:57.677]   - Field: ‘label’
[10:19:57.677]   - Field: ‘local’
[10:19:57.677]   - Field: ‘owner’
[10:19:57.677]   - Field: ‘envir’
[10:19:57.677]   - Field: ‘workers’
[10:19:57.678]   - Field: ‘packages’
[10:19:57.678]   - Field: ‘gc’
[10:19:57.678]   - Field: ‘conditions’
[10:19:57.678]   - Field: ‘persistent’
[10:19:57.678]   - Field: ‘expr’
[10:19:57.678]   - Field: ‘uuid’
[10:19:57.678]   - Field: ‘seed’
[10:19:57.678]   - Field: ‘version’
[10:19:57.678]   - Field: ‘result’
[10:19:57.678]   - Field: ‘asynchronous’
[10:19:57.678]   - Field: ‘calls’
[10:19:57.678]   - Field: ‘globals’
[10:19:57.679]   - Field: ‘stdout’
[10:19:57.679]   - Field: ‘earlySignal’
[10:19:57.679]   - Field: ‘lazy’
[10:19:57.679]   - Field: ‘state’
[10:19:57.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:57.679] - Launch lazy future ...
[10:19:57.679] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:57.679] Packages needed by future strategies (n = 0): <none>
[10:19:57.680] {
[10:19:57.680]     {
[10:19:57.680]         {
[10:19:57.680]             ...future.startTime <- base::Sys.time()
[10:19:57.680]             {
[10:19:57.680]                 {
[10:19:57.680]                   {
[10:19:57.680]                     {
[10:19:57.680]                       {
[10:19:57.680]                         base::local({
[10:19:57.680]                           has_future <- base::requireNamespace("future", 
[10:19:57.680]                             quietly = TRUE)
[10:19:57.680]                           if (has_future) {
[10:19:57.680]                             ns <- base::getNamespace("future")
[10:19:57.680]                             version <- ns[[".package"]][["version"]]
[10:19:57.680]                             if (is.null(version)) 
[10:19:57.680]                               version <- utils::packageVersion("future")
[10:19:57.680]                           }
[10:19:57.680]                           else {
[10:19:57.680]                             version <- NULL
[10:19:57.680]                           }
[10:19:57.680]                           if (!has_future || version < "1.8.0") {
[10:19:57.680]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:57.680]                               "", base::R.version$version.string), 
[10:19:57.680]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:57.680]                                 base::R.version$platform, 8 * 
[10:19:57.680]                                   base::.Machine$sizeof.pointer), 
[10:19:57.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:57.680]                                 "release", "version")], collapse = " "), 
[10:19:57.680]                               hostname = base::Sys.info()[["nodename"]])
[10:19:57.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:57.680]                               info)
[10:19:57.680]                             info <- base::paste(info, collapse = "; ")
[10:19:57.680]                             if (!has_future) {
[10:19:57.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:57.680]                                 info)
[10:19:57.680]                             }
[10:19:57.680]                             else {
[10:19:57.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:57.680]                                 info, version)
[10:19:57.680]                             }
[10:19:57.680]                             base::stop(msg)
[10:19:57.680]                           }
[10:19:57.680]                         })
[10:19:57.680]                       }
[10:19:57.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:57.680]                       base::options(mc.cores = 1L)
[10:19:57.680]                     }
[10:19:57.680]                     base::local({
[10:19:57.680]                       for (pkg in c("stats", "future.apply")) {
[10:19:57.680]                         base::loadNamespace(pkg)
[10:19:57.680]                         base::library(pkg, character.only = TRUE)
[10:19:57.680]                       }
[10:19:57.680]                     })
[10:19:57.680]                   }
[10:19:57.680]                   ...future.strategy.old <- future::plan("list")
[10:19:57.680]                   options(future.plan = NULL)
[10:19:57.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:57.680]                 }
[10:19:57.680]                 ...future.workdir <- getwd()
[10:19:57.680]             }
[10:19:57.680]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:57.680]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:57.680]         }
[10:19:57.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:57.680]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:57.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:57.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:57.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:57.680]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:57.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:57.680]             base::names(...future.oldOptions))
[10:19:57.680]     }
[10:19:57.680]     if (FALSE) {
[10:19:57.680]     }
[10:19:57.680]     else {
[10:19:57.680]         if (TRUE) {
[10:19:57.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:57.680]                 open = "w")
[10:19:57.680]         }
[10:19:57.680]         else {
[10:19:57.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:57.680]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:57.680]         }
[10:19:57.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:57.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:57.680]             base::sink(type = "output", split = FALSE)
[10:19:57.680]             base::close(...future.stdout)
[10:19:57.680]         }, add = TRUE)
[10:19:57.680]     }
[10:19:57.680]     ...future.frame <- base::sys.nframe()
[10:19:57.680]     ...future.conditions <- base::list()
[10:19:57.680]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:57.680]     if (FALSE) {
[10:19:57.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:57.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:57.680]     }
[10:19:57.680]     ...future.result <- base::tryCatch({
[10:19:57.680]         base::withCallingHandlers({
[10:19:57.680]             ...future.value <- base::withVisible(base::local({
[10:19:57.680]                 ...future.makeSendCondition <- base::local({
[10:19:57.680]                   sendCondition <- NULL
[10:19:57.680]                   function(frame = 1L) {
[10:19:57.680]                     if (is.function(sendCondition)) 
[10:19:57.680]                       return(sendCondition)
[10:19:57.680]                     ns <- getNamespace("parallel")
[10:19:57.680]                     if (exists("sendData", mode = "function", 
[10:19:57.680]                       envir = ns)) {
[10:19:57.680]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:57.680]                         envir = ns)
[10:19:57.680]                       envir <- sys.frame(frame)
[10:19:57.680]                       master <- NULL
[10:19:57.680]                       while (!identical(envir, .GlobalEnv) && 
[10:19:57.680]                         !identical(envir, emptyenv())) {
[10:19:57.680]                         if (exists("master", mode = "list", envir = envir, 
[10:19:57.680]                           inherits = FALSE)) {
[10:19:57.680]                           master <- get("master", mode = "list", 
[10:19:57.680]                             envir = envir, inherits = FALSE)
[10:19:57.680]                           if (inherits(master, c("SOCKnode", 
[10:19:57.680]                             "SOCK0node"))) {
[10:19:57.680]                             sendCondition <<- function(cond) {
[10:19:57.680]                               data <- list(type = "VALUE", value = cond, 
[10:19:57.680]                                 success = TRUE)
[10:19:57.680]                               parallel_sendData(master, data)
[10:19:57.680]                             }
[10:19:57.680]                             return(sendCondition)
[10:19:57.680]                           }
[10:19:57.680]                         }
[10:19:57.680]                         frame <- frame + 1L
[10:19:57.680]                         envir <- sys.frame(frame)
[10:19:57.680]                       }
[10:19:57.680]                     }
[10:19:57.680]                     sendCondition <<- function(cond) NULL
[10:19:57.680]                   }
[10:19:57.680]                 })
[10:19:57.680]                 withCallingHandlers({
[10:19:57.680]                   {
[10:19:57.680]                     do.call(function(...) {
[10:19:57.680]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.680]                       if (!identical(...future.globals.maxSize.org, 
[10:19:57.680]                         ...future.globals.maxSize)) {
[10:19:57.680]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.680]                         on.exit(options(oopts), add = TRUE)
[10:19:57.680]                       }
[10:19:57.680]                       {
[10:19:57.680]                         lapply(seq_along(...future.elements_ii), 
[10:19:57.680]                           FUN = function(jj) {
[10:19:57.680]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.680]                             ...future.FUN(...future.X_jj, ...)
[10:19:57.680]                           })
[10:19:57.680]                       }
[10:19:57.680]                     }, args = future.call.arguments)
[10:19:57.680]                   }
[10:19:57.680]                 }, immediateCondition = function(cond) {
[10:19:57.680]                   sendCondition <- ...future.makeSendCondition()
[10:19:57.680]                   sendCondition(cond)
[10:19:57.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.680]                   {
[10:19:57.680]                     inherits <- base::inherits
[10:19:57.680]                     invokeRestart <- base::invokeRestart
[10:19:57.680]                     is.null <- base::is.null
[10:19:57.680]                     muffled <- FALSE
[10:19:57.680]                     if (inherits(cond, "message")) {
[10:19:57.680]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:57.680]                       if (muffled) 
[10:19:57.680]                         invokeRestart("muffleMessage")
[10:19:57.680]                     }
[10:19:57.680]                     else if (inherits(cond, "warning")) {
[10:19:57.680]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:57.680]                       if (muffled) 
[10:19:57.680]                         invokeRestart("muffleWarning")
[10:19:57.680]                     }
[10:19:57.680]                     else if (inherits(cond, "condition")) {
[10:19:57.680]                       if (!is.null(pattern)) {
[10:19:57.680]                         computeRestarts <- base::computeRestarts
[10:19:57.680]                         grepl <- base::grepl
[10:19:57.680]                         restarts <- computeRestarts(cond)
[10:19:57.680]                         for (restart in restarts) {
[10:19:57.680]                           name <- restart$name
[10:19:57.680]                           if (is.null(name)) 
[10:19:57.680]                             next
[10:19:57.680]                           if (!grepl(pattern, name)) 
[10:19:57.680]                             next
[10:19:57.680]                           invokeRestart(restart)
[10:19:57.680]                           muffled <- TRUE
[10:19:57.680]                           break
[10:19:57.680]                         }
[10:19:57.680]                       }
[10:19:57.680]                     }
[10:19:57.680]                     invisible(muffled)
[10:19:57.680]                   }
[10:19:57.680]                   muffleCondition(cond)
[10:19:57.680]                 })
[10:19:57.680]             }))
[10:19:57.680]             future::FutureResult(value = ...future.value$value, 
[10:19:57.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.680]                   ...future.rng), globalenv = if (FALSE) 
[10:19:57.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:57.680]                     ...future.globalenv.names))
[10:19:57.680]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:57.680]         }, condition = base::local({
[10:19:57.680]             c <- base::c
[10:19:57.680]             inherits <- base::inherits
[10:19:57.680]             invokeRestart <- base::invokeRestart
[10:19:57.680]             length <- base::length
[10:19:57.680]             list <- base::list
[10:19:57.680]             seq.int <- base::seq.int
[10:19:57.680]             signalCondition <- base::signalCondition
[10:19:57.680]             sys.calls <- base::sys.calls
[10:19:57.680]             `[[` <- base::`[[`
[10:19:57.680]             `+` <- base::`+`
[10:19:57.680]             `<<-` <- base::`<<-`
[10:19:57.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:57.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:57.680]                   3L)]
[10:19:57.680]             }
[10:19:57.680]             function(cond) {
[10:19:57.680]                 is_error <- inherits(cond, "error")
[10:19:57.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:57.680]                   NULL)
[10:19:57.680]                 if (is_error) {
[10:19:57.680]                   sessionInformation <- function() {
[10:19:57.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:57.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:57.680]                       search = base::search(), system = base::Sys.info())
[10:19:57.680]                   }
[10:19:57.680]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:57.680]                     cond$call), session = sessionInformation(), 
[10:19:57.680]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:57.680]                   signalCondition(cond)
[10:19:57.680]                 }
[10:19:57.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:57.680]                 "immediateCondition"))) {
[10:19:57.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:57.680]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:57.680]                   if (TRUE && !signal) {
[10:19:57.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.680]                     {
[10:19:57.680]                       inherits <- base::inherits
[10:19:57.680]                       invokeRestart <- base::invokeRestart
[10:19:57.680]                       is.null <- base::is.null
[10:19:57.680]                       muffled <- FALSE
[10:19:57.680]                       if (inherits(cond, "message")) {
[10:19:57.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.680]                         if (muffled) 
[10:19:57.680]                           invokeRestart("muffleMessage")
[10:19:57.680]                       }
[10:19:57.680]                       else if (inherits(cond, "warning")) {
[10:19:57.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.680]                         if (muffled) 
[10:19:57.680]                           invokeRestart("muffleWarning")
[10:19:57.680]                       }
[10:19:57.680]                       else if (inherits(cond, "condition")) {
[10:19:57.680]                         if (!is.null(pattern)) {
[10:19:57.680]                           computeRestarts <- base::computeRestarts
[10:19:57.680]                           grepl <- base::grepl
[10:19:57.680]                           restarts <- computeRestarts(cond)
[10:19:57.680]                           for (restart in restarts) {
[10:19:57.680]                             name <- restart$name
[10:19:57.680]                             if (is.null(name)) 
[10:19:57.680]                               next
[10:19:57.680]                             if (!grepl(pattern, name)) 
[10:19:57.680]                               next
[10:19:57.680]                             invokeRestart(restart)
[10:19:57.680]                             muffled <- TRUE
[10:19:57.680]                             break
[10:19:57.680]                           }
[10:19:57.680]                         }
[10:19:57.680]                       }
[10:19:57.680]                       invisible(muffled)
[10:19:57.680]                     }
[10:19:57.680]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.680]                   }
[10:19:57.680]                 }
[10:19:57.680]                 else {
[10:19:57.680]                   if (TRUE) {
[10:19:57.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.680]                     {
[10:19:57.680]                       inherits <- base::inherits
[10:19:57.680]                       invokeRestart <- base::invokeRestart
[10:19:57.680]                       is.null <- base::is.null
[10:19:57.680]                       muffled <- FALSE
[10:19:57.680]                       if (inherits(cond, "message")) {
[10:19:57.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.680]                         if (muffled) 
[10:19:57.680]                           invokeRestart("muffleMessage")
[10:19:57.680]                       }
[10:19:57.680]                       else if (inherits(cond, "warning")) {
[10:19:57.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.680]                         if (muffled) 
[10:19:57.680]                           invokeRestart("muffleWarning")
[10:19:57.680]                       }
[10:19:57.680]                       else if (inherits(cond, "condition")) {
[10:19:57.680]                         if (!is.null(pattern)) {
[10:19:57.680]                           computeRestarts <- base::computeRestarts
[10:19:57.680]                           grepl <- base::grepl
[10:19:57.680]                           restarts <- computeRestarts(cond)
[10:19:57.680]                           for (restart in restarts) {
[10:19:57.680]                             name <- restart$name
[10:19:57.680]                             if (is.null(name)) 
[10:19:57.680]                               next
[10:19:57.680]                             if (!grepl(pattern, name)) 
[10:19:57.680]                               next
[10:19:57.680]                             invokeRestart(restart)
[10:19:57.680]                             muffled <- TRUE
[10:19:57.680]                             break
[10:19:57.680]                           }
[10:19:57.680]                         }
[10:19:57.680]                       }
[10:19:57.680]                       invisible(muffled)
[10:19:57.680]                     }
[10:19:57.680]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.680]                   }
[10:19:57.680]                 }
[10:19:57.680]             }
[10:19:57.680]         }))
[10:19:57.680]     }, error = function(ex) {
[10:19:57.680]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:57.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.680]                 ...future.rng), started = ...future.startTime, 
[10:19:57.680]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:57.680]             version = "1.8"), class = "FutureResult")
[10:19:57.680]     }, finally = {
[10:19:57.680]         if (!identical(...future.workdir, getwd())) 
[10:19:57.680]             setwd(...future.workdir)
[10:19:57.680]         {
[10:19:57.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:57.680]                 ...future.oldOptions$nwarnings <- NULL
[10:19:57.680]             }
[10:19:57.680]             base::options(...future.oldOptions)
[10:19:57.680]             if (.Platform$OS.type == "windows") {
[10:19:57.680]                 old_names <- names(...future.oldEnvVars)
[10:19:57.680]                 envs <- base::Sys.getenv()
[10:19:57.680]                 names <- names(envs)
[10:19:57.680]                 common <- intersect(names, old_names)
[10:19:57.680]                 added <- setdiff(names, old_names)
[10:19:57.680]                 removed <- setdiff(old_names, names)
[10:19:57.680]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:57.680]                   envs[common]]
[10:19:57.680]                 NAMES <- toupper(changed)
[10:19:57.680]                 args <- list()
[10:19:57.680]                 for (kk in seq_along(NAMES)) {
[10:19:57.680]                   name <- changed[[kk]]
[10:19:57.680]                   NAME <- NAMES[[kk]]
[10:19:57.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.680]                     next
[10:19:57.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.680]                 }
[10:19:57.680]                 NAMES <- toupper(added)
[10:19:57.680]                 for (kk in seq_along(NAMES)) {
[10:19:57.680]                   name <- added[[kk]]
[10:19:57.680]                   NAME <- NAMES[[kk]]
[10:19:57.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.680]                     next
[10:19:57.680]                   args[[name]] <- ""
[10:19:57.680]                 }
[10:19:57.680]                 NAMES <- toupper(removed)
[10:19:57.680]                 for (kk in seq_along(NAMES)) {
[10:19:57.680]                   name <- removed[[kk]]
[10:19:57.680]                   NAME <- NAMES[[kk]]
[10:19:57.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.680]                     next
[10:19:57.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.680]                 }
[10:19:57.680]                 if (length(args) > 0) 
[10:19:57.680]                   base::do.call(base::Sys.setenv, args = args)
[10:19:57.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:57.680]             }
[10:19:57.680]             else {
[10:19:57.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:57.680]             }
[10:19:57.680]             {
[10:19:57.680]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:57.680]                   0L) {
[10:19:57.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:57.680]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:57.680]                   base::options(opts)
[10:19:57.680]                 }
[10:19:57.680]                 {
[10:19:57.680]                   {
[10:19:57.680]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:57.680]                     NULL
[10:19:57.680]                   }
[10:19:57.680]                   options(future.plan = NULL)
[10:19:57.680]                   if (is.na(NA_character_)) 
[10:19:57.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:57.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:57.680]                     .init = FALSE)
[10:19:57.680]                 }
[10:19:57.680]             }
[10:19:57.680]         }
[10:19:57.680]     })
[10:19:57.680]     if (TRUE) {
[10:19:57.680]         base::sink(type = "output", split = FALSE)
[10:19:57.680]         if (TRUE) {
[10:19:57.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:57.680]         }
[10:19:57.680]         else {
[10:19:57.680]             ...future.result["stdout"] <- base::list(NULL)
[10:19:57.680]         }
[10:19:57.680]         base::close(...future.stdout)
[10:19:57.680]         ...future.stdout <- NULL
[10:19:57.680]     }
[10:19:57.680]     ...future.result$conditions <- ...future.conditions
[10:19:57.680]     ...future.result$finished <- base::Sys.time()
[10:19:57.680]     ...future.result
[10:19:57.680] }
[10:19:57.683] Exporting 11 global objects (13.46 KiB) to cluster node #1 ...
[10:19:57.683] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #1 ...
[10:19:57.724] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #1 ... DONE
[10:19:57.725] Exporting ‘x_FUN’ (311 bytes) to cluster node #1 ...
[10:19:57.725] Exporting ‘x_FUN’ (311 bytes) to cluster node #1 ... DONE
[10:19:57.725] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:57.725] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:57.726] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:57.766] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:57.767] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:57.807] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:57.808] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:57.808] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:57.808] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:57.808] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:57.809] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:57.809] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:57.809] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ...
[10:19:57.809] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ... DONE
[10:19:57.810] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:57.810] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:57.810] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:57.810] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:57.810] Exporting 11 global objects (13.46 KiB) to cluster node #1 ... DONE
[10:19:57.811] MultisessionFuture started
[10:19:57.811] - Launch lazy future ... done
[10:19:57.811] run() for ‘MultisessionFuture’ ... done
[10:19:57.811] Created future:
[10:19:57.811] MultisessionFuture:
[10:19:57.811] Label: ‘future_vapply-1’
[10:19:57.811] Expression:
[10:19:57.811] {
[10:19:57.811]     do.call(function(...) {
[10:19:57.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.811]             on.exit(options(oopts), add = TRUE)
[10:19:57.811]         }
[10:19:57.811]         {
[10:19:57.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.811]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.811]             })
[10:19:57.811]         }
[10:19:57.811]     }, args = future.call.arguments)
[10:19:57.811] }
[10:19:57.811] Lazy evaluation: FALSE
[10:19:57.811] Asynchronous evaluation: TRUE
[10:19:57.811] Local evaluation: TRUE
[10:19:57.811] Environment: R_GlobalEnv
[10:19:57.811] Capture standard output: TRUE
[10:19:57.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:57.811] Globals: 11 objects totaling 13.35 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:57.811] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:57.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:57.811] Resolved: FALSE
[10:19:57.811] Value: <not collected>
[10:19:57.811] Conditions captured: <none>
[10:19:57.811] Early signaling: FALSE
[10:19:57.811] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:57.811] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.823] Chunk #1 of 2 ... DONE
[10:19:57.823] Chunk #2 of 2 ...
[10:19:57.823]  - Finding globals in 'X' for chunk #2 ...
[10:19:57.823] getGlobalsAndPackages() ...
[10:19:57.823] Searching for globals...
[10:19:57.823] 
[10:19:57.824] Searching for globals ... DONE
[10:19:57.824] - globals: [0] <none>
[10:19:57.824] getGlobalsAndPackages() ... DONE
[10:19:57.824]    + additional globals found: [n=0] 
[10:19:57.824]    + additional namespaces needed: [n=0] 
[10:19:57.824]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:57.824]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:57.824]  - seeds: <none>
[10:19:57.824]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.824] getGlobalsAndPackages() ...
[10:19:57.824] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.825] Resolving globals: FALSE
[10:19:57.825] Tweak future expression to call with '...' arguments ...
[10:19:57.825] {
[10:19:57.825]     do.call(function(...) {
[10:19:57.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.825]             on.exit(options(oopts), add = TRUE)
[10:19:57.825]         }
[10:19:57.825]         {
[10:19:57.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.825]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.825]             })
[10:19:57.825]         }
[10:19:57.825]     }, args = future.call.arguments)
[10:19:57.825] }
[10:19:57.825] Tweak future expression to call with '...' arguments ... DONE
[10:19:57.825] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:57.826] - packages: [2] ‘stats’, ‘future.apply’
[10:19:57.826] getGlobalsAndPackages() ... DONE
[10:19:57.826] run() for ‘Future’ ...
[10:19:57.826] - state: ‘created’
[10:19:57.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:57.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:57.840]   - Field: ‘node’
[10:19:57.840]   - Field: ‘label’
[10:19:57.840]   - Field: ‘local’
[10:19:57.840]   - Field: ‘owner’
[10:19:57.841]   - Field: ‘envir’
[10:19:57.841]   - Field: ‘workers’
[10:19:57.841]   - Field: ‘packages’
[10:19:57.841]   - Field: ‘gc’
[10:19:57.841]   - Field: ‘conditions’
[10:19:57.841]   - Field: ‘persistent’
[10:19:57.841]   - Field: ‘expr’
[10:19:57.841]   - Field: ‘uuid’
[10:19:57.841]   - Field: ‘seed’
[10:19:57.841]   - Field: ‘version’
[10:19:57.841]   - Field: ‘result’
[10:19:57.842]   - Field: ‘asynchronous’
[10:19:57.842]   - Field: ‘calls’
[10:19:57.842]   - Field: ‘globals’
[10:19:57.842]   - Field: ‘stdout’
[10:19:57.842]   - Field: ‘earlySignal’
[10:19:57.842]   - Field: ‘lazy’
[10:19:57.842]   - Field: ‘state’
[10:19:57.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:57.842] - Launch lazy future ...
[10:19:57.842] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:57.843] Packages needed by future strategies (n = 0): <none>
[10:19:57.843] {
[10:19:57.843]     {
[10:19:57.843]         {
[10:19:57.843]             ...future.startTime <- base::Sys.time()
[10:19:57.843]             {
[10:19:57.843]                 {
[10:19:57.843]                   {
[10:19:57.843]                     {
[10:19:57.843]                       {
[10:19:57.843]                         base::local({
[10:19:57.843]                           has_future <- base::requireNamespace("future", 
[10:19:57.843]                             quietly = TRUE)
[10:19:57.843]                           if (has_future) {
[10:19:57.843]                             ns <- base::getNamespace("future")
[10:19:57.843]                             version <- ns[[".package"]][["version"]]
[10:19:57.843]                             if (is.null(version)) 
[10:19:57.843]                               version <- utils::packageVersion("future")
[10:19:57.843]                           }
[10:19:57.843]                           else {
[10:19:57.843]                             version <- NULL
[10:19:57.843]                           }
[10:19:57.843]                           if (!has_future || version < "1.8.0") {
[10:19:57.843]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:57.843]                               "", base::R.version$version.string), 
[10:19:57.843]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:57.843]                                 base::R.version$platform, 8 * 
[10:19:57.843]                                   base::.Machine$sizeof.pointer), 
[10:19:57.843]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:57.843]                                 "release", "version")], collapse = " "), 
[10:19:57.843]                               hostname = base::Sys.info()[["nodename"]])
[10:19:57.843]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:57.843]                               info)
[10:19:57.843]                             info <- base::paste(info, collapse = "; ")
[10:19:57.843]                             if (!has_future) {
[10:19:57.843]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:57.843]                                 info)
[10:19:57.843]                             }
[10:19:57.843]                             else {
[10:19:57.843]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:57.843]                                 info, version)
[10:19:57.843]                             }
[10:19:57.843]                             base::stop(msg)
[10:19:57.843]                           }
[10:19:57.843]                         })
[10:19:57.843]                       }
[10:19:57.843]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:57.843]                       base::options(mc.cores = 1L)
[10:19:57.843]                     }
[10:19:57.843]                     base::local({
[10:19:57.843]                       for (pkg in c("stats", "future.apply")) {
[10:19:57.843]                         base::loadNamespace(pkg)
[10:19:57.843]                         base::library(pkg, character.only = TRUE)
[10:19:57.843]                       }
[10:19:57.843]                     })
[10:19:57.843]                   }
[10:19:57.843]                   ...future.strategy.old <- future::plan("list")
[10:19:57.843]                   options(future.plan = NULL)
[10:19:57.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:57.843]                 }
[10:19:57.843]                 ...future.workdir <- getwd()
[10:19:57.843]             }
[10:19:57.843]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:57.843]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:57.843]         }
[10:19:57.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:57.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:57.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:57.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:57.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:57.843]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:57.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:57.843]             base::names(...future.oldOptions))
[10:19:57.843]     }
[10:19:57.843]     if (FALSE) {
[10:19:57.843]     }
[10:19:57.843]     else {
[10:19:57.843]         if (TRUE) {
[10:19:57.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:57.843]                 open = "w")
[10:19:57.843]         }
[10:19:57.843]         else {
[10:19:57.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:57.843]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:57.843]         }
[10:19:57.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:57.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:57.843]             base::sink(type = "output", split = FALSE)
[10:19:57.843]             base::close(...future.stdout)
[10:19:57.843]         }, add = TRUE)
[10:19:57.843]     }
[10:19:57.843]     ...future.frame <- base::sys.nframe()
[10:19:57.843]     ...future.conditions <- base::list()
[10:19:57.843]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:57.843]     if (FALSE) {
[10:19:57.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:57.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:57.843]     }
[10:19:57.843]     ...future.result <- base::tryCatch({
[10:19:57.843]         base::withCallingHandlers({
[10:19:57.843]             ...future.value <- base::withVisible(base::local({
[10:19:57.843]                 ...future.makeSendCondition <- base::local({
[10:19:57.843]                   sendCondition <- NULL
[10:19:57.843]                   function(frame = 1L) {
[10:19:57.843]                     if (is.function(sendCondition)) 
[10:19:57.843]                       return(sendCondition)
[10:19:57.843]                     ns <- getNamespace("parallel")
[10:19:57.843]                     if (exists("sendData", mode = "function", 
[10:19:57.843]                       envir = ns)) {
[10:19:57.843]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:57.843]                         envir = ns)
[10:19:57.843]                       envir <- sys.frame(frame)
[10:19:57.843]                       master <- NULL
[10:19:57.843]                       while (!identical(envir, .GlobalEnv) && 
[10:19:57.843]                         !identical(envir, emptyenv())) {
[10:19:57.843]                         if (exists("master", mode = "list", envir = envir, 
[10:19:57.843]                           inherits = FALSE)) {
[10:19:57.843]                           master <- get("master", mode = "list", 
[10:19:57.843]                             envir = envir, inherits = FALSE)
[10:19:57.843]                           if (inherits(master, c("SOCKnode", 
[10:19:57.843]                             "SOCK0node"))) {
[10:19:57.843]                             sendCondition <<- function(cond) {
[10:19:57.843]                               data <- list(type = "VALUE", value = cond, 
[10:19:57.843]                                 success = TRUE)
[10:19:57.843]                               parallel_sendData(master, data)
[10:19:57.843]                             }
[10:19:57.843]                             return(sendCondition)
[10:19:57.843]                           }
[10:19:57.843]                         }
[10:19:57.843]                         frame <- frame + 1L
[10:19:57.843]                         envir <- sys.frame(frame)
[10:19:57.843]                       }
[10:19:57.843]                     }
[10:19:57.843]                     sendCondition <<- function(cond) NULL
[10:19:57.843]                   }
[10:19:57.843]                 })
[10:19:57.843]                 withCallingHandlers({
[10:19:57.843]                   {
[10:19:57.843]                     do.call(function(...) {
[10:19:57.843]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.843]                       if (!identical(...future.globals.maxSize.org, 
[10:19:57.843]                         ...future.globals.maxSize)) {
[10:19:57.843]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.843]                         on.exit(options(oopts), add = TRUE)
[10:19:57.843]                       }
[10:19:57.843]                       {
[10:19:57.843]                         lapply(seq_along(...future.elements_ii), 
[10:19:57.843]                           FUN = function(jj) {
[10:19:57.843]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.843]                             ...future.FUN(...future.X_jj, ...)
[10:19:57.843]                           })
[10:19:57.843]                       }
[10:19:57.843]                     }, args = future.call.arguments)
[10:19:57.843]                   }
[10:19:57.843]                 }, immediateCondition = function(cond) {
[10:19:57.843]                   sendCondition <- ...future.makeSendCondition()
[10:19:57.843]                   sendCondition(cond)
[10:19:57.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.843]                   {
[10:19:57.843]                     inherits <- base::inherits
[10:19:57.843]                     invokeRestart <- base::invokeRestart
[10:19:57.843]                     is.null <- base::is.null
[10:19:57.843]                     muffled <- FALSE
[10:19:57.843]                     if (inherits(cond, "message")) {
[10:19:57.843]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:57.843]                       if (muffled) 
[10:19:57.843]                         invokeRestart("muffleMessage")
[10:19:57.843]                     }
[10:19:57.843]                     else if (inherits(cond, "warning")) {
[10:19:57.843]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:57.843]                       if (muffled) 
[10:19:57.843]                         invokeRestart("muffleWarning")
[10:19:57.843]                     }
[10:19:57.843]                     else if (inherits(cond, "condition")) {
[10:19:57.843]                       if (!is.null(pattern)) {
[10:19:57.843]                         computeRestarts <- base::computeRestarts
[10:19:57.843]                         grepl <- base::grepl
[10:19:57.843]                         restarts <- computeRestarts(cond)
[10:19:57.843]                         for (restart in restarts) {
[10:19:57.843]                           name <- restart$name
[10:19:57.843]                           if (is.null(name)) 
[10:19:57.843]                             next
[10:19:57.843]                           if (!grepl(pattern, name)) 
[10:19:57.843]                             next
[10:19:57.843]                           invokeRestart(restart)
[10:19:57.843]                           muffled <- TRUE
[10:19:57.843]                           break
[10:19:57.843]                         }
[10:19:57.843]                       }
[10:19:57.843]                     }
[10:19:57.843]                     invisible(muffled)
[10:19:57.843]                   }
[10:19:57.843]                   muffleCondition(cond)
[10:19:57.843]                 })
[10:19:57.843]             }))
[10:19:57.843]             future::FutureResult(value = ...future.value$value, 
[10:19:57.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.843]                   ...future.rng), globalenv = if (FALSE) 
[10:19:57.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:57.843]                     ...future.globalenv.names))
[10:19:57.843]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:57.843]         }, condition = base::local({
[10:19:57.843]             c <- base::c
[10:19:57.843]             inherits <- base::inherits
[10:19:57.843]             invokeRestart <- base::invokeRestart
[10:19:57.843]             length <- base::length
[10:19:57.843]             list <- base::list
[10:19:57.843]             seq.int <- base::seq.int
[10:19:57.843]             signalCondition <- base::signalCondition
[10:19:57.843]             sys.calls <- base::sys.calls
[10:19:57.843]             `[[` <- base::`[[`
[10:19:57.843]             `+` <- base::`+`
[10:19:57.843]             `<<-` <- base::`<<-`
[10:19:57.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:57.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:57.843]                   3L)]
[10:19:57.843]             }
[10:19:57.843]             function(cond) {
[10:19:57.843]                 is_error <- inherits(cond, "error")
[10:19:57.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:57.843]                   NULL)
[10:19:57.843]                 if (is_error) {
[10:19:57.843]                   sessionInformation <- function() {
[10:19:57.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:57.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:57.843]                       search = base::search(), system = base::Sys.info())
[10:19:57.843]                   }
[10:19:57.843]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:57.843]                     cond$call), session = sessionInformation(), 
[10:19:57.843]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:57.843]                   signalCondition(cond)
[10:19:57.843]                 }
[10:19:57.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:57.843]                 "immediateCondition"))) {
[10:19:57.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:57.843]                   ...future.conditions[[length(...future.conditions) + 
[10:19:57.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:57.843]                   if (TRUE && !signal) {
[10:19:57.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.843]                     {
[10:19:57.843]                       inherits <- base::inherits
[10:19:57.843]                       invokeRestart <- base::invokeRestart
[10:19:57.843]                       is.null <- base::is.null
[10:19:57.843]                       muffled <- FALSE
[10:19:57.843]                       if (inherits(cond, "message")) {
[10:19:57.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.843]                         if (muffled) 
[10:19:57.843]                           invokeRestart("muffleMessage")
[10:19:57.843]                       }
[10:19:57.843]                       else if (inherits(cond, "warning")) {
[10:19:57.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.843]                         if (muffled) 
[10:19:57.843]                           invokeRestart("muffleWarning")
[10:19:57.843]                       }
[10:19:57.843]                       else if (inherits(cond, "condition")) {
[10:19:57.843]                         if (!is.null(pattern)) {
[10:19:57.843]                           computeRestarts <- base::computeRestarts
[10:19:57.843]                           grepl <- base::grepl
[10:19:57.843]                           restarts <- computeRestarts(cond)
[10:19:57.843]                           for (restart in restarts) {
[10:19:57.843]                             name <- restart$name
[10:19:57.843]                             if (is.null(name)) 
[10:19:57.843]                               next
[10:19:57.843]                             if (!grepl(pattern, name)) 
[10:19:57.843]                               next
[10:19:57.843]                             invokeRestart(restart)
[10:19:57.843]                             muffled <- TRUE
[10:19:57.843]                             break
[10:19:57.843]                           }
[10:19:57.843]                         }
[10:19:57.843]                       }
[10:19:57.843]                       invisible(muffled)
[10:19:57.843]                     }
[10:19:57.843]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.843]                   }
[10:19:57.843]                 }
[10:19:57.843]                 else {
[10:19:57.843]                   if (TRUE) {
[10:19:57.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:57.843]                     {
[10:19:57.843]                       inherits <- base::inherits
[10:19:57.843]                       invokeRestart <- base::invokeRestart
[10:19:57.843]                       is.null <- base::is.null
[10:19:57.843]                       muffled <- FALSE
[10:19:57.843]                       if (inherits(cond, "message")) {
[10:19:57.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:57.843]                         if (muffled) 
[10:19:57.843]                           invokeRestart("muffleMessage")
[10:19:57.843]                       }
[10:19:57.843]                       else if (inherits(cond, "warning")) {
[10:19:57.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:57.843]                         if (muffled) 
[10:19:57.843]                           invokeRestart("muffleWarning")
[10:19:57.843]                       }
[10:19:57.843]                       else if (inherits(cond, "condition")) {
[10:19:57.843]                         if (!is.null(pattern)) {
[10:19:57.843]                           computeRestarts <- base::computeRestarts
[10:19:57.843]                           grepl <- base::grepl
[10:19:57.843]                           restarts <- computeRestarts(cond)
[10:19:57.843]                           for (restart in restarts) {
[10:19:57.843]                             name <- restart$name
[10:19:57.843]                             if (is.null(name)) 
[10:19:57.843]                               next
[10:19:57.843]                             if (!grepl(pattern, name)) 
[10:19:57.843]                               next
[10:19:57.843]                             invokeRestart(restart)
[10:19:57.843]                             muffled <- TRUE
[10:19:57.843]                             break
[10:19:57.843]                           }
[10:19:57.843]                         }
[10:19:57.843]                       }
[10:19:57.843]                       invisible(muffled)
[10:19:57.843]                     }
[10:19:57.843]                     muffleCondition(cond, pattern = "^muffle")
[10:19:57.843]                   }
[10:19:57.843]                 }
[10:19:57.843]             }
[10:19:57.843]         }))
[10:19:57.843]     }, error = function(ex) {
[10:19:57.843]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:57.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:57.843]                 ...future.rng), started = ...future.startTime, 
[10:19:57.843]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:57.843]             version = "1.8"), class = "FutureResult")
[10:19:57.843]     }, finally = {
[10:19:57.843]         if (!identical(...future.workdir, getwd())) 
[10:19:57.843]             setwd(...future.workdir)
[10:19:57.843]         {
[10:19:57.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:57.843]                 ...future.oldOptions$nwarnings <- NULL
[10:19:57.843]             }
[10:19:57.843]             base::options(...future.oldOptions)
[10:19:57.843]             if (.Platform$OS.type == "windows") {
[10:19:57.843]                 old_names <- names(...future.oldEnvVars)
[10:19:57.843]                 envs <- base::Sys.getenv()
[10:19:57.843]                 names <- names(envs)
[10:19:57.843]                 common <- intersect(names, old_names)
[10:19:57.843]                 added <- setdiff(names, old_names)
[10:19:57.843]                 removed <- setdiff(old_names, names)
[10:19:57.843]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:57.843]                   envs[common]]
[10:19:57.843]                 NAMES <- toupper(changed)
[10:19:57.843]                 args <- list()
[10:19:57.843]                 for (kk in seq_along(NAMES)) {
[10:19:57.843]                   name <- changed[[kk]]
[10:19:57.843]                   NAME <- NAMES[[kk]]
[10:19:57.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.843]                     next
[10:19:57.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.843]                 }
[10:19:57.843]                 NAMES <- toupper(added)
[10:19:57.843]                 for (kk in seq_along(NAMES)) {
[10:19:57.843]                   name <- added[[kk]]
[10:19:57.843]                   NAME <- NAMES[[kk]]
[10:19:57.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.843]                     next
[10:19:57.843]                   args[[name]] <- ""
[10:19:57.843]                 }
[10:19:57.843]                 NAMES <- toupper(removed)
[10:19:57.843]                 for (kk in seq_along(NAMES)) {
[10:19:57.843]                   name <- removed[[kk]]
[10:19:57.843]                   NAME <- NAMES[[kk]]
[10:19:57.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:57.843]                     next
[10:19:57.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:57.843]                 }
[10:19:57.843]                 if (length(args) > 0) 
[10:19:57.843]                   base::do.call(base::Sys.setenv, args = args)
[10:19:57.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:57.843]             }
[10:19:57.843]             else {
[10:19:57.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:57.843]             }
[10:19:57.843]             {
[10:19:57.843]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:57.843]                   0L) {
[10:19:57.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:57.843]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:57.843]                   base::options(opts)
[10:19:57.843]                 }
[10:19:57.843]                 {
[10:19:57.843]                   {
[10:19:57.843]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:57.843]                     NULL
[10:19:57.843]                   }
[10:19:57.843]                   options(future.plan = NULL)
[10:19:57.843]                   if (is.na(NA_character_)) 
[10:19:57.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:57.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:57.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:57.843]                     .init = FALSE)
[10:19:57.843]                 }
[10:19:57.843]             }
[10:19:57.843]         }
[10:19:57.843]     })
[10:19:57.843]     if (TRUE) {
[10:19:57.843]         base::sink(type = "output", split = FALSE)
[10:19:57.843]         if (TRUE) {
[10:19:57.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:57.843]         }
[10:19:57.843]         else {
[10:19:57.843]             ...future.result["stdout"] <- base::list(NULL)
[10:19:57.843]         }
[10:19:57.843]         base::close(...future.stdout)
[10:19:57.843]         ...future.stdout <- NULL
[10:19:57.843]     }
[10:19:57.843]     ...future.result$conditions <- ...future.conditions
[10:19:57.843]     ...future.result$finished <- base::Sys.time()
[10:19:57.843]     ...future.result
[10:19:57.843] }
[10:19:57.846] Exporting 11 global objects (13.49 KiB) to cluster node #2 ...
[10:19:57.846] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #2 ...
[10:19:57.887] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #2 ... DONE
[10:19:57.888] Exporting ‘x_FUN’ (311 bytes) to cluster node #2 ...
[10:19:57.888] Exporting ‘x_FUN’ (311 bytes) to cluster node #2 ... DONE
[10:19:57.888] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:57.889] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:57.889] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:57.929] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:57.930] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:57.970] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:57.971] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:57.971] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:57.971] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:57.972] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:57.972] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:57.972] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:57.972] Exporting ‘...future.elements_ii’ (177 bytes) to cluster node #2 ...
[10:19:57.973] Exporting ‘...future.elements_ii’ (177 bytes) to cluster node #2 ... DONE
[10:19:57.973] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:57.973] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:57.973] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:57.973] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:57.974] Exporting 11 global objects (13.49 KiB) to cluster node #2 ... DONE
[10:19:57.974] MultisessionFuture started
[10:19:57.974] - Launch lazy future ... done
[10:19:57.974] run() for ‘MultisessionFuture’ ... done
[10:19:57.974] Created future:
[10:19:57.974] MultisessionFuture:
[10:19:57.974] Label: ‘future_vapply-2’
[10:19:57.974] Expression:
[10:19:57.974] {
[10:19:57.974]     do.call(function(...) {
[10:19:57.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:57.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:57.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:57.974]             on.exit(options(oopts), add = TRUE)
[10:19:57.974]         }
[10:19:57.974]         {
[10:19:57.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:57.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:57.974]                 ...future.FUN(...future.X_jj, ...)
[10:19:57.974]             })
[10:19:57.974]         }
[10:19:57.974]     }, args = future.call.arguments)
[10:19:57.974] }
[10:19:57.974] Lazy evaluation: FALSE
[10:19:57.974] Asynchronous evaluation: TRUE
[10:19:57.974] Local evaluation: TRUE
[10:19:57.974] Environment: R_GlobalEnv
[10:19:57.974] Capture standard output: TRUE
[10:19:57.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:57.974] Globals: 11 objects totaling 13.34 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:57.974] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:57.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:57.974] Resolved: FALSE
[10:19:57.974] Value: <not collected>
[10:19:57.974] Conditions captured: <none>
[10:19:57.974] Early signaling: FALSE
[10:19:57.974] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:57.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:57.986] Chunk #2 of 2 ... DONE
[10:19:57.986] Launching 2 futures (chunks) ... DONE
[10:19:57.986] Resolving 2 futures (chunks) ...
[10:19:57.986] resolve() on list ...
[10:19:57.986]  recursive: 0
[10:19:57.987]  length: 2
[10:19:57.987] 
[10:19:57.987] receiveMessageFromWorker() for ClusterFuture ...
[10:19:57.987] - Validating connection of MultisessionFuture
[10:19:57.987] - received message: FutureResult
[10:19:57.987] - Received FutureResult
[10:19:57.988] - Erased future from FutureRegistry
[10:19:57.988] result() for ClusterFuture ...
[10:19:57.988] - result already collected: FutureResult
[10:19:57.988] result() for ClusterFuture ... done
[10:19:57.988] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:57.988] Future #1
[10:19:57.988] result() for ClusterFuture ...
[10:19:57.988] - result already collected: FutureResult
[10:19:57.988] result() for ClusterFuture ... done
[10:19:57.988] result() for ClusterFuture ...
[10:19:57.988] - result already collected: FutureResult
[10:19:57.988] result() for ClusterFuture ... done
[10:19:57.989] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:57.989] - nx: 2
[10:19:57.989] - relay: TRUE
[10:19:57.989] - stdout: TRUE
[10:19:57.989] - signal: TRUE
[10:19:57.989] - resignal: FALSE
[10:19:57.989] - force: TRUE
[10:19:57.989] - relayed: [n=2] FALSE, FALSE
[10:19:57.989] - queued futures: [n=2] FALSE, FALSE
[10:19:57.989]  - until=1
[10:19:57.989]  - relaying element #1
[10:19:57.989] result() for ClusterFuture ...
[10:19:57.990] - result already collected: FutureResult
[10:19:57.990] result() for ClusterFuture ... done
[10:19:57.990] result() for ClusterFuture ...
[10:19:57.990] - result already collected: FutureResult
[10:19:57.990] result() for ClusterFuture ... done
[10:19:57.990] result() for ClusterFuture ...
[10:19:57.990] - result already collected: FutureResult
[10:19:57.990] result() for ClusterFuture ... done
[10:19:57.990] result() for ClusterFuture ...
[10:19:57.990] - result already collected: FutureResult
[10:19:57.990] result() for ClusterFuture ... done
[10:19:57.990] - relayed: [n=2] TRUE, FALSE
[10:19:57.990] - queued futures: [n=2] TRUE, FALSE
[10:19:57.991] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:57.991]  length: 1 (resolved future 1)
[10:19:58.018] receiveMessageFromWorker() for ClusterFuture ...
[10:19:58.018] - Validating connection of MultisessionFuture
[10:19:58.018] - received message: FutureResult
[10:19:58.019] - Received FutureResult
[10:19:58.019] - Erased future from FutureRegistry
[10:19:58.019] result() for ClusterFuture ...
[10:19:58.019] - result already collected: FutureResult
[10:19:58.019] result() for ClusterFuture ... done
[10:19:58.019] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:58.019] Future #2
[10:19:58.019] result() for ClusterFuture ...
[10:19:58.019] - result already collected: FutureResult
[10:19:58.020] result() for ClusterFuture ... done
[10:19:58.020] result() for ClusterFuture ...
[10:19:58.020] - result already collected: FutureResult
[10:19:58.020] result() for ClusterFuture ... done
[10:19:58.020] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:58.020] - nx: 2
[10:19:58.020] - relay: TRUE
[10:19:58.020] - stdout: TRUE
[10:19:58.020] - signal: TRUE
[10:19:58.020] - resignal: FALSE
[10:19:58.020] - force: TRUE
[10:19:58.020] - relayed: [n=2] TRUE, FALSE
[10:19:58.021] - queued futures: [n=2] TRUE, FALSE
[10:19:58.021]  - until=2
[10:19:58.021]  - relaying element #2
[10:19:58.021] result() for ClusterFuture ...
[10:19:58.021] - result already collected: FutureResult
[10:19:58.021] result() for ClusterFuture ... done
[10:19:58.021] result() for ClusterFuture ...
[10:19:58.021] - result already collected: FutureResult
[10:19:58.021] result() for ClusterFuture ... done
[10:19:58.021] result() for ClusterFuture ...
[10:19:58.021] - result already collected: FutureResult
[10:19:58.021] result() for ClusterFuture ... done
[10:19:58.022] result() for ClusterFuture ...
[10:19:58.022] - result already collected: FutureResult
[10:19:58.022] result() for ClusterFuture ... done
[10:19:58.022] - relayed: [n=2] TRUE, TRUE
[10:19:58.022] - queued futures: [n=2] TRUE, TRUE
[10:19:58.022] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:58.022]  length: 0 (resolved future 2)
[10:19:58.022] Relaying remaining futures
[10:19:58.022] signalConditionsASAP(NULL, pos=0) ...
[10:19:58.022] - nx: 2
[10:19:58.022] - relay: TRUE
[10:19:58.022] - stdout: TRUE
[10:19:58.022] - signal: TRUE
[10:19:58.023] - resignal: FALSE
[10:19:58.023] - force: TRUE
[10:19:58.023] - relayed: [n=2] TRUE, TRUE
[10:19:58.023] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:58.023] - relayed: [n=2] TRUE, TRUE
[10:19:58.023] - queued futures: [n=2] TRUE, TRUE
[10:19:58.023] signalConditionsASAP(NULL, pos=0) ... done
[10:19:58.023] resolve() on list ... DONE
[10:19:58.023] result() for ClusterFuture ...
[10:19:58.023] - result already collected: FutureResult
[10:19:58.023] result() for ClusterFuture ... done
[10:19:58.024] result() for ClusterFuture ...
[10:19:58.024] - result already collected: FutureResult
[10:19:58.024] result() for ClusterFuture ... done
[10:19:58.024] result() for ClusterFuture ...
[10:19:58.024] - result already collected: FutureResult
[10:19:58.024] result() for ClusterFuture ... done
[10:19:58.024] result() for ClusterFuture ...
[10:19:58.024] - result already collected: FutureResult
[10:19:58.024] result() for ClusterFuture ... done
[10:19:58.024]  - Number of value chunks collected: 2
[10:19:58.024] Resolving 2 futures (chunks) ... DONE
[10:19:58.024] Reducing values from 2 chunks ...
[10:19:58.025]  - Number of values collected after concatenation: 3
[10:19:58.025]  - Number of values expected: 3
[10:19:58.025] Reducing values from 2 chunks ... DONE
[10:19:58.025] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:19:58.026] future_lapply() ...
[10:19:58.071] Number of chunks: 2
[10:19:58.072] getGlobalsAndPackagesXApply() ...
[10:19:58.072]  - future.globals: TRUE
[10:19:58.072] getGlobalsAndPackages() ...
[10:19:58.072] Searching for globals...
[10:19:58.076] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:19:58.076] Searching for globals ... DONE
[10:19:58.077] Resolving globals: FALSE
[10:19:58.077] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[10:19:58.078] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[10:19:58.078] - globals: [1] ‘FUN’
[10:19:58.078] - packages: [1] ‘stats’
[10:19:58.078] getGlobalsAndPackages() ... DONE
[10:19:58.078]  - globals found/used: [n=1] ‘FUN’
[10:19:58.078]  - needed namespaces: [n=1] ‘stats’
[10:19:58.078] Finding globals ... DONE
[10:19:58.078]  - use_args: TRUE
[10:19:58.078]  - Getting '...' globals ...
[10:19:58.079] resolve() on list ...
[10:19:58.079]  recursive: 0
[10:19:58.079]  length: 1
[10:19:58.079]  elements: ‘...’
[10:19:58.079]  length: 0 (resolved future 1)
[10:19:58.079] resolve() on list ... DONE
[10:19:58.079]    - '...' content: [n=0] 
[10:19:58.079] List of 1
[10:19:58.079]  $ ...: list()
[10:19:58.079]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.079]  - attr(*, "where")=List of 1
[10:19:58.079]   ..$ ...:<environment: 0x55c6a2b5be48> 
[10:19:58.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.079]  - attr(*, "resolved")= logi TRUE
[10:19:58.079]  - attr(*, "total_size")= num NA
[10:19:58.082]  - Getting '...' globals ... DONE
[10:19:58.082] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:19:58.082] List of 2
[10:19:58.082]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:19:58.082]  $ ...          : list()
[10:19:58.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.082]  - attr(*, "where")=List of 2
[10:19:58.082]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:58.082]   ..$ ...          :<environment: 0x55c6a2b5be48> 
[10:19:58.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.082]  - attr(*, "resolved")= logi FALSE
[10:19:58.082]  - attr(*, "total_size")= num 18895
[10:19:58.084] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:58.084] getGlobalsAndPackagesXApply() ... DONE
[10:19:58.085] Number of futures (= number of chunks): 2
[10:19:58.085] Launching 2 futures (chunks) ...
[10:19:58.085] Chunk #1 of 2 ...
[10:19:58.085]  - Finding globals in 'X' for chunk #1 ...
[10:19:58.085] getGlobalsAndPackages() ...
[10:19:58.085] Searching for globals...
[10:19:58.085] 
[10:19:58.085] Searching for globals ... DONE
[10:19:58.086] - globals: [0] <none>
[10:19:58.086] getGlobalsAndPackages() ... DONE
[10:19:58.086]    + additional globals found: [n=0] 
[10:19:58.086]    + additional namespaces needed: [n=0] 
[10:19:58.086]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:58.086]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:58.086]  - seeds: <none>
[10:19:58.086]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.086] getGlobalsAndPackages() ...
[10:19:58.086] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.086] Resolving globals: FALSE
[10:19:58.086] Tweak future expression to call with '...' arguments ...
[10:19:58.087] {
[10:19:58.087]     do.call(function(...) {
[10:19:58.087]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.087]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.087]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.087]             on.exit(options(oopts), add = TRUE)
[10:19:58.087]         }
[10:19:58.087]         {
[10:19:58.087]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.087]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.087]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.087]             })
[10:19:58.087]         }
[10:19:58.087]     }, args = future.call.arguments)
[10:19:58.087] }
[10:19:58.087] Tweak future expression to call with '...' arguments ... DONE
[10:19:58.087] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.087] - packages: [1] ‘stats’
[10:19:58.087] getGlobalsAndPackages() ... DONE
[10:19:58.088] run() for ‘Future’ ...
[10:19:58.088] - state: ‘created’
[10:19:58.088] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:58.101] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:58.102]   - Field: ‘node’
[10:19:58.102]   - Field: ‘label’
[10:19:58.102]   - Field: ‘local’
[10:19:58.102]   - Field: ‘owner’
[10:19:58.102]   - Field: ‘envir’
[10:19:58.102]   - Field: ‘workers’
[10:19:58.102]   - Field: ‘packages’
[10:19:58.102]   - Field: ‘gc’
[10:19:58.102]   - Field: ‘conditions’
[10:19:58.102]   - Field: ‘persistent’
[10:19:58.103]   - Field: ‘expr’
[10:19:58.103]   - Field: ‘uuid’
[10:19:58.103]   - Field: ‘seed’
[10:19:58.103]   - Field: ‘version’
[10:19:58.103]   - Field: ‘result’
[10:19:58.103]   - Field: ‘asynchronous’
[10:19:58.103]   - Field: ‘calls’
[10:19:58.103]   - Field: ‘globals’
[10:19:58.103]   - Field: ‘stdout’
[10:19:58.103]   - Field: ‘earlySignal’
[10:19:58.103]   - Field: ‘lazy’
[10:19:58.103]   - Field: ‘state’
[10:19:58.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:58.104] - Launch lazy future ...
[10:19:58.104] Packages needed by the future expression (n = 1): ‘stats’
[10:19:58.104] Packages needed by future strategies (n = 0): <none>
[10:19:58.104] {
[10:19:58.104]     {
[10:19:58.104]         {
[10:19:58.104]             ...future.startTime <- base::Sys.time()
[10:19:58.104]             {
[10:19:58.104]                 {
[10:19:58.104]                   {
[10:19:58.104]                     {
[10:19:58.104]                       {
[10:19:58.104]                         base::local({
[10:19:58.104]                           has_future <- base::requireNamespace("future", 
[10:19:58.104]                             quietly = TRUE)
[10:19:58.104]                           if (has_future) {
[10:19:58.104]                             ns <- base::getNamespace("future")
[10:19:58.104]                             version <- ns[[".package"]][["version"]]
[10:19:58.104]                             if (is.null(version)) 
[10:19:58.104]                               version <- utils::packageVersion("future")
[10:19:58.104]                           }
[10:19:58.104]                           else {
[10:19:58.104]                             version <- NULL
[10:19:58.104]                           }
[10:19:58.104]                           if (!has_future || version < "1.8.0") {
[10:19:58.104]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:58.104]                               "", base::R.version$version.string), 
[10:19:58.104]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:58.104]                                 base::R.version$platform, 8 * 
[10:19:58.104]                                   base::.Machine$sizeof.pointer), 
[10:19:58.104]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:58.104]                                 "release", "version")], collapse = " "), 
[10:19:58.104]                               hostname = base::Sys.info()[["nodename"]])
[10:19:58.104]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:58.104]                               info)
[10:19:58.104]                             info <- base::paste(info, collapse = "; ")
[10:19:58.104]                             if (!has_future) {
[10:19:58.104]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:58.104]                                 info)
[10:19:58.104]                             }
[10:19:58.104]                             else {
[10:19:58.104]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:58.104]                                 info, version)
[10:19:58.104]                             }
[10:19:58.104]                             base::stop(msg)
[10:19:58.104]                           }
[10:19:58.104]                         })
[10:19:58.104]                       }
[10:19:58.104]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:58.104]                       base::options(mc.cores = 1L)
[10:19:58.104]                     }
[10:19:58.104]                     base::local({
[10:19:58.104]                       for (pkg in "stats") {
[10:19:58.104]                         base::loadNamespace(pkg)
[10:19:58.104]                         base::library(pkg, character.only = TRUE)
[10:19:58.104]                       }
[10:19:58.104]                     })
[10:19:58.104]                   }
[10:19:58.104]                   ...future.strategy.old <- future::plan("list")
[10:19:58.104]                   options(future.plan = NULL)
[10:19:58.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:58.104]                 }
[10:19:58.104]                 ...future.workdir <- getwd()
[10:19:58.104]             }
[10:19:58.104]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:58.104]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:58.104]         }
[10:19:58.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:58.104]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:58.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:58.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:58.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:58.104]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:58.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:58.104]             base::names(...future.oldOptions))
[10:19:58.104]     }
[10:19:58.104]     if (FALSE) {
[10:19:58.104]     }
[10:19:58.104]     else {
[10:19:58.104]         if (TRUE) {
[10:19:58.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:58.104]                 open = "w")
[10:19:58.104]         }
[10:19:58.104]         else {
[10:19:58.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:58.104]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:58.104]         }
[10:19:58.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:58.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:58.104]             base::sink(type = "output", split = FALSE)
[10:19:58.104]             base::close(...future.stdout)
[10:19:58.104]         }, add = TRUE)
[10:19:58.104]     }
[10:19:58.104]     ...future.frame <- base::sys.nframe()
[10:19:58.104]     ...future.conditions <- base::list()
[10:19:58.104]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:58.104]     if (FALSE) {
[10:19:58.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:58.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:58.104]     }
[10:19:58.104]     ...future.result <- base::tryCatch({
[10:19:58.104]         base::withCallingHandlers({
[10:19:58.104]             ...future.value <- base::withVisible(base::local({
[10:19:58.104]                 ...future.makeSendCondition <- base::local({
[10:19:58.104]                   sendCondition <- NULL
[10:19:58.104]                   function(frame = 1L) {
[10:19:58.104]                     if (is.function(sendCondition)) 
[10:19:58.104]                       return(sendCondition)
[10:19:58.104]                     ns <- getNamespace("parallel")
[10:19:58.104]                     if (exists("sendData", mode = "function", 
[10:19:58.104]                       envir = ns)) {
[10:19:58.104]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:58.104]                         envir = ns)
[10:19:58.104]                       envir <- sys.frame(frame)
[10:19:58.104]                       master <- NULL
[10:19:58.104]                       while (!identical(envir, .GlobalEnv) && 
[10:19:58.104]                         !identical(envir, emptyenv())) {
[10:19:58.104]                         if (exists("master", mode = "list", envir = envir, 
[10:19:58.104]                           inherits = FALSE)) {
[10:19:58.104]                           master <- get("master", mode = "list", 
[10:19:58.104]                             envir = envir, inherits = FALSE)
[10:19:58.104]                           if (inherits(master, c("SOCKnode", 
[10:19:58.104]                             "SOCK0node"))) {
[10:19:58.104]                             sendCondition <<- function(cond) {
[10:19:58.104]                               data <- list(type = "VALUE", value = cond, 
[10:19:58.104]                                 success = TRUE)
[10:19:58.104]                               parallel_sendData(master, data)
[10:19:58.104]                             }
[10:19:58.104]                             return(sendCondition)
[10:19:58.104]                           }
[10:19:58.104]                         }
[10:19:58.104]                         frame <- frame + 1L
[10:19:58.104]                         envir <- sys.frame(frame)
[10:19:58.104]                       }
[10:19:58.104]                     }
[10:19:58.104]                     sendCondition <<- function(cond) NULL
[10:19:58.104]                   }
[10:19:58.104]                 })
[10:19:58.104]                 withCallingHandlers({
[10:19:58.104]                   {
[10:19:58.104]                     do.call(function(...) {
[10:19:58.104]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.104]                       if (!identical(...future.globals.maxSize.org, 
[10:19:58.104]                         ...future.globals.maxSize)) {
[10:19:58.104]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.104]                         on.exit(options(oopts), add = TRUE)
[10:19:58.104]                       }
[10:19:58.104]                       {
[10:19:58.104]                         lapply(seq_along(...future.elements_ii), 
[10:19:58.104]                           FUN = function(jj) {
[10:19:58.104]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.104]                             ...future.FUN(...future.X_jj, ...)
[10:19:58.104]                           })
[10:19:58.104]                       }
[10:19:58.104]                     }, args = future.call.arguments)
[10:19:58.104]                   }
[10:19:58.104]                 }, immediateCondition = function(cond) {
[10:19:58.104]                   sendCondition <- ...future.makeSendCondition()
[10:19:58.104]                   sendCondition(cond)
[10:19:58.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.104]                   {
[10:19:58.104]                     inherits <- base::inherits
[10:19:58.104]                     invokeRestart <- base::invokeRestart
[10:19:58.104]                     is.null <- base::is.null
[10:19:58.104]                     muffled <- FALSE
[10:19:58.104]                     if (inherits(cond, "message")) {
[10:19:58.104]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:58.104]                       if (muffled) 
[10:19:58.104]                         invokeRestart("muffleMessage")
[10:19:58.104]                     }
[10:19:58.104]                     else if (inherits(cond, "warning")) {
[10:19:58.104]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:58.104]                       if (muffled) 
[10:19:58.104]                         invokeRestart("muffleWarning")
[10:19:58.104]                     }
[10:19:58.104]                     else if (inherits(cond, "condition")) {
[10:19:58.104]                       if (!is.null(pattern)) {
[10:19:58.104]                         computeRestarts <- base::computeRestarts
[10:19:58.104]                         grepl <- base::grepl
[10:19:58.104]                         restarts <- computeRestarts(cond)
[10:19:58.104]                         for (restart in restarts) {
[10:19:58.104]                           name <- restart$name
[10:19:58.104]                           if (is.null(name)) 
[10:19:58.104]                             next
[10:19:58.104]                           if (!grepl(pattern, name)) 
[10:19:58.104]                             next
[10:19:58.104]                           invokeRestart(restart)
[10:19:58.104]                           muffled <- TRUE
[10:19:58.104]                           break
[10:19:58.104]                         }
[10:19:58.104]                       }
[10:19:58.104]                     }
[10:19:58.104]                     invisible(muffled)
[10:19:58.104]                   }
[10:19:58.104]                   muffleCondition(cond)
[10:19:58.104]                 })
[10:19:58.104]             }))
[10:19:58.104]             future::FutureResult(value = ...future.value$value, 
[10:19:58.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.104]                   ...future.rng), globalenv = if (FALSE) 
[10:19:58.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:58.104]                     ...future.globalenv.names))
[10:19:58.104]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:58.104]         }, condition = base::local({
[10:19:58.104]             c <- base::c
[10:19:58.104]             inherits <- base::inherits
[10:19:58.104]             invokeRestart <- base::invokeRestart
[10:19:58.104]             length <- base::length
[10:19:58.104]             list <- base::list
[10:19:58.104]             seq.int <- base::seq.int
[10:19:58.104]             signalCondition <- base::signalCondition
[10:19:58.104]             sys.calls <- base::sys.calls
[10:19:58.104]             `[[` <- base::`[[`
[10:19:58.104]             `+` <- base::`+`
[10:19:58.104]             `<<-` <- base::`<<-`
[10:19:58.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:58.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:58.104]                   3L)]
[10:19:58.104]             }
[10:19:58.104]             function(cond) {
[10:19:58.104]                 is_error <- inherits(cond, "error")
[10:19:58.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:58.104]                   NULL)
[10:19:58.104]                 if (is_error) {
[10:19:58.104]                   sessionInformation <- function() {
[10:19:58.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:58.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:58.104]                       search = base::search(), system = base::Sys.info())
[10:19:58.104]                   }
[10:19:58.104]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:58.104]                     cond$call), session = sessionInformation(), 
[10:19:58.104]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:58.104]                   signalCondition(cond)
[10:19:58.104]                 }
[10:19:58.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:58.104]                 "immediateCondition"))) {
[10:19:58.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:58.104]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:58.104]                   if (TRUE && !signal) {
[10:19:58.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.104]                     {
[10:19:58.104]                       inherits <- base::inherits
[10:19:58.104]                       invokeRestart <- base::invokeRestart
[10:19:58.104]                       is.null <- base::is.null
[10:19:58.104]                       muffled <- FALSE
[10:19:58.104]                       if (inherits(cond, "message")) {
[10:19:58.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.104]                         if (muffled) 
[10:19:58.104]                           invokeRestart("muffleMessage")
[10:19:58.104]                       }
[10:19:58.104]                       else if (inherits(cond, "warning")) {
[10:19:58.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.104]                         if (muffled) 
[10:19:58.104]                           invokeRestart("muffleWarning")
[10:19:58.104]                       }
[10:19:58.104]                       else if (inherits(cond, "condition")) {
[10:19:58.104]                         if (!is.null(pattern)) {
[10:19:58.104]                           computeRestarts <- base::computeRestarts
[10:19:58.104]                           grepl <- base::grepl
[10:19:58.104]                           restarts <- computeRestarts(cond)
[10:19:58.104]                           for (restart in restarts) {
[10:19:58.104]                             name <- restart$name
[10:19:58.104]                             if (is.null(name)) 
[10:19:58.104]                               next
[10:19:58.104]                             if (!grepl(pattern, name)) 
[10:19:58.104]                               next
[10:19:58.104]                             invokeRestart(restart)
[10:19:58.104]                             muffled <- TRUE
[10:19:58.104]                             break
[10:19:58.104]                           }
[10:19:58.104]                         }
[10:19:58.104]                       }
[10:19:58.104]                       invisible(muffled)
[10:19:58.104]                     }
[10:19:58.104]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.104]                   }
[10:19:58.104]                 }
[10:19:58.104]                 else {
[10:19:58.104]                   if (TRUE) {
[10:19:58.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.104]                     {
[10:19:58.104]                       inherits <- base::inherits
[10:19:58.104]                       invokeRestart <- base::invokeRestart
[10:19:58.104]                       is.null <- base::is.null
[10:19:58.104]                       muffled <- FALSE
[10:19:58.104]                       if (inherits(cond, "message")) {
[10:19:58.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.104]                         if (muffled) 
[10:19:58.104]                           invokeRestart("muffleMessage")
[10:19:58.104]                       }
[10:19:58.104]                       else if (inherits(cond, "warning")) {
[10:19:58.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.104]                         if (muffled) 
[10:19:58.104]                           invokeRestart("muffleWarning")
[10:19:58.104]                       }
[10:19:58.104]                       else if (inherits(cond, "condition")) {
[10:19:58.104]                         if (!is.null(pattern)) {
[10:19:58.104]                           computeRestarts <- base::computeRestarts
[10:19:58.104]                           grepl <- base::grepl
[10:19:58.104]                           restarts <- computeRestarts(cond)
[10:19:58.104]                           for (restart in restarts) {
[10:19:58.104]                             name <- restart$name
[10:19:58.104]                             if (is.null(name)) 
[10:19:58.104]                               next
[10:19:58.104]                             if (!grepl(pattern, name)) 
[10:19:58.104]                               next
[10:19:58.104]                             invokeRestart(restart)
[10:19:58.104]                             muffled <- TRUE
[10:19:58.104]                             break
[10:19:58.104]                           }
[10:19:58.104]                         }
[10:19:58.104]                       }
[10:19:58.104]                       invisible(muffled)
[10:19:58.104]                     }
[10:19:58.104]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.104]                   }
[10:19:58.104]                 }
[10:19:58.104]             }
[10:19:58.104]         }))
[10:19:58.104]     }, error = function(ex) {
[10:19:58.104]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:58.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.104]                 ...future.rng), started = ...future.startTime, 
[10:19:58.104]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:58.104]             version = "1.8"), class = "FutureResult")
[10:19:58.104]     }, finally = {
[10:19:58.104]         if (!identical(...future.workdir, getwd())) 
[10:19:58.104]             setwd(...future.workdir)
[10:19:58.104]         {
[10:19:58.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:58.104]                 ...future.oldOptions$nwarnings <- NULL
[10:19:58.104]             }
[10:19:58.104]             base::options(...future.oldOptions)
[10:19:58.104]             if (.Platform$OS.type == "windows") {
[10:19:58.104]                 old_names <- names(...future.oldEnvVars)
[10:19:58.104]                 envs <- base::Sys.getenv()
[10:19:58.104]                 names <- names(envs)
[10:19:58.104]                 common <- intersect(names, old_names)
[10:19:58.104]                 added <- setdiff(names, old_names)
[10:19:58.104]                 removed <- setdiff(old_names, names)
[10:19:58.104]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:58.104]                   envs[common]]
[10:19:58.104]                 NAMES <- toupper(changed)
[10:19:58.104]                 args <- list()
[10:19:58.104]                 for (kk in seq_along(NAMES)) {
[10:19:58.104]                   name <- changed[[kk]]
[10:19:58.104]                   NAME <- NAMES[[kk]]
[10:19:58.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.104]                     next
[10:19:58.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.104]                 }
[10:19:58.104]                 NAMES <- toupper(added)
[10:19:58.104]                 for (kk in seq_along(NAMES)) {
[10:19:58.104]                   name <- added[[kk]]
[10:19:58.104]                   NAME <- NAMES[[kk]]
[10:19:58.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.104]                     next
[10:19:58.104]                   args[[name]] <- ""
[10:19:58.104]                 }
[10:19:58.104]                 NAMES <- toupper(removed)
[10:19:58.104]                 for (kk in seq_along(NAMES)) {
[10:19:58.104]                   name <- removed[[kk]]
[10:19:58.104]                   NAME <- NAMES[[kk]]
[10:19:58.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.104]                     next
[10:19:58.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.104]                 }
[10:19:58.104]                 if (length(args) > 0) 
[10:19:58.104]                   base::do.call(base::Sys.setenv, args = args)
[10:19:58.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:58.104]             }
[10:19:58.104]             else {
[10:19:58.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:58.104]             }
[10:19:58.104]             {
[10:19:58.104]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:58.104]                   0L) {
[10:19:58.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:58.104]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:58.104]                   base::options(opts)
[10:19:58.104]                 }
[10:19:58.104]                 {
[10:19:58.104]                   {
[10:19:58.104]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:58.104]                     NULL
[10:19:58.104]                   }
[10:19:58.104]                   options(future.plan = NULL)
[10:19:58.104]                   if (is.na(NA_character_)) 
[10:19:58.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:58.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:58.104]                     .init = FALSE)
[10:19:58.104]                 }
[10:19:58.104]             }
[10:19:58.104]         }
[10:19:58.104]     })
[10:19:58.104]     if (TRUE) {
[10:19:58.104]         base::sink(type = "output", split = FALSE)
[10:19:58.104]         if (TRUE) {
[10:19:58.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:58.104]         }
[10:19:58.104]         else {
[10:19:58.104]             ...future.result["stdout"] <- base::list(NULL)
[10:19:58.104]         }
[10:19:58.104]         base::close(...future.stdout)
[10:19:58.104]         ...future.stdout <- NULL
[10:19:58.104]     }
[10:19:58.104]     ...future.result$conditions <- ...future.conditions
[10:19:58.104]     ...future.result$finished <- base::Sys.time()
[10:19:58.104]     ...future.result
[10:19:58.104] }
[10:19:58.107] Exporting 5 global objects (5.62 KiB) to cluster node #1 ...
[10:19:58.107] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #1 ...
[10:19:58.148] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #1 ... DONE
[10:19:58.148] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:58.149] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:58.149] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ...
[10:19:58.150] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ... DONE
[10:19:58.150] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:58.150] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:58.150] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:58.150] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:58.151] Exporting 5 global objects (5.62 KiB) to cluster node #1 ... DONE
[10:19:58.151] MultisessionFuture started
[10:19:58.151] - Launch lazy future ... done
[10:19:58.151] run() for ‘MultisessionFuture’ ... done
[10:19:58.151] Created future:
[10:19:58.151] MultisessionFuture:
[10:19:58.151] Label: ‘future_sapply-1’
[10:19:58.151] Expression:
[10:19:58.151] {
[10:19:58.151]     do.call(function(...) {
[10:19:58.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.151]             on.exit(options(oopts), add = TRUE)
[10:19:58.151]         }
[10:19:58.151]         {
[10:19:58.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.151]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.151]             })
[10:19:58.151]         }
[10:19:58.151]     }, args = future.call.arguments)
[10:19:58.151] }
[10:19:58.151] Lazy evaluation: FALSE
[10:19:58.151] Asynchronous evaluation: TRUE
[10:19:58.151] Local evaluation: TRUE
[10:19:58.151] Environment: R_GlobalEnv
[10:19:58.151] Capture standard output: TRUE
[10:19:58.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:58.151] Globals: 5 objects totaling 5.17 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 369 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:58.151] Packages: 1 packages (‘stats’)
[10:19:58.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:58.151] Resolved: FALSE
[10:19:58.151] Value: <not collected>
[10:19:58.151] Conditions captured: <none>
[10:19:58.151] Early signaling: FALSE
[10:19:58.151] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:58.151] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.163] Chunk #1 of 2 ... DONE
[10:19:58.163] Chunk #2 of 2 ...
[10:19:58.163]  - Finding globals in 'X' for chunk #2 ...
[10:19:58.163] getGlobalsAndPackages() ...
[10:19:58.163] Searching for globals...
[10:19:58.164] 
[10:19:58.164] Searching for globals ... DONE
[10:19:58.164] - globals: [0] <none>
[10:19:58.164] getGlobalsAndPackages() ... DONE
[10:19:58.164]    + additional globals found: [n=0] 
[10:19:58.164]    + additional namespaces needed: [n=0] 
[10:19:58.164]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:58.164]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:58.164]  - seeds: <none>
[10:19:58.164]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.164] getGlobalsAndPackages() ...
[10:19:58.165] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.165] Resolving globals: FALSE
[10:19:58.165] Tweak future expression to call with '...' arguments ...
[10:19:58.165] {
[10:19:58.165]     do.call(function(...) {
[10:19:58.165]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.165]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.165]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.165]             on.exit(options(oopts), add = TRUE)
[10:19:58.165]         }
[10:19:58.165]         {
[10:19:58.165]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.165]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.165]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.165]             })
[10:19:58.165]         }
[10:19:58.165]     }, args = future.call.arguments)
[10:19:58.165] }
[10:19:58.165] Tweak future expression to call with '...' arguments ... DONE
[10:19:58.165] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.166] - packages: [1] ‘stats’
[10:19:58.166] getGlobalsAndPackages() ... DONE
[10:19:58.166] run() for ‘Future’ ...
[10:19:58.166] - state: ‘created’
[10:19:58.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:58.180] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:58.180]   - Field: ‘node’
[10:19:58.180]   - Field: ‘label’
[10:19:58.180]   - Field: ‘local’
[10:19:58.180]   - Field: ‘owner’
[10:19:58.180]   - Field: ‘envir’
[10:19:58.180]   - Field: ‘workers’
[10:19:58.180]   - Field: ‘packages’
[10:19:58.180]   - Field: ‘gc’
[10:19:58.181]   - Field: ‘conditions’
[10:19:58.181]   - Field: ‘persistent’
[10:19:58.181]   - Field: ‘expr’
[10:19:58.181]   - Field: ‘uuid’
[10:19:58.181]   - Field: ‘seed’
[10:19:58.181]   - Field: ‘version’
[10:19:58.181]   - Field: ‘result’
[10:19:58.181]   - Field: ‘asynchronous’
[10:19:58.181]   - Field: ‘calls’
[10:19:58.181]   - Field: ‘globals’
[10:19:58.181]   - Field: ‘stdout’
[10:19:58.181]   - Field: ‘earlySignal’
[10:19:58.182]   - Field: ‘lazy’
[10:19:58.182]   - Field: ‘state’
[10:19:58.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:58.182] - Launch lazy future ...
[10:19:58.182] Packages needed by the future expression (n = 1): ‘stats’
[10:19:58.182] Packages needed by future strategies (n = 0): <none>
[10:19:58.183] {
[10:19:58.183]     {
[10:19:58.183]         {
[10:19:58.183]             ...future.startTime <- base::Sys.time()
[10:19:58.183]             {
[10:19:58.183]                 {
[10:19:58.183]                   {
[10:19:58.183]                     {
[10:19:58.183]                       {
[10:19:58.183]                         base::local({
[10:19:58.183]                           has_future <- base::requireNamespace("future", 
[10:19:58.183]                             quietly = TRUE)
[10:19:58.183]                           if (has_future) {
[10:19:58.183]                             ns <- base::getNamespace("future")
[10:19:58.183]                             version <- ns[[".package"]][["version"]]
[10:19:58.183]                             if (is.null(version)) 
[10:19:58.183]                               version <- utils::packageVersion("future")
[10:19:58.183]                           }
[10:19:58.183]                           else {
[10:19:58.183]                             version <- NULL
[10:19:58.183]                           }
[10:19:58.183]                           if (!has_future || version < "1.8.0") {
[10:19:58.183]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:58.183]                               "", base::R.version$version.string), 
[10:19:58.183]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:58.183]                                 base::R.version$platform, 8 * 
[10:19:58.183]                                   base::.Machine$sizeof.pointer), 
[10:19:58.183]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:58.183]                                 "release", "version")], collapse = " "), 
[10:19:58.183]                               hostname = base::Sys.info()[["nodename"]])
[10:19:58.183]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:58.183]                               info)
[10:19:58.183]                             info <- base::paste(info, collapse = "; ")
[10:19:58.183]                             if (!has_future) {
[10:19:58.183]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:58.183]                                 info)
[10:19:58.183]                             }
[10:19:58.183]                             else {
[10:19:58.183]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:58.183]                                 info, version)
[10:19:58.183]                             }
[10:19:58.183]                             base::stop(msg)
[10:19:58.183]                           }
[10:19:58.183]                         })
[10:19:58.183]                       }
[10:19:58.183]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:58.183]                       base::options(mc.cores = 1L)
[10:19:58.183]                     }
[10:19:58.183]                     base::local({
[10:19:58.183]                       for (pkg in "stats") {
[10:19:58.183]                         base::loadNamespace(pkg)
[10:19:58.183]                         base::library(pkg, character.only = TRUE)
[10:19:58.183]                       }
[10:19:58.183]                     })
[10:19:58.183]                   }
[10:19:58.183]                   ...future.strategy.old <- future::plan("list")
[10:19:58.183]                   options(future.plan = NULL)
[10:19:58.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:58.183]                 }
[10:19:58.183]                 ...future.workdir <- getwd()
[10:19:58.183]             }
[10:19:58.183]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:58.183]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:58.183]         }
[10:19:58.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:58.183]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:58.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:58.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:58.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:58.183]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:58.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:58.183]             base::names(...future.oldOptions))
[10:19:58.183]     }
[10:19:58.183]     if (FALSE) {
[10:19:58.183]     }
[10:19:58.183]     else {
[10:19:58.183]         if (TRUE) {
[10:19:58.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:58.183]                 open = "w")
[10:19:58.183]         }
[10:19:58.183]         else {
[10:19:58.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:58.183]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:58.183]         }
[10:19:58.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:58.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:58.183]             base::sink(type = "output", split = FALSE)
[10:19:58.183]             base::close(...future.stdout)
[10:19:58.183]         }, add = TRUE)
[10:19:58.183]     }
[10:19:58.183]     ...future.frame <- base::sys.nframe()
[10:19:58.183]     ...future.conditions <- base::list()
[10:19:58.183]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:58.183]     if (FALSE) {
[10:19:58.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:58.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:58.183]     }
[10:19:58.183]     ...future.result <- base::tryCatch({
[10:19:58.183]         base::withCallingHandlers({
[10:19:58.183]             ...future.value <- base::withVisible(base::local({
[10:19:58.183]                 ...future.makeSendCondition <- base::local({
[10:19:58.183]                   sendCondition <- NULL
[10:19:58.183]                   function(frame = 1L) {
[10:19:58.183]                     if (is.function(sendCondition)) 
[10:19:58.183]                       return(sendCondition)
[10:19:58.183]                     ns <- getNamespace("parallel")
[10:19:58.183]                     if (exists("sendData", mode = "function", 
[10:19:58.183]                       envir = ns)) {
[10:19:58.183]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:58.183]                         envir = ns)
[10:19:58.183]                       envir <- sys.frame(frame)
[10:19:58.183]                       master <- NULL
[10:19:58.183]                       while (!identical(envir, .GlobalEnv) && 
[10:19:58.183]                         !identical(envir, emptyenv())) {
[10:19:58.183]                         if (exists("master", mode = "list", envir = envir, 
[10:19:58.183]                           inherits = FALSE)) {
[10:19:58.183]                           master <- get("master", mode = "list", 
[10:19:58.183]                             envir = envir, inherits = FALSE)
[10:19:58.183]                           if (inherits(master, c("SOCKnode", 
[10:19:58.183]                             "SOCK0node"))) {
[10:19:58.183]                             sendCondition <<- function(cond) {
[10:19:58.183]                               data <- list(type = "VALUE", value = cond, 
[10:19:58.183]                                 success = TRUE)
[10:19:58.183]                               parallel_sendData(master, data)
[10:19:58.183]                             }
[10:19:58.183]                             return(sendCondition)
[10:19:58.183]                           }
[10:19:58.183]                         }
[10:19:58.183]                         frame <- frame + 1L
[10:19:58.183]                         envir <- sys.frame(frame)
[10:19:58.183]                       }
[10:19:58.183]                     }
[10:19:58.183]                     sendCondition <<- function(cond) NULL
[10:19:58.183]                   }
[10:19:58.183]                 })
[10:19:58.183]                 withCallingHandlers({
[10:19:58.183]                   {
[10:19:58.183]                     do.call(function(...) {
[10:19:58.183]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.183]                       if (!identical(...future.globals.maxSize.org, 
[10:19:58.183]                         ...future.globals.maxSize)) {
[10:19:58.183]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.183]                         on.exit(options(oopts), add = TRUE)
[10:19:58.183]                       }
[10:19:58.183]                       {
[10:19:58.183]                         lapply(seq_along(...future.elements_ii), 
[10:19:58.183]                           FUN = function(jj) {
[10:19:58.183]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.183]                             ...future.FUN(...future.X_jj, ...)
[10:19:58.183]                           })
[10:19:58.183]                       }
[10:19:58.183]                     }, args = future.call.arguments)
[10:19:58.183]                   }
[10:19:58.183]                 }, immediateCondition = function(cond) {
[10:19:58.183]                   sendCondition <- ...future.makeSendCondition()
[10:19:58.183]                   sendCondition(cond)
[10:19:58.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.183]                   {
[10:19:58.183]                     inherits <- base::inherits
[10:19:58.183]                     invokeRestart <- base::invokeRestart
[10:19:58.183]                     is.null <- base::is.null
[10:19:58.183]                     muffled <- FALSE
[10:19:58.183]                     if (inherits(cond, "message")) {
[10:19:58.183]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:58.183]                       if (muffled) 
[10:19:58.183]                         invokeRestart("muffleMessage")
[10:19:58.183]                     }
[10:19:58.183]                     else if (inherits(cond, "warning")) {
[10:19:58.183]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:58.183]                       if (muffled) 
[10:19:58.183]                         invokeRestart("muffleWarning")
[10:19:58.183]                     }
[10:19:58.183]                     else if (inherits(cond, "condition")) {
[10:19:58.183]                       if (!is.null(pattern)) {
[10:19:58.183]                         computeRestarts <- base::computeRestarts
[10:19:58.183]                         grepl <- base::grepl
[10:19:58.183]                         restarts <- computeRestarts(cond)
[10:19:58.183]                         for (restart in restarts) {
[10:19:58.183]                           name <- restart$name
[10:19:58.183]                           if (is.null(name)) 
[10:19:58.183]                             next
[10:19:58.183]                           if (!grepl(pattern, name)) 
[10:19:58.183]                             next
[10:19:58.183]                           invokeRestart(restart)
[10:19:58.183]                           muffled <- TRUE
[10:19:58.183]                           break
[10:19:58.183]                         }
[10:19:58.183]                       }
[10:19:58.183]                     }
[10:19:58.183]                     invisible(muffled)
[10:19:58.183]                   }
[10:19:58.183]                   muffleCondition(cond)
[10:19:58.183]                 })
[10:19:58.183]             }))
[10:19:58.183]             future::FutureResult(value = ...future.value$value, 
[10:19:58.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.183]                   ...future.rng), globalenv = if (FALSE) 
[10:19:58.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:58.183]                     ...future.globalenv.names))
[10:19:58.183]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:58.183]         }, condition = base::local({
[10:19:58.183]             c <- base::c
[10:19:58.183]             inherits <- base::inherits
[10:19:58.183]             invokeRestart <- base::invokeRestart
[10:19:58.183]             length <- base::length
[10:19:58.183]             list <- base::list
[10:19:58.183]             seq.int <- base::seq.int
[10:19:58.183]             signalCondition <- base::signalCondition
[10:19:58.183]             sys.calls <- base::sys.calls
[10:19:58.183]             `[[` <- base::`[[`
[10:19:58.183]             `+` <- base::`+`
[10:19:58.183]             `<<-` <- base::`<<-`
[10:19:58.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:58.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:58.183]                   3L)]
[10:19:58.183]             }
[10:19:58.183]             function(cond) {
[10:19:58.183]                 is_error <- inherits(cond, "error")
[10:19:58.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:58.183]                   NULL)
[10:19:58.183]                 if (is_error) {
[10:19:58.183]                   sessionInformation <- function() {
[10:19:58.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:58.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:58.183]                       search = base::search(), system = base::Sys.info())
[10:19:58.183]                   }
[10:19:58.183]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:58.183]                     cond$call), session = sessionInformation(), 
[10:19:58.183]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:58.183]                   signalCondition(cond)
[10:19:58.183]                 }
[10:19:58.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:58.183]                 "immediateCondition"))) {
[10:19:58.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:58.183]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:58.183]                   if (TRUE && !signal) {
[10:19:58.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.183]                     {
[10:19:58.183]                       inherits <- base::inherits
[10:19:58.183]                       invokeRestart <- base::invokeRestart
[10:19:58.183]                       is.null <- base::is.null
[10:19:58.183]                       muffled <- FALSE
[10:19:58.183]                       if (inherits(cond, "message")) {
[10:19:58.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.183]                         if (muffled) 
[10:19:58.183]                           invokeRestart("muffleMessage")
[10:19:58.183]                       }
[10:19:58.183]                       else if (inherits(cond, "warning")) {
[10:19:58.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.183]                         if (muffled) 
[10:19:58.183]                           invokeRestart("muffleWarning")
[10:19:58.183]                       }
[10:19:58.183]                       else if (inherits(cond, "condition")) {
[10:19:58.183]                         if (!is.null(pattern)) {
[10:19:58.183]                           computeRestarts <- base::computeRestarts
[10:19:58.183]                           grepl <- base::grepl
[10:19:58.183]                           restarts <- computeRestarts(cond)
[10:19:58.183]                           for (restart in restarts) {
[10:19:58.183]                             name <- restart$name
[10:19:58.183]                             if (is.null(name)) 
[10:19:58.183]                               next
[10:19:58.183]                             if (!grepl(pattern, name)) 
[10:19:58.183]                               next
[10:19:58.183]                             invokeRestart(restart)
[10:19:58.183]                             muffled <- TRUE
[10:19:58.183]                             break
[10:19:58.183]                           }
[10:19:58.183]                         }
[10:19:58.183]                       }
[10:19:58.183]                       invisible(muffled)
[10:19:58.183]                     }
[10:19:58.183]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.183]                   }
[10:19:58.183]                 }
[10:19:58.183]                 else {
[10:19:58.183]                   if (TRUE) {
[10:19:58.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.183]                     {
[10:19:58.183]                       inherits <- base::inherits
[10:19:58.183]                       invokeRestart <- base::invokeRestart
[10:19:58.183]                       is.null <- base::is.null
[10:19:58.183]                       muffled <- FALSE
[10:19:58.183]                       if (inherits(cond, "message")) {
[10:19:58.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.183]                         if (muffled) 
[10:19:58.183]                           invokeRestart("muffleMessage")
[10:19:58.183]                       }
[10:19:58.183]                       else if (inherits(cond, "warning")) {
[10:19:58.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.183]                         if (muffled) 
[10:19:58.183]                           invokeRestart("muffleWarning")
[10:19:58.183]                       }
[10:19:58.183]                       else if (inherits(cond, "condition")) {
[10:19:58.183]                         if (!is.null(pattern)) {
[10:19:58.183]                           computeRestarts <- base::computeRestarts
[10:19:58.183]                           grepl <- base::grepl
[10:19:58.183]                           restarts <- computeRestarts(cond)
[10:19:58.183]                           for (restart in restarts) {
[10:19:58.183]                             name <- restart$name
[10:19:58.183]                             if (is.null(name)) 
[10:19:58.183]                               next
[10:19:58.183]                             if (!grepl(pattern, name)) 
[10:19:58.183]                               next
[10:19:58.183]                             invokeRestart(restart)
[10:19:58.183]                             muffled <- TRUE
[10:19:58.183]                             break
[10:19:58.183]                           }
[10:19:58.183]                         }
[10:19:58.183]                       }
[10:19:58.183]                       invisible(muffled)
[10:19:58.183]                     }
[10:19:58.183]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.183]                   }
[10:19:58.183]                 }
[10:19:58.183]             }
[10:19:58.183]         }))
[10:19:58.183]     }, error = function(ex) {
[10:19:58.183]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:58.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.183]                 ...future.rng), started = ...future.startTime, 
[10:19:58.183]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:58.183]             version = "1.8"), class = "FutureResult")
[10:19:58.183]     }, finally = {
[10:19:58.183]         if (!identical(...future.workdir, getwd())) 
[10:19:58.183]             setwd(...future.workdir)
[10:19:58.183]         {
[10:19:58.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:58.183]                 ...future.oldOptions$nwarnings <- NULL
[10:19:58.183]             }
[10:19:58.183]             base::options(...future.oldOptions)
[10:19:58.183]             if (.Platform$OS.type == "windows") {
[10:19:58.183]                 old_names <- names(...future.oldEnvVars)
[10:19:58.183]                 envs <- base::Sys.getenv()
[10:19:58.183]                 names <- names(envs)
[10:19:58.183]                 common <- intersect(names, old_names)
[10:19:58.183]                 added <- setdiff(names, old_names)
[10:19:58.183]                 removed <- setdiff(old_names, names)
[10:19:58.183]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:58.183]                   envs[common]]
[10:19:58.183]                 NAMES <- toupper(changed)
[10:19:58.183]                 args <- list()
[10:19:58.183]                 for (kk in seq_along(NAMES)) {
[10:19:58.183]                   name <- changed[[kk]]
[10:19:58.183]                   NAME <- NAMES[[kk]]
[10:19:58.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.183]                     next
[10:19:58.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.183]                 }
[10:19:58.183]                 NAMES <- toupper(added)
[10:19:58.183]                 for (kk in seq_along(NAMES)) {
[10:19:58.183]                   name <- added[[kk]]
[10:19:58.183]                   NAME <- NAMES[[kk]]
[10:19:58.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.183]                     next
[10:19:58.183]                   args[[name]] <- ""
[10:19:58.183]                 }
[10:19:58.183]                 NAMES <- toupper(removed)
[10:19:58.183]                 for (kk in seq_along(NAMES)) {
[10:19:58.183]                   name <- removed[[kk]]
[10:19:58.183]                   NAME <- NAMES[[kk]]
[10:19:58.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.183]                     next
[10:19:58.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.183]                 }
[10:19:58.183]                 if (length(args) > 0) 
[10:19:58.183]                   base::do.call(base::Sys.setenv, args = args)
[10:19:58.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:58.183]             }
[10:19:58.183]             else {
[10:19:58.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:58.183]             }
[10:19:58.183]             {
[10:19:58.183]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:58.183]                   0L) {
[10:19:58.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:58.183]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:58.183]                   base::options(opts)
[10:19:58.183]                 }
[10:19:58.183]                 {
[10:19:58.183]                   {
[10:19:58.183]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:58.183]                     NULL
[10:19:58.183]                   }
[10:19:58.183]                   options(future.plan = NULL)
[10:19:58.183]                   if (is.na(NA_character_)) 
[10:19:58.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:58.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:58.183]                     .init = FALSE)
[10:19:58.183]                 }
[10:19:58.183]             }
[10:19:58.183]         }
[10:19:58.183]     })
[10:19:58.183]     if (TRUE) {
[10:19:58.183]         base::sink(type = "output", split = FALSE)
[10:19:58.183]         if (TRUE) {
[10:19:58.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:58.183]         }
[10:19:58.183]         else {
[10:19:58.183]             ...future.result["stdout"] <- base::list(NULL)
[10:19:58.183]         }
[10:19:58.183]         base::close(...future.stdout)
[10:19:58.183]         ...future.stdout <- NULL
[10:19:58.183]     }
[10:19:58.183]     ...future.result$conditions <- ...future.conditions
[10:19:58.183]     ...future.result$finished <- base::Sys.time()
[10:19:58.183]     ...future.result
[10:19:58.183] }
[10:19:58.185] Exporting 5 global objects (5.55 KiB) to cluster node #2 ...
[10:19:58.186] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #2 ...
[10:19:58.226] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #2 ... DONE
[10:19:58.227] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:58.227] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:58.227] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ...
[10:19:58.228] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ... DONE
[10:19:58.228] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:58.228] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:58.228] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:58.229] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:58.229] Exporting 5 global objects (5.55 KiB) to cluster node #2 ... DONE
[10:19:58.229] MultisessionFuture started
[10:19:58.229] - Launch lazy future ... done
[10:19:58.229] run() for ‘MultisessionFuture’ ... done
[10:19:58.229] Created future:
[10:19:58.230] MultisessionFuture:
[10:19:58.230] Label: ‘future_sapply-2’
[10:19:58.230] Expression:
[10:19:58.230] {
[10:19:58.230]     do.call(function(...) {
[10:19:58.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.230]             on.exit(options(oopts), add = TRUE)
[10:19:58.230]         }
[10:19:58.230]         {
[10:19:58.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.230]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.230]             })
[10:19:58.230]         }
[10:19:58.230]     }, args = future.call.arguments)
[10:19:58.230] }
[10:19:58.230] Lazy evaluation: FALSE
[10:19:58.230] Asynchronous evaluation: TRUE
[10:19:58.230] Local evaluation: TRUE
[10:19:58.230] Environment: R_GlobalEnv
[10:19:58.230] Capture standard output: TRUE
[10:19:58.230] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:58.230] Globals: 5 objects totaling 5.10 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 293 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:58.230] Packages: 1 packages (‘stats’)
[10:19:58.230] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:58.230] Resolved: FALSE
[10:19:58.230] Value: <not collected>
[10:19:58.230] Conditions captured: <none>
[10:19:58.230] Early signaling: FALSE
[10:19:58.230] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:58.230] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.241] Chunk #2 of 2 ... DONE
[10:19:58.241] Launching 2 futures (chunks) ... DONE
[10:19:58.241] Resolving 2 futures (chunks) ...
[10:19:58.241] resolve() on list ...
[10:19:58.241]  recursive: 0
[10:19:58.242]  length: 2
[10:19:58.242] 
[10:19:58.242] receiveMessageFromWorker() for ClusterFuture ...
[10:19:58.242] - Validating connection of MultisessionFuture
[10:19:58.242] - received message: FutureResult
[10:19:58.243] - Received FutureResult
[10:19:58.243] - Erased future from FutureRegistry
[10:19:58.243] result() for ClusterFuture ...
[10:19:58.243] - result already collected: FutureResult
[10:19:58.243] result() for ClusterFuture ... done
[10:19:58.243] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:58.243] Future #1
[10:19:58.243] result() for ClusterFuture ...
[10:19:58.243] - result already collected: FutureResult
[10:19:58.243] result() for ClusterFuture ... done
[10:19:58.243] result() for ClusterFuture ...
[10:19:58.243] - result already collected: FutureResult
[10:19:58.243] result() for ClusterFuture ... done
[10:19:58.244] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:58.244] - nx: 2
[10:19:58.244] - relay: TRUE
[10:19:58.244] - stdout: TRUE
[10:19:58.244] - signal: TRUE
[10:19:58.244] - resignal: FALSE
[10:19:58.244] - force: TRUE
[10:19:58.244] - relayed: [n=2] FALSE, FALSE
[10:19:58.244] - queued futures: [n=2] FALSE, FALSE
[10:19:58.244]  - until=1
[10:19:58.244]  - relaying element #1
[10:19:58.244] result() for ClusterFuture ...
[10:19:58.245] - result already collected: FutureResult
[10:19:58.245] result() for ClusterFuture ... done
[10:19:58.245] result() for ClusterFuture ...
[10:19:58.245] - result already collected: FutureResult
[10:19:58.245] result() for ClusterFuture ... done
[10:19:58.245] result() for ClusterFuture ...
[10:19:58.245] - result already collected: FutureResult
[10:19:58.245] result() for ClusterFuture ... done
[10:19:58.245] result() for ClusterFuture ...
[10:19:58.245] - result already collected: FutureResult
[10:19:58.245] result() for ClusterFuture ... done
[10:19:58.245] - relayed: [n=2] TRUE, FALSE
[10:19:58.245] - queued futures: [n=2] TRUE, FALSE
[10:19:58.246] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:58.246]  length: 1 (resolved future 1)
[10:19:58.271] receiveMessageFromWorker() for ClusterFuture ...
[10:19:58.271] - Validating connection of MultisessionFuture
[10:19:58.271] - received message: FutureResult
[10:19:58.272] - Received FutureResult
[10:19:58.272] - Erased future from FutureRegistry
[10:19:58.272] result() for ClusterFuture ...
[10:19:58.272] - result already collected: FutureResult
[10:19:58.272] result() for ClusterFuture ... done
[10:19:58.272] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:58.272] Future #2
[10:19:58.272] result() for ClusterFuture ...
[10:19:58.272] - result already collected: FutureResult
[10:19:58.272] result() for ClusterFuture ... done
[10:19:58.272] result() for ClusterFuture ...
[10:19:58.273] - result already collected: FutureResult
[10:19:58.273] result() for ClusterFuture ... done
[10:19:58.273] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:58.273] - nx: 2
[10:19:58.273] - relay: TRUE
[10:19:58.273] - stdout: TRUE
[10:19:58.273] - signal: TRUE
[10:19:58.273] - resignal: FALSE
[10:19:58.273] - force: TRUE
[10:19:58.273] - relayed: [n=2] TRUE, FALSE
[10:19:58.273] - queued futures: [n=2] TRUE, FALSE
[10:19:58.273]  - until=2
[10:19:58.273]  - relaying element #2
[10:19:58.274] result() for ClusterFuture ...
[10:19:58.274] - result already collected: FutureResult
[10:19:58.274] result() for ClusterFuture ... done
[10:19:58.274] result() for ClusterFuture ...
[10:19:58.274] - result already collected: FutureResult
[10:19:58.274] result() for ClusterFuture ... done
[10:19:58.274] result() for ClusterFuture ...
[10:19:58.274] - result already collected: FutureResult
[10:19:58.274] result() for ClusterFuture ... done
[10:19:58.274] result() for ClusterFuture ...
[10:19:58.274] - result already collected: FutureResult
[10:19:58.274] result() for ClusterFuture ... done
[10:19:58.275] - relayed: [n=2] TRUE, TRUE
[10:19:58.275] - queued futures: [n=2] TRUE, TRUE
[10:19:58.275] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:58.275]  length: 0 (resolved future 2)
[10:19:58.275] Relaying remaining futures
[10:19:58.275] signalConditionsASAP(NULL, pos=0) ...
[10:19:58.275] - nx: 2
[10:19:58.275] - relay: TRUE
[10:19:58.275] - stdout: TRUE
[10:19:58.275] - signal: TRUE
[10:19:58.275] - resignal: FALSE
[10:19:58.275] - force: TRUE
[10:19:58.276] - relayed: [n=2] TRUE, TRUE
[10:19:58.276] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:58.276] - relayed: [n=2] TRUE, TRUE
[10:19:58.276] - queued futures: [n=2] TRUE, TRUE
[10:19:58.276] signalConditionsASAP(NULL, pos=0) ... done
[10:19:58.276] resolve() on list ... DONE
[10:19:58.276] result() for ClusterFuture ...
[10:19:58.276] - result already collected: FutureResult
[10:19:58.276] result() for ClusterFuture ... done
[10:19:58.276] result() for ClusterFuture ...
[10:19:58.276] - result already collected: FutureResult
[10:19:58.276] result() for ClusterFuture ... done
[10:19:58.277] result() for ClusterFuture ...
[10:19:58.277] - result already collected: FutureResult
[10:19:58.277] result() for ClusterFuture ... done
[10:19:58.277] result() for ClusterFuture ...
[10:19:58.277] - result already collected: FutureResult
[10:19:58.277] result() for ClusterFuture ... done
[10:19:58.277]  - Number of value chunks collected: 2
[10:19:58.277] Resolving 2 futures (chunks) ... DONE
[10:19:58.277] Reducing values from 2 chunks ...
[10:19:58.277]  - Number of values collected after concatenation: 7
[10:19:58.277]  - Number of values expected: 7
[10:19:58.278] Reducing values from 2 chunks ... DONE
[10:19:58.278] future_lapply() ... DONE
[10:19:58.278] future_lapply() ...
[10:19:58.281] Number of chunks: 2
[10:19:58.281] getGlobalsAndPackagesXApply() ...
[10:19:58.281]  - future.globals: TRUE
[10:19:58.281] getGlobalsAndPackages() ...
[10:19:58.281] Searching for globals...
[10:19:58.288] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:19:58.288] Searching for globals ... DONE
[10:19:58.288] Resolving globals: FALSE
[10:19:58.290] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[10:19:58.290] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[10:19:58.290] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:58.290] - packages: [2] ‘stats’, ‘future.apply’
[10:19:58.290] getGlobalsAndPackages() ... DONE
[10:19:58.290]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:58.291]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:19:58.291] Finding globals ... DONE
[10:19:58.291]  - use_args: TRUE
[10:19:58.291]  - Getting '...' globals ...
[10:19:58.291] resolve() on list ...
[10:19:58.291]  recursive: 0
[10:19:58.291]  length: 1
[10:19:58.291]  elements: ‘...’
[10:19:58.291]  length: 0 (resolved future 1)
[10:19:58.292] resolve() on list ... DONE
[10:19:58.292]    - '...' content: [n=0] 
[10:19:58.292] List of 1
[10:19:58.292]  $ ...: list()
[10:19:58.292]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.292]  - attr(*, "where")=List of 1
[10:19:58.292]   ..$ ...:<environment: 0x55c6a109eb90> 
[10:19:58.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.292]  - attr(*, "resolved")= logi TRUE
[10:19:58.292]  - attr(*, "total_size")= num NA
[10:19:58.294]  - Getting '...' globals ... DONE
[10:19:58.294] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:58.294] List of 8
[10:19:58.294]  $ ...future.FUN:function (x, ...)  
[10:19:58.294]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:19:58.294]  $ times        : int 5
[10:19:58.294]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:58.294]  $ stop_if_not  :function (...)  
[10:19:58.294]  $ dim          : NULL
[10:19:58.294]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:58.294]  $ ...          : list()
[10:19:58.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.294]  - attr(*, "where")=List of 8
[10:19:58.294]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:58.294]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:58.294]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:58.294]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:58.294]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:58.294]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:58.294]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:58.294]   ..$ ...          :<environment: 0x55c6a109eb90> 
[10:19:58.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.294]  - attr(*, "resolved")= logi FALSE
[10:19:58.294]  - attr(*, "total_size")= num 48005
[10:19:58.300] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:19:58.300] getGlobalsAndPackagesXApply() ... DONE
[10:19:58.300] Number of futures (= number of chunks): 2
[10:19:58.300] Launching 2 futures (chunks) ...
[10:19:58.300] Chunk #1 of 2 ...
[10:19:58.300]  - Finding globals in 'X' for chunk #1 ...
[10:19:58.300] getGlobalsAndPackages() ...
[10:19:58.301] Searching for globals...
[10:19:58.301] 
[10:19:58.301] Searching for globals ... DONE
[10:19:58.301] - globals: [0] <none>
[10:19:58.301] getGlobalsAndPackages() ... DONE
[10:19:58.301]    + additional globals found: [n=0] 
[10:19:58.301]    + additional namespaces needed: [n=0] 
[10:19:58.301]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:58.303]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:58.303]  - seeds: <none>
[10:19:58.303]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.304] getGlobalsAndPackages() ...
[10:19:58.304] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.304] Resolving globals: FALSE
[10:19:58.304] Tweak future expression to call with '...' arguments ...
[10:19:58.304] {
[10:19:58.304]     do.call(function(...) {
[10:19:58.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.304]             on.exit(options(oopts), add = TRUE)
[10:19:58.304]         }
[10:19:58.304]         {
[10:19:58.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.304]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.304]             })
[10:19:58.304]         }
[10:19:58.304]     }, args = future.call.arguments)
[10:19:58.304] }
[10:19:58.304] Tweak future expression to call with '...' arguments ... DONE
[10:19:58.305] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.305] - packages: [2] ‘stats’, ‘future.apply’
[10:19:58.305] getGlobalsAndPackages() ... DONE
[10:19:58.305] run() for ‘Future’ ...
[10:19:58.305] - state: ‘created’
[10:19:58.305] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:58.319] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.319] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:58.319]   - Field: ‘node’
[10:19:58.320]   - Field: ‘label’
[10:19:58.320]   - Field: ‘local’
[10:19:58.320]   - Field: ‘owner’
[10:19:58.320]   - Field: ‘envir’
[10:19:58.320]   - Field: ‘workers’
[10:19:58.320]   - Field: ‘packages’
[10:19:58.320]   - Field: ‘gc’
[10:19:58.320]   - Field: ‘conditions’
[10:19:58.320]   - Field: ‘persistent’
[10:19:58.320]   - Field: ‘expr’
[10:19:58.320]   - Field: ‘uuid’
[10:19:58.320]   - Field: ‘seed’
[10:19:58.321]   - Field: ‘version’
[10:19:58.321]   - Field: ‘result’
[10:19:58.321]   - Field: ‘asynchronous’
[10:19:58.321]   - Field: ‘calls’
[10:19:58.321]   - Field: ‘globals’
[10:19:58.321]   - Field: ‘stdout’
[10:19:58.321]   - Field: ‘earlySignal’
[10:19:58.321]   - Field: ‘lazy’
[10:19:58.321]   - Field: ‘state’
[10:19:58.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:58.321] - Launch lazy future ...
[10:19:58.322] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:58.322] Packages needed by future strategies (n = 0): <none>
[10:19:58.322] {
[10:19:58.322]     {
[10:19:58.322]         {
[10:19:58.322]             ...future.startTime <- base::Sys.time()
[10:19:58.322]             {
[10:19:58.322]                 {
[10:19:58.322]                   {
[10:19:58.322]                     {
[10:19:58.322]                       {
[10:19:58.322]                         base::local({
[10:19:58.322]                           has_future <- base::requireNamespace("future", 
[10:19:58.322]                             quietly = TRUE)
[10:19:58.322]                           if (has_future) {
[10:19:58.322]                             ns <- base::getNamespace("future")
[10:19:58.322]                             version <- ns[[".package"]][["version"]]
[10:19:58.322]                             if (is.null(version)) 
[10:19:58.322]                               version <- utils::packageVersion("future")
[10:19:58.322]                           }
[10:19:58.322]                           else {
[10:19:58.322]                             version <- NULL
[10:19:58.322]                           }
[10:19:58.322]                           if (!has_future || version < "1.8.0") {
[10:19:58.322]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:58.322]                               "", base::R.version$version.string), 
[10:19:58.322]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:58.322]                                 base::R.version$platform, 8 * 
[10:19:58.322]                                   base::.Machine$sizeof.pointer), 
[10:19:58.322]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:58.322]                                 "release", "version")], collapse = " "), 
[10:19:58.322]                               hostname = base::Sys.info()[["nodename"]])
[10:19:58.322]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:58.322]                               info)
[10:19:58.322]                             info <- base::paste(info, collapse = "; ")
[10:19:58.322]                             if (!has_future) {
[10:19:58.322]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:58.322]                                 info)
[10:19:58.322]                             }
[10:19:58.322]                             else {
[10:19:58.322]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:58.322]                                 info, version)
[10:19:58.322]                             }
[10:19:58.322]                             base::stop(msg)
[10:19:58.322]                           }
[10:19:58.322]                         })
[10:19:58.322]                       }
[10:19:58.322]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:58.322]                       base::options(mc.cores = 1L)
[10:19:58.322]                     }
[10:19:58.322]                     base::local({
[10:19:58.322]                       for (pkg in c("stats", "future.apply")) {
[10:19:58.322]                         base::loadNamespace(pkg)
[10:19:58.322]                         base::library(pkg, character.only = TRUE)
[10:19:58.322]                       }
[10:19:58.322]                     })
[10:19:58.322]                   }
[10:19:58.322]                   ...future.strategy.old <- future::plan("list")
[10:19:58.322]                   options(future.plan = NULL)
[10:19:58.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:58.322]                 }
[10:19:58.322]                 ...future.workdir <- getwd()
[10:19:58.322]             }
[10:19:58.322]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:58.322]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:58.322]         }
[10:19:58.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:58.322]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:58.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:58.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:58.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:58.322]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:58.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:58.322]             base::names(...future.oldOptions))
[10:19:58.322]     }
[10:19:58.322]     if (FALSE) {
[10:19:58.322]     }
[10:19:58.322]     else {
[10:19:58.322]         if (TRUE) {
[10:19:58.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:58.322]                 open = "w")
[10:19:58.322]         }
[10:19:58.322]         else {
[10:19:58.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:58.322]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:58.322]         }
[10:19:58.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:58.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:58.322]             base::sink(type = "output", split = FALSE)
[10:19:58.322]             base::close(...future.stdout)
[10:19:58.322]         }, add = TRUE)
[10:19:58.322]     }
[10:19:58.322]     ...future.frame <- base::sys.nframe()
[10:19:58.322]     ...future.conditions <- base::list()
[10:19:58.322]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:58.322]     if (FALSE) {
[10:19:58.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:58.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:58.322]     }
[10:19:58.322]     ...future.result <- base::tryCatch({
[10:19:58.322]         base::withCallingHandlers({
[10:19:58.322]             ...future.value <- base::withVisible(base::local({
[10:19:58.322]                 ...future.makeSendCondition <- base::local({
[10:19:58.322]                   sendCondition <- NULL
[10:19:58.322]                   function(frame = 1L) {
[10:19:58.322]                     if (is.function(sendCondition)) 
[10:19:58.322]                       return(sendCondition)
[10:19:58.322]                     ns <- getNamespace("parallel")
[10:19:58.322]                     if (exists("sendData", mode = "function", 
[10:19:58.322]                       envir = ns)) {
[10:19:58.322]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:58.322]                         envir = ns)
[10:19:58.322]                       envir <- sys.frame(frame)
[10:19:58.322]                       master <- NULL
[10:19:58.322]                       while (!identical(envir, .GlobalEnv) && 
[10:19:58.322]                         !identical(envir, emptyenv())) {
[10:19:58.322]                         if (exists("master", mode = "list", envir = envir, 
[10:19:58.322]                           inherits = FALSE)) {
[10:19:58.322]                           master <- get("master", mode = "list", 
[10:19:58.322]                             envir = envir, inherits = FALSE)
[10:19:58.322]                           if (inherits(master, c("SOCKnode", 
[10:19:58.322]                             "SOCK0node"))) {
[10:19:58.322]                             sendCondition <<- function(cond) {
[10:19:58.322]                               data <- list(type = "VALUE", value = cond, 
[10:19:58.322]                                 success = TRUE)
[10:19:58.322]                               parallel_sendData(master, data)
[10:19:58.322]                             }
[10:19:58.322]                             return(sendCondition)
[10:19:58.322]                           }
[10:19:58.322]                         }
[10:19:58.322]                         frame <- frame + 1L
[10:19:58.322]                         envir <- sys.frame(frame)
[10:19:58.322]                       }
[10:19:58.322]                     }
[10:19:58.322]                     sendCondition <<- function(cond) NULL
[10:19:58.322]                   }
[10:19:58.322]                 })
[10:19:58.322]                 withCallingHandlers({
[10:19:58.322]                   {
[10:19:58.322]                     do.call(function(...) {
[10:19:58.322]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.322]                       if (!identical(...future.globals.maxSize.org, 
[10:19:58.322]                         ...future.globals.maxSize)) {
[10:19:58.322]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.322]                         on.exit(options(oopts), add = TRUE)
[10:19:58.322]                       }
[10:19:58.322]                       {
[10:19:58.322]                         lapply(seq_along(...future.elements_ii), 
[10:19:58.322]                           FUN = function(jj) {
[10:19:58.322]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.322]                             ...future.FUN(...future.X_jj, ...)
[10:19:58.322]                           })
[10:19:58.322]                       }
[10:19:58.322]                     }, args = future.call.arguments)
[10:19:58.322]                   }
[10:19:58.322]                 }, immediateCondition = function(cond) {
[10:19:58.322]                   sendCondition <- ...future.makeSendCondition()
[10:19:58.322]                   sendCondition(cond)
[10:19:58.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.322]                   {
[10:19:58.322]                     inherits <- base::inherits
[10:19:58.322]                     invokeRestart <- base::invokeRestart
[10:19:58.322]                     is.null <- base::is.null
[10:19:58.322]                     muffled <- FALSE
[10:19:58.322]                     if (inherits(cond, "message")) {
[10:19:58.322]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:58.322]                       if (muffled) 
[10:19:58.322]                         invokeRestart("muffleMessage")
[10:19:58.322]                     }
[10:19:58.322]                     else if (inherits(cond, "warning")) {
[10:19:58.322]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:58.322]                       if (muffled) 
[10:19:58.322]                         invokeRestart("muffleWarning")
[10:19:58.322]                     }
[10:19:58.322]                     else if (inherits(cond, "condition")) {
[10:19:58.322]                       if (!is.null(pattern)) {
[10:19:58.322]                         computeRestarts <- base::computeRestarts
[10:19:58.322]                         grepl <- base::grepl
[10:19:58.322]                         restarts <- computeRestarts(cond)
[10:19:58.322]                         for (restart in restarts) {
[10:19:58.322]                           name <- restart$name
[10:19:58.322]                           if (is.null(name)) 
[10:19:58.322]                             next
[10:19:58.322]                           if (!grepl(pattern, name)) 
[10:19:58.322]                             next
[10:19:58.322]                           invokeRestart(restart)
[10:19:58.322]                           muffled <- TRUE
[10:19:58.322]                           break
[10:19:58.322]                         }
[10:19:58.322]                       }
[10:19:58.322]                     }
[10:19:58.322]                     invisible(muffled)
[10:19:58.322]                   }
[10:19:58.322]                   muffleCondition(cond)
[10:19:58.322]                 })
[10:19:58.322]             }))
[10:19:58.322]             future::FutureResult(value = ...future.value$value, 
[10:19:58.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.322]                   ...future.rng), globalenv = if (FALSE) 
[10:19:58.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:58.322]                     ...future.globalenv.names))
[10:19:58.322]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:58.322]         }, condition = base::local({
[10:19:58.322]             c <- base::c
[10:19:58.322]             inherits <- base::inherits
[10:19:58.322]             invokeRestart <- base::invokeRestart
[10:19:58.322]             length <- base::length
[10:19:58.322]             list <- base::list
[10:19:58.322]             seq.int <- base::seq.int
[10:19:58.322]             signalCondition <- base::signalCondition
[10:19:58.322]             sys.calls <- base::sys.calls
[10:19:58.322]             `[[` <- base::`[[`
[10:19:58.322]             `+` <- base::`+`
[10:19:58.322]             `<<-` <- base::`<<-`
[10:19:58.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:58.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:58.322]                   3L)]
[10:19:58.322]             }
[10:19:58.322]             function(cond) {
[10:19:58.322]                 is_error <- inherits(cond, "error")
[10:19:58.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:58.322]                   NULL)
[10:19:58.322]                 if (is_error) {
[10:19:58.322]                   sessionInformation <- function() {
[10:19:58.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:58.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:58.322]                       search = base::search(), system = base::Sys.info())
[10:19:58.322]                   }
[10:19:58.322]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:58.322]                     cond$call), session = sessionInformation(), 
[10:19:58.322]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:58.322]                   signalCondition(cond)
[10:19:58.322]                 }
[10:19:58.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:58.322]                 "immediateCondition"))) {
[10:19:58.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:58.322]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:58.322]                   if (TRUE && !signal) {
[10:19:58.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.322]                     {
[10:19:58.322]                       inherits <- base::inherits
[10:19:58.322]                       invokeRestart <- base::invokeRestart
[10:19:58.322]                       is.null <- base::is.null
[10:19:58.322]                       muffled <- FALSE
[10:19:58.322]                       if (inherits(cond, "message")) {
[10:19:58.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.322]                         if (muffled) 
[10:19:58.322]                           invokeRestart("muffleMessage")
[10:19:58.322]                       }
[10:19:58.322]                       else if (inherits(cond, "warning")) {
[10:19:58.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.322]                         if (muffled) 
[10:19:58.322]                           invokeRestart("muffleWarning")
[10:19:58.322]                       }
[10:19:58.322]                       else if (inherits(cond, "condition")) {
[10:19:58.322]                         if (!is.null(pattern)) {
[10:19:58.322]                           computeRestarts <- base::computeRestarts
[10:19:58.322]                           grepl <- base::grepl
[10:19:58.322]                           restarts <- computeRestarts(cond)
[10:19:58.322]                           for (restart in restarts) {
[10:19:58.322]                             name <- restart$name
[10:19:58.322]                             if (is.null(name)) 
[10:19:58.322]                               next
[10:19:58.322]                             if (!grepl(pattern, name)) 
[10:19:58.322]                               next
[10:19:58.322]                             invokeRestart(restart)
[10:19:58.322]                             muffled <- TRUE
[10:19:58.322]                             break
[10:19:58.322]                           }
[10:19:58.322]                         }
[10:19:58.322]                       }
[10:19:58.322]                       invisible(muffled)
[10:19:58.322]                     }
[10:19:58.322]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.322]                   }
[10:19:58.322]                 }
[10:19:58.322]                 else {
[10:19:58.322]                   if (TRUE) {
[10:19:58.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.322]                     {
[10:19:58.322]                       inherits <- base::inherits
[10:19:58.322]                       invokeRestart <- base::invokeRestart
[10:19:58.322]                       is.null <- base::is.null
[10:19:58.322]                       muffled <- FALSE
[10:19:58.322]                       if (inherits(cond, "message")) {
[10:19:58.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.322]                         if (muffled) 
[10:19:58.322]                           invokeRestart("muffleMessage")
[10:19:58.322]                       }
[10:19:58.322]                       else if (inherits(cond, "warning")) {
[10:19:58.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.322]                         if (muffled) 
[10:19:58.322]                           invokeRestart("muffleWarning")
[10:19:58.322]                       }
[10:19:58.322]                       else if (inherits(cond, "condition")) {
[10:19:58.322]                         if (!is.null(pattern)) {
[10:19:58.322]                           computeRestarts <- base::computeRestarts
[10:19:58.322]                           grepl <- base::grepl
[10:19:58.322]                           restarts <- computeRestarts(cond)
[10:19:58.322]                           for (restart in restarts) {
[10:19:58.322]                             name <- restart$name
[10:19:58.322]                             if (is.null(name)) 
[10:19:58.322]                               next
[10:19:58.322]                             if (!grepl(pattern, name)) 
[10:19:58.322]                               next
[10:19:58.322]                             invokeRestart(restart)
[10:19:58.322]                             muffled <- TRUE
[10:19:58.322]                             break
[10:19:58.322]                           }
[10:19:58.322]                         }
[10:19:58.322]                       }
[10:19:58.322]                       invisible(muffled)
[10:19:58.322]                     }
[10:19:58.322]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.322]                   }
[10:19:58.322]                 }
[10:19:58.322]             }
[10:19:58.322]         }))
[10:19:58.322]     }, error = function(ex) {
[10:19:58.322]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:58.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.322]                 ...future.rng), started = ...future.startTime, 
[10:19:58.322]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:58.322]             version = "1.8"), class = "FutureResult")
[10:19:58.322]     }, finally = {
[10:19:58.322]         if (!identical(...future.workdir, getwd())) 
[10:19:58.322]             setwd(...future.workdir)
[10:19:58.322]         {
[10:19:58.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:58.322]                 ...future.oldOptions$nwarnings <- NULL
[10:19:58.322]             }
[10:19:58.322]             base::options(...future.oldOptions)
[10:19:58.322]             if (.Platform$OS.type == "windows") {
[10:19:58.322]                 old_names <- names(...future.oldEnvVars)
[10:19:58.322]                 envs <- base::Sys.getenv()
[10:19:58.322]                 names <- names(envs)
[10:19:58.322]                 common <- intersect(names, old_names)
[10:19:58.322]                 added <- setdiff(names, old_names)
[10:19:58.322]                 removed <- setdiff(old_names, names)
[10:19:58.322]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:58.322]                   envs[common]]
[10:19:58.322]                 NAMES <- toupper(changed)
[10:19:58.322]                 args <- list()
[10:19:58.322]                 for (kk in seq_along(NAMES)) {
[10:19:58.322]                   name <- changed[[kk]]
[10:19:58.322]                   NAME <- NAMES[[kk]]
[10:19:58.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.322]                     next
[10:19:58.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.322]                 }
[10:19:58.322]                 NAMES <- toupper(added)
[10:19:58.322]                 for (kk in seq_along(NAMES)) {
[10:19:58.322]                   name <- added[[kk]]
[10:19:58.322]                   NAME <- NAMES[[kk]]
[10:19:58.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.322]                     next
[10:19:58.322]                   args[[name]] <- ""
[10:19:58.322]                 }
[10:19:58.322]                 NAMES <- toupper(removed)
[10:19:58.322]                 for (kk in seq_along(NAMES)) {
[10:19:58.322]                   name <- removed[[kk]]
[10:19:58.322]                   NAME <- NAMES[[kk]]
[10:19:58.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.322]                     next
[10:19:58.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.322]                 }
[10:19:58.322]                 if (length(args) > 0) 
[10:19:58.322]                   base::do.call(base::Sys.setenv, args = args)
[10:19:58.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:58.322]             }
[10:19:58.322]             else {
[10:19:58.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:58.322]             }
[10:19:58.322]             {
[10:19:58.322]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:58.322]                   0L) {
[10:19:58.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:58.322]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:58.322]                   base::options(opts)
[10:19:58.322]                 }
[10:19:58.322]                 {
[10:19:58.322]                   {
[10:19:58.322]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:58.322]                     NULL
[10:19:58.322]                   }
[10:19:58.322]                   options(future.plan = NULL)
[10:19:58.322]                   if (is.na(NA_character_)) 
[10:19:58.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:58.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:58.322]                     .init = FALSE)
[10:19:58.322]                 }
[10:19:58.322]             }
[10:19:58.322]         }
[10:19:58.322]     })
[10:19:58.322]     if (TRUE) {
[10:19:58.322]         base::sink(type = "output", split = FALSE)
[10:19:58.322]         if (TRUE) {
[10:19:58.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:58.322]         }
[10:19:58.322]         else {
[10:19:58.322]             ...future.result["stdout"] <- base::list(NULL)
[10:19:58.322]         }
[10:19:58.322]         base::close(...future.stdout)
[10:19:58.322]         ...future.stdout <- NULL
[10:19:58.322]     }
[10:19:58.322]     ...future.result$conditions <- ...future.conditions
[10:19:58.322]     ...future.result$finished <- base::Sys.time()
[10:19:58.322]     ...future.result
[10:19:58.322] }
[10:19:58.325] Exporting 11 global objects (27.06 KiB) to cluster node #1 ...
[10:19:58.325] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #1 ...
[10:19:58.367] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #1 ... DONE
[10:19:58.367] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #1 ...
[10:19:58.407] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #1 ... DONE
[10:19:58.408] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:58.408] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:58.408] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:58.449] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:58.449] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:58.490] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:58.490] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:58.491] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:58.491] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:58.491] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:58.492] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:58.492] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:58.492] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ...
[10:19:58.492] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ... DONE
[10:19:58.493] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:58.493] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:58.493] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:58.493] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:58.493] Exporting 11 global objects (27.06 KiB) to cluster node #1 ... DONE
[10:19:58.494] MultisessionFuture started
[10:19:58.494] - Launch lazy future ... done
[10:19:58.494] run() for ‘MultisessionFuture’ ... done
[10:19:58.494] Created future:
[10:19:58.494] MultisessionFuture:
[10:19:58.494] Label: ‘future_vapply-1’
[10:19:58.494] Expression:
[10:19:58.494] {
[10:19:58.494]     do.call(function(...) {
[10:19:58.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.494]             on.exit(options(oopts), add = TRUE)
[10:19:58.494]         }
[10:19:58.494]         {
[10:19:58.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.494]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.494]             })
[10:19:58.494]         }
[10:19:58.494]     }, args = future.call.arguments)
[10:19:58.494] }
[10:19:58.494] Lazy evaluation: FALSE
[10:19:58.494] Asynchronous evaluation: TRUE
[10:19:58.494] Local evaluation: TRUE
[10:19:58.494] Environment: R_GlobalEnv
[10:19:58.494] Capture standard output: TRUE
[10:19:58.494] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:58.494] Globals: 11 objects totaling 27.22 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:58.494] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:58.494] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:58.494] Resolved: FALSE
[10:19:58.494] Value: <not collected>
[10:19:58.494] Conditions captured: <none>
[10:19:58.494] Early signaling: FALSE
[10:19:58.494] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:58.494] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.506] Chunk #1 of 2 ... DONE
[10:19:58.506] Chunk #2 of 2 ...
[10:19:58.506]  - Finding globals in 'X' for chunk #2 ...
[10:19:58.506] getGlobalsAndPackages() ...
[10:19:58.506] Searching for globals...
[10:19:58.507] 
[10:19:58.507] Searching for globals ... DONE
[10:19:58.507] - globals: [0] <none>
[10:19:58.507] getGlobalsAndPackages() ... DONE
[10:19:58.507]    + additional globals found: [n=0] 
[10:19:58.507]    + additional namespaces needed: [n=0] 
[10:19:58.507]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:58.507]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:58.507]  - seeds: <none>
[10:19:58.507]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.507] getGlobalsAndPackages() ...
[10:19:58.508] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.508] Resolving globals: FALSE
[10:19:58.508] Tweak future expression to call with '...' arguments ...
[10:19:58.508] {
[10:19:58.508]     do.call(function(...) {
[10:19:58.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.508]             on.exit(options(oopts), add = TRUE)
[10:19:58.508]         }
[10:19:58.508]         {
[10:19:58.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.508]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.508]             })
[10:19:58.508]         }
[10:19:58.508]     }, args = future.call.arguments)
[10:19:58.508] }
[10:19:58.508] Tweak future expression to call with '...' arguments ... DONE
[10:19:58.509] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.509] - packages: [2] ‘stats’, ‘future.apply’
[10:19:58.509] getGlobalsAndPackages() ... DONE
[10:19:58.509] run() for ‘Future’ ...
[10:19:58.509] - state: ‘created’
[10:19:58.509] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:58.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:58.523]   - Field: ‘node’
[10:19:58.523]   - Field: ‘label’
[10:19:58.523]   - Field: ‘local’
[10:19:58.523]   - Field: ‘owner’
[10:19:58.524]   - Field: ‘envir’
[10:19:58.524]   - Field: ‘workers’
[10:19:58.524]   - Field: ‘packages’
[10:19:58.524]   - Field: ‘gc’
[10:19:58.524]   - Field: ‘conditions’
[10:19:58.524]   - Field: ‘persistent’
[10:19:58.524]   - Field: ‘expr’
[10:19:58.524]   - Field: ‘uuid’
[10:19:58.524]   - Field: ‘seed’
[10:19:58.524]   - Field: ‘version’
[10:19:58.524]   - Field: ‘result’
[10:19:58.524]   - Field: ‘asynchronous’
[10:19:58.524]   - Field: ‘calls’
[10:19:58.525]   - Field: ‘globals’
[10:19:58.525]   - Field: ‘stdout’
[10:19:58.525]   - Field: ‘earlySignal’
[10:19:58.525]   - Field: ‘lazy’
[10:19:58.525]   - Field: ‘state’
[10:19:58.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:58.525] - Launch lazy future ...
[10:19:58.525] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:19:58.525] Packages needed by future strategies (n = 0): <none>
[10:19:58.526] {
[10:19:58.526]     {
[10:19:58.526]         {
[10:19:58.526]             ...future.startTime <- base::Sys.time()
[10:19:58.526]             {
[10:19:58.526]                 {
[10:19:58.526]                   {
[10:19:58.526]                     {
[10:19:58.526]                       {
[10:19:58.526]                         base::local({
[10:19:58.526]                           has_future <- base::requireNamespace("future", 
[10:19:58.526]                             quietly = TRUE)
[10:19:58.526]                           if (has_future) {
[10:19:58.526]                             ns <- base::getNamespace("future")
[10:19:58.526]                             version <- ns[[".package"]][["version"]]
[10:19:58.526]                             if (is.null(version)) 
[10:19:58.526]                               version <- utils::packageVersion("future")
[10:19:58.526]                           }
[10:19:58.526]                           else {
[10:19:58.526]                             version <- NULL
[10:19:58.526]                           }
[10:19:58.526]                           if (!has_future || version < "1.8.0") {
[10:19:58.526]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:58.526]                               "", base::R.version$version.string), 
[10:19:58.526]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:58.526]                                 base::R.version$platform, 8 * 
[10:19:58.526]                                   base::.Machine$sizeof.pointer), 
[10:19:58.526]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:58.526]                                 "release", "version")], collapse = " "), 
[10:19:58.526]                               hostname = base::Sys.info()[["nodename"]])
[10:19:58.526]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:58.526]                               info)
[10:19:58.526]                             info <- base::paste(info, collapse = "; ")
[10:19:58.526]                             if (!has_future) {
[10:19:58.526]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:58.526]                                 info)
[10:19:58.526]                             }
[10:19:58.526]                             else {
[10:19:58.526]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:58.526]                                 info, version)
[10:19:58.526]                             }
[10:19:58.526]                             base::stop(msg)
[10:19:58.526]                           }
[10:19:58.526]                         })
[10:19:58.526]                       }
[10:19:58.526]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:58.526]                       base::options(mc.cores = 1L)
[10:19:58.526]                     }
[10:19:58.526]                     base::local({
[10:19:58.526]                       for (pkg in c("stats", "future.apply")) {
[10:19:58.526]                         base::loadNamespace(pkg)
[10:19:58.526]                         base::library(pkg, character.only = TRUE)
[10:19:58.526]                       }
[10:19:58.526]                     })
[10:19:58.526]                   }
[10:19:58.526]                   ...future.strategy.old <- future::plan("list")
[10:19:58.526]                   options(future.plan = NULL)
[10:19:58.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:58.526]                 }
[10:19:58.526]                 ...future.workdir <- getwd()
[10:19:58.526]             }
[10:19:58.526]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:58.526]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:58.526]         }
[10:19:58.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:58.526]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:58.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:58.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:58.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:58.526]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:58.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:58.526]             base::names(...future.oldOptions))
[10:19:58.526]     }
[10:19:58.526]     if (FALSE) {
[10:19:58.526]     }
[10:19:58.526]     else {
[10:19:58.526]         if (TRUE) {
[10:19:58.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:58.526]                 open = "w")
[10:19:58.526]         }
[10:19:58.526]         else {
[10:19:58.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:58.526]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:58.526]         }
[10:19:58.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:58.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:58.526]             base::sink(type = "output", split = FALSE)
[10:19:58.526]             base::close(...future.stdout)
[10:19:58.526]         }, add = TRUE)
[10:19:58.526]     }
[10:19:58.526]     ...future.frame <- base::sys.nframe()
[10:19:58.526]     ...future.conditions <- base::list()
[10:19:58.526]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:58.526]     if (FALSE) {
[10:19:58.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:58.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:58.526]     }
[10:19:58.526]     ...future.result <- base::tryCatch({
[10:19:58.526]         base::withCallingHandlers({
[10:19:58.526]             ...future.value <- base::withVisible(base::local({
[10:19:58.526]                 ...future.makeSendCondition <- base::local({
[10:19:58.526]                   sendCondition <- NULL
[10:19:58.526]                   function(frame = 1L) {
[10:19:58.526]                     if (is.function(sendCondition)) 
[10:19:58.526]                       return(sendCondition)
[10:19:58.526]                     ns <- getNamespace("parallel")
[10:19:58.526]                     if (exists("sendData", mode = "function", 
[10:19:58.526]                       envir = ns)) {
[10:19:58.526]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:58.526]                         envir = ns)
[10:19:58.526]                       envir <- sys.frame(frame)
[10:19:58.526]                       master <- NULL
[10:19:58.526]                       while (!identical(envir, .GlobalEnv) && 
[10:19:58.526]                         !identical(envir, emptyenv())) {
[10:19:58.526]                         if (exists("master", mode = "list", envir = envir, 
[10:19:58.526]                           inherits = FALSE)) {
[10:19:58.526]                           master <- get("master", mode = "list", 
[10:19:58.526]                             envir = envir, inherits = FALSE)
[10:19:58.526]                           if (inherits(master, c("SOCKnode", 
[10:19:58.526]                             "SOCK0node"))) {
[10:19:58.526]                             sendCondition <<- function(cond) {
[10:19:58.526]                               data <- list(type = "VALUE", value = cond, 
[10:19:58.526]                                 success = TRUE)
[10:19:58.526]                               parallel_sendData(master, data)
[10:19:58.526]                             }
[10:19:58.526]                             return(sendCondition)
[10:19:58.526]                           }
[10:19:58.526]                         }
[10:19:58.526]                         frame <- frame + 1L
[10:19:58.526]                         envir <- sys.frame(frame)
[10:19:58.526]                       }
[10:19:58.526]                     }
[10:19:58.526]                     sendCondition <<- function(cond) NULL
[10:19:58.526]                   }
[10:19:58.526]                 })
[10:19:58.526]                 withCallingHandlers({
[10:19:58.526]                   {
[10:19:58.526]                     do.call(function(...) {
[10:19:58.526]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.526]                       if (!identical(...future.globals.maxSize.org, 
[10:19:58.526]                         ...future.globals.maxSize)) {
[10:19:58.526]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.526]                         on.exit(options(oopts), add = TRUE)
[10:19:58.526]                       }
[10:19:58.526]                       {
[10:19:58.526]                         lapply(seq_along(...future.elements_ii), 
[10:19:58.526]                           FUN = function(jj) {
[10:19:58.526]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.526]                             ...future.FUN(...future.X_jj, ...)
[10:19:58.526]                           })
[10:19:58.526]                       }
[10:19:58.526]                     }, args = future.call.arguments)
[10:19:58.526]                   }
[10:19:58.526]                 }, immediateCondition = function(cond) {
[10:19:58.526]                   sendCondition <- ...future.makeSendCondition()
[10:19:58.526]                   sendCondition(cond)
[10:19:58.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.526]                   {
[10:19:58.526]                     inherits <- base::inherits
[10:19:58.526]                     invokeRestart <- base::invokeRestart
[10:19:58.526]                     is.null <- base::is.null
[10:19:58.526]                     muffled <- FALSE
[10:19:58.526]                     if (inherits(cond, "message")) {
[10:19:58.526]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:58.526]                       if (muffled) 
[10:19:58.526]                         invokeRestart("muffleMessage")
[10:19:58.526]                     }
[10:19:58.526]                     else if (inherits(cond, "warning")) {
[10:19:58.526]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:58.526]                       if (muffled) 
[10:19:58.526]                         invokeRestart("muffleWarning")
[10:19:58.526]                     }
[10:19:58.526]                     else if (inherits(cond, "condition")) {
[10:19:58.526]                       if (!is.null(pattern)) {
[10:19:58.526]                         computeRestarts <- base::computeRestarts
[10:19:58.526]                         grepl <- base::grepl
[10:19:58.526]                         restarts <- computeRestarts(cond)
[10:19:58.526]                         for (restart in restarts) {
[10:19:58.526]                           name <- restart$name
[10:19:58.526]                           if (is.null(name)) 
[10:19:58.526]                             next
[10:19:58.526]                           if (!grepl(pattern, name)) 
[10:19:58.526]                             next
[10:19:58.526]                           invokeRestart(restart)
[10:19:58.526]                           muffled <- TRUE
[10:19:58.526]                           break
[10:19:58.526]                         }
[10:19:58.526]                       }
[10:19:58.526]                     }
[10:19:58.526]                     invisible(muffled)
[10:19:58.526]                   }
[10:19:58.526]                   muffleCondition(cond)
[10:19:58.526]                 })
[10:19:58.526]             }))
[10:19:58.526]             future::FutureResult(value = ...future.value$value, 
[10:19:58.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.526]                   ...future.rng), globalenv = if (FALSE) 
[10:19:58.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:58.526]                     ...future.globalenv.names))
[10:19:58.526]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:58.526]         }, condition = base::local({
[10:19:58.526]             c <- base::c
[10:19:58.526]             inherits <- base::inherits
[10:19:58.526]             invokeRestart <- base::invokeRestart
[10:19:58.526]             length <- base::length
[10:19:58.526]             list <- base::list
[10:19:58.526]             seq.int <- base::seq.int
[10:19:58.526]             signalCondition <- base::signalCondition
[10:19:58.526]             sys.calls <- base::sys.calls
[10:19:58.526]             `[[` <- base::`[[`
[10:19:58.526]             `+` <- base::`+`
[10:19:58.526]             `<<-` <- base::`<<-`
[10:19:58.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:58.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:58.526]                   3L)]
[10:19:58.526]             }
[10:19:58.526]             function(cond) {
[10:19:58.526]                 is_error <- inherits(cond, "error")
[10:19:58.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:58.526]                   NULL)
[10:19:58.526]                 if (is_error) {
[10:19:58.526]                   sessionInformation <- function() {
[10:19:58.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:58.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:58.526]                       search = base::search(), system = base::Sys.info())
[10:19:58.526]                   }
[10:19:58.526]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:58.526]                     cond$call), session = sessionInformation(), 
[10:19:58.526]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:58.526]                   signalCondition(cond)
[10:19:58.526]                 }
[10:19:58.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:58.526]                 "immediateCondition"))) {
[10:19:58.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:58.526]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:58.526]                   if (TRUE && !signal) {
[10:19:58.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.526]                     {
[10:19:58.526]                       inherits <- base::inherits
[10:19:58.526]                       invokeRestart <- base::invokeRestart
[10:19:58.526]                       is.null <- base::is.null
[10:19:58.526]                       muffled <- FALSE
[10:19:58.526]                       if (inherits(cond, "message")) {
[10:19:58.526]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.526]                         if (muffled) 
[10:19:58.526]                           invokeRestart("muffleMessage")
[10:19:58.526]                       }
[10:19:58.526]                       else if (inherits(cond, "warning")) {
[10:19:58.526]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.526]                         if (muffled) 
[10:19:58.526]                           invokeRestart("muffleWarning")
[10:19:58.526]                       }
[10:19:58.526]                       else if (inherits(cond, "condition")) {
[10:19:58.526]                         if (!is.null(pattern)) {
[10:19:58.526]                           computeRestarts <- base::computeRestarts
[10:19:58.526]                           grepl <- base::grepl
[10:19:58.526]                           restarts <- computeRestarts(cond)
[10:19:58.526]                           for (restart in restarts) {
[10:19:58.526]                             name <- restart$name
[10:19:58.526]                             if (is.null(name)) 
[10:19:58.526]                               next
[10:19:58.526]                             if (!grepl(pattern, name)) 
[10:19:58.526]                               next
[10:19:58.526]                             invokeRestart(restart)
[10:19:58.526]                             muffled <- TRUE
[10:19:58.526]                             break
[10:19:58.526]                           }
[10:19:58.526]                         }
[10:19:58.526]                       }
[10:19:58.526]                       invisible(muffled)
[10:19:58.526]                     }
[10:19:58.526]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.526]                   }
[10:19:58.526]                 }
[10:19:58.526]                 else {
[10:19:58.526]                   if (TRUE) {
[10:19:58.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.526]                     {
[10:19:58.526]                       inherits <- base::inherits
[10:19:58.526]                       invokeRestart <- base::invokeRestart
[10:19:58.526]                       is.null <- base::is.null
[10:19:58.526]                       muffled <- FALSE
[10:19:58.526]                       if (inherits(cond, "message")) {
[10:19:58.526]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.526]                         if (muffled) 
[10:19:58.526]                           invokeRestart("muffleMessage")
[10:19:58.526]                       }
[10:19:58.526]                       else if (inherits(cond, "warning")) {
[10:19:58.526]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.526]                         if (muffled) 
[10:19:58.526]                           invokeRestart("muffleWarning")
[10:19:58.526]                       }
[10:19:58.526]                       else if (inherits(cond, "condition")) {
[10:19:58.526]                         if (!is.null(pattern)) {
[10:19:58.526]                           computeRestarts <- base::computeRestarts
[10:19:58.526]                           grepl <- base::grepl
[10:19:58.526]                           restarts <- computeRestarts(cond)
[10:19:58.526]                           for (restart in restarts) {
[10:19:58.526]                             name <- restart$name
[10:19:58.526]                             if (is.null(name)) 
[10:19:58.526]                               next
[10:19:58.526]                             if (!grepl(pattern, name)) 
[10:19:58.526]                               next
[10:19:58.526]                             invokeRestart(restart)
[10:19:58.526]                             muffled <- TRUE
[10:19:58.526]                             break
[10:19:58.526]                           }
[10:19:58.526]                         }
[10:19:58.526]                       }
[10:19:58.526]                       invisible(muffled)
[10:19:58.526]                     }
[10:19:58.526]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.526]                   }
[10:19:58.526]                 }
[10:19:58.526]             }
[10:19:58.526]         }))
[10:19:58.526]     }, error = function(ex) {
[10:19:58.526]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:58.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.526]                 ...future.rng), started = ...future.startTime, 
[10:19:58.526]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:58.526]             version = "1.8"), class = "FutureResult")
[10:19:58.526]     }, finally = {
[10:19:58.526]         if (!identical(...future.workdir, getwd())) 
[10:19:58.526]             setwd(...future.workdir)
[10:19:58.526]         {
[10:19:58.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:58.526]                 ...future.oldOptions$nwarnings <- NULL
[10:19:58.526]             }
[10:19:58.526]             base::options(...future.oldOptions)
[10:19:58.526]             if (.Platform$OS.type == "windows") {
[10:19:58.526]                 old_names <- names(...future.oldEnvVars)
[10:19:58.526]                 envs <- base::Sys.getenv()
[10:19:58.526]                 names <- names(envs)
[10:19:58.526]                 common <- intersect(names, old_names)
[10:19:58.526]                 added <- setdiff(names, old_names)
[10:19:58.526]                 removed <- setdiff(old_names, names)
[10:19:58.526]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:58.526]                   envs[common]]
[10:19:58.526]                 NAMES <- toupper(changed)
[10:19:58.526]                 args <- list()
[10:19:58.526]                 for (kk in seq_along(NAMES)) {
[10:19:58.526]                   name <- changed[[kk]]
[10:19:58.526]                   NAME <- NAMES[[kk]]
[10:19:58.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.526]                     next
[10:19:58.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.526]                 }
[10:19:58.526]                 NAMES <- toupper(added)
[10:19:58.526]                 for (kk in seq_along(NAMES)) {
[10:19:58.526]                   name <- added[[kk]]
[10:19:58.526]                   NAME <- NAMES[[kk]]
[10:19:58.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.526]                     next
[10:19:58.526]                   args[[name]] <- ""
[10:19:58.526]                 }
[10:19:58.526]                 NAMES <- toupper(removed)
[10:19:58.526]                 for (kk in seq_along(NAMES)) {
[10:19:58.526]                   name <- removed[[kk]]
[10:19:58.526]                   NAME <- NAMES[[kk]]
[10:19:58.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.526]                     next
[10:19:58.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.526]                 }
[10:19:58.526]                 if (length(args) > 0) 
[10:19:58.526]                   base::do.call(base::Sys.setenv, args = args)
[10:19:58.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:58.526]             }
[10:19:58.526]             else {
[10:19:58.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:58.526]             }
[10:19:58.526]             {
[10:19:58.526]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:58.526]                   0L) {
[10:19:58.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:58.526]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:58.526]                   base::options(opts)
[10:19:58.526]                 }
[10:19:58.526]                 {
[10:19:58.526]                   {
[10:19:58.526]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:58.526]                     NULL
[10:19:58.526]                   }
[10:19:58.526]                   options(future.plan = NULL)
[10:19:58.526]                   if (is.na(NA_character_)) 
[10:19:58.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:58.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:58.526]                     .init = FALSE)
[10:19:58.526]                 }
[10:19:58.526]             }
[10:19:58.526]         }
[10:19:58.526]     })
[10:19:58.526]     if (TRUE) {
[10:19:58.526]         base::sink(type = "output", split = FALSE)
[10:19:58.526]         if (TRUE) {
[10:19:58.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:58.526]         }
[10:19:58.526]         else {
[10:19:58.526]             ...future.result["stdout"] <- base::list(NULL)
[10:19:58.526]         }
[10:19:58.526]         base::close(...future.stdout)
[10:19:58.526]         ...future.stdout <- NULL
[10:19:58.526]     }
[10:19:58.526]     ...future.result$conditions <- ...future.conditions
[10:19:58.526]     ...future.result$finished <- base::Sys.time()
[10:19:58.526]     ...future.result
[10:19:58.526] }
[10:19:58.529] Exporting 11 global objects (26.98 KiB) to cluster node #2 ...
[10:19:58.529] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #2 ...
[10:19:58.571] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #2 ... DONE
[10:19:58.571] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #2 ...
[10:19:58.611] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #2 ... DONE
[10:19:58.611] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:58.612] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:58.612] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:58.653] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:58.653] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:58.694] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:58.694] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:58.695] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:58.695] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:58.695] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:58.695] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:58.696] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:58.696] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ...
[10:19:58.696] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ... DONE
[10:19:58.696] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:58.697] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:58.697] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:58.697] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:58.697] Exporting 11 global objects (26.98 KiB) to cluster node #2 ... DONE
[10:19:58.698] MultisessionFuture started
[10:19:58.698] - Launch lazy future ... done
[10:19:58.698] run() for ‘MultisessionFuture’ ... done
[10:19:58.698] Created future:
[10:19:58.698] MultisessionFuture:
[10:19:58.698] Label: ‘future_vapply-2’
[10:19:58.698] Expression:
[10:19:58.698] {
[10:19:58.698]     do.call(function(...) {
[10:19:58.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.698]             on.exit(options(oopts), add = TRUE)
[10:19:58.698]         }
[10:19:58.698]         {
[10:19:58.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.698]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.698]             })
[10:19:58.698]         }
[10:19:58.698]     }, args = future.call.arguments)
[10:19:58.698] }
[10:19:58.698] Lazy evaluation: FALSE
[10:19:58.698] Asynchronous evaluation: TRUE
[10:19:58.698] Local evaluation: TRUE
[10:19:58.698] Environment: R_GlobalEnv
[10:19:58.698] Capture standard output: TRUE
[10:19:58.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:58.698] Globals: 11 objects totaling 27.14 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:58.698] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:19:58.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:58.698] Resolved: FALSE
[10:19:58.698] Value: <not collected>
[10:19:58.698] Conditions captured: <none>
[10:19:58.698] Early signaling: FALSE
[10:19:58.698] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:58.698] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.710] Chunk #2 of 2 ... DONE
[10:19:58.710] Launching 2 futures (chunks) ... DONE
[10:19:58.710] Resolving 2 futures (chunks) ...
[10:19:58.710] resolve() on list ...
[10:19:58.710]  recursive: 0
[10:19:58.710]  length: 2
[10:19:58.710] 
[10:19:58.711] receiveMessageFromWorker() for ClusterFuture ...
[10:19:58.711] - Validating connection of MultisessionFuture
[10:19:58.711] - received message: FutureResult
[10:19:58.711] - Received FutureResult
[10:19:58.711] - Erased future from FutureRegistry
[10:19:58.711] result() for ClusterFuture ...
[10:19:58.711] - result already collected: FutureResult
[10:19:58.711] result() for ClusterFuture ... done
[10:19:58.712] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:58.712] Future #1
[10:19:58.712] result() for ClusterFuture ...
[10:19:58.712] - result already collected: FutureResult
[10:19:58.712] result() for ClusterFuture ... done
[10:19:58.712] result() for ClusterFuture ...
[10:19:58.712] - result already collected: FutureResult
[10:19:58.712] result() for ClusterFuture ... done
[10:19:58.712] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:58.712] - nx: 2
[10:19:58.712] - relay: TRUE
[10:19:58.712] - stdout: TRUE
[10:19:58.713] - signal: TRUE
[10:19:58.713] - resignal: FALSE
[10:19:58.713] - force: TRUE
[10:19:58.713] - relayed: [n=2] FALSE, FALSE
[10:19:58.713] - queued futures: [n=2] FALSE, FALSE
[10:19:58.713]  - until=1
[10:19:58.713]  - relaying element #1
[10:19:58.713] result() for ClusterFuture ...
[10:19:58.713] - result already collected: FutureResult
[10:19:58.713] result() for ClusterFuture ... done
[10:19:58.713] result() for ClusterFuture ...
[10:19:58.713] - result already collected: FutureResult
[10:19:58.713] result() for ClusterFuture ... done
[10:19:58.714] result() for ClusterFuture ...
[10:19:58.714] - result already collected: FutureResult
[10:19:58.714] result() for ClusterFuture ... done
[10:19:58.714] result() for ClusterFuture ...
[10:19:58.714] - result already collected: FutureResult
[10:19:58.714] result() for ClusterFuture ... done
[10:19:58.714] - relayed: [n=2] TRUE, FALSE
[10:19:58.714] - queued futures: [n=2] TRUE, FALSE
[10:19:58.714] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:58.714]  length: 1 (resolved future 1)
[10:19:58.740] receiveMessageFromWorker() for ClusterFuture ...
[10:19:58.740] - Validating connection of MultisessionFuture
[10:19:58.741] - received message: FutureResult
[10:19:58.741] - Received FutureResult
[10:19:58.741] - Erased future from FutureRegistry
[10:19:58.741] result() for ClusterFuture ...
[10:19:58.741] - result already collected: FutureResult
[10:19:58.741] result() for ClusterFuture ... done
[10:19:58.741] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:58.741] Future #2
[10:19:58.741] result() for ClusterFuture ...
[10:19:58.741] - result already collected: FutureResult
[10:19:58.741] result() for ClusterFuture ... done
[10:19:58.742] result() for ClusterFuture ...
[10:19:58.742] - result already collected: FutureResult
[10:19:58.742] result() for ClusterFuture ... done
[10:19:58.742] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:58.742] - nx: 2
[10:19:58.742] - relay: TRUE
[10:19:58.742] - stdout: TRUE
[10:19:58.742] - signal: TRUE
[10:19:58.742] - resignal: FALSE
[10:19:58.742] - force: TRUE
[10:19:58.742] - relayed: [n=2] TRUE, FALSE
[10:19:58.742] - queued futures: [n=2] TRUE, FALSE
[10:19:58.742]  - until=2
[10:19:58.743]  - relaying element #2
[10:19:58.743] result() for ClusterFuture ...
[10:19:58.743] - result already collected: FutureResult
[10:19:58.743] result() for ClusterFuture ... done
[10:19:58.743] result() for ClusterFuture ...
[10:19:58.743] - result already collected: FutureResult
[10:19:58.743] result() for ClusterFuture ... done
[10:19:58.743] result() for ClusterFuture ...
[10:19:58.743] - result already collected: FutureResult
[10:19:58.743] result() for ClusterFuture ... done
[10:19:58.743] result() for ClusterFuture ...
[10:19:58.743] - result already collected: FutureResult
[10:19:58.743] result() for ClusterFuture ... done
[10:19:58.744] - relayed: [n=2] TRUE, TRUE
[10:19:58.744] - queued futures: [n=2] TRUE, TRUE
[10:19:58.744] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:58.744]  length: 0 (resolved future 2)
[10:19:58.744] Relaying remaining futures
[10:19:58.744] signalConditionsASAP(NULL, pos=0) ...
[10:19:58.744] - nx: 2
[10:19:58.744] - relay: TRUE
[10:19:58.744] - stdout: TRUE
[10:19:58.744] - signal: TRUE
[10:19:58.744] - resignal: FALSE
[10:19:58.744] - force: TRUE
[10:19:58.744] - relayed: [n=2] TRUE, TRUE
[10:19:58.745] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:58.745] - relayed: [n=2] TRUE, TRUE
[10:19:58.745] - queued futures: [n=2] TRUE, TRUE
[10:19:58.745] signalConditionsASAP(NULL, pos=0) ... done
[10:19:58.745] resolve() on list ... DONE
[10:19:58.745] result() for ClusterFuture ...
[10:19:58.745] - result already collected: FutureResult
[10:19:58.745] result() for ClusterFuture ... done
[10:19:58.745] result() for ClusterFuture ...
[10:19:58.745] - result already collected: FutureResult
[10:19:58.745] result() for ClusterFuture ... done
[10:19:58.746] result() for ClusterFuture ...
[10:19:58.746] - result already collected: FutureResult
[10:19:58.746] result() for ClusterFuture ... done
[10:19:58.746] result() for ClusterFuture ...
[10:19:58.746] - result already collected: FutureResult
[10:19:58.746] result() for ClusterFuture ... done
[10:19:58.746]  - Number of value chunks collected: 2
[10:19:58.746] Resolving 2 futures (chunks) ... DONE
[10:19:58.746] Reducing values from 2 chunks ...
[10:19:58.746]  - Number of values collected after concatenation: 7
[10:19:58.746]  - Number of values expected: 7
[10:19:58.746] Reducing values from 2 chunks ... DONE
[10:19:58.746] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:19:58.748] future_lapply() ...
[10:19:58.750] Number of chunks: 2
[10:19:58.750] getGlobalsAndPackagesXApply() ...
[10:19:58.750]  - future.globals: TRUE
[10:19:58.750] getGlobalsAndPackages() ...
[10:19:58.750] Searching for globals...
[10:19:58.752] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:19:58.752] Searching for globals ... DONE
[10:19:58.752] Resolving globals: FALSE
[10:19:58.752] The total size of the 1 globals is 680 bytes (680 bytes)
[10:19:58.753] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[10:19:58.753] - globals: [1] ‘FUN’
[10:19:58.753] 
[10:19:58.753] getGlobalsAndPackages() ... DONE
[10:19:58.753]  - globals found/used: [n=1] ‘FUN’
[10:19:58.753]  - needed namespaces: [n=0] 
[10:19:58.753] Finding globals ... DONE
[10:19:58.753]  - use_args: TRUE
[10:19:58.753]  - Getting '...' globals ...
[10:19:58.754] resolve() on list ...
[10:19:58.754]  recursive: 0
[10:19:58.754]  length: 1
[10:19:58.754]  elements: ‘...’
[10:19:58.754]  length: 0 (resolved future 1)
[10:19:58.754] resolve() on list ... DONE
[10:19:58.754]    - '...' content: [n=1] ‘y’
[10:19:58.754] List of 1
[10:19:58.754]  $ ...:List of 1
[10:19:58.754]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:58.754]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.754]  - attr(*, "where")=List of 1
[10:19:58.754]   ..$ ...:<environment: 0x55c6a17e5c48> 
[10:19:58.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.754]  - attr(*, "resolved")= logi TRUE
[10:19:58.754]  - attr(*, "total_size")= num NA
[10:19:58.757]  - Getting '...' globals ... DONE
[10:19:58.757] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:19:58.757] List of 2
[10:19:58.757]  $ ...future.FUN:function (x, y)  
[10:19:58.757]  $ ...          :List of 1
[10:19:58.757]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:58.757]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.757]  - attr(*, "where")=List of 2
[10:19:58.757]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:58.757]   ..$ ...          :<environment: 0x55c6a17e5c48> 
[10:19:58.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.757]  - attr(*, "resolved")= logi FALSE
[10:19:58.757]  - attr(*, "total_size")= num 7318
[10:19:58.760] Packages to be attached in all futures: [n=0] 
[10:19:58.760] getGlobalsAndPackagesXApply() ... DONE
[10:19:58.760] Number of futures (= number of chunks): 2
[10:19:58.760] Launching 2 futures (chunks) ...
[10:19:58.761] Chunk #1 of 2 ...
[10:19:58.761]  - Finding globals in 'X' for chunk #1 ...
[10:19:58.761] getGlobalsAndPackages() ...
[10:19:58.761] Searching for globals...
[10:19:58.761] 
[10:19:58.761] Searching for globals ... DONE
[10:19:58.761] - globals: [0] <none>
[10:19:58.761] getGlobalsAndPackages() ... DONE
[10:19:58.761]    + additional globals found: [n=0] 
[10:19:58.761]    + additional namespaces needed: [n=0] 
[10:19:58.762]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:58.762]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:58.762]  - seeds: <none>
[10:19:58.762]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.762] getGlobalsAndPackages() ...
[10:19:58.762] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.762] Resolving globals: FALSE
[10:19:58.762] Tweak future expression to call with '...' arguments ...
[10:19:58.762] {
[10:19:58.762]     do.call(function(...) {
[10:19:58.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.762]             on.exit(options(oopts), add = TRUE)
[10:19:58.762]         }
[10:19:58.762]         {
[10:19:58.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.762]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.762]             })
[10:19:58.762]         }
[10:19:58.762]     }, args = future.call.arguments)
[10:19:58.762] }
[10:19:58.762] Tweak future expression to call with '...' arguments ... DONE
[10:19:58.763] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.763] 
[10:19:58.763] getGlobalsAndPackages() ... DONE
[10:19:58.763] run() for ‘Future’ ...
[10:19:58.763] - state: ‘created’
[10:19:58.763] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:58.777] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:58.777]   - Field: ‘node’
[10:19:58.777]   - Field: ‘label’
[10:19:58.777]   - Field: ‘local’
[10:19:58.777]   - Field: ‘owner’
[10:19:58.778]   - Field: ‘envir’
[10:19:58.778]   - Field: ‘workers’
[10:19:58.778]   - Field: ‘packages’
[10:19:58.778]   - Field: ‘gc’
[10:19:58.778]   - Field: ‘conditions’
[10:19:58.778]   - Field: ‘persistent’
[10:19:58.778]   - Field: ‘expr’
[10:19:58.778]   - Field: ‘uuid’
[10:19:58.778]   - Field: ‘seed’
[10:19:58.778]   - Field: ‘version’
[10:19:58.778]   - Field: ‘result’
[10:19:58.778]   - Field: ‘asynchronous’
[10:19:58.779]   - Field: ‘calls’
[10:19:58.779]   - Field: ‘globals’
[10:19:58.779]   - Field: ‘stdout’
[10:19:58.779]   - Field: ‘earlySignal’
[10:19:58.779]   - Field: ‘lazy’
[10:19:58.779]   - Field: ‘state’
[10:19:58.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:58.779] - Launch lazy future ...
[10:19:58.779] Packages needed by the future expression (n = 0): <none>
[10:19:58.779] Packages needed by future strategies (n = 0): <none>
[10:19:58.780] {
[10:19:58.780]     {
[10:19:58.780]         {
[10:19:58.780]             ...future.startTime <- base::Sys.time()
[10:19:58.780]             {
[10:19:58.780]                 {
[10:19:58.780]                   {
[10:19:58.780]                     {
[10:19:58.780]                       base::local({
[10:19:58.780]                         has_future <- base::requireNamespace("future", 
[10:19:58.780]                           quietly = TRUE)
[10:19:58.780]                         if (has_future) {
[10:19:58.780]                           ns <- base::getNamespace("future")
[10:19:58.780]                           version <- ns[[".package"]][["version"]]
[10:19:58.780]                           if (is.null(version)) 
[10:19:58.780]                             version <- utils::packageVersion("future")
[10:19:58.780]                         }
[10:19:58.780]                         else {
[10:19:58.780]                           version <- NULL
[10:19:58.780]                         }
[10:19:58.780]                         if (!has_future || version < "1.8.0") {
[10:19:58.780]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:58.780]                             "", base::R.version$version.string), 
[10:19:58.780]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:58.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:58.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:58.780]                               "release", "version")], collapse = " "), 
[10:19:58.780]                             hostname = base::Sys.info()[["nodename"]])
[10:19:58.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:58.780]                             info)
[10:19:58.780]                           info <- base::paste(info, collapse = "; ")
[10:19:58.780]                           if (!has_future) {
[10:19:58.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:58.780]                               info)
[10:19:58.780]                           }
[10:19:58.780]                           else {
[10:19:58.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:58.780]                               info, version)
[10:19:58.780]                           }
[10:19:58.780]                           base::stop(msg)
[10:19:58.780]                         }
[10:19:58.780]                       })
[10:19:58.780]                     }
[10:19:58.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:58.780]                     base::options(mc.cores = 1L)
[10:19:58.780]                   }
[10:19:58.780]                   ...future.strategy.old <- future::plan("list")
[10:19:58.780]                   options(future.plan = NULL)
[10:19:58.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:58.780]                 }
[10:19:58.780]                 ...future.workdir <- getwd()
[10:19:58.780]             }
[10:19:58.780]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:58.780]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:58.780]         }
[10:19:58.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:58.780]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:58.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:58.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:58.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:58.780]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:58.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:58.780]             base::names(...future.oldOptions))
[10:19:58.780]     }
[10:19:58.780]     if (FALSE) {
[10:19:58.780]     }
[10:19:58.780]     else {
[10:19:58.780]         if (TRUE) {
[10:19:58.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:58.780]                 open = "w")
[10:19:58.780]         }
[10:19:58.780]         else {
[10:19:58.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:58.780]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:58.780]         }
[10:19:58.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:58.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:58.780]             base::sink(type = "output", split = FALSE)
[10:19:58.780]             base::close(...future.stdout)
[10:19:58.780]         }, add = TRUE)
[10:19:58.780]     }
[10:19:58.780]     ...future.frame <- base::sys.nframe()
[10:19:58.780]     ...future.conditions <- base::list()
[10:19:58.780]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:58.780]     if (FALSE) {
[10:19:58.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:58.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:58.780]     }
[10:19:58.780]     ...future.result <- base::tryCatch({
[10:19:58.780]         base::withCallingHandlers({
[10:19:58.780]             ...future.value <- base::withVisible(base::local({
[10:19:58.780]                 ...future.makeSendCondition <- base::local({
[10:19:58.780]                   sendCondition <- NULL
[10:19:58.780]                   function(frame = 1L) {
[10:19:58.780]                     if (is.function(sendCondition)) 
[10:19:58.780]                       return(sendCondition)
[10:19:58.780]                     ns <- getNamespace("parallel")
[10:19:58.780]                     if (exists("sendData", mode = "function", 
[10:19:58.780]                       envir = ns)) {
[10:19:58.780]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:58.780]                         envir = ns)
[10:19:58.780]                       envir <- sys.frame(frame)
[10:19:58.780]                       master <- NULL
[10:19:58.780]                       while (!identical(envir, .GlobalEnv) && 
[10:19:58.780]                         !identical(envir, emptyenv())) {
[10:19:58.780]                         if (exists("master", mode = "list", envir = envir, 
[10:19:58.780]                           inherits = FALSE)) {
[10:19:58.780]                           master <- get("master", mode = "list", 
[10:19:58.780]                             envir = envir, inherits = FALSE)
[10:19:58.780]                           if (inherits(master, c("SOCKnode", 
[10:19:58.780]                             "SOCK0node"))) {
[10:19:58.780]                             sendCondition <<- function(cond) {
[10:19:58.780]                               data <- list(type = "VALUE", value = cond, 
[10:19:58.780]                                 success = TRUE)
[10:19:58.780]                               parallel_sendData(master, data)
[10:19:58.780]                             }
[10:19:58.780]                             return(sendCondition)
[10:19:58.780]                           }
[10:19:58.780]                         }
[10:19:58.780]                         frame <- frame + 1L
[10:19:58.780]                         envir <- sys.frame(frame)
[10:19:58.780]                       }
[10:19:58.780]                     }
[10:19:58.780]                     sendCondition <<- function(cond) NULL
[10:19:58.780]                   }
[10:19:58.780]                 })
[10:19:58.780]                 withCallingHandlers({
[10:19:58.780]                   {
[10:19:58.780]                     do.call(function(...) {
[10:19:58.780]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.780]                       if (!identical(...future.globals.maxSize.org, 
[10:19:58.780]                         ...future.globals.maxSize)) {
[10:19:58.780]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.780]                         on.exit(options(oopts), add = TRUE)
[10:19:58.780]                       }
[10:19:58.780]                       {
[10:19:58.780]                         lapply(seq_along(...future.elements_ii), 
[10:19:58.780]                           FUN = function(jj) {
[10:19:58.780]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.780]                             ...future.FUN(...future.X_jj, ...)
[10:19:58.780]                           })
[10:19:58.780]                       }
[10:19:58.780]                     }, args = future.call.arguments)
[10:19:58.780]                   }
[10:19:58.780]                 }, immediateCondition = function(cond) {
[10:19:58.780]                   sendCondition <- ...future.makeSendCondition()
[10:19:58.780]                   sendCondition(cond)
[10:19:58.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.780]                   {
[10:19:58.780]                     inherits <- base::inherits
[10:19:58.780]                     invokeRestart <- base::invokeRestart
[10:19:58.780]                     is.null <- base::is.null
[10:19:58.780]                     muffled <- FALSE
[10:19:58.780]                     if (inherits(cond, "message")) {
[10:19:58.780]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:58.780]                       if (muffled) 
[10:19:58.780]                         invokeRestart("muffleMessage")
[10:19:58.780]                     }
[10:19:58.780]                     else if (inherits(cond, "warning")) {
[10:19:58.780]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:58.780]                       if (muffled) 
[10:19:58.780]                         invokeRestart("muffleWarning")
[10:19:58.780]                     }
[10:19:58.780]                     else if (inherits(cond, "condition")) {
[10:19:58.780]                       if (!is.null(pattern)) {
[10:19:58.780]                         computeRestarts <- base::computeRestarts
[10:19:58.780]                         grepl <- base::grepl
[10:19:58.780]                         restarts <- computeRestarts(cond)
[10:19:58.780]                         for (restart in restarts) {
[10:19:58.780]                           name <- restart$name
[10:19:58.780]                           if (is.null(name)) 
[10:19:58.780]                             next
[10:19:58.780]                           if (!grepl(pattern, name)) 
[10:19:58.780]                             next
[10:19:58.780]                           invokeRestart(restart)
[10:19:58.780]                           muffled <- TRUE
[10:19:58.780]                           break
[10:19:58.780]                         }
[10:19:58.780]                       }
[10:19:58.780]                     }
[10:19:58.780]                     invisible(muffled)
[10:19:58.780]                   }
[10:19:58.780]                   muffleCondition(cond)
[10:19:58.780]                 })
[10:19:58.780]             }))
[10:19:58.780]             future::FutureResult(value = ...future.value$value, 
[10:19:58.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.780]                   ...future.rng), globalenv = if (FALSE) 
[10:19:58.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:58.780]                     ...future.globalenv.names))
[10:19:58.780]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:58.780]         }, condition = base::local({
[10:19:58.780]             c <- base::c
[10:19:58.780]             inherits <- base::inherits
[10:19:58.780]             invokeRestart <- base::invokeRestart
[10:19:58.780]             length <- base::length
[10:19:58.780]             list <- base::list
[10:19:58.780]             seq.int <- base::seq.int
[10:19:58.780]             signalCondition <- base::signalCondition
[10:19:58.780]             sys.calls <- base::sys.calls
[10:19:58.780]             `[[` <- base::`[[`
[10:19:58.780]             `+` <- base::`+`
[10:19:58.780]             `<<-` <- base::`<<-`
[10:19:58.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:58.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:58.780]                   3L)]
[10:19:58.780]             }
[10:19:58.780]             function(cond) {
[10:19:58.780]                 is_error <- inherits(cond, "error")
[10:19:58.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:58.780]                   NULL)
[10:19:58.780]                 if (is_error) {
[10:19:58.780]                   sessionInformation <- function() {
[10:19:58.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:58.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:58.780]                       search = base::search(), system = base::Sys.info())
[10:19:58.780]                   }
[10:19:58.780]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:58.780]                     cond$call), session = sessionInformation(), 
[10:19:58.780]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:58.780]                   signalCondition(cond)
[10:19:58.780]                 }
[10:19:58.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:58.780]                 "immediateCondition"))) {
[10:19:58.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:58.780]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:58.780]                   if (TRUE && !signal) {
[10:19:58.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.780]                     {
[10:19:58.780]                       inherits <- base::inherits
[10:19:58.780]                       invokeRestart <- base::invokeRestart
[10:19:58.780]                       is.null <- base::is.null
[10:19:58.780]                       muffled <- FALSE
[10:19:58.780]                       if (inherits(cond, "message")) {
[10:19:58.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.780]                         if (muffled) 
[10:19:58.780]                           invokeRestart("muffleMessage")
[10:19:58.780]                       }
[10:19:58.780]                       else if (inherits(cond, "warning")) {
[10:19:58.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.780]                         if (muffled) 
[10:19:58.780]                           invokeRestart("muffleWarning")
[10:19:58.780]                       }
[10:19:58.780]                       else if (inherits(cond, "condition")) {
[10:19:58.780]                         if (!is.null(pattern)) {
[10:19:58.780]                           computeRestarts <- base::computeRestarts
[10:19:58.780]                           grepl <- base::grepl
[10:19:58.780]                           restarts <- computeRestarts(cond)
[10:19:58.780]                           for (restart in restarts) {
[10:19:58.780]                             name <- restart$name
[10:19:58.780]                             if (is.null(name)) 
[10:19:58.780]                               next
[10:19:58.780]                             if (!grepl(pattern, name)) 
[10:19:58.780]                               next
[10:19:58.780]                             invokeRestart(restart)
[10:19:58.780]                             muffled <- TRUE
[10:19:58.780]                             break
[10:19:58.780]                           }
[10:19:58.780]                         }
[10:19:58.780]                       }
[10:19:58.780]                       invisible(muffled)
[10:19:58.780]                     }
[10:19:58.780]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.780]                   }
[10:19:58.780]                 }
[10:19:58.780]                 else {
[10:19:58.780]                   if (TRUE) {
[10:19:58.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.780]                     {
[10:19:58.780]                       inherits <- base::inherits
[10:19:58.780]                       invokeRestart <- base::invokeRestart
[10:19:58.780]                       is.null <- base::is.null
[10:19:58.780]                       muffled <- FALSE
[10:19:58.780]                       if (inherits(cond, "message")) {
[10:19:58.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.780]                         if (muffled) 
[10:19:58.780]                           invokeRestart("muffleMessage")
[10:19:58.780]                       }
[10:19:58.780]                       else if (inherits(cond, "warning")) {
[10:19:58.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.780]                         if (muffled) 
[10:19:58.780]                           invokeRestart("muffleWarning")
[10:19:58.780]                       }
[10:19:58.780]                       else if (inherits(cond, "condition")) {
[10:19:58.780]                         if (!is.null(pattern)) {
[10:19:58.780]                           computeRestarts <- base::computeRestarts
[10:19:58.780]                           grepl <- base::grepl
[10:19:58.780]                           restarts <- computeRestarts(cond)
[10:19:58.780]                           for (restart in restarts) {
[10:19:58.780]                             name <- restart$name
[10:19:58.780]                             if (is.null(name)) 
[10:19:58.780]                               next
[10:19:58.780]                             if (!grepl(pattern, name)) 
[10:19:58.780]                               next
[10:19:58.780]                             invokeRestart(restart)
[10:19:58.780]                             muffled <- TRUE
[10:19:58.780]                             break
[10:19:58.780]                           }
[10:19:58.780]                         }
[10:19:58.780]                       }
[10:19:58.780]                       invisible(muffled)
[10:19:58.780]                     }
[10:19:58.780]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.780]                   }
[10:19:58.780]                 }
[10:19:58.780]             }
[10:19:58.780]         }))
[10:19:58.780]     }, error = function(ex) {
[10:19:58.780]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:58.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.780]                 ...future.rng), started = ...future.startTime, 
[10:19:58.780]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:58.780]             version = "1.8"), class = "FutureResult")
[10:19:58.780]     }, finally = {
[10:19:58.780]         if (!identical(...future.workdir, getwd())) 
[10:19:58.780]             setwd(...future.workdir)
[10:19:58.780]         {
[10:19:58.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:58.780]                 ...future.oldOptions$nwarnings <- NULL
[10:19:58.780]             }
[10:19:58.780]             base::options(...future.oldOptions)
[10:19:58.780]             if (.Platform$OS.type == "windows") {
[10:19:58.780]                 old_names <- names(...future.oldEnvVars)
[10:19:58.780]                 envs <- base::Sys.getenv()
[10:19:58.780]                 names <- names(envs)
[10:19:58.780]                 common <- intersect(names, old_names)
[10:19:58.780]                 added <- setdiff(names, old_names)
[10:19:58.780]                 removed <- setdiff(old_names, names)
[10:19:58.780]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:58.780]                   envs[common]]
[10:19:58.780]                 NAMES <- toupper(changed)
[10:19:58.780]                 args <- list()
[10:19:58.780]                 for (kk in seq_along(NAMES)) {
[10:19:58.780]                   name <- changed[[kk]]
[10:19:58.780]                   NAME <- NAMES[[kk]]
[10:19:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.780]                     next
[10:19:58.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.780]                 }
[10:19:58.780]                 NAMES <- toupper(added)
[10:19:58.780]                 for (kk in seq_along(NAMES)) {
[10:19:58.780]                   name <- added[[kk]]
[10:19:58.780]                   NAME <- NAMES[[kk]]
[10:19:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.780]                     next
[10:19:58.780]                   args[[name]] <- ""
[10:19:58.780]                 }
[10:19:58.780]                 NAMES <- toupper(removed)
[10:19:58.780]                 for (kk in seq_along(NAMES)) {
[10:19:58.780]                   name <- removed[[kk]]
[10:19:58.780]                   NAME <- NAMES[[kk]]
[10:19:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.780]                     next
[10:19:58.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.780]                 }
[10:19:58.780]                 if (length(args) > 0) 
[10:19:58.780]                   base::do.call(base::Sys.setenv, args = args)
[10:19:58.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:58.780]             }
[10:19:58.780]             else {
[10:19:58.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:58.780]             }
[10:19:58.780]             {
[10:19:58.780]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:58.780]                   0L) {
[10:19:58.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:58.780]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:58.780]                   base::options(opts)
[10:19:58.780]                 }
[10:19:58.780]                 {
[10:19:58.780]                   {
[10:19:58.780]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:58.780]                     NULL
[10:19:58.780]                   }
[10:19:58.780]                   options(future.plan = NULL)
[10:19:58.780]                   if (is.na(NA_character_)) 
[10:19:58.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:58.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:58.780]                     .init = FALSE)
[10:19:58.780]                 }
[10:19:58.780]             }
[10:19:58.780]         }
[10:19:58.780]     })
[10:19:58.780]     if (TRUE) {
[10:19:58.780]         base::sink(type = "output", split = FALSE)
[10:19:58.780]         if (TRUE) {
[10:19:58.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:58.780]         }
[10:19:58.780]         else {
[10:19:58.780]             ...future.result["stdout"] <- base::list(NULL)
[10:19:58.780]         }
[10:19:58.780]         base::close(...future.stdout)
[10:19:58.780]         ...future.stdout <- NULL
[10:19:58.780]     }
[10:19:58.780]     ...future.result$conditions <- ...future.conditions
[10:19:58.780]     ...future.result$finished <- base::Sys.time()
[10:19:58.780]     ...future.result
[10:19:58.780] }
[10:19:58.783] Exporting 5 global objects (1.43 KiB) to cluster node #1 ...
[10:19:58.783] Exporting ‘...future.FUN’ (680 bytes) to cluster node #1 ...
[10:19:58.783] Exporting ‘...future.FUN’ (680 bytes) to cluster node #1 ... DONE
[10:19:58.783] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ...
[10:19:58.784] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ... DONE
[10:19:58.784] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ...
[10:19:58.784] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ... DONE
[10:19:58.784] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:58.785] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:58.785] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:58.785] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:58.785] Exporting 5 global objects (1.43 KiB) to cluster node #1 ... DONE
[10:19:58.786] MultisessionFuture started
[10:19:58.786] - Launch lazy future ... done
[10:19:58.786] run() for ‘MultisessionFuture’ ... done
[10:19:58.786] Created future:
[10:19:58.786] MultisessionFuture:
[10:19:58.786] Label: ‘future_sapply-1’
[10:19:58.786] Expression:
[10:19:58.786] {
[10:19:58.786]     do.call(function(...) {
[10:19:58.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.786]             on.exit(options(oopts), add = TRUE)
[10:19:58.786]         }
[10:19:58.786]         {
[10:19:58.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.786]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.786]             })
[10:19:58.786]         }
[10:19:58.786]     }, args = future.call.arguments)
[10:19:58.786] }
[10:19:58.786] Lazy evaluation: FALSE
[10:19:58.786] Asynchronous evaluation: TRUE
[10:19:58.786] Local evaluation: TRUE
[10:19:58.786] Environment: R_GlobalEnv
[10:19:58.786] Capture standard output: TRUE
[10:19:58.786] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:58.786] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:58.786] Packages: <none>
[10:19:58.786] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:58.786] Resolved: FALSE
[10:19:58.786] Value: <not collected>
[10:19:58.786] Conditions captured: <none>
[10:19:58.786] Early signaling: FALSE
[10:19:58.786] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:58.786] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.797] Chunk #1 of 2 ... DONE
[10:19:58.797] Chunk #2 of 2 ...
[10:19:58.797]  - Finding globals in 'X' for chunk #2 ...
[10:19:58.798] getGlobalsAndPackages() ...
[10:19:58.798] Searching for globals...
[10:19:58.798] 
[10:19:58.798] Searching for globals ... DONE
[10:19:58.798] - globals: [0] <none>
[10:19:58.798] getGlobalsAndPackages() ... DONE
[10:19:58.798]    + additional globals found: [n=0] 
[10:19:58.798]    + additional namespaces needed: [n=0] 
[10:19:58.798]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:58.798]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:58.799]  - seeds: <none>
[10:19:58.799]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.799] getGlobalsAndPackages() ...
[10:19:58.799] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.799] Resolving globals: FALSE
[10:19:58.799] Tweak future expression to call with '...' arguments ...
[10:19:58.799] {
[10:19:58.799]     do.call(function(...) {
[10:19:58.799]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.799]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.799]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.799]             on.exit(options(oopts), add = TRUE)
[10:19:58.799]         }
[10:19:58.799]         {
[10:19:58.799]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.799]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.799]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.799]             })
[10:19:58.799]         }
[10:19:58.799]     }, args = future.call.arguments)
[10:19:58.799] }
[10:19:58.799] Tweak future expression to call with '...' arguments ... DONE
[10:19:58.800] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.800] 
[10:19:58.800] getGlobalsAndPackages() ... DONE
[10:19:58.800] run() for ‘Future’ ...
[10:19:58.800] - state: ‘created’
[10:19:58.800] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:58.815] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.815] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:58.815]   - Field: ‘node’
[10:19:58.815]   - Field: ‘label’
[10:19:58.815]   - Field: ‘local’
[10:19:58.815]   - Field: ‘owner’
[10:19:58.815]   - Field: ‘envir’
[10:19:58.815]   - Field: ‘workers’
[10:19:58.815]   - Field: ‘packages’
[10:19:58.815]   - Field: ‘gc’
[10:19:58.816]   - Field: ‘conditions’
[10:19:58.816]   - Field: ‘persistent’
[10:19:58.816]   - Field: ‘expr’
[10:19:58.816]   - Field: ‘uuid’
[10:19:58.816]   - Field: ‘seed’
[10:19:58.816]   - Field: ‘version’
[10:19:58.816]   - Field: ‘result’
[10:19:58.816]   - Field: ‘asynchronous’
[10:19:58.816]   - Field: ‘calls’
[10:19:58.816]   - Field: ‘globals’
[10:19:58.816]   - Field: ‘stdout’
[10:19:58.816]   - Field: ‘earlySignal’
[10:19:58.817]   - Field: ‘lazy’
[10:19:58.817]   - Field: ‘state’
[10:19:58.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:58.817] - Launch lazy future ...
[10:19:58.817] Packages needed by the future expression (n = 0): <none>
[10:19:58.817] Packages needed by future strategies (n = 0): <none>
[10:19:58.818] {
[10:19:58.818]     {
[10:19:58.818]         {
[10:19:58.818]             ...future.startTime <- base::Sys.time()
[10:19:58.818]             {
[10:19:58.818]                 {
[10:19:58.818]                   {
[10:19:58.818]                     {
[10:19:58.818]                       base::local({
[10:19:58.818]                         has_future <- base::requireNamespace("future", 
[10:19:58.818]                           quietly = TRUE)
[10:19:58.818]                         if (has_future) {
[10:19:58.818]                           ns <- base::getNamespace("future")
[10:19:58.818]                           version <- ns[[".package"]][["version"]]
[10:19:58.818]                           if (is.null(version)) 
[10:19:58.818]                             version <- utils::packageVersion("future")
[10:19:58.818]                         }
[10:19:58.818]                         else {
[10:19:58.818]                           version <- NULL
[10:19:58.818]                         }
[10:19:58.818]                         if (!has_future || version < "1.8.0") {
[10:19:58.818]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:58.818]                             "", base::R.version$version.string), 
[10:19:58.818]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:58.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:58.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:58.818]                               "release", "version")], collapse = " "), 
[10:19:58.818]                             hostname = base::Sys.info()[["nodename"]])
[10:19:58.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:58.818]                             info)
[10:19:58.818]                           info <- base::paste(info, collapse = "; ")
[10:19:58.818]                           if (!has_future) {
[10:19:58.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:58.818]                               info)
[10:19:58.818]                           }
[10:19:58.818]                           else {
[10:19:58.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:58.818]                               info, version)
[10:19:58.818]                           }
[10:19:58.818]                           base::stop(msg)
[10:19:58.818]                         }
[10:19:58.818]                       })
[10:19:58.818]                     }
[10:19:58.818]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:58.818]                     base::options(mc.cores = 1L)
[10:19:58.818]                   }
[10:19:58.818]                   ...future.strategy.old <- future::plan("list")
[10:19:58.818]                   options(future.plan = NULL)
[10:19:58.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:58.818]                 }
[10:19:58.818]                 ...future.workdir <- getwd()
[10:19:58.818]             }
[10:19:58.818]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:58.818]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:58.818]         }
[10:19:58.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:58.818]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:58.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:58.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:58.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:58.818]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:58.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:58.818]             base::names(...future.oldOptions))
[10:19:58.818]     }
[10:19:58.818]     if (FALSE) {
[10:19:58.818]     }
[10:19:58.818]     else {
[10:19:58.818]         if (TRUE) {
[10:19:58.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:58.818]                 open = "w")
[10:19:58.818]         }
[10:19:58.818]         else {
[10:19:58.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:58.818]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:58.818]         }
[10:19:58.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:58.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:58.818]             base::sink(type = "output", split = FALSE)
[10:19:58.818]             base::close(...future.stdout)
[10:19:58.818]         }, add = TRUE)
[10:19:58.818]     }
[10:19:58.818]     ...future.frame <- base::sys.nframe()
[10:19:58.818]     ...future.conditions <- base::list()
[10:19:58.818]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:58.818]     if (FALSE) {
[10:19:58.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:58.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:58.818]     }
[10:19:58.818]     ...future.result <- base::tryCatch({
[10:19:58.818]         base::withCallingHandlers({
[10:19:58.818]             ...future.value <- base::withVisible(base::local({
[10:19:58.818]                 ...future.makeSendCondition <- base::local({
[10:19:58.818]                   sendCondition <- NULL
[10:19:58.818]                   function(frame = 1L) {
[10:19:58.818]                     if (is.function(sendCondition)) 
[10:19:58.818]                       return(sendCondition)
[10:19:58.818]                     ns <- getNamespace("parallel")
[10:19:58.818]                     if (exists("sendData", mode = "function", 
[10:19:58.818]                       envir = ns)) {
[10:19:58.818]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:58.818]                         envir = ns)
[10:19:58.818]                       envir <- sys.frame(frame)
[10:19:58.818]                       master <- NULL
[10:19:58.818]                       while (!identical(envir, .GlobalEnv) && 
[10:19:58.818]                         !identical(envir, emptyenv())) {
[10:19:58.818]                         if (exists("master", mode = "list", envir = envir, 
[10:19:58.818]                           inherits = FALSE)) {
[10:19:58.818]                           master <- get("master", mode = "list", 
[10:19:58.818]                             envir = envir, inherits = FALSE)
[10:19:58.818]                           if (inherits(master, c("SOCKnode", 
[10:19:58.818]                             "SOCK0node"))) {
[10:19:58.818]                             sendCondition <<- function(cond) {
[10:19:58.818]                               data <- list(type = "VALUE", value = cond, 
[10:19:58.818]                                 success = TRUE)
[10:19:58.818]                               parallel_sendData(master, data)
[10:19:58.818]                             }
[10:19:58.818]                             return(sendCondition)
[10:19:58.818]                           }
[10:19:58.818]                         }
[10:19:58.818]                         frame <- frame + 1L
[10:19:58.818]                         envir <- sys.frame(frame)
[10:19:58.818]                       }
[10:19:58.818]                     }
[10:19:58.818]                     sendCondition <<- function(cond) NULL
[10:19:58.818]                   }
[10:19:58.818]                 })
[10:19:58.818]                 withCallingHandlers({
[10:19:58.818]                   {
[10:19:58.818]                     do.call(function(...) {
[10:19:58.818]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.818]                       if (!identical(...future.globals.maxSize.org, 
[10:19:58.818]                         ...future.globals.maxSize)) {
[10:19:58.818]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.818]                         on.exit(options(oopts), add = TRUE)
[10:19:58.818]                       }
[10:19:58.818]                       {
[10:19:58.818]                         lapply(seq_along(...future.elements_ii), 
[10:19:58.818]                           FUN = function(jj) {
[10:19:58.818]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.818]                             ...future.FUN(...future.X_jj, ...)
[10:19:58.818]                           })
[10:19:58.818]                       }
[10:19:58.818]                     }, args = future.call.arguments)
[10:19:58.818]                   }
[10:19:58.818]                 }, immediateCondition = function(cond) {
[10:19:58.818]                   sendCondition <- ...future.makeSendCondition()
[10:19:58.818]                   sendCondition(cond)
[10:19:58.818]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.818]                   {
[10:19:58.818]                     inherits <- base::inherits
[10:19:58.818]                     invokeRestart <- base::invokeRestart
[10:19:58.818]                     is.null <- base::is.null
[10:19:58.818]                     muffled <- FALSE
[10:19:58.818]                     if (inherits(cond, "message")) {
[10:19:58.818]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:58.818]                       if (muffled) 
[10:19:58.818]                         invokeRestart("muffleMessage")
[10:19:58.818]                     }
[10:19:58.818]                     else if (inherits(cond, "warning")) {
[10:19:58.818]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:58.818]                       if (muffled) 
[10:19:58.818]                         invokeRestart("muffleWarning")
[10:19:58.818]                     }
[10:19:58.818]                     else if (inherits(cond, "condition")) {
[10:19:58.818]                       if (!is.null(pattern)) {
[10:19:58.818]                         computeRestarts <- base::computeRestarts
[10:19:58.818]                         grepl <- base::grepl
[10:19:58.818]                         restarts <- computeRestarts(cond)
[10:19:58.818]                         for (restart in restarts) {
[10:19:58.818]                           name <- restart$name
[10:19:58.818]                           if (is.null(name)) 
[10:19:58.818]                             next
[10:19:58.818]                           if (!grepl(pattern, name)) 
[10:19:58.818]                             next
[10:19:58.818]                           invokeRestart(restart)
[10:19:58.818]                           muffled <- TRUE
[10:19:58.818]                           break
[10:19:58.818]                         }
[10:19:58.818]                       }
[10:19:58.818]                     }
[10:19:58.818]                     invisible(muffled)
[10:19:58.818]                   }
[10:19:58.818]                   muffleCondition(cond)
[10:19:58.818]                 })
[10:19:58.818]             }))
[10:19:58.818]             future::FutureResult(value = ...future.value$value, 
[10:19:58.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.818]                   ...future.rng), globalenv = if (FALSE) 
[10:19:58.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:58.818]                     ...future.globalenv.names))
[10:19:58.818]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:58.818]         }, condition = base::local({
[10:19:58.818]             c <- base::c
[10:19:58.818]             inherits <- base::inherits
[10:19:58.818]             invokeRestart <- base::invokeRestart
[10:19:58.818]             length <- base::length
[10:19:58.818]             list <- base::list
[10:19:58.818]             seq.int <- base::seq.int
[10:19:58.818]             signalCondition <- base::signalCondition
[10:19:58.818]             sys.calls <- base::sys.calls
[10:19:58.818]             `[[` <- base::`[[`
[10:19:58.818]             `+` <- base::`+`
[10:19:58.818]             `<<-` <- base::`<<-`
[10:19:58.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:58.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:58.818]                   3L)]
[10:19:58.818]             }
[10:19:58.818]             function(cond) {
[10:19:58.818]                 is_error <- inherits(cond, "error")
[10:19:58.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:58.818]                   NULL)
[10:19:58.818]                 if (is_error) {
[10:19:58.818]                   sessionInformation <- function() {
[10:19:58.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:58.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:58.818]                       search = base::search(), system = base::Sys.info())
[10:19:58.818]                   }
[10:19:58.818]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:58.818]                     cond$call), session = sessionInformation(), 
[10:19:58.818]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:58.818]                   signalCondition(cond)
[10:19:58.818]                 }
[10:19:58.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:58.818]                 "immediateCondition"))) {
[10:19:58.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:58.818]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:58.818]                   if (TRUE && !signal) {
[10:19:58.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.818]                     {
[10:19:58.818]                       inherits <- base::inherits
[10:19:58.818]                       invokeRestart <- base::invokeRestart
[10:19:58.818]                       is.null <- base::is.null
[10:19:58.818]                       muffled <- FALSE
[10:19:58.818]                       if (inherits(cond, "message")) {
[10:19:58.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.818]                         if (muffled) 
[10:19:58.818]                           invokeRestart("muffleMessage")
[10:19:58.818]                       }
[10:19:58.818]                       else if (inherits(cond, "warning")) {
[10:19:58.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.818]                         if (muffled) 
[10:19:58.818]                           invokeRestart("muffleWarning")
[10:19:58.818]                       }
[10:19:58.818]                       else if (inherits(cond, "condition")) {
[10:19:58.818]                         if (!is.null(pattern)) {
[10:19:58.818]                           computeRestarts <- base::computeRestarts
[10:19:58.818]                           grepl <- base::grepl
[10:19:58.818]                           restarts <- computeRestarts(cond)
[10:19:58.818]                           for (restart in restarts) {
[10:19:58.818]                             name <- restart$name
[10:19:58.818]                             if (is.null(name)) 
[10:19:58.818]                               next
[10:19:58.818]                             if (!grepl(pattern, name)) 
[10:19:58.818]                               next
[10:19:58.818]                             invokeRestart(restart)
[10:19:58.818]                             muffled <- TRUE
[10:19:58.818]                             break
[10:19:58.818]                           }
[10:19:58.818]                         }
[10:19:58.818]                       }
[10:19:58.818]                       invisible(muffled)
[10:19:58.818]                     }
[10:19:58.818]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.818]                   }
[10:19:58.818]                 }
[10:19:58.818]                 else {
[10:19:58.818]                   if (TRUE) {
[10:19:58.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.818]                     {
[10:19:58.818]                       inherits <- base::inherits
[10:19:58.818]                       invokeRestart <- base::invokeRestart
[10:19:58.818]                       is.null <- base::is.null
[10:19:58.818]                       muffled <- FALSE
[10:19:58.818]                       if (inherits(cond, "message")) {
[10:19:58.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.818]                         if (muffled) 
[10:19:58.818]                           invokeRestart("muffleMessage")
[10:19:58.818]                       }
[10:19:58.818]                       else if (inherits(cond, "warning")) {
[10:19:58.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.818]                         if (muffled) 
[10:19:58.818]                           invokeRestart("muffleWarning")
[10:19:58.818]                       }
[10:19:58.818]                       else if (inherits(cond, "condition")) {
[10:19:58.818]                         if (!is.null(pattern)) {
[10:19:58.818]                           computeRestarts <- base::computeRestarts
[10:19:58.818]                           grepl <- base::grepl
[10:19:58.818]                           restarts <- computeRestarts(cond)
[10:19:58.818]                           for (restart in restarts) {
[10:19:58.818]                             name <- restart$name
[10:19:58.818]                             if (is.null(name)) 
[10:19:58.818]                               next
[10:19:58.818]                             if (!grepl(pattern, name)) 
[10:19:58.818]                               next
[10:19:58.818]                             invokeRestart(restart)
[10:19:58.818]                             muffled <- TRUE
[10:19:58.818]                             break
[10:19:58.818]                           }
[10:19:58.818]                         }
[10:19:58.818]                       }
[10:19:58.818]                       invisible(muffled)
[10:19:58.818]                     }
[10:19:58.818]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.818]                   }
[10:19:58.818]                 }
[10:19:58.818]             }
[10:19:58.818]         }))
[10:19:58.818]     }, error = function(ex) {
[10:19:58.818]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:58.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.818]                 ...future.rng), started = ...future.startTime, 
[10:19:58.818]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:58.818]             version = "1.8"), class = "FutureResult")
[10:19:58.818]     }, finally = {
[10:19:58.818]         if (!identical(...future.workdir, getwd())) 
[10:19:58.818]             setwd(...future.workdir)
[10:19:58.818]         {
[10:19:58.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:58.818]                 ...future.oldOptions$nwarnings <- NULL
[10:19:58.818]             }
[10:19:58.818]             base::options(...future.oldOptions)
[10:19:58.818]             if (.Platform$OS.type == "windows") {
[10:19:58.818]                 old_names <- names(...future.oldEnvVars)
[10:19:58.818]                 envs <- base::Sys.getenv()
[10:19:58.818]                 names <- names(envs)
[10:19:58.818]                 common <- intersect(names, old_names)
[10:19:58.818]                 added <- setdiff(names, old_names)
[10:19:58.818]                 removed <- setdiff(old_names, names)
[10:19:58.818]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:58.818]                   envs[common]]
[10:19:58.818]                 NAMES <- toupper(changed)
[10:19:58.818]                 args <- list()
[10:19:58.818]                 for (kk in seq_along(NAMES)) {
[10:19:58.818]                   name <- changed[[kk]]
[10:19:58.818]                   NAME <- NAMES[[kk]]
[10:19:58.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.818]                     next
[10:19:58.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.818]                 }
[10:19:58.818]                 NAMES <- toupper(added)
[10:19:58.818]                 for (kk in seq_along(NAMES)) {
[10:19:58.818]                   name <- added[[kk]]
[10:19:58.818]                   NAME <- NAMES[[kk]]
[10:19:58.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.818]                     next
[10:19:58.818]                   args[[name]] <- ""
[10:19:58.818]                 }
[10:19:58.818]                 NAMES <- toupper(removed)
[10:19:58.818]                 for (kk in seq_along(NAMES)) {
[10:19:58.818]                   name <- removed[[kk]]
[10:19:58.818]                   NAME <- NAMES[[kk]]
[10:19:58.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.818]                     next
[10:19:58.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.818]                 }
[10:19:58.818]                 if (length(args) > 0) 
[10:19:58.818]                   base::do.call(base::Sys.setenv, args = args)
[10:19:58.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:58.818]             }
[10:19:58.818]             else {
[10:19:58.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:58.818]             }
[10:19:58.818]             {
[10:19:58.818]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:58.818]                   0L) {
[10:19:58.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:58.818]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:58.818]                   base::options(opts)
[10:19:58.818]                 }
[10:19:58.818]                 {
[10:19:58.818]                   {
[10:19:58.818]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:58.818]                     NULL
[10:19:58.818]                   }
[10:19:58.818]                   options(future.plan = NULL)
[10:19:58.818]                   if (is.na(NA_character_)) 
[10:19:58.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:58.818]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:58.818]                     .init = FALSE)
[10:19:58.818]                 }
[10:19:58.818]             }
[10:19:58.818]         }
[10:19:58.818]     })
[10:19:58.818]     if (TRUE) {
[10:19:58.818]         base::sink(type = "output", split = FALSE)
[10:19:58.818]         if (TRUE) {
[10:19:58.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:58.818]         }
[10:19:58.818]         else {
[10:19:58.818]             ...future.result["stdout"] <- base::list(NULL)
[10:19:58.818]         }
[10:19:58.818]         base::close(...future.stdout)
[10:19:58.818]         ...future.stdout <- NULL
[10:19:58.818]     }
[10:19:58.818]     ...future.result$conditions <- ...future.conditions
[10:19:58.818]     ...future.result$finished <- base::Sys.time()
[10:19:58.818]     ...future.result
[10:19:58.818] }
[10:19:58.820] Exporting 5 global objects (1.43 KiB) to cluster node #2 ...
[10:19:58.820] Exporting ‘...future.FUN’ (680 bytes) to cluster node #2 ...
[10:19:58.821] Exporting ‘...future.FUN’ (680 bytes) to cluster node #2 ... DONE
[10:19:58.821] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ...
[10:19:58.821] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ... DONE
[10:19:58.821] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[10:19:58.822] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[10:19:58.822] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:58.822] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:58.823] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:58.823] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:58.823] Exporting 5 global objects (1.43 KiB) to cluster node #2 ... DONE
[10:19:58.823] MultisessionFuture started
[10:19:58.824] - Launch lazy future ... done
[10:19:58.824] run() for ‘MultisessionFuture’ ... done
[10:19:58.824] Created future:
[10:19:58.824] MultisessionFuture:
[10:19:58.824] Label: ‘future_sapply-2’
[10:19:58.824] Expression:
[10:19:58.824] {
[10:19:58.824]     do.call(function(...) {
[10:19:58.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.824]             on.exit(options(oopts), add = TRUE)
[10:19:58.824]         }
[10:19:58.824]         {
[10:19:58.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.824]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.824]             })
[10:19:58.824]         }
[10:19:58.824]     }, args = future.call.arguments)
[10:19:58.824] }
[10:19:58.824] Lazy evaluation: FALSE
[10:19:58.824] Asynchronous evaluation: TRUE
[10:19:58.824] Local evaluation: TRUE
[10:19:58.824] Environment: R_GlobalEnv
[10:19:58.824] Capture standard output: TRUE
[10:19:58.824] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:58.824] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:58.824] Packages: <none>
[10:19:58.824] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:58.824] Resolved: FALSE
[10:19:58.824] Value: <not collected>
[10:19:58.824] Conditions captured: <none>
[10:19:58.824] Early signaling: FALSE
[10:19:58.824] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:58.824] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.835] Chunk #2 of 2 ... DONE
[10:19:58.835] Launching 2 futures (chunks) ... DONE
[10:19:58.835] Resolving 2 futures (chunks) ...
[10:19:58.836] resolve() on list ...
[10:19:58.836]  recursive: 0
[10:19:58.836]  length: 2
[10:19:58.836] 
[10:19:58.836] receiveMessageFromWorker() for ClusterFuture ...
[10:19:58.836] - Validating connection of MultisessionFuture
[10:19:58.837] - received message: FutureResult
[10:19:58.837] - Received FutureResult
[10:19:58.837] - Erased future from FutureRegistry
[10:19:58.837] result() for ClusterFuture ...
[10:19:58.837] - result already collected: FutureResult
[10:19:58.837] result() for ClusterFuture ... done
[10:19:58.837] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:58.837] Future #1
[10:19:58.837] result() for ClusterFuture ...
[10:19:58.837] - result already collected: FutureResult
[10:19:58.837] result() for ClusterFuture ... done
[10:19:58.838] result() for ClusterFuture ...
[10:19:58.838] - result already collected: FutureResult
[10:19:58.838] result() for ClusterFuture ... done
[10:19:58.838] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:58.838] - nx: 2
[10:19:58.838] - relay: TRUE
[10:19:58.838] - stdout: TRUE
[10:19:58.838] - signal: TRUE
[10:19:58.838] - resignal: FALSE
[10:19:58.838] - force: TRUE
[10:19:58.838] - relayed: [n=2] FALSE, FALSE
[10:19:58.839] - queued futures: [n=2] FALSE, FALSE
[10:19:58.839]  - until=1
[10:19:58.839]  - relaying element #1
[10:19:58.841] result() for ClusterFuture ...
[10:19:58.841] - result already collected: FutureResult
[10:19:58.841] result() for ClusterFuture ... done
[10:19:58.841] result() for ClusterFuture ...
[10:19:58.841] - result already collected: FutureResult
[10:19:58.841] result() for ClusterFuture ... done
[10:19:58.841] result() for ClusterFuture ...
[10:19:58.842] - result already collected: FutureResult
[10:19:58.842] result() for ClusterFuture ... done
[10:19:58.842] result() for ClusterFuture ...
[10:19:58.842] - result already collected: FutureResult
[10:19:58.842] result() for ClusterFuture ... done
[10:19:58.842] - relayed: [n=2] TRUE, FALSE
[10:19:58.842] - queued futures: [n=2] TRUE, FALSE
[10:19:58.842] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:58.842]  length: 1 (resolved future 1)
[10:19:58.866] receiveMessageFromWorker() for ClusterFuture ...
[10:19:58.866] - Validating connection of MultisessionFuture
[10:19:58.867] - received message: FutureResult
[10:19:58.867] - Received FutureResult
[10:19:58.867] - Erased future from FutureRegistry
[10:19:58.867] result() for ClusterFuture ...
[10:19:58.867] - result already collected: FutureResult
[10:19:58.867] result() for ClusterFuture ... done
[10:19:58.867] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:58.867] Future #2
[10:19:58.867] result() for ClusterFuture ...
[10:19:58.867] - result already collected: FutureResult
[10:19:58.868] result() for ClusterFuture ... done
[10:19:58.868] result() for ClusterFuture ...
[10:19:58.868] - result already collected: FutureResult
[10:19:58.868] result() for ClusterFuture ... done
[10:19:58.868] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:58.868] - nx: 2
[10:19:58.868] - relay: TRUE
[10:19:58.868] - stdout: TRUE
[10:19:58.868] - signal: TRUE
[10:19:58.868] - resignal: FALSE
[10:19:58.868] - force: TRUE
[10:19:58.868] - relayed: [n=2] TRUE, FALSE
[10:19:58.868] - queued futures: [n=2] TRUE, FALSE
[10:19:58.869]  - until=2
[10:19:58.869]  - relaying element #2
[10:19:58.869] result() for ClusterFuture ...
[10:19:58.869] - result already collected: FutureResult
[10:19:58.869] result() for ClusterFuture ... done
[10:19:58.869] result() for ClusterFuture ...
[10:19:58.869] - result already collected: FutureResult
[10:19:58.869] result() for ClusterFuture ... done
[10:19:58.869] result() for ClusterFuture ...
[10:19:58.869] - result already collected: FutureResult
[10:19:58.869] result() for ClusterFuture ... done
[10:19:58.869] result() for ClusterFuture ...
[10:19:58.870] - result already collected: FutureResult
[10:19:58.870] result() for ClusterFuture ... done
[10:19:58.870] - relayed: [n=2] TRUE, TRUE
[10:19:58.870] - queued futures: [n=2] TRUE, TRUE
[10:19:58.870] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:58.870]  length: 0 (resolved future 2)
[10:19:58.870] Relaying remaining futures
[10:19:58.870] signalConditionsASAP(NULL, pos=0) ...
[10:19:58.870] - nx: 2
[10:19:58.870] - relay: TRUE
[10:19:58.870] - stdout: TRUE
[10:19:58.870] - signal: TRUE
[10:19:58.870] - resignal: FALSE
[10:19:58.871] - force: TRUE
[10:19:58.871] - relayed: [n=2] TRUE, TRUE
[10:19:58.871] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:58.871] - relayed: [n=2] TRUE, TRUE
[10:19:58.871] - queued futures: [n=2] TRUE, TRUE
[10:19:58.871] signalConditionsASAP(NULL, pos=0) ... done
[10:19:58.871] resolve() on list ... DONE
[10:19:58.871] result() for ClusterFuture ...
[10:19:58.871] - result already collected: FutureResult
[10:19:58.871] result() for ClusterFuture ... done
[10:19:58.871] result() for ClusterFuture ...
[10:19:58.872] - result already collected: FutureResult
[10:19:58.872] result() for ClusterFuture ... done
[10:19:58.872] result() for ClusterFuture ...
[10:19:58.872] - result already collected: FutureResult
[10:19:58.872] result() for ClusterFuture ... done
[10:19:58.872] result() for ClusterFuture ...
[10:19:58.872] - result already collected: FutureResult
[10:19:58.872] result() for ClusterFuture ... done
[10:19:58.872]  - Number of value chunks collected: 2
[10:19:58.872] Resolving 2 futures (chunks) ... DONE
[10:19:58.872] Reducing values from 2 chunks ...
[10:19:58.872]  - Number of values collected after concatenation: 4
[10:19:58.872]  - Number of values expected: 4
[10:19:58.873] Reducing values from 2 chunks ... DONE
[10:19:58.873] future_lapply() ... DONE
[10:19:58.873] future_lapply() ...
[10:19:58.876] Number of chunks: 2
[10:19:58.876] getGlobalsAndPackagesXApply() ...
[10:19:58.876]  - future.globals: TRUE
[10:19:58.877] getGlobalsAndPackages() ...
[10:19:58.877] Searching for globals...
[10:19:58.880] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:19:58.880] Searching for globals ... DONE
[10:19:58.880] Resolving globals: FALSE
[10:19:58.881] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[10:19:58.881] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:58.882] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:58.882] - packages: [1] ‘future.apply’
[10:19:58.882] getGlobalsAndPackages() ... DONE
[10:19:58.882]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:58.882]  - needed namespaces: [n=1] ‘future.apply’
[10:19:58.882] Finding globals ... DONE
[10:19:58.882]  - use_args: TRUE
[10:19:58.882]  - Getting '...' globals ...
[10:19:58.883] resolve() on list ...
[10:19:58.883]  recursive: 0
[10:19:58.883]  length: 1
[10:19:58.883]  elements: ‘...’
[10:19:58.883]  length: 0 (resolved future 1)
[10:19:58.883] resolve() on list ... DONE
[10:19:58.883]    - '...' content: [n=1] ‘y’
[10:19:58.883] List of 1
[10:19:58.883]  $ ...:List of 1
[10:19:58.883]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:58.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.883]  - attr(*, "where")=List of 1
[10:19:58.883]   ..$ ...:<environment: 0x55c6a28c9148> 
[10:19:58.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.883]  - attr(*, "resolved")= logi TRUE
[10:19:58.883]  - attr(*, "total_size")= num NA
[10:19:58.886]  - Getting '...' globals ... DONE
[10:19:58.886] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:58.886] List of 8
[10:19:58.886]  $ ...future.FUN:function (x, ...)  
[10:19:58.886]  $ x_FUN        :function (x, y)  
[10:19:58.886]  $ times        : int 15
[10:19:58.886]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:58.886]  $ stop_if_not  :function (...)  
[10:19:58.886]  $ dim          : int [1:2] 3 5
[10:19:58.886]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:19:58.886]  $ ...          :List of 1
[10:19:58.886]   ..$ y: num [1:5] 2 4 6 8 10
[10:19:58.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:58.886]  - attr(*, "where")=List of 8
[10:19:58.886]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:58.886]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:58.886]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:58.886]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:58.886]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:58.886]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:58.886]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:58.886]   ..$ ...          :<environment: 0x55c6a28c9148> 
[10:19:58.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:58.886]  - attr(*, "resolved")= logi FALSE
[10:19:58.886]  - attr(*, "total_size")= num 26659
[10:19:58.892] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:58.892] getGlobalsAndPackagesXApply() ... DONE
[10:19:58.892] Number of futures (= number of chunks): 2
[10:19:58.892] Launching 2 futures (chunks) ...
[10:19:58.892] Chunk #1 of 2 ...
[10:19:58.892]  - Finding globals in 'X' for chunk #1 ...
[10:19:58.892] getGlobalsAndPackages() ...
[10:19:58.892] Searching for globals...
[10:19:58.893] 
[10:19:58.893] Searching for globals ... DONE
[10:19:58.893] - globals: [0] <none>
[10:19:58.893] getGlobalsAndPackages() ... DONE
[10:19:58.893]    + additional globals found: [n=0] 
[10:19:58.893]    + additional namespaces needed: [n=0] 
[10:19:58.893]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:58.893]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:58.893]  - seeds: <none>
[10:19:58.893]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.893] getGlobalsAndPackages() ...
[10:19:58.894] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.894] Resolving globals: FALSE
[10:19:58.894] Tweak future expression to call with '...' arguments ...
[10:19:58.894] {
[10:19:58.894]     do.call(function(...) {
[10:19:58.894]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.894]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:58.894]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.894]             on.exit(options(oopts), add = TRUE)
[10:19:58.894]         }
[10:19:58.894]         {
[10:19:58.894]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:58.894]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.894]                 ...future.FUN(...future.X_jj, ...)
[10:19:58.894]             })
[10:19:58.894]         }
[10:19:58.894]     }, args = future.call.arguments)
[10:19:58.894] }
[10:19:58.894] Tweak future expression to call with '...' arguments ... DONE
[10:19:58.895] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:58.895] - packages: [1] ‘future.apply’
[10:19:58.895] getGlobalsAndPackages() ... DONE
[10:19:58.895] run() for ‘Future’ ...
[10:19:58.895] - state: ‘created’
[10:19:58.895] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:58.909] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:58.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:58.909]   - Field: ‘node’
[10:19:58.909]   - Field: ‘label’
[10:19:58.909]   - Field: ‘local’
[10:19:58.910]   - Field: ‘owner’
[10:19:58.910]   - Field: ‘envir’
[10:19:58.910]   - Field: ‘workers’
[10:19:58.910]   - Field: ‘packages’
[10:19:58.910]   - Field: ‘gc’
[10:19:58.910]   - Field: ‘conditions’
[10:19:58.910]   - Field: ‘persistent’
[10:19:58.910]   - Field: ‘expr’
[10:19:58.910]   - Field: ‘uuid’
[10:19:58.910]   - Field: ‘seed’
[10:19:58.910]   - Field: ‘version’
[10:19:58.910]   - Field: ‘result’
[10:19:58.911]   - Field: ‘asynchronous’
[10:19:58.911]   - Field: ‘calls’
[10:19:58.911]   - Field: ‘globals’
[10:19:58.911]   - Field: ‘stdout’
[10:19:58.911]   - Field: ‘earlySignal’
[10:19:58.911]   - Field: ‘lazy’
[10:19:58.911]   - Field: ‘state’
[10:19:58.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:58.911] - Launch lazy future ...
[10:19:58.911] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:58.912] Packages needed by future strategies (n = 0): <none>
[10:19:58.912] {
[10:19:58.912]     {
[10:19:58.912]         {
[10:19:58.912]             ...future.startTime <- base::Sys.time()
[10:19:58.912]             {
[10:19:58.912]                 {
[10:19:58.912]                   {
[10:19:58.912]                     {
[10:19:58.912]                       {
[10:19:58.912]                         base::local({
[10:19:58.912]                           has_future <- base::requireNamespace("future", 
[10:19:58.912]                             quietly = TRUE)
[10:19:58.912]                           if (has_future) {
[10:19:58.912]                             ns <- base::getNamespace("future")
[10:19:58.912]                             version <- ns[[".package"]][["version"]]
[10:19:58.912]                             if (is.null(version)) 
[10:19:58.912]                               version <- utils::packageVersion("future")
[10:19:58.912]                           }
[10:19:58.912]                           else {
[10:19:58.912]                             version <- NULL
[10:19:58.912]                           }
[10:19:58.912]                           if (!has_future || version < "1.8.0") {
[10:19:58.912]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:58.912]                               "", base::R.version$version.string), 
[10:19:58.912]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:58.912]                                 base::R.version$platform, 8 * 
[10:19:58.912]                                   base::.Machine$sizeof.pointer), 
[10:19:58.912]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:58.912]                                 "release", "version")], collapse = " "), 
[10:19:58.912]                               hostname = base::Sys.info()[["nodename"]])
[10:19:58.912]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:58.912]                               info)
[10:19:58.912]                             info <- base::paste(info, collapse = "; ")
[10:19:58.912]                             if (!has_future) {
[10:19:58.912]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:58.912]                                 info)
[10:19:58.912]                             }
[10:19:58.912]                             else {
[10:19:58.912]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:58.912]                                 info, version)
[10:19:58.912]                             }
[10:19:58.912]                             base::stop(msg)
[10:19:58.912]                           }
[10:19:58.912]                         })
[10:19:58.912]                       }
[10:19:58.912]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:58.912]                       base::options(mc.cores = 1L)
[10:19:58.912]                     }
[10:19:58.912]                     base::local({
[10:19:58.912]                       for (pkg in "future.apply") {
[10:19:58.912]                         base::loadNamespace(pkg)
[10:19:58.912]                         base::library(pkg, character.only = TRUE)
[10:19:58.912]                       }
[10:19:58.912]                     })
[10:19:58.912]                   }
[10:19:58.912]                   ...future.strategy.old <- future::plan("list")
[10:19:58.912]                   options(future.plan = NULL)
[10:19:58.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:58.912]                 }
[10:19:58.912]                 ...future.workdir <- getwd()
[10:19:58.912]             }
[10:19:58.912]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:58.912]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:58.912]         }
[10:19:58.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:58.912]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:58.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:58.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:58.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:58.912]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:58.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:58.912]             base::names(...future.oldOptions))
[10:19:58.912]     }
[10:19:58.912]     if (FALSE) {
[10:19:58.912]     }
[10:19:58.912]     else {
[10:19:58.912]         if (TRUE) {
[10:19:58.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:58.912]                 open = "w")
[10:19:58.912]         }
[10:19:58.912]         else {
[10:19:58.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:58.912]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:58.912]         }
[10:19:58.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:58.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:58.912]             base::sink(type = "output", split = FALSE)
[10:19:58.912]             base::close(...future.stdout)
[10:19:58.912]         }, add = TRUE)
[10:19:58.912]     }
[10:19:58.912]     ...future.frame <- base::sys.nframe()
[10:19:58.912]     ...future.conditions <- base::list()
[10:19:58.912]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:58.912]     if (FALSE) {
[10:19:58.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:58.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:58.912]     }
[10:19:58.912]     ...future.result <- base::tryCatch({
[10:19:58.912]         base::withCallingHandlers({
[10:19:58.912]             ...future.value <- base::withVisible(base::local({
[10:19:58.912]                 ...future.makeSendCondition <- base::local({
[10:19:58.912]                   sendCondition <- NULL
[10:19:58.912]                   function(frame = 1L) {
[10:19:58.912]                     if (is.function(sendCondition)) 
[10:19:58.912]                       return(sendCondition)
[10:19:58.912]                     ns <- getNamespace("parallel")
[10:19:58.912]                     if (exists("sendData", mode = "function", 
[10:19:58.912]                       envir = ns)) {
[10:19:58.912]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:58.912]                         envir = ns)
[10:19:58.912]                       envir <- sys.frame(frame)
[10:19:58.912]                       master <- NULL
[10:19:58.912]                       while (!identical(envir, .GlobalEnv) && 
[10:19:58.912]                         !identical(envir, emptyenv())) {
[10:19:58.912]                         if (exists("master", mode = "list", envir = envir, 
[10:19:58.912]                           inherits = FALSE)) {
[10:19:58.912]                           master <- get("master", mode = "list", 
[10:19:58.912]                             envir = envir, inherits = FALSE)
[10:19:58.912]                           if (inherits(master, c("SOCKnode", 
[10:19:58.912]                             "SOCK0node"))) {
[10:19:58.912]                             sendCondition <<- function(cond) {
[10:19:58.912]                               data <- list(type = "VALUE", value = cond, 
[10:19:58.912]                                 success = TRUE)
[10:19:58.912]                               parallel_sendData(master, data)
[10:19:58.912]                             }
[10:19:58.912]                             return(sendCondition)
[10:19:58.912]                           }
[10:19:58.912]                         }
[10:19:58.912]                         frame <- frame + 1L
[10:19:58.912]                         envir <- sys.frame(frame)
[10:19:58.912]                       }
[10:19:58.912]                     }
[10:19:58.912]                     sendCondition <<- function(cond) NULL
[10:19:58.912]                   }
[10:19:58.912]                 })
[10:19:58.912]                 withCallingHandlers({
[10:19:58.912]                   {
[10:19:58.912]                     do.call(function(...) {
[10:19:58.912]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:58.912]                       if (!identical(...future.globals.maxSize.org, 
[10:19:58.912]                         ...future.globals.maxSize)) {
[10:19:58.912]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:58.912]                         on.exit(options(oopts), add = TRUE)
[10:19:58.912]                       }
[10:19:58.912]                       {
[10:19:58.912]                         lapply(seq_along(...future.elements_ii), 
[10:19:58.912]                           FUN = function(jj) {
[10:19:58.912]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:58.912]                             ...future.FUN(...future.X_jj, ...)
[10:19:58.912]                           })
[10:19:58.912]                       }
[10:19:58.912]                     }, args = future.call.arguments)
[10:19:58.912]                   }
[10:19:58.912]                 }, immediateCondition = function(cond) {
[10:19:58.912]                   sendCondition <- ...future.makeSendCondition()
[10:19:58.912]                   sendCondition(cond)
[10:19:58.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.912]                   {
[10:19:58.912]                     inherits <- base::inherits
[10:19:58.912]                     invokeRestart <- base::invokeRestart
[10:19:58.912]                     is.null <- base::is.null
[10:19:58.912]                     muffled <- FALSE
[10:19:58.912]                     if (inherits(cond, "message")) {
[10:19:58.912]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:58.912]                       if (muffled) 
[10:19:58.912]                         invokeRestart("muffleMessage")
[10:19:58.912]                     }
[10:19:58.912]                     else if (inherits(cond, "warning")) {
[10:19:58.912]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:58.912]                       if (muffled) 
[10:19:58.912]                         invokeRestart("muffleWarning")
[10:19:58.912]                     }
[10:19:58.912]                     else if (inherits(cond, "condition")) {
[10:19:58.912]                       if (!is.null(pattern)) {
[10:19:58.912]                         computeRestarts <- base::computeRestarts
[10:19:58.912]                         grepl <- base::grepl
[10:19:58.912]                         restarts <- computeRestarts(cond)
[10:19:58.912]                         for (restart in restarts) {
[10:19:58.912]                           name <- restart$name
[10:19:58.912]                           if (is.null(name)) 
[10:19:58.912]                             next
[10:19:58.912]                           if (!grepl(pattern, name)) 
[10:19:58.912]                             next
[10:19:58.912]                           invokeRestart(restart)
[10:19:58.912]                           muffled <- TRUE
[10:19:58.912]                           break
[10:19:58.912]                         }
[10:19:58.912]                       }
[10:19:58.912]                     }
[10:19:58.912]                     invisible(muffled)
[10:19:58.912]                   }
[10:19:58.912]                   muffleCondition(cond)
[10:19:58.912]                 })
[10:19:58.912]             }))
[10:19:58.912]             future::FutureResult(value = ...future.value$value, 
[10:19:58.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.912]                   ...future.rng), globalenv = if (FALSE) 
[10:19:58.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:58.912]                     ...future.globalenv.names))
[10:19:58.912]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:58.912]         }, condition = base::local({
[10:19:58.912]             c <- base::c
[10:19:58.912]             inherits <- base::inherits
[10:19:58.912]             invokeRestart <- base::invokeRestart
[10:19:58.912]             length <- base::length
[10:19:58.912]             list <- base::list
[10:19:58.912]             seq.int <- base::seq.int
[10:19:58.912]             signalCondition <- base::signalCondition
[10:19:58.912]             sys.calls <- base::sys.calls
[10:19:58.912]             `[[` <- base::`[[`
[10:19:58.912]             `+` <- base::`+`
[10:19:58.912]             `<<-` <- base::`<<-`
[10:19:58.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:58.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:58.912]                   3L)]
[10:19:58.912]             }
[10:19:58.912]             function(cond) {
[10:19:58.912]                 is_error <- inherits(cond, "error")
[10:19:58.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:58.912]                   NULL)
[10:19:58.912]                 if (is_error) {
[10:19:58.912]                   sessionInformation <- function() {
[10:19:58.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:58.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:58.912]                       search = base::search(), system = base::Sys.info())
[10:19:58.912]                   }
[10:19:58.912]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:58.912]                     cond$call), session = sessionInformation(), 
[10:19:58.912]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:58.912]                   signalCondition(cond)
[10:19:58.912]                 }
[10:19:58.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:58.912]                 "immediateCondition"))) {
[10:19:58.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:58.912]                   ...future.conditions[[length(...future.conditions) + 
[10:19:58.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:58.912]                   if (TRUE && !signal) {
[10:19:58.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.912]                     {
[10:19:58.912]                       inherits <- base::inherits
[10:19:58.912]                       invokeRestart <- base::invokeRestart
[10:19:58.912]                       is.null <- base::is.null
[10:19:58.912]                       muffled <- FALSE
[10:19:58.912]                       if (inherits(cond, "message")) {
[10:19:58.912]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.912]                         if (muffled) 
[10:19:58.912]                           invokeRestart("muffleMessage")
[10:19:58.912]                       }
[10:19:58.912]                       else if (inherits(cond, "warning")) {
[10:19:58.912]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.912]                         if (muffled) 
[10:19:58.912]                           invokeRestart("muffleWarning")
[10:19:58.912]                       }
[10:19:58.912]                       else if (inherits(cond, "condition")) {
[10:19:58.912]                         if (!is.null(pattern)) {
[10:19:58.912]                           computeRestarts <- base::computeRestarts
[10:19:58.912]                           grepl <- base::grepl
[10:19:58.912]                           restarts <- computeRestarts(cond)
[10:19:58.912]                           for (restart in restarts) {
[10:19:58.912]                             name <- restart$name
[10:19:58.912]                             if (is.null(name)) 
[10:19:58.912]                               next
[10:19:58.912]                             if (!grepl(pattern, name)) 
[10:19:58.912]                               next
[10:19:58.912]                             invokeRestart(restart)
[10:19:58.912]                             muffled <- TRUE
[10:19:58.912]                             break
[10:19:58.912]                           }
[10:19:58.912]                         }
[10:19:58.912]                       }
[10:19:58.912]                       invisible(muffled)
[10:19:58.912]                     }
[10:19:58.912]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.912]                   }
[10:19:58.912]                 }
[10:19:58.912]                 else {
[10:19:58.912]                   if (TRUE) {
[10:19:58.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:58.912]                     {
[10:19:58.912]                       inherits <- base::inherits
[10:19:58.912]                       invokeRestart <- base::invokeRestart
[10:19:58.912]                       is.null <- base::is.null
[10:19:58.912]                       muffled <- FALSE
[10:19:58.912]                       if (inherits(cond, "message")) {
[10:19:58.912]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:58.912]                         if (muffled) 
[10:19:58.912]                           invokeRestart("muffleMessage")
[10:19:58.912]                       }
[10:19:58.912]                       else if (inherits(cond, "warning")) {
[10:19:58.912]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:58.912]                         if (muffled) 
[10:19:58.912]                           invokeRestart("muffleWarning")
[10:19:58.912]                       }
[10:19:58.912]                       else if (inherits(cond, "condition")) {
[10:19:58.912]                         if (!is.null(pattern)) {
[10:19:58.912]                           computeRestarts <- base::computeRestarts
[10:19:58.912]                           grepl <- base::grepl
[10:19:58.912]                           restarts <- computeRestarts(cond)
[10:19:58.912]                           for (restart in restarts) {
[10:19:58.912]                             name <- restart$name
[10:19:58.912]                             if (is.null(name)) 
[10:19:58.912]                               next
[10:19:58.912]                             if (!grepl(pattern, name)) 
[10:19:58.912]                               next
[10:19:58.912]                             invokeRestart(restart)
[10:19:58.912]                             muffled <- TRUE
[10:19:58.912]                             break
[10:19:58.912]                           }
[10:19:58.912]                         }
[10:19:58.912]                       }
[10:19:58.912]                       invisible(muffled)
[10:19:58.912]                     }
[10:19:58.912]                     muffleCondition(cond, pattern = "^muffle")
[10:19:58.912]                   }
[10:19:58.912]                 }
[10:19:58.912]             }
[10:19:58.912]         }))
[10:19:58.912]     }, error = function(ex) {
[10:19:58.912]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:58.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:58.912]                 ...future.rng), started = ...future.startTime, 
[10:19:58.912]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:58.912]             version = "1.8"), class = "FutureResult")
[10:19:58.912]     }, finally = {
[10:19:58.912]         if (!identical(...future.workdir, getwd())) 
[10:19:58.912]             setwd(...future.workdir)
[10:19:58.912]         {
[10:19:58.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:58.912]                 ...future.oldOptions$nwarnings <- NULL
[10:19:58.912]             }
[10:19:58.912]             base::options(...future.oldOptions)
[10:19:58.912]             if (.Platform$OS.type == "windows") {
[10:19:58.912]                 old_names <- names(...future.oldEnvVars)
[10:19:58.912]                 envs <- base::Sys.getenv()
[10:19:58.912]                 names <- names(envs)
[10:19:58.912]                 common <- intersect(names, old_names)
[10:19:58.912]                 added <- setdiff(names, old_names)
[10:19:58.912]                 removed <- setdiff(old_names, names)
[10:19:58.912]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:58.912]                   envs[common]]
[10:19:58.912]                 NAMES <- toupper(changed)
[10:19:58.912]                 args <- list()
[10:19:58.912]                 for (kk in seq_along(NAMES)) {
[10:19:58.912]                   name <- changed[[kk]]
[10:19:58.912]                   NAME <- NAMES[[kk]]
[10:19:58.912]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.912]                     next
[10:19:58.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.912]                 }
[10:19:58.912]                 NAMES <- toupper(added)
[10:19:58.912]                 for (kk in seq_along(NAMES)) {
[10:19:58.912]                   name <- added[[kk]]
[10:19:58.912]                   NAME <- NAMES[[kk]]
[10:19:58.912]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.912]                     next
[10:19:58.912]                   args[[name]] <- ""
[10:19:58.912]                 }
[10:19:58.912]                 NAMES <- toupper(removed)
[10:19:58.912]                 for (kk in seq_along(NAMES)) {
[10:19:58.912]                   name <- removed[[kk]]
[10:19:58.912]                   NAME <- NAMES[[kk]]
[10:19:58.912]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:58.912]                     next
[10:19:58.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:58.912]                 }
[10:19:58.912]                 if (length(args) > 0) 
[10:19:58.912]                   base::do.call(base::Sys.setenv, args = args)
[10:19:58.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:58.912]             }
[10:19:58.912]             else {
[10:19:58.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:58.912]             }
[10:19:58.912]             {
[10:19:58.912]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:58.912]                   0L) {
[10:19:58.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:58.912]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:58.912]                   base::options(opts)
[10:19:58.912]                 }
[10:19:58.912]                 {
[10:19:58.912]                   {
[10:19:58.912]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:58.912]                     NULL
[10:19:58.912]                   }
[10:19:58.912]                   options(future.plan = NULL)
[10:19:58.912]                   if (is.na(NA_character_)) 
[10:19:58.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:58.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:58.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:58.912]                     .init = FALSE)
[10:19:58.912]                 }
[10:19:58.912]             }
[10:19:58.912]         }
[10:19:58.912]     })
[10:19:58.912]     if (TRUE) {
[10:19:58.912]         base::sink(type = "output", split = FALSE)
[10:19:58.912]         if (TRUE) {
[10:19:58.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:58.912]         }
[10:19:58.912]         else {
[10:19:58.912]             ...future.result["stdout"] <- base::list(NULL)
[10:19:58.912]         }
[10:19:58.912]         base::close(...future.stdout)
[10:19:58.912]         ...future.stdout <- NULL
[10:19:58.912]     }
[10:19:58.912]     ...future.result$conditions <- ...future.conditions
[10:19:58.912]     ...future.result$finished <- base::Sys.time()
[10:19:58.912]     ...future.result
[10:19:58.912] }
[10:19:58.915] Exporting 11 global objects (14.80 KiB) to cluster node #1 ...
[10:19:58.915] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #1 ...
[10:19:58.956] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #1 ... DONE
[10:19:58.957] Exporting ‘x_FUN’ (680 bytes) to cluster node #1 ...
[10:19:58.957] Exporting ‘x_FUN’ (680 bytes) to cluster node #1 ... DONE
[10:19:58.957] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:58.958] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:58.958] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:58.998] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:58.999] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:59.039] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:59.040] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[10:19:59.040] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[10:19:59.040] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:19:59.041] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:19:59.041] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ...
[10:19:59.041] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ... DONE
[10:19:59.041] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ...
[10:19:59.042] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ... DONE
[10:19:59.042] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:59.042] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.042] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:59.042] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.043] Exporting 11 global objects (14.80 KiB) to cluster node #1 ... DONE
[10:19:59.043] MultisessionFuture started
[10:19:59.043] - Launch lazy future ... done
[10:19:59.043] run() for ‘MultisessionFuture’ ... done
[10:19:59.043] Created future:
[10:19:59.043] MultisessionFuture:
[10:19:59.043] Label: ‘future_vapply-1’
[10:19:59.043] Expression:
[10:19:59.043] {
[10:19:59.043]     do.call(function(...) {
[10:19:59.043]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.043]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.043]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.043]             on.exit(options(oopts), add = TRUE)
[10:19:59.043]         }
[10:19:59.043]         {
[10:19:59.043]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.043]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.043]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.043]             })
[10:19:59.043]         }
[10:19:59.043]     }, args = future.call.arguments)
[10:19:59.043] }
[10:19:59.043] Lazy evaluation: FALSE
[10:19:59.043] Asynchronous evaluation: TRUE
[10:19:59.043] Local evaluation: TRUE
[10:19:59.043] Environment: R_GlobalEnv
[10:19:59.043] Capture standard output: TRUE
[10:19:59.043] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:59.043] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:59.043] Packages: 1 packages (‘future.apply’)
[10:19:59.043] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:59.043] Resolved: FALSE
[10:19:59.043] Value: <not collected>
[10:19:59.043] Conditions captured: <none>
[10:19:59.043] Early signaling: FALSE
[10:19:59.043] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:59.043] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.055] Chunk #1 of 2 ... DONE
[10:19:59.055] Chunk #2 of 2 ...
[10:19:59.055]  - Finding globals in 'X' for chunk #2 ...
[10:19:59.055] getGlobalsAndPackages() ...
[10:19:59.055] Searching for globals...
[10:19:59.056] 
[10:19:59.056] Searching for globals ... DONE
[10:19:59.056] - globals: [0] <none>
[10:19:59.056] getGlobalsAndPackages() ... DONE
[10:19:59.056]    + additional globals found: [n=0] 
[10:19:59.056]    + additional namespaces needed: [n=0] 
[10:19:59.056]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:59.056]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:59.056]  - seeds: <none>
[10:19:59.056]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.056] getGlobalsAndPackages() ...
[10:19:59.057] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.057] Resolving globals: FALSE
[10:19:59.057] Tweak future expression to call with '...' arguments ...
[10:19:59.057] {
[10:19:59.057]     do.call(function(...) {
[10:19:59.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.057]             on.exit(options(oopts), add = TRUE)
[10:19:59.057]         }
[10:19:59.057]         {
[10:19:59.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.057]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.057]             })
[10:19:59.057]         }
[10:19:59.057]     }, args = future.call.arguments)
[10:19:59.057] }
[10:19:59.057] Tweak future expression to call with '...' arguments ... DONE
[10:19:59.058] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.058] - packages: [1] ‘future.apply’
[10:19:59.058] getGlobalsAndPackages() ... DONE
[10:19:59.058] run() for ‘Future’ ...
[10:19:59.058] - state: ‘created’
[10:19:59.058] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:59.072] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:59.072]   - Field: ‘node’
[10:19:59.072]   - Field: ‘label’
[10:19:59.072]   - Field: ‘local’
[10:19:59.072]   - Field: ‘owner’
[10:19:59.072]   - Field: ‘envir’
[10:19:59.072]   - Field: ‘workers’
[10:19:59.073]   - Field: ‘packages’
[10:19:59.073]   - Field: ‘gc’
[10:19:59.073]   - Field: ‘conditions’
[10:19:59.073]   - Field: ‘persistent’
[10:19:59.073]   - Field: ‘expr’
[10:19:59.073]   - Field: ‘uuid’
[10:19:59.073]   - Field: ‘seed’
[10:19:59.073]   - Field: ‘version’
[10:19:59.073]   - Field: ‘result’
[10:19:59.073]   - Field: ‘asynchronous’
[10:19:59.073]   - Field: ‘calls’
[10:19:59.073]   - Field: ‘globals’
[10:19:59.073]   - Field: ‘stdout’
[10:19:59.074]   - Field: ‘earlySignal’
[10:19:59.074]   - Field: ‘lazy’
[10:19:59.074]   - Field: ‘state’
[10:19:59.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:59.074] - Launch lazy future ...
[10:19:59.074] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:59.074] Packages needed by future strategies (n = 0): <none>
[10:19:59.075] {
[10:19:59.075]     {
[10:19:59.075]         {
[10:19:59.075]             ...future.startTime <- base::Sys.time()
[10:19:59.075]             {
[10:19:59.075]                 {
[10:19:59.075]                   {
[10:19:59.075]                     {
[10:19:59.075]                       {
[10:19:59.075]                         base::local({
[10:19:59.075]                           has_future <- base::requireNamespace("future", 
[10:19:59.075]                             quietly = TRUE)
[10:19:59.075]                           if (has_future) {
[10:19:59.075]                             ns <- base::getNamespace("future")
[10:19:59.075]                             version <- ns[[".package"]][["version"]]
[10:19:59.075]                             if (is.null(version)) 
[10:19:59.075]                               version <- utils::packageVersion("future")
[10:19:59.075]                           }
[10:19:59.075]                           else {
[10:19:59.075]                             version <- NULL
[10:19:59.075]                           }
[10:19:59.075]                           if (!has_future || version < "1.8.0") {
[10:19:59.075]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:59.075]                               "", base::R.version$version.string), 
[10:19:59.075]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:59.075]                                 base::R.version$platform, 8 * 
[10:19:59.075]                                   base::.Machine$sizeof.pointer), 
[10:19:59.075]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:59.075]                                 "release", "version")], collapse = " "), 
[10:19:59.075]                               hostname = base::Sys.info()[["nodename"]])
[10:19:59.075]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:59.075]                               info)
[10:19:59.075]                             info <- base::paste(info, collapse = "; ")
[10:19:59.075]                             if (!has_future) {
[10:19:59.075]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:59.075]                                 info)
[10:19:59.075]                             }
[10:19:59.075]                             else {
[10:19:59.075]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:59.075]                                 info, version)
[10:19:59.075]                             }
[10:19:59.075]                             base::stop(msg)
[10:19:59.075]                           }
[10:19:59.075]                         })
[10:19:59.075]                       }
[10:19:59.075]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:59.075]                       base::options(mc.cores = 1L)
[10:19:59.075]                     }
[10:19:59.075]                     base::local({
[10:19:59.075]                       for (pkg in "future.apply") {
[10:19:59.075]                         base::loadNamespace(pkg)
[10:19:59.075]                         base::library(pkg, character.only = TRUE)
[10:19:59.075]                       }
[10:19:59.075]                     })
[10:19:59.075]                   }
[10:19:59.075]                   ...future.strategy.old <- future::plan("list")
[10:19:59.075]                   options(future.plan = NULL)
[10:19:59.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:59.075]                 }
[10:19:59.075]                 ...future.workdir <- getwd()
[10:19:59.075]             }
[10:19:59.075]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:59.075]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:59.075]         }
[10:19:59.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:59.075]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:59.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:59.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:59.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:59.075]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:59.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:59.075]             base::names(...future.oldOptions))
[10:19:59.075]     }
[10:19:59.075]     if (FALSE) {
[10:19:59.075]     }
[10:19:59.075]     else {
[10:19:59.075]         if (TRUE) {
[10:19:59.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:59.075]                 open = "w")
[10:19:59.075]         }
[10:19:59.075]         else {
[10:19:59.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:59.075]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:59.075]         }
[10:19:59.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:59.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:59.075]             base::sink(type = "output", split = FALSE)
[10:19:59.075]             base::close(...future.stdout)
[10:19:59.075]         }, add = TRUE)
[10:19:59.075]     }
[10:19:59.075]     ...future.frame <- base::sys.nframe()
[10:19:59.075]     ...future.conditions <- base::list()
[10:19:59.075]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:59.075]     if (FALSE) {
[10:19:59.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:59.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:59.075]     }
[10:19:59.075]     ...future.result <- base::tryCatch({
[10:19:59.075]         base::withCallingHandlers({
[10:19:59.075]             ...future.value <- base::withVisible(base::local({
[10:19:59.075]                 ...future.makeSendCondition <- base::local({
[10:19:59.075]                   sendCondition <- NULL
[10:19:59.075]                   function(frame = 1L) {
[10:19:59.075]                     if (is.function(sendCondition)) 
[10:19:59.075]                       return(sendCondition)
[10:19:59.075]                     ns <- getNamespace("parallel")
[10:19:59.075]                     if (exists("sendData", mode = "function", 
[10:19:59.075]                       envir = ns)) {
[10:19:59.075]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:59.075]                         envir = ns)
[10:19:59.075]                       envir <- sys.frame(frame)
[10:19:59.075]                       master <- NULL
[10:19:59.075]                       while (!identical(envir, .GlobalEnv) && 
[10:19:59.075]                         !identical(envir, emptyenv())) {
[10:19:59.075]                         if (exists("master", mode = "list", envir = envir, 
[10:19:59.075]                           inherits = FALSE)) {
[10:19:59.075]                           master <- get("master", mode = "list", 
[10:19:59.075]                             envir = envir, inherits = FALSE)
[10:19:59.075]                           if (inherits(master, c("SOCKnode", 
[10:19:59.075]                             "SOCK0node"))) {
[10:19:59.075]                             sendCondition <<- function(cond) {
[10:19:59.075]                               data <- list(type = "VALUE", value = cond, 
[10:19:59.075]                                 success = TRUE)
[10:19:59.075]                               parallel_sendData(master, data)
[10:19:59.075]                             }
[10:19:59.075]                             return(sendCondition)
[10:19:59.075]                           }
[10:19:59.075]                         }
[10:19:59.075]                         frame <- frame + 1L
[10:19:59.075]                         envir <- sys.frame(frame)
[10:19:59.075]                       }
[10:19:59.075]                     }
[10:19:59.075]                     sendCondition <<- function(cond) NULL
[10:19:59.075]                   }
[10:19:59.075]                 })
[10:19:59.075]                 withCallingHandlers({
[10:19:59.075]                   {
[10:19:59.075]                     do.call(function(...) {
[10:19:59.075]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.075]                       if (!identical(...future.globals.maxSize.org, 
[10:19:59.075]                         ...future.globals.maxSize)) {
[10:19:59.075]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.075]                         on.exit(options(oopts), add = TRUE)
[10:19:59.075]                       }
[10:19:59.075]                       {
[10:19:59.075]                         lapply(seq_along(...future.elements_ii), 
[10:19:59.075]                           FUN = function(jj) {
[10:19:59.075]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.075]                             ...future.FUN(...future.X_jj, ...)
[10:19:59.075]                           })
[10:19:59.075]                       }
[10:19:59.075]                     }, args = future.call.arguments)
[10:19:59.075]                   }
[10:19:59.075]                 }, immediateCondition = function(cond) {
[10:19:59.075]                   sendCondition <- ...future.makeSendCondition()
[10:19:59.075]                   sendCondition(cond)
[10:19:59.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.075]                   {
[10:19:59.075]                     inherits <- base::inherits
[10:19:59.075]                     invokeRestart <- base::invokeRestart
[10:19:59.075]                     is.null <- base::is.null
[10:19:59.075]                     muffled <- FALSE
[10:19:59.075]                     if (inherits(cond, "message")) {
[10:19:59.075]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:59.075]                       if (muffled) 
[10:19:59.075]                         invokeRestart("muffleMessage")
[10:19:59.075]                     }
[10:19:59.075]                     else if (inherits(cond, "warning")) {
[10:19:59.075]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:59.075]                       if (muffled) 
[10:19:59.075]                         invokeRestart("muffleWarning")
[10:19:59.075]                     }
[10:19:59.075]                     else if (inherits(cond, "condition")) {
[10:19:59.075]                       if (!is.null(pattern)) {
[10:19:59.075]                         computeRestarts <- base::computeRestarts
[10:19:59.075]                         grepl <- base::grepl
[10:19:59.075]                         restarts <- computeRestarts(cond)
[10:19:59.075]                         for (restart in restarts) {
[10:19:59.075]                           name <- restart$name
[10:19:59.075]                           if (is.null(name)) 
[10:19:59.075]                             next
[10:19:59.075]                           if (!grepl(pattern, name)) 
[10:19:59.075]                             next
[10:19:59.075]                           invokeRestart(restart)
[10:19:59.075]                           muffled <- TRUE
[10:19:59.075]                           break
[10:19:59.075]                         }
[10:19:59.075]                       }
[10:19:59.075]                     }
[10:19:59.075]                     invisible(muffled)
[10:19:59.075]                   }
[10:19:59.075]                   muffleCondition(cond)
[10:19:59.075]                 })
[10:19:59.075]             }))
[10:19:59.075]             future::FutureResult(value = ...future.value$value, 
[10:19:59.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.075]                   ...future.rng), globalenv = if (FALSE) 
[10:19:59.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:59.075]                     ...future.globalenv.names))
[10:19:59.075]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:59.075]         }, condition = base::local({
[10:19:59.075]             c <- base::c
[10:19:59.075]             inherits <- base::inherits
[10:19:59.075]             invokeRestart <- base::invokeRestart
[10:19:59.075]             length <- base::length
[10:19:59.075]             list <- base::list
[10:19:59.075]             seq.int <- base::seq.int
[10:19:59.075]             signalCondition <- base::signalCondition
[10:19:59.075]             sys.calls <- base::sys.calls
[10:19:59.075]             `[[` <- base::`[[`
[10:19:59.075]             `+` <- base::`+`
[10:19:59.075]             `<<-` <- base::`<<-`
[10:19:59.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:59.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:59.075]                   3L)]
[10:19:59.075]             }
[10:19:59.075]             function(cond) {
[10:19:59.075]                 is_error <- inherits(cond, "error")
[10:19:59.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:59.075]                   NULL)
[10:19:59.075]                 if (is_error) {
[10:19:59.075]                   sessionInformation <- function() {
[10:19:59.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:59.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:59.075]                       search = base::search(), system = base::Sys.info())
[10:19:59.075]                   }
[10:19:59.075]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:59.075]                     cond$call), session = sessionInformation(), 
[10:19:59.075]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:59.075]                   signalCondition(cond)
[10:19:59.075]                 }
[10:19:59.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:59.075]                 "immediateCondition"))) {
[10:19:59.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:59.075]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:59.075]                   if (TRUE && !signal) {
[10:19:59.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.075]                     {
[10:19:59.075]                       inherits <- base::inherits
[10:19:59.075]                       invokeRestart <- base::invokeRestart
[10:19:59.075]                       is.null <- base::is.null
[10:19:59.075]                       muffled <- FALSE
[10:19:59.075]                       if (inherits(cond, "message")) {
[10:19:59.075]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.075]                         if (muffled) 
[10:19:59.075]                           invokeRestart("muffleMessage")
[10:19:59.075]                       }
[10:19:59.075]                       else if (inherits(cond, "warning")) {
[10:19:59.075]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.075]                         if (muffled) 
[10:19:59.075]                           invokeRestart("muffleWarning")
[10:19:59.075]                       }
[10:19:59.075]                       else if (inherits(cond, "condition")) {
[10:19:59.075]                         if (!is.null(pattern)) {
[10:19:59.075]                           computeRestarts <- base::computeRestarts
[10:19:59.075]                           grepl <- base::grepl
[10:19:59.075]                           restarts <- computeRestarts(cond)
[10:19:59.075]                           for (restart in restarts) {
[10:19:59.075]                             name <- restart$name
[10:19:59.075]                             if (is.null(name)) 
[10:19:59.075]                               next
[10:19:59.075]                             if (!grepl(pattern, name)) 
[10:19:59.075]                               next
[10:19:59.075]                             invokeRestart(restart)
[10:19:59.075]                             muffled <- TRUE
[10:19:59.075]                             break
[10:19:59.075]                           }
[10:19:59.075]                         }
[10:19:59.075]                       }
[10:19:59.075]                       invisible(muffled)
[10:19:59.075]                     }
[10:19:59.075]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.075]                   }
[10:19:59.075]                 }
[10:19:59.075]                 else {
[10:19:59.075]                   if (TRUE) {
[10:19:59.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.075]                     {
[10:19:59.075]                       inherits <- base::inherits
[10:19:59.075]                       invokeRestart <- base::invokeRestart
[10:19:59.075]                       is.null <- base::is.null
[10:19:59.075]                       muffled <- FALSE
[10:19:59.075]                       if (inherits(cond, "message")) {
[10:19:59.075]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.075]                         if (muffled) 
[10:19:59.075]                           invokeRestart("muffleMessage")
[10:19:59.075]                       }
[10:19:59.075]                       else if (inherits(cond, "warning")) {
[10:19:59.075]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.075]                         if (muffled) 
[10:19:59.075]                           invokeRestart("muffleWarning")
[10:19:59.075]                       }
[10:19:59.075]                       else if (inherits(cond, "condition")) {
[10:19:59.075]                         if (!is.null(pattern)) {
[10:19:59.075]                           computeRestarts <- base::computeRestarts
[10:19:59.075]                           grepl <- base::grepl
[10:19:59.075]                           restarts <- computeRestarts(cond)
[10:19:59.075]                           for (restart in restarts) {
[10:19:59.075]                             name <- restart$name
[10:19:59.075]                             if (is.null(name)) 
[10:19:59.075]                               next
[10:19:59.075]                             if (!grepl(pattern, name)) 
[10:19:59.075]                               next
[10:19:59.075]                             invokeRestart(restart)
[10:19:59.075]                             muffled <- TRUE
[10:19:59.075]                             break
[10:19:59.075]                           }
[10:19:59.075]                         }
[10:19:59.075]                       }
[10:19:59.075]                       invisible(muffled)
[10:19:59.075]                     }
[10:19:59.075]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.075]                   }
[10:19:59.075]                 }
[10:19:59.075]             }
[10:19:59.075]         }))
[10:19:59.075]     }, error = function(ex) {
[10:19:59.075]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:59.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.075]                 ...future.rng), started = ...future.startTime, 
[10:19:59.075]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:59.075]             version = "1.8"), class = "FutureResult")
[10:19:59.075]     }, finally = {
[10:19:59.075]         if (!identical(...future.workdir, getwd())) 
[10:19:59.075]             setwd(...future.workdir)
[10:19:59.075]         {
[10:19:59.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:59.075]                 ...future.oldOptions$nwarnings <- NULL
[10:19:59.075]             }
[10:19:59.075]             base::options(...future.oldOptions)
[10:19:59.075]             if (.Platform$OS.type == "windows") {
[10:19:59.075]                 old_names <- names(...future.oldEnvVars)
[10:19:59.075]                 envs <- base::Sys.getenv()
[10:19:59.075]                 names <- names(envs)
[10:19:59.075]                 common <- intersect(names, old_names)
[10:19:59.075]                 added <- setdiff(names, old_names)
[10:19:59.075]                 removed <- setdiff(old_names, names)
[10:19:59.075]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:59.075]                   envs[common]]
[10:19:59.075]                 NAMES <- toupper(changed)
[10:19:59.075]                 args <- list()
[10:19:59.075]                 for (kk in seq_along(NAMES)) {
[10:19:59.075]                   name <- changed[[kk]]
[10:19:59.075]                   NAME <- NAMES[[kk]]
[10:19:59.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.075]                     next
[10:19:59.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.075]                 }
[10:19:59.075]                 NAMES <- toupper(added)
[10:19:59.075]                 for (kk in seq_along(NAMES)) {
[10:19:59.075]                   name <- added[[kk]]
[10:19:59.075]                   NAME <- NAMES[[kk]]
[10:19:59.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.075]                     next
[10:19:59.075]                   args[[name]] <- ""
[10:19:59.075]                 }
[10:19:59.075]                 NAMES <- toupper(removed)
[10:19:59.075]                 for (kk in seq_along(NAMES)) {
[10:19:59.075]                   name <- removed[[kk]]
[10:19:59.075]                   NAME <- NAMES[[kk]]
[10:19:59.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.075]                     next
[10:19:59.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.075]                 }
[10:19:59.075]                 if (length(args) > 0) 
[10:19:59.075]                   base::do.call(base::Sys.setenv, args = args)
[10:19:59.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:59.075]             }
[10:19:59.075]             else {
[10:19:59.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:59.075]             }
[10:19:59.075]             {
[10:19:59.075]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:59.075]                   0L) {
[10:19:59.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:59.075]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:59.075]                   base::options(opts)
[10:19:59.075]                 }
[10:19:59.075]                 {
[10:19:59.075]                   {
[10:19:59.075]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:59.075]                     NULL
[10:19:59.075]                   }
[10:19:59.075]                   options(future.plan = NULL)
[10:19:59.075]                   if (is.na(NA_character_)) 
[10:19:59.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:59.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:59.075]                     .init = FALSE)
[10:19:59.075]                 }
[10:19:59.075]             }
[10:19:59.075]         }
[10:19:59.075]     })
[10:19:59.075]     if (TRUE) {
[10:19:59.075]         base::sink(type = "output", split = FALSE)
[10:19:59.075]         if (TRUE) {
[10:19:59.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:59.075]         }
[10:19:59.075]         else {
[10:19:59.075]             ...future.result["stdout"] <- base::list(NULL)
[10:19:59.075]         }
[10:19:59.075]         base::close(...future.stdout)
[10:19:59.075]         ...future.stdout <- NULL
[10:19:59.075]     }
[10:19:59.075]     ...future.result$conditions <- ...future.conditions
[10:19:59.075]     ...future.result$finished <- base::Sys.time()
[10:19:59.075]     ...future.result
[10:19:59.075] }
[10:19:59.078] Exporting 11 global objects (14.80 KiB) to cluster node #2 ...
[10:19:59.078] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #2 ...
[10:19:59.118] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #2 ... DONE
[10:19:59.119] Exporting ‘x_FUN’ (680 bytes) to cluster node #2 ...
[10:19:59.119] Exporting ‘x_FUN’ (680 bytes) to cluster node #2 ... DONE
[10:19:59.119] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:59.120] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:59.120] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:59.161] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:59.162] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:59.202] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:59.203] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[10:19:59.203] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[10:19:59.203] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:19:59.203] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:19:59.204] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ...
[10:19:59.204] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ... DONE
[10:19:59.204] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[10:19:59.204] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[10:19:59.205] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:59.205] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.205] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:59.205] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.205] Exporting 11 global objects (14.80 KiB) to cluster node #2 ... DONE
[10:19:59.206] MultisessionFuture started
[10:19:59.206] - Launch lazy future ... done
[10:19:59.206] run() for ‘MultisessionFuture’ ... done
[10:19:59.206] Created future:
[10:19:59.206] MultisessionFuture:
[10:19:59.206] Label: ‘future_vapply-2’
[10:19:59.206] Expression:
[10:19:59.206] {
[10:19:59.206]     do.call(function(...) {
[10:19:59.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.206]             on.exit(options(oopts), add = TRUE)
[10:19:59.206]         }
[10:19:59.206]         {
[10:19:59.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.206]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.206]             })
[10:19:59.206]         }
[10:19:59.206]     }, args = future.call.arguments)
[10:19:59.206] }
[10:19:59.206] Lazy evaluation: FALSE
[10:19:59.206] Asynchronous evaluation: TRUE
[10:19:59.206] Local evaluation: TRUE
[10:19:59.206] Environment: R_GlobalEnv
[10:19:59.206] Capture standard output: TRUE
[10:19:59.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:59.206] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:59.206] Packages: 1 packages (‘future.apply’)
[10:19:59.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:59.206] Resolved: FALSE
[10:19:59.206] Value: <not collected>
[10:19:59.206] Conditions captured: <none>
[10:19:59.206] Early signaling: FALSE
[10:19:59.206] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:59.206] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.218] Chunk #2 of 2 ... DONE
[10:19:59.218] Launching 2 futures (chunks) ... DONE
[10:19:59.218] Resolving 2 futures (chunks) ...
[10:19:59.218] resolve() on list ...
[10:19:59.218]  recursive: 0
[10:19:59.218]  length: 2
[10:19:59.219] 
[10:19:59.219] receiveMessageFromWorker() for ClusterFuture ...
[10:19:59.219] - Validating connection of MultisessionFuture
[10:19:59.219] - received message: FutureResult
[10:19:59.219] - Received FutureResult
[10:19:59.219] - Erased future from FutureRegistry
[10:19:59.220] result() for ClusterFuture ...
[10:19:59.220] - result already collected: FutureResult
[10:19:59.220] result() for ClusterFuture ... done
[10:19:59.220] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:59.220] Future #1
[10:19:59.220] result() for ClusterFuture ...
[10:19:59.220] - result already collected: FutureResult
[10:19:59.220] result() for ClusterFuture ... done
[10:19:59.220] result() for ClusterFuture ...
[10:19:59.220] - result already collected: FutureResult
[10:19:59.220] result() for ClusterFuture ... done
[10:19:59.220] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:59.221] - nx: 2
[10:19:59.221] - relay: TRUE
[10:19:59.221] - stdout: TRUE
[10:19:59.221] - signal: TRUE
[10:19:59.221] - resignal: FALSE
[10:19:59.221] - force: TRUE
[10:19:59.221] - relayed: [n=2] FALSE, FALSE
[10:19:59.221] - queued futures: [n=2] FALSE, FALSE
[10:19:59.221]  - until=1
[10:19:59.221]  - relaying element #1
[10:19:59.221] result() for ClusterFuture ...
[10:19:59.221] - result already collected: FutureResult
[10:19:59.221] result() for ClusterFuture ... done
[10:19:59.222] result() for ClusterFuture ...
[10:19:59.222] - result already collected: FutureResult
[10:19:59.222] result() for ClusterFuture ... done
[10:19:59.222] result() for ClusterFuture ...
[10:19:59.222] - result already collected: FutureResult
[10:19:59.222] result() for ClusterFuture ... done
[10:19:59.222] result() for ClusterFuture ...
[10:19:59.222] - result already collected: FutureResult
[10:19:59.222] result() for ClusterFuture ... done
[10:19:59.222] - relayed: [n=2] TRUE, FALSE
[10:19:59.222] - queued futures: [n=2] TRUE, FALSE
[10:19:59.222] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:59.223]  length: 1 (resolved future 1)
[10:19:59.248] receiveMessageFromWorker() for ClusterFuture ...
[10:19:59.248] - Validating connection of MultisessionFuture
[10:19:59.249] - received message: FutureResult
[10:19:59.249] - Received FutureResult
[10:19:59.249] - Erased future from FutureRegistry
[10:19:59.249] result() for ClusterFuture ...
[10:19:59.249] - result already collected: FutureResult
[10:19:59.249] result() for ClusterFuture ... done
[10:19:59.249] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:59.249] Future #2
[10:19:59.249] result() for ClusterFuture ...
[10:19:59.249] - result already collected: FutureResult
[10:19:59.249] result() for ClusterFuture ... done
[10:19:59.250] result() for ClusterFuture ...
[10:19:59.250] - result already collected: FutureResult
[10:19:59.250] result() for ClusterFuture ... done
[10:19:59.250] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:59.250] - nx: 2
[10:19:59.250] - relay: TRUE
[10:19:59.250] - stdout: TRUE
[10:19:59.250] - signal: TRUE
[10:19:59.250] - resignal: FALSE
[10:19:59.250] - force: TRUE
[10:19:59.250] - relayed: [n=2] TRUE, FALSE
[10:19:59.250] - queued futures: [n=2] TRUE, FALSE
[10:19:59.250]  - until=2
[10:19:59.251]  - relaying element #2
[10:19:59.251] result() for ClusterFuture ...
[10:19:59.251] - result already collected: FutureResult
[10:19:59.251] result() for ClusterFuture ... done
[10:19:59.251] result() for ClusterFuture ...
[10:19:59.251] - result already collected: FutureResult
[10:19:59.251] result() for ClusterFuture ... done
[10:19:59.251] result() for ClusterFuture ...
[10:19:59.251] - result already collected: FutureResult
[10:19:59.251] result() for ClusterFuture ... done
[10:19:59.251] result() for ClusterFuture ...
[10:19:59.251] - result already collected: FutureResult
[10:19:59.251] result() for ClusterFuture ... done
[10:19:59.252] - relayed: [n=2] TRUE, TRUE
[10:19:59.252] - queued futures: [n=2] TRUE, TRUE
[10:19:59.252] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:59.252]  length: 0 (resolved future 2)
[10:19:59.252] Relaying remaining futures
[10:19:59.252] signalConditionsASAP(NULL, pos=0) ...
[10:19:59.252] - nx: 2
[10:19:59.252] - relay: TRUE
[10:19:59.252] - stdout: TRUE
[10:19:59.252] - signal: TRUE
[10:19:59.252] - resignal: FALSE
[10:19:59.252] - force: TRUE
[10:19:59.252] - relayed: [n=2] TRUE, TRUE
[10:19:59.253] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:59.253] - relayed: [n=2] TRUE, TRUE
[10:19:59.253] - queued futures: [n=2] TRUE, TRUE
[10:19:59.253] signalConditionsASAP(NULL, pos=0) ... done
[10:19:59.253] resolve() on list ... DONE
[10:19:59.253] result() for ClusterFuture ...
[10:19:59.253] - result already collected: FutureResult
[10:19:59.253] result() for ClusterFuture ... done
[10:19:59.253] result() for ClusterFuture ...
[10:19:59.253] - result already collected: FutureResult
[10:19:59.253] result() for ClusterFuture ... done
[10:19:59.254] result() for ClusterFuture ...
[10:19:59.254] - result already collected: FutureResult
[10:19:59.254] result() for ClusterFuture ... done
[10:19:59.254] result() for ClusterFuture ...
[10:19:59.254] - result already collected: FutureResult
[10:19:59.254] result() for ClusterFuture ... done
[10:19:59.254]  - Number of value chunks collected: 2
[10:19:59.254] Resolving 2 futures (chunks) ... DONE
[10:19:59.254] Reducing values from 2 chunks ...
[10:19:59.254]  - Number of values collected after concatenation: 4
[10:19:59.254]  - Number of values expected: 4
[10:19:59.254] Reducing values from 2 chunks ... DONE
[10:19:59.254] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:19:59.256] future_lapply() ...
[10:19:59.259] Number of chunks: 2
[10:19:59.260] getGlobalsAndPackagesXApply() ...
[10:19:59.260]  - future.globals: TRUE
[10:19:59.260] getGlobalsAndPackages() ...
[10:19:59.260] Searching for globals...
[10:19:59.263] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:59.263] Searching for globals ... DONE
[10:19:59.263] Resolving globals: FALSE
[10:19:59.264] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[10:19:59.264] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:59.264] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:59.264] - packages: [1] ‘future.apply’
[10:19:59.265] getGlobalsAndPackages() ... DONE
[10:19:59.265]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:59.265]  - needed namespaces: [n=1] ‘future.apply’
[10:19:59.265] Finding globals ... DONE
[10:19:59.265]  - use_args: TRUE
[10:19:59.265]  - Getting '...' globals ...
[10:19:59.267] resolve() on list ...
[10:19:59.268]  recursive: 0
[10:19:59.268]  length: 1
[10:19:59.268]  elements: ‘...’
[10:19:59.268]  length: 0 (resolved future 1)
[10:19:59.268] resolve() on list ... DONE
[10:19:59.268]    - '...' content: [n=0] 
[10:19:59.268] List of 1
[10:19:59.268]  $ ...: list()
[10:19:59.268]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:59.268]  - attr(*, "where")=List of 1
[10:19:59.268]   ..$ ...:<environment: 0x55c69fd47aa0> 
[10:19:59.268]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:59.268]  - attr(*, "resolved")= logi TRUE
[10:19:59.268]  - attr(*, "total_size")= num NA
[10:19:59.270]  - Getting '...' globals ... DONE
[10:19:59.271] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:59.271] List of 8
[10:19:59.271]  $ ...future.FUN:function (x, ...)  
[10:19:59.271]  $ x_FUN        :function (x)  
[10:19:59.271]  $ times        : int 1
[10:19:59.271]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:59.271]  $ stop_if_not  :function (...)  
[10:19:59.271]  $ dim          : NULL
[10:19:59.271]  $ valid_types  : chr "logical"
[10:19:59.271]  $ ...          : list()
[10:19:59.271]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:59.271]  - attr(*, "where")=List of 8
[10:19:59.271]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:59.271]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:59.271]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:59.271]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:59.271]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:59.271]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:59.271]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:59.271]   ..$ ...          :<environment: 0x55c69fd47aa0> 
[10:19:59.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:59.271]  - attr(*, "resolved")= logi FALSE
[10:19:59.271]  - attr(*, "total_size")= num 30734
[10:19:59.276] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:59.276] getGlobalsAndPackagesXApply() ... DONE
[10:19:59.276] Number of futures (= number of chunks): 2
[10:19:59.276] Launching 2 futures (chunks) ...
[10:19:59.276] Chunk #1 of 2 ...
[10:19:59.276]  - Finding globals in 'X' for chunk #1 ...
[10:19:59.276] getGlobalsAndPackages() ...
[10:19:59.276] Searching for globals...
[10:19:59.277] 
[10:19:59.277] Searching for globals ... DONE
[10:19:59.277] - globals: [0] <none>
[10:19:59.277] getGlobalsAndPackages() ... DONE
[10:19:59.277]    + additional globals found: [n=0] 
[10:19:59.277]    + additional namespaces needed: [n=0] 
[10:19:59.277]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:59.277]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:59.277]  - seeds: <none>
[10:19:59.277]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.277] getGlobalsAndPackages() ...
[10:19:59.278] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.278] Resolving globals: FALSE
[10:19:59.278] Tweak future expression to call with '...' arguments ...
[10:19:59.278] {
[10:19:59.278]     do.call(function(...) {
[10:19:59.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.278]             on.exit(options(oopts), add = TRUE)
[10:19:59.278]         }
[10:19:59.278]         {
[10:19:59.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.278]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.278]             })
[10:19:59.278]         }
[10:19:59.278]     }, args = future.call.arguments)
[10:19:59.278] }
[10:19:59.278] Tweak future expression to call with '...' arguments ... DONE
[10:19:59.279] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.279] - packages: [1] ‘future.apply’
[10:19:59.279] getGlobalsAndPackages() ... DONE
[10:19:59.279] run() for ‘Future’ ...
[10:19:59.279] - state: ‘created’
[10:19:59.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:59.293] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:59.293]   - Field: ‘node’
[10:19:59.293]   - Field: ‘label’
[10:19:59.293]   - Field: ‘local’
[10:19:59.293]   - Field: ‘owner’
[10:19:59.293]   - Field: ‘envir’
[10:19:59.293]   - Field: ‘workers’
[10:19:59.294]   - Field: ‘packages’
[10:19:59.294]   - Field: ‘gc’
[10:19:59.294]   - Field: ‘conditions’
[10:19:59.294]   - Field: ‘persistent’
[10:19:59.294]   - Field: ‘expr’
[10:19:59.294]   - Field: ‘uuid’
[10:19:59.294]   - Field: ‘seed’
[10:19:59.294]   - Field: ‘version’
[10:19:59.294]   - Field: ‘result’
[10:19:59.294]   - Field: ‘asynchronous’
[10:19:59.294]   - Field: ‘calls’
[10:19:59.295]   - Field: ‘globals’
[10:19:59.295]   - Field: ‘stdout’
[10:19:59.295]   - Field: ‘earlySignal’
[10:19:59.295]   - Field: ‘lazy’
[10:19:59.295]   - Field: ‘state’
[10:19:59.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:59.295] - Launch lazy future ...
[10:19:59.295] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:59.295] Packages needed by future strategies (n = 0): <none>
[10:19:59.296] {
[10:19:59.296]     {
[10:19:59.296]         {
[10:19:59.296]             ...future.startTime <- base::Sys.time()
[10:19:59.296]             {
[10:19:59.296]                 {
[10:19:59.296]                   {
[10:19:59.296]                     {
[10:19:59.296]                       {
[10:19:59.296]                         base::local({
[10:19:59.296]                           has_future <- base::requireNamespace("future", 
[10:19:59.296]                             quietly = TRUE)
[10:19:59.296]                           if (has_future) {
[10:19:59.296]                             ns <- base::getNamespace("future")
[10:19:59.296]                             version <- ns[[".package"]][["version"]]
[10:19:59.296]                             if (is.null(version)) 
[10:19:59.296]                               version <- utils::packageVersion("future")
[10:19:59.296]                           }
[10:19:59.296]                           else {
[10:19:59.296]                             version <- NULL
[10:19:59.296]                           }
[10:19:59.296]                           if (!has_future || version < "1.8.0") {
[10:19:59.296]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:59.296]                               "", base::R.version$version.string), 
[10:19:59.296]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:59.296]                                 base::R.version$platform, 8 * 
[10:19:59.296]                                   base::.Machine$sizeof.pointer), 
[10:19:59.296]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:59.296]                                 "release", "version")], collapse = " "), 
[10:19:59.296]                               hostname = base::Sys.info()[["nodename"]])
[10:19:59.296]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:59.296]                               info)
[10:19:59.296]                             info <- base::paste(info, collapse = "; ")
[10:19:59.296]                             if (!has_future) {
[10:19:59.296]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:59.296]                                 info)
[10:19:59.296]                             }
[10:19:59.296]                             else {
[10:19:59.296]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:59.296]                                 info, version)
[10:19:59.296]                             }
[10:19:59.296]                             base::stop(msg)
[10:19:59.296]                           }
[10:19:59.296]                         })
[10:19:59.296]                       }
[10:19:59.296]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:59.296]                       base::options(mc.cores = 1L)
[10:19:59.296]                     }
[10:19:59.296]                     base::local({
[10:19:59.296]                       for (pkg in "future.apply") {
[10:19:59.296]                         base::loadNamespace(pkg)
[10:19:59.296]                         base::library(pkg, character.only = TRUE)
[10:19:59.296]                       }
[10:19:59.296]                     })
[10:19:59.296]                   }
[10:19:59.296]                   ...future.strategy.old <- future::plan("list")
[10:19:59.296]                   options(future.plan = NULL)
[10:19:59.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:59.296]                 }
[10:19:59.296]                 ...future.workdir <- getwd()
[10:19:59.296]             }
[10:19:59.296]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:59.296]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:59.296]         }
[10:19:59.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:59.296]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:59.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:59.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:59.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:59.296]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:59.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:59.296]             base::names(...future.oldOptions))
[10:19:59.296]     }
[10:19:59.296]     if (FALSE) {
[10:19:59.296]     }
[10:19:59.296]     else {
[10:19:59.296]         if (TRUE) {
[10:19:59.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:59.296]                 open = "w")
[10:19:59.296]         }
[10:19:59.296]         else {
[10:19:59.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:59.296]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:59.296]         }
[10:19:59.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:59.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:59.296]             base::sink(type = "output", split = FALSE)
[10:19:59.296]             base::close(...future.stdout)
[10:19:59.296]         }, add = TRUE)
[10:19:59.296]     }
[10:19:59.296]     ...future.frame <- base::sys.nframe()
[10:19:59.296]     ...future.conditions <- base::list()
[10:19:59.296]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:59.296]     if (FALSE) {
[10:19:59.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:59.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:59.296]     }
[10:19:59.296]     ...future.result <- base::tryCatch({
[10:19:59.296]         base::withCallingHandlers({
[10:19:59.296]             ...future.value <- base::withVisible(base::local({
[10:19:59.296]                 ...future.makeSendCondition <- base::local({
[10:19:59.296]                   sendCondition <- NULL
[10:19:59.296]                   function(frame = 1L) {
[10:19:59.296]                     if (is.function(sendCondition)) 
[10:19:59.296]                       return(sendCondition)
[10:19:59.296]                     ns <- getNamespace("parallel")
[10:19:59.296]                     if (exists("sendData", mode = "function", 
[10:19:59.296]                       envir = ns)) {
[10:19:59.296]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:59.296]                         envir = ns)
[10:19:59.296]                       envir <- sys.frame(frame)
[10:19:59.296]                       master <- NULL
[10:19:59.296]                       while (!identical(envir, .GlobalEnv) && 
[10:19:59.296]                         !identical(envir, emptyenv())) {
[10:19:59.296]                         if (exists("master", mode = "list", envir = envir, 
[10:19:59.296]                           inherits = FALSE)) {
[10:19:59.296]                           master <- get("master", mode = "list", 
[10:19:59.296]                             envir = envir, inherits = FALSE)
[10:19:59.296]                           if (inherits(master, c("SOCKnode", 
[10:19:59.296]                             "SOCK0node"))) {
[10:19:59.296]                             sendCondition <<- function(cond) {
[10:19:59.296]                               data <- list(type = "VALUE", value = cond, 
[10:19:59.296]                                 success = TRUE)
[10:19:59.296]                               parallel_sendData(master, data)
[10:19:59.296]                             }
[10:19:59.296]                             return(sendCondition)
[10:19:59.296]                           }
[10:19:59.296]                         }
[10:19:59.296]                         frame <- frame + 1L
[10:19:59.296]                         envir <- sys.frame(frame)
[10:19:59.296]                       }
[10:19:59.296]                     }
[10:19:59.296]                     sendCondition <<- function(cond) NULL
[10:19:59.296]                   }
[10:19:59.296]                 })
[10:19:59.296]                 withCallingHandlers({
[10:19:59.296]                   {
[10:19:59.296]                     do.call(function(...) {
[10:19:59.296]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.296]                       if (!identical(...future.globals.maxSize.org, 
[10:19:59.296]                         ...future.globals.maxSize)) {
[10:19:59.296]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.296]                         on.exit(options(oopts), add = TRUE)
[10:19:59.296]                       }
[10:19:59.296]                       {
[10:19:59.296]                         lapply(seq_along(...future.elements_ii), 
[10:19:59.296]                           FUN = function(jj) {
[10:19:59.296]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.296]                             ...future.FUN(...future.X_jj, ...)
[10:19:59.296]                           })
[10:19:59.296]                       }
[10:19:59.296]                     }, args = future.call.arguments)
[10:19:59.296]                   }
[10:19:59.296]                 }, immediateCondition = function(cond) {
[10:19:59.296]                   sendCondition <- ...future.makeSendCondition()
[10:19:59.296]                   sendCondition(cond)
[10:19:59.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.296]                   {
[10:19:59.296]                     inherits <- base::inherits
[10:19:59.296]                     invokeRestart <- base::invokeRestart
[10:19:59.296]                     is.null <- base::is.null
[10:19:59.296]                     muffled <- FALSE
[10:19:59.296]                     if (inherits(cond, "message")) {
[10:19:59.296]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:59.296]                       if (muffled) 
[10:19:59.296]                         invokeRestart("muffleMessage")
[10:19:59.296]                     }
[10:19:59.296]                     else if (inherits(cond, "warning")) {
[10:19:59.296]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:59.296]                       if (muffled) 
[10:19:59.296]                         invokeRestart("muffleWarning")
[10:19:59.296]                     }
[10:19:59.296]                     else if (inherits(cond, "condition")) {
[10:19:59.296]                       if (!is.null(pattern)) {
[10:19:59.296]                         computeRestarts <- base::computeRestarts
[10:19:59.296]                         grepl <- base::grepl
[10:19:59.296]                         restarts <- computeRestarts(cond)
[10:19:59.296]                         for (restart in restarts) {
[10:19:59.296]                           name <- restart$name
[10:19:59.296]                           if (is.null(name)) 
[10:19:59.296]                             next
[10:19:59.296]                           if (!grepl(pattern, name)) 
[10:19:59.296]                             next
[10:19:59.296]                           invokeRestart(restart)
[10:19:59.296]                           muffled <- TRUE
[10:19:59.296]                           break
[10:19:59.296]                         }
[10:19:59.296]                       }
[10:19:59.296]                     }
[10:19:59.296]                     invisible(muffled)
[10:19:59.296]                   }
[10:19:59.296]                   muffleCondition(cond)
[10:19:59.296]                 })
[10:19:59.296]             }))
[10:19:59.296]             future::FutureResult(value = ...future.value$value, 
[10:19:59.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.296]                   ...future.rng), globalenv = if (FALSE) 
[10:19:59.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:59.296]                     ...future.globalenv.names))
[10:19:59.296]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:59.296]         }, condition = base::local({
[10:19:59.296]             c <- base::c
[10:19:59.296]             inherits <- base::inherits
[10:19:59.296]             invokeRestart <- base::invokeRestart
[10:19:59.296]             length <- base::length
[10:19:59.296]             list <- base::list
[10:19:59.296]             seq.int <- base::seq.int
[10:19:59.296]             signalCondition <- base::signalCondition
[10:19:59.296]             sys.calls <- base::sys.calls
[10:19:59.296]             `[[` <- base::`[[`
[10:19:59.296]             `+` <- base::`+`
[10:19:59.296]             `<<-` <- base::`<<-`
[10:19:59.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:59.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:59.296]                   3L)]
[10:19:59.296]             }
[10:19:59.296]             function(cond) {
[10:19:59.296]                 is_error <- inherits(cond, "error")
[10:19:59.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:59.296]                   NULL)
[10:19:59.296]                 if (is_error) {
[10:19:59.296]                   sessionInformation <- function() {
[10:19:59.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:59.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:59.296]                       search = base::search(), system = base::Sys.info())
[10:19:59.296]                   }
[10:19:59.296]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:59.296]                     cond$call), session = sessionInformation(), 
[10:19:59.296]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:59.296]                   signalCondition(cond)
[10:19:59.296]                 }
[10:19:59.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:59.296]                 "immediateCondition"))) {
[10:19:59.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:59.296]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:59.296]                   if (TRUE && !signal) {
[10:19:59.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.296]                     {
[10:19:59.296]                       inherits <- base::inherits
[10:19:59.296]                       invokeRestart <- base::invokeRestart
[10:19:59.296]                       is.null <- base::is.null
[10:19:59.296]                       muffled <- FALSE
[10:19:59.296]                       if (inherits(cond, "message")) {
[10:19:59.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.296]                         if (muffled) 
[10:19:59.296]                           invokeRestart("muffleMessage")
[10:19:59.296]                       }
[10:19:59.296]                       else if (inherits(cond, "warning")) {
[10:19:59.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.296]                         if (muffled) 
[10:19:59.296]                           invokeRestart("muffleWarning")
[10:19:59.296]                       }
[10:19:59.296]                       else if (inherits(cond, "condition")) {
[10:19:59.296]                         if (!is.null(pattern)) {
[10:19:59.296]                           computeRestarts <- base::computeRestarts
[10:19:59.296]                           grepl <- base::grepl
[10:19:59.296]                           restarts <- computeRestarts(cond)
[10:19:59.296]                           for (restart in restarts) {
[10:19:59.296]                             name <- restart$name
[10:19:59.296]                             if (is.null(name)) 
[10:19:59.296]                               next
[10:19:59.296]                             if (!grepl(pattern, name)) 
[10:19:59.296]                               next
[10:19:59.296]                             invokeRestart(restart)
[10:19:59.296]                             muffled <- TRUE
[10:19:59.296]                             break
[10:19:59.296]                           }
[10:19:59.296]                         }
[10:19:59.296]                       }
[10:19:59.296]                       invisible(muffled)
[10:19:59.296]                     }
[10:19:59.296]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.296]                   }
[10:19:59.296]                 }
[10:19:59.296]                 else {
[10:19:59.296]                   if (TRUE) {
[10:19:59.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.296]                     {
[10:19:59.296]                       inherits <- base::inherits
[10:19:59.296]                       invokeRestart <- base::invokeRestart
[10:19:59.296]                       is.null <- base::is.null
[10:19:59.296]                       muffled <- FALSE
[10:19:59.296]                       if (inherits(cond, "message")) {
[10:19:59.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.296]                         if (muffled) 
[10:19:59.296]                           invokeRestart("muffleMessage")
[10:19:59.296]                       }
[10:19:59.296]                       else if (inherits(cond, "warning")) {
[10:19:59.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.296]                         if (muffled) 
[10:19:59.296]                           invokeRestart("muffleWarning")
[10:19:59.296]                       }
[10:19:59.296]                       else if (inherits(cond, "condition")) {
[10:19:59.296]                         if (!is.null(pattern)) {
[10:19:59.296]                           computeRestarts <- base::computeRestarts
[10:19:59.296]                           grepl <- base::grepl
[10:19:59.296]                           restarts <- computeRestarts(cond)
[10:19:59.296]                           for (restart in restarts) {
[10:19:59.296]                             name <- restart$name
[10:19:59.296]                             if (is.null(name)) 
[10:19:59.296]                               next
[10:19:59.296]                             if (!grepl(pattern, name)) 
[10:19:59.296]                               next
[10:19:59.296]                             invokeRestart(restart)
[10:19:59.296]                             muffled <- TRUE
[10:19:59.296]                             break
[10:19:59.296]                           }
[10:19:59.296]                         }
[10:19:59.296]                       }
[10:19:59.296]                       invisible(muffled)
[10:19:59.296]                     }
[10:19:59.296]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.296]                   }
[10:19:59.296]                 }
[10:19:59.296]             }
[10:19:59.296]         }))
[10:19:59.296]     }, error = function(ex) {
[10:19:59.296]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:59.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.296]                 ...future.rng), started = ...future.startTime, 
[10:19:59.296]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:59.296]             version = "1.8"), class = "FutureResult")
[10:19:59.296]     }, finally = {
[10:19:59.296]         if (!identical(...future.workdir, getwd())) 
[10:19:59.296]             setwd(...future.workdir)
[10:19:59.296]         {
[10:19:59.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:59.296]                 ...future.oldOptions$nwarnings <- NULL
[10:19:59.296]             }
[10:19:59.296]             base::options(...future.oldOptions)
[10:19:59.296]             if (.Platform$OS.type == "windows") {
[10:19:59.296]                 old_names <- names(...future.oldEnvVars)
[10:19:59.296]                 envs <- base::Sys.getenv()
[10:19:59.296]                 names <- names(envs)
[10:19:59.296]                 common <- intersect(names, old_names)
[10:19:59.296]                 added <- setdiff(names, old_names)
[10:19:59.296]                 removed <- setdiff(old_names, names)
[10:19:59.296]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:59.296]                   envs[common]]
[10:19:59.296]                 NAMES <- toupper(changed)
[10:19:59.296]                 args <- list()
[10:19:59.296]                 for (kk in seq_along(NAMES)) {
[10:19:59.296]                   name <- changed[[kk]]
[10:19:59.296]                   NAME <- NAMES[[kk]]
[10:19:59.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.296]                     next
[10:19:59.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.296]                 }
[10:19:59.296]                 NAMES <- toupper(added)
[10:19:59.296]                 for (kk in seq_along(NAMES)) {
[10:19:59.296]                   name <- added[[kk]]
[10:19:59.296]                   NAME <- NAMES[[kk]]
[10:19:59.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.296]                     next
[10:19:59.296]                   args[[name]] <- ""
[10:19:59.296]                 }
[10:19:59.296]                 NAMES <- toupper(removed)
[10:19:59.296]                 for (kk in seq_along(NAMES)) {
[10:19:59.296]                   name <- removed[[kk]]
[10:19:59.296]                   NAME <- NAMES[[kk]]
[10:19:59.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.296]                     next
[10:19:59.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.296]                 }
[10:19:59.296]                 if (length(args) > 0) 
[10:19:59.296]                   base::do.call(base::Sys.setenv, args = args)
[10:19:59.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:59.296]             }
[10:19:59.296]             else {
[10:19:59.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:59.296]             }
[10:19:59.296]             {
[10:19:59.296]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:59.296]                   0L) {
[10:19:59.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:59.296]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:59.296]                   base::options(opts)
[10:19:59.296]                 }
[10:19:59.296]                 {
[10:19:59.296]                   {
[10:19:59.296]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:59.296]                     NULL
[10:19:59.296]                   }
[10:19:59.296]                   options(future.plan = NULL)
[10:19:59.296]                   if (is.na(NA_character_)) 
[10:19:59.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:59.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:59.296]                     .init = FALSE)
[10:19:59.296]                 }
[10:19:59.296]             }
[10:19:59.296]         }
[10:19:59.296]     })
[10:19:59.296]     if (TRUE) {
[10:19:59.296]         base::sink(type = "output", split = FALSE)
[10:19:59.296]         if (TRUE) {
[10:19:59.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:59.296]         }
[10:19:59.296]         else {
[10:19:59.296]             ...future.result["stdout"] <- base::list(NULL)
[10:19:59.296]         }
[10:19:59.296]         base::close(...future.stdout)
[10:19:59.296]         ...future.stdout <- NULL
[10:19:59.296]     }
[10:19:59.296]     ...future.result$conditions <- ...future.conditions
[10:19:59.296]     ...future.result$finished <- base::Sys.time()
[10:19:59.296]     ...future.result
[10:19:59.296] }
[10:19:59.299] Exporting 11 global objects (16.77 KiB) to cluster node #1 ...
[10:19:59.299] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #1 ...
[10:19:59.339] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #1 ... DONE
[10:19:59.340] Exporting ‘x_FUN’ (41 bytes) to cluster node #1 ...
[10:19:59.340] Exporting ‘x_FUN’ (41 bytes) to cluster node #1 ... DONE
[10:19:59.340] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:59.340] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:59.341] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:59.381] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:59.382] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:59.422] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:59.422] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:59.423] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.423] Exporting ‘valid_types’ (46 bytes) to cluster node #1 ...
[10:19:59.423] Exporting ‘valid_types’ (46 bytes) to cluster node #1 ... DONE
[10:19:59.423] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:59.424] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:59.424] Exporting ‘...future.elements_ii’ (1.67 KiB) to cluster node #1 ...
[10:19:59.424] Exporting ‘...future.elements_ii’ (1.67 KiB) to cluster node #1 ... DONE
[10:19:59.424] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:59.425] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.425] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:59.425] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.425] Exporting 11 global objects (16.77 KiB) to cluster node #1 ... DONE
[10:19:59.426] MultisessionFuture started
[10:19:59.426] - Launch lazy future ... done
[10:19:59.426] run() for ‘MultisessionFuture’ ... done
[10:19:59.426] Created future:
[10:19:59.426] MultisessionFuture:
[10:19:59.426] Label: ‘future_vapply-1’
[10:19:59.426] Expression:
[10:19:59.426] {
[10:19:59.426]     do.call(function(...) {
[10:19:59.426]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.426]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.426]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.426]             on.exit(options(oopts), add = TRUE)
[10:19:59.426]         }
[10:19:59.426]         {
[10:19:59.426]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.426]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.426]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.426]             })
[10:19:59.426]         }
[10:19:59.426]     }, args = future.call.arguments)
[10:19:59.426] }
[10:19:59.426] Lazy evaluation: FALSE
[10:19:59.426] Asynchronous evaluation: TRUE
[10:19:59.426] Local evaluation: TRUE
[10:19:59.426] Environment: R_GlobalEnv
[10:19:59.426] Capture standard output: TRUE
[10:19:59.426] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:59.426] Globals: 11 objects totaling 16.54 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:59.426] Packages: 1 packages (‘future.apply’)
[10:19:59.426] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:59.426] Resolved: FALSE
[10:19:59.426] Value: <not collected>
[10:19:59.426] Conditions captured: <none>
[10:19:59.426] Early signaling: FALSE
[10:19:59.426] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:59.426] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.438] Chunk #1 of 2 ... DONE
[10:19:59.438] Chunk #2 of 2 ...
[10:19:59.438]  - Finding globals in 'X' for chunk #2 ...
[10:19:59.438] getGlobalsAndPackages() ...
[10:19:59.438] Searching for globals...
[10:19:59.438] 
[10:19:59.439] Searching for globals ... DONE
[10:19:59.439] - globals: [0] <none>
[10:19:59.439] getGlobalsAndPackages() ... DONE
[10:19:59.439]    + additional globals found: [n=0] 
[10:19:59.439]    + additional namespaces needed: [n=0] 
[10:19:59.439]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:59.439]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:59.439]  - seeds: <none>
[10:19:59.439]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.439] getGlobalsAndPackages() ...
[10:19:59.439] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.439] Resolving globals: FALSE
[10:19:59.440] Tweak future expression to call with '...' arguments ...
[10:19:59.440] {
[10:19:59.440]     do.call(function(...) {
[10:19:59.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.440]             on.exit(options(oopts), add = TRUE)
[10:19:59.440]         }
[10:19:59.440]         {
[10:19:59.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.440]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.440]             })
[10:19:59.440]         }
[10:19:59.440]     }, args = future.call.arguments)
[10:19:59.440] }
[10:19:59.440] Tweak future expression to call with '...' arguments ... DONE
[10:19:59.440] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.441] - packages: [1] ‘future.apply’
[10:19:59.441] getGlobalsAndPackages() ... DONE
[10:19:59.441] run() for ‘Future’ ...
[10:19:59.441] - state: ‘created’
[10:19:59.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:59.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:59.455]   - Field: ‘node’
[10:19:59.455]   - Field: ‘label’
[10:19:59.455]   - Field: ‘local’
[10:19:59.455]   - Field: ‘owner’
[10:19:59.455]   - Field: ‘envir’
[10:19:59.455]   - Field: ‘workers’
[10:19:59.456]   - Field: ‘packages’
[10:19:59.456]   - Field: ‘gc’
[10:19:59.456]   - Field: ‘conditions’
[10:19:59.456]   - Field: ‘persistent’
[10:19:59.456]   - Field: ‘expr’
[10:19:59.456]   - Field: ‘uuid’
[10:19:59.456]   - Field: ‘seed’
[10:19:59.456]   - Field: ‘version’
[10:19:59.456]   - Field: ‘result’
[10:19:59.456]   - Field: ‘asynchronous’
[10:19:59.456]   - Field: ‘calls’
[10:19:59.456]   - Field: ‘globals’
[10:19:59.457]   - Field: ‘stdout’
[10:19:59.457]   - Field: ‘earlySignal’
[10:19:59.457]   - Field: ‘lazy’
[10:19:59.457]   - Field: ‘state’
[10:19:59.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:59.457] - Launch lazy future ...
[10:19:59.457] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:59.457] Packages needed by future strategies (n = 0): <none>
[10:19:59.458] {
[10:19:59.458]     {
[10:19:59.458]         {
[10:19:59.458]             ...future.startTime <- base::Sys.time()
[10:19:59.458]             {
[10:19:59.458]                 {
[10:19:59.458]                   {
[10:19:59.458]                     {
[10:19:59.458]                       {
[10:19:59.458]                         base::local({
[10:19:59.458]                           has_future <- base::requireNamespace("future", 
[10:19:59.458]                             quietly = TRUE)
[10:19:59.458]                           if (has_future) {
[10:19:59.458]                             ns <- base::getNamespace("future")
[10:19:59.458]                             version <- ns[[".package"]][["version"]]
[10:19:59.458]                             if (is.null(version)) 
[10:19:59.458]                               version <- utils::packageVersion("future")
[10:19:59.458]                           }
[10:19:59.458]                           else {
[10:19:59.458]                             version <- NULL
[10:19:59.458]                           }
[10:19:59.458]                           if (!has_future || version < "1.8.0") {
[10:19:59.458]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:59.458]                               "", base::R.version$version.string), 
[10:19:59.458]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:59.458]                                 base::R.version$platform, 8 * 
[10:19:59.458]                                   base::.Machine$sizeof.pointer), 
[10:19:59.458]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:59.458]                                 "release", "version")], collapse = " "), 
[10:19:59.458]                               hostname = base::Sys.info()[["nodename"]])
[10:19:59.458]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:59.458]                               info)
[10:19:59.458]                             info <- base::paste(info, collapse = "; ")
[10:19:59.458]                             if (!has_future) {
[10:19:59.458]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:59.458]                                 info)
[10:19:59.458]                             }
[10:19:59.458]                             else {
[10:19:59.458]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:59.458]                                 info, version)
[10:19:59.458]                             }
[10:19:59.458]                             base::stop(msg)
[10:19:59.458]                           }
[10:19:59.458]                         })
[10:19:59.458]                       }
[10:19:59.458]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:59.458]                       base::options(mc.cores = 1L)
[10:19:59.458]                     }
[10:19:59.458]                     base::local({
[10:19:59.458]                       for (pkg in "future.apply") {
[10:19:59.458]                         base::loadNamespace(pkg)
[10:19:59.458]                         base::library(pkg, character.only = TRUE)
[10:19:59.458]                       }
[10:19:59.458]                     })
[10:19:59.458]                   }
[10:19:59.458]                   ...future.strategy.old <- future::plan("list")
[10:19:59.458]                   options(future.plan = NULL)
[10:19:59.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:59.458]                 }
[10:19:59.458]                 ...future.workdir <- getwd()
[10:19:59.458]             }
[10:19:59.458]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:59.458]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:59.458]         }
[10:19:59.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:59.458]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:59.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:59.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:59.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:59.458]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:59.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:59.458]             base::names(...future.oldOptions))
[10:19:59.458]     }
[10:19:59.458]     if (FALSE) {
[10:19:59.458]     }
[10:19:59.458]     else {
[10:19:59.458]         if (TRUE) {
[10:19:59.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:59.458]                 open = "w")
[10:19:59.458]         }
[10:19:59.458]         else {
[10:19:59.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:59.458]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:59.458]         }
[10:19:59.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:59.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:59.458]             base::sink(type = "output", split = FALSE)
[10:19:59.458]             base::close(...future.stdout)
[10:19:59.458]         }, add = TRUE)
[10:19:59.458]     }
[10:19:59.458]     ...future.frame <- base::sys.nframe()
[10:19:59.458]     ...future.conditions <- base::list()
[10:19:59.458]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:59.458]     if (FALSE) {
[10:19:59.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:59.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:59.458]     }
[10:19:59.458]     ...future.result <- base::tryCatch({
[10:19:59.458]         base::withCallingHandlers({
[10:19:59.458]             ...future.value <- base::withVisible(base::local({
[10:19:59.458]                 ...future.makeSendCondition <- base::local({
[10:19:59.458]                   sendCondition <- NULL
[10:19:59.458]                   function(frame = 1L) {
[10:19:59.458]                     if (is.function(sendCondition)) 
[10:19:59.458]                       return(sendCondition)
[10:19:59.458]                     ns <- getNamespace("parallel")
[10:19:59.458]                     if (exists("sendData", mode = "function", 
[10:19:59.458]                       envir = ns)) {
[10:19:59.458]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:59.458]                         envir = ns)
[10:19:59.458]                       envir <- sys.frame(frame)
[10:19:59.458]                       master <- NULL
[10:19:59.458]                       while (!identical(envir, .GlobalEnv) && 
[10:19:59.458]                         !identical(envir, emptyenv())) {
[10:19:59.458]                         if (exists("master", mode = "list", envir = envir, 
[10:19:59.458]                           inherits = FALSE)) {
[10:19:59.458]                           master <- get("master", mode = "list", 
[10:19:59.458]                             envir = envir, inherits = FALSE)
[10:19:59.458]                           if (inherits(master, c("SOCKnode", 
[10:19:59.458]                             "SOCK0node"))) {
[10:19:59.458]                             sendCondition <<- function(cond) {
[10:19:59.458]                               data <- list(type = "VALUE", value = cond, 
[10:19:59.458]                                 success = TRUE)
[10:19:59.458]                               parallel_sendData(master, data)
[10:19:59.458]                             }
[10:19:59.458]                             return(sendCondition)
[10:19:59.458]                           }
[10:19:59.458]                         }
[10:19:59.458]                         frame <- frame + 1L
[10:19:59.458]                         envir <- sys.frame(frame)
[10:19:59.458]                       }
[10:19:59.458]                     }
[10:19:59.458]                     sendCondition <<- function(cond) NULL
[10:19:59.458]                   }
[10:19:59.458]                 })
[10:19:59.458]                 withCallingHandlers({
[10:19:59.458]                   {
[10:19:59.458]                     do.call(function(...) {
[10:19:59.458]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.458]                       if (!identical(...future.globals.maxSize.org, 
[10:19:59.458]                         ...future.globals.maxSize)) {
[10:19:59.458]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.458]                         on.exit(options(oopts), add = TRUE)
[10:19:59.458]                       }
[10:19:59.458]                       {
[10:19:59.458]                         lapply(seq_along(...future.elements_ii), 
[10:19:59.458]                           FUN = function(jj) {
[10:19:59.458]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.458]                             ...future.FUN(...future.X_jj, ...)
[10:19:59.458]                           })
[10:19:59.458]                       }
[10:19:59.458]                     }, args = future.call.arguments)
[10:19:59.458]                   }
[10:19:59.458]                 }, immediateCondition = function(cond) {
[10:19:59.458]                   sendCondition <- ...future.makeSendCondition()
[10:19:59.458]                   sendCondition(cond)
[10:19:59.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.458]                   {
[10:19:59.458]                     inherits <- base::inherits
[10:19:59.458]                     invokeRestart <- base::invokeRestart
[10:19:59.458]                     is.null <- base::is.null
[10:19:59.458]                     muffled <- FALSE
[10:19:59.458]                     if (inherits(cond, "message")) {
[10:19:59.458]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:59.458]                       if (muffled) 
[10:19:59.458]                         invokeRestart("muffleMessage")
[10:19:59.458]                     }
[10:19:59.458]                     else if (inherits(cond, "warning")) {
[10:19:59.458]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:59.458]                       if (muffled) 
[10:19:59.458]                         invokeRestart("muffleWarning")
[10:19:59.458]                     }
[10:19:59.458]                     else if (inherits(cond, "condition")) {
[10:19:59.458]                       if (!is.null(pattern)) {
[10:19:59.458]                         computeRestarts <- base::computeRestarts
[10:19:59.458]                         grepl <- base::grepl
[10:19:59.458]                         restarts <- computeRestarts(cond)
[10:19:59.458]                         for (restart in restarts) {
[10:19:59.458]                           name <- restart$name
[10:19:59.458]                           if (is.null(name)) 
[10:19:59.458]                             next
[10:19:59.458]                           if (!grepl(pattern, name)) 
[10:19:59.458]                             next
[10:19:59.458]                           invokeRestart(restart)
[10:19:59.458]                           muffled <- TRUE
[10:19:59.458]                           break
[10:19:59.458]                         }
[10:19:59.458]                       }
[10:19:59.458]                     }
[10:19:59.458]                     invisible(muffled)
[10:19:59.458]                   }
[10:19:59.458]                   muffleCondition(cond)
[10:19:59.458]                 })
[10:19:59.458]             }))
[10:19:59.458]             future::FutureResult(value = ...future.value$value, 
[10:19:59.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.458]                   ...future.rng), globalenv = if (FALSE) 
[10:19:59.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:59.458]                     ...future.globalenv.names))
[10:19:59.458]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:59.458]         }, condition = base::local({
[10:19:59.458]             c <- base::c
[10:19:59.458]             inherits <- base::inherits
[10:19:59.458]             invokeRestart <- base::invokeRestart
[10:19:59.458]             length <- base::length
[10:19:59.458]             list <- base::list
[10:19:59.458]             seq.int <- base::seq.int
[10:19:59.458]             signalCondition <- base::signalCondition
[10:19:59.458]             sys.calls <- base::sys.calls
[10:19:59.458]             `[[` <- base::`[[`
[10:19:59.458]             `+` <- base::`+`
[10:19:59.458]             `<<-` <- base::`<<-`
[10:19:59.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:59.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:59.458]                   3L)]
[10:19:59.458]             }
[10:19:59.458]             function(cond) {
[10:19:59.458]                 is_error <- inherits(cond, "error")
[10:19:59.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:59.458]                   NULL)
[10:19:59.458]                 if (is_error) {
[10:19:59.458]                   sessionInformation <- function() {
[10:19:59.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:59.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:59.458]                       search = base::search(), system = base::Sys.info())
[10:19:59.458]                   }
[10:19:59.458]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:59.458]                     cond$call), session = sessionInformation(), 
[10:19:59.458]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:59.458]                   signalCondition(cond)
[10:19:59.458]                 }
[10:19:59.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:59.458]                 "immediateCondition"))) {
[10:19:59.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:59.458]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:59.458]                   if (TRUE && !signal) {
[10:19:59.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.458]                     {
[10:19:59.458]                       inherits <- base::inherits
[10:19:59.458]                       invokeRestart <- base::invokeRestart
[10:19:59.458]                       is.null <- base::is.null
[10:19:59.458]                       muffled <- FALSE
[10:19:59.458]                       if (inherits(cond, "message")) {
[10:19:59.458]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.458]                         if (muffled) 
[10:19:59.458]                           invokeRestart("muffleMessage")
[10:19:59.458]                       }
[10:19:59.458]                       else if (inherits(cond, "warning")) {
[10:19:59.458]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.458]                         if (muffled) 
[10:19:59.458]                           invokeRestart("muffleWarning")
[10:19:59.458]                       }
[10:19:59.458]                       else if (inherits(cond, "condition")) {
[10:19:59.458]                         if (!is.null(pattern)) {
[10:19:59.458]                           computeRestarts <- base::computeRestarts
[10:19:59.458]                           grepl <- base::grepl
[10:19:59.458]                           restarts <- computeRestarts(cond)
[10:19:59.458]                           for (restart in restarts) {
[10:19:59.458]                             name <- restart$name
[10:19:59.458]                             if (is.null(name)) 
[10:19:59.458]                               next
[10:19:59.458]                             if (!grepl(pattern, name)) 
[10:19:59.458]                               next
[10:19:59.458]                             invokeRestart(restart)
[10:19:59.458]                             muffled <- TRUE
[10:19:59.458]                             break
[10:19:59.458]                           }
[10:19:59.458]                         }
[10:19:59.458]                       }
[10:19:59.458]                       invisible(muffled)
[10:19:59.458]                     }
[10:19:59.458]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.458]                   }
[10:19:59.458]                 }
[10:19:59.458]                 else {
[10:19:59.458]                   if (TRUE) {
[10:19:59.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.458]                     {
[10:19:59.458]                       inherits <- base::inherits
[10:19:59.458]                       invokeRestart <- base::invokeRestart
[10:19:59.458]                       is.null <- base::is.null
[10:19:59.458]                       muffled <- FALSE
[10:19:59.458]                       if (inherits(cond, "message")) {
[10:19:59.458]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.458]                         if (muffled) 
[10:19:59.458]                           invokeRestart("muffleMessage")
[10:19:59.458]                       }
[10:19:59.458]                       else if (inherits(cond, "warning")) {
[10:19:59.458]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.458]                         if (muffled) 
[10:19:59.458]                           invokeRestart("muffleWarning")
[10:19:59.458]                       }
[10:19:59.458]                       else if (inherits(cond, "condition")) {
[10:19:59.458]                         if (!is.null(pattern)) {
[10:19:59.458]                           computeRestarts <- base::computeRestarts
[10:19:59.458]                           grepl <- base::grepl
[10:19:59.458]                           restarts <- computeRestarts(cond)
[10:19:59.458]                           for (restart in restarts) {
[10:19:59.458]                             name <- restart$name
[10:19:59.458]                             if (is.null(name)) 
[10:19:59.458]                               next
[10:19:59.458]                             if (!grepl(pattern, name)) 
[10:19:59.458]                               next
[10:19:59.458]                             invokeRestart(restart)
[10:19:59.458]                             muffled <- TRUE
[10:19:59.458]                             break
[10:19:59.458]                           }
[10:19:59.458]                         }
[10:19:59.458]                       }
[10:19:59.458]                       invisible(muffled)
[10:19:59.458]                     }
[10:19:59.458]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.458]                   }
[10:19:59.458]                 }
[10:19:59.458]             }
[10:19:59.458]         }))
[10:19:59.458]     }, error = function(ex) {
[10:19:59.458]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:59.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.458]                 ...future.rng), started = ...future.startTime, 
[10:19:59.458]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:59.458]             version = "1.8"), class = "FutureResult")
[10:19:59.458]     }, finally = {
[10:19:59.458]         if (!identical(...future.workdir, getwd())) 
[10:19:59.458]             setwd(...future.workdir)
[10:19:59.458]         {
[10:19:59.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:59.458]                 ...future.oldOptions$nwarnings <- NULL
[10:19:59.458]             }
[10:19:59.458]             base::options(...future.oldOptions)
[10:19:59.458]             if (.Platform$OS.type == "windows") {
[10:19:59.458]                 old_names <- names(...future.oldEnvVars)
[10:19:59.458]                 envs <- base::Sys.getenv()
[10:19:59.458]                 names <- names(envs)
[10:19:59.458]                 common <- intersect(names, old_names)
[10:19:59.458]                 added <- setdiff(names, old_names)
[10:19:59.458]                 removed <- setdiff(old_names, names)
[10:19:59.458]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:59.458]                   envs[common]]
[10:19:59.458]                 NAMES <- toupper(changed)
[10:19:59.458]                 args <- list()
[10:19:59.458]                 for (kk in seq_along(NAMES)) {
[10:19:59.458]                   name <- changed[[kk]]
[10:19:59.458]                   NAME <- NAMES[[kk]]
[10:19:59.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.458]                     next
[10:19:59.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.458]                 }
[10:19:59.458]                 NAMES <- toupper(added)
[10:19:59.458]                 for (kk in seq_along(NAMES)) {
[10:19:59.458]                   name <- added[[kk]]
[10:19:59.458]                   NAME <- NAMES[[kk]]
[10:19:59.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.458]                     next
[10:19:59.458]                   args[[name]] <- ""
[10:19:59.458]                 }
[10:19:59.458]                 NAMES <- toupper(removed)
[10:19:59.458]                 for (kk in seq_along(NAMES)) {
[10:19:59.458]                   name <- removed[[kk]]
[10:19:59.458]                   NAME <- NAMES[[kk]]
[10:19:59.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.458]                     next
[10:19:59.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.458]                 }
[10:19:59.458]                 if (length(args) > 0) 
[10:19:59.458]                   base::do.call(base::Sys.setenv, args = args)
[10:19:59.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:59.458]             }
[10:19:59.458]             else {
[10:19:59.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:59.458]             }
[10:19:59.458]             {
[10:19:59.458]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:59.458]                   0L) {
[10:19:59.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:59.458]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:59.458]                   base::options(opts)
[10:19:59.458]                 }
[10:19:59.458]                 {
[10:19:59.458]                   {
[10:19:59.458]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:59.458]                     NULL
[10:19:59.458]                   }
[10:19:59.458]                   options(future.plan = NULL)
[10:19:59.458]                   if (is.na(NA_character_)) 
[10:19:59.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:59.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:59.458]                     .init = FALSE)
[10:19:59.458]                 }
[10:19:59.458]             }
[10:19:59.458]         }
[10:19:59.458]     })
[10:19:59.458]     if (TRUE) {
[10:19:59.458]         base::sink(type = "output", split = FALSE)
[10:19:59.458]         if (TRUE) {
[10:19:59.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:59.458]         }
[10:19:59.458]         else {
[10:19:59.458]             ...future.result["stdout"] <- base::list(NULL)
[10:19:59.458]         }
[10:19:59.458]         base::close(...future.stdout)
[10:19:59.458]         ...future.stdout <- NULL
[10:19:59.458]     }
[10:19:59.458]     ...future.result$conditions <- ...future.conditions
[10:19:59.458]     ...future.result$finished <- base::Sys.time()
[10:19:59.458]     ...future.result
[10:19:59.458] }
[10:19:59.461] Exporting 11 global objects (16.50 KiB) to cluster node #2 ...
[10:19:59.461] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #2 ...
[10:19:59.501] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #2 ... DONE
[10:19:59.502] Exporting ‘x_FUN’ (41 bytes) to cluster node #2 ...
[10:19:59.502] Exporting ‘x_FUN’ (41 bytes) to cluster node #2 ... DONE
[10:19:59.502] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:59.503] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:59.503] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:59.543] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:59.544] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:59.584] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:59.584] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:59.585] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.585] Exporting ‘valid_types’ (46 bytes) to cluster node #2 ...
[10:19:59.585] Exporting ‘valid_types’ (46 bytes) to cluster node #2 ... DONE
[10:19:59.586] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:59.586] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:59.586] Exporting ‘...future.elements_ii’ (1.41 KiB) to cluster node #2 ...
[10:19:59.586] Exporting ‘...future.elements_ii’ (1.41 KiB) to cluster node #2 ... DONE
[10:19:59.587] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:59.587] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.587] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:59.587] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.588] Exporting 11 global objects (16.50 KiB) to cluster node #2 ... DONE
[10:19:59.588] MultisessionFuture started
[10:19:59.588] - Launch lazy future ... done
[10:19:59.588] run() for ‘MultisessionFuture’ ... done
[10:19:59.588] Created future:
[10:19:59.588] MultisessionFuture:
[10:19:59.588] Label: ‘future_vapply-2’
[10:19:59.588] Expression:
[10:19:59.588] {
[10:19:59.588]     do.call(function(...) {
[10:19:59.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.588]             on.exit(options(oopts), add = TRUE)
[10:19:59.588]         }
[10:19:59.588]         {
[10:19:59.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.588]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.588]             })
[10:19:59.588]         }
[10:19:59.588]     }, args = future.call.arguments)
[10:19:59.588] }
[10:19:59.588] Lazy evaluation: FALSE
[10:19:59.588] Asynchronous evaluation: TRUE
[10:19:59.588] Local evaluation: TRUE
[10:19:59.588] Environment: R_GlobalEnv
[10:19:59.588] Capture standard output: TRUE
[10:19:59.588] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:59.588] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:59.588] Packages: 1 packages (‘future.apply’)
[10:19:59.588] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:59.588] Resolved: FALSE
[10:19:59.588] Value: <not collected>
[10:19:59.588] Conditions captured: <none>
[10:19:59.588] Early signaling: FALSE
[10:19:59.588] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:59.588] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.600] Chunk #2 of 2 ... DONE
[10:19:59.600] Launching 2 futures (chunks) ... DONE
[10:19:59.600] Resolving 2 futures (chunks) ...
[10:19:59.600] resolve() on list ...
[10:19:59.600]  recursive: 0
[10:19:59.601]  length: 2
[10:19:59.601] 
[10:19:59.601] receiveMessageFromWorker() for ClusterFuture ...
[10:19:59.601] - Validating connection of MultisessionFuture
[10:19:59.601] - received message: FutureResult
[10:19:59.601] - Received FutureResult
[10:19:59.602] - Erased future from FutureRegistry
[10:19:59.602] result() for ClusterFuture ...
[10:19:59.602] - result already collected: FutureResult
[10:19:59.602] result() for ClusterFuture ... done
[10:19:59.602] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:59.602] Future #1
[10:19:59.602] result() for ClusterFuture ...
[10:19:59.602] - result already collected: FutureResult
[10:19:59.602] result() for ClusterFuture ... done
[10:19:59.602] result() for ClusterFuture ...
[10:19:59.602] - result already collected: FutureResult
[10:19:59.602] result() for ClusterFuture ... done
[10:19:59.603] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:59.603] - nx: 2
[10:19:59.603] - relay: TRUE
[10:19:59.603] - stdout: TRUE
[10:19:59.603] - signal: TRUE
[10:19:59.603] - resignal: FALSE
[10:19:59.603] - force: TRUE
[10:19:59.603] - relayed: [n=2] FALSE, FALSE
[10:19:59.603] - queued futures: [n=2] FALSE, FALSE
[10:19:59.603]  - until=1
[10:19:59.603]  - relaying element #1
[10:19:59.603] result() for ClusterFuture ...
[10:19:59.603] - result already collected: FutureResult
[10:19:59.604] result() for ClusterFuture ... done
[10:19:59.604] result() for ClusterFuture ...
[10:19:59.604] - result already collected: FutureResult
[10:19:59.604] result() for ClusterFuture ... done
[10:19:59.604] result() for ClusterFuture ...
[10:19:59.604] - result already collected: FutureResult
[10:19:59.604] result() for ClusterFuture ... done
[10:19:59.604] result() for ClusterFuture ...
[10:19:59.604] - result already collected: FutureResult
[10:19:59.604] result() for ClusterFuture ... done
[10:19:59.604] - relayed: [n=2] TRUE, FALSE
[10:19:59.604] - queued futures: [n=2] TRUE, FALSE
[10:19:59.605] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:59.605]  length: 1 (resolved future 1)
[10:19:59.630] receiveMessageFromWorker() for ClusterFuture ...
[10:19:59.630] - Validating connection of MultisessionFuture
[10:19:59.631] - received message: FutureResult
[10:19:59.631] - Received FutureResult
[10:19:59.631] - Erased future from FutureRegistry
[10:19:59.631] result() for ClusterFuture ...
[10:19:59.631] - result already collected: FutureResult
[10:19:59.631] result() for ClusterFuture ... done
[10:19:59.631] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:59.631] Future #2
[10:19:59.631] result() for ClusterFuture ...
[10:19:59.632] - result already collected: FutureResult
[10:19:59.632] result() for ClusterFuture ... done
[10:19:59.632] result() for ClusterFuture ...
[10:19:59.632] - result already collected: FutureResult
[10:19:59.632] result() for ClusterFuture ... done
[10:19:59.632] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:59.632] - nx: 2
[10:19:59.632] - relay: TRUE
[10:19:59.632] - stdout: TRUE
[10:19:59.632] - signal: TRUE
[10:19:59.632] - resignal: FALSE
[10:19:59.632] - force: TRUE
[10:19:59.632] - relayed: [n=2] TRUE, FALSE
[10:19:59.633] - queued futures: [n=2] TRUE, FALSE
[10:19:59.633]  - until=2
[10:19:59.633]  - relaying element #2
[10:19:59.633] result() for ClusterFuture ...
[10:19:59.633] - result already collected: FutureResult
[10:19:59.633] result() for ClusterFuture ... done
[10:19:59.633] result() for ClusterFuture ...
[10:19:59.633] - result already collected: FutureResult
[10:19:59.633] result() for ClusterFuture ... done
[10:19:59.633] result() for ClusterFuture ...
[10:19:59.633] - result already collected: FutureResult
[10:19:59.633] result() for ClusterFuture ... done
[10:19:59.634] result() for ClusterFuture ...
[10:19:59.634] - result already collected: FutureResult
[10:19:59.634] result() for ClusterFuture ... done
[10:19:59.634] - relayed: [n=2] TRUE, TRUE
[10:19:59.634] - queued futures: [n=2] TRUE, TRUE
[10:19:59.634] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:59.634]  length: 0 (resolved future 2)
[10:19:59.634] Relaying remaining futures
[10:19:59.634] signalConditionsASAP(NULL, pos=0) ...
[10:19:59.634] - nx: 2
[10:19:59.634] - relay: TRUE
[10:19:59.634] - stdout: TRUE
[10:19:59.634] - signal: TRUE
[10:19:59.635] - resignal: FALSE
[10:19:59.635] - force: TRUE
[10:19:59.635] - relayed: [n=2] TRUE, TRUE
[10:19:59.635] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:59.635] - relayed: [n=2] TRUE, TRUE
[10:19:59.635] - queued futures: [n=2] TRUE, TRUE
[10:19:59.635] signalConditionsASAP(NULL, pos=0) ... done
[10:19:59.635] resolve() on list ... DONE
[10:19:59.635] result() for ClusterFuture ...
[10:19:59.635] - result already collected: FutureResult
[10:19:59.635] result() for ClusterFuture ... done
[10:19:59.635] result() for ClusterFuture ...
[10:19:59.636] - result already collected: FutureResult
[10:19:59.636] result() for ClusterFuture ... done
[10:19:59.636] result() for ClusterFuture ...
[10:19:59.636] - result already collected: FutureResult
[10:19:59.636] result() for ClusterFuture ... done
[10:19:59.636] result() for ClusterFuture ...
[10:19:59.636] - result already collected: FutureResult
[10:19:59.636] result() for ClusterFuture ... done
[10:19:59.636]  - Number of value chunks collected: 2
[10:19:59.636] Resolving 2 futures (chunks) ... DONE
[10:19:59.636] Reducing values from 2 chunks ...
[10:19:59.636]  - Number of values collected after concatenation: 11
[10:19:59.636]  - Number of values expected: 11
[10:19:59.637] Reducing values from 2 chunks ... DONE
[10:19:59.637] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:19:59.638] future_lapply() ...
[10:19:59.641] Number of chunks: 2
[10:19:59.641] getGlobalsAndPackagesXApply() ...
[10:19:59.641]  - future.globals: TRUE
[10:19:59.641] getGlobalsAndPackages() ...
[10:19:59.641] Searching for globals...
[10:19:59.644] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:19:59.644] Searching for globals ... DONE
[10:19:59.644] Resolving globals: FALSE
[10:19:59.645] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[10:19:59.645] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:19:59.646] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:59.646] - packages: [1] ‘future.apply’
[10:19:59.646] getGlobalsAndPackages() ... DONE
[10:19:59.646]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:19:59.646]  - needed namespaces: [n=1] ‘future.apply’
[10:19:59.646] Finding globals ... DONE
[10:19:59.646]  - use_args: TRUE
[10:19:59.646]  - Getting '...' globals ...
[10:19:59.647] resolve() on list ...
[10:19:59.647]  recursive: 0
[10:19:59.647]  length: 1
[10:19:59.647]  elements: ‘...’
[10:19:59.647]  length: 0 (resolved future 1)
[10:19:59.647] resolve() on list ... DONE
[10:19:59.647]    - '...' content: [n=0] 
[10:19:59.647] List of 1
[10:19:59.647]  $ ...: list()
[10:19:59.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:59.647]  - attr(*, "where")=List of 1
[10:19:59.647]   ..$ ...:<environment: 0x55c6a1264da0> 
[10:19:59.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:59.647]  - attr(*, "resolved")= logi TRUE
[10:19:59.647]  - attr(*, "total_size")= num NA
[10:19:59.649]  - Getting '...' globals ... DONE
[10:19:59.650] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:19:59.650] List of 8
[10:19:59.650]  $ ...future.FUN:function (x, ...)  
[10:19:59.650]  $ x_FUN        :function (x)  
[10:19:59.650]  $ times        : int 1
[10:19:59.650]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:19:59.650]  $ stop_if_not  :function (...)  
[10:19:59.650]  $ dim          : NULL
[10:19:59.650]  $ valid_types  : chr [1:2] "logical" "integer"
[10:19:59.650]  $ ...          : list()
[10:19:59.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:19:59.650]  - attr(*, "where")=List of 8
[10:19:59.650]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:59.650]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:19:59.650]   ..$ times        :<environment: R_EmptyEnv> 
[10:19:59.650]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:19:59.650]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:19:59.650]   ..$ dim          :<environment: R_EmptyEnv> 
[10:19:59.650]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:19:59.650]   ..$ ...          :<environment: 0x55c6a1264da0> 
[10:19:59.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:59.650]  - attr(*, "resolved")= logi FALSE
[10:19:59.650]  - attr(*, "total_size")= num 22016
[10:19:59.655] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:19:59.655] getGlobalsAndPackagesXApply() ... DONE
[10:19:59.655] Number of futures (= number of chunks): 2
[10:19:59.655] Launching 2 futures (chunks) ...
[10:19:59.655] Chunk #1 of 2 ...
[10:19:59.655]  - Finding globals in 'X' for chunk #1 ...
[10:19:59.655] getGlobalsAndPackages() ...
[10:19:59.656] Searching for globals...
[10:19:59.656] 
[10:19:59.656] Searching for globals ... DONE
[10:19:59.656] - globals: [0] <none>
[10:19:59.656] getGlobalsAndPackages() ... DONE
[10:19:59.656]    + additional globals found: [n=0] 
[10:19:59.656]    + additional namespaces needed: [n=0] 
[10:19:59.656]  - Finding globals in 'X' for chunk #1 ... DONE
[10:19:59.656]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:59.656]  - seeds: <none>
[10:19:59.657]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.657] getGlobalsAndPackages() ...
[10:19:59.657] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.657] Resolving globals: FALSE
[10:19:59.657] Tweak future expression to call with '...' arguments ...
[10:19:59.657] {
[10:19:59.657]     do.call(function(...) {
[10:19:59.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.657]             on.exit(options(oopts), add = TRUE)
[10:19:59.657]         }
[10:19:59.657]         {
[10:19:59.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.657]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.657]             })
[10:19:59.657]         }
[10:19:59.657]     }, args = future.call.arguments)
[10:19:59.657] }
[10:19:59.657] Tweak future expression to call with '...' arguments ... DONE
[10:19:59.658] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.658] - packages: [1] ‘future.apply’
[10:19:59.658] getGlobalsAndPackages() ... DONE
[10:19:59.658] run() for ‘Future’ ...
[10:19:59.658] - state: ‘created’
[10:19:59.659] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:59.676] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:59.676]   - Field: ‘node’
[10:19:59.676]   - Field: ‘label’
[10:19:59.676]   - Field: ‘local’
[10:19:59.676]   - Field: ‘owner’
[10:19:59.676]   - Field: ‘envir’
[10:19:59.676]   - Field: ‘workers’
[10:19:59.676]   - Field: ‘packages’
[10:19:59.676]   - Field: ‘gc’
[10:19:59.677]   - Field: ‘conditions’
[10:19:59.677]   - Field: ‘persistent’
[10:19:59.677]   - Field: ‘expr’
[10:19:59.677]   - Field: ‘uuid’
[10:19:59.677]   - Field: ‘seed’
[10:19:59.677]   - Field: ‘version’
[10:19:59.677]   - Field: ‘result’
[10:19:59.677]   - Field: ‘asynchronous’
[10:19:59.677]   - Field: ‘calls’
[10:19:59.677]   - Field: ‘globals’
[10:19:59.677]   - Field: ‘stdout’
[10:19:59.677]   - Field: ‘earlySignal’
[10:19:59.678]   - Field: ‘lazy’
[10:19:59.678]   - Field: ‘state’
[10:19:59.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:59.678] - Launch lazy future ...
[10:19:59.678] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:59.678] Packages needed by future strategies (n = 0): <none>
[10:19:59.679] {
[10:19:59.679]     {
[10:19:59.679]         {
[10:19:59.679]             ...future.startTime <- base::Sys.time()
[10:19:59.679]             {
[10:19:59.679]                 {
[10:19:59.679]                   {
[10:19:59.679]                     {
[10:19:59.679]                       {
[10:19:59.679]                         base::local({
[10:19:59.679]                           has_future <- base::requireNamespace("future", 
[10:19:59.679]                             quietly = TRUE)
[10:19:59.679]                           if (has_future) {
[10:19:59.679]                             ns <- base::getNamespace("future")
[10:19:59.679]                             version <- ns[[".package"]][["version"]]
[10:19:59.679]                             if (is.null(version)) 
[10:19:59.679]                               version <- utils::packageVersion("future")
[10:19:59.679]                           }
[10:19:59.679]                           else {
[10:19:59.679]                             version <- NULL
[10:19:59.679]                           }
[10:19:59.679]                           if (!has_future || version < "1.8.0") {
[10:19:59.679]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:59.679]                               "", base::R.version$version.string), 
[10:19:59.679]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:59.679]                                 base::R.version$platform, 8 * 
[10:19:59.679]                                   base::.Machine$sizeof.pointer), 
[10:19:59.679]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:59.679]                                 "release", "version")], collapse = " "), 
[10:19:59.679]                               hostname = base::Sys.info()[["nodename"]])
[10:19:59.679]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:59.679]                               info)
[10:19:59.679]                             info <- base::paste(info, collapse = "; ")
[10:19:59.679]                             if (!has_future) {
[10:19:59.679]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:59.679]                                 info)
[10:19:59.679]                             }
[10:19:59.679]                             else {
[10:19:59.679]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:59.679]                                 info, version)
[10:19:59.679]                             }
[10:19:59.679]                             base::stop(msg)
[10:19:59.679]                           }
[10:19:59.679]                         })
[10:19:59.679]                       }
[10:19:59.679]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:59.679]                       base::options(mc.cores = 1L)
[10:19:59.679]                     }
[10:19:59.679]                     base::local({
[10:19:59.679]                       for (pkg in "future.apply") {
[10:19:59.679]                         base::loadNamespace(pkg)
[10:19:59.679]                         base::library(pkg, character.only = TRUE)
[10:19:59.679]                       }
[10:19:59.679]                     })
[10:19:59.679]                   }
[10:19:59.679]                   ...future.strategy.old <- future::plan("list")
[10:19:59.679]                   options(future.plan = NULL)
[10:19:59.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:59.679]                 }
[10:19:59.679]                 ...future.workdir <- getwd()
[10:19:59.679]             }
[10:19:59.679]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:59.679]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:59.679]         }
[10:19:59.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:59.679]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:59.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:59.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:59.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:59.679]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:59.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:59.679]             base::names(...future.oldOptions))
[10:19:59.679]     }
[10:19:59.679]     if (FALSE) {
[10:19:59.679]     }
[10:19:59.679]     else {
[10:19:59.679]         if (TRUE) {
[10:19:59.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:59.679]                 open = "w")
[10:19:59.679]         }
[10:19:59.679]         else {
[10:19:59.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:59.679]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:59.679]         }
[10:19:59.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:59.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:59.679]             base::sink(type = "output", split = FALSE)
[10:19:59.679]             base::close(...future.stdout)
[10:19:59.679]         }, add = TRUE)
[10:19:59.679]     }
[10:19:59.679]     ...future.frame <- base::sys.nframe()
[10:19:59.679]     ...future.conditions <- base::list()
[10:19:59.679]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:59.679]     if (FALSE) {
[10:19:59.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:59.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:59.679]     }
[10:19:59.679]     ...future.result <- base::tryCatch({
[10:19:59.679]         base::withCallingHandlers({
[10:19:59.679]             ...future.value <- base::withVisible(base::local({
[10:19:59.679]                 ...future.makeSendCondition <- base::local({
[10:19:59.679]                   sendCondition <- NULL
[10:19:59.679]                   function(frame = 1L) {
[10:19:59.679]                     if (is.function(sendCondition)) 
[10:19:59.679]                       return(sendCondition)
[10:19:59.679]                     ns <- getNamespace("parallel")
[10:19:59.679]                     if (exists("sendData", mode = "function", 
[10:19:59.679]                       envir = ns)) {
[10:19:59.679]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:59.679]                         envir = ns)
[10:19:59.679]                       envir <- sys.frame(frame)
[10:19:59.679]                       master <- NULL
[10:19:59.679]                       while (!identical(envir, .GlobalEnv) && 
[10:19:59.679]                         !identical(envir, emptyenv())) {
[10:19:59.679]                         if (exists("master", mode = "list", envir = envir, 
[10:19:59.679]                           inherits = FALSE)) {
[10:19:59.679]                           master <- get("master", mode = "list", 
[10:19:59.679]                             envir = envir, inherits = FALSE)
[10:19:59.679]                           if (inherits(master, c("SOCKnode", 
[10:19:59.679]                             "SOCK0node"))) {
[10:19:59.679]                             sendCondition <<- function(cond) {
[10:19:59.679]                               data <- list(type = "VALUE", value = cond, 
[10:19:59.679]                                 success = TRUE)
[10:19:59.679]                               parallel_sendData(master, data)
[10:19:59.679]                             }
[10:19:59.679]                             return(sendCondition)
[10:19:59.679]                           }
[10:19:59.679]                         }
[10:19:59.679]                         frame <- frame + 1L
[10:19:59.679]                         envir <- sys.frame(frame)
[10:19:59.679]                       }
[10:19:59.679]                     }
[10:19:59.679]                     sendCondition <<- function(cond) NULL
[10:19:59.679]                   }
[10:19:59.679]                 })
[10:19:59.679]                 withCallingHandlers({
[10:19:59.679]                   {
[10:19:59.679]                     do.call(function(...) {
[10:19:59.679]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.679]                       if (!identical(...future.globals.maxSize.org, 
[10:19:59.679]                         ...future.globals.maxSize)) {
[10:19:59.679]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.679]                         on.exit(options(oopts), add = TRUE)
[10:19:59.679]                       }
[10:19:59.679]                       {
[10:19:59.679]                         lapply(seq_along(...future.elements_ii), 
[10:19:59.679]                           FUN = function(jj) {
[10:19:59.679]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.679]                             ...future.FUN(...future.X_jj, ...)
[10:19:59.679]                           })
[10:19:59.679]                       }
[10:19:59.679]                     }, args = future.call.arguments)
[10:19:59.679]                   }
[10:19:59.679]                 }, immediateCondition = function(cond) {
[10:19:59.679]                   sendCondition <- ...future.makeSendCondition()
[10:19:59.679]                   sendCondition(cond)
[10:19:59.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.679]                   {
[10:19:59.679]                     inherits <- base::inherits
[10:19:59.679]                     invokeRestart <- base::invokeRestart
[10:19:59.679]                     is.null <- base::is.null
[10:19:59.679]                     muffled <- FALSE
[10:19:59.679]                     if (inherits(cond, "message")) {
[10:19:59.679]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:59.679]                       if (muffled) 
[10:19:59.679]                         invokeRestart("muffleMessage")
[10:19:59.679]                     }
[10:19:59.679]                     else if (inherits(cond, "warning")) {
[10:19:59.679]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:59.679]                       if (muffled) 
[10:19:59.679]                         invokeRestart("muffleWarning")
[10:19:59.679]                     }
[10:19:59.679]                     else if (inherits(cond, "condition")) {
[10:19:59.679]                       if (!is.null(pattern)) {
[10:19:59.679]                         computeRestarts <- base::computeRestarts
[10:19:59.679]                         grepl <- base::grepl
[10:19:59.679]                         restarts <- computeRestarts(cond)
[10:19:59.679]                         for (restart in restarts) {
[10:19:59.679]                           name <- restart$name
[10:19:59.679]                           if (is.null(name)) 
[10:19:59.679]                             next
[10:19:59.679]                           if (!grepl(pattern, name)) 
[10:19:59.679]                             next
[10:19:59.679]                           invokeRestart(restart)
[10:19:59.679]                           muffled <- TRUE
[10:19:59.679]                           break
[10:19:59.679]                         }
[10:19:59.679]                       }
[10:19:59.679]                     }
[10:19:59.679]                     invisible(muffled)
[10:19:59.679]                   }
[10:19:59.679]                   muffleCondition(cond)
[10:19:59.679]                 })
[10:19:59.679]             }))
[10:19:59.679]             future::FutureResult(value = ...future.value$value, 
[10:19:59.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.679]                   ...future.rng), globalenv = if (FALSE) 
[10:19:59.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:59.679]                     ...future.globalenv.names))
[10:19:59.679]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:59.679]         }, condition = base::local({
[10:19:59.679]             c <- base::c
[10:19:59.679]             inherits <- base::inherits
[10:19:59.679]             invokeRestart <- base::invokeRestart
[10:19:59.679]             length <- base::length
[10:19:59.679]             list <- base::list
[10:19:59.679]             seq.int <- base::seq.int
[10:19:59.679]             signalCondition <- base::signalCondition
[10:19:59.679]             sys.calls <- base::sys.calls
[10:19:59.679]             `[[` <- base::`[[`
[10:19:59.679]             `+` <- base::`+`
[10:19:59.679]             `<<-` <- base::`<<-`
[10:19:59.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:59.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:59.679]                   3L)]
[10:19:59.679]             }
[10:19:59.679]             function(cond) {
[10:19:59.679]                 is_error <- inherits(cond, "error")
[10:19:59.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:59.679]                   NULL)
[10:19:59.679]                 if (is_error) {
[10:19:59.679]                   sessionInformation <- function() {
[10:19:59.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:59.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:59.679]                       search = base::search(), system = base::Sys.info())
[10:19:59.679]                   }
[10:19:59.679]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:59.679]                     cond$call), session = sessionInformation(), 
[10:19:59.679]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:59.679]                   signalCondition(cond)
[10:19:59.679]                 }
[10:19:59.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:59.679]                 "immediateCondition"))) {
[10:19:59.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:59.679]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:59.679]                   if (TRUE && !signal) {
[10:19:59.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.679]                     {
[10:19:59.679]                       inherits <- base::inherits
[10:19:59.679]                       invokeRestart <- base::invokeRestart
[10:19:59.679]                       is.null <- base::is.null
[10:19:59.679]                       muffled <- FALSE
[10:19:59.679]                       if (inherits(cond, "message")) {
[10:19:59.679]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.679]                         if (muffled) 
[10:19:59.679]                           invokeRestart("muffleMessage")
[10:19:59.679]                       }
[10:19:59.679]                       else if (inherits(cond, "warning")) {
[10:19:59.679]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.679]                         if (muffled) 
[10:19:59.679]                           invokeRestart("muffleWarning")
[10:19:59.679]                       }
[10:19:59.679]                       else if (inherits(cond, "condition")) {
[10:19:59.679]                         if (!is.null(pattern)) {
[10:19:59.679]                           computeRestarts <- base::computeRestarts
[10:19:59.679]                           grepl <- base::grepl
[10:19:59.679]                           restarts <- computeRestarts(cond)
[10:19:59.679]                           for (restart in restarts) {
[10:19:59.679]                             name <- restart$name
[10:19:59.679]                             if (is.null(name)) 
[10:19:59.679]                               next
[10:19:59.679]                             if (!grepl(pattern, name)) 
[10:19:59.679]                               next
[10:19:59.679]                             invokeRestart(restart)
[10:19:59.679]                             muffled <- TRUE
[10:19:59.679]                             break
[10:19:59.679]                           }
[10:19:59.679]                         }
[10:19:59.679]                       }
[10:19:59.679]                       invisible(muffled)
[10:19:59.679]                     }
[10:19:59.679]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.679]                   }
[10:19:59.679]                 }
[10:19:59.679]                 else {
[10:19:59.679]                   if (TRUE) {
[10:19:59.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.679]                     {
[10:19:59.679]                       inherits <- base::inherits
[10:19:59.679]                       invokeRestart <- base::invokeRestart
[10:19:59.679]                       is.null <- base::is.null
[10:19:59.679]                       muffled <- FALSE
[10:19:59.679]                       if (inherits(cond, "message")) {
[10:19:59.679]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.679]                         if (muffled) 
[10:19:59.679]                           invokeRestart("muffleMessage")
[10:19:59.679]                       }
[10:19:59.679]                       else if (inherits(cond, "warning")) {
[10:19:59.679]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.679]                         if (muffled) 
[10:19:59.679]                           invokeRestart("muffleWarning")
[10:19:59.679]                       }
[10:19:59.679]                       else if (inherits(cond, "condition")) {
[10:19:59.679]                         if (!is.null(pattern)) {
[10:19:59.679]                           computeRestarts <- base::computeRestarts
[10:19:59.679]                           grepl <- base::grepl
[10:19:59.679]                           restarts <- computeRestarts(cond)
[10:19:59.679]                           for (restart in restarts) {
[10:19:59.679]                             name <- restart$name
[10:19:59.679]                             if (is.null(name)) 
[10:19:59.679]                               next
[10:19:59.679]                             if (!grepl(pattern, name)) 
[10:19:59.679]                               next
[10:19:59.679]                             invokeRestart(restart)
[10:19:59.679]                             muffled <- TRUE
[10:19:59.679]                             break
[10:19:59.679]                           }
[10:19:59.679]                         }
[10:19:59.679]                       }
[10:19:59.679]                       invisible(muffled)
[10:19:59.679]                     }
[10:19:59.679]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.679]                   }
[10:19:59.679]                 }
[10:19:59.679]             }
[10:19:59.679]         }))
[10:19:59.679]     }, error = function(ex) {
[10:19:59.679]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:59.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.679]                 ...future.rng), started = ...future.startTime, 
[10:19:59.679]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:59.679]             version = "1.8"), class = "FutureResult")
[10:19:59.679]     }, finally = {
[10:19:59.679]         if (!identical(...future.workdir, getwd())) 
[10:19:59.679]             setwd(...future.workdir)
[10:19:59.679]         {
[10:19:59.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:59.679]                 ...future.oldOptions$nwarnings <- NULL
[10:19:59.679]             }
[10:19:59.679]             base::options(...future.oldOptions)
[10:19:59.679]             if (.Platform$OS.type == "windows") {
[10:19:59.679]                 old_names <- names(...future.oldEnvVars)
[10:19:59.679]                 envs <- base::Sys.getenv()
[10:19:59.679]                 names <- names(envs)
[10:19:59.679]                 common <- intersect(names, old_names)
[10:19:59.679]                 added <- setdiff(names, old_names)
[10:19:59.679]                 removed <- setdiff(old_names, names)
[10:19:59.679]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:59.679]                   envs[common]]
[10:19:59.679]                 NAMES <- toupper(changed)
[10:19:59.679]                 args <- list()
[10:19:59.679]                 for (kk in seq_along(NAMES)) {
[10:19:59.679]                   name <- changed[[kk]]
[10:19:59.679]                   NAME <- NAMES[[kk]]
[10:19:59.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.679]                     next
[10:19:59.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.679]                 }
[10:19:59.679]                 NAMES <- toupper(added)
[10:19:59.679]                 for (kk in seq_along(NAMES)) {
[10:19:59.679]                   name <- added[[kk]]
[10:19:59.679]                   NAME <- NAMES[[kk]]
[10:19:59.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.679]                     next
[10:19:59.679]                   args[[name]] <- ""
[10:19:59.679]                 }
[10:19:59.679]                 NAMES <- toupper(removed)
[10:19:59.679]                 for (kk in seq_along(NAMES)) {
[10:19:59.679]                   name <- removed[[kk]]
[10:19:59.679]                   NAME <- NAMES[[kk]]
[10:19:59.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.679]                     next
[10:19:59.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.679]                 }
[10:19:59.679]                 if (length(args) > 0) 
[10:19:59.679]                   base::do.call(base::Sys.setenv, args = args)
[10:19:59.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:59.679]             }
[10:19:59.679]             else {
[10:19:59.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:59.679]             }
[10:19:59.679]             {
[10:19:59.679]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:59.679]                   0L) {
[10:19:59.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:59.679]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:59.679]                   base::options(opts)
[10:19:59.679]                 }
[10:19:59.679]                 {
[10:19:59.679]                   {
[10:19:59.679]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:59.679]                     NULL
[10:19:59.679]                   }
[10:19:59.679]                   options(future.plan = NULL)
[10:19:59.679]                   if (is.na(NA_character_)) 
[10:19:59.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:59.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:59.679]                     .init = FALSE)
[10:19:59.679]                 }
[10:19:59.679]             }
[10:19:59.679]         }
[10:19:59.679]     })
[10:19:59.679]     if (TRUE) {
[10:19:59.679]         base::sink(type = "output", split = FALSE)
[10:19:59.679]         if (TRUE) {
[10:19:59.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:59.679]         }
[10:19:59.679]         else {
[10:19:59.679]             ...future.result["stdout"] <- base::list(NULL)
[10:19:59.679]         }
[10:19:59.679]         base::close(...future.stdout)
[10:19:59.679]         ...future.stdout <- NULL
[10:19:59.679]     }
[10:19:59.679]     ...future.result$conditions <- ...future.conditions
[10:19:59.679]     ...future.result$finished <- base::Sys.time()
[10:19:59.679]     ...future.result
[10:19:59.679] }
[10:19:59.682] Exporting 11 global objects (12.36 KiB) to cluster node #1 ...
[10:19:59.682] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #1 ...
[10:19:59.723] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #1 ... DONE
[10:19:59.724] Exporting ‘x_FUN’ (37 bytes) to cluster node #1 ...
[10:19:59.724] Exporting ‘x_FUN’ (37 bytes) to cluster node #1 ... DONE
[10:19:59.724] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:19:59.725] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:19:59.725] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:19:59.765] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:19:59.766] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:19:59.806] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:19:59.806] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:19:59.809] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.809] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[10:19:59.810] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[10:19:59.810] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:19:59.810] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:19:59.810] Exporting ‘...future.elements_ii’ (89 bytes) to cluster node #1 ...
[10:19:59.811] Exporting ‘...future.elements_ii’ (89 bytes) to cluster node #1 ... DONE
[10:19:59.811] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:59.811] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.811] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:59.812] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:59.812] Exporting 11 global objects (12.36 KiB) to cluster node #1 ... DONE
[10:19:59.812] MultisessionFuture started
[10:19:59.812] - Launch lazy future ... done
[10:19:59.813] run() for ‘MultisessionFuture’ ... done
[10:19:59.813] Created future:
[10:19:59.813] MultisessionFuture:
[10:19:59.813] Label: ‘future_vapply-1’
[10:19:59.813] Expression:
[10:19:59.813] {
[10:19:59.813]     do.call(function(...) {
[10:19:59.813]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.813]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.813]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.813]             on.exit(options(oopts), add = TRUE)
[10:19:59.813]         }
[10:19:59.813]         {
[10:19:59.813]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.813]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.813]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.813]             })
[10:19:59.813]         }
[10:19:59.813]     }, args = future.call.arguments)
[10:19:59.813] }
[10:19:59.813] Lazy evaluation: FALSE
[10:19:59.813] Asynchronous evaluation: TRUE
[10:19:59.813] Local evaluation: TRUE
[10:19:59.813] Environment: R_GlobalEnv
[10:19:59.813] Capture standard output: TRUE
[10:19:59.813] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:59.813] Globals: 11 objects totaling 12.15 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:59.813] Packages: 1 packages (‘future.apply’)
[10:19:59.813] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:59.813] Resolved: FALSE
[10:19:59.813] Value: <not collected>
[10:19:59.813] Conditions captured: <none>
[10:19:59.813] Early signaling: FALSE
[10:19:59.813] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:59.813] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.824] Chunk #1 of 2 ... DONE
[10:19:59.824] Chunk #2 of 2 ...
[10:19:59.825]  - Finding globals in 'X' for chunk #2 ...
[10:19:59.825] getGlobalsAndPackages() ...
[10:19:59.825] Searching for globals...
[10:19:59.825] 
[10:19:59.825] Searching for globals ... DONE
[10:19:59.825] - globals: [0] <none>
[10:19:59.825] getGlobalsAndPackages() ... DONE
[10:19:59.825]    + additional globals found: [n=0] 
[10:19:59.825]    + additional namespaces needed: [n=0] 
[10:19:59.825]  - Finding globals in 'X' for chunk #2 ... DONE
[10:19:59.826]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:59.826]  - seeds: <none>
[10:19:59.826]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.826] getGlobalsAndPackages() ...
[10:19:59.826] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.826] Resolving globals: FALSE
[10:19:59.826] Tweak future expression to call with '...' arguments ...
[10:19:59.826] {
[10:19:59.826]     do.call(function(...) {
[10:19:59.826]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.826]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.826]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.826]             on.exit(options(oopts), add = TRUE)
[10:19:59.826]         }
[10:19:59.826]         {
[10:19:59.826]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.826]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.826]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.826]             })
[10:19:59.826]         }
[10:19:59.826]     }, args = future.call.arguments)
[10:19:59.826] }
[10:19:59.826] Tweak future expression to call with '...' arguments ... DONE
[10:19:59.827] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:59.827] - packages: [1] ‘future.apply’
[10:19:59.827] getGlobalsAndPackages() ... DONE
[10:19:59.827] run() for ‘Future’ ...
[10:19:59.828] - state: ‘created’
[10:19:59.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:59.841] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:59.841]   - Field: ‘node’
[10:19:59.841]   - Field: ‘label’
[10:19:59.842]   - Field: ‘local’
[10:19:59.842]   - Field: ‘owner’
[10:19:59.842]   - Field: ‘envir’
[10:19:59.842]   - Field: ‘workers’
[10:19:59.842]   - Field: ‘packages’
[10:19:59.842]   - Field: ‘gc’
[10:19:59.842]   - Field: ‘conditions’
[10:19:59.842]   - Field: ‘persistent’
[10:19:59.842]   - Field: ‘expr’
[10:19:59.842]   - Field: ‘uuid’
[10:19:59.842]   - Field: ‘seed’
[10:19:59.842]   - Field: ‘version’
[10:19:59.843]   - Field: ‘result’
[10:19:59.843]   - Field: ‘asynchronous’
[10:19:59.843]   - Field: ‘calls’
[10:19:59.843]   - Field: ‘globals’
[10:19:59.843]   - Field: ‘stdout’
[10:19:59.843]   - Field: ‘earlySignal’
[10:19:59.843]   - Field: ‘lazy’
[10:19:59.843]   - Field: ‘state’
[10:19:59.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:59.843] - Launch lazy future ...
[10:19:59.844] Packages needed by the future expression (n = 1): ‘future.apply’
[10:19:59.844] Packages needed by future strategies (n = 0): <none>
[10:19:59.844] {
[10:19:59.844]     {
[10:19:59.844]         {
[10:19:59.844]             ...future.startTime <- base::Sys.time()
[10:19:59.844]             {
[10:19:59.844]                 {
[10:19:59.844]                   {
[10:19:59.844]                     {
[10:19:59.844]                       {
[10:19:59.844]                         base::local({
[10:19:59.844]                           has_future <- base::requireNamespace("future", 
[10:19:59.844]                             quietly = TRUE)
[10:19:59.844]                           if (has_future) {
[10:19:59.844]                             ns <- base::getNamespace("future")
[10:19:59.844]                             version <- ns[[".package"]][["version"]]
[10:19:59.844]                             if (is.null(version)) 
[10:19:59.844]                               version <- utils::packageVersion("future")
[10:19:59.844]                           }
[10:19:59.844]                           else {
[10:19:59.844]                             version <- NULL
[10:19:59.844]                           }
[10:19:59.844]                           if (!has_future || version < "1.8.0") {
[10:19:59.844]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:59.844]                               "", base::R.version$version.string), 
[10:19:59.844]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:59.844]                                 base::R.version$platform, 8 * 
[10:19:59.844]                                   base::.Machine$sizeof.pointer), 
[10:19:59.844]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:59.844]                                 "release", "version")], collapse = " "), 
[10:19:59.844]                               hostname = base::Sys.info()[["nodename"]])
[10:19:59.844]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:59.844]                               info)
[10:19:59.844]                             info <- base::paste(info, collapse = "; ")
[10:19:59.844]                             if (!has_future) {
[10:19:59.844]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:59.844]                                 info)
[10:19:59.844]                             }
[10:19:59.844]                             else {
[10:19:59.844]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:59.844]                                 info, version)
[10:19:59.844]                             }
[10:19:59.844]                             base::stop(msg)
[10:19:59.844]                           }
[10:19:59.844]                         })
[10:19:59.844]                       }
[10:19:59.844]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:59.844]                       base::options(mc.cores = 1L)
[10:19:59.844]                     }
[10:19:59.844]                     base::local({
[10:19:59.844]                       for (pkg in "future.apply") {
[10:19:59.844]                         base::loadNamespace(pkg)
[10:19:59.844]                         base::library(pkg, character.only = TRUE)
[10:19:59.844]                       }
[10:19:59.844]                     })
[10:19:59.844]                   }
[10:19:59.844]                   ...future.strategy.old <- future::plan("list")
[10:19:59.844]                   options(future.plan = NULL)
[10:19:59.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:59.844]                 }
[10:19:59.844]                 ...future.workdir <- getwd()
[10:19:59.844]             }
[10:19:59.844]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:59.844]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:59.844]         }
[10:19:59.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:59.844]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:59.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:59.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:59.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:59.844]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:59.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:59.844]             base::names(...future.oldOptions))
[10:19:59.844]     }
[10:19:59.844]     if (FALSE) {
[10:19:59.844]     }
[10:19:59.844]     else {
[10:19:59.844]         if (TRUE) {
[10:19:59.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:59.844]                 open = "w")
[10:19:59.844]         }
[10:19:59.844]         else {
[10:19:59.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:59.844]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:59.844]         }
[10:19:59.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:59.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:59.844]             base::sink(type = "output", split = FALSE)
[10:19:59.844]             base::close(...future.stdout)
[10:19:59.844]         }, add = TRUE)
[10:19:59.844]     }
[10:19:59.844]     ...future.frame <- base::sys.nframe()
[10:19:59.844]     ...future.conditions <- base::list()
[10:19:59.844]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:59.844]     if (FALSE) {
[10:19:59.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:59.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:59.844]     }
[10:19:59.844]     ...future.result <- base::tryCatch({
[10:19:59.844]         base::withCallingHandlers({
[10:19:59.844]             ...future.value <- base::withVisible(base::local({
[10:19:59.844]                 ...future.makeSendCondition <- base::local({
[10:19:59.844]                   sendCondition <- NULL
[10:19:59.844]                   function(frame = 1L) {
[10:19:59.844]                     if (is.function(sendCondition)) 
[10:19:59.844]                       return(sendCondition)
[10:19:59.844]                     ns <- getNamespace("parallel")
[10:19:59.844]                     if (exists("sendData", mode = "function", 
[10:19:59.844]                       envir = ns)) {
[10:19:59.844]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:59.844]                         envir = ns)
[10:19:59.844]                       envir <- sys.frame(frame)
[10:19:59.844]                       master <- NULL
[10:19:59.844]                       while (!identical(envir, .GlobalEnv) && 
[10:19:59.844]                         !identical(envir, emptyenv())) {
[10:19:59.844]                         if (exists("master", mode = "list", envir = envir, 
[10:19:59.844]                           inherits = FALSE)) {
[10:19:59.844]                           master <- get("master", mode = "list", 
[10:19:59.844]                             envir = envir, inherits = FALSE)
[10:19:59.844]                           if (inherits(master, c("SOCKnode", 
[10:19:59.844]                             "SOCK0node"))) {
[10:19:59.844]                             sendCondition <<- function(cond) {
[10:19:59.844]                               data <- list(type = "VALUE", value = cond, 
[10:19:59.844]                                 success = TRUE)
[10:19:59.844]                               parallel_sendData(master, data)
[10:19:59.844]                             }
[10:19:59.844]                             return(sendCondition)
[10:19:59.844]                           }
[10:19:59.844]                         }
[10:19:59.844]                         frame <- frame + 1L
[10:19:59.844]                         envir <- sys.frame(frame)
[10:19:59.844]                       }
[10:19:59.844]                     }
[10:19:59.844]                     sendCondition <<- function(cond) NULL
[10:19:59.844]                   }
[10:19:59.844]                 })
[10:19:59.844]                 withCallingHandlers({
[10:19:59.844]                   {
[10:19:59.844]                     do.call(function(...) {
[10:19:59.844]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.844]                       if (!identical(...future.globals.maxSize.org, 
[10:19:59.844]                         ...future.globals.maxSize)) {
[10:19:59.844]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.844]                         on.exit(options(oopts), add = TRUE)
[10:19:59.844]                       }
[10:19:59.844]                       {
[10:19:59.844]                         lapply(seq_along(...future.elements_ii), 
[10:19:59.844]                           FUN = function(jj) {
[10:19:59.844]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.844]                             ...future.FUN(...future.X_jj, ...)
[10:19:59.844]                           })
[10:19:59.844]                       }
[10:19:59.844]                     }, args = future.call.arguments)
[10:19:59.844]                   }
[10:19:59.844]                 }, immediateCondition = function(cond) {
[10:19:59.844]                   sendCondition <- ...future.makeSendCondition()
[10:19:59.844]                   sendCondition(cond)
[10:19:59.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.844]                   {
[10:19:59.844]                     inherits <- base::inherits
[10:19:59.844]                     invokeRestart <- base::invokeRestart
[10:19:59.844]                     is.null <- base::is.null
[10:19:59.844]                     muffled <- FALSE
[10:19:59.844]                     if (inherits(cond, "message")) {
[10:19:59.844]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:59.844]                       if (muffled) 
[10:19:59.844]                         invokeRestart("muffleMessage")
[10:19:59.844]                     }
[10:19:59.844]                     else if (inherits(cond, "warning")) {
[10:19:59.844]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:59.844]                       if (muffled) 
[10:19:59.844]                         invokeRestart("muffleWarning")
[10:19:59.844]                     }
[10:19:59.844]                     else if (inherits(cond, "condition")) {
[10:19:59.844]                       if (!is.null(pattern)) {
[10:19:59.844]                         computeRestarts <- base::computeRestarts
[10:19:59.844]                         grepl <- base::grepl
[10:19:59.844]                         restarts <- computeRestarts(cond)
[10:19:59.844]                         for (restart in restarts) {
[10:19:59.844]                           name <- restart$name
[10:19:59.844]                           if (is.null(name)) 
[10:19:59.844]                             next
[10:19:59.844]                           if (!grepl(pattern, name)) 
[10:19:59.844]                             next
[10:19:59.844]                           invokeRestart(restart)
[10:19:59.844]                           muffled <- TRUE
[10:19:59.844]                           break
[10:19:59.844]                         }
[10:19:59.844]                       }
[10:19:59.844]                     }
[10:19:59.844]                     invisible(muffled)
[10:19:59.844]                   }
[10:19:59.844]                   muffleCondition(cond)
[10:19:59.844]                 })
[10:19:59.844]             }))
[10:19:59.844]             future::FutureResult(value = ...future.value$value, 
[10:19:59.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.844]                   ...future.rng), globalenv = if (FALSE) 
[10:19:59.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:59.844]                     ...future.globalenv.names))
[10:19:59.844]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:59.844]         }, condition = base::local({
[10:19:59.844]             c <- base::c
[10:19:59.844]             inherits <- base::inherits
[10:19:59.844]             invokeRestart <- base::invokeRestart
[10:19:59.844]             length <- base::length
[10:19:59.844]             list <- base::list
[10:19:59.844]             seq.int <- base::seq.int
[10:19:59.844]             signalCondition <- base::signalCondition
[10:19:59.844]             sys.calls <- base::sys.calls
[10:19:59.844]             `[[` <- base::`[[`
[10:19:59.844]             `+` <- base::`+`
[10:19:59.844]             `<<-` <- base::`<<-`
[10:19:59.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:59.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:59.844]                   3L)]
[10:19:59.844]             }
[10:19:59.844]             function(cond) {
[10:19:59.844]                 is_error <- inherits(cond, "error")
[10:19:59.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:59.844]                   NULL)
[10:19:59.844]                 if (is_error) {
[10:19:59.844]                   sessionInformation <- function() {
[10:19:59.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:59.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:59.844]                       search = base::search(), system = base::Sys.info())
[10:19:59.844]                   }
[10:19:59.844]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:59.844]                     cond$call), session = sessionInformation(), 
[10:19:59.844]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:59.844]                   signalCondition(cond)
[10:19:59.844]                 }
[10:19:59.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:59.844]                 "immediateCondition"))) {
[10:19:59.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:59.844]                   ...future.conditions[[length(...future.conditions) + 
[10:19:59.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:59.844]                   if (TRUE && !signal) {
[10:19:59.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.844]                     {
[10:19:59.844]                       inherits <- base::inherits
[10:19:59.844]                       invokeRestart <- base::invokeRestart
[10:19:59.844]                       is.null <- base::is.null
[10:19:59.844]                       muffled <- FALSE
[10:19:59.844]                       if (inherits(cond, "message")) {
[10:19:59.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.844]                         if (muffled) 
[10:19:59.844]                           invokeRestart("muffleMessage")
[10:19:59.844]                       }
[10:19:59.844]                       else if (inherits(cond, "warning")) {
[10:19:59.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.844]                         if (muffled) 
[10:19:59.844]                           invokeRestart("muffleWarning")
[10:19:59.844]                       }
[10:19:59.844]                       else if (inherits(cond, "condition")) {
[10:19:59.844]                         if (!is.null(pattern)) {
[10:19:59.844]                           computeRestarts <- base::computeRestarts
[10:19:59.844]                           grepl <- base::grepl
[10:19:59.844]                           restarts <- computeRestarts(cond)
[10:19:59.844]                           for (restart in restarts) {
[10:19:59.844]                             name <- restart$name
[10:19:59.844]                             if (is.null(name)) 
[10:19:59.844]                               next
[10:19:59.844]                             if (!grepl(pattern, name)) 
[10:19:59.844]                               next
[10:19:59.844]                             invokeRestart(restart)
[10:19:59.844]                             muffled <- TRUE
[10:19:59.844]                             break
[10:19:59.844]                           }
[10:19:59.844]                         }
[10:19:59.844]                       }
[10:19:59.844]                       invisible(muffled)
[10:19:59.844]                     }
[10:19:59.844]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.844]                   }
[10:19:59.844]                 }
[10:19:59.844]                 else {
[10:19:59.844]                   if (TRUE) {
[10:19:59.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:59.844]                     {
[10:19:59.844]                       inherits <- base::inherits
[10:19:59.844]                       invokeRestart <- base::invokeRestart
[10:19:59.844]                       is.null <- base::is.null
[10:19:59.844]                       muffled <- FALSE
[10:19:59.844]                       if (inherits(cond, "message")) {
[10:19:59.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:59.844]                         if (muffled) 
[10:19:59.844]                           invokeRestart("muffleMessage")
[10:19:59.844]                       }
[10:19:59.844]                       else if (inherits(cond, "warning")) {
[10:19:59.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:59.844]                         if (muffled) 
[10:19:59.844]                           invokeRestart("muffleWarning")
[10:19:59.844]                       }
[10:19:59.844]                       else if (inherits(cond, "condition")) {
[10:19:59.844]                         if (!is.null(pattern)) {
[10:19:59.844]                           computeRestarts <- base::computeRestarts
[10:19:59.844]                           grepl <- base::grepl
[10:19:59.844]                           restarts <- computeRestarts(cond)
[10:19:59.844]                           for (restart in restarts) {
[10:19:59.844]                             name <- restart$name
[10:19:59.844]                             if (is.null(name)) 
[10:19:59.844]                               next
[10:19:59.844]                             if (!grepl(pattern, name)) 
[10:19:59.844]                               next
[10:19:59.844]                             invokeRestart(restart)
[10:19:59.844]                             muffled <- TRUE
[10:19:59.844]                             break
[10:19:59.844]                           }
[10:19:59.844]                         }
[10:19:59.844]                       }
[10:19:59.844]                       invisible(muffled)
[10:19:59.844]                     }
[10:19:59.844]                     muffleCondition(cond, pattern = "^muffle")
[10:19:59.844]                   }
[10:19:59.844]                 }
[10:19:59.844]             }
[10:19:59.844]         }))
[10:19:59.844]     }, error = function(ex) {
[10:19:59.844]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:59.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:59.844]                 ...future.rng), started = ...future.startTime, 
[10:19:59.844]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:59.844]             version = "1.8"), class = "FutureResult")
[10:19:59.844]     }, finally = {
[10:19:59.844]         if (!identical(...future.workdir, getwd())) 
[10:19:59.844]             setwd(...future.workdir)
[10:19:59.844]         {
[10:19:59.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:59.844]                 ...future.oldOptions$nwarnings <- NULL
[10:19:59.844]             }
[10:19:59.844]             base::options(...future.oldOptions)
[10:19:59.844]             if (.Platform$OS.type == "windows") {
[10:19:59.844]                 old_names <- names(...future.oldEnvVars)
[10:19:59.844]                 envs <- base::Sys.getenv()
[10:19:59.844]                 names <- names(envs)
[10:19:59.844]                 common <- intersect(names, old_names)
[10:19:59.844]                 added <- setdiff(names, old_names)
[10:19:59.844]                 removed <- setdiff(old_names, names)
[10:19:59.844]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:59.844]                   envs[common]]
[10:19:59.844]                 NAMES <- toupper(changed)
[10:19:59.844]                 args <- list()
[10:19:59.844]                 for (kk in seq_along(NAMES)) {
[10:19:59.844]                   name <- changed[[kk]]
[10:19:59.844]                   NAME <- NAMES[[kk]]
[10:19:59.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.844]                     next
[10:19:59.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.844]                 }
[10:19:59.844]                 NAMES <- toupper(added)
[10:19:59.844]                 for (kk in seq_along(NAMES)) {
[10:19:59.844]                   name <- added[[kk]]
[10:19:59.844]                   NAME <- NAMES[[kk]]
[10:19:59.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.844]                     next
[10:19:59.844]                   args[[name]] <- ""
[10:19:59.844]                 }
[10:19:59.844]                 NAMES <- toupper(removed)
[10:19:59.844]                 for (kk in seq_along(NAMES)) {
[10:19:59.844]                   name <- removed[[kk]]
[10:19:59.844]                   NAME <- NAMES[[kk]]
[10:19:59.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:59.844]                     next
[10:19:59.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:59.844]                 }
[10:19:59.844]                 if (length(args) > 0) 
[10:19:59.844]                   base::do.call(base::Sys.setenv, args = args)
[10:19:59.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:59.844]             }
[10:19:59.844]             else {
[10:19:59.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:59.844]             }
[10:19:59.844]             {
[10:19:59.844]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:59.844]                   0L) {
[10:19:59.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:59.844]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:59.844]                   base::options(opts)
[10:19:59.844]                 }
[10:19:59.844]                 {
[10:19:59.844]                   {
[10:19:59.844]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:59.844]                     NULL
[10:19:59.844]                   }
[10:19:59.844]                   options(future.plan = NULL)
[10:19:59.844]                   if (is.na(NA_character_)) 
[10:19:59.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:59.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:59.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:59.844]                     .init = FALSE)
[10:19:59.844]                 }
[10:19:59.844]             }
[10:19:59.844]         }
[10:19:59.844]     })
[10:19:59.844]     if (TRUE) {
[10:19:59.844]         base::sink(type = "output", split = FALSE)
[10:19:59.844]         if (TRUE) {
[10:19:59.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:59.844]         }
[10:19:59.844]         else {
[10:19:59.844]             ...future.result["stdout"] <- base::list(NULL)
[10:19:59.844]         }
[10:19:59.844]         base::close(...future.stdout)
[10:19:59.844]         ...future.stdout <- NULL
[10:19:59.844]     }
[10:19:59.844]     ...future.result$conditions <- ...future.conditions
[10:19:59.844]     ...future.result$finished <- base::Sys.time()
[10:19:59.844]     ...future.result
[10:19:59.844] }
[10:19:59.849] Exporting 11 global objects (12.39 KiB) to cluster node #2 ...
[10:19:59.849] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #2 ...
[10:19:59.890] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #2 ... DONE
[10:19:59.891] Exporting ‘x_FUN’ (37 bytes) to cluster node #2 ...
[10:19:59.891] Exporting ‘x_FUN’ (37 bytes) to cluster node #2 ... DONE
[10:19:59.891] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:19:59.891] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:19:59.892] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:19:59.932] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:19:59.933] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:19:59.973] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:19:59.973] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:19:59.974] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.974] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[10:19:59.974] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[10:19:59.975] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:19:59.975] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:19:59.975] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[10:19:59.976] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[10:19:59.976] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:59.976] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.976] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:59.977] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:59.977] Exporting 11 global objects (12.39 KiB) to cluster node #2 ... DONE
[10:19:59.977] MultisessionFuture started
[10:19:59.977] - Launch lazy future ... done
[10:19:59.977] run() for ‘MultisessionFuture’ ... done
[10:19:59.977] Created future:
[10:19:59.978] MultisessionFuture:
[10:19:59.978] Label: ‘future_vapply-2’
[10:19:59.978] Expression:
[10:19:59.978] {
[10:19:59.978]     do.call(function(...) {
[10:19:59.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:59.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:59.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:59.978]             on.exit(options(oopts), add = TRUE)
[10:19:59.978]         }
[10:19:59.978]         {
[10:19:59.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:19:59.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:19:59.978]                 ...future.FUN(...future.X_jj, ...)
[10:19:59.978]             })
[10:19:59.978]         }
[10:19:59.978]     }, args = future.call.arguments)
[10:19:59.978] }
[10:19:59.978] Lazy evaluation: FALSE
[10:19:59.978] Asynchronous evaluation: TRUE
[10:19:59.978] Local evaluation: TRUE
[10:19:59.978] Environment: R_GlobalEnv
[10:19:59.978] Capture standard output: TRUE
[10:19:59.978] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:59.978] Globals: 11 objects totaling 12.17 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:19:59.978] Packages: 1 packages (‘future.apply’)
[10:19:59.978] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:59.978] Resolved: FALSE
[10:19:59.978] Value: <not collected>
[10:19:59.978] Conditions captured: <none>
[10:19:59.978] Early signaling: FALSE
[10:19:59.978] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:19:59.978] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:59.989] Chunk #2 of 2 ... DONE
[10:19:59.989] Launching 2 futures (chunks) ... DONE
[10:19:59.989] Resolving 2 futures (chunks) ...
[10:19:59.989] resolve() on list ...
[10:19:59.989]  recursive: 0
[10:19:59.990]  length: 2
[10:19:59.990] 
[10:19:59.990] receiveMessageFromWorker() for ClusterFuture ...
[10:19:59.990] - Validating connection of MultisessionFuture
[10:19:59.990] - received message: FutureResult
[10:19:59.991] - Received FutureResult
[10:19:59.991] - Erased future from FutureRegistry
[10:19:59.991] result() for ClusterFuture ...
[10:19:59.991] - result already collected: FutureResult
[10:19:59.991] result() for ClusterFuture ... done
[10:19:59.991] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:59.991] Future #1
[10:19:59.991] result() for ClusterFuture ...
[10:19:59.991] - result already collected: FutureResult
[10:19:59.991] result() for ClusterFuture ... done
[10:19:59.991] result() for ClusterFuture ...
[10:19:59.991] - result already collected: FutureResult
[10:19:59.992] result() for ClusterFuture ... done
[10:19:59.992] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:59.992] - nx: 2
[10:19:59.992] - relay: TRUE
[10:19:59.992] - stdout: TRUE
[10:19:59.992] - signal: TRUE
[10:19:59.992] - resignal: FALSE
[10:19:59.992] - force: TRUE
[10:19:59.992] - relayed: [n=2] FALSE, FALSE
[10:19:59.992] - queued futures: [n=2] FALSE, FALSE
[10:19:59.992]  - until=1
[10:19:59.992]  - relaying element #1
[10:19:59.993] result() for ClusterFuture ...
[10:19:59.993] - result already collected: FutureResult
[10:19:59.993] result() for ClusterFuture ... done
[10:19:59.993] result() for ClusterFuture ...
[10:19:59.993] - result already collected: FutureResult
[10:19:59.993] result() for ClusterFuture ... done
[10:19:59.993] result() for ClusterFuture ...
[10:19:59.993] - result already collected: FutureResult
[10:19:59.993] result() for ClusterFuture ... done
[10:19:59.993] result() for ClusterFuture ...
[10:19:59.993] - result already collected: FutureResult
[10:19:59.993] result() for ClusterFuture ... done
[10:19:59.993] - relayed: [n=2] TRUE, FALSE
[10:19:59.994] - queued futures: [n=2] TRUE, FALSE
[10:19:59.994] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:59.994]  length: 1 (resolved future 1)
[10:20:00.019] receiveMessageFromWorker() for ClusterFuture ...
[10:20:00.019] - Validating connection of MultisessionFuture
[10:20:00.020] - received message: FutureResult
[10:20:00.020] - Received FutureResult
[10:20:00.020] - Erased future from FutureRegistry
[10:20:00.020] result() for ClusterFuture ...
[10:20:00.020] - result already collected: FutureResult
[10:20:00.020] result() for ClusterFuture ... done
[10:20:00.020] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:00.020] Future #2
[10:20:00.020] result() for ClusterFuture ...
[10:20:00.020] - result already collected: FutureResult
[10:20:00.020] result() for ClusterFuture ... done
[10:20:00.021] result() for ClusterFuture ...
[10:20:00.021] - result already collected: FutureResult
[10:20:00.021] result() for ClusterFuture ... done
[10:20:00.021] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:20:00.021] - nx: 2
[10:20:00.021] - relay: TRUE
[10:20:00.021] - stdout: TRUE
[10:20:00.021] - signal: TRUE
[10:20:00.021] - resignal: FALSE
[10:20:00.021] - force: TRUE
[10:20:00.021] - relayed: [n=2] TRUE, FALSE
[10:20:00.021] - queued futures: [n=2] TRUE, FALSE
[10:20:00.021]  - until=2
[10:20:00.022]  - relaying element #2
[10:20:00.022] result() for ClusterFuture ...
[10:20:00.022] - result already collected: FutureResult
[10:20:00.022] result() for ClusterFuture ... done
[10:20:00.022] result() for ClusterFuture ...
[10:20:00.022] - result already collected: FutureResult
[10:20:00.022] result() for ClusterFuture ... done
[10:20:00.022] result() for ClusterFuture ...
[10:20:00.022] - result already collected: FutureResult
[10:20:00.022] result() for ClusterFuture ... done
[10:20:00.022] result() for ClusterFuture ...
[10:20:00.022] - result already collected: FutureResult
[10:20:00.022] result() for ClusterFuture ... done
[10:20:00.023] - relayed: [n=2] TRUE, TRUE
[10:20:00.023] - queued futures: [n=2] TRUE, TRUE
[10:20:00.023] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:20:00.023]  length: 0 (resolved future 2)
[10:20:00.023] Relaying remaining futures
[10:20:00.023] signalConditionsASAP(NULL, pos=0) ...
[10:20:00.023] - nx: 2
[10:20:00.023] - relay: TRUE
[10:20:00.023] - stdout: TRUE
[10:20:00.023] - signal: TRUE
[10:20:00.023] - resignal: FALSE
[10:20:00.023] - force: TRUE
[10:20:00.023] - relayed: [n=2] TRUE, TRUE
[10:20:00.024] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:00.024] - relayed: [n=2] TRUE, TRUE
[10:20:00.024] - queued futures: [n=2] TRUE, TRUE
[10:20:00.024] signalConditionsASAP(NULL, pos=0) ... done
[10:20:00.024] resolve() on list ... DONE
[10:20:00.024] result() for ClusterFuture ...
[10:20:00.024] - result already collected: FutureResult
[10:20:00.024] result() for ClusterFuture ... done
[10:20:00.024] result() for ClusterFuture ...
[10:20:00.024] - result already collected: FutureResult
[10:20:00.024] result() for ClusterFuture ... done
[10:20:00.024] result() for ClusterFuture ...
[10:20:00.025] - result already collected: FutureResult
[10:20:00.025] result() for ClusterFuture ... done
[10:20:00.025] result() for ClusterFuture ...
[10:20:00.025] - result already collected: FutureResult
[10:20:00.025] result() for ClusterFuture ... done
[10:20:00.025]  - Number of value chunks collected: 2
[10:20:00.025] Resolving 2 futures (chunks) ... DONE
[10:20:00.025] Reducing values from 2 chunks ...
[10:20:00.025]  - Number of values collected after concatenation: 3
[10:20:00.025]  - Number of values expected: 3
[10:20:00.025] Reducing values from 2 chunks ... DONE
[10:20:00.025] future_lapply() ... DONE
- exceptions ...
[10:20:00.026] future_lapply() ...
[10:20:00.029] Number of chunks: 2
[10:20:00.029] getGlobalsAndPackagesXApply() ...
[10:20:00.029]  - future.globals: TRUE
[10:20:00.029] getGlobalsAndPackages() ...
[10:20:00.029] Searching for globals...
[10:20:00.032] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:20:00.033] Searching for globals ... DONE
[10:20:00.033] Resolving globals: FALSE
[10:20:00.033] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[10:20:00.034] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[10:20:00.034] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:20:00.034] - packages: [1] ‘future.apply’
[10:20:00.034] getGlobalsAndPackages() ... DONE
[10:20:00.034]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:20:00.034]  - needed namespaces: [n=1] ‘future.apply’
[10:20:00.034] Finding globals ... DONE
[10:20:00.035]  - use_args: TRUE
[10:20:00.035]  - Getting '...' globals ...
[10:20:00.035] resolve() on list ...
[10:20:00.035]  recursive: 0
[10:20:00.035]  length: 1
[10:20:00.035]  elements: ‘...’
[10:20:00.035]  length: 0 (resolved future 1)
[10:20:00.035] resolve() on list ... DONE
[10:20:00.036]    - '...' content: [n=0] 
[10:20:00.036] List of 1
[10:20:00.036]  $ ...: list()
[10:20:00.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:00.036]  - attr(*, "where")=List of 1
[10:20:00.036]   ..$ ...:<environment: 0x55c6a1e44b10> 
[10:20:00.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:00.036]  - attr(*, "resolved")= logi TRUE
[10:20:00.036]  - attr(*, "total_size")= num NA
[10:20:00.038]  - Getting '...' globals ... DONE
[10:20:00.038] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:20:00.038] List of 8
[10:20:00.038]  $ ...future.FUN:function (x, ...)  
[10:20:00.038]  $ x_FUN        :function (x)  
[10:20:00.038]  $ times        : int 2
[10:20:00.038]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:20:00.038]  $ stop_if_not  :function (...)  
[10:20:00.038]  $ dim          : NULL
[10:20:00.038]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:20:00.038]  $ ...          : list()
[10:20:00.038]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:00.038]  - attr(*, "where")=List of 8
[10:20:00.038]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:00.038]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:20:00.038]   ..$ times        :<environment: R_EmptyEnv> 
[10:20:00.038]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:20:00.038]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:20:00.038]   ..$ dim          :<environment: R_EmptyEnv> 
[10:20:00.038]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:20:00.038]   ..$ ...          :<environment: 0x55c6a1e44b10> 
[10:20:00.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:00.038]  - attr(*, "resolved")= logi FALSE
[10:20:00.038]  - attr(*, "total_size")= num 23676
[10:20:00.043] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:20:00.043] getGlobalsAndPackagesXApply() ... DONE
[10:20:00.044] Number of futures (= number of chunks): 2
[10:20:00.044] Launching 2 futures (chunks) ...
[10:20:00.044] Chunk #1 of 2 ...
[10:20:00.044]  - Finding globals in 'X' for chunk #1 ...
[10:20:00.044] getGlobalsAndPackages() ...
[10:20:00.044] Searching for globals...
[10:20:00.044] 
[10:20:00.044] Searching for globals ... DONE
[10:20:00.044] - globals: [0] <none>
[10:20:00.044] getGlobalsAndPackages() ... DONE
[10:20:00.045]    + additional globals found: [n=0] 
[10:20:00.045]    + additional namespaces needed: [n=0] 
[10:20:00.045]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:00.045]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:00.045]  - seeds: <none>
[10:20:00.045]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:00.045] getGlobalsAndPackages() ...
[10:20:00.045] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:00.045] Resolving globals: FALSE
[10:20:00.045] Tweak future expression to call with '...' arguments ...
[10:20:00.045] {
[10:20:00.045]     do.call(function(...) {
[10:20:00.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:00.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:00.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:00.045]             on.exit(options(oopts), add = TRUE)
[10:20:00.045]         }
[10:20:00.045]         {
[10:20:00.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:00.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:00.045]                 ...future.FUN(...future.X_jj, ...)
[10:20:00.045]             })
[10:20:00.045]         }
[10:20:00.045]     }, args = future.call.arguments)
[10:20:00.045] }
[10:20:00.046] Tweak future expression to call with '...' arguments ... DONE
[10:20:00.046] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:00.046] - packages: [1] ‘future.apply’
[10:20:00.046] getGlobalsAndPackages() ... DONE
[10:20:00.047] run() for ‘Future’ ...
[10:20:00.047] - state: ‘created’
[10:20:00.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:00.060] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:00.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:00.061]   - Field: ‘node’
[10:20:00.061]   - Field: ‘label’
[10:20:00.061]   - Field: ‘local’
[10:20:00.061]   - Field: ‘owner’
[10:20:00.061]   - Field: ‘envir’
[10:20:00.061]   - Field: ‘workers’
[10:20:00.061]   - Field: ‘packages’
[10:20:00.061]   - Field: ‘gc’
[10:20:00.061]   - Field: ‘conditions’
[10:20:00.061]   - Field: ‘persistent’
[10:20:00.062]   - Field: ‘expr’
[10:20:00.062]   - Field: ‘uuid’
[10:20:00.062]   - Field: ‘seed’
[10:20:00.062]   - Field: ‘version’
[10:20:00.062]   - Field: ‘result’
[10:20:00.062]   - Field: ‘asynchronous’
[10:20:00.062]   - Field: ‘calls’
[10:20:00.062]   - Field: ‘globals’
[10:20:00.062]   - Field: ‘stdout’
[10:20:00.062]   - Field: ‘earlySignal’
[10:20:00.062]   - Field: ‘lazy’
[10:20:00.062]   - Field: ‘state’
[10:20:00.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:00.063] - Launch lazy future ...
[10:20:00.063] Packages needed by the future expression (n = 1): ‘future.apply’
[10:20:00.063] Packages needed by future strategies (n = 0): <none>
[10:20:00.063] {
[10:20:00.063]     {
[10:20:00.063]         {
[10:20:00.063]             ...future.startTime <- base::Sys.time()
[10:20:00.063]             {
[10:20:00.063]                 {
[10:20:00.063]                   {
[10:20:00.063]                     {
[10:20:00.063]                       {
[10:20:00.063]                         base::local({
[10:20:00.063]                           has_future <- base::requireNamespace("future", 
[10:20:00.063]                             quietly = TRUE)
[10:20:00.063]                           if (has_future) {
[10:20:00.063]                             ns <- base::getNamespace("future")
[10:20:00.063]                             version <- ns[[".package"]][["version"]]
[10:20:00.063]                             if (is.null(version)) 
[10:20:00.063]                               version <- utils::packageVersion("future")
[10:20:00.063]                           }
[10:20:00.063]                           else {
[10:20:00.063]                             version <- NULL
[10:20:00.063]                           }
[10:20:00.063]                           if (!has_future || version < "1.8.0") {
[10:20:00.063]                             info <- base::c(r_version = base::gsub("R version ", 
[10:20:00.063]                               "", base::R.version$version.string), 
[10:20:00.063]                               platform = base::sprintf("%s (%s-bit)", 
[10:20:00.063]                                 base::R.version$platform, 8 * 
[10:20:00.063]                                   base::.Machine$sizeof.pointer), 
[10:20:00.063]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:00.063]                                 "release", "version")], collapse = " "), 
[10:20:00.063]                               hostname = base::Sys.info()[["nodename"]])
[10:20:00.063]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:20:00.063]                               info)
[10:20:00.063]                             info <- base::paste(info, collapse = "; ")
[10:20:00.063]                             if (!has_future) {
[10:20:00.063]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:00.063]                                 info)
[10:20:00.063]                             }
[10:20:00.063]                             else {
[10:20:00.063]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:00.063]                                 info, version)
[10:20:00.063]                             }
[10:20:00.063]                             base::stop(msg)
[10:20:00.063]                           }
[10:20:00.063]                         })
[10:20:00.063]                       }
[10:20:00.063]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:00.063]                       base::options(mc.cores = 1L)
[10:20:00.063]                     }
[10:20:00.063]                     base::local({
[10:20:00.063]                       for (pkg in "future.apply") {
[10:20:00.063]                         base::loadNamespace(pkg)
[10:20:00.063]                         base::library(pkg, character.only = TRUE)
[10:20:00.063]                       }
[10:20:00.063]                     })
[10:20:00.063]                   }
[10:20:00.063]                   ...future.strategy.old <- future::plan("list")
[10:20:00.063]                   options(future.plan = NULL)
[10:20:00.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:00.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:00.063]                 }
[10:20:00.063]                 ...future.workdir <- getwd()
[10:20:00.063]             }
[10:20:00.063]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:00.063]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:00.063]         }
[10:20:00.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:00.063]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:00.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:00.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:00.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:00.063]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:00.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:00.063]             base::names(...future.oldOptions))
[10:20:00.063]     }
[10:20:00.063]     if (FALSE) {
[10:20:00.063]     }
[10:20:00.063]     else {
[10:20:00.063]         if (TRUE) {
[10:20:00.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:00.063]                 open = "w")
[10:20:00.063]         }
[10:20:00.063]         else {
[10:20:00.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:00.063]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:00.063]         }
[10:20:00.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:00.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:00.063]             base::sink(type = "output", split = FALSE)
[10:20:00.063]             base::close(...future.stdout)
[10:20:00.063]         }, add = TRUE)
[10:20:00.063]     }
[10:20:00.063]     ...future.frame <- base::sys.nframe()
[10:20:00.063]     ...future.conditions <- base::list()
[10:20:00.063]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:00.063]     if (FALSE) {
[10:20:00.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:00.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:00.063]     }
[10:20:00.063]     ...future.result <- base::tryCatch({
[10:20:00.063]         base::withCallingHandlers({
[10:20:00.063]             ...future.value <- base::withVisible(base::local({
[10:20:00.063]                 ...future.makeSendCondition <- base::local({
[10:20:00.063]                   sendCondition <- NULL
[10:20:00.063]                   function(frame = 1L) {
[10:20:00.063]                     if (is.function(sendCondition)) 
[10:20:00.063]                       return(sendCondition)
[10:20:00.063]                     ns <- getNamespace("parallel")
[10:20:00.063]                     if (exists("sendData", mode = "function", 
[10:20:00.063]                       envir = ns)) {
[10:20:00.063]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:00.063]                         envir = ns)
[10:20:00.063]                       envir <- sys.frame(frame)
[10:20:00.063]                       master <- NULL
[10:20:00.063]                       while (!identical(envir, .GlobalEnv) && 
[10:20:00.063]                         !identical(envir, emptyenv())) {
[10:20:00.063]                         if (exists("master", mode = "list", envir = envir, 
[10:20:00.063]                           inherits = FALSE)) {
[10:20:00.063]                           master <- get("master", mode = "list", 
[10:20:00.063]                             envir = envir, inherits = FALSE)
[10:20:00.063]                           if (inherits(master, c("SOCKnode", 
[10:20:00.063]                             "SOCK0node"))) {
[10:20:00.063]                             sendCondition <<- function(cond) {
[10:20:00.063]                               data <- list(type = "VALUE", value = cond, 
[10:20:00.063]                                 success = TRUE)
[10:20:00.063]                               parallel_sendData(master, data)
[10:20:00.063]                             }
[10:20:00.063]                             return(sendCondition)
[10:20:00.063]                           }
[10:20:00.063]                         }
[10:20:00.063]                         frame <- frame + 1L
[10:20:00.063]                         envir <- sys.frame(frame)
[10:20:00.063]                       }
[10:20:00.063]                     }
[10:20:00.063]                     sendCondition <<- function(cond) NULL
[10:20:00.063]                   }
[10:20:00.063]                 })
[10:20:00.063]                 withCallingHandlers({
[10:20:00.063]                   {
[10:20:00.063]                     do.call(function(...) {
[10:20:00.063]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:00.063]                       if (!identical(...future.globals.maxSize.org, 
[10:20:00.063]                         ...future.globals.maxSize)) {
[10:20:00.063]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:00.063]                         on.exit(options(oopts), add = TRUE)
[10:20:00.063]                       }
[10:20:00.063]                       {
[10:20:00.063]                         lapply(seq_along(...future.elements_ii), 
[10:20:00.063]                           FUN = function(jj) {
[10:20:00.063]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:00.063]                             ...future.FUN(...future.X_jj, ...)
[10:20:00.063]                           })
[10:20:00.063]                       }
[10:20:00.063]                     }, args = future.call.arguments)
[10:20:00.063]                   }
[10:20:00.063]                 }, immediateCondition = function(cond) {
[10:20:00.063]                   sendCondition <- ...future.makeSendCondition()
[10:20:00.063]                   sendCondition(cond)
[10:20:00.063]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:00.063]                   {
[10:20:00.063]                     inherits <- base::inherits
[10:20:00.063]                     invokeRestart <- base::invokeRestart
[10:20:00.063]                     is.null <- base::is.null
[10:20:00.063]                     muffled <- FALSE
[10:20:00.063]                     if (inherits(cond, "message")) {
[10:20:00.063]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:00.063]                       if (muffled) 
[10:20:00.063]                         invokeRestart("muffleMessage")
[10:20:00.063]                     }
[10:20:00.063]                     else if (inherits(cond, "warning")) {
[10:20:00.063]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:00.063]                       if (muffled) 
[10:20:00.063]                         invokeRestart("muffleWarning")
[10:20:00.063]                     }
[10:20:00.063]                     else if (inherits(cond, "condition")) {
[10:20:00.063]                       if (!is.null(pattern)) {
[10:20:00.063]                         computeRestarts <- base::computeRestarts
[10:20:00.063]                         grepl <- base::grepl
[10:20:00.063]                         restarts <- computeRestarts(cond)
[10:20:00.063]                         for (restart in restarts) {
[10:20:00.063]                           name <- restart$name
[10:20:00.063]                           if (is.null(name)) 
[10:20:00.063]                             next
[10:20:00.063]                           if (!grepl(pattern, name)) 
[10:20:00.063]                             next
[10:20:00.063]                           invokeRestart(restart)
[10:20:00.063]                           muffled <- TRUE
[10:20:00.063]                           break
[10:20:00.063]                         }
[10:20:00.063]                       }
[10:20:00.063]                     }
[10:20:00.063]                     invisible(muffled)
[10:20:00.063]                   }
[10:20:00.063]                   muffleCondition(cond)
[10:20:00.063]                 })
[10:20:00.063]             }))
[10:20:00.063]             future::FutureResult(value = ...future.value$value, 
[10:20:00.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:00.063]                   ...future.rng), globalenv = if (FALSE) 
[10:20:00.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:00.063]                     ...future.globalenv.names))
[10:20:00.063]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:00.063]         }, condition = base::local({
[10:20:00.063]             c <- base::c
[10:20:00.063]             inherits <- base::inherits
[10:20:00.063]             invokeRestart <- base::invokeRestart
[10:20:00.063]             length <- base::length
[10:20:00.063]             list <- base::list
[10:20:00.063]             seq.int <- base::seq.int
[10:20:00.063]             signalCondition <- base::signalCondition
[10:20:00.063]             sys.calls <- base::sys.calls
[10:20:00.063]             `[[` <- base::`[[`
[10:20:00.063]             `+` <- base::`+`
[10:20:00.063]             `<<-` <- base::`<<-`
[10:20:00.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:00.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:00.063]                   3L)]
[10:20:00.063]             }
[10:20:00.063]             function(cond) {
[10:20:00.063]                 is_error <- inherits(cond, "error")
[10:20:00.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:00.063]                   NULL)
[10:20:00.063]                 if (is_error) {
[10:20:00.063]                   sessionInformation <- function() {
[10:20:00.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:00.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:00.063]                       search = base::search(), system = base::Sys.info())
[10:20:00.063]                   }
[10:20:00.063]                   ...future.conditions[[length(...future.conditions) + 
[10:20:00.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:00.063]                     cond$call), session = sessionInformation(), 
[10:20:00.063]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:00.063]                   signalCondition(cond)
[10:20:00.063]                 }
[10:20:00.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:00.063]                 "immediateCondition"))) {
[10:20:00.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:00.063]                   ...future.conditions[[length(...future.conditions) + 
[10:20:00.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:00.063]                   if (TRUE && !signal) {
[10:20:00.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:00.063]                     {
[10:20:00.063]                       inherits <- base::inherits
[10:20:00.063]                       invokeRestart <- base::invokeRestart
[10:20:00.063]                       is.null <- base::is.null
[10:20:00.063]                       muffled <- FALSE
[10:20:00.063]                       if (inherits(cond, "message")) {
[10:20:00.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:00.063]                         if (muffled) 
[10:20:00.063]                           invokeRestart("muffleMessage")
[10:20:00.063]                       }
[10:20:00.063]                       else if (inherits(cond, "warning")) {
[10:20:00.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:00.063]                         if (muffled) 
[10:20:00.063]                           invokeRestart("muffleWarning")
[10:20:00.063]                       }
[10:20:00.063]                       else if (inherits(cond, "condition")) {
[10:20:00.063]                         if (!is.null(pattern)) {
[10:20:00.063]                           computeRestarts <- base::computeRestarts
[10:20:00.063]                           grepl <- base::grepl
[10:20:00.063]                           restarts <- computeRestarts(cond)
[10:20:00.063]                           for (restart in restarts) {
[10:20:00.063]                             name <- restart$name
[10:20:00.063]                             if (is.null(name)) 
[10:20:00.063]                               next
[10:20:00.063]                             if (!grepl(pattern, name)) 
[10:20:00.063]                               next
[10:20:00.063]                             invokeRestart(restart)
[10:20:00.063]                             muffled <- TRUE
[10:20:00.063]                             break
[10:20:00.063]                           }
[10:20:00.063]                         }
[10:20:00.063]                       }
[10:20:00.063]                       invisible(muffled)
[10:20:00.063]                     }
[10:20:00.063]                     muffleCondition(cond, pattern = "^muffle")
[10:20:00.063]                   }
[10:20:00.063]                 }
[10:20:00.063]                 else {
[10:20:00.063]                   if (TRUE) {
[10:20:00.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:00.063]                     {
[10:20:00.063]                       inherits <- base::inherits
[10:20:00.063]                       invokeRestart <- base::invokeRestart
[10:20:00.063]                       is.null <- base::is.null
[10:20:00.063]                       muffled <- FALSE
[10:20:00.063]                       if (inherits(cond, "message")) {
[10:20:00.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:00.063]                         if (muffled) 
[10:20:00.063]                           invokeRestart("muffleMessage")
[10:20:00.063]                       }
[10:20:00.063]                       else if (inherits(cond, "warning")) {
[10:20:00.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:00.063]                         if (muffled) 
[10:20:00.063]                           invokeRestart("muffleWarning")
[10:20:00.063]                       }
[10:20:00.063]                       else if (inherits(cond, "condition")) {
[10:20:00.063]                         if (!is.null(pattern)) {
[10:20:00.063]                           computeRestarts <- base::computeRestarts
[10:20:00.063]                           grepl <- base::grepl
[10:20:00.063]                           restarts <- computeRestarts(cond)
[10:20:00.063]                           for (restart in restarts) {
[10:20:00.063]                             name <- restart$name
[10:20:00.063]                             if (is.null(name)) 
[10:20:00.063]                               next
[10:20:00.063]                             if (!grepl(pattern, name)) 
[10:20:00.063]                               next
[10:20:00.063]                             invokeRestart(restart)
[10:20:00.063]                             muffled <- TRUE
[10:20:00.063]                             break
[10:20:00.063]                           }
[10:20:00.063]                         }
[10:20:00.063]                       }
[10:20:00.063]                       invisible(muffled)
[10:20:00.063]                     }
[10:20:00.063]                     muffleCondition(cond, pattern = "^muffle")
[10:20:00.063]                   }
[10:20:00.063]                 }
[10:20:00.063]             }
[10:20:00.063]         }))
[10:20:00.063]     }, error = function(ex) {
[10:20:00.063]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:00.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:00.063]                 ...future.rng), started = ...future.startTime, 
[10:20:00.063]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:00.063]             version = "1.8"), class = "FutureResult")
[10:20:00.063]     }, finally = {
[10:20:00.063]         if (!identical(...future.workdir, getwd())) 
[10:20:00.063]             setwd(...future.workdir)
[10:20:00.063]         {
[10:20:00.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:00.063]                 ...future.oldOptions$nwarnings <- NULL
[10:20:00.063]             }
[10:20:00.063]             base::options(...future.oldOptions)
[10:20:00.063]             if (.Platform$OS.type == "windows") {
[10:20:00.063]                 old_names <- names(...future.oldEnvVars)
[10:20:00.063]                 envs <- base::Sys.getenv()
[10:20:00.063]                 names <- names(envs)
[10:20:00.063]                 common <- intersect(names, old_names)
[10:20:00.063]                 added <- setdiff(names, old_names)
[10:20:00.063]                 removed <- setdiff(old_names, names)
[10:20:00.063]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:00.063]                   envs[common]]
[10:20:00.063]                 NAMES <- toupper(changed)
[10:20:00.063]                 args <- list()
[10:20:00.063]                 for (kk in seq_along(NAMES)) {
[10:20:00.063]                   name <- changed[[kk]]
[10:20:00.063]                   NAME <- NAMES[[kk]]
[10:20:00.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:00.063]                     next
[10:20:00.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:00.063]                 }
[10:20:00.063]                 NAMES <- toupper(added)
[10:20:00.063]                 for (kk in seq_along(NAMES)) {
[10:20:00.063]                   name <- added[[kk]]
[10:20:00.063]                   NAME <- NAMES[[kk]]
[10:20:00.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:00.063]                     next
[10:20:00.063]                   args[[name]] <- ""
[10:20:00.063]                 }
[10:20:00.063]                 NAMES <- toupper(removed)
[10:20:00.063]                 for (kk in seq_along(NAMES)) {
[10:20:00.063]                   name <- removed[[kk]]
[10:20:00.063]                   NAME <- NAMES[[kk]]
[10:20:00.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:00.063]                     next
[10:20:00.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:00.063]                 }
[10:20:00.063]                 if (length(args) > 0) 
[10:20:00.063]                   base::do.call(base::Sys.setenv, args = args)
[10:20:00.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:00.063]             }
[10:20:00.063]             else {
[10:20:00.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:00.063]             }
[10:20:00.063]             {
[10:20:00.063]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:00.063]                   0L) {
[10:20:00.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:00.063]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:00.063]                   base::options(opts)
[10:20:00.063]                 }
[10:20:00.063]                 {
[10:20:00.063]                   {
[10:20:00.063]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:00.063]                     NULL
[10:20:00.063]                   }
[10:20:00.063]                   options(future.plan = NULL)
[10:20:00.063]                   if (is.na(NA_character_)) 
[10:20:00.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:00.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:00.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:00.063]                     .init = FALSE)
[10:20:00.063]                 }
[10:20:00.063]             }
[10:20:00.063]         }
[10:20:00.063]     })
[10:20:00.063]     if (TRUE) {
[10:20:00.063]         base::sink(type = "output", split = FALSE)
[10:20:00.063]         if (TRUE) {
[10:20:00.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:00.063]         }
[10:20:00.063]         else {
[10:20:00.063]             ...future.result["stdout"] <- base::list(NULL)
[10:20:00.063]         }
[10:20:00.063]         base::close(...future.stdout)
[10:20:00.063]         ...future.stdout <- NULL
[10:20:00.063]     }
[10:20:00.063]     ...future.result$conditions <- ...future.conditions
[10:20:00.063]     ...future.result$finished <- base::Sys.time()
[10:20:00.063]     ...future.result
[10:20:00.063] }
[10:20:00.066] Exporting 11 global objects (13.22 KiB) to cluster node #1 ...
[10:20:00.067] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #1 ...
[10:20:00.107] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #1 ... DONE
[10:20:00.108] Exporting ‘x_FUN’ (185 bytes) to cluster node #1 ...
[10:20:00.108] Exporting ‘x_FUN’ (185 bytes) to cluster node #1 ... DONE
[10:20:00.108] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[10:20:00.109] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[10:20:00.109] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[10:20:00.149] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[10:20:00.150] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[10:20:00.190] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[10:20:00.190] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[10:20:00.191] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[10:20:00.191] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[10:20:00.191] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[10:20:00.191] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:20:00.192] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:20:00.192] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[10:20:00.192] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[10:20:00.192] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:20:00.192] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:20:00.193] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:20:00.193] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:20:00.193] Exporting 11 global objects (13.22 KiB) to cluster node #1 ... DONE
[10:20:00.193] MultisessionFuture started
[10:20:00.193] - Launch lazy future ... done
[10:20:00.194] run() for ‘MultisessionFuture’ ... done
[10:20:00.194] Created future:
[10:20:00.194] MultisessionFuture:
[10:20:00.194] Label: ‘future_vapply-1’
[10:20:00.194] Expression:
[10:20:00.194] {
[10:20:00.194]     do.call(function(...) {
[10:20:00.194]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:00.194]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:00.194]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:00.194]             on.exit(options(oopts), add = TRUE)
[10:20:00.194]         }
[10:20:00.194]         {
[10:20:00.194]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:00.194]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:00.194]                 ...future.FUN(...future.X_jj, ...)
[10:20:00.194]             })
[10:20:00.194]         }
[10:20:00.194]     }, args = future.call.arguments)
[10:20:00.194] }
[10:20:00.194] Lazy evaluation: FALSE
[10:20:00.194] Asynchronous evaluation: TRUE
[10:20:00.194] Local evaluation: TRUE
[10:20:00.194] Environment: R_GlobalEnv
[10:20:00.194] Capture standard output: TRUE
[10:20:00.194] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:00.194] Globals: 11 objects totaling 13.00 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:20:00.194] Packages: 1 packages (‘future.apply’)
[10:20:00.194] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:00.194] Resolved: FALSE
[10:20:00.194] Value: <not collected>
[10:20:00.194] Conditions captured: <none>
[10:20:00.194] Early signaling: FALSE
[10:20:00.194] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:20:00.194] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:00.205] Chunk #1 of 2 ... DONE
[10:20:00.205] Chunk #2 of 2 ...
[10:20:00.206]  - Finding globals in 'X' for chunk #2 ...
[10:20:00.206] getGlobalsAndPackages() ...
[10:20:00.206] Searching for globals...
[10:20:00.206] 
[10:20:00.206] Searching for globals ... DONE
[10:20:00.206] - globals: [0] <none>
[10:20:00.206] getGlobalsAndPackages() ... DONE
[10:20:00.207]    + additional globals found: [n=0] 
[10:20:00.207]    + additional namespaces needed: [n=0] 
[10:20:00.207]  - Finding globals in 'X' for chunk #2 ... DONE
[10:20:00.207]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:00.207]  - seeds: <none>
[10:20:00.207]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:00.207] getGlobalsAndPackages() ...
[10:20:00.207] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:00.207] Resolving globals: FALSE
[10:20:00.207] Tweak future expression to call with '...' arguments ...
[10:20:00.208] {
[10:20:00.208]     do.call(function(...) {
[10:20:00.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:00.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:00.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:00.208]             on.exit(options(oopts), add = TRUE)
[10:20:00.208]         }
[10:20:00.208]         {
[10:20:00.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:00.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:00.208]                 ...future.FUN(...future.X_jj, ...)
[10:20:00.208]             })
[10:20:00.208]         }
[10:20:00.208]     }, args = future.call.arguments)
[10:20:00.208] }
[10:20:00.208] Tweak future expression to call with '...' arguments ... DONE
[10:20:00.208] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:00.208] - packages: [1] ‘future.apply’
[10:20:00.208] getGlobalsAndPackages() ... DONE
[10:20:00.209] run() for ‘Future’ ...
[10:20:00.209] - state: ‘created’
[10:20:00.209] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:00.223] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:00.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:00.223]   - Field: ‘node’
[10:20:00.223]   - Field: ‘label’
[10:20:00.223]   - Field: ‘local’
[10:20:00.223]   - Field: ‘owner’
[10:20:00.223]   - Field: ‘envir’
[10:20:00.223]   - Field: ‘workers’
[10:20:00.224]   - Field: ‘packages’
[10:20:00.224]   - Field: ‘gc’
[10:20:00.224]   - Field: ‘conditions’
[10:20:00.224]   - Field: ‘persistent’
[10:20:00.224]   - Field: ‘expr’
[10:20:00.224]   - Field: ‘uuid’
[10:20:00.224]   - Field: ‘seed’
[10:20:00.224]   - Field: ‘version’
[10:20:00.224]   - Field: ‘result’
[10:20:00.224]   - Field: ‘asynchronous’
[10:20:00.224]   - Field: ‘calls’
[10:20:00.224]   - Field: ‘globals’
[10:20:00.225]   - Field: ‘stdout’
[10:20:00.225]   - Field: ‘earlySignal’
[10:20:00.225]   - Field: ‘lazy’
[10:20:00.225]   - Field: ‘state’
[10:20:00.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:00.225] - Launch lazy future ...
[10:20:00.225] Packages needed by the future expression (n = 1): ‘future.apply’
[10:20:00.225] Packages needed by future strategies (n = 0): <none>
[10:20:00.226] {
[10:20:00.226]     {
[10:20:00.226]         {
[10:20:00.226]             ...future.startTime <- base::Sys.time()
[10:20:00.226]             {
[10:20:00.226]                 {
[10:20:00.226]                   {
[10:20:00.226]                     {
[10:20:00.226]                       {
[10:20:00.226]                         base::local({
[10:20:00.226]                           has_future <- base::requireNamespace("future", 
[10:20:00.226]                             quietly = TRUE)
[10:20:00.226]                           if (has_future) {
[10:20:00.226]                             ns <- base::getNamespace("future")
[10:20:00.226]                             version <- ns[[".package"]][["version"]]
[10:20:00.226]                             if (is.null(version)) 
[10:20:00.226]                               version <- utils::packageVersion("future")
[10:20:00.226]                           }
[10:20:00.226]                           else {
[10:20:00.226]                             version <- NULL
[10:20:00.226]                           }
[10:20:00.226]                           if (!has_future || version < "1.8.0") {
[10:20:00.226]                             info <- base::c(r_version = base::gsub("R version ", 
[10:20:00.226]                               "", base::R.version$version.string), 
[10:20:00.226]                               platform = base::sprintf("%s (%s-bit)", 
[10:20:00.226]                                 base::R.version$platform, 8 * 
[10:20:00.226]                                   base::.Machine$sizeof.pointer), 
[10:20:00.226]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:00.226]                                 "release", "version")], collapse = " "), 
[10:20:00.226]                               hostname = base::Sys.info()[["nodename"]])
[10:20:00.226]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:20:00.226]                               info)
[10:20:00.226]                             info <- base::paste(info, collapse = "; ")
[10:20:00.226]                             if (!has_future) {
[10:20:00.226]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:00.226]                                 info)
[10:20:00.226]                             }
[10:20:00.226]                             else {
[10:20:00.226]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:00.226]                                 info, version)
[10:20:00.226]                             }
[10:20:00.226]                             base::stop(msg)
[10:20:00.226]                           }
[10:20:00.226]                         })
[10:20:00.226]                       }
[10:20:00.226]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:00.226]                       base::options(mc.cores = 1L)
[10:20:00.226]                     }
[10:20:00.226]                     base::local({
[10:20:00.226]                       for (pkg in "future.apply") {
[10:20:00.226]                         base::loadNamespace(pkg)
[10:20:00.226]                         base::library(pkg, character.only = TRUE)
[10:20:00.226]                       }
[10:20:00.226]                     })
[10:20:00.226]                   }
[10:20:00.226]                   ...future.strategy.old <- future::plan("list")
[10:20:00.226]                   options(future.plan = NULL)
[10:20:00.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:00.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:00.226]                 }
[10:20:00.226]                 ...future.workdir <- getwd()
[10:20:00.226]             }
[10:20:00.226]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:00.226]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:00.226]         }
[10:20:00.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:00.226]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:00.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:00.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:00.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:00.226]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:00.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:00.226]             base::names(...future.oldOptions))
[10:20:00.226]     }
[10:20:00.226]     if (FALSE) {
[10:20:00.226]     }
[10:20:00.226]     else {
[10:20:00.226]         if (TRUE) {
[10:20:00.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:00.226]                 open = "w")
[10:20:00.226]         }
[10:20:00.226]         else {
[10:20:00.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:00.226]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:00.226]         }
[10:20:00.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:00.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:00.226]             base::sink(type = "output", split = FALSE)
[10:20:00.226]             base::close(...future.stdout)
[10:20:00.226]         }, add = TRUE)
[10:20:00.226]     }
[10:20:00.226]     ...future.frame <- base::sys.nframe()
[10:20:00.226]     ...future.conditions <- base::list()
[10:20:00.226]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:00.226]     if (FALSE) {
[10:20:00.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:00.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:00.226]     }
[10:20:00.226]     ...future.result <- base::tryCatch({
[10:20:00.226]         base::withCallingHandlers({
[10:20:00.226]             ...future.value <- base::withVisible(base::local({
[10:20:00.226]                 ...future.makeSendCondition <- base::local({
[10:20:00.226]                   sendCondition <- NULL
[10:20:00.226]                   function(frame = 1L) {
[10:20:00.226]                     if (is.function(sendCondition)) 
[10:20:00.226]                       return(sendCondition)
[10:20:00.226]                     ns <- getNamespace("parallel")
[10:20:00.226]                     if (exists("sendData", mode = "function", 
[10:20:00.226]                       envir = ns)) {
[10:20:00.226]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:00.226]                         envir = ns)
[10:20:00.226]                       envir <- sys.frame(frame)
[10:20:00.226]                       master <- NULL
[10:20:00.226]                       while (!identical(envir, .GlobalEnv) && 
[10:20:00.226]                         !identical(envir, emptyenv())) {
[10:20:00.226]                         if (exists("master", mode = "list", envir = envir, 
[10:20:00.226]                           inherits = FALSE)) {
[10:20:00.226]                           master <- get("master", mode = "list", 
[10:20:00.226]                             envir = envir, inherits = FALSE)
[10:20:00.226]                           if (inherits(master, c("SOCKnode", 
[10:20:00.226]                             "SOCK0node"))) {
[10:20:00.226]                             sendCondition <<- function(cond) {
[10:20:00.226]                               data <- list(type = "VALUE", value = cond, 
[10:20:00.226]                                 success = TRUE)
[10:20:00.226]                               parallel_sendData(master, data)
[10:20:00.226]                             }
[10:20:00.226]                             return(sendCondition)
[10:20:00.226]                           }
[10:20:00.226]                         }
[10:20:00.226]                         frame <- frame + 1L
[10:20:00.226]                         envir <- sys.frame(frame)
[10:20:00.226]                       }
[10:20:00.226]                     }
[10:20:00.226]                     sendCondition <<- function(cond) NULL
[10:20:00.226]                   }
[10:20:00.226]                 })
[10:20:00.226]                 withCallingHandlers({
[10:20:00.226]                   {
[10:20:00.226]                     do.call(function(...) {
[10:20:00.226]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:00.226]                       if (!identical(...future.globals.maxSize.org, 
[10:20:00.226]                         ...future.globals.maxSize)) {
[10:20:00.226]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:00.226]                         on.exit(options(oopts), add = TRUE)
[10:20:00.226]                       }
[10:20:00.226]                       {
[10:20:00.226]                         lapply(seq_along(...future.elements_ii), 
[10:20:00.226]                           FUN = function(jj) {
[10:20:00.226]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:00.226]                             ...future.FUN(...future.X_jj, ...)
[10:20:00.226]                           })
[10:20:00.226]                       }
[10:20:00.226]                     }, args = future.call.arguments)
[10:20:00.226]                   }
[10:20:00.226]                 }, immediateCondition = function(cond) {
[10:20:00.226]                   sendCondition <- ...future.makeSendCondition()
[10:20:00.226]                   sendCondition(cond)
[10:20:00.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:00.226]                   {
[10:20:00.226]                     inherits <- base::inherits
[10:20:00.226]                     invokeRestart <- base::invokeRestart
[10:20:00.226]                     is.null <- base::is.null
[10:20:00.226]                     muffled <- FALSE
[10:20:00.226]                     if (inherits(cond, "message")) {
[10:20:00.226]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:00.226]                       if (muffled) 
[10:20:00.226]                         invokeRestart("muffleMessage")
[10:20:00.226]                     }
[10:20:00.226]                     else if (inherits(cond, "warning")) {
[10:20:00.226]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:00.226]                       if (muffled) 
[10:20:00.226]                         invokeRestart("muffleWarning")
[10:20:00.226]                     }
[10:20:00.226]                     else if (inherits(cond, "condition")) {
[10:20:00.226]                       if (!is.null(pattern)) {
[10:20:00.226]                         computeRestarts <- base::computeRestarts
[10:20:00.226]                         grepl <- base::grepl
[10:20:00.226]                         restarts <- computeRestarts(cond)
[10:20:00.226]                         for (restart in restarts) {
[10:20:00.226]                           name <- restart$name
[10:20:00.226]                           if (is.null(name)) 
[10:20:00.226]                             next
[10:20:00.226]                           if (!grepl(pattern, name)) 
[10:20:00.226]                             next
[10:20:00.226]                           invokeRestart(restart)
[10:20:00.226]                           muffled <- TRUE
[10:20:00.226]                           break
[10:20:00.226]                         }
[10:20:00.226]                       }
[10:20:00.226]                     }
[10:20:00.226]                     invisible(muffled)
[10:20:00.226]                   }
[10:20:00.226]                   muffleCondition(cond)
[10:20:00.226]                 })
[10:20:00.226]             }))
[10:20:00.226]             future::FutureResult(value = ...future.value$value, 
[10:20:00.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:00.226]                   ...future.rng), globalenv = if (FALSE) 
[10:20:00.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:00.226]                     ...future.globalenv.names))
[10:20:00.226]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:00.226]         }, condition = base::local({
[10:20:00.226]             c <- base::c
[10:20:00.226]             inherits <- base::inherits
[10:20:00.226]             invokeRestart <- base::invokeRestart
[10:20:00.226]             length <- base::length
[10:20:00.226]             list <- base::list
[10:20:00.226]             seq.int <- base::seq.int
[10:20:00.226]             signalCondition <- base::signalCondition
[10:20:00.226]             sys.calls <- base::sys.calls
[10:20:00.226]             `[[` <- base::`[[`
[10:20:00.226]             `+` <- base::`+`
[10:20:00.226]             `<<-` <- base::`<<-`
[10:20:00.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:00.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:00.226]                   3L)]
[10:20:00.226]             }
[10:20:00.226]             function(cond) {
[10:20:00.226]                 is_error <- inherits(cond, "error")
[10:20:00.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:00.226]                   NULL)
[10:20:00.226]                 if (is_error) {
[10:20:00.226]                   sessionInformation <- function() {
[10:20:00.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:00.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:00.226]                       search = base::search(), system = base::Sys.info())
[10:20:00.226]                   }
[10:20:00.226]                   ...future.conditions[[length(...future.conditions) + 
[10:20:00.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:00.226]                     cond$call), session = sessionInformation(), 
[10:20:00.226]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:00.226]                   signalCondition(cond)
[10:20:00.226]                 }
[10:20:00.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:00.226]                 "immediateCondition"))) {
[10:20:00.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:00.226]                   ...future.conditions[[length(...future.conditions) + 
[10:20:00.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:00.226]                   if (TRUE && !signal) {
[10:20:00.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:00.226]                     {
[10:20:00.226]                       inherits <- base::inherits
[10:20:00.226]                       invokeRestart <- base::invokeRestart
[10:20:00.226]                       is.null <- base::is.null
[10:20:00.226]                       muffled <- FALSE
[10:20:00.226]                       if (inherits(cond, "message")) {
[10:20:00.226]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:00.226]                         if (muffled) 
[10:20:00.226]                           invokeRestart("muffleMessage")
[10:20:00.226]                       }
[10:20:00.226]                       else if (inherits(cond, "warning")) {
[10:20:00.226]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:00.226]                         if (muffled) 
[10:20:00.226]                           invokeRestart("muffleWarning")
[10:20:00.226]                       }
[10:20:00.226]                       else if (inherits(cond, "condition")) {
[10:20:00.226]                         if (!is.null(pattern)) {
[10:20:00.226]                           computeRestarts <- base::computeRestarts
[10:20:00.226]                           grepl <- base::grepl
[10:20:00.226]                           restarts <- computeRestarts(cond)
[10:20:00.226]                           for (restart in restarts) {
[10:20:00.226]                             name <- restart$name
[10:20:00.226]                             if (is.null(name)) 
[10:20:00.226]                               next
[10:20:00.226]                             if (!grepl(pattern, name)) 
[10:20:00.226]                               next
[10:20:00.226]                             invokeRestart(restart)
[10:20:00.226]                             muffled <- TRUE
[10:20:00.226]                             break
[10:20:00.226]                           }
[10:20:00.226]                         }
[10:20:00.226]                       }
[10:20:00.226]                       invisible(muffled)
[10:20:00.226]                     }
[10:20:00.226]                     muffleCondition(cond, pattern = "^muffle")
[10:20:00.226]                   }
[10:20:00.226]                 }
[10:20:00.226]                 else {
[10:20:00.226]                   if (TRUE) {
[10:20:00.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:00.226]                     {
[10:20:00.226]                       inherits <- base::inherits
[10:20:00.226]                       invokeRestart <- base::invokeRestart
[10:20:00.226]                       is.null <- base::is.null
[10:20:00.226]                       muffled <- FALSE
[10:20:00.226]                       if (inherits(cond, "message")) {
[10:20:00.226]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:00.226]                         if (muffled) 
[10:20:00.226]                           invokeRestart("muffleMessage")
[10:20:00.226]                       }
[10:20:00.226]                       else if (inherits(cond, "warning")) {
[10:20:00.226]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:00.226]                         if (muffled) 
[10:20:00.226]                           invokeRestart("muffleWarning")
[10:20:00.226]                       }
[10:20:00.226]                       else if (inherits(cond, "condition")) {
[10:20:00.226]                         if (!is.null(pattern)) {
[10:20:00.226]                           computeRestarts <- base::computeRestarts
[10:20:00.226]                           grepl <- base::grepl
[10:20:00.226]                           restarts <- computeRestarts(cond)
[10:20:00.226]                           for (restart in restarts) {
[10:20:00.226]                             name <- restart$name
[10:20:00.226]                             if (is.null(name)) 
[10:20:00.226]                               next
[10:20:00.226]                             if (!grepl(pattern, name)) 
[10:20:00.226]                               next
[10:20:00.226]                             invokeRestart(restart)
[10:20:00.226]                             muffled <- TRUE
[10:20:00.226]                             break
[10:20:00.226]                           }
[10:20:00.226]                         }
[10:20:00.226]                       }
[10:20:00.226]                       invisible(muffled)
[10:20:00.226]                     }
[10:20:00.226]                     muffleCondition(cond, pattern = "^muffle")
[10:20:00.226]                   }
[10:20:00.226]                 }
[10:20:00.226]             }
[10:20:00.226]         }))
[10:20:00.226]     }, error = function(ex) {
[10:20:00.226]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:00.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:00.226]                 ...future.rng), started = ...future.startTime, 
[10:20:00.226]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:00.226]             version = "1.8"), class = "FutureResult")
[10:20:00.226]     }, finally = {
[10:20:00.226]         if (!identical(...future.workdir, getwd())) 
[10:20:00.226]             setwd(...future.workdir)
[10:20:00.226]         {
[10:20:00.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:00.226]                 ...future.oldOptions$nwarnings <- NULL
[10:20:00.226]             }
[10:20:00.226]             base::options(...future.oldOptions)
[10:20:00.226]             if (.Platform$OS.type == "windows") {
[10:20:00.226]                 old_names <- names(...future.oldEnvVars)
[10:20:00.226]                 envs <- base::Sys.getenv()
[10:20:00.226]                 names <- names(envs)
[10:20:00.226]                 common <- intersect(names, old_names)
[10:20:00.226]                 added <- setdiff(names, old_names)
[10:20:00.226]                 removed <- setdiff(old_names, names)
[10:20:00.226]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:00.226]                   envs[common]]
[10:20:00.226]                 NAMES <- toupper(changed)
[10:20:00.226]                 args <- list()
[10:20:00.226]                 for (kk in seq_along(NAMES)) {
[10:20:00.226]                   name <- changed[[kk]]
[10:20:00.226]                   NAME <- NAMES[[kk]]
[10:20:00.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:00.226]                     next
[10:20:00.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:00.226]                 }
[10:20:00.226]                 NAMES <- toupper(added)
[10:20:00.226]                 for (kk in seq_along(NAMES)) {
[10:20:00.226]                   name <- added[[kk]]
[10:20:00.226]                   NAME <- NAMES[[kk]]
[10:20:00.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:00.226]                     next
[10:20:00.226]                   args[[name]] <- ""
[10:20:00.226]                 }
[10:20:00.226]                 NAMES <- toupper(removed)
[10:20:00.226]                 for (kk in seq_along(NAMES)) {
[10:20:00.226]                   name <- removed[[kk]]
[10:20:00.226]                   NAME <- NAMES[[kk]]
[10:20:00.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:00.226]                     next
[10:20:00.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:00.226]                 }
[10:20:00.226]                 if (length(args) > 0) 
[10:20:00.226]                   base::do.call(base::Sys.setenv, args = args)
[10:20:00.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:00.226]             }
[10:20:00.226]             else {
[10:20:00.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:00.226]             }
[10:20:00.226]             {
[10:20:00.226]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:00.226]                   0L) {
[10:20:00.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:00.226]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:00.226]                   base::options(opts)
[10:20:00.226]                 }
[10:20:00.226]                 {
[10:20:00.226]                   {
[10:20:00.226]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:00.226]                     NULL
[10:20:00.226]                   }
[10:20:00.226]                   options(future.plan = NULL)
[10:20:00.226]                   if (is.na(NA_character_)) 
[10:20:00.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:00.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:00.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:00.226]                     .init = FALSE)
[10:20:00.226]                 }
[10:20:00.226]             }
[10:20:00.226]         }
[10:20:00.226]     })
[10:20:00.226]     if (TRUE) {
[10:20:00.226]         base::sink(type = "output", split = FALSE)
[10:20:00.226]         if (TRUE) {
[10:20:00.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:00.226]         }
[10:20:00.226]         else {
[10:20:00.226]             ...future.result["stdout"] <- base::list(NULL)
[10:20:00.226]         }
[10:20:00.226]         base::close(...future.stdout)
[10:20:00.226]         ...future.stdout <- NULL
[10:20:00.226]     }
[10:20:00.226]     ...future.result$conditions <- ...future.conditions
[10:20:00.226]     ...future.result$finished <- base::Sys.time()
[10:20:00.226]     ...future.result
[10:20:00.226] }
[10:20:00.229] Exporting 11 global objects (13.23 KiB) to cluster node #2 ...
[10:20:00.229] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #2 ...
[10:20:00.270] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #2 ... DONE
[10:20:00.271] Exporting ‘x_FUN’ (185 bytes) to cluster node #2 ...
[10:20:00.271] Exporting ‘x_FUN’ (185 bytes) to cluster node #2 ... DONE
[10:20:00.271] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[10:20:00.272] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[10:20:00.272] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[10:20:00.312] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[10:20:00.313] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[10:20:00.353] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[10:20:00.353] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[10:20:00.354] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[10:20:00.354] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[10:20:00.354] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[10:20:00.355] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:20:00.355] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:20:00.355] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #2 ...
[10:20:00.355] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #2 ... DONE
[10:20:00.356] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:20:00.356] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:20:00.356] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:20:00.357] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:20:00.357] Exporting 11 global objects (13.23 KiB) to cluster node #2 ... DONE
[10:20:00.357] MultisessionFuture started
[10:20:00.357] - Launch lazy future ... done
[10:20:00.357] run() for ‘MultisessionFuture’ ... done
[10:20:00.358] Created future:
[10:20:00.358] MultisessionFuture:
[10:20:00.358] Label: ‘future_vapply-2’
[10:20:00.358] Expression:
[10:20:00.358] {
[10:20:00.358]     do.call(function(...) {
[10:20:00.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:00.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:00.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:00.358]             on.exit(options(oopts), add = TRUE)
[10:20:00.358]         }
[10:20:00.358]         {
[10:20:00.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:00.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:00.358]                 ...future.FUN(...future.X_jj, ...)
[10:20:00.358]             })
[10:20:00.358]         }
[10:20:00.358]     }, args = future.call.arguments)
[10:20:00.358] }
[10:20:00.358] Lazy evaluation: FALSE
[10:20:00.358] Asynchronous evaluation: TRUE
[10:20:00.358] Local evaluation: TRUE
[10:20:00.358] Environment: R_GlobalEnv
[10:20:00.358] Capture standard output: TRUE
[10:20:00.358] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:00.358] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[10:20:00.358] Packages: 1 packages (‘future.apply’)
[10:20:00.358] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:00.358] Resolved: FALSE
[10:20:00.358] Value: <not collected>
[10:20:00.358] Conditions captured: <none>
[10:20:00.358] Early signaling: FALSE
[10:20:00.358] Owner process: 64d6c2dd-9313-3b78-b674-3da6409a4293
[10:20:00.358] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:00.369] Chunk #2 of 2 ... DONE
[10:20:00.369] Launching 2 futures (chunks) ... DONE
[10:20:00.369] Resolving 2 futures (chunks) ...
[10:20:00.370] resolve() on list ...
[10:20:00.370]  recursive: 0
[10:20:00.370]  length: 2
[10:20:00.370] 
[10:20:00.370] receiveMessageFromWorker() for ClusterFuture ...
[10:20:00.370] - Validating connection of MultisessionFuture
[10:20:00.371] - received message: FutureResult
[10:20:00.371] - Received FutureResult
[10:20:00.371] - Erased future from FutureRegistry
[10:20:00.371] result() for ClusterFuture ...
[10:20:00.371] - result already collected: FutureResult
[10:20:00.371] result() for ClusterFuture ... done
[10:20:00.371] signalConditions() ...
[10:20:00.371]  - include = ‘immediateCondition’
[10:20:00.372]  - exclude = 
[10:20:00.372]  - resignal = FALSE
[10:20:00.372]  - Number of conditions: 1
[10:20:00.372] signalConditions() ... done
[10:20:00.372] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:00.372] Future #1
[10:20:00.372] result() for ClusterFuture ...
[10:20:00.372] - result already collected: FutureResult
[10:20:00.372] result() for ClusterFuture ... done
[10:20:00.372] result() for ClusterFuture ...
[10:20:00.372] - result already collected: FutureResult
[10:20:00.375] result() for ClusterFuture ... done
[10:20:00.375] signalConditions() ...
[10:20:00.375]  - include = ‘immediateCondition’
[10:20:00.375]  - exclude = 
[10:20:00.375]  - resignal = FALSE
[10:20:00.376]  - Number of conditions: 1
[10:20:00.376] signalConditions() ... done
[10:20:00.376] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:20:00.376] - nx: 2
[10:20:00.376] - relay: TRUE
[10:20:00.376] - stdout: TRUE
[10:20:00.376] - signal: TRUE
[10:20:00.376] - resignal: FALSE
[10:20:00.376] - force: TRUE
[10:20:00.376] - relayed: [n=2] FALSE, FALSE
[10:20:00.376] - queued futures: [n=2] FALSE, FALSE
[10:20:00.376]  - until=1
[10:20:00.376]  - relaying element #1
[10:20:00.377] result() for ClusterFuture ...
[10:20:00.377] - result already collected: FutureResult
[10:20:00.377] result() for ClusterFuture ... done
[10:20:00.377] result() for ClusterFuture ...
[10:20:00.377] - result already collected: FutureResult
[10:20:00.377] result() for ClusterFuture ... done
[10:20:00.377] signalConditions() ...
[10:20:00.377]  - include = ‘immediateCondition’
[10:20:00.377]  - exclude = 
[10:20:00.377]  - resignal = FALSE
[10:20:00.377]  - Number of conditions: 1
[10:20:00.377] signalConditions() ... done
[10:20:00.378] result() for ClusterFuture ...
[10:20:00.378] - result already collected: FutureResult
[10:20:00.378] result() for ClusterFuture ... done
[10:20:00.378] signalConditions() ...
[10:20:00.378]  - include = ‘immediateCondition’
[10:20:00.378]  - exclude = 
[10:20:00.378]  - resignal = FALSE
[10:20:00.378]  - Number of conditions: 1
[10:20:00.378] signalConditions() ... done
[10:20:00.378] result() for ClusterFuture ...
[10:20:00.378] - result already collected: FutureResult
[10:20:00.378] result() for ClusterFuture ... done
[10:20:00.378] signalConditions() ...
[10:20:00.379]  - include = ‘condition’
[10:20:00.379]  - exclude = ‘immediateCondition’
[10:20:00.379]  - resignal = TRUE
[10:20:00.379]  - Number of conditions: 1
[10:20:00.379]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:20:00.379] signalConditions() ... done
[10:20:00.379] - relayed: [n=2] FALSE, FALSE
[10:20:00.379] - queued futures: [n=2] TRUE, FALSE
[10:20:00.379] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:20:00.379] plan(): Setting new future strategy stack:
[10:20:00.379] List of future strategies:
[10:20:00.379] 1. sequential:
[10:20:00.379]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:00.379]    - tweaked: FALSE
[10:20:00.379]    - call: plan(sequential)
[10:20:00.380] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[10:20:00.381] plan(): Setting new future strategy stack:
[10:20:00.381] List of future strategies:
[10:20:00.381] 1. FutureStrategy:
[10:20:00.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:00.381]    - tweaked: FALSE
[10:20:00.381]    - call: future::plan(oplan)
[10:20:00.382] plan(): nbrOfWorkers() = 1
> 
